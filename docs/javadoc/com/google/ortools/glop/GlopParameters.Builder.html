<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.16) on Thu Sep 15 09:38:29 CEST 2022 -->
<title>GlopParameters.Builder (com.google.ortools:ortools-java 9.4.1874 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-09-15">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GlopParameters.Builder (com.google.ortools:ortools-java 9.4.1874 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":9,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":10,"i104":10,"i105":10,"i106":10,"i107":10,"i108":10,"i109":10,"i110":10,"i111":10,"i112":10,"i113":10,"i114":10,"i115":10,"i116":10,"i117":10,"i118":10,"i119":10,"i120":10,"i121":10,"i122":10,"i123":10,"i124":10,"i125":10,"i126":10,"i127":10,"i128":10,"i129":10,"i130":10,"i131":10,"i132":10,"i133":10,"i134":10,"i135":10,"i136":10,"i137":10,"i138":10,"i139":10,"i140":10,"i141":10,"i142":10,"i143":10,"i144":10,"i145":10,"i146":10,"i147":10,"i148":10,"i149":10,"i150":10,"i151":10,"i152":10,"i153":10,"i154":10,"i155":10,"i156":10,"i157":10,"i158":10,"i159":10,"i160":10,"i161":10,"i162":10,"i163":10,"i164":10,"i165":10,"i166":10,"i167":10,"i168":10,"i169":10,"i170":10,"i171":10,"i172":10,"i173":10,"i174":10,"i175":10,"i176":10,"i177":10,"i178":10,"i179":10,"i180":10,"i181":10,"i182":10,"i183":10,"i184":10,"i185":10,"i186":10,"i187":10,"i188":10,"i189":10,"i190":10,"i191":10,"i192":10,"i193":10,"i194":10,"i195":10,"i196":10,"i197":10,"i198":10,"i199":10,"i200":10,"i201":10,"i202":10,"i203":10,"i204":10,"i205":10,"i206":10,"i207":10,"i208":10,"i209":10,"i210":10,"i211":10,"i212":10,"i213":10,"i214":10,"i215":10,"i216":10,"i217":10,"i218":10,"i219":10,"i220":10,"i221":10,"i222":10,"i223":10,"i224":10,"i225":10,"i226":10,"i227":10,"i228":10,"i229":10,"i230":10,"i231":10,"i232":10,"i233":10,"i234":10,"i235":10,"i236":10,"i237":10,"i238":10,"i239":10,"i240":10,"i241":10,"i242":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GlopParameters.Builder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.google.ortools.glop</a></div>
<h2 title="Class GlopParameters.Builder" class="title">Class GlopParameters.Builder</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.google.protobuf.AbstractMessageLite.Builder</li>
<li>
<ul class="inheritance">
<li>com.google.protobuf.AbstractMessage.Builder&lt;BuilderType&gt;</li>
<li>
<ul class="inheritance">
<li>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</li>
<li>
<ul class="inheritance">
<li>com.google.ortools.glop.GlopParameters.Builder</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code>, <code>com.google.protobuf.Message.Builder</code>, <code>com.google.protobuf.MessageLite.Builder</code>, <code>com.google.protobuf.MessageLiteOrBuilder</code>, <code>com.google.protobuf.MessageOrBuilder</code>, <code>java.lang.Cloneable</code></dd>
</dl>
<dl>
<dt>Enclosing class:</dt>
<dd><a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a></dd>
</dl>
<hr>
<pre>public static final class <span class="typeNameLabel">GlopParameters.Builder</span>
extends com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;
implements <a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></pre>
<div class="block"><pre>
 next id = 69
 </pre>

 Protobuf type <code>operations_research.glop.GlopParameters</code></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor,java.lang.Object)">addRepeatedField</a></span>&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field,
                java.lang.Object&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#build()">build</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#buildPartial()">buildPartial</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clear()">clear</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearAllowSimplexAlgorithmChange()">clearAllowSimplexAlgorithmChange</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearBasisRefactorizationPeriod()">clearBasisRefactorizationPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearChangeStatusToImprecise()">clearChangeStatusToImprecise</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearCostScaling()">clearCostScaling</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearCrossoverBoundSnappingDistance()">clearCrossoverBoundSnappingDistance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDegenerateMinistepFactor()">clearDegenerateMinistepFactor</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDevexWeightsResetPeriod()">clearDevexWeightsResetPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDropTolerance()">clearDropTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDualFeasibilityTolerance()">clearDualFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDualizerThreshold()">clearDualizerThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDualSmallPivotThreshold()">clearDualSmallPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearDynamicallyAdjustRefactorizationPeriod()">clearDynamicallyAdjustRefactorizationPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearExploitSingletonColumnInInitialBasis()">clearExploitSingletonColumnInInitialBasis</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearFeasibilityRule()">clearFeasibilityRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearField(com.google.protobuf.Descriptors.FieldDescriptor)">clearField</a></span>&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearHarrisToleranceRatio()">clearHarrisToleranceRatio</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearInitialBasis()">clearInitialBasis</a></span>()</code></th>
<td class="colLast">
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearInitialConditionNumberThreshold()">clearInitialConditionNumberThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearInitializeDevexWithColumnNorms()">clearInitializeDevexWithColumnNorms</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearLogSearchProgress()">clearLogSearchProgress</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearLogToStdout()">clearLogToStdout</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearLuFactorizationPivotThreshold()">clearLuFactorizationPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMarkowitzSingularityThreshold()">clearMarkowitzSingularityThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMarkowitzZlatevParameter()">clearMarkowitzZlatevParameter</a></span>()</code></th>
<td class="colLast">
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMaxDeterministicTime()">clearMaxDeterministicTime</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMaxNumberOfIterations()">clearMaxNumberOfIterations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMaxNumberOfReoptimizations()">clearMaxNumberOfReoptimizations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMaxTimeInSeconds()">clearMaxTimeInSeconds</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMaxValidMagnitude()">clearMaxValidMagnitude</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearMinimumAcceptablePivot()">clearMinimumAcceptablePivot</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearNumOmpThreads()">clearNumOmpThreads</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearObjectiveLowerLimit()">clearObjectiveLowerLimit</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearObjectiveUpperLimit()">clearObjectiveUpperLimit</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearOneof(com.google.protobuf.Descriptors.OneofDescriptor)">clearOneof</a></span>&#8203;(com.google.protobuf.Descriptors.OneofDescriptor&nbsp;oneof)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearOptimizationRule()">clearOptimizationRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the optimization phase.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearPerturbCostsInDualSimplex()">clearPerturbCostsInDualSimplex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearPreprocessorZeroTolerance()">clearPreprocessorZeroTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearPrimalFeasibilityTolerance()">clearPrimalFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearProvideStrongOptimalGuarantee()">clearProvideStrongOptimalGuarantee</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearPushToVertex()">clearPushToVertex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearRandomSeed()">clearRandomSeed</a></span>()</code></th>
<td class="colLast">
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearRatioTestZeroThreshold()">clearRatioTestZeroThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During the primal simplex (resp.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearRecomputeEdgesNormThreshold()">clearRecomputeEdgesNormThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearRecomputeReducedCostsThreshold()">clearRecomputeReducedCostsThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearRefactorizationThreshold()">clearRefactorizationThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearRelativeCostPerturbation()">clearRelativeCostPerturbation</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearRelativeMaxCostPerturbation()">clearRelativeMaxCostPerturbation</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearScalingMethod()">clearScalingMethod</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearSmallPivotThreshold()">clearSmallPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearSolutionFeasibilityTolerance()">clearSolutionFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearSolveDualProblem()">clearSolveDualProblem</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearUseDedicatedDualFeasibilityAlgorithm()">clearUseDedicatedDualFeasibilityAlgorithm</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We have two possible dual phase I algorithms.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearUseDualSimplex()">clearUseDualSimplex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearUseImpliedFreePreprocessor()">clearUseImpliedFreePreprocessor</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearUseMiddleProductFormUpdate()">clearUseMiddleProductFormUpdate</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearUsePreprocessing()">clearUsePreprocessing</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearUseScaling()">clearUseScaling</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearUseTransposedMatrix()">clearUseTransposedMatrix</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clone()">clone</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAllowSimplexAlgorithmChange()">getAllowSimplexAlgorithmChange</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getBasisRefactorizationPeriod()">getBasisRefactorizationPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getChangeStatusToImprecise()">getChangeStatusToImprecise</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCostScaling()">getCostScaling</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCrossoverBoundSnappingDistance()">getCrossoverBoundSnappingDistance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDefaultInstanceForType()">getDefaultInstanceForType</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDegenerateMinistepFactor()">getDegenerateMinistepFactor</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>static com.google.protobuf.Descriptors.Descriptor</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDescriptor()">getDescriptor</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>com.google.protobuf.Descriptors.Descriptor</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDescriptorForType()">getDescriptorForType</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDevexWeightsResetPeriod()">getDevexWeightsResetPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDropTolerance()">getDropTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDualFeasibilityTolerance()">getDualFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDualizerThreshold()">getDualizerThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDualSmallPivotThreshold()">getDualSmallPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDynamicallyAdjustRefactorizationPeriod()">getDynamicallyAdjustRefactorizationPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getExploitSingletonColumnInInitialBasis()">getExploitSingletonColumnInInitialBasis</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFeasibilityRule()">getFeasibilityRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getHarrisToleranceRatio()">getHarrisToleranceRatio</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInitialBasis()">getInitialBasis</a></span>()</code></th>
<td class="colLast">
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInitialConditionNumberThreshold()">getInitialConditionNumberThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInitializeDevexWithColumnNorms()">getInitializeDevexWithColumnNorms</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLogSearchProgress()">getLogSearchProgress</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLogToStdout()">getLogToStdout</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLuFactorizationPivotThreshold()">getLuFactorizationPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMarkowitzSingularityThreshold()">getMarkowitzSingularityThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMarkowitzZlatevParameter()">getMarkowitzZlatevParameter</a></span>()</code></th>
<td class="colLast">
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxDeterministicTime()">getMaxDeterministicTime</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxNumberOfIterations()">getMaxNumberOfIterations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxNumberOfReoptimizations()">getMaxNumberOfReoptimizations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxTimeInSeconds()">getMaxTimeInSeconds</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxValidMagnitude()">getMaxValidMagnitude</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMinimumAcceptablePivot()">getMinimumAcceptablePivot</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNumOmpThreads()">getNumOmpThreads</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getObjectiveLowerLimit()">getObjectiveLowerLimit</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getObjectiveUpperLimit()">getObjectiveUpperLimit</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getOptimizationRule()">getOptimizationRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the optimization phase.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPerturbCostsInDualSimplex()">getPerturbCostsInDualSimplex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPreprocessorZeroTolerance()">getPreprocessorZeroTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPrimalFeasibilityTolerance()">getPrimalFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getProvideStrongOptimalGuarantee()">getProvideStrongOptimalGuarantee</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPushToVertex()">getPushToVertex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRandomSeed()">getRandomSeed</a></span>()</code></th>
<td class="colLast">
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRatioTestZeroThreshold()">getRatioTestZeroThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During the primal simplex (resp.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRecomputeEdgesNormThreshold()">getRecomputeEdgesNormThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRecomputeReducedCostsThreshold()">getRecomputeReducedCostsThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRefactorizationThreshold()">getRefactorizationThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRelativeCostPerturbation()">getRelativeCostPerturbation</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRelativeMaxCostPerturbation()">getRelativeMaxCostPerturbation</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getScalingMethod()">getScalingMethod</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSmallPivotThreshold()">getSmallPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSolutionFeasibilityTolerance()">getSolutionFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSolveDualProblem()">getSolveDualProblem</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUseDedicatedDualFeasibilityAlgorithm()">getUseDedicatedDualFeasibilityAlgorithm</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We have two possible dual phase I algorithms.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUseDualSimplex()">getUseDualSimplex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUseImpliedFreePreprocessor()">getUseImpliedFreePreprocessor</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUseMiddleProductFormUpdate()">getUseMiddleProductFormUpdate</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUsePreprocessing()">getUsePreprocessing</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUseScaling()">getUseScaling</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUseTransposedMatrix()">getUseTransposedMatrix</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasAllowSimplexAlgorithmChange()">hasAllowSimplexAlgorithmChange</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasBasisRefactorizationPeriod()">hasBasisRefactorizationPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasChangeStatusToImprecise()">hasChangeStatusToImprecise</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasCostScaling()">hasCostScaling</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasCrossoverBoundSnappingDistance()">hasCrossoverBoundSnappingDistance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDegenerateMinistepFactor()">hasDegenerateMinistepFactor</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDevexWeightsResetPeriod()">hasDevexWeightsResetPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDropTolerance()">hasDropTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDualFeasibilityTolerance()">hasDualFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDualizerThreshold()">hasDualizerThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDualSmallPivotThreshold()">hasDualSmallPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDynamicallyAdjustRefactorizationPeriod()">hasDynamicallyAdjustRefactorizationPeriod</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasExploitSingletonColumnInInitialBasis()">hasExploitSingletonColumnInInitialBasis</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasFeasibilityRule()">hasFeasibilityRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasHarrisToleranceRatio()">hasHarrisToleranceRatio</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasInitialBasis()">hasInitialBasis</a></span>()</code></th>
<td class="colLast">
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasInitialConditionNumberThreshold()">hasInitialConditionNumberThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasInitializeDevexWithColumnNorms()">hasInitializeDevexWithColumnNorms</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasLogSearchProgress()">hasLogSearchProgress</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasLogToStdout()">hasLogToStdout</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasLuFactorizationPivotThreshold()">hasLuFactorizationPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMarkowitzSingularityThreshold()">hasMarkowitzSingularityThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMarkowitzZlatevParameter()">hasMarkowitzZlatevParameter</a></span>()</code></th>
<td class="colLast">
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMaxDeterministicTime()">hasMaxDeterministicTime</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMaxNumberOfIterations()">hasMaxNumberOfIterations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMaxNumberOfReoptimizations()">hasMaxNumberOfReoptimizations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMaxTimeInSeconds()">hasMaxTimeInSeconds</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMaxValidMagnitude()">hasMaxValidMagnitude</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMinimumAcceptablePivot()">hasMinimumAcceptablePivot</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasNumOmpThreads()">hasNumOmpThreads</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasObjectiveLowerLimit()">hasObjectiveLowerLimit</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasObjectiveUpperLimit()">hasObjectiveUpperLimit</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasOptimizationRule()">hasOptimizationRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the optimization phase.</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasPerturbCostsInDualSimplex()">hasPerturbCostsInDualSimplex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasPreprocessorZeroTolerance()">hasPreprocessorZeroTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasPrimalFeasibilityTolerance()">hasPrimalFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasProvideStrongOptimalGuarantee()">hasProvideStrongOptimalGuarantee</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasPushToVertex()">hasPushToVertex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRandomSeed()">hasRandomSeed</a></span>()</code></th>
<td class="colLast">
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRatioTestZeroThreshold()">hasRatioTestZeroThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 During the primal simplex (resp.</div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRecomputeEdgesNormThreshold()">hasRecomputeEdgesNormThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRecomputeReducedCostsThreshold()">hasRecomputeReducedCostsThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRefactorizationThreshold()">hasRefactorizationThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRelativeCostPerturbation()">hasRelativeCostPerturbation</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRelativeMaxCostPerturbation()">hasRelativeMaxCostPerturbation</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasScalingMethod()">hasScalingMethod</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasSmallPivotThreshold()">hasSmallPivotThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasSolutionFeasibilityTolerance()">hasSolutionFeasibilityTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasSolveDualProblem()">hasSolveDualProblem</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUseDedicatedDualFeasibilityAlgorithm()">hasUseDedicatedDualFeasibilityAlgorithm</a></span>()</code></th>
<td class="colLast">
<div class="block">
 We have two possible dual phase I algorithms.</div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUseDualSimplex()">hasUseDualSimplex</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUseImpliedFreePreprocessor()">hasUseImpliedFreePreprocessor</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUseMiddleProductFormUpdate()">hasUseMiddleProductFormUpdate</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUsePreprocessing()">hasUsePreprocessing</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUseScaling()">hasUseScaling</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUseTransposedMatrix()">hasUseTransposedMatrix</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code>protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#internalGetFieldAccessorTable()">internalGetFieldAccessorTable</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInitialized()">isInitialized</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeFrom(com.google.ortools.glop.GlopParameters)">mergeFrom</a></span>&#8203;(<a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a>&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeFrom(com.google.protobuf.CodedInputStream,com.google.protobuf.ExtensionRegistryLite)">mergeFrom</a></span>&#8203;(com.google.protobuf.CodedInputStream&nbsp;input,
         com.google.protobuf.ExtensionRegistryLite&nbsp;extensionRegistry)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeFrom(com.google.protobuf.Message)">mergeFrom</a></span>&#8203;(com.google.protobuf.Message&nbsp;other)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeUnknownFields(com.google.protobuf.UnknownFieldSet)">mergeUnknownFields</a></span>&#8203;(com.google.protobuf.UnknownFieldSet&nbsp;unknownFields)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setAllowSimplexAlgorithmChange(boolean)">setAllowSimplexAlgorithmChange</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBasisRefactorizationPeriod(int)">setBasisRefactorizationPeriod</a></span>&#8203;(int&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setChangeStatusToImprecise(boolean)">setChangeStatusToImprecise</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setCostScaling(com.google.ortools.glop.GlopParameters.CostScalingAlgorithm)">setCostScaling</a></span>&#8203;(<a href="GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a>&nbsp;value)</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setCrossoverBoundSnappingDistance(double)">setCrossoverBoundSnappingDistance</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDegenerateMinistepFactor(double)">setDegenerateMinistepFactor</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDevexWeightsResetPeriod(int)">setDevexWeightsResetPeriod</a></span>&#8203;(int&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDropTolerance(double)">setDropTolerance</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDualFeasibilityTolerance(double)">setDualFeasibilityTolerance</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDualizerThreshold(double)">setDualizerThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDualSmallPivotThreshold(double)">setDualSmallPivotThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDynamicallyAdjustRefactorizationPeriod(boolean)">setDynamicallyAdjustRefactorizationPeriod</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setExploitSingletonColumnInInitialBasis(boolean)">setExploitSingletonColumnInInitialBasis</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setFeasibilityRule(com.google.ortools.glop.GlopParameters.PricingRule)">setFeasibilityRule</a></span>&#8203;(<a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setField(com.google.protobuf.Descriptors.FieldDescriptor,java.lang.Object)">setField</a></span>&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field,
        java.lang.Object&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setHarrisToleranceRatio(double)">setHarrisToleranceRatio</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setInitialBasis(com.google.ortools.glop.GlopParameters.InitialBasisHeuristic)">setInitialBasis</a></span>&#8203;(<a href="GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a>&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setInitialConditionNumberThreshold(double)">setInitialConditionNumberThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setInitializeDevexWithColumnNorms(boolean)">setInitializeDevexWithColumnNorms</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setLogSearchProgress(boolean)">setLogSearchProgress</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setLogToStdout(boolean)">setLogToStdout</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setLuFactorizationPivotThreshold(double)">setLuFactorizationPivotThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMarkowitzSingularityThreshold(double)">setMarkowitzSingularityThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMarkowitzZlatevParameter(int)">setMarkowitzZlatevParameter</a></span>&#8203;(int&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxDeterministicTime(double)">setMaxDeterministicTime</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxNumberOfIterations(long)">setMaxNumberOfIterations</a></span>&#8203;(long&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxNumberOfReoptimizations(double)">setMaxNumberOfReoptimizations</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxTimeInSeconds(double)">setMaxTimeInSeconds</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxValidMagnitude(double)">setMaxValidMagnitude</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMinimumAcceptablePivot(double)">setMinimumAcceptablePivot</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNumOmpThreads(int)">setNumOmpThreads</a></span>&#8203;(int&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</td>
</tr>
<tr id="i215" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setObjectiveLowerLimit(double)">setObjectiveLowerLimit</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</td>
</tr>
<tr id="i216" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setObjectiveUpperLimit(double)">setObjectiveUpperLimit</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</td>
</tr>
<tr id="i217" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setOptimizationRule(com.google.ortools.glop.GlopParameters.PricingRule)">setOptimizationRule</a></span>&#8203;(<a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 PricingRule to use during the optimization phase.</div>
</td>
</tr>
<tr id="i218" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPerturbCostsInDualSimplex(boolean)">setPerturbCostsInDualSimplex</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</td>
</tr>
<tr id="i219" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPreprocessorZeroTolerance(double)">setPreprocessorZeroTolerance</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</td>
</tr>
<tr id="i220" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPrimalFeasibilityTolerance(double)">setPrimalFeasibilityTolerance</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</td>
</tr>
<tr id="i221" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setProvideStrongOptimalGuarantee(boolean)">setProvideStrongOptimalGuarantee</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.</div>
</td>
</tr>
<tr id="i222" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPushToVertex(boolean)">setPushToVertex</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</td>
</tr>
<tr id="i223" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRandomSeed(int)">setRandomSeed</a></span>&#8203;(int&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i224" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRatioTestZeroThreshold(double)">setRatioTestZeroThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 During the primal simplex (resp.</div>
</td>
</tr>
<tr id="i225" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRecomputeEdgesNormThreshold(double)">setRecomputeEdgesNormThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</td>
</tr>
<tr id="i226" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRecomputeReducedCostsThreshold(double)">setRecomputeReducedCostsThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</td>
</tr>
<tr id="i227" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRefactorizationThreshold(double)">setRefactorizationThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].</div>
</td>
</tr>
<tr id="i228" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRelativeCostPerturbation(double)">setRelativeCostPerturbation</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);</div>
</td>
</tr>
<tr id="i229" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRelativeMaxCostPerturbation(double)">setRelativeMaxCostPerturbation</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i230" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor,int,java.lang.Object)">setRepeatedField</a></span>&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field,
                int&nbsp;index,
                java.lang.Object&nbsp;value)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i231" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setScalingMethod(com.google.ortools.glop.GlopParameters.ScalingAlgorithm)">setScalingMethod</a></span>&#8203;(<a href="GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a>&nbsp;value)</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</td>
</tr>
<tr id="i232" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setSmallPivotThreshold(double)">setSmallPivotThreshold</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</td>
</tr>
<tr id="i233" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setSolutionFeasibilityTolerance(double)">setSolutionFeasibilityTolerance</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</td>
</tr>
<tr id="i234" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setSolveDualProblem(com.google.ortools.glop.GlopParameters.SolverBehavior)">setSolveDualProblem</a></span>&#8203;(<a href="GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a>&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</td>
</tr>
<tr id="i235" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUnknownFields(com.google.protobuf.UnknownFieldSet)">setUnknownFields</a></span>&#8203;(com.google.protobuf.UnknownFieldSet&nbsp;unknownFields)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i236" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUseDedicatedDualFeasibilityAlgorithm(boolean)">setUseDedicatedDualFeasibilityAlgorithm</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 We have two possible dual phase I algorithms.</div>
</td>
</tr>
<tr id="i237" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUseDualSimplex(boolean)">setUseDualSimplex</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</td>
</tr>
<tr id="i238" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUseImpliedFreePreprocessor(boolean)">setUseImpliedFreePreprocessor</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</td>
</tr>
<tr id="i239" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUseMiddleProductFormUpdate(boolean)">setUseMiddleProductFormUpdate</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</td>
</tr>
<tr id="i240" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUsePreprocessing(boolean)">setUsePreprocessing</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</td>
</tr>
<tr id="i241" class="rowColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUseScaling(boolean)">setUseScaling</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</td>
</tr>
<tr id="i242" class="altColor">
<td class="colFirst"><code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUseTransposedMatrix(boolean)">setUseTransposedMatrix</a></span>&#8203;(boolean&nbsp;value)</code></th>
<td class="colLast">
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.google.protobuf.GeneratedMessageV3.Builder">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;com.google.protobuf.GeneratedMessageV3.Builder</h3>
<code>getAllFields, getField, getFieldBuilder, getOneofFieldDescriptor, getParentForChildren, getRepeatedField, getRepeatedFieldBuilder, getRepeatedFieldCount, getUnknownFields, hasField, hasOneof, internalGetMapField, internalGetMutableMapField, isClean, markClean, newBuilderForField, onBuilt, onChanged, setUnknownFieldsProto3</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.google.protobuf.AbstractMessage.Builder">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;com.google.protobuf.AbstractMessage.Builder</h3>
<code>findInitializationErrors, getInitializationErrorString, internalMergeFrom, mergeDelimitedFrom, mergeDelimitedFrom, mergeFrom, mergeFrom, mergeFrom, mergeFrom, mergeFrom, mergeFrom, mergeFrom, mergeFrom, mergeFrom, newUninitializedMessageException, toString</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.google.protobuf.AbstractMessageLite.Builder">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;com.google.protobuf.AbstractMessageLite.Builder</h3>
<code>addAll, addAll, mergeFrom, newUninitializedMessageException</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.google.protobuf.MessageLite.Builder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageLite.Builder</h3>
<code>mergeFrom</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.google.protobuf.MessageOrBuilder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageOrBuilder</h3>
<code>findInitializationErrors, getAllFields, getField, getInitializationErrorString, getOneofFieldDescriptor, getRepeatedField, getRepeatedFieldCount, getUnknownFields, hasField, hasOneof</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="getDescriptor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDescriptor</h4>
<pre class="methodSignature">public static final&nbsp;com.google.protobuf.Descriptors.Descriptor&nbsp;getDescriptor()</pre>
</li>
</ul>
<a id="internalGetFieldAccessorTable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>internalGetFieldAccessorTable</h4>
<pre class="methodSignature">protected&nbsp;com.google.protobuf.GeneratedMessageV3.FieldAccessorTable&nbsp;internalGetFieldAccessorTable()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>internalGetFieldAccessorTable</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="clear()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clear</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clear()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clear</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clear</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageLite.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>clear</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="getDescriptorForType()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDescriptorForType</h4>
<pre class="methodSignature">public&nbsp;com.google.protobuf.Descriptors.Descriptor&nbsp;getDescriptorForType()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getDescriptorForType</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getDescriptorForType</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageOrBuilder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>getDescriptorForType</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="getDefaultInstanceForType()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultInstanceForType</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a>&nbsp;getDefaultInstanceForType()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getDefaultInstanceForType</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageLiteOrBuilder</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getDefaultInstanceForType</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageOrBuilder</code></dd>
</dl>
</li>
</ul>
<a id="build()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>build</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a>&nbsp;build()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>build</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>build</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageLite.Builder</code></dd>
</dl>
</li>
</ul>
<a id="buildPartial()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildPartial</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a>&nbsp;buildPartial()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>buildPartial</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>buildPartial</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageLite.Builder</code></dd>
</dl>
</li>
</ul>
<a id="clone()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clone</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clone()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clone</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clone</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageLite.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>clone</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="setField(com.google.protobuf.Descriptors.FieldDescriptor,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setField</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setField&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field,
                                       java.lang.Object&nbsp;value)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setField</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>setField</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="clearField(com.google.protobuf.Descriptors.FieldDescriptor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearField</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearField&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clearField</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>clearField</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="clearOneof(com.google.protobuf.Descriptors.OneofDescriptor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearOneof</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearOneof&#8203;(com.google.protobuf.Descriptors.OneofDescriptor&nbsp;oneof)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clearOneof</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>clearOneof</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor,int,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRepeatedField</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRepeatedField&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field,
                                               int&nbsp;index,
                                               java.lang.Object&nbsp;value)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setRepeatedField</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>setRepeatedField</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addRepeatedField</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;addRepeatedField&#8203;(com.google.protobuf.Descriptors.FieldDescriptor&nbsp;field,
                                               java.lang.Object&nbsp;value)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>addRepeatedField</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>addRepeatedField</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="mergeFrom(com.google.protobuf.Message)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeFrom</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;mergeFrom&#8203;(com.google.protobuf.Message&nbsp;other)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>mergeFrom</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>mergeFrom</code>&nbsp;in class&nbsp;<code>com.google.protobuf.AbstractMessage.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="mergeFrom(com.google.ortools.glop.GlopParameters)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeFrom</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;mergeFrom&#8203;(<a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a>&nbsp;other)</pre>
</li>
</ul>
<a id="isInitialized()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isInitialized</h4>
<pre class="methodSignature">public final&nbsp;boolean&nbsp;isInitialized()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>isInitialized</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageLiteOrBuilder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>isInitialized</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="mergeFrom(com.google.protobuf.CodedInputStream,com.google.protobuf.ExtensionRegistryLite)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeFrom</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;mergeFrom&#8203;(com.google.protobuf.CodedInputStream&nbsp;input,
                                        com.google.protobuf.ExtensionRegistryLite&nbsp;extensionRegistry)
                                 throws java.io.IOException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>mergeFrom</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>mergeFrom</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.MessageLite.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>mergeFrom</code>&nbsp;in class&nbsp;<code>com.google.protobuf.AbstractMessage.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd>
</dl>
</li>
</ul>
<a id="hasScalingMethod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasScalingMethod</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasScalingMethod()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasScalingMethod()">hasScalingMethod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the scalingMethod field is set.</dd>
</dl>
</li>
</ul>
<a id="getScalingMethod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getScalingMethod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a>&nbsp;getScalingMethod()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getScalingMethod()">getScalingMethod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The scalingMethod.</dd>
</dl>
</li>
</ul>
<a id="setScalingMethod(com.google.ortools.glop.GlopParameters.ScalingAlgorithm)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setScalingMethod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setScalingMethod&#8203;(<a href="GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a>&nbsp;value)</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The scalingMethod to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearScalingMethod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearScalingMethod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearScalingMethod()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasFeasibilityRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityRule</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasFeasibilityRule()</pre>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasFeasibilityRule()">hasFeasibilityRule</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityRule field is set.</dd>
</dl>
</li>
</ul>
<a id="getFeasibilityRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityRule</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;getFeasibilityRule()</pre>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getFeasibilityRule()">getFeasibilityRule</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityRule.</dd>
</dl>
</li>
</ul>
<a id="setFeasibilityRule(com.google.ortools.glop.GlopParameters.PricingRule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFeasibilityRule</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setFeasibilityRule&#8203;(<a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;value)</pre>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The feasibilityRule to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearFeasibilityRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearFeasibilityRule</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearFeasibilityRule()</pre>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasOptimizationRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasOptimizationRule</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasOptimizationRule()</pre>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasOptimizationRule()">hasOptimizationRule</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the optimizationRule field is set.</dd>
</dl>
</li>
</ul>
<a id="getOptimizationRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimizationRule</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;getOptimizationRule()</pre>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getOptimizationRule()">getOptimizationRule</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The optimizationRule.</dd>
</dl>
</li>
</ul>
<a id="setOptimizationRule(com.google.ortools.glop.GlopParameters.PricingRule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOptimizationRule</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setOptimizationRule&#8203;(<a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;value)</pre>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The optimizationRule to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearOptimizationRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearOptimizationRule</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearOptimizationRule()</pre>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasRefactorizationThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRefactorizationThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRefactorizationThreshold()</pre>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasRefactorizationThreshold()">hasRefactorizationThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the refactorizationThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getRefactorizationThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRefactorizationThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getRefactorizationThreshold()</pre>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getRefactorizationThreshold()">getRefactorizationThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The refactorizationThreshold.</dd>
</dl>
</li>
</ul>
<a id="setRefactorizationThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRefactorizationThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRefactorizationThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The refactorizationThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearRefactorizationThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearRefactorizationThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearRefactorizationThreshold()</pre>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasRecomputeReducedCostsThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRecomputeReducedCostsThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRecomputeReducedCostsThreshold()</pre>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasRecomputeReducedCostsThreshold()">hasRecomputeReducedCostsThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the recomputeReducedCostsThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getRecomputeReducedCostsThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRecomputeReducedCostsThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getRecomputeReducedCostsThreshold()</pre>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getRecomputeReducedCostsThreshold()">getRecomputeReducedCostsThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The recomputeReducedCostsThreshold.</dd>
</dl>
</li>
</ul>
<a id="setRecomputeReducedCostsThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRecomputeReducedCostsThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRecomputeReducedCostsThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The recomputeReducedCostsThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearRecomputeReducedCostsThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearRecomputeReducedCostsThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearRecomputeReducedCostsThreshold()</pre>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasRecomputeEdgesNormThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRecomputeEdgesNormThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRecomputeEdgesNormThreshold()</pre>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasRecomputeEdgesNormThreshold()">hasRecomputeEdgesNormThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the recomputeEdgesNormThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getRecomputeEdgesNormThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRecomputeEdgesNormThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getRecomputeEdgesNormThreshold()</pre>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getRecomputeEdgesNormThreshold()">getRecomputeEdgesNormThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The recomputeEdgesNormThreshold.</dd>
</dl>
</li>
</ul>
<a id="setRecomputeEdgesNormThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRecomputeEdgesNormThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRecomputeEdgesNormThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The recomputeEdgesNormThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearRecomputeEdgesNormThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearRecomputeEdgesNormThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearRecomputeEdgesNormThreshold()</pre>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasPrimalFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPrimalFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasPrimalFeasibilityTolerance()</pre>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.
 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasPrimalFeasibilityTolerance()">hasPrimalFeasibilityTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the primalFeasibilityTolerance field is set.</dd>
</dl>
</li>
</ul>
<a id="getPrimalFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPrimalFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getPrimalFeasibilityTolerance()</pre>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.
 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getPrimalFeasibilityTolerance()">getPrimalFeasibilityTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The primalFeasibilityTolerance.</dd>
</dl>
</li>
</ul>
<a id="setPrimalFeasibilityTolerance(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPrimalFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setPrimalFeasibilityTolerance&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.
 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The primalFeasibilityTolerance to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearPrimalFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearPrimalFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearPrimalFeasibilityTolerance()</pre>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.
 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasDualFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDualFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasDualFeasibilityTolerance()</pre>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.
 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.
 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasDualFeasibilityTolerance()">hasDualFeasibilityTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dualFeasibilityTolerance field is set.</dd>
</dl>
</li>
</ul>
<a id="getDualFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDualFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getDualFeasibilityTolerance()</pre>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.
 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.
 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getDualFeasibilityTolerance()">getDualFeasibilityTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dualFeasibilityTolerance.</dd>
</dl>
</li>
</ul>
<a id="setDualFeasibilityTolerance(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDualFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setDualFeasibilityTolerance&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.
 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.
 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The dualFeasibilityTolerance to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearDualFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDualFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearDualFeasibilityTolerance()</pre>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.
 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.
 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasRatioTestZeroThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRatioTestZeroThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRatioTestZeroThreshold()</pre>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.
 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasRatioTestZeroThreshold()">hasRatioTestZeroThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the ratioTestZeroThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getRatioTestZeroThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRatioTestZeroThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getRatioTestZeroThreshold()</pre>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.
 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getRatioTestZeroThreshold()">getRatioTestZeroThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The ratioTestZeroThreshold.</dd>
</dl>
</li>
</ul>
<a id="setRatioTestZeroThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRatioTestZeroThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRatioTestZeroThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.
 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The ratioTestZeroThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearRatioTestZeroThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearRatioTestZeroThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearRatioTestZeroThreshold()</pre>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.
 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasHarrisToleranceRatio()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasHarrisToleranceRatio</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasHarrisToleranceRatio()</pre>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.
 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasHarrisToleranceRatio()">hasHarrisToleranceRatio</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the harrisToleranceRatio field is set.</dd>
</dl>
</li>
</ul>
<a id="getHarrisToleranceRatio()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHarrisToleranceRatio</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getHarrisToleranceRatio()</pre>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.
 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getHarrisToleranceRatio()">getHarrisToleranceRatio</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The harrisToleranceRatio.</dd>
</dl>
</li>
</ul>
<a id="setHarrisToleranceRatio(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setHarrisToleranceRatio</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setHarrisToleranceRatio&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.
 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The harrisToleranceRatio to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearHarrisToleranceRatio()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearHarrisToleranceRatio</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearHarrisToleranceRatio()</pre>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.
 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasSmallPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasSmallPivotThreshold()</pre>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasSmallPivotThreshold()">hasSmallPivotThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the smallPivotThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getSmallPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getSmallPivotThreshold()</pre>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getSmallPivotThreshold()">getSmallPivotThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The smallPivotThreshold.</dd>
</dl>
</li>
</ul>
<a id="setSmallPivotThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setSmallPivotThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The smallPivotThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearSmallPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearSmallPivotThreshold()</pre>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMinimumAcceptablePivot()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMinimumAcceptablePivot</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMinimumAcceptablePivot()</pre>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMinimumAcceptablePivot()">hasMinimumAcceptablePivot</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the minimumAcceptablePivot field is set.</dd>
</dl>
</li>
</ul>
<a id="getMinimumAcceptablePivot()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinimumAcceptablePivot</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getMinimumAcceptablePivot()</pre>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMinimumAcceptablePivot()">getMinimumAcceptablePivot</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The minimumAcceptablePivot.</dd>
</dl>
</li>
</ul>
<a id="setMinimumAcceptablePivot(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMinimumAcceptablePivot</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMinimumAcceptablePivot&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The minimumAcceptablePivot to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMinimumAcceptablePivot()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMinimumAcceptablePivot</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMinimumAcceptablePivot()</pre>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasDropTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDropTolerance</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasDropTolerance()</pre>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasDropTolerance()">hasDropTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dropTolerance field is set.</dd>
</dl>
</li>
</ul>
<a id="getDropTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDropTolerance</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getDropTolerance()</pre>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getDropTolerance()">getDropTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dropTolerance.</dd>
</dl>
</li>
</ul>
<a id="setDropTolerance(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDropTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setDropTolerance&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The dropTolerance to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearDropTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDropTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearDropTolerance()</pre>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasUseScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseScaling</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasUseScaling()</pre>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasUseScaling()">hasUseScaling</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useScaling field is set.</dd>
</dl>
</li>
</ul>
<a id="getUseScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseScaling</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getUseScaling()</pre>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getUseScaling()">getUseScaling</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useScaling.</dd>
</dl>
</li>
</ul>
<a id="setUseScaling(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseScaling</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUseScaling&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The useScaling to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearUseScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearUseScaling</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearUseScaling()</pre>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasCostScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCostScaling</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasCostScaling()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasCostScaling()">hasCostScaling</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the costScaling field is set.</dd>
</dl>
</li>
</ul>
<a id="getCostScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCostScaling</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a>&nbsp;getCostScaling()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getCostScaling()">getCostScaling</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The costScaling.</dd>
</dl>
</li>
</ul>
<a id="setCostScaling(com.google.ortools.glop.GlopParameters.CostScalingAlgorithm)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCostScaling</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setCostScaling&#8203;(<a href="GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a>&nbsp;value)</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The costScaling to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearCostScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearCostScaling</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearCostScaling()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasInitialBasis()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialBasis</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasInitialBasis()</pre>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasInitialBasis()">hasInitialBasis</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialBasis field is set.</dd>
</dl>
</li>
</ul>
<a id="getInitialBasis()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialBasis</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a>&nbsp;getInitialBasis()</pre>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getInitialBasis()">getInitialBasis</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialBasis.</dd>
</dl>
</li>
</ul>
<a id="setInitialBasis(com.google.ortools.glop.GlopParameters.InitialBasisHeuristic)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInitialBasis</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setInitialBasis&#8203;(<a href="GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a>&nbsp;value)</pre>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The initialBasis to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearInitialBasis()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearInitialBasis</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearInitialBasis()</pre>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasUseTransposedMatrix()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseTransposedMatrix</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasUseTransposedMatrix()</pre>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasUseTransposedMatrix()">hasUseTransposedMatrix</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useTransposedMatrix field is set.</dd>
</dl>
</li>
</ul>
<a id="getUseTransposedMatrix()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseTransposedMatrix</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getUseTransposedMatrix()</pre>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getUseTransposedMatrix()">getUseTransposedMatrix</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useTransposedMatrix.</dd>
</dl>
</li>
</ul>
<a id="setUseTransposedMatrix(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseTransposedMatrix</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUseTransposedMatrix&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The useTransposedMatrix to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearUseTransposedMatrix()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearUseTransposedMatrix</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearUseTransposedMatrix()</pre>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasBasisRefactorizationPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasBasisRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasBasisRefactorizationPeriod()</pre>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasBasisRefactorizationPeriod()">hasBasisRefactorizationPeriod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the basisRefactorizationPeriod field is set.</dd>
</dl>
</li>
</ul>
<a id="getBasisRefactorizationPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBasisRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getBasisRefactorizationPeriod()</pre>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getBasisRefactorizationPeriod()">getBasisRefactorizationPeriod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The basisRefactorizationPeriod.</dd>
</dl>
</li>
</ul>
<a id="setBasisRefactorizationPeriod(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBasisRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setBasisRefactorizationPeriod&#8203;(int&nbsp;value)</pre>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The basisRefactorizationPeriod to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearBasisRefactorizationPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearBasisRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearBasisRefactorizationPeriod()</pre>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasDynamicallyAdjustRefactorizationPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDynamicallyAdjustRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasDynamicallyAdjustRefactorizationPeriod()</pre>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasDynamicallyAdjustRefactorizationPeriod()">hasDynamicallyAdjustRefactorizationPeriod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dynamicallyAdjustRefactorizationPeriod field is set.</dd>
</dl>
</li>
</ul>
<a id="getDynamicallyAdjustRefactorizationPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDynamicallyAdjustRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getDynamicallyAdjustRefactorizationPeriod()</pre>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getDynamicallyAdjustRefactorizationPeriod()">getDynamicallyAdjustRefactorizationPeriod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dynamicallyAdjustRefactorizationPeriod.</dd>
</dl>
</li>
</ul>
<a id="setDynamicallyAdjustRefactorizationPeriod(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDynamicallyAdjustRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setDynamicallyAdjustRefactorizationPeriod&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The dynamicallyAdjustRefactorizationPeriod to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearDynamicallyAdjustRefactorizationPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDynamicallyAdjustRefactorizationPeriod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearDynamicallyAdjustRefactorizationPeriod()</pre>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasSolveDualProblem()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolveDualProblem</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasSolveDualProblem()</pre>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasSolveDualProblem()">hasSolveDualProblem</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the solveDualProblem field is set.</dd>
</dl>
</li>
</ul>
<a id="getSolveDualProblem()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSolveDualProblem</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a>&nbsp;getSolveDualProblem()</pre>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getSolveDualProblem()">getSolveDualProblem</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The solveDualProblem.</dd>
</dl>
</li>
</ul>
<a id="setSolveDualProblem(com.google.ortools.glop.GlopParameters.SolverBehavior)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSolveDualProblem</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setSolveDualProblem&#8203;(<a href="GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a>&nbsp;value)</pre>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The solveDualProblem to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearSolveDualProblem()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearSolveDualProblem</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearSolveDualProblem()</pre>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasDualizerThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDualizerThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasDualizerThreshold()</pre>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasDualizerThreshold()">hasDualizerThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dualizerThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getDualizerThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDualizerThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getDualizerThreshold()</pre>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getDualizerThreshold()">getDualizerThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dualizerThreshold.</dd>
</dl>
</li>
</ul>
<a id="setDualizerThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDualizerThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setDualizerThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The dualizerThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearDualizerThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDualizerThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearDualizerThreshold()</pre>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasSolutionFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolutionFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasSolutionFeasibilityTolerance()</pre>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.
 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasSolutionFeasibilityTolerance()">hasSolutionFeasibilityTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the solutionFeasibilityTolerance field is set.</dd>
</dl>
</li>
</ul>
<a id="getSolutionFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSolutionFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getSolutionFeasibilityTolerance()</pre>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.
 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getSolutionFeasibilityTolerance()">getSolutionFeasibilityTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The solutionFeasibilityTolerance.</dd>
</dl>
</li>
</ul>
<a id="setSolutionFeasibilityTolerance(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSolutionFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setSolutionFeasibilityTolerance&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.
 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The solutionFeasibilityTolerance to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearSolutionFeasibilityTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearSolutionFeasibilityTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearSolutionFeasibilityTolerance()</pre>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.
 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasProvideStrongOptimalGuarantee()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasProvideStrongOptimalGuarantee</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasProvideStrongOptimalGuarantee()</pre>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
   component of the objective function a bit, then the pair (primal values,
   dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
   defined in the comment for solution_feasibility_tolerance (*).
 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.
 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasProvideStrongOptimalGuarantee()">hasProvideStrongOptimalGuarantee</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the provideStrongOptimalGuarantee field is set.</dd>
</dl>
</li>
</ul>
<a id="getProvideStrongOptimalGuarantee()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProvideStrongOptimalGuarantee</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getProvideStrongOptimalGuarantee()</pre>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
   component of the objective function a bit, then the pair (primal values,
   dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
   defined in the comment for solution_feasibility_tolerance (*).
 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.
 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getProvideStrongOptimalGuarantee()">getProvideStrongOptimalGuarantee</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The provideStrongOptimalGuarantee.</dd>
</dl>
</li>
</ul>
<a id="setProvideStrongOptimalGuarantee(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setProvideStrongOptimalGuarantee</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setProvideStrongOptimalGuarantee&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
   component of the objective function a bit, then the pair (primal values,
   dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
   defined in the comment for solution_feasibility_tolerance (*).
 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.
 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The provideStrongOptimalGuarantee to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearProvideStrongOptimalGuarantee()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearProvideStrongOptimalGuarantee</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearProvideStrongOptimalGuarantee()</pre>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
   component of the objective function a bit, then the pair (primal values,
   dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
   defined in the comment for solution_feasibility_tolerance (*).
 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.
 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasChangeStatusToImprecise()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasChangeStatusToImprecise</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasChangeStatusToImprecise()</pre>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasChangeStatusToImprecise()">hasChangeStatusToImprecise</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the changeStatusToImprecise field is set.</dd>
</dl>
</li>
</ul>
<a id="getChangeStatusToImprecise()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getChangeStatusToImprecise</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getChangeStatusToImprecise()</pre>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getChangeStatusToImprecise()">getChangeStatusToImprecise</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The changeStatusToImprecise.</dd>
</dl>
</li>
</ul>
<a id="setChangeStatusToImprecise(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setChangeStatusToImprecise</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setChangeStatusToImprecise&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The changeStatusToImprecise to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearChangeStatusToImprecise()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearChangeStatusToImprecise</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearChangeStatusToImprecise()</pre>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMaxNumberOfReoptimizations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumberOfReoptimizations</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMaxNumberOfReoptimizations()</pre>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMaxNumberOfReoptimizations()">hasMaxNumberOfReoptimizations</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumberOfReoptimizations field is set.</dd>
</dl>
</li>
</ul>
<a id="getMaxNumberOfReoptimizations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumberOfReoptimizations</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getMaxNumberOfReoptimizations()</pre>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMaxNumberOfReoptimizations()">getMaxNumberOfReoptimizations</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumberOfReoptimizations.</dd>
</dl>
</li>
</ul>
<a id="setMaxNumberOfReoptimizations(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxNumberOfReoptimizations</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMaxNumberOfReoptimizations&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The maxNumberOfReoptimizations to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMaxNumberOfReoptimizations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMaxNumberOfReoptimizations</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMaxNumberOfReoptimizations()</pre>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasLuFactorizationPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLuFactorizationPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasLuFactorizationPivotThreshold()</pre>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasLuFactorizationPivotThreshold()">hasLuFactorizationPivotThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the luFactorizationPivotThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getLuFactorizationPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLuFactorizationPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getLuFactorizationPivotThreshold()</pre>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getLuFactorizationPivotThreshold()">getLuFactorizationPivotThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The luFactorizationPivotThreshold.</dd>
</dl>
</li>
</ul>
<a id="setLuFactorizationPivotThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLuFactorizationPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setLuFactorizationPivotThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The luFactorizationPivotThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearLuFactorizationPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearLuFactorizationPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearLuFactorizationPivotThreshold()</pre>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMaxTimeInSeconds()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxTimeInSeconds</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMaxTimeInSeconds()</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMaxTimeInSeconds()">hasMaxTimeInSeconds</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxTimeInSeconds field is set.</dd>
</dl>
</li>
</ul>
<a id="getMaxTimeInSeconds()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxTimeInSeconds</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getMaxTimeInSeconds()</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMaxTimeInSeconds()">getMaxTimeInSeconds</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxTimeInSeconds.</dd>
</dl>
</li>
</ul>
<a id="setMaxTimeInSeconds(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxTimeInSeconds</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMaxTimeInSeconds&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The maxTimeInSeconds to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMaxTimeInSeconds()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMaxTimeInSeconds</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMaxTimeInSeconds()</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMaxDeterministicTime()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxDeterministicTime</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMaxDeterministicTime()</pre>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).
 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMaxDeterministicTime()">hasMaxDeterministicTime</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxDeterministicTime field is set.</dd>
</dl>
</li>
</ul>
<a id="getMaxDeterministicTime()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxDeterministicTime</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getMaxDeterministicTime()</pre>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).
 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMaxDeterministicTime()">getMaxDeterministicTime</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxDeterministicTime.</dd>
</dl>
</li>
</ul>
<a id="setMaxDeterministicTime(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxDeterministicTime</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMaxDeterministicTime&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).
 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The maxDeterministicTime to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMaxDeterministicTime()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMaxDeterministicTime</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMaxDeterministicTime()</pre>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).
 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMaxNumberOfIterations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumberOfIterations</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMaxNumberOfIterations()</pre>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMaxNumberOfIterations()">hasMaxNumberOfIterations</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumberOfIterations field is set.</dd>
</dl>
</li>
</ul>
<a id="getMaxNumberOfIterations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumberOfIterations</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getMaxNumberOfIterations()</pre>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMaxNumberOfIterations()">getMaxNumberOfIterations</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumberOfIterations.</dd>
</dl>
</li>
</ul>
<a id="setMaxNumberOfIterations(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxNumberOfIterations</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMaxNumberOfIterations&#8203;(long&nbsp;value)</pre>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The maxNumberOfIterations to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMaxNumberOfIterations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMaxNumberOfIterations</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMaxNumberOfIterations()</pre>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMarkowitzZlatevParameter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMarkowitzZlatevParameter</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMarkowitzZlatevParameter()</pre>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMarkowitzZlatevParameter()">hasMarkowitzZlatevParameter</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the markowitzZlatevParameter field is set.</dd>
</dl>
</li>
</ul>
<a id="getMarkowitzZlatevParameter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMarkowitzZlatevParameter</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getMarkowitzZlatevParameter()</pre>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMarkowitzZlatevParameter()">getMarkowitzZlatevParameter</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The markowitzZlatevParameter.</dd>
</dl>
</li>
</ul>
<a id="setMarkowitzZlatevParameter(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMarkowitzZlatevParameter</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMarkowitzZlatevParameter&#8203;(int&nbsp;value)</pre>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The markowitzZlatevParameter to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMarkowitzZlatevParameter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMarkowitzZlatevParameter</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMarkowitzZlatevParameter()</pre>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMarkowitzSingularityThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMarkowitzSingularityThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMarkowitzSingularityThreshold()</pre>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMarkowitzSingularityThreshold()">hasMarkowitzSingularityThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the markowitzSingularityThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getMarkowitzSingularityThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMarkowitzSingularityThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getMarkowitzSingularityThreshold()</pre>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMarkowitzSingularityThreshold()">getMarkowitzSingularityThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The markowitzSingularityThreshold.</dd>
</dl>
</li>
</ul>
<a id="setMarkowitzSingularityThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMarkowitzSingularityThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMarkowitzSingularityThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The markowitzSingularityThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMarkowitzSingularityThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMarkowitzSingularityThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMarkowitzSingularityThreshold()</pre>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasUseDualSimplex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDualSimplex</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasUseDualSimplex()</pre>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasUseDualSimplex()">hasUseDualSimplex</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDualSimplex field is set.</dd>
</dl>
</li>
</ul>
<a id="getUseDualSimplex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDualSimplex</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getUseDualSimplex()</pre>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getUseDualSimplex()">getUseDualSimplex</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDualSimplex.</dd>
</dl>
</li>
</ul>
<a id="setUseDualSimplex(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseDualSimplex</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUseDualSimplex&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The useDualSimplex to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearUseDualSimplex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearUseDualSimplex</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearUseDualSimplex()</pre>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasAllowSimplexAlgorithmChange()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAllowSimplexAlgorithmChange</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasAllowSimplexAlgorithmChange()</pre>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasAllowSimplexAlgorithmChange()">hasAllowSimplexAlgorithmChange</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the allowSimplexAlgorithmChange field is set.</dd>
</dl>
</li>
</ul>
<a id="getAllowSimplexAlgorithmChange()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllowSimplexAlgorithmChange</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getAllowSimplexAlgorithmChange()</pre>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getAllowSimplexAlgorithmChange()">getAllowSimplexAlgorithmChange</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The allowSimplexAlgorithmChange.</dd>
</dl>
</li>
</ul>
<a id="setAllowSimplexAlgorithmChange(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAllowSimplexAlgorithmChange</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setAllowSimplexAlgorithmChange&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The allowSimplexAlgorithmChange to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearAllowSimplexAlgorithmChange()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearAllowSimplexAlgorithmChange</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearAllowSimplexAlgorithmChange()</pre>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasDevexWeightsResetPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDevexWeightsResetPeriod</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasDevexWeightsResetPeriod()</pre>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasDevexWeightsResetPeriod()">hasDevexWeightsResetPeriod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the devexWeightsResetPeriod field is set.</dd>
</dl>
</li>
</ul>
<a id="getDevexWeightsResetPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDevexWeightsResetPeriod</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getDevexWeightsResetPeriod()</pre>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getDevexWeightsResetPeriod()">getDevexWeightsResetPeriod</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The devexWeightsResetPeriod.</dd>
</dl>
</li>
</ul>
<a id="setDevexWeightsResetPeriod(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDevexWeightsResetPeriod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setDevexWeightsResetPeriod&#8203;(int&nbsp;value)</pre>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The devexWeightsResetPeriod to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearDevexWeightsResetPeriod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDevexWeightsResetPeriod</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearDevexWeightsResetPeriod()</pre>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasUsePreprocessing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUsePreprocessing</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasUsePreprocessing()</pre>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasUsePreprocessing()">hasUsePreprocessing</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the usePreprocessing field is set.</dd>
</dl>
</li>
</ul>
<a id="getUsePreprocessing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUsePreprocessing</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getUsePreprocessing()</pre>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getUsePreprocessing()">getUsePreprocessing</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The usePreprocessing.</dd>
</dl>
</li>
</ul>
<a id="setUsePreprocessing(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUsePreprocessing</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUsePreprocessing&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The usePreprocessing to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearUsePreprocessing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearUsePreprocessing</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearUsePreprocessing()</pre>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasUseMiddleProductFormUpdate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseMiddleProductFormUpdate</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasUseMiddleProductFormUpdate()</pre>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasUseMiddleProductFormUpdate()">hasUseMiddleProductFormUpdate</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useMiddleProductFormUpdate field is set.</dd>
</dl>
</li>
</ul>
<a id="getUseMiddleProductFormUpdate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseMiddleProductFormUpdate</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getUseMiddleProductFormUpdate()</pre>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getUseMiddleProductFormUpdate()">getUseMiddleProductFormUpdate</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useMiddleProductFormUpdate.</dd>
</dl>
</li>
</ul>
<a id="setUseMiddleProductFormUpdate(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseMiddleProductFormUpdate</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUseMiddleProductFormUpdate&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The useMiddleProductFormUpdate to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearUseMiddleProductFormUpdate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearUseMiddleProductFormUpdate</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearUseMiddleProductFormUpdate()</pre>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasInitializeDevexWithColumnNorms()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitializeDevexWithColumnNorms</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasInitializeDevexWithColumnNorms()</pre>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasInitializeDevexWithColumnNorms()">hasInitializeDevexWithColumnNorms</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initializeDevexWithColumnNorms field is set.</dd>
</dl>
</li>
</ul>
<a id="getInitializeDevexWithColumnNorms()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitializeDevexWithColumnNorms</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getInitializeDevexWithColumnNorms()</pre>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getInitializeDevexWithColumnNorms()">getInitializeDevexWithColumnNorms</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initializeDevexWithColumnNorms.</dd>
</dl>
</li>
</ul>
<a id="setInitializeDevexWithColumnNorms(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInitializeDevexWithColumnNorms</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setInitializeDevexWithColumnNorms&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The initializeDevexWithColumnNorms to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearInitializeDevexWithColumnNorms()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearInitializeDevexWithColumnNorms</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearInitializeDevexWithColumnNorms()</pre>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasExploitSingletonColumnInInitialBasis()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitSingletonColumnInInitialBasis</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasExploitSingletonColumnInInitialBasis()</pre>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasExploitSingletonColumnInInitialBasis()">hasExploitSingletonColumnInInitialBasis</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitSingletonColumnInInitialBasis field is set.</dd>
</dl>
</li>
</ul>
<a id="getExploitSingletonColumnInInitialBasis()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitSingletonColumnInInitialBasis</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getExploitSingletonColumnInInitialBasis()</pre>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getExploitSingletonColumnInInitialBasis()">getExploitSingletonColumnInInitialBasis</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitSingletonColumnInInitialBasis.</dd>
</dl>
</li>
</ul>
<a id="setExploitSingletonColumnInInitialBasis(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setExploitSingletonColumnInInitialBasis</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setExploitSingletonColumnInInitialBasis&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The exploitSingletonColumnInInitialBasis to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearExploitSingletonColumnInInitialBasis()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearExploitSingletonColumnInInitialBasis</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearExploitSingletonColumnInInitialBasis()</pre>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasDualSmallPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDualSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasDualSmallPivotThreshold()</pre>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasDualSmallPivotThreshold()">hasDualSmallPivotThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dualSmallPivotThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getDualSmallPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDualSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getDualSmallPivotThreshold()</pre>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getDualSmallPivotThreshold()">getDualSmallPivotThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dualSmallPivotThreshold.</dd>
</dl>
</li>
</ul>
<a id="setDualSmallPivotThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDualSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setDualSmallPivotThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The dualSmallPivotThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearDualSmallPivotThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDualSmallPivotThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearDualSmallPivotThreshold()</pre>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasPreprocessorZeroTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPreprocessorZeroTolerance</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasPreprocessorZeroTolerance()</pre>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.
 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasPreprocessorZeroTolerance()">hasPreprocessorZeroTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the preprocessorZeroTolerance field is set.</dd>
</dl>
</li>
</ul>
<a id="getPreprocessorZeroTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPreprocessorZeroTolerance</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getPreprocessorZeroTolerance()</pre>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.
 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getPreprocessorZeroTolerance()">getPreprocessorZeroTolerance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The preprocessorZeroTolerance.</dd>
</dl>
</li>
</ul>
<a id="setPreprocessorZeroTolerance(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPreprocessorZeroTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setPreprocessorZeroTolerance&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.
 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The preprocessorZeroTolerance to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearPreprocessorZeroTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearPreprocessorZeroTolerance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearPreprocessorZeroTolerance()</pre>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.
 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasObjectiveLowerLimit()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasObjectiveLowerLimit</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasObjectiveLowerLimit()</pre>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.
 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasObjectiveLowerLimit()">hasObjectiveLowerLimit</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the objectiveLowerLimit field is set.</dd>
</dl>
</li>
</ul>
<a id="getObjectiveLowerLimit()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObjectiveLowerLimit</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getObjectiveLowerLimit()</pre>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.
 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getObjectiveLowerLimit()">getObjectiveLowerLimit</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The objectiveLowerLimit.</dd>
</dl>
</li>
</ul>
<a id="setObjectiveLowerLimit(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setObjectiveLowerLimit</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setObjectiveLowerLimit&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.
 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The objectiveLowerLimit to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearObjectiveLowerLimit()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearObjectiveLowerLimit</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearObjectiveLowerLimit()</pre>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.
 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasObjectiveUpperLimit()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasObjectiveUpperLimit</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasObjectiveUpperLimit()</pre>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasObjectiveUpperLimit()">hasObjectiveUpperLimit</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the objectiveUpperLimit field is set.</dd>
</dl>
</li>
</ul>
<a id="getObjectiveUpperLimit()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObjectiveUpperLimit</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getObjectiveUpperLimit()</pre>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getObjectiveUpperLimit()">getObjectiveUpperLimit</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The objectiveUpperLimit.</dd>
</dl>
</li>
</ul>
<a id="setObjectiveUpperLimit(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setObjectiveUpperLimit</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setObjectiveUpperLimit&#8203;(double&nbsp;value)</pre>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The objectiveUpperLimit to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearObjectiveUpperLimit()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearObjectiveUpperLimit</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearObjectiveUpperLimit()</pre>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasDegenerateMinistepFactor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDegenerateMinistepFactor</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasDegenerateMinistepFactor()</pre>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommanded in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.
 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).
 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasDegenerateMinistepFactor()">hasDegenerateMinistepFactor</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the degenerateMinistepFactor field is set.</dd>
</dl>
</li>
</ul>
<a id="getDegenerateMinistepFactor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDegenerateMinistepFactor</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getDegenerateMinistepFactor()</pre>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommanded in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.
 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).
 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getDegenerateMinistepFactor()">getDegenerateMinistepFactor</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The degenerateMinistepFactor.</dd>
</dl>
</li>
</ul>
<a id="setDegenerateMinistepFactor(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDegenerateMinistepFactor</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setDegenerateMinistepFactor&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommanded in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.
 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).
 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The degenerateMinistepFactor to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearDegenerateMinistepFactor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearDegenerateMinistepFactor</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearDegenerateMinistepFactor()</pre>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommanded in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.
 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).
 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasRandomSeed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRandomSeed</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRandomSeed()</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.
 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasRandomSeed()">hasRandomSeed</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the randomSeed field is set.</dd>
</dl>
</li>
</ul>
<a id="getRandomSeed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomSeed</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getRandomSeed()</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.
 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getRandomSeed()">getRandomSeed</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The randomSeed.</dd>
</dl>
</li>
</ul>
<a id="setRandomSeed(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRandomSeed</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRandomSeed&#8203;(int&nbsp;value)</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.
 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The randomSeed to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearRandomSeed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearRandomSeed</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearRandomSeed()</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.
 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasNumOmpThreads()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumOmpThreads</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasNumOmpThreads()</pre>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasNumOmpThreads()">hasNumOmpThreads</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numOmpThreads field is set.</dd>
</dl>
</li>
</ul>
<a id="getNumOmpThreads()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumOmpThreads</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getNumOmpThreads()</pre>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getNumOmpThreads()">getNumOmpThreads</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numOmpThreads.</dd>
</dl>
</li>
</ul>
<a id="setNumOmpThreads(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNumOmpThreads</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setNumOmpThreads&#8203;(int&nbsp;value)</pre>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The numOmpThreads to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearNumOmpThreads()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearNumOmpThreads</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearNumOmpThreads()</pre>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasPerturbCostsInDualSimplex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPerturbCostsInDualSimplex</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasPerturbCostsInDualSimplex()</pre>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasPerturbCostsInDualSimplex()">hasPerturbCostsInDualSimplex</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the perturbCostsInDualSimplex field is set.</dd>
</dl>
</li>
</ul>
<a id="getPerturbCostsInDualSimplex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPerturbCostsInDualSimplex</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getPerturbCostsInDualSimplex()</pre>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getPerturbCostsInDualSimplex()">getPerturbCostsInDualSimplex</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The perturbCostsInDualSimplex.</dd>
</dl>
</li>
</ul>
<a id="setPerturbCostsInDualSimplex(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPerturbCostsInDualSimplex</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setPerturbCostsInDualSimplex&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The perturbCostsInDualSimplex to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearPerturbCostsInDualSimplex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearPerturbCostsInDualSimplex</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearPerturbCostsInDualSimplex()</pre>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasUseDedicatedDualFeasibilityAlgorithm()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDedicatedDualFeasibilityAlgorithm</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasUseDedicatedDualFeasibilityAlgorithm()</pre>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.
 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasUseDedicatedDualFeasibilityAlgorithm()">hasUseDedicatedDualFeasibilityAlgorithm</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDedicatedDualFeasibilityAlgorithm field is set.</dd>
</dl>
</li>
</ul>
<a id="getUseDedicatedDualFeasibilityAlgorithm()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDedicatedDualFeasibilityAlgorithm</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getUseDedicatedDualFeasibilityAlgorithm()</pre>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.
 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getUseDedicatedDualFeasibilityAlgorithm()">getUseDedicatedDualFeasibilityAlgorithm</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDedicatedDualFeasibilityAlgorithm.</dd>
</dl>
</li>
</ul>
<a id="setUseDedicatedDualFeasibilityAlgorithm(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseDedicatedDualFeasibilityAlgorithm</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUseDedicatedDualFeasibilityAlgorithm&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.
 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The useDedicatedDualFeasibilityAlgorithm to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearUseDedicatedDualFeasibilityAlgorithm()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearUseDedicatedDualFeasibilityAlgorithm</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearUseDedicatedDualFeasibilityAlgorithm()</pre>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.
 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasRelativeCostPerturbation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRelativeCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRelativeCostPerturbation()</pre>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasRelativeCostPerturbation()">hasRelativeCostPerturbation</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the relativeCostPerturbation field is set.</dd>
</dl>
</li>
</ul>
<a id="getRelativeCostPerturbation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRelativeCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getRelativeCostPerturbation()</pre>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getRelativeCostPerturbation()">getRelativeCostPerturbation</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The relativeCostPerturbation.</dd>
</dl>
</li>
</ul>
<a id="setRelativeCostPerturbation(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRelativeCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRelativeCostPerturbation&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The relativeCostPerturbation to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearRelativeCostPerturbation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearRelativeCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearRelativeCostPerturbation()</pre>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasRelativeMaxCostPerturbation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRelativeMaxCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRelativeMaxCostPerturbation()</pre>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasRelativeMaxCostPerturbation()">hasRelativeMaxCostPerturbation</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the relativeMaxCostPerturbation field is set.</dd>
</dl>
</li>
</ul>
<a id="getRelativeMaxCostPerturbation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRelativeMaxCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getRelativeMaxCostPerturbation()</pre>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getRelativeMaxCostPerturbation()">getRelativeMaxCostPerturbation</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The relativeMaxCostPerturbation.</dd>
</dl>
</li>
</ul>
<a id="setRelativeMaxCostPerturbation(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRelativeMaxCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setRelativeMaxCostPerturbation&#8203;(double&nbsp;value)</pre>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The relativeMaxCostPerturbation to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearRelativeMaxCostPerturbation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearRelativeMaxCostPerturbation</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearRelativeMaxCostPerturbation()</pre>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasInitialConditionNumberThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialConditionNumberThreshold</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasInitialConditionNumberThreshold()</pre>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasInitialConditionNumberThreshold()">hasInitialConditionNumberThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialConditionNumberThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getInitialConditionNumberThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialConditionNumberThreshold</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getInitialConditionNumberThreshold()</pre>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getInitialConditionNumberThreshold()">getInitialConditionNumberThreshold</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialConditionNumberThreshold.</dd>
</dl>
</li>
</ul>
<a id="setInitialConditionNumberThreshold(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInitialConditionNumberThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setInitialConditionNumberThreshold&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The initialConditionNumberThreshold to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearInitialConditionNumberThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearInitialConditionNumberThreshold</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearInitialConditionNumberThreshold()</pre>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasLogSearchProgress()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogSearchProgress</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasLogSearchProgress()</pre>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasLogSearchProgress()">hasLogSearchProgress</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logSearchProgress field is set.</dd>
</dl>
</li>
</ul>
<a id="getLogSearchProgress()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogSearchProgress</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getLogSearchProgress()</pre>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getLogSearchProgress()">getLogSearchProgress</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logSearchProgress.</dd>
</dl>
</li>
</ul>
<a id="setLogSearchProgress(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLogSearchProgress</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setLogSearchProgress&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The logSearchProgress to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearLogSearchProgress()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearLogSearchProgress</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearLogSearchProgress()</pre>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasLogToStdout()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogToStdout</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasLogToStdout()</pre>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasLogToStdout()">hasLogToStdout</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logToStdout field is set.</dd>
</dl>
</li>
</ul>
<a id="getLogToStdout()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogToStdout</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getLogToStdout()</pre>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getLogToStdout()">getLogToStdout</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logToStdout.</dd>
</dl>
</li>
</ul>
<a id="setLogToStdout(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLogToStdout</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setLogToStdout&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The logToStdout to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearLogToStdout()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearLogToStdout</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearLogToStdout()</pre>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasCrossoverBoundSnappingDistance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCrossoverBoundSnappingDistance</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasCrossoverBoundSnappingDistance()</pre>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.
 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.
 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().
 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasCrossoverBoundSnappingDistance()">hasCrossoverBoundSnappingDistance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the crossoverBoundSnappingDistance field is set.</dd>
</dl>
</li>
</ul>
<a id="getCrossoverBoundSnappingDistance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCrossoverBoundSnappingDistance</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getCrossoverBoundSnappingDistance()</pre>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.
 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.
 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().
 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getCrossoverBoundSnappingDistance()">getCrossoverBoundSnappingDistance</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The crossoverBoundSnappingDistance.</dd>
</dl>
</li>
</ul>
<a id="setCrossoverBoundSnappingDistance(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCrossoverBoundSnappingDistance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setCrossoverBoundSnappingDistance&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.
 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.
 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().
 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The crossoverBoundSnappingDistance to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearCrossoverBoundSnappingDistance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearCrossoverBoundSnappingDistance</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearCrossoverBoundSnappingDistance()</pre>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.
 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.
 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().
 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasPushToVertex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPushToVertex</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasPushToVertex()</pre>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasPushToVertex()">hasPushToVertex</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the pushToVertex field is set.</dd>
</dl>
</li>
</ul>
<a id="getPushToVertex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPushToVertex</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getPushToVertex()</pre>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getPushToVertex()">getPushToVertex</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The pushToVertex.</dd>
</dl>
</li>
</ul>
<a id="setPushToVertex(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPushToVertex</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setPushToVertex&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The pushToVertex to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearPushToVertex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearPushToVertex</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearPushToVertex()</pre>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasUseImpliedFreePreprocessor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseImpliedFreePreprocessor</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasUseImpliedFreePreprocessor()</pre>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasUseImpliedFreePreprocessor()">hasUseImpliedFreePreprocessor</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useImpliedFreePreprocessor field is set.</dd>
</dl>
</li>
</ul>
<a id="getUseImpliedFreePreprocessor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseImpliedFreePreprocessor</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getUseImpliedFreePreprocessor()</pre>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getUseImpliedFreePreprocessor()">getUseImpliedFreePreprocessor</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useImpliedFreePreprocessor.</dd>
</dl>
</li>
</ul>
<a id="setUseImpliedFreePreprocessor(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseImpliedFreePreprocessor</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUseImpliedFreePreprocessor&#8203;(boolean&nbsp;value)</pre>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The useImpliedFreePreprocessor to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearUseImpliedFreePreprocessor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearUseImpliedFreePreprocessor</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearUseImpliedFreePreprocessor()</pre>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="hasMaxValidMagnitude()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxValidMagnitude</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasMaxValidMagnitude()</pre>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 199 [default = 1e+30];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#hasMaxValidMagnitude()">hasMaxValidMagnitude</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxValidMagnitude field is set.</dd>
</dl>
</li>
</ul>
<a id="getMaxValidMagnitude()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxValidMagnitude</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getMaxValidMagnitude()</pre>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 199 [default = 1e+30];</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="GlopParametersOrBuilder.html#getMaxValidMagnitude()">getMaxValidMagnitude</a></code>&nbsp;in interface&nbsp;<code><a href="GlopParametersOrBuilder.html" title="interface in com.google.ortools.glop">GlopParametersOrBuilder</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxValidMagnitude.</dd>
</dl>
</li>
</ul>
<a id="setMaxValidMagnitude(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxValidMagnitude</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setMaxValidMagnitude&#8203;(double&nbsp;value)</pre>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 199 [default = 1e+30];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The maxValidMagnitude to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="clearMaxValidMagnitude()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearMaxValidMagnitude</h4>
<pre class="methodSignature">public&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;clearMaxValidMagnitude()</pre>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 199 [default = 1e+30];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This builder for chaining.</dd>
</dl>
</li>
</ul>
<a id="setUnknownFields(com.google.protobuf.UnknownFieldSet)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUnknownFields</h4>
<pre class="methodSignature">public final&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;setUnknownFields&#8203;(com.google.protobuf.UnknownFieldSet&nbsp;unknownFields)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setUnknownFields</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>setUnknownFields</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="mergeUnknownFields(com.google.protobuf.UnknownFieldSet)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>mergeUnknownFields</h4>
<pre class="methodSignature">public final&nbsp;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&nbsp;mergeUnknownFields&#8203;(com.google.protobuf.UnknownFieldSet&nbsp;unknownFields)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>mergeUnknownFields</code>&nbsp;in interface&nbsp;<code>com.google.protobuf.Message.Builder</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>mergeUnknownFields</code>&nbsp;in class&nbsp;<code>com.google.protobuf.GeneratedMessageV3.Builder&lt;<a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a>&gt;</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GlopParameters.Builder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2022. All rights reserved.</small></p>
</footer>
</body>
</html>
