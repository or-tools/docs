<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang>
<head>
<!-- Generated by javadoc (1.8.0_402) on Tue Sep 17 13:31:30 GMT 2024 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>GlopParametersOrBuilder (com.google.ortools:ortools-java 9.11.9999 API)</title>
<meta name="date" content="2024-09-17">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GlopParametersOrBuilder (com.google.ortools:ortools-java 9.11.9999 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6,"i23":6,"i24":6,"i25":6,"i26":6,"i27":6,"i28":6,"i29":6,"i30":6,"i31":6,"i32":6,"i33":6,"i34":6,"i35":6,"i36":6,"i37":6,"i38":6,"i39":6,"i40":6,"i41":6,"i42":6,"i43":6,"i44":6,"i45":6,"i46":6,"i47":6,"i48":6,"i49":6,"i50":6,"i51":6,"i52":6,"i53":6,"i54":6,"i55":6,"i56":6,"i57":6,"i58":6,"i59":6,"i60":6,"i61":6,"i62":6,"i63":6,"i64":6,"i65":6,"i66":6,"i67":6,"i68":6,"i69":6,"i70":6,"i71":6,"i72":6,"i73":6,"i74":6,"i75":6,"i76":6,"i77":6,"i78":6,"i79":6,"i80":6,"i81":6,"i82":6,"i83":6,"i84":6,"i85":6,"i86":6,"i87":6,"i88":6,"i89":6,"i90":6,"i91":6,"i92":6,"i93":6,"i94":6,"i95":6,"i96":6,"i97":6,"i98":6,"i99":6,"i100":6,"i101":6,"i102":6,"i103":6,"i104":6,"i105":6,"i106":6,"i107":6,"i108":6,"i109":6,"i110":6,"i111":6,"i112":6,"i113":6,"i114":6,"i115":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GlopParametersOrBuilder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/ortools/glop/GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/google/ortools/glop/Parameters.html" title="class in com.google.ortools.glop"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/ortools/glop/GlopParametersOrBuilder.html" target="_top">Frames</a></li>
<li><a href="GlopParametersOrBuilder.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.google.ortools.glop</div>
<h2 title="Interface GlopParametersOrBuilder" class="title">Interface GlopParametersOrBuilder</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd>com.google.protobuf.MessageLiteOrBuilder, com.google.protobuf.MessageOrBuilder</dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><a href="../../../../com/google/ortools/glop/GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a>, <a href="../../../../com/google/ortools/glop/GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></dd>
</dl>
<hr>
<br>
<pre>public interface <span class="typeNameLabel">GlopParametersOrBuilder</span>
extends com.google.protobuf.MessageOrBuilder</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getAllowSimplexAlgorithmChange--">getAllowSimplexAlgorithmChange</a></span>()</code>
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getBasisRefactorizationPeriod--">getBasisRefactorizationPeriod</a></span>()</code>
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getChangeStatusToImprecise--">getChangeStatusToImprecise</a></span>()</code>
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/glop/GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getCostScaling--">getCostScaling</a></span>()</code>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getCrossoverBoundSnappingDistance--">getCrossoverBoundSnappingDistance</a></span>()</code>
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDegenerateMinistepFactor--">getDegenerateMinistepFactor</a></span>()</code>
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDevexWeightsResetPeriod--">getDevexWeightsResetPeriod</a></span>()</code>
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDropMagnitude--">getDropMagnitude</a></span>()</code>
<div class="block">
 Value in the input LP lower than this will be ignored.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDropTolerance--">getDropTolerance</a></span>()</code>
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDualFeasibilityTolerance--">getDualFeasibilityTolerance</a></span>()</code>
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDualizerThreshold--">getDualizerThreshold</a></span>()</code>
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDualPricePrioritizeNorm--">getDualPricePrioritizeNorm</a></span>()</code>
<div class="block">
 On some problem like stp3d or pds-100 this makes a huge difference in
 speed and number of iterations of the dual simplex.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDualSmallPivotThreshold--">getDualSmallPivotThreshold</a></span>()</code>
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getDynamicallyAdjustRefactorizationPeriod--">getDynamicallyAdjustRefactorizationPeriod</a></span>()</code>
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getExploitSingletonColumnInInitialBasis--">getExploitSingletonColumnInInitialBasis</a></span>()</code>
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/glop/GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getFeasibilityRule--">getFeasibilityRule</a></span>()</code>
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getHarrisToleranceRatio--">getHarrisToleranceRatio</a></span>()</code>
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/glop/GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getInitialBasis--">getInitialBasis</a></span>()</code>
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getInitialConditionNumberThreshold--">getInitialConditionNumberThreshold</a></span>()</code>
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getInitializeDevexWithColumnNorms--">getInitializeDevexWithColumnNorms</a></span>()</code>
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getLogSearchProgress--">getLogSearchProgress</a></span>()</code>
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getLogToStdout--">getLogToStdout</a></span>()</code>
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getLuFactorizationPivotThreshold--">getLuFactorizationPivotThreshold</a></span>()</code>
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMarkowitzSingularityThreshold--">getMarkowitzSingularityThreshold</a></span>()</code>
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMarkowitzZlatevParameter--">getMarkowitzZlatevParameter</a></span>()</code>
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMaxDeterministicTime--">getMaxDeterministicTime</a></span>()</code>
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMaxNumberOfIterations--">getMaxNumberOfIterations</a></span>()</code>
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMaxNumberOfReoptimizations--">getMaxNumberOfReoptimizations</a></span>()</code>
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMaxTimeInSeconds--">getMaxTimeInSeconds</a></span>()</code>
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMaxValidMagnitude--">getMaxValidMagnitude</a></span>()</code>
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getMinimumAcceptablePivot--">getMinimumAcceptablePivot</a></span>()</code>
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getNumOmpThreads--">getNumOmpThreads</a></span>()</code>
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getObjectiveLowerLimit--">getObjectiveLowerLimit</a></span>()</code>
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getObjectiveUpperLimit--">getObjectiveUpperLimit</a></span>()</code>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/glop/GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getOptimizationRule--">getOptimizationRule</a></span>()</code>
<div class="block">
 PricingRule to use during the optimization phase.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getPerturbCostsInDualSimplex--">getPerturbCostsInDualSimplex</a></span>()</code>
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getPreprocessorZeroTolerance--">getPreprocessorZeroTolerance</a></span>()</code>
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getPrimalFeasibilityTolerance--">getPrimalFeasibilityTolerance</a></span>()</code>
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getProvideStrongOptimalGuarantee--">getProvideStrongOptimalGuarantee</a></span>()</code>
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getPushToVertex--">getPushToVertex</a></span>()</code>
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getRandomSeed--">getRandomSeed</a></span>()</code>
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getRatioTestZeroThreshold--">getRatioTestZeroThreshold</a></span>()</code>
<div class="block">
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getRecomputeEdgesNormThreshold--">getRecomputeEdgesNormThreshold</a></span>()</code>
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getRecomputeReducedCostsThreshold--">getRecomputeReducedCostsThreshold</a></span>()</code>
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getRefactorizationThreshold--">getRefactorizationThreshold</a></span>()</code>
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row]</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getRelativeCostPerturbation--">getRelativeCostPerturbation</a></span>()</code>
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
 relative_cost_perturbation * cost
 + relative_max_cost_perturbation * max_cost);
 

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getRelativeMaxCostPerturbation--">getRelativeMaxCostPerturbation</a></span>()</code>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/glop/GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getScalingMethod--">getScalingMethod</a></span>()</code>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getSmallPivotThreshold--">getSmallPivotThreshold</a></span>()</code>
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getSolutionFeasibilityTolerance--">getSolutionFeasibilityTolerance</a></span>()</code>
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/glop/GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getSolveDualProblem--">getSolveDualProblem</a></span>()</code>
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getUseDedicatedDualFeasibilityAlgorithm--">getUseDedicatedDualFeasibilityAlgorithm</a></span>()</code>
<div class="block">
 We have two possible dual phase I algorithms.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getUseDualSimplex--">getUseDualSimplex</a></span>()</code>
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getUseImpliedFreePreprocessor--">getUseImpliedFreePreprocessor</a></span>()</code>
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getUseMiddleProductFormUpdate--">getUseMiddleProductFormUpdate</a></span>()</code>
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getUsePreprocessing--">getUsePreprocessing</a></span>()</code>
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getUseScaling--">getUseScaling</a></span>()</code>
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#getUseTransposedMatrix--">getUseTransposedMatrix</a></span>()</code>
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasAllowSimplexAlgorithmChange--">hasAllowSimplexAlgorithmChange</a></span>()</code>
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasBasisRefactorizationPeriod--">hasBasisRefactorizationPeriod</a></span>()</code>
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasChangeStatusToImprecise--">hasChangeStatusToImprecise</a></span>()</code>
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasCostScaling--">hasCostScaling</a></span>()</code>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasCrossoverBoundSnappingDistance--">hasCrossoverBoundSnappingDistance</a></span>()</code>
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDegenerateMinistepFactor--">hasDegenerateMinistepFactor</a></span>()</code>
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDevexWeightsResetPeriod--">hasDevexWeightsResetPeriod</a></span>()</code>
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDropMagnitude--">hasDropMagnitude</a></span>()</code>
<div class="block">
 Value in the input LP lower than this will be ignored.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDropTolerance--">hasDropTolerance</a></span>()</code>
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDualFeasibilityTolerance--">hasDualFeasibilityTolerance</a></span>()</code>
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDualizerThreshold--">hasDualizerThreshold</a></span>()</code>
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDualPricePrioritizeNorm--">hasDualPricePrioritizeNorm</a></span>()</code>
<div class="block">
 On some problem like stp3d or pds-100 this makes a huge difference in
 speed and number of iterations of the dual simplex.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDualSmallPivotThreshold--">hasDualSmallPivotThreshold</a></span>()</code>
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasDynamicallyAdjustRefactorizationPeriod--">hasDynamicallyAdjustRefactorizationPeriod</a></span>()</code>
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasExploitSingletonColumnInInitialBasis--">hasExploitSingletonColumnInInitialBasis</a></span>()</code>
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasFeasibilityRule--">hasFeasibilityRule</a></span>()</code>
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasHarrisToleranceRatio--">hasHarrisToleranceRatio</a></span>()</code>
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasInitialBasis--">hasInitialBasis</a></span>()</code>
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasInitialConditionNumberThreshold--">hasInitialConditionNumberThreshold</a></span>()</code>
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasInitializeDevexWithColumnNorms--">hasInitializeDevexWithColumnNorms</a></span>()</code>
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasLogSearchProgress--">hasLogSearchProgress</a></span>()</code>
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasLogToStdout--">hasLogToStdout</a></span>()</code>
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasLuFactorizationPivotThreshold--">hasLuFactorizationPivotThreshold</a></span>()</code>
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMarkowitzSingularityThreshold--">hasMarkowitzSingularityThreshold</a></span>()</code>
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMarkowitzZlatevParameter--">hasMarkowitzZlatevParameter</a></span>()</code>
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMaxDeterministicTime--">hasMaxDeterministicTime</a></span>()</code>
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMaxNumberOfIterations--">hasMaxNumberOfIterations</a></span>()</code>
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMaxNumberOfReoptimizations--">hasMaxNumberOfReoptimizations</a></span>()</code>
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMaxTimeInSeconds--">hasMaxTimeInSeconds</a></span>()</code>
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMaxValidMagnitude--">hasMaxValidMagnitude</a></span>()</code>
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasMinimumAcceptablePivot--">hasMinimumAcceptablePivot</a></span>()</code>
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasNumOmpThreads--">hasNumOmpThreads</a></span>()</code>
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasObjectiveLowerLimit--">hasObjectiveLowerLimit</a></span>()</code>
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasObjectiveUpperLimit--">hasObjectiveUpperLimit</a></span>()</code>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasOptimizationRule--">hasOptimizationRule</a></span>()</code>
<div class="block">
 PricingRule to use during the optimization phase.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasPerturbCostsInDualSimplex--">hasPerturbCostsInDualSimplex</a></span>()</code>
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasPreprocessorZeroTolerance--">hasPreprocessorZeroTolerance</a></span>()</code>
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasPrimalFeasibilityTolerance--">hasPrimalFeasibilityTolerance</a></span>()</code>
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasProvideStrongOptimalGuarantee--">hasProvideStrongOptimalGuarantee</a></span>()</code>
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasPushToVertex--">hasPushToVertex</a></span>()</code>
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasRandomSeed--">hasRandomSeed</a></span>()</code>
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasRatioTestZeroThreshold--">hasRatioTestZeroThreshold</a></span>()</code>
<div class="block">
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasRecomputeEdgesNormThreshold--">hasRecomputeEdgesNormThreshold</a></span>()</code>
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasRecomputeReducedCostsThreshold--">hasRecomputeReducedCostsThreshold</a></span>()</code>
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasRefactorizationThreshold--">hasRefactorizationThreshold</a></span>()</code>
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row]</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasRelativeCostPerturbation--">hasRelativeCostPerturbation</a></span>()</code>
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
 relative_cost_perturbation * cost
 + relative_max_cost_perturbation * max_cost);
 

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasRelativeMaxCostPerturbation--">hasRelativeMaxCostPerturbation</a></span>()</code>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasScalingMethod--">hasScalingMethod</a></span>()</code>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasSmallPivotThreshold--">hasSmallPivotThreshold</a></span>()</code>
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasSolutionFeasibilityTolerance--">hasSolutionFeasibilityTolerance</a></span>()</code>
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasSolveDualProblem--">hasSolveDualProblem</a></span>()</code>
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasUseDedicatedDualFeasibilityAlgorithm--">hasUseDedicatedDualFeasibilityAlgorithm</a></span>()</code>
<div class="block">
 We have two possible dual phase I algorithms.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasUseDualSimplex--">hasUseDualSimplex</a></span>()</code>
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasUseImpliedFreePreprocessor--">hasUseImpliedFreePreprocessor</a></span>()</code>
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasUseMiddleProductFormUpdate--">hasUseMiddleProductFormUpdate</a></span>()</code>
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasUsePreprocessing--">hasUsePreprocessing</a></span>()</code>
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasUseScaling--">hasUseScaling</a></span>()</code>
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/glop/GlopParametersOrBuilder.html#hasUseTransposedMatrix--">hasUseTransposedMatrix</a></span>()</code>
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.com.google.protobuf.MessageOrBuilder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageOrBuilder</h3>
<code>findInitializationErrors, getAllFields, getDefaultInstanceForType, getDescriptorForType, getField, getInitializationErrorString, getOneofFieldDescriptor, getRepeatedField, getRepeatedFieldCount, getUnknownFields, hasField, hasOneof</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.com.google.protobuf.MessageLiteOrBuilder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageLiteOrBuilder</h3>
<code>isInitialized</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="hasScalingMethod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasScalingMethod</h4>
<pre>boolean&nbsp;hasScalingMethod()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the scalingMethod field is set.</dd>
</dl>
</li>
</ul>
<a name="getScalingMethod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getScalingMethod</h4>
<pre><a href="../../../../com/google/ortools/glop/GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a>&nbsp;getScalingMethod()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The scalingMethod.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityRule--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityRule</h4>
<pre>boolean&nbsp;hasFeasibilityRule()</pre>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityRule field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityRule--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityRule</h4>
<pre><a href="../../../../com/google/ortools/glop/GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;getFeasibilityRule()</pre>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityRule.</dd>
</dl>
</li>
</ul>
<a name="hasOptimizationRule--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasOptimizationRule</h4>
<pre>boolean&nbsp;hasOptimizationRule()</pre>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the optimizationRule field is set.</dd>
</dl>
</li>
</ul>
<a name="getOptimizationRule--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimizationRule</h4>
<pre><a href="../../../../com/google/ortools/glop/GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a>&nbsp;getOptimizationRule()</pre>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The optimizationRule.</dd>
</dl>
</li>
</ul>
<a name="hasRefactorizationThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRefactorizationThreshold</h4>
<pre>boolean&nbsp;hasRefactorizationThreshold()</pre>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the refactorizationThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getRefactorizationThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRefactorizationThreshold</h4>
<pre>double&nbsp;getRefactorizationThreshold()</pre>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The refactorizationThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasRecomputeReducedCostsThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRecomputeReducedCostsThreshold</h4>
<pre>boolean&nbsp;hasRecomputeReducedCostsThreshold()</pre>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the recomputeReducedCostsThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getRecomputeReducedCostsThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRecomputeReducedCostsThreshold</h4>
<pre>double&nbsp;getRecomputeReducedCostsThreshold()</pre>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The recomputeReducedCostsThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasRecomputeEdgesNormThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRecomputeEdgesNormThreshold</h4>
<pre>boolean&nbsp;hasRecomputeEdgesNormThreshold()</pre>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the recomputeEdgesNormThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getRecomputeEdgesNormThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRecomputeEdgesNormThreshold</h4>
<pre>double&nbsp;getRecomputeEdgesNormThreshold()</pre>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The recomputeEdgesNormThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasPrimalFeasibilityTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPrimalFeasibilityTolerance</h4>
<pre>boolean&nbsp;hasPrimalFeasibilityTolerance()</pre>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.

 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the primalFeasibilityTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getPrimalFeasibilityTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPrimalFeasibilityTolerance</h4>
<pre>double&nbsp;getPrimalFeasibilityTolerance()</pre>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.

 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The primalFeasibilityTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasDualFeasibilityTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDualFeasibilityTolerance</h4>
<pre>boolean&nbsp;hasDualFeasibilityTolerance()</pre>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.

 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.

 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dualFeasibilityTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getDualFeasibilityTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDualFeasibilityTolerance</h4>
<pre>double&nbsp;getDualFeasibilityTolerance()</pre>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.

 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.

 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dualFeasibilityTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasRatioTestZeroThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRatioTestZeroThreshold</h4>
<pre>boolean&nbsp;hasRatioTestZeroThreshold()</pre>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.

 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the ratioTestZeroThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getRatioTestZeroThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRatioTestZeroThreshold</h4>
<pre>double&nbsp;getRatioTestZeroThreshold()</pre>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.

 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The ratioTestZeroThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasHarrisToleranceRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasHarrisToleranceRatio</h4>
<pre>boolean&nbsp;hasHarrisToleranceRatio()</pre>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.

 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the harrisToleranceRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getHarrisToleranceRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHarrisToleranceRatio</h4>
<pre>double&nbsp;getHarrisToleranceRatio()</pre>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.

 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The harrisToleranceRatio.</dd>
</dl>
</li>
</ul>
<a name="hasSmallPivotThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSmallPivotThreshold</h4>
<pre>boolean&nbsp;hasSmallPivotThreshold()</pre>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the smallPivotThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getSmallPivotThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSmallPivotThreshold</h4>
<pre>double&nbsp;getSmallPivotThreshold()</pre>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The smallPivotThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasMinimumAcceptablePivot--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMinimumAcceptablePivot</h4>
<pre>boolean&nbsp;hasMinimumAcceptablePivot()</pre>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the minimumAcceptablePivot field is set.</dd>
</dl>
</li>
</ul>
<a name="getMinimumAcceptablePivot--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinimumAcceptablePivot</h4>
<pre>double&nbsp;getMinimumAcceptablePivot()</pre>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The minimumAcceptablePivot.</dd>
</dl>
</li>
</ul>
<a name="hasDropTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDropTolerance</h4>
<pre>boolean&nbsp;hasDropTolerance()</pre>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dropTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getDropTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDropTolerance</h4>
<pre>double&nbsp;getDropTolerance()</pre>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dropTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasUseScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseScaling</h4>
<pre>boolean&nbsp;hasUseScaling()</pre>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useScaling field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseScaling</h4>
<pre>boolean&nbsp;getUseScaling()</pre>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useScaling.</dd>
</dl>
</li>
</ul>
<a name="hasCostScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCostScaling</h4>
<pre>boolean&nbsp;hasCostScaling()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the costScaling field is set.</dd>
</dl>
</li>
</ul>
<a name="getCostScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCostScaling</h4>
<pre><a href="../../../../com/google/ortools/glop/GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a>&nbsp;getCostScaling()</pre>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The costScaling.</dd>
</dl>
</li>
</ul>
<a name="hasInitialBasis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialBasis</h4>
<pre>boolean&nbsp;hasInitialBasis()</pre>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialBasis field is set.</dd>
</dl>
</li>
</ul>
<a name="getInitialBasis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialBasis</h4>
<pre><a href="../../../../com/google/ortools/glop/GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a>&nbsp;getInitialBasis()</pre>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialBasis.</dd>
</dl>
</li>
</ul>
<a name="hasUseTransposedMatrix--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseTransposedMatrix</h4>
<pre>boolean&nbsp;hasUseTransposedMatrix()</pre>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useTransposedMatrix field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseTransposedMatrix--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseTransposedMatrix</h4>
<pre>boolean&nbsp;getUseTransposedMatrix()</pre>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useTransposedMatrix.</dd>
</dl>
</li>
</ul>
<a name="hasBasisRefactorizationPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasBasisRefactorizationPeriod</h4>
<pre>boolean&nbsp;hasBasisRefactorizationPeriod()</pre>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the basisRefactorizationPeriod field is set.</dd>
</dl>
</li>
</ul>
<a name="getBasisRefactorizationPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBasisRefactorizationPeriod</h4>
<pre>int&nbsp;getBasisRefactorizationPeriod()</pre>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The basisRefactorizationPeriod.</dd>
</dl>
</li>
</ul>
<a name="hasDynamicallyAdjustRefactorizationPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDynamicallyAdjustRefactorizationPeriod</h4>
<pre>boolean&nbsp;hasDynamicallyAdjustRefactorizationPeriod()</pre>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dynamicallyAdjustRefactorizationPeriod field is set.</dd>
</dl>
</li>
</ul>
<a name="getDynamicallyAdjustRefactorizationPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDynamicallyAdjustRefactorizationPeriod</h4>
<pre>boolean&nbsp;getDynamicallyAdjustRefactorizationPeriod()</pre>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dynamicallyAdjustRefactorizationPeriod.</dd>
</dl>
</li>
</ul>
<a name="hasSolveDualProblem--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolveDualProblem</h4>
<pre>boolean&nbsp;hasSolveDualProblem()</pre>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the solveDualProblem field is set.</dd>
</dl>
</li>
</ul>
<a name="getSolveDualProblem--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSolveDualProblem</h4>
<pre><a href="../../../../com/google/ortools/glop/GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a>&nbsp;getSolveDualProblem()</pre>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The solveDualProblem.</dd>
</dl>
</li>
</ul>
<a name="hasDualizerThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDualizerThreshold</h4>
<pre>boolean&nbsp;hasDualizerThreshold()</pre>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dualizerThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getDualizerThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDualizerThreshold</h4>
<pre>double&nbsp;getDualizerThreshold()</pre>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dualizerThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasSolutionFeasibilityTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolutionFeasibilityTolerance</h4>
<pre>boolean&nbsp;hasSolutionFeasibilityTolerance()</pre>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.

 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the solutionFeasibilityTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getSolutionFeasibilityTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSolutionFeasibilityTolerance</h4>
<pre>double&nbsp;getSolutionFeasibilityTolerance()</pre>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.

 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The solutionFeasibilityTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasProvideStrongOptimalGuarantee--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasProvideStrongOptimalGuarantee</h4>
<pre>boolean&nbsp;hasProvideStrongOptimalGuarantee()</pre>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
 component of the objective function a bit, then the pair (primal values,
 dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
 defined in the comment for solution_feasibility_tolerance (*).

 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.

 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the provideStrongOptimalGuarantee field is set.</dd>
</dl>
</li>
</ul>
<a name="getProvideStrongOptimalGuarantee--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProvideStrongOptimalGuarantee</h4>
<pre>boolean&nbsp;getProvideStrongOptimalGuarantee()</pre>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
 component of the objective function a bit, then the pair (primal values,
 dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
 defined in the comment for solution_feasibility_tolerance (*).

 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.

 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The provideStrongOptimalGuarantee.</dd>
</dl>
</li>
</ul>
<a name="hasChangeStatusToImprecise--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasChangeStatusToImprecise</h4>
<pre>boolean&nbsp;hasChangeStatusToImprecise()</pre>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the changeStatusToImprecise field is set.</dd>
</dl>
</li>
</ul>
<a name="getChangeStatusToImprecise--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getChangeStatusToImprecise</h4>
<pre>boolean&nbsp;getChangeStatusToImprecise()</pre>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The changeStatusToImprecise.</dd>
</dl>
</li>
</ul>
<a name="hasMaxNumberOfReoptimizations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumberOfReoptimizations</h4>
<pre>boolean&nbsp;hasMaxNumberOfReoptimizations()</pre>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumberOfReoptimizations field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxNumberOfReoptimizations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumberOfReoptimizations</h4>
<pre>double&nbsp;getMaxNumberOfReoptimizations()</pre>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumberOfReoptimizations.</dd>
</dl>
</li>
</ul>
<a name="hasLuFactorizationPivotThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLuFactorizationPivotThreshold</h4>
<pre>boolean&nbsp;hasLuFactorizationPivotThreshold()</pre>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the luFactorizationPivotThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getLuFactorizationPivotThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLuFactorizationPivotThreshold</h4>
<pre>double&nbsp;getLuFactorizationPivotThreshold()</pre>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The luFactorizationPivotThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasMaxTimeInSeconds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxTimeInSeconds</h4>
<pre>boolean&nbsp;hasMaxTimeInSeconds()</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxTimeInSeconds field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxTimeInSeconds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxTimeInSeconds</h4>
<pre>double&nbsp;getMaxTimeInSeconds()</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxTimeInSeconds.</dd>
</dl>
</li>
</ul>
<a name="hasMaxDeterministicTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxDeterministicTime</h4>
<pre>boolean&nbsp;hasMaxDeterministicTime()</pre>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).

 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxDeterministicTime field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxDeterministicTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxDeterministicTime</h4>
<pre>double&nbsp;getMaxDeterministicTime()</pre>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).

 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxDeterministicTime.</dd>
</dl>
</li>
</ul>
<a name="hasMaxNumberOfIterations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumberOfIterations</h4>
<pre>boolean&nbsp;hasMaxNumberOfIterations()</pre>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumberOfIterations field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxNumberOfIterations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumberOfIterations</h4>
<pre>long&nbsp;getMaxNumberOfIterations()</pre>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumberOfIterations.</dd>
</dl>
</li>
</ul>
<a name="hasMarkowitzZlatevParameter--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMarkowitzZlatevParameter</h4>
<pre>boolean&nbsp;hasMarkowitzZlatevParameter()</pre>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the markowitzZlatevParameter field is set.</dd>
</dl>
</li>
</ul>
<a name="getMarkowitzZlatevParameter--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMarkowitzZlatevParameter</h4>
<pre>int&nbsp;getMarkowitzZlatevParameter()</pre>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The markowitzZlatevParameter.</dd>
</dl>
</li>
</ul>
<a name="hasMarkowitzSingularityThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMarkowitzSingularityThreshold</h4>
<pre>boolean&nbsp;hasMarkowitzSingularityThreshold()</pre>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the markowitzSingularityThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getMarkowitzSingularityThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMarkowitzSingularityThreshold</h4>
<pre>double&nbsp;getMarkowitzSingularityThreshold()</pre>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The markowitzSingularityThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasUseDualSimplex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDualSimplex</h4>
<pre>boolean&nbsp;hasUseDualSimplex()</pre>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDualSimplex field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseDualSimplex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDualSimplex</h4>
<pre>boolean&nbsp;getUseDualSimplex()</pre>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDualSimplex.</dd>
</dl>
</li>
</ul>
<a name="hasAllowSimplexAlgorithmChange--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAllowSimplexAlgorithmChange</h4>
<pre>boolean&nbsp;hasAllowSimplexAlgorithmChange()</pre>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the allowSimplexAlgorithmChange field is set.</dd>
</dl>
</li>
</ul>
<a name="getAllowSimplexAlgorithmChange--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllowSimplexAlgorithmChange</h4>
<pre>boolean&nbsp;getAllowSimplexAlgorithmChange()</pre>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The allowSimplexAlgorithmChange.</dd>
</dl>
</li>
</ul>
<a name="hasDevexWeightsResetPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDevexWeightsResetPeriod</h4>
<pre>boolean&nbsp;hasDevexWeightsResetPeriod()</pre>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the devexWeightsResetPeriod field is set.</dd>
</dl>
</li>
</ul>
<a name="getDevexWeightsResetPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDevexWeightsResetPeriod</h4>
<pre>int&nbsp;getDevexWeightsResetPeriod()</pre>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The devexWeightsResetPeriod.</dd>
</dl>
</li>
</ul>
<a name="hasUsePreprocessing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUsePreprocessing</h4>
<pre>boolean&nbsp;hasUsePreprocessing()</pre>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the usePreprocessing field is set.</dd>
</dl>
</li>
</ul>
<a name="getUsePreprocessing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUsePreprocessing</h4>
<pre>boolean&nbsp;getUsePreprocessing()</pre>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The usePreprocessing.</dd>
</dl>
</li>
</ul>
<a name="hasUseMiddleProductFormUpdate--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseMiddleProductFormUpdate</h4>
<pre>boolean&nbsp;hasUseMiddleProductFormUpdate()</pre>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useMiddleProductFormUpdate field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseMiddleProductFormUpdate--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseMiddleProductFormUpdate</h4>
<pre>boolean&nbsp;getUseMiddleProductFormUpdate()</pre>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useMiddleProductFormUpdate.</dd>
</dl>
</li>
</ul>
<a name="hasInitializeDevexWithColumnNorms--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitializeDevexWithColumnNorms</h4>
<pre>boolean&nbsp;hasInitializeDevexWithColumnNorms()</pre>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initializeDevexWithColumnNorms field is set.</dd>
</dl>
</li>
</ul>
<a name="getInitializeDevexWithColumnNorms--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitializeDevexWithColumnNorms</h4>
<pre>boolean&nbsp;getInitializeDevexWithColumnNorms()</pre>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initializeDevexWithColumnNorms.</dd>
</dl>
</li>
</ul>
<a name="hasExploitSingletonColumnInInitialBasis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitSingletonColumnInInitialBasis</h4>
<pre>boolean&nbsp;hasExploitSingletonColumnInInitialBasis()</pre>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitSingletonColumnInInitialBasis field is set.</dd>
</dl>
</li>
</ul>
<a name="getExploitSingletonColumnInInitialBasis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitSingletonColumnInInitialBasis</h4>
<pre>boolean&nbsp;getExploitSingletonColumnInInitialBasis()</pre>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitSingletonColumnInInitialBasis.</dd>
</dl>
</li>
</ul>
<a name="hasDualSmallPivotThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDualSmallPivotThreshold</h4>
<pre>boolean&nbsp;hasDualSmallPivotThreshold()</pre>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dualSmallPivotThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getDualSmallPivotThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDualSmallPivotThreshold</h4>
<pre>double&nbsp;getDualSmallPivotThreshold()</pre>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dualSmallPivotThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasPreprocessorZeroTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPreprocessorZeroTolerance</h4>
<pre>boolean&nbsp;hasPreprocessorZeroTolerance()</pre>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.

 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the preprocessorZeroTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getPreprocessorZeroTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPreprocessorZeroTolerance</h4>
<pre>double&nbsp;getPreprocessorZeroTolerance()</pre>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.

 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The preprocessorZeroTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasObjectiveLowerLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasObjectiveLowerLimit</h4>
<pre>boolean&nbsp;hasObjectiveLowerLimit()</pre>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.

 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the objectiveLowerLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getObjectiveLowerLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObjectiveLowerLimit</h4>
<pre>double&nbsp;getObjectiveLowerLimit()</pre>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.

 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The objectiveLowerLimit.</dd>
</dl>
</li>
</ul>
<a name="hasObjectiveUpperLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasObjectiveUpperLimit</h4>
<pre>boolean&nbsp;hasObjectiveUpperLimit()</pre>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the objectiveUpperLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getObjectiveUpperLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObjectiveUpperLimit</h4>
<pre>double&nbsp;getObjectiveUpperLimit()</pre>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The objectiveUpperLimit.</dd>
</dl>
</li>
</ul>
<a name="hasDegenerateMinistepFactor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDegenerateMinistepFactor</h4>
<pre>boolean&nbsp;hasDegenerateMinistepFactor()</pre>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommended in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.

 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).

 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the degenerateMinistepFactor field is set.</dd>
</dl>
</li>
</ul>
<a name="getDegenerateMinistepFactor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDegenerateMinistepFactor</h4>
<pre>double&nbsp;getDegenerateMinistepFactor()</pre>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommended in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.

 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).

 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The degenerateMinistepFactor.</dd>
</dl>
</li>
</ul>
<a name="hasRandomSeed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRandomSeed</h4>
<pre>boolean&nbsp;hasRandomSeed()</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.

 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.

 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the randomSeed field is set.</dd>
</dl>
</li>
</ul>
<a name="getRandomSeed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomSeed</h4>
<pre>int&nbsp;getRandomSeed()</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.

 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.

 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The randomSeed.</dd>
</dl>
</li>
</ul>
<a name="hasNumOmpThreads--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumOmpThreads</h4>
<pre>boolean&nbsp;hasNumOmpThreads()</pre>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numOmpThreads field is set.</dd>
</dl>
</li>
</ul>
<a name="getNumOmpThreads--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumOmpThreads</h4>
<pre>int&nbsp;getNumOmpThreads()</pre>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numOmpThreads.</dd>
</dl>
</li>
</ul>
<a name="hasPerturbCostsInDualSimplex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPerturbCostsInDualSimplex</h4>
<pre>boolean&nbsp;hasPerturbCostsInDualSimplex()</pre>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the perturbCostsInDualSimplex field is set.</dd>
</dl>
</li>
</ul>
<a name="getPerturbCostsInDualSimplex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPerturbCostsInDualSimplex</h4>
<pre>boolean&nbsp;getPerturbCostsInDualSimplex()</pre>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The perturbCostsInDualSimplex.</dd>
</dl>
</li>
</ul>
<a name="hasUseDedicatedDualFeasibilityAlgorithm--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDedicatedDualFeasibilityAlgorithm</h4>
<pre>boolean&nbsp;hasUseDedicatedDualFeasibilityAlgorithm()</pre>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.

 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDedicatedDualFeasibilityAlgorithm field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseDedicatedDualFeasibilityAlgorithm--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDedicatedDualFeasibilityAlgorithm</h4>
<pre>boolean&nbsp;getUseDedicatedDualFeasibilityAlgorithm()</pre>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.

 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDedicatedDualFeasibilityAlgorithm.</dd>
</dl>
</li>
</ul>
<a name="hasRelativeCostPerturbation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRelativeCostPerturbation</h4>
<pre>boolean&nbsp;hasRelativeCostPerturbation()</pre>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
 relative_cost_perturbation * cost
 + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the relativeCostPerturbation field is set.</dd>
</dl>
</li>
</ul>
<a name="getRelativeCostPerturbation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRelativeCostPerturbation</h4>
<pre>double&nbsp;getRelativeCostPerturbation()</pre>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
 relative_cost_perturbation * cost
 + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The relativeCostPerturbation.</dd>
</dl>
</li>
</ul>
<a name="hasRelativeMaxCostPerturbation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRelativeMaxCostPerturbation</h4>
<pre>boolean&nbsp;hasRelativeMaxCostPerturbation()</pre>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the relativeMaxCostPerturbation field is set.</dd>
</dl>
</li>
</ul>
<a name="getRelativeMaxCostPerturbation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRelativeMaxCostPerturbation</h4>
<pre>double&nbsp;getRelativeMaxCostPerturbation()</pre>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The relativeMaxCostPerturbation.</dd>
</dl>
</li>
</ul>
<a name="hasInitialConditionNumberThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialConditionNumberThreshold</h4>
<pre>boolean&nbsp;hasInitialConditionNumberThreshold()</pre>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialConditionNumberThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getInitialConditionNumberThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialConditionNumberThreshold</h4>
<pre>double&nbsp;getInitialConditionNumberThreshold()</pre>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialConditionNumberThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasLogSearchProgress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogSearchProgress</h4>
<pre>boolean&nbsp;hasLogSearchProgress()</pre>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logSearchProgress field is set.</dd>
</dl>
</li>
</ul>
<a name="getLogSearchProgress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogSearchProgress</h4>
<pre>boolean&nbsp;getLogSearchProgress()</pre>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logSearchProgress.</dd>
</dl>
</li>
</ul>
<a name="hasLogToStdout--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogToStdout</h4>
<pre>boolean&nbsp;hasLogToStdout()</pre>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logToStdout field is set.</dd>
</dl>
</li>
</ul>
<a name="getLogToStdout--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogToStdout</h4>
<pre>boolean&nbsp;getLogToStdout()</pre>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logToStdout.</dd>
</dl>
</li>
</ul>
<a name="hasCrossoverBoundSnappingDistance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCrossoverBoundSnappingDistance</h4>
<pre>boolean&nbsp;hasCrossoverBoundSnappingDistance()</pre>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.

 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.

 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().

 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the crossoverBoundSnappingDistance field is set.</dd>
</dl>
</li>
</ul>
<a name="getCrossoverBoundSnappingDistance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCrossoverBoundSnappingDistance</h4>
<pre>double&nbsp;getCrossoverBoundSnappingDistance()</pre>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.

 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.

 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().

 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The crossoverBoundSnappingDistance.</dd>
</dl>
</li>
</ul>
<a name="hasPushToVertex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPushToVertex</h4>
<pre>boolean&nbsp;hasPushToVertex()</pre>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the pushToVertex field is set.</dd>
</dl>
</li>
</ul>
<a name="getPushToVertex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPushToVertex</h4>
<pre>boolean&nbsp;getPushToVertex()</pre>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The pushToVertex.</dd>
</dl>
</li>
</ul>
<a name="hasUseImpliedFreePreprocessor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseImpliedFreePreprocessor</h4>
<pre>boolean&nbsp;hasUseImpliedFreePreprocessor()</pre>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useImpliedFreePreprocessor field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseImpliedFreePreprocessor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseImpliedFreePreprocessor</h4>
<pre>boolean&nbsp;getUseImpliedFreePreprocessor()</pre>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useImpliedFreePreprocessor.</dd>
</dl>
</li>
</ul>
<a name="hasMaxValidMagnitude--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxValidMagnitude</h4>
<pre>boolean&nbsp;hasMaxValidMagnitude()</pre>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 70 [default = 1e+30];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxValidMagnitude field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxValidMagnitude--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxValidMagnitude</h4>
<pre>double&nbsp;getMaxValidMagnitude()</pre>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 70 [default = 1e+30];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxValidMagnitude.</dd>
</dl>
</li>
</ul>
<a name="hasDropMagnitude--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDropMagnitude</h4>
<pre>boolean&nbsp;hasDropMagnitude()</pre>
<div class="block"><pre>
 Value in the input LP lower than this will be ignored. This is similar to
 drop_tolerance but more aggressive as this is used before scaling. This is
 mainly here to avoid underflow and have simpler invariant in the code, like
 a * b == 0 iff a or b is zero and things like this.
 </pre>

 <code>optional double drop_magnitude = 71 [default = 1e-30];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dropMagnitude field is set.</dd>
</dl>
</li>
</ul>
<a name="getDropMagnitude--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDropMagnitude</h4>
<pre>double&nbsp;getDropMagnitude()</pre>
<div class="block"><pre>
 Value in the input LP lower than this will be ignored. This is similar to
 drop_tolerance but more aggressive as this is used before scaling. This is
 mainly here to avoid underflow and have simpler invariant in the code, like
 a * b == 0 iff a or b is zero and things like this.
 </pre>

 <code>optional double drop_magnitude = 71 [default = 1e-30];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dropMagnitude.</dd>
</dl>
</li>
</ul>
<a name="hasDualPricePrioritizeNorm--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDualPricePrioritizeNorm</h4>
<pre>boolean&nbsp;hasDualPricePrioritizeNorm()</pre>
<div class="block"><pre>
 On some problem like stp3d or pds-100 this makes a huge difference in
 speed and number of iterations of the dual simplex.
 </pre>

 <code>optional bool dual_price_prioritize_norm = 69 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the dualPricePrioritizeNorm field is set.</dd>
</dl>
</li>
</ul>
<a name="getDualPricePrioritizeNorm--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getDualPricePrioritizeNorm</h4>
<pre>boolean&nbsp;getDualPricePrioritizeNorm()</pre>
<div class="block"><pre>
 On some problem like stp3d or pds-100 this makes a huge difference in
 speed and number of iterations of the dual simplex.
 </pre>

 <code>optional bool dual_price_prioritize_norm = 69 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The dualPricePrioritizeNorm.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GlopParametersOrBuilder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/ortools/glop/GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/google/ortools/glop/Parameters.html" title="class in com.google.ortools.glop"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/ortools/glop/GlopParametersOrBuilder.html" target="_top">Frames</a></li>
<li><a href="GlopParametersOrBuilder.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2024. All rights reserved.</small></p>
</body>
</html>
