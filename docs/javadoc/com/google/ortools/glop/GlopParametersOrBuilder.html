<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) on Thu Mar 03 21:59:09 CET 2022 -->
<title>GlopParametersOrBuilder (com.google.ortools:ortools-java 9.3.10440 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-03-03">
<meta name="description" content="declaration: package: com.google.ortools.glop, interface: GlopParametersOrBuilder">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/GlopParametersOrBuilder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.google.ortools.glop</a></div>
<h1 title="Interface GlopParametersOrBuilder" class="title">Interface GlopParametersOrBuilder</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Superinterfaces:</dt>
<dd><code>com.google.protobuf.MessageLiteOrBuilder</code>, <code>com.google.protobuf.MessageOrBuilder</code></dd>
</dl>
<dl class="notes">
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="GlopParameters.html" title="class in com.google.ortools.glop">GlopParameters</a></code>, <code><a href="GlopParameters.Builder.html" title="class in com.google.ortools.glop">GlopParameters.Builder</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">GlopParametersOrBuilder</span><span class="extends-implements">
extends com.google.protobuf.MessageOrBuilder</span></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getAllowSimplexAlgorithmChange()" class="member-name-link">getAllowSimplexAlgorithmChange</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getBasisRefactorizationPeriod()" class="member-name-link">getBasisRefactorizationPeriod</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getChangeStatusToImprecise()" class="member-name-link">getChangeStatusToImprecise</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getCostScaling()" class="member-name-link">getCostScaling</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getCrossoverBoundSnappingDistance()" class="member-name-link">getCrossoverBoundSnappingDistance</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getDegenerateMinistepFactor()" class="member-name-link">getDegenerateMinistepFactor</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getDevexWeightsResetPeriod()" class="member-name-link">getDevexWeightsResetPeriod</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getDropTolerance()" class="member-name-link">getDropTolerance</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getDualFeasibilityTolerance()" class="member-name-link">getDualFeasibilityTolerance</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getDualizerThreshold()" class="member-name-link">getDualizerThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getDualSmallPivotThreshold()" class="member-name-link">getDualSmallPivotThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getDynamicallyAdjustRefactorizationPeriod()" class="member-name-link">getDynamicallyAdjustRefactorizationPeriod</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getExploitSingletonColumnInInitialBasis()" class="member-name-link">getExploitSingletonColumnInInitialBasis</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getFeasibilityRule()" class="member-name-link">getFeasibilityRule</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getHarrisToleranceRatio()" class="member-name-link">getHarrisToleranceRatio</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getInitialBasis()" class="member-name-link">getInitialBasis</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getInitialConditionNumberThreshold()" class="member-name-link">getInitialConditionNumberThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getInitializeDevexWithColumnNorms()" class="member-name-link">getInitializeDevexWithColumnNorms</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getLogSearchProgress()" class="member-name-link">getLogSearchProgress</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getLogToStdout()" class="member-name-link">getLogToStdout</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getLuFactorizationPivotThreshold()" class="member-name-link">getLuFactorizationPivotThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMarkowitzSingularityThreshold()" class="member-name-link">getMarkowitzSingularityThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMarkowitzZlatevParameter()" class="member-name-link">getMarkowitzZlatevParameter</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMaxDeterministicTime()" class="member-name-link">getMaxDeterministicTime</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMaxNumberOfIterations()" class="member-name-link">getMaxNumberOfIterations</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMaxNumberOfReoptimizations()" class="member-name-link">getMaxNumberOfReoptimizations</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMaxTimeInSeconds()" class="member-name-link">getMaxTimeInSeconds</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMaxValidMagnitude()" class="member-name-link">getMaxValidMagnitude</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getMinimumAcceptablePivot()" class="member-name-link">getMinimumAcceptablePivot</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getNumOmpThreads()" class="member-name-link">getNumOmpThreads</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getObjectiveLowerLimit()" class="member-name-link">getObjectiveLowerLimit</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getObjectiveUpperLimit()" class="member-name-link">getObjectiveUpperLimit</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getOptimizationRule()" class="member-name-link">getOptimizationRule</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 PricingRule to use during the optimization phase.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getPerturbCostsInDualSimplex()" class="member-name-link">getPerturbCostsInDualSimplex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getPreprocessorZeroTolerance()" class="member-name-link">getPreprocessorZeroTolerance</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getPrimalFeasibilityTolerance()" class="member-name-link">getPrimalFeasibilityTolerance</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getProvideStrongOptimalGuarantee()" class="member-name-link">getProvideStrongOptimalGuarantee</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getPushToVertex()" class="member-name-link">getPushToVertex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getRandomSeed()" class="member-name-link">getRandomSeed</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getRatioTestZeroThreshold()" class="member-name-link">getRatioTestZeroThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 During the primal simplex (resp.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getRecomputeEdgesNormThreshold()" class="member-name-link">getRecomputeEdgesNormThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getRecomputeReducedCostsThreshold()" class="member-name-link">getRecomputeReducedCostsThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getRefactorizationThreshold()" class="member-name-link">getRefactorizationThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getRelativeCostPerturbation()" class="member-name-link">getRelativeCostPerturbation</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getRelativeMaxCostPerturbation()" class="member-name-link">getRelativeMaxCostPerturbation</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getScalingMethod()" class="member-name-link">getScalingMethod</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getSmallPivotThreshold()" class="member-name-link">getSmallPivotThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getSolutionFeasibilityTolerance()" class="member-name-link">getSolutionFeasibilityTolerance</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getSolveDualProblem()" class="member-name-link">getSolveDualProblem</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getUseDedicatedDualFeasibilityAlgorithm()" class="member-name-link">getUseDedicatedDualFeasibilityAlgorithm</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We have two possible dual phase I algorithms.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getUseDualSimplex()" class="member-name-link">getUseDualSimplex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getUseImpliedFreePreprocessor()" class="member-name-link">getUseImpliedFreePreprocessor</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getUseMiddleProductFormUpdate()" class="member-name-link">getUseMiddleProductFormUpdate</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getUsePreprocessing()" class="member-name-link">getUsePreprocessing</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getUseScaling()" class="member-name-link">getUseScaling</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#getUseTransposedMatrix()" class="member-name-link">getUseTransposedMatrix</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasAllowSimplexAlgorithmChange()" class="member-name-link">hasAllowSimplexAlgorithmChange</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasBasisRefactorizationPeriod()" class="member-name-link">hasBasisRefactorizationPeriod</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Number of iterations between two basis refactorizations.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasChangeStatusToImprecise()" class="member-name-link">hasChangeStatusToImprecise</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasCostScaling()" class="member-name-link">hasCostScaling</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasCrossoverBoundSnappingDistance()" class="member-name-link">hasCrossoverBoundSnappingDistance</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasDegenerateMinistepFactor()" class="member-name-link">hasDegenerateMinistepFactor</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasDevexWeightsResetPeriod()" class="member-name-link">hasDevexWeightsResetPeriod</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Devex weights will be reset to 1.0 after that number of updates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasDropTolerance()" class="member-name-link">hasDropTolerance</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasDualFeasibilityTolerance()" class="member-name-link">hasDualFeasibilityTolerance</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasDualizerThreshold()" class="member-name-link">hasDualizerThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasDualSmallPivotThreshold()" class="member-name-link">hasDualSmallPivotThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Like small_pivot_threshold but for the dual simplex.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasDynamicallyAdjustRefactorizationPeriod()" class="member-name-link">hasDynamicallyAdjustRefactorizationPeriod</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasExploitSingletonColumnInInitialBasis()" class="member-name-link">hasExploitSingletonColumnInInitialBasis</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasFeasibilityRule()" class="member-name-link">hasFeasibilityRule</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 PricingRule to use during the feasibility phase.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasHarrisToleranceRatio()" class="member-name-link">hasHarrisToleranceRatio</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasInitialBasis()" class="member-name-link">hasInitialBasis</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasInitialConditionNumberThreshold()" class="member-name-link">hasInitialConditionNumberThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasInitializeDevexWithColumnNorms()" class="member-name-link">hasInitializeDevexWithColumnNorms</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasLogSearchProgress()" class="member-name-link">hasLogSearchProgress</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, logs the progress of a solve to LOG(INFO).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasLogToStdout()" class="member-name-link">hasLogToStdout</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, logs will be displayed to stdout instead of using Google log info.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasLuFactorizationPivotThreshold()" class="member-name-link">hasLuFactorizationPivotThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMarkowitzSingularityThreshold()" class="member-name-link">hasMarkowitzSingularityThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMarkowitzZlatevParameter()" class="member-name-link">hasMarkowitzZlatevParameter</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMaxDeterministicTime()" class="member-name-link">hasMaxDeterministicTime</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Maximum deterministic time allowed to solve a problem.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMaxNumberOfIterations()" class="member-name-link">hasMaxNumberOfIterations</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Maximum number of simplex iterations to solve a problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMaxNumberOfReoptimizations()" class="member-name-link">hasMaxNumberOfReoptimizations</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMaxTimeInSeconds()" class="member-name-link">hasMaxTimeInSeconds</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMaxValidMagnitude()" class="member-name-link">hasMaxValidMagnitude</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasMinimumAcceptablePivot()" class="member-name-link">hasMinimumAcceptablePivot</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We never follow a basis change with a pivot under this threshold.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasNumOmpThreads()" class="member-name-link">hasNumOmpThreads</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Number of threads in the OMP parallel sections.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasObjectiveLowerLimit()" class="member-name-link">hasObjectiveLowerLimit</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasObjectiveUpperLimit()" class="member-name-link">hasObjectiveUpperLimit</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasOptimizationRule()" class="member-name-link">hasOptimizationRule</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 PricingRule to use during the optimization phase.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasPerturbCostsInDualSimplex()" class="member-name-link">hasPerturbCostsInDualSimplex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasPreprocessorZeroTolerance()" class="member-name-link">hasPreprocessorZeroTolerance</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 A floating point tolerance used by the preprocessors.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasPrimalFeasibilityTolerance()" class="member-name-link">hasPrimalFeasibilityTolerance</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasProvideStrongOptimalGuarantee()" class="member-name-link">hasProvideStrongOptimalGuarantee</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasPushToVertex()" class="member-name-link">hasPushToVertex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasRandomSeed()" class="member-name-link">hasRandomSeed</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasRatioTestZeroThreshold()" class="member-name-link">hasRatioTestZeroThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 During the primal simplex (resp.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasRecomputeEdgesNormThreshold()" class="member-name-link">hasRecomputeEdgesNormThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasRecomputeReducedCostsThreshold()" class="member-name-link">hasRecomputeReducedCostsThreshold</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We estimate the accuracy of the iteratively computed reduced costs.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasRefactorizationThreshold()" class="member-name-link">hasRefactorizationThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasRelativeCostPerturbation()" class="member-name-link">hasRelativeCostPerturbation</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasRelativeMaxCostPerturbation()" class="member-name-link">hasRelativeMaxCostPerturbation</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasScalingMethod()" class="member-name-link">hasScalingMethod</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasSmallPivotThreshold()" class="member-name-link">hasSmallPivotThreshold</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasSolutionFeasibilityTolerance()" class="member-name-link">hasSolutionFeasibilityTolerance</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasSolveDualProblem()" class="member-name-link">hasSolveDualProblem</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we solve the dual of the given problem.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasUseDedicatedDualFeasibilityAlgorithm()" class="member-name-link">hasUseDedicatedDualFeasibilityAlgorithm</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 We have two possible dual phase I algorithms.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasUseDualSimplex()" class="member-name-link">hasUseDualSimplex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we use the dual simplex algorithm instead of the primal.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasUseImpliedFreePreprocessor()" class="member-name-link">hasUseImpliedFreePreprocessor</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 If presolve runs, include the pass that detects implied free variables.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasUseMiddleProductFormUpdate()" class="member-name-link">hasUseMiddleProductFormUpdate</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not to use the middle product form update rather than the
 standard eta LU update.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasUsePreprocessing()" class="member-name-link">hasUsePreprocessing</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we use advanced preprocessing techniques.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasUseScaling()" class="member-name-link">hasUseScaling</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hasUseTransposedMatrix()" class="member-name-link">hasUseTransposedMatrix</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-com.google.protobuf.MessageLiteOrBuilder">Methods inherited from interface&nbsp;com.google.protobuf.MessageLiteOrBuilder</h3>
<code>isInitialized</code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-com.google.protobuf.MessageOrBuilder">Methods inherited from interface&nbsp;com.google.protobuf.MessageOrBuilder</h3>
<code>findInitializationErrors, getAllFields, getDefaultInstanceForType, getDescriptorForType, getField, getInitializationErrorString, getOneofFieldDescriptor, getRepeatedField, getRepeatedFieldCount, getUnknownFields, hasField, hasOneof</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="hasScalingMethod()">
<h3>hasScalingMethod</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasScalingMethod</span>()</div>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the scalingMethod field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getScalingMethod()">
<h3>getScalingMethod</h3>
<div class="member-signature"><span class="return-type"><a href="GlopParameters.ScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.ScalingAlgorithm</a></span>&nbsp;<span class="element-name">getScalingMethod</span>()</div>
<div class="block"><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The scalingMethod.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasFeasibilityRule()">
<h3>hasFeasibilityRule</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasFeasibilityRule</span>()</div>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the feasibilityRule field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getFeasibilityRule()">
<h3>getFeasibilityRule</h3>
<div class="member-signature"><span class="return-type"><a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></span>&nbsp;<span class="element-name">getFeasibilityRule</span>()</div>
<div class="block"><pre>
 PricingRule to use during the feasibility phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The feasibilityRule.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasOptimizationRule()">
<h3>hasOptimizationRule</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasOptimizationRule</span>()</div>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the optimizationRule field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getOptimizationRule()">
<h3>getOptimizationRule</h3>
<div class="member-signature"><span class="return-type"><a href="GlopParameters.PricingRule.html" title="enum in com.google.ortools.glop">GlopParameters.PricingRule</a></span>&nbsp;<span class="element-name">getOptimizationRule</span>()</div>
<div class="block"><pre>
 PricingRule to use during the optimization phase.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The optimizationRule.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasRefactorizationThreshold()">
<h3>hasRefactorizationThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasRefactorizationThreshold</span>()</div>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the refactorizationThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRefactorizationThreshold()">
<h3>getRefactorizationThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getRefactorizationThreshold</span>()</div>
<div class="block"><pre>
 We estimate the factorization accuracy of B during each pivot by using
 the fact that we can compute the pivot coefficient in two ways:
 - From direction[leaving_row].
 - From update_row[entering_column].
 If the two values have a relative difference above this threshold, we
 trigger a refactorization.
 </pre>

 <code>optional double refactorization_threshold = 6 [default = 1e-09];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The refactorizationThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasRecomputeReducedCostsThreshold()">
<h3>hasRecomputeReducedCostsThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasRecomputeReducedCostsThreshold</span>()</div>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the recomputeReducedCostsThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRecomputeReducedCostsThreshold()">
<h3>getRecomputeReducedCostsThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getRecomputeReducedCostsThreshold</span>()</div>
<div class="block"><pre>
 We estimate the accuracy of the iteratively computed reduced costs. If
 it falls below this threshold, we reinitialize them from scratch. Note
 that such an operation is pretty fast, so we can use a low threshold.
 It is important to have a good accuracy here (better than the
 dual_feasibility_tolerance below) to be sure of the sign of such a cost.
 </pre>

 <code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The recomputeReducedCostsThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasRecomputeEdgesNormThreshold()">
<h3>hasRecomputeEdgesNormThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasRecomputeEdgesNormThreshold</span>()</div>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the recomputeEdgesNormThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRecomputeEdgesNormThreshold()">
<h3>getRecomputeEdgesNormThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getRecomputeEdgesNormThreshold</span>()</div>
<div class="block"><pre>
 Note that the threshold is a relative error on the actual norm (not the
 squared one) and that edge norms are always greater than 1. Recomputing
 norms is a really expensive operation and a large threshold is ok since
 this doesn't impact directly the solution but just the entering variable
 choice.
 </pre>

 <code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The recomputeEdgesNormThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasPrimalFeasibilityTolerance()">
<h3>hasPrimalFeasibilityTolerance</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasPrimalFeasibilityTolerance</span>()</div>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.
 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the primalFeasibilityTolerance field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getPrimalFeasibilityTolerance()">
<h3>getPrimalFeasibilityTolerance</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getPrimalFeasibilityTolerance</span>()</div>
<div class="block"><pre>
 This tolerance indicates by how much we allow the variable values to go out
 of bounds and still consider the current solution primal-feasible. We also
 use the same tolerance for the error A.x - b. Note that the two errors are
 closely related if A is scaled in such a way that the greatest coefficient
 magnitude on each column is 1.0.
 This is also simply called feasibility tolerance in other solvers.
 </pre>

 <code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The primalFeasibilityTolerance.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasDualFeasibilityTolerance()">
<h3>hasDualFeasibilityTolerance</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasDualFeasibilityTolerance</span>()</div>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.
 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.
 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the dualFeasibilityTolerance field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getDualFeasibilityTolerance()">
<h3>getDualFeasibilityTolerance</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getDualFeasibilityTolerance</span>()</div>
<div class="block"><pre>
 Variables whose reduced costs have an absolute value smaller than this
 tolerance are not considered as entering candidates. That is they do not
 take part in deciding whether a solution is dual-feasible or not.
 Note that this value can temporarily increase during the execution of the
 algorithm if the estimated precision of the reduced costs is higher than
 this tolerance. Note also that we scale the costs (in the presolve step) so
 that the cost magnitude range contains one.
 This is also known as the optimality tolerance in other solvers.
 </pre>

 <code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The dualFeasibilityTolerance.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasRatioTestZeroThreshold()">
<h3>hasRatioTestZeroThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasRatioTestZeroThreshold</span>()</div>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.
 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the ratioTestZeroThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRatioTestZeroThreshold()">
<h3>getRatioTestZeroThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getRatioTestZeroThreshold</span>()</div>
<div class="block"><pre>
 During the primal simplex (resp. dual simplex), the coefficients of the
 direction (resp. update row) with a magnitude lower than this threshold are
 not considered during the ratio test. This tolerance is related to the
 precision at which a Solve() involving the basis matrix can be performed.
 TODO(user): Automatically increase it when we detect that the precision
 of the Solve() is worse than this.
 </pre>

 <code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The ratioTestZeroThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasHarrisToleranceRatio()">
<h3>hasHarrisToleranceRatio</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasHarrisToleranceRatio</span>()</div>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.
 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the harrisToleranceRatio field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getHarrisToleranceRatio()">
<h3>getHarrisToleranceRatio</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getHarrisToleranceRatio</span>()</div>
<div class="block"><pre>
 This impacts the ratio test and indicates by how much we allow a basic
 variable value that we move to go out of bounds. The value should be in
 [0.0, 1.0) and should be interpreted as a ratio of the
 primal_feasibility_tolerance. Setting this to 0.0 basically disables the
 Harris ratio test while setting this too close to 1.0 will make it
 difficult to keep the variable values inside their bounds modulo the
 primal_feasibility_tolerance.
 Note that the same comment applies to the dual simplex ratio test. There,
 we allow the reduced costs to be of an infeasible sign by as much as this
 ratio times the dual_feasibility_tolerance.
 </pre>

 <code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The harrisToleranceRatio.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasSmallPivotThreshold()">
<h3>hasSmallPivotThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasSmallPivotThreshold</span>()</div>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the smallPivotThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSmallPivotThreshold()">
<h3>getSmallPivotThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getSmallPivotThreshold</span>()</div>
<div class="block"><pre>
 When we choose the leaving variable, we want to avoid small pivot because
 they are the less precise and may cause numerical instabilities. For a
 pivot under this threshold times the infinity norm of the direction, we try
 various countermeasures in order to avoid using it.
 </pre>

 <code>optional double small_pivot_threshold = 14 [default = 1e-06];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The smallPivotThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMinimumAcceptablePivot()">
<h3>hasMinimumAcceptablePivot</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMinimumAcceptablePivot</span>()</div>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the minimumAcceptablePivot field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMinimumAcceptablePivot()">
<h3>getMinimumAcceptablePivot</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getMinimumAcceptablePivot</span>()</div>
<div class="block"><pre>
 We never follow a basis change with a pivot under this threshold.
 </pre>

 <code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The minimumAcceptablePivot.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasDropTolerance()">
<h3>hasDropTolerance</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasDropTolerance</span>()</div>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the dropTolerance field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getDropTolerance()">
<h3>getDropTolerance</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getDropTolerance</span>()</div>
<div class="block"><pre>
 In order to increase the sparsity of the manipulated vectors, floating
 point values with a magnitude smaller than this parameter are set to zero
 (only in some places). This parameter should be positive or zero.
 </pre>

 <code>optional double drop_tolerance = 52 [default = 1e-14];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The dropTolerance.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasUseScaling()">
<h3>hasUseScaling</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasUseScaling</span>()</div>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the useScaling field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getUseScaling()">
<h3>getUseScaling</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getUseScaling</span>()</div>
<div class="block"><pre>
 Whether or not we scale the matrix A so that the maximum coefficient on
 each line and each column is 1.0.
 </pre>

 <code>optional bool use_scaling = 16 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The useScaling.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasCostScaling()">
<h3>hasCostScaling</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasCostScaling</span>()</div>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the costScaling field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getCostScaling()">
<h3>getCostScaling</h3>
<div class="member-signature"><span class="return-type"><a href="GlopParameters.CostScalingAlgorithm.html" title="enum in com.google.ortools.glop">GlopParameters.CostScalingAlgorithm</a></span>&nbsp;<span class="element-name">getCostScaling</span>()</div>
<div class="block"><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The costScaling.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasInitialBasis()">
<h3>hasInitialBasis</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasInitialBasis</span>()</div>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the initialBasis field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getInitialBasis()">
<h3>getInitialBasis</h3>
<div class="member-signature"><span class="return-type"><a href="GlopParameters.InitialBasisHeuristic.html" title="enum in com.google.ortools.glop">GlopParameters.InitialBasisHeuristic</a></span>&nbsp;<span class="element-name">getInitialBasis</span>()</div>
<div class="block"><pre>
 What heuristic is used to try to replace the fixed slack columns in the
 initial basis of the primal simplex.
 </pre>

 <code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The initialBasis.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasUseTransposedMatrix()">
<h3>hasUseTransposedMatrix</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasUseTransposedMatrix</span>()</div>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the useTransposedMatrix field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getUseTransposedMatrix()">
<h3>getUseTransposedMatrix</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getUseTransposedMatrix</span>()</div>
<div class="block"><pre>
 Whether or not we keep a transposed version of the matrix A to speed-up the
 pricing at the cost of extra memory and the initial tranposition
 computation.
 </pre>

 <code>optional bool use_transposed_matrix = 18 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The useTransposedMatrix.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasBasisRefactorizationPeriod()">
<h3>hasBasisRefactorizationPeriod</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasBasisRefactorizationPeriod</span>()</div>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the basisRefactorizationPeriod field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getBasisRefactorizationPeriod()">
<h3>getBasisRefactorizationPeriod</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">getBasisRefactorizationPeriod</span>()</div>
<div class="block"><pre>
 Number of iterations between two basis refactorizations. Note that various
 conditions in the algorithm may trigger a refactorization before this
 period is reached. Set this to 0 if you want to refactorize at each step.
 </pre>

 <code>optional int32 basis_refactorization_period = 19 [default = 64];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The basisRefactorizationPeriod.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasDynamicallyAdjustRefactorizationPeriod()">
<h3>hasDynamicallyAdjustRefactorizationPeriod</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasDynamicallyAdjustRefactorizationPeriod</span>()</div>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the dynamicallyAdjustRefactorizationPeriod field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getDynamicallyAdjustRefactorizationPeriod()">
<h3>getDynamicallyAdjustRefactorizationPeriod</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getDynamicallyAdjustRefactorizationPeriod</span>()</div>
<div class="block"><pre>
 If this is true, then basis_refactorization_period becomes a lower bound on
 the number of iterations between two refactorization (provided there is no
 numerical accuracy issues). Depending on the estimated time to refactorize
 vs the extra time spend in each solves because of the LU update, we try to
 balance the two times.
 </pre>

 <code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The dynamicallyAdjustRefactorizationPeriod.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasSolveDualProblem()">
<h3>hasSolveDualProblem</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasSolveDualProblem</span>()</div>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the solveDualProblem field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSolveDualProblem()">
<h3>getSolveDualProblem</h3>
<div class="member-signature"><span class="return-type"><a href="GlopParameters.SolverBehavior.html" title="enum in com.google.ortools.glop">GlopParameters.SolverBehavior</a></span>&nbsp;<span class="element-name">getSolveDualProblem</span>()</div>
<div class="block"><pre>
 Whether or not we solve the dual of the given problem.
 With a value of auto, the algorithm decide which approach is probably the
 fastest depending on the problem dimensions (see dualizer_threshold).
 </pre>

 <code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The solveDualProblem.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasDualizerThreshold()">
<h3>hasDualizerThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasDualizerThreshold</span>()</div>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the dualizerThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getDualizerThreshold()">
<h3>getDualizerThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getDualizerThreshold</span>()</div>
<div class="block"><pre>
 When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
 of constraints of the problem is more than this threshold times the number
 of variables.
 </pre>

 <code>optional double dualizer_threshold = 21 [default = 1.5];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The dualizerThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasSolutionFeasibilityTolerance()">
<h3>hasSolutionFeasibilityTolerance</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasSolutionFeasibilityTolerance</span>()</div>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.
 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the solutionFeasibilityTolerance field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSolutionFeasibilityTolerance()">
<h3>getSolutionFeasibilityTolerance</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getSolutionFeasibilityTolerance</span>()</div>
<div class="block"><pre>
 When the problem status is OPTIMAL, we check the optimality using this
 relative tolerance and change the status to IMPRECISE if an issue is
 detected.
 The tolerance is "relative" in the sense that our thresholds are:
 - tolerance * max(1.0, abs(bound)) for crossing a given bound.
 - tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
 - tolerance for an infeasible dual value.
 </pre>

 <code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The solutionFeasibilityTolerance.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasProvideStrongOptimalGuarantee()">
<h3>hasProvideStrongOptimalGuarantee</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasProvideStrongOptimalGuarantee</span>()</div>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
   component of the objective function a bit, then the pair (primal values,
   dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
   defined in the comment for solution_feasibility_tolerance (*).
 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.
 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the provideStrongOptimalGuarantee field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getProvideStrongOptimalGuarantee()">
<h3>getProvideStrongOptimalGuarantee</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getProvideStrongOptimalGuarantee</span>()</div>
<div class="block"><pre>
 If true, then when the solver returns a solution with an OPTIMAL status,
 we can guarantee that:
 - The primal variable are in their bounds.
 - The dual variable are in their bounds.
 - If we modify each component of the right-hand side a bit and each
   component of the objective function a bit, then the pair (primal values,
   dual values) is an EXACT optimal solution of the perturbed problem.
 - The modifications above are smaller than the associated tolerances as
   defined in the comment for solution_feasibility_tolerance (*).
 (*): This is the only place where the guarantee is not tight since we
 compute the upper bounds with scalar product of the primal/dual
 solution and the initial problem coefficients with only double precision.
 Note that whether or not this option is true, we still check the
 primal/dual infeasibility and objective gap. However if it is false, we
 don't move the primal/dual values within their bounds and leave them
 untouched.
 </pre>

 <code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The provideStrongOptimalGuarantee.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasChangeStatusToImprecise()">
<h3>hasChangeStatusToImprecise</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasChangeStatusToImprecise</span>()</div>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the changeStatusToImprecise field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getChangeStatusToImprecise()">
<h3>getChangeStatusToImprecise</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getChangeStatusToImprecise</span>()</div>
<div class="block"><pre>
 If true, the internal API will change the return status to imprecise if the
 solution does not respect the internal tolerances.
 </pre>

 <code>optional bool change_status_to_imprecise = 58 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The changeStatusToImprecise.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMaxNumberOfReoptimizations()">
<h3>hasMaxNumberOfReoptimizations</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMaxNumberOfReoptimizations</span>()</div>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the maxNumberOfReoptimizations field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMaxNumberOfReoptimizations()">
<h3>getMaxNumberOfReoptimizations</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getMaxNumberOfReoptimizations</span>()</div>
<div class="block"><pre>
 When the solution of phase II is imprecise, we re-run the phase II with the
 opposite algorithm from that imprecise solution (i.e., if primal or dual
 simplex was used, we use dual or primal simplex, respectively). We repeat
 such re-optimization until the solution is precise, or we hit this limit.
 </pre>

 <code>optional double max_number_of_reoptimizations = 56 [default = 40];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The maxNumberOfReoptimizations.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasLuFactorizationPivotThreshold()">
<h3>hasLuFactorizationPivotThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasLuFactorizationPivotThreshold</span>()</div>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the luFactorizationPivotThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getLuFactorizationPivotThreshold()">
<h3>getLuFactorizationPivotThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getLuFactorizationPivotThreshold</span>()</div>
<div class="block"><pre>
 Threshold for LU-factorization: for stability reasons, the magnitude of the
 chosen pivot at a given step is guaranteed to be greater than this
 threshold times the maximum magnitude of all the possible pivot choices in
 the same column. The value must be in [0,1].
 </pre>

 <code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The luFactorizationPivotThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMaxTimeInSeconds()">
<h3>hasMaxTimeInSeconds</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMaxTimeInSeconds</span>()</div>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the maxTimeInSeconds field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMaxTimeInSeconds()">
<h3>getMaxTimeInSeconds</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getMaxTimeInSeconds</span>()</div>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 </pre>

 <code>optional double max_time_in_seconds = 26 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The maxTimeInSeconds.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMaxDeterministicTime()">
<h3>hasMaxDeterministicTime</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMaxDeterministicTime</span>()</div>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).
 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the maxDeterministicTime field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMaxDeterministicTime()">
<h3>getMaxDeterministicTime</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getMaxDeterministicTime</span>()</div>
<div class="block"><pre>
 Maximum deterministic time allowed to solve a problem. The deterministic
 time is more or less correlated to the running time, and its unit should
 be around the second (at least on a Xeon(R) CPU E5-1650 v2 &#64; 3.50GHz).
 TODO(user): Improve the correlation.
 </pre>

 <code>optional double max_deterministic_time = 45 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The maxDeterministicTime.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMaxNumberOfIterations()">
<h3>hasMaxNumberOfIterations</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMaxNumberOfIterations</span>()</div>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the maxNumberOfIterations field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMaxNumberOfIterations()">
<h3>getMaxNumberOfIterations</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="element-name">getMaxNumberOfIterations</span>()</div>
<div class="block"><pre>
 Maximum number of simplex iterations to solve a problem.
 A value of -1 means no limit.
 </pre>

 <code>optional int64 max_number_of_iterations = 27 [default = -1];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The maxNumberOfIterations.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMarkowitzZlatevParameter()">
<h3>hasMarkowitzZlatevParameter</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMarkowitzZlatevParameter</span>()</div>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the markowitzZlatevParameter field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMarkowitzZlatevParameter()">
<h3>getMarkowitzZlatevParameter</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">getMarkowitzZlatevParameter</span>()</div>
<div class="block"><pre>
 How many columns do we look at in the Markowitz pivoting rule to find
 a good pivot. See markowitz.h.
 </pre>

 <code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The markowitzZlatevParameter.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMarkowitzSingularityThreshold()">
<h3>hasMarkowitzSingularityThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMarkowitzSingularityThreshold</span>()</div>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the markowitzSingularityThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMarkowitzSingularityThreshold()">
<h3>getMarkowitzSingularityThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getMarkowitzSingularityThreshold</span>()</div>
<div class="block"><pre>
 If a pivot magnitude is smaller than this during the Markowitz LU
 factorization, then the matrix is assumed to be singular. Note that
 this is an absolute threshold and is not relative to the other possible
 pivots on the same column (see lu_factorization_pivot_threshold).
 </pre>

 <code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The markowitzSingularityThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasUseDualSimplex()">
<h3>hasUseDualSimplex</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasUseDualSimplex</span>()</div>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the useDualSimplex field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getUseDualSimplex()">
<h3>getUseDualSimplex</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getUseDualSimplex</span>()</div>
<div class="block"><pre>
 Whether or not we use the dual simplex algorithm instead of the primal.
 </pre>

 <code>optional bool use_dual_simplex = 31 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The useDualSimplex.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasAllowSimplexAlgorithmChange()">
<h3>hasAllowSimplexAlgorithmChange</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasAllowSimplexAlgorithmChange</span>()</div>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the allowSimplexAlgorithmChange field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getAllowSimplexAlgorithmChange()">
<h3>getAllowSimplexAlgorithmChange</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getAllowSimplexAlgorithmChange</span>()</div>
<div class="block"><pre>
 During incremental solve, let the solver decide if it use the primal or
 dual simplex algorithm depending on the current solution and on the new
 problem. Note that even if this is true, the value of use_dual_simplex
 still indicates the default algorithm that the solver will use.
 </pre>

 <code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The allowSimplexAlgorithmChange.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasDevexWeightsResetPeriod()">
<h3>hasDevexWeightsResetPeriod</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasDevexWeightsResetPeriod</span>()</div>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the devexWeightsResetPeriod field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getDevexWeightsResetPeriod()">
<h3>getDevexWeightsResetPeriod</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">getDevexWeightsResetPeriod</span>()</div>
<div class="block"><pre>
 Devex weights will be reset to 1.0 after that number of updates.
 </pre>

 <code>optional int32 devex_weights_reset_period = 33 [default = 150];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The devexWeightsResetPeriod.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasUsePreprocessing()">
<h3>hasUsePreprocessing</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasUsePreprocessing</span>()</div>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the usePreprocessing field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getUsePreprocessing()">
<h3>getUsePreprocessing</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getUsePreprocessing</span>()</div>
<div class="block"><pre>
 Whether or not we use advanced preprocessing techniques.
 </pre>

 <code>optional bool use_preprocessing = 34 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The usePreprocessing.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasUseMiddleProductFormUpdate()">
<h3>hasUseMiddleProductFormUpdate</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasUseMiddleProductFormUpdate</span>()</div>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the useMiddleProductFormUpdate field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getUseMiddleProductFormUpdate()">
<h3>getUseMiddleProductFormUpdate</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getUseMiddleProductFormUpdate</span>()</div>
<div class="block"><pre>
 Whether or not to use the middle product form update rather than the
 standard eta LU update. The middle form product update should be a lot more
 efficient (close to the Forrest-Tomlin update, a bit slower but easier to
 implement). See for more details:
 Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
 simplex method", 28 january 2013, Technical Report ERGO-13-0001
 http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf
 </pre>

 <code>optional bool use_middle_product_form_update = 35 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The useMiddleProductFormUpdate.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasInitializeDevexWithColumnNorms()">
<h3>hasInitializeDevexWithColumnNorms</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasInitializeDevexWithColumnNorms</span>()</div>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the initializeDevexWithColumnNorms field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getInitializeDevexWithColumnNorms()">
<h3>getInitializeDevexWithColumnNorms</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getInitializeDevexWithColumnNorms</span>()</div>
<div class="block"><pre>
 Whether we initialize devex weights to 1.0 or to the norms of the matrix
 columns.
 </pre>

 <code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The initializeDevexWithColumnNorms.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasExploitSingletonColumnInInitialBasis()">
<h3>hasExploitSingletonColumnInInitialBasis</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasExploitSingletonColumnInInitialBasis</span>()</div>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the exploitSingletonColumnInInitialBasis field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getExploitSingletonColumnInInitialBasis()">
<h3>getExploitSingletonColumnInInitialBasis</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getExploitSingletonColumnInInitialBasis</span>()</div>
<div class="block"><pre>
 Whether or not we exploit the singleton columns already present in the
 problem when we create the initial basis.
 </pre>

 <code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The exploitSingletonColumnInInitialBasis.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasDualSmallPivotThreshold()">
<h3>hasDualSmallPivotThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasDualSmallPivotThreshold</span>()</div>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the dualSmallPivotThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getDualSmallPivotThreshold()">
<h3>getDualSmallPivotThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getDualSmallPivotThreshold</span>()</div>
<div class="block"><pre>
 Like small_pivot_threshold but for the dual simplex. This is needed because
 the dual algorithm does not interpret this value in the same way.
 TODO(user): Clean this up and use the same small pivot detection.
 </pre>

 <code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The dualSmallPivotThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasPreprocessorZeroTolerance()">
<h3>hasPreprocessorZeroTolerance</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasPreprocessorZeroTolerance</span>()</div>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.
 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the preprocessorZeroTolerance field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getPreprocessorZeroTolerance()">
<h3>getPreprocessorZeroTolerance</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getPreprocessorZeroTolerance</span>()</div>
<div class="block"><pre>
 A floating point tolerance used by the preprocessors. This is used for
 things like detecting if two columns/rows are proportional or if an
 interval is empty.
 Note that the preprocessors also use solution_feasibility_tolerance() to
 detect if a problem is infeasible.
 </pre>

 <code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The preprocessorZeroTolerance.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasObjectiveLowerLimit()">
<h3>hasObjectiveLowerLimit</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasObjectiveLowerLimit</span>()</div>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.
 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the objectiveLowerLimit field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getObjectiveLowerLimit()">
<h3>getObjectiveLowerLimit</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getObjectiveLowerLimit</span>()</div>
<div class="block"><pre>
 The solver will stop as soon as it has proven that the objective is smaller
 than objective_lower_limit or greater than objective_upper_limit. Depending
 on the simplex algorithm (primal or dual) and the optimization direction,
 note that only one bound will be used at the time.
 Important: The solver does not add any tolerances to these values, and as
 soon as the objective (as computed by the solver, so with some imprecision)
 crosses one of these bounds (strictly), the search will stop. It is up to
 the client to add any tolerance if needed.
 </pre>

 <code>optional double objective_lower_limit = 40 [default = -inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The objectiveLowerLimit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasObjectiveUpperLimit()">
<h3>hasObjectiveUpperLimit</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasObjectiveUpperLimit</span>()</div>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the objectiveUpperLimit field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getObjectiveUpperLimit()">
<h3>getObjectiveUpperLimit</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getObjectiveUpperLimit</span>()</div>
<div class="block"><code>optional double objective_upper_limit = 41 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The objectiveUpperLimit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasDegenerateMinistepFactor()">
<h3>hasDegenerateMinistepFactor</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasDegenerateMinistepFactor</span>()</div>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommanded in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.
 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).
 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the degenerateMinistepFactor field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getDegenerateMinistepFactor()">
<h3>getDegenerateMinistepFactor</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getDegenerateMinistepFactor</span>()</div>
<div class="block"><pre>
 During a degenerate iteration, the more conservative approach is to do a
 step of length zero (while shifting the bound of the leaving variable).
 That is, the variable values are unchanged for the primal simplex or the
 reduced cost are unchanged for the dual simplex. However, instead of doing
 a step of length zero, it seems to be better on degenerate problems to do a
 small positive step. This is what is recommanded in the EXPAND procedure
 described in:
 P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
 cycling procedure for linearly constrained optimization".
 Mathematical Programming, 45:437&#92;u2013474, 1989.
 Here, during a degenerate iteration we do a small positive step of this
 factor times the primal (resp. dual) tolerance. In the primal simplex, this
 may effectively push variable values (very slightly) further out of their
 bounds (resp. reduced costs for the dual simplex).
 Setting this to zero reverts to the more conservative approach of a zero
 step during degenerate iterations.
 </pre>

 <code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The degenerateMinistepFactor.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasRandomSeed()">
<h3>hasRandomSeed</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasRandomSeed</span>()</div>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.
 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the randomSeed field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRandomSeed()">
<h3>getRandomSeed</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">getRandomSeed</span>()</div>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.
 Note that this may lead to a different solution, for example a different
 optimal basis.
 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 Also note that the solver is fully deterministic: two runs of the same
 binary, on the same machine, on the exact same data and with the same
 parameters will go through the exact same iterations. If they hit a time
 limit, they might of course yield different results because one will have
 advanced farther than the other.
 </pre>

 <code>optional int32 random_seed = 43 [default = 1];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The randomSeed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasNumOmpThreads()">
<h3>hasNumOmpThreads</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasNumOmpThreads</span>()</div>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the numOmpThreads field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getNumOmpThreads()">
<h3>getNumOmpThreads</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">getNumOmpThreads</span>()</div>
<div class="block"><pre>
 Number of threads in the OMP parallel sections. If left to 1, the code will
 not create any OMP threads and will remain single-threaded.
 </pre>

 <code>optional int32 num_omp_threads = 44 [default = 1];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The numOmpThreads.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasPerturbCostsInDualSimplex()">
<h3>hasPerturbCostsInDualSimplex</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasPerturbCostsInDualSimplex</span>()</div>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the perturbCostsInDualSimplex field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getPerturbCostsInDualSimplex()">
<h3>getPerturbCostsInDualSimplex</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getPerturbCostsInDualSimplex</span>()</div>
<div class="block"><pre>
 When this is true, then the costs are randomly perturbed before the dual
 simplex is even started. This has been shown to improve the dual simplex
 performance. For a good reference, see Huangfu Q (2013) "High performance
 simplex solver", Ph.D, dissertation, University of Edinburgh.
 </pre>

 <code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The perturbCostsInDualSimplex.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasUseDedicatedDualFeasibilityAlgorithm()">
<h3>hasUseDedicatedDualFeasibilityAlgorithm</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasUseDedicatedDualFeasibilityAlgorithm</span>()</div>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.
 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the useDedicatedDualFeasibilityAlgorithm field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getUseDedicatedDualFeasibilityAlgorithm()">
<h3>getUseDedicatedDualFeasibilityAlgorithm</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getUseDedicatedDualFeasibilityAlgorithm</span>()</div>
<div class="block"><pre>
 We have two possible dual phase I algorithms. Both work on an LP that
 minimize the sum of dual infeasiblities. One use dedicated code (when this
 param is true), the other one use exactly the same code as the dual phase
 II but on an auxiliary problem where the variable bounds of the original
 problem are changed.
 TODO(user): For now we have both, but ideally the non-dedicated version
 will win since it is a lot less code to maintain.
 </pre>

 <code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The useDedicatedDualFeasibilityAlgorithm.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasRelativeCostPerturbation()">
<h3>hasRelativeCostPerturbation</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasRelativeCostPerturbation</span>()</div>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the relativeCostPerturbation field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRelativeCostPerturbation()">
<h3>getRelativeCostPerturbation</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getRelativeCostPerturbation</span>()</div>
<div class="block"><pre>
 The magnitude of the cost perturbation is given by
 RandomIn(1.0, 2.0) * (
     relative_cost_perturbation * cost
   + relative_max_cost_perturbation * max_cost);
 </pre>

 <code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The relativeCostPerturbation.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasRelativeMaxCostPerturbation()">
<h3>hasRelativeMaxCostPerturbation</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasRelativeMaxCostPerturbation</span>()</div>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the relativeMaxCostPerturbation field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRelativeMaxCostPerturbation()">
<h3>getRelativeMaxCostPerturbation</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getRelativeMaxCostPerturbation</span>()</div>
<div class="block"><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The relativeMaxCostPerturbation.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasInitialConditionNumberThreshold()">
<h3>hasInitialConditionNumberThreshold</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasInitialConditionNumberThreshold</span>()</div>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the initialConditionNumberThreshold field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getInitialConditionNumberThreshold()">
<h3>getInitialConditionNumberThreshold</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getInitialConditionNumberThreshold</span>()</div>
<div class="block"><pre>
 If our upper bound on the condition number of the initial basis (from our
 heurisitic or a warm start) is above this threshold, we revert to an all
 slack basis.
 </pre>

 <code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The initialConditionNumberThreshold.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasLogSearchProgress()">
<h3>hasLogSearchProgress</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasLogSearchProgress</span>()</div>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the logSearchProgress field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getLogSearchProgress()">
<h3>getLogSearchProgress</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getLogSearchProgress</span>()</div>
<div class="block"><pre>
 If true, logs the progress of a solve to LOG(INFO). Note that the same
 messages can also be turned on by displaying logs at level 1 for the
 relevant files.
 </pre>

 <code>optional bool log_search_progress = 61 [default = false];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The logSearchProgress.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasLogToStdout()">
<h3>hasLogToStdout</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasLogToStdout</span>()</div>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the logToStdout field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getLogToStdout()">
<h3>getLogToStdout</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getLogToStdout</span>()</div>
<div class="block"><pre>
 If true, logs will be displayed to stdout instead of using Google log info.
 </pre>

 <code>optional bool log_to_stdout = 66 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The logToStdout.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasCrossoverBoundSnappingDistance()">
<h3>hasCrossoverBoundSnappingDistance</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasCrossoverBoundSnappingDistance</span>()</div>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.
 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.
 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().
 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the crossoverBoundSnappingDistance field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getCrossoverBoundSnappingDistance()">
<h3>getCrossoverBoundSnappingDistance</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getCrossoverBoundSnappingDistance</span>()</div>
<div class="block"><pre>
 If the starting basis contains FREE variable with bounds, we will move
 any such variable to their closer bounds if the distance is smaller than
 this parameter.
 The starting statuses can contains FREE variables with bounds, if a user
 set it like this externally. Also, any variable with an initial BASIC
 status that was not kept in the initial basis is marked as FREE before this
 step is applied.
 Note that by default a FREE variable is assumed to be zero unless a
 starting value was specified via SetStartingVariableValuesForNextSolve().
 Note that, at the end of the solve, some of these FREE variable with bounds
 and an interior point value might still be left in the final solution.
 Enable push_to_vertex to clean these up.
 </pre>

 <code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The crossoverBoundSnappingDistance.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasPushToVertex()">
<h3>hasPushToVertex</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasPushToVertex</span>()</div>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the pushToVertex field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getPushToVertex()">
<h3>getPushToVertex</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getPushToVertex</span>()</div>
<div class="block"><pre>
 If the optimization phases finishes with super-basic variables (i.e.,
 variables that either 1) have bounds but are FREE in the basis, or 2) have
 no bounds and are FREE in the basis at a nonzero value), then run a "push"
 phase to push these variables to bounds, obtaining a vertex solution. Note
 this situation can happen only if a starting value was specified via
 SetStartingVariableValuesForNextSolve().
 </pre>

 <code>optional bool push_to_vertex = 65 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The pushToVertex.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasUseImpliedFreePreprocessor()">
<h3>hasUseImpliedFreePreprocessor</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasUseImpliedFreePreprocessor</span>()</div>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the useImpliedFreePreprocessor field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getUseImpliedFreePreprocessor()">
<h3>getUseImpliedFreePreprocessor</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">getUseImpliedFreePreprocessor</span>()</div>
<div class="block"><pre>
 If presolve runs, include the pass that detects implied free variables.
 </pre>

 <code>optional bool use_implied_free_preprocessor = 67 [default = true];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The useImpliedFreePreprocessor.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasMaxValidMagnitude()">
<h3>hasMaxValidMagnitude</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">hasMaxValidMagnitude</span>()</div>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 199 [default = 1e+30];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>Whether the maxValidMagnitude field is set.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getMaxValidMagnitude()">
<h3>getMaxValidMagnitude</h3>
<div class="member-signature"><span class="return-type">double</span>&nbsp;<span class="element-name">getMaxValidMagnitude</span>()</div>
<div class="block"><pre>
 Any finite values in the input LP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. In practice, users
 shouldn't use super large values in an LP. With the default threshold, even
 evaluating large constraint with variables at their bound shouldn't cause
 any overflow.
 </pre>

 <code>optional double max_valid_magnitude = 199 [default = 1e+30];</code></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The maxValidMagnitude.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small>Copyright &#169; 2022. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
