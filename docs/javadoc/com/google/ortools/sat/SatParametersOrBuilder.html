<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang>
<head>
<!-- Generated by javadoc (1.8.0_442) on Mon Feb 17 12:52:51 GMT 2025 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>SatParametersOrBuilder (com.google.ortools:ortools-java 9.12.9999 API)</title>
<meta name="date" content="2025-02-17">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="SatParametersOrBuilder (com.google.ortools:ortools-java 9.12.9999 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6,"i23":6,"i24":6,"i25":6,"i26":6,"i27":6,"i28":6,"i29":6,"i30":6,"i31":6,"i32":6,"i33":6,"i34":6,"i35":6,"i36":6,"i37":6,"i38":6,"i39":6,"i40":6,"i41":6,"i42":6,"i43":6,"i44":6,"i45":6,"i46":6,"i47":6,"i48":6,"i49":6,"i50":6,"i51":6,"i52":6,"i53":6,"i54":6,"i55":6,"i56":6,"i57":6,"i58":6,"i59":6,"i60":6,"i61":6,"i62":6,"i63":6,"i64":6,"i65":6,"i66":6,"i67":6,"i68":6,"i69":6,"i70":6,"i71":6,"i72":6,"i73":6,"i74":6,"i75":6,"i76":6,"i77":6,"i78":6,"i79":6,"i80":6,"i81":6,"i82":6,"i83":6,"i84":6,"i85":6,"i86":6,"i87":6,"i88":6,"i89":6,"i90":6,"i91":6,"i92":6,"i93":6,"i94":6,"i95":6,"i96":6,"i97":6,"i98":6,"i99":6,"i100":6,"i101":6,"i102":6,"i103":6,"i104":6,"i105":6,"i106":6,"i107":6,"i108":6,"i109":6,"i110":6,"i111":6,"i112":6,"i113":6,"i114":6,"i115":6,"i116":6,"i117":6,"i118":6,"i119":6,"i120":6,"i121":6,"i122":6,"i123":6,"i124":6,"i125":6,"i126":6,"i127":6,"i128":6,"i129":6,"i130":6,"i131":6,"i132":6,"i133":6,"i134":6,"i135":6,"i136":6,"i137":6,"i138":6,"i139":6,"i140":6,"i141":6,"i142":6,"i143":6,"i144":6,"i145":6,"i146":6,"i147":6,"i148":6,"i149":6,"i150":6,"i151":6,"i152":6,"i153":6,"i154":6,"i155":6,"i156":6,"i157":6,"i158":6,"i159":6,"i160":6,"i161":6,"i162":6,"i163":6,"i164":6,"i165":6,"i166":6,"i167":6,"i168":6,"i169":6,"i170":6,"i171":6,"i172":6,"i173":6,"i174":6,"i175":6,"i176":6,"i177":6,"i178":6,"i179":6,"i180":6,"i181":6,"i182":6,"i183":6,"i184":6,"i185":6,"i186":6,"i187":6,"i188":6,"i189":6,"i190":6,"i191":6,"i192":6,"i193":6,"i194":6,"i195":6,"i196":6,"i197":6,"i198":6,"i199":6,"i200":6,"i201":6,"i202":6,"i203":6,"i204":6,"i205":6,"i206":6,"i207":6,"i208":6,"i209":6,"i210":6,"i211":6,"i212":6,"i213":6,"i214":6,"i215":6,"i216":6,"i217":6,"i218":6,"i219":6,"i220":6,"i221":6,"i222":6,"i223":6,"i224":6,"i225":6,"i226":6,"i227":6,"i228":6,"i229":6,"i230":6,"i231":6,"i232":6,"i233":6,"i234":6,"i235":6,"i236":6,"i237":6,"i238":6,"i239":6,"i240":6,"i241":6,"i242":6,"i243":6,"i244":6,"i245":6,"i246":6,"i247":6,"i248":6,"i249":6,"i250":6,"i251":6,"i252":6,"i253":6,"i254":6,"i255":6,"i256":6,"i257":6,"i258":6,"i259":6,"i260":6,"i261":6,"i262":6,"i263":6,"i264":6,"i265":6,"i266":6,"i267":6,"i268":6,"i269":6,"i270":6,"i271":6,"i272":6,"i273":6,"i274":6,"i275":6,"i276":6,"i277":6,"i278":6,"i279":6,"i280":6,"i281":6,"i282":6,"i283":6,"i284":6,"i285":6,"i286":6,"i287":6,"i288":6,"i289":6,"i290":6,"i291":6,"i292":6,"i293":6,"i294":6,"i295":6,"i296":6,"i297":6,"i298":6,"i299":6,"i300":6,"i301":6,"i302":6,"i303":6,"i304":6,"i305":6,"i306":6,"i307":6,"i308":6,"i309":6,"i310":6,"i311":6,"i312":6,"i313":6,"i314":6,"i315":6,"i316":6,"i317":6,"i318":6,"i319":6,"i320":6,"i321":6,"i322":6,"i323":6,"i324":6,"i325":6,"i326":6,"i327":6,"i328":6,"i329":6,"i330":6,"i331":6,"i332":6,"i333":6,"i334":6,"i335":6,"i336":6,"i337":6,"i338":6,"i339":6,"i340":6,"i341":6,"i342":6,"i343":6,"i344":6,"i345":6,"i346":6,"i347":6,"i348":6,"i349":6,"i350":6,"i351":6,"i352":6,"i353":6,"i354":6,"i355":6,"i356":6,"i357":6,"i358":6,"i359":6,"i360":6,"i361":6,"i362":6,"i363":6,"i364":6,"i365":6,"i366":6,"i367":6,"i368":6,"i369":6,"i370":6,"i371":6,"i372":6,"i373":6,"i374":6,"i375":6,"i376":6,"i377":6,"i378":6,"i379":6,"i380":6,"i381":6,"i382":6,"i383":6,"i384":6,"i385":6,"i386":6,"i387":6,"i388":6,"i389":6,"i390":6,"i391":6,"i392":6,"i393":6,"i394":6,"i395":6,"i396":6,"i397":6,"i398":6,"i399":6,"i400":6,"i401":6,"i402":6,"i403":6,"i404":6,"i405":6,"i406":6,"i407":6,"i408":6,"i409":6,"i410":6,"i411":6,"i412":6,"i413":6,"i414":6,"i415":6,"i416":6,"i417":6,"i418":6,"i419":6,"i420":6,"i421":6,"i422":6,"i423":6,"i424":6,"i425":6,"i426":6,"i427":6,"i428":6,"i429":6,"i430":6,"i431":6,"i432":6,"i433":6,"i434":6,"i435":6,"i436":6,"i437":6,"i438":6,"i439":6,"i440":6,"i441":6,"i442":6,"i443":6,"i444":6,"i445":6,"i446":6,"i447":6,"i448":6,"i449":6,"i450":6,"i451":6,"i452":6,"i453":6,"i454":6,"i455":6,"i456":6,"i457":6,"i458":6,"i459":6,"i460":6,"i461":6,"i462":6,"i463":6,"i464":6,"i465":6,"i466":6,"i467":6,"i468":6,"i469":6,"i470":6,"i471":6,"i472":6,"i473":6,"i474":6,"i475":6,"i476":6,"i477":6,"i478":6,"i479":6,"i480":6,"i481":6,"i482":6,"i483":6,"i484":6,"i485":6,"i486":6,"i487":6,"i488":6,"i489":6,"i490":6,"i491":6,"i492":6,"i493":6,"i494":6,"i495":6,"i496":6,"i497":6,"i498":6,"i499":6,"i500":6,"i501":6,"i502":6,"i503":6,"i504":6,"i505":6,"i506":6,"i507":6,"i508":6,"i509":6,"i510":6,"i511":6,"i512":6,"i513":6,"i514":6,"i515":6,"i516":6,"i517":6,"i518":6,"i519":6,"i520":6,"i521":6,"i522":6,"i523":6,"i524":6,"i525":6,"i526":6,"i527":6,"i528":6,"i529":6,"i530":6,"i531":6,"i532":6,"i533":6,"i534":6,"i535":6,"i536":6,"i537":6,"i538":6,"i539":6,"i540":6,"i541":6,"i542":6,"i543":6,"i544":6,"i545":6,"i546":6,"i547":6,"i548":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SatParametersOrBuilder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/ortools/sat/SatParameters.VariableOrder.html" title="enum in com.google.ortools.sat"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/google/ortools/sat/SatParametersOuterClass.html" title="class in com.google.ortools.sat"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/ortools/sat/SatParametersOrBuilder.html" target="_top">Frames</a></li>
<li><a href="SatParametersOrBuilder.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.google.ortools.sat</div>
<h2 title="Interface SatParametersOrBuilder" class="title">Interface SatParametersOrBuilder</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd>com.google.protobuf.MessageLiteOrBuilder, com.google.protobuf.MessageOrBuilder</dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><a href="../../../../com/google/ortools/sat/SatParameters.html" title="class in com.google.ortools.sat">SatParameters</a>, <a href="../../../../com/google/ortools/sat/SatParameters.Builder.html" title="class in com.google.ortools.sat">SatParameters.Builder</a></dd>
</dl>
<hr>
<br>
<pre>public interface <span class="typeNameLabel">SatParametersOrBuilder</span>
extends com.google.protobuf.MessageOrBuilder</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAbsoluteGapLimit--">getAbsoluteGapLimit</a></span>()</code>
<div class="block">
 Stop the search when the gap between the best feasible objective (O) and
 our best objective bound (B) is smaller than a limit.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddCgCuts--">getAddCgCuts</a></span>()</code>
<div class="block">
 Whether we generate and add Chvatal-Gomory cuts to the LP at root node.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddCliqueCuts--">getAddCliqueCuts</a></span>()</code>
<div class="block">
 Whether we generate clique cuts from the binary implication graph.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddLinMaxCuts--">getAddLinMaxCuts</a></span>()</code>
<div class="block">
 For the lin max constraints, generates the cuts described in "Strong
 mixed-integer programming formulations for trained neural networks" by Ross
 Anderson et.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddLpConstraintsLazily--">getAddLpConstraintsLazily</a></span>()</code>
<div class="block">
 If true, we start by an empty LP, and only add constraints not satisfied
 by the current LP solution batch by batch.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddMirCuts--">getAddMirCuts</a></span>()</code>
<div class="block">
 Whether we generate MIR cuts at root node.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddObjectiveCut--">getAddObjectiveCut</a></span>()</code>
<div class="block">
 When the LP objective is fractional, do we add the cut that forces the
 linear objective expression to be greater or equal to this fractional value
 rounded up?</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddRltCuts--">getAddRltCuts</a></span>()</code>
<div class="block">
 Whether we generate RLT cuts.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAddZeroHalfCuts--">getAddZeroHalfCuts</a></span>()</code>
<div class="block">
 Whether we generate Zero-Half cuts at root node.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAlsoBumpVariablesInConflictReasons--">getAlsoBumpVariablesInConflictReasons</a></span>()</code>
<div class="block">
 When this is true, then the variables that appear in any of the reason of
 the variables in a conflict have their activity bumped.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAtMostOneMaxExpansionSize--">getAtMostOneMaxExpansionSize</a></span>()</code>
<div class="block">
 All at_most_one constraints with a size &lt;= param will be replaced by a
 quadratic number of binary implications.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getAutoDetectGreaterThanAtLeastOneOf--">getAutoDetectGreaterThanAtLeastOneOf</a></span>()</code>
<div class="block">
 If true, then the precedences propagator try to detect for each variable if
 it has a set of "optional incoming arc" for which at least one of them is
 present.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.BinaryMinizationAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.BinaryMinizationAlgorithm</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getBinaryMinimizationAlgorithm--">getBinaryMinimizationAlgorithm</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.BinaryMinizationAlgorithm binary_minimization_algorithm = 34 [default = BINARY_MINIMIZATION_FIRST];</code></div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getBinarySearchNumConflicts--">getBinarySearchNumConflicts</a></span>()</code>
<div class="block">
 If non-negative, perform a binary search on the objective variable in order
 to find an [min, max] interval outside of which the solver proved unsat/sat
 under this amount of conflict.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getBlockingRestartMultiplier--">getBlockingRestartMultiplier</a></span>()</code>
<div class="block"><code>optional double blocking_restart_multiplier = 66 [default = 1.4];</code></div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getBlockingRestartWindowSize--">getBlockingRestartWindowSize</a></span>()</code>
<div class="block"><code>optional int32 blocking_restart_window_size = 65 [default = 5000];</code></div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getBooleanEncodingLevel--">getBooleanEncodingLevel</a></span>()</code>
<div class="block">
 A non-negative level indicating how much we should try to fully encode
 Integer variables as Boolean.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCatchSigintSignal--">getCatchSigintSignal</a></span>()</code>
<div class="block">
 Indicates if the CP-SAT layer should catch Control-C (SIGINT) signals
 when calling solve.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getClauseActivityDecay--">getClauseActivityDecay</a></span>()</code>
<div class="block">
 Clause activity parameters (same effect as the one on the variables).</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getClauseCleanupLbdBound--">getClauseCleanupLbdBound</a></span>()</code>
<div class="block">
 All the clauses with a LBD (literal blocks distance) lower or equal to this
 parameters will always be kept.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.ClauseOrdering.html" title="enum in com.google.ortools.sat">SatParameters.ClauseOrdering</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getClauseCleanupOrdering--">getClauseCleanupOrdering</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseOrdering clause_cleanup_ordering = 60 [default = CLAUSE_ACTIVITY];</code></div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getClauseCleanupPeriod--">getClauseCleanupPeriod</a></span>()</code>
<div class="block">
 Trigger a cleanup when this number of "deletable" clauses is learned.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.ClauseProtection.html" title="enum in com.google.ortools.sat">SatParameters.ClauseProtection</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getClauseCleanupProtection--">getClauseCleanupProtection</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseProtection clause_cleanup_protection = 58 [default = PROTECTION_NONE];</code></div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getClauseCleanupRatio--">getClauseCleanupRatio</a></span>()</code>
<div class="block">
 During a cleanup, if clause_cleanup_target is 0, we will delete the
 clause_cleanup_ratio of "deletable" clauses instead of aiming for a fixed
 target of clauses to keep.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getClauseCleanupTarget--">getClauseCleanupTarget</a></span>()</code>
<div class="block">
 During a cleanup, we will always keep that number of "deletable" clauses.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getConvertIntervals--">getConvertIntervals</a></span>()</code>
<div class="block">
 Temporary flag util the feature is more mature.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCoreMinimizationLevel--">getCoreMinimizationLevel</a></span>()</code>
<div class="block">
 If positive, we spend some effort on each core:
 - At level 1, we use a simple heuristic to try to minimize an UNSAT core</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCountAssumptionLevelsInLbd--">getCountAssumptionLevelsInLbd</a></span>()</code>
<div class="block">
 Whether or not the assumption levels are taken into account during the LBD
 computation.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCoverOptimization--">getCoverOptimization</a></span>()</code>
<div class="block">
 If true, when the max-sat algo find a core, we compute the minimal number
 of literals in the core that needs to be true to have a feasible solution.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCpModelPresolve--">getCpModelPresolve</a></span>()</code>
<div class="block">
 Whether we presolve the cp_model before solving it.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCpModelProbingLevel--">getCpModelProbingLevel</a></span>()</code>
<div class="block">
 How much effort do we spend on probing. 0 disables it completely.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCpModelUseSatPresolve--">getCpModelUseSatPresolve</a></span>()</code>
<div class="block">
 Whether we also use the sat presolve when cp_model_presolve is true.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCutActiveCountDecay--">getCutActiveCountDecay</a></span>()</code>
<div class="block"><code>optional double cut_active_count_decay = 156 [default = 0.8];</code></div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCutCleanupTarget--">getCutCleanupTarget</a></span>()</code>
<div class="block">
 Target number of constraints to remove during cleanup.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCutLevel--">getCutLevel</a></span>()</code>
<div class="block">
 Control the global cut effort.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getCutMaxActiveCountValue--">getCutMaxActiveCountValue</a></span>()</code>
<div class="block">
 These parameters are similar to sat clause management activity parameters.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDebugCrashIfPresolveBreaksHint--">getDebugCrashIfPresolveBreaksHint</a></span>()</code>
<div class="block">
 Crash if presolve breaks a feasible hint.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDebugCrashOnBadHint--">getDebugCrashOnBadHint</a></span>()</code>
<div class="block">
 Crash if we do not manage to complete the hint into a full solution.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDebugMaxNumPresolveOperations--">getDebugMaxNumPresolveOperations</a></span>()</code>
<div class="block">
 If positive, try to stop just after that many presolve rules have been
 applied.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDebugPostsolveWithFullSolver--">getDebugPostsolveWithFullSolver</a></span>()</code>
<div class="block">
 We have two different postsolve code.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDefaultRestartAlgorithms--">getDefaultRestartAlgorithms</a></span>()</code>
<div class="block"><code>optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];</code></div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>com.google.protobuf.ByteString</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDefaultRestartAlgorithmsBytes--">getDefaultRestartAlgorithmsBytes</a></span>()</code>
<div class="block"><code>optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];</code></div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDetectLinearizedProduct--">getDetectLinearizedProduct</a></span>()</code>
<div class="block">
 Infer products of Boolean or of Boolean time IntegerVariable from the
 linear constrainst in the problem.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDetectTableWithCost--">getDetectTableWithCost</a></span>()</code>
<div class="block">
 If true, we detect variable that are unique to a table constraint and only
 there to encode a cost on each tuple.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDisableConstraintExpansion--">getDisableConstraintExpansion</a></span>()</code>
<div class="block">
 If true, it disable all constraint expansion.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getDiversifyLnsParams--">getDiversifyLnsParams</a></span>()</code>
<div class="block">
 If true, registers more lns subsolvers with different parameters.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getEncodeComplexLinearConstraintWithInteger--">getEncodeComplexLinearConstraintWithInteger</a></span>()</code>
<div class="block">
 Linear constraint with a complex right hand side (more than a single
 interval) need to be expanded, there is a couple of way to do that.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getEncodeCumulativeAsReservoir--">getEncodeCumulativeAsReservoir</a></span>()</code>
<div class="block">
 Encore cumulative with fixed demands and capacity as a reservoir
 constraint.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getEnumerateAllSolutions--">getEnumerateAllSolutions</a></span>()</code>
<div class="block">
 Whether we enumerate all solutions of a problem without objective.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExpandAlldiffConstraints--">getExpandAlldiffConstraints</a></span>()</code>
<div class="block">
 If true, expand all_different constraints that are not permutations.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExpandReservoirConstraints--">getExpandReservoirConstraints</a></span>()</code>
<div class="block">
 If true, expand the reservoir constraints by creating booleans for all
 possible precedences between event and encoding the constraint.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExpandReservoirUsingCircuit--">getExpandReservoirUsingCircuit</a></span>()</code>
<div class="block">
 Mainly useful for testing.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExploitAllLpSolution--">getExploitAllLpSolution</a></span>()</code>
<div class="block">
 If true and the Lp relaxation of the problem has a solution, try to exploit
 it.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExploitAllPrecedences--">getExploitAllPrecedences</a></span>()</code>
<div class="block"><code>optional bool exploit_all_precedences = 220 [default = false];</code></div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExploitBestSolution--">getExploitBestSolution</a></span>()</code>
<div class="block">
 When branching on a variable, follow the last best solution value.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExploitIntegerLpSolution--">getExploitIntegerLpSolution</a></span>()</code>
<div class="block">
 If true and the Lp relaxation of the problem has an integer optimal
 solution, try to exploit it.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExploitObjective--">getExploitObjective</a></span>()</code>
<div class="block">
 When branching an a variable that directly affect the objective,
 branch on the value that lead to the best objective first.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExploitRelaxationSolution--">getExploitRelaxationSolution</a></span>()</code>
<div class="block">
 When branching on a variable, follow the last best relaxation solution
 value.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExtraSubsolvers-int-">getExtraSubsolvers</a></span>(int&nbsp;index)</code>
<div class="block">
 A convenient way to add more workers types.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>com.google.protobuf.ByteString</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExtraSubsolversBytes-int-">getExtraSubsolversBytes</a></span>(int&nbsp;index)</code>
<div class="block">
 A convenient way to add more workers types.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExtraSubsolversCount--">getExtraSubsolversCount</a></span>()</code>
<div class="block">
 A convenient way to add more workers types.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getExtraSubsolversList--">getExtraSubsolversList</a></span>()</code>
<div class="block">
 A convenient way to add more workers types.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpBatchDtime--">getFeasibilityJumpBatchDtime</a></span>()</code>
<div class="block">
 How much dtime for each LS batch.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpDecay--">getFeasibilityJumpDecay</a></span>()</code>
<div class="block">
 On each restart, we randomly choose if we use decay (with this parameter)
 or no decay.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpEnableRestarts--">getFeasibilityJumpEnableRestarts</a></span>()</code>
<div class="block">
 When stagnating, feasibility jump will either restart from a default
 solution (with some possible randomization), or randomly pertubate the
 current solution.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpLinearizationLevel--">getFeasibilityJumpLinearizationLevel</a></span>()</code>
<div class="block">
 How much do we linearize the problem in the local search code.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpMaxExpandedConstraintSize--">getFeasibilityJumpMaxExpandedConstraintSize</a></span>()</code>
<div class="block">
 Maximum size of no_overlap or no_overlap_2d constraint for a quadratic
 expansion.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpRestartFactor--">getFeasibilityJumpRestartFactor</a></span>()</code>
<div class="block">
 This is a factor that directly influence the work before each restart.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpVarPerburbationRangeRatio--">getFeasibilityJumpVarPerburbationRangeRatio</a></span>()</code>
<div class="block">
 Max distance between the default value and the pertubated value relative to
 the range of the domain of the variable.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFeasibilityJumpVarRandomizationProbability--">getFeasibilityJumpVarRandomizationProbability</a></span>()</code>
<div class="block">
 Probability for a variable to have a non default value upon restarts or
 perturbations.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFillAdditionalSolutionsInResponse--">getFillAdditionalSolutionsInResponse</a></span>()</code>
<div class="block">
 If true, the final response addition_solutions field will be filled with
 all solutions from our solutions pool.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFillTightenedDomainsInResponse--">getFillTightenedDomainsInResponse</a></span>()</code>
<div class="block">
 If true, add information about the derived variable domains to the
 CpSolverResponse.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFilterSubsolvers-int-">getFilterSubsolvers</a></span>(int&nbsp;index)</code>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>com.google.protobuf.ByteString</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFilterSubsolversBytes-int-">getFilterSubsolversBytes</a></span>(int&nbsp;index)</code>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFilterSubsolversCount--">getFilterSubsolversCount</a></span>()</code>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFilterSubsolversList--">getFilterSubsolversList</a></span>()</code>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFindBigLinearOverlap--">getFindBigLinearOverlap</a></span>()</code>
<div class="block">
 Try to find large "rectangle" in the linear constraint matrix with
 identical lines.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFindMultipleCores--">getFindMultipleCores</a></span>()</code>
<div class="block">
 Whether we try to find more independent cores for a given set of
 assumptions in the core based max-SAT algorithms.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFixVariablesToTheirHintedValue--">getFixVariablesToTheirHintedValue</a></span>()</code>
<div class="block">
 If true, variables appearing in the solution hints will be fixed to their
 hinted value.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.FPRoundingMethod.html" title="enum in com.google.ortools.sat">SatParameters.FPRoundingMethod</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getFpRounding--">getFpRounding</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.FPRoundingMethod fp_rounding = 165 [default = PROPAGATION_ASSISTED];</code></div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getGlucoseDecayIncrement--">getGlucoseDecayIncrement</a></span>()</code>
<div class="block"><code>optional double glucose_decay_increment = 23 [default = 0.01];</code></div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getGlucoseDecayIncrementPeriod--">getGlucoseDecayIncrementPeriod</a></span>()</code>
<div class="block"><code>optional int32 glucose_decay_increment_period = 24 [default = 5000];</code></div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getGlucoseMaxDecay--">getGlucoseMaxDecay</a></span>()</code>
<div class="block">
 The activity starts at 0.8 and increment by 0.01 every 5000 conflicts until
 0.95.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getHintConflictLimit--">getHintConflictLimit</a></span>()</code>
<div class="block">
 Conflict limit used in the phase that exploit the solution hint.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getIgnoreNames--">getIgnoreNames</a></span>()</code>
<div class="block">
 If true, we don't keep names in our internal copy of the user given model.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getIgnoreSubsolvers-int-">getIgnoreSubsolvers</a></span>(int&nbsp;index)</code>
<div class="block">
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>com.google.protobuf.ByteString</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getIgnoreSubsolversBytes-int-">getIgnoreSubsolversBytes</a></span>(int&nbsp;index)</code>
<div class="block">
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getIgnoreSubsolversCount--">getIgnoreSubsolversCount</a></span>()</code>
<div class="block">
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getIgnoreSubsolversList--">getIgnoreSubsolversList</a></span>()</code>
<div class="block">
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInferAllDiffs--">getInferAllDiffs</a></span>()</code>
<div class="block">
 Run a max-clique code amongst all the x !</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.Polarity.html" title="enum in com.google.ortools.sat">SatParameters.Polarity</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInitialPolarity--">getInitialPolarity</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.Polarity initial_polarity = 2 [default = POLARITY_FALSE];</code></div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInitialVariablesActivity--">getInitialVariablesActivity</a></span>()</code>
<div class="block">
 The initial value of the variables activity.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInprocessingDtimeRatio--">getInprocessingDtimeRatio</a></span>()</code>
<div class="block">
 Proportion of deterministic time we should spend on inprocessing.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInprocessingMinimizationDtime--">getInprocessingMinimizationDtime</a></span>()</code>
<div class="block">
 Parameters for an heuristic similar to the one described in "An effective
 learnt clause minimization approach for CDCL Sat Solvers",
 https://www.ijcai.org/proceedings/2017/0098.pdf

 This is the amount of dtime we should spend on this technique during each
 inprocessing phase.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInprocessingMinimizationUseAllOrderings--">getInprocessingMinimizationUseAllOrderings</a></span>()</code>
<div class="block"><code>optional bool inprocessing_minimization_use_all_orderings = 298 [default = false];</code></div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInprocessingMinimizationUseConflictAnalysis--">getInprocessingMinimizationUseConflictAnalysis</a></span>()</code>
<div class="block"><code>optional bool inprocessing_minimization_use_conflict_analysis = 297 [default = true];</code></div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInprocessingProbingDtime--">getInprocessingProbingDtime</a></span>()</code>
<div class="block">
 The amount of dtime we should spend on probing for each inprocessing round.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInstantiateAllVariables--">getInstantiateAllVariables</a></span>()</code>
<div class="block">
 If true, the solver will add a default integer branching strategy to the
 already defined search strategy.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInterleaveBatchSize--">getInterleaveBatchSize</a></span>()</code>
<div class="block"><code>optional int32 interleave_batch_size = 134 [default = 0];</code></div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getInterleaveSearch--">getInterleaveSearch</a></span>()</code>
<div class="block">
 Experimental.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getKeepAllFeasibleSolutionsInPresolve--">getKeepAllFeasibleSolutionsInPresolve</a></span>()</code>
<div class="block">
 If true, we disable the presolve reductions that remove feasible solutions
 from the search space.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getKeepSymmetryInPresolve--">getKeepSymmetryInPresolve</a></span>()</code>
<div class="block">
 Experimental.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLbRelaxNumWorkersThreshold--">getLbRelaxNumWorkersThreshold</a></span>()</code>
<div class="block">
 Only use lb-relax if we have at least that many workers.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLinearizationLevel--">getLinearizationLevel</a></span>()</code>
<div class="block">
 A non-negative level indicating the type of constraints we consider in the
 LP relaxation.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLinearSplitSize--">getLinearSplitSize</a></span>()</code>
<div class="block">
 Linear constraints that are not pseudo-Boolean and that are longer than
 this size will be split into sqrt(size) intermediate sums in order to have
 faster propation in the CP engine.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLnsInitialDeterministicLimit--">getLnsInitialDeterministicLimit</a></span>()</code>
<div class="block"><code>optional double lns_initial_deterministic_limit = 308 [default = 0.1];</code></div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLnsInitialDifficulty--">getLnsInitialDifficulty</a></span>()</code>
<div class="block">
 Initial parameters for neighborhood generation.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLogPrefix--">getLogPrefix</a></span>()</code>
<div class="block">
 Add a prefix to all logs.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>com.google.protobuf.ByteString</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLogPrefixBytes--">getLogPrefixBytes</a></span>()</code>
<div class="block">
 Add a prefix to all logs.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLogSearchProgress--">getLogSearchProgress</a></span>()</code>
<div class="block">
 Whether the solver should log the search progress.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLogSubsolverStatistics--">getLogSubsolverStatistics</a></span>()</code>
<div class="block">
 Whether the solver should display per sub-solver search statistics.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLogToResponse--">getLogToResponse</a></span>()</code>
<div class="block">
 Log to response proto.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLogToStdout--">getLogToStdout</a></span>()</code>
<div class="block">
 Log to stdout.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLpDualTolerance--">getLpDualTolerance</a></span>()</code>
<div class="block"><code>optional double lp_dual_tolerance = 267 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getLpPrimalTolerance--">getLpPrimalTolerance</a></span>()</code>
<div class="block">
 The internal LP tolerances used by CP-SAT.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxAllDiffCutSize--">getMaxAllDiffCutSize</a></span>()</code>
<div class="block">
 Cut generator for all diffs can add too many cuts for large all_diff
 constraints.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxClauseActivityValue--">getMaxClauseActivityValue</a></span>()</code>
<div class="block"><code>optional double max_clause_activity_value = 18 [default = 1e+20];</code></div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxConsecutiveInactiveCount--">getMaxConsecutiveInactiveCount</a></span>()</code>
<div class="block">
 If a constraint/cut in LP is not active for that many consecutive OPTIMAL
 solves, remove it from the LP.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxCutRoundsAtLevelZero--">getMaxCutRoundsAtLevelZero</a></span>()</code>
<div class="block">
 Max number of time we perform cut generation and resolve the LP at level 0.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxDeterministicTime--">getMaxDeterministicTime</a></span>()</code>
<div class="block">
 Maximum time allowed in deterministic time to solve a problem.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxDomainSizeWhenEncodingEqNeqConstraints--">getMaxDomainSizeWhenEncodingEqNeqConstraints</a></span>()</code>
<div class="block">
 When loading a*x + b*y ==/!</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaximumRegionsToSplitInDisconnectedNoOverlap2D--">getMaximumRegionsToSplitInDisconnectedNoOverlap2D</a></span>()</code>
<div class="block">
 Detects when the space where items of a no_overlap_2d constraint can placed
 is disjoint (ie., fixed boxes split the domain).</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxIntegerRoundingScaling--">getMaxIntegerRoundingScaling</a></span>()</code>
<div class="block">
 In the integer rounding procedure used for MIR and Gomory cut, the maximum
 "scaling" we use (must be positive).</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxLinMaxSizeForExpansion--">getMaxLinMaxSizeForExpansion</a></span>()</code>
<div class="block">
 If the number of expressions in the lin_max is less that the max size
 parameter, model expansion replaces target = max(xi) by linear constraint
 with the introduction of new booleans bi such that bi =&gt; target == xi.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxMemoryInMb--">getMaxMemoryInMb</a></span>()</code>
<div class="block">
 Maximum memory allowed for the whole thread containing the solver.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxNumberOfConflicts--">getMaxNumberOfConflicts</a></span>()</code>
<div class="block">
 Maximum number of conflicts allowed to solve a problem.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxNumCuts--">getMaxNumCuts</a></span>()</code>
<div class="block">
 The limit on the number of cuts in our cut pool.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxNumDeterministicBatches--">getMaxNumDeterministicBatches</a></span>()</code>
<div class="block">
 Stops after that number of batches has been scheduled.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxNumIntervalsForTimetableEdgeFinding--">getMaxNumIntervalsForTimetableEdgeFinding</a></span>()</code>
<div class="block">
 Max number of intervals for the timetable_edge_finding algorithm to
 propagate.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxPairsPairwiseReasoningInNoOverlap2D--">getMaxPairsPairwiseReasoningInNoOverlap2D</a></span>()</code>
<div class="block">
 If the number of pairs to look is below this threshold, do an extra step of
 propagation in the no_overlap_2d constraint by looking at all pairs of
 intervals.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxPresolveIterations--">getMaxPresolveIterations</a></span>()</code>
<div class="block">
 In case of large reduction in a presolve iteration, we perform multiple
 presolve iterations.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.MaxSatAssumptionOrder.html" title="enum in com.google.ortools.sat">SatParameters.MaxSatAssumptionOrder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxSatAssumptionOrder--">getMaxSatAssumptionOrder</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatAssumptionOrder max_sat_assumption_order = 51 [default = DEFAULT_ASSUMPTION_ORDER];</code></div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxSatReverseAssumptionOrder--">getMaxSatReverseAssumptionOrder</a></span>()</code>
<div class="block">
 If true, adds the assumption in the reverse order of the one defined by
 max_sat_assumption_order.</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.MaxSatStratificationAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.MaxSatStratificationAlgorithm</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxSatStratification--">getMaxSatStratification</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatStratificationAlgorithm max_sat_stratification = 53 [default = STRATIFICATION_DESCENT];</code></div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxSizeToCreatePrecedenceLiteralsInDisjunctive--">getMaxSizeToCreatePrecedenceLiteralsInDisjunctive</a></span>()</code>
<div class="block">
 Create one literal for each disjunction of two pairs of tasks.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxTimeInSeconds--">getMaxTimeInSeconds</a></span>()</code>
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMaxVariableActivityValue--">getMaxVariableActivityValue</a></span>()</code>
<div class="block"><code>optional double max_variable_activity_value = 16 [default = 1e+100];</code></div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMergeAtMostOneWorkLimit--">getMergeAtMostOneWorkLimit</a></span>()</code>
<div class="block"><code>optional double merge_at_most_one_work_limit = 146 [default = 100000000];</code></div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMergeNoOverlapWorkLimit--">getMergeNoOverlapWorkLimit</a></span>()</code>
<div class="block">
 During presolve, we use a maximum clique heuristic to merge together
 no-overlap constraints or at most one constraints.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.ConflictMinimizationAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.ConflictMinimizationAlgorithm</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMinimizationAlgorithm--">getMinimizationAlgorithm</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.ConflictMinimizationAlgorithm minimization_algorithm = 4 [default = RECURSIVE];</code></div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMinimizeReductionDuringPbResolution--">getMinimizeReductionDuringPbResolution</a></span>()</code>
<div class="block">
 A different algorithm during PB resolution.</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMinimizeSharedClauses--">getMinimizeSharedClauses</a></span>()</code>
<div class="block">
 Minimize and detect subsumption of shared clauses immediately after they
 are imported.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMinOrthogonalityForLpConstraints--">getMinOrthogonalityForLpConstraints</a></span>()</code>
<div class="block">
 While adding constraints, skip the constraints which have orthogonality
 less than 'min_orthogonality_for_lp_constraints' with already added
 constraints during current call.</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipAutomaticallyScaleVariables--">getMipAutomaticallyScaleVariables</a></span>()</code>
<div class="block">
 If true, some continuous variable might be automatically scaled.</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipCheckPrecision--">getMipCheckPrecision</a></span>()</code>
<div class="block">
 As explained in mip_precision and mip_max_activity_exponent, we cannot
 always reach the wanted precision during scaling.</div>
</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipComputeTrueObjectiveBound--">getMipComputeTrueObjectiveBound</a></span>()</code>
<div class="block">
 Even if we make big error when scaling the objective, we can always derive
 a correct lower bound on the original objective by using the exact lower
 bound on the scaled integer version of the objective.</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipDropTolerance--">getMipDropTolerance</a></span>()</code>
<div class="block">
 Any value in the input mip with a magnitude lower than this will be set to
 zero.</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipMaxActivityExponent--">getMipMaxActivityExponent</a></span>()</code>
<div class="block">
 To avoid integer overflow, we always force the maximum possible constraint
 activity (and objective value) according to the initial variable domain to
 be smaller than 2 to this given power.</div>
</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipMaxBound--">getMipMaxBound</a></span>()</code>
<div class="block">
 We need to bound the maximum magnitude of the variables for CP-SAT, and
 that is the bound we use.</div>
</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipMaxValidMagnitude--">getMipMaxValidMagnitude</a></span>()</code>
<div class="block">
 Any finite values in the input MIP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipPresolveLevel--">getMipPresolveLevel</a></span>()</code>
<div class="block">
 When solving a MIP, we do some basic floating point presolving before
 scaling the problem to integer to be handled by CP-SAT.</div>
</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipScaleLargeDomain--">getMipScaleLargeDomain</a></span>()</code>
<div class="block">
 If this is false, then mip_var_scaling is only applied to variables with
 "small" domain.</div>
</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipTreatHighMagnitudeBoundsAsInfinity--">getMipTreatHighMagnitudeBoundsAsInfinity</a></span>()</code>
<div class="block">
 By default, any variable/constraint bound with a finite value and a
 magnitude greater than the mip_max_valid_magnitude will result with a
 invalid model.</div>
</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipVarScaling--">getMipVarScaling</a></span>()</code>
<div class="block">
 All continuous variable of the problem will be multiplied by this factor.</div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getMipWantedPrecision--">getMipWantedPrecision</a></span>()</code>
<div class="block">
 When scaling constraint with double coefficients to integer coefficients,
 we will multiply by a power of 2 and round the coefficients.</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getName--">getName</a></span>()</code>
<div class="block">
 In some context, like in a portfolio of search, it makes sense to name a
 given parameters set for logging purpose.</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>com.google.protobuf.ByteString</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNameBytes--">getNameBytes</a></span>()</code>
<div class="block">
 In some context, like in a portfolio of search, it makes sense to name a
 given parameters set for logging purpose.</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNewConstraintsBatchSize--">getNewConstraintsBatchSize</a></span>()</code>
<div class="block">
 Add that many lazy constraints (or cuts) at once in the LP.</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNewLinearPropagation--">getNewLinearPropagation</a></span>()</code>
<div class="block">
 The new linear propagation code treat all constraints at once and use
 an adaptation of Bellman-Ford-Tarjan to propagate constraint in a smarter
 order and potentially detect propagation cycle earlier.</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNumConflictsBeforeStrategyChanges--">getNumConflictsBeforeStrategyChanges</a></span>()</code>
<div class="block">
 After each restart, if the number of conflict since the last strategy
 change is greater that this, then we increment a "strategy_counter" that
 can be use to change the search strategy used by the following restarts.</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNumFullSubsolvers--">getNumFullSubsolvers</a></span>()</code>
<div class="block">
 We distinguish subsolvers that consume a full thread, and the ones that are
 always interleaved.</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNumSearchWorkers--">getNumSearchWorkers</a></span>()</code>
<div class="block"><code>optional int32 num_search_workers = 100 [default = 0];</code></div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNumViolationLs--">getNumViolationLs</a></span>()</code>
<div class="block">
 This will create incomplete subsolvers (that are not LNS subsolvers)
 that use the feasibility jump code to find improving solution, treating
 the objective improvement as a hard constraint.</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getNumWorkers--">getNumWorkers</a></span>()</code>
<div class="block">
 Specify the number of parallel workers (i.e. threads) to use during search.</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getOnlyAddCutsAtLevelZero--">getOnlyAddCutsAtLevelZero</a></span>()</code>
<div class="block">
 For the cut that can be generated at any level, this control if we only
 try to generate them at the root node.</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getOnlySolveIp--">getOnlySolveIp</a></span>()</code>
<div class="block">
 If one try to solve a MIP model with CP-SAT, because we assume all variable
 to be integer after scaling, we will not necessarily have the correct
 optimal.</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getOptimizeWithCore--">getOptimizeWithCore</a></span>()</code>
<div class="block">
 The default optimization method is a simple "linear scan", each time trying
 to find a better solution than the previous one.</div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getOptimizeWithLbTreeSearch--">getOptimizeWithLbTreeSearch</a></span>()</code>
<div class="block">
 Do a more conventional tree search (by opposition to SAT based one) where
 we keep all the explored node in a tree.</div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getOptimizeWithMaxHs--">getOptimizeWithMaxHs</a></span>()</code>
<div class="block">
 This has no effect if optimize_with_core is false.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPbCleanupIncrement--">getPbCleanupIncrement</a></span>()</code>
<div class="block">
 Same as for the clauses, but for the learned pseudo-Boolean constraints.</div>
</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPbCleanupRatio--">getPbCleanupRatio</a></span>()</code>
<div class="block"><code>optional double pb_cleanup_ratio = 47 [default = 0.5];</code></div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPermutePresolveConstraintOrder--">getPermutePresolveConstraintOrder</a></span>()</code>
<div class="block"><code>optional bool permute_presolve_constraint_order = 179 [default = false];</code></div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPermuteVariableRandomly--">getPermuteVariableRandomly</a></span>()</code>
<div class="block">
 This is mainly here to test the solver variability.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPolarityExploitLsHints--">getPolarityExploitLsHints</a></span>()</code>
<div class="block">
 If true and we have first solution LS workers, tries in some phase to
 follow a LS solutions that violates has litle constraints as possible.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPolarityRephaseIncrement--">getPolarityRephaseIncrement</a></span>()</code>
<div class="block">
 If non-zero, then we change the polarity heuristic after that many number
 of conflicts in an arithmetically increasing fashion.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPolishLpSolution--">getPolishLpSolution</a></span>()</code>
<div class="block">
 Whether we try to do a few degenerate iteration at the end of an LP solve
 to minimize the fractionality of the integer variable in the basis.</div>
</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.VariableOrder.html" title="enum in com.google.ortools.sat">SatParameters.VariableOrder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPreferredVariableOrder--">getPreferredVariableOrder</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.VariableOrder preferred_variable_order = 1 [default = IN_ORDER];</code></div>
</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveBlockedClause--">getPresolveBlockedClause</a></span>()</code>
<div class="block">
 Whether we use an heuristic to detect some basic case of blocked clause
 in the SAT presolve.</div>
</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveBvaThreshold--">getPresolveBvaThreshold</a></span>()</code>
<div class="block">
 Apply Bounded Variable Addition (BVA) if the number of clauses is reduced
 by stricly more than this threshold.</div>
</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveBveClauseWeight--">getPresolveBveClauseWeight</a></span>()</code>
<div class="block">
 During presolve, we apply BVE only if this weight times the number of
 clauses plus the number of clause literals is not increased.</div>
</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveBveThreshold--">getPresolveBveThreshold</a></span>()</code>
<div class="block">
 During presolve, only try to perform the bounded variable elimination (BVE)
 of a variable x if the number of occurrences of x times the number of
 occurrences of not(x) is not greater than this parameter.</div>
</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveExtractIntegerEnforcement--">getPresolveExtractIntegerEnforcement</a></span>()</code>
<div class="block">
 If true, we will extract from linear constraints, enforcement literals of
 the form "integer variable at bound =&gt; simplified constraint".</div>
</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveInclusionWorkLimit--">getPresolveInclusionWorkLimit</a></span>()</code>
<div class="block">
 A few presolve operations involve detecting constraints included in other
 constraint.</div>
</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveProbingDeterministicTimeLimit--">getPresolveProbingDeterministicTimeLimit</a></span>()</code>
<div class="block"><code>optional double presolve_probing_deterministic_time_limit = 57 [default = 30];</code></div>
</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveSubstitutionLevel--">getPresolveSubstitutionLevel</a></span>()</code>
<div class="block">
 How much substitution (also called free variable aggregation in MIP
 litterature) should we perform at presolve.</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPresolveUseBva--">getPresolveUseBva</a></span>()</code>
<div class="block">
 Whether or not we use Bounded Variable Addition (BVA) in the presolve.</div>
</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getProbingDeterministicTimeLimit--">getProbingDeterministicTimeLimit</a></span>()</code>
<div class="block">
 The maximum "deterministic" time limit to spend in probing.</div>
</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getProbingNumCombinationsLimit--">getProbingNumCombinationsLimit</a></span>()</code>
<div class="block">
 How many combinations of pairs or triplets of variables we want to scan.</div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPropagationLoopDetectionFactor--">getPropagationLoopDetectionFactor</a></span>()</code>
<div class="block">
 Some search decisions might cause a really large number of propagations to
 happen when integer variables with large domains are only reduced by 1 at
 each step.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPseudoCostReliabilityThreshold--">getPseudoCostReliabilityThreshold</a></span>()</code>
<div class="block">
 The solver ignores the pseudo costs of variables with number of recordings
 less than this threshold.</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getPushAllTasksTowardStart--">getPushAllTasksTowardStart</a></span>()</code>
<div class="block">
 Experimental code: specify if the objective pushes all tasks toward the
 start of the schedule.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRandomBranchesRatio--">getRandomBranchesRatio</a></span>()</code>
<div class="block">
 A number between 0 and 1 that indicates the proportion of branching
 variables that are selected randomly instead of choosing the first variable
 from the given variable_ordering strategy.</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRandomizeSearch--">getRandomizeSearch</a></span>()</code>
<div class="block">
 Randomize fixed search.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRandomPolarityRatio--">getRandomPolarityRatio</a></span>()</code>
<div class="block">
 The proportion of polarity chosen at random.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRandomSeed--">getRandomSeed</a></span>()</code>
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRelativeGapLimit--">getRelativeGapLimit</a></span>()</code>
<div class="block"><code>optional double relative_gap_limit = 160 [default = 0];</code></div>
</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRemoveFixedVariablesEarly--">getRemoveFixedVariablesEarly</a></span>()</code>
<div class="block">
 If cp_model_presolve is true and there is a large proportion of fixed
 variable after the first model copy, remap all the model to a dense set of
 variable before the full presolve even starts.</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRepairHint--">getRepairHint</a></span>()</code>
<div class="block">
 If true, the solver tries to repair the solution given in the hint.</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.RestartAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.RestartAlgorithm</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRestartAlgorithms-int-">getRestartAlgorithms</a></span>(int&nbsp;index)</code>
<div class="block">
 The restart strategies will change each time the strategy_counter is
 increased.</div>
</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRestartAlgorithmsCount--">getRestartAlgorithmsCount</a></span>()</code>
<div class="block">
 The restart strategies will change each time the strategy_counter is
 increased.</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../com/google/ortools/sat/SatParameters.RestartAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.RestartAlgorithm</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRestartAlgorithmsList--">getRestartAlgorithmsList</a></span>()</code>
<div class="block">
 The restart strategies will change each time the strategy_counter is
 increased.</div>
</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRestartDlAverageRatio--">getRestartDlAverageRatio</a></span>()</code>
<div class="block">
 In the moving average restart algorithms, a restart is triggered if the
 window average times this ratio is greater that the global average.</div>
</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRestartLbdAverageRatio--">getRestartLbdAverageRatio</a></span>()</code>
<div class="block"><code>optional double restart_lbd_average_ratio = 71 [default = 1];</code></div>
</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRestartPeriod--">getRestartPeriod</a></span>()</code>
<div class="block">
 Restart period for the FIXED_RESTART strategy.</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRestartRunningWindowSize--">getRestartRunningWindowSize</a></span>()</code>
<div class="block">
 Size of the window for the moving average restarts.</div>
</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRootLpIterations--">getRootLpIterations</a></span>()</code>
<div class="block">
 Even at the root node, we do not want to spend too much time on the LP if
 it is "difficult".</div>
</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRoutingCutDpEffort--">getRoutingCutDpEffort</a></span>()</code>
<div class="block">
 The amount of "effort" to spend in dynamic programming for computing
 routing cuts.</div>
</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRoutingCutSubsetSizeForBinaryRelationBound--">getRoutingCutSubsetSizeForBinaryRelationBound</a></span>()</code>
<div class="block">
 If the size of a subset of nodes of a RoutesConstraint is less than this
 value, use linear constraints of size 1 and 2 (such as capacity and time
 window constraints) enforced by the arc literals to compute cuts for this
 subset (unless the subset size is less than
 routing_cut_subset_size_for_tight_binary_relation_bound, in which case the
 corresponding algorithm is used instead).</div>
</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getRoutingCutSubsetSizeForTightBinaryRelationBound--">getRoutingCutSubsetSizeForTightBinaryRelationBound</a></span>()</code>
<div class="block">
 Similar to above, but with a different algorithm producing better cuts, at
 the price of a higher O(2^n) complexity, where n is the subset size.</div>
</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSaveLpBasisInLbTreeSearch--">getSaveLpBasisInLbTreeSearch</a></span>()</code>
<div class="block">
 Experimental.</div>
</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.SearchBranching.html" title="enum in com.google.ortools.sat">SatParameters.SearchBranching</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSearchBranching--">getSearchBranching</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.SearchBranching search_branching = 82 [default = AUTOMATIC_SEARCH];</code></div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSearchRandomVariablePoolSize--">getSearchRandomVariablePoolSize</a></span>()</code>
<div class="block">
 Search randomization will collect the top
 'search_random_variable_pool_size' valued variables, and pick one randomly.</div>
</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getShareBinaryClauses--">getShareBinaryClauses</a></span>()</code>
<div class="block">
 Allows sharing of new learned binary clause between workers.</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeBalanceTolerance--">getSharedTreeBalanceTolerance</a></span>()</code>
<div class="block">
 How much deeper compared to the ideal max depth of the tree is considered
 "balanced" enough to still accept a split.</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeMaxNodesPerWorker--">getSharedTreeMaxNodesPerWorker</a></span>()</code>
<div class="block">
 In order to limit total shared memory and communication overhead, limit the
 total number of nodes that may be generated in the shared tree.</div>
</td>
</tr>
<tr id="i215" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeNumWorkers--">getSharedTreeNumWorkers</a></span>()</code>
<div class="block">
 Enables shared tree search.</div>
</td>
</tr>
<tr id="i216" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeOpenLeavesPerWorker--">getSharedTreeOpenLeavesPerWorker</a></span>()</code>
<div class="block">
 How many open leaf nodes should the shared tree maintain per worker.</div>
</td>
</tr>
<tr id="i217" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.SharedTreeSplitStrategy.html" title="enum in com.google.ortools.sat">SatParameters.SharedTreeSplitStrategy</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeSplitStrategy--">getSharedTreeSplitStrategy</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.SharedTreeSplitStrategy shared_tree_split_strategy = 239 [default = SPLIT_STRATEGY_AUTO];</code></div>
</td>
</tr>
<tr id="i218" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeWorkerEnablePhaseSharing--">getSharedTreeWorkerEnablePhaseSharing</a></span>()</code>
<div class="block">
 If true, shared tree workers share their target phase when returning an
 assigned subtree for the next worker to use.</div>
</td>
</tr>
<tr id="i219" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeWorkerEnableTrailSharing--">getSharedTreeWorkerEnableTrailSharing</a></span>()</code>
<div class="block">
 If true, workers share more of the information from their local trail.</div>
</td>
</tr>
<tr id="i220" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSharedTreeWorkerMinRestartsPerSubtree--">getSharedTreeWorkerMinRestartsPerSubtree</a></span>()</code>
<div class="block">
 Minimum restarts before a worker will replace a subtree
 that looks "bad" based on the average LBD of learned clauses.</div>
</td>
</tr>
<tr id="i221" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getShareGlueClauses--">getShareGlueClauses</a></span>()</code>
<div class="block">
 Allows sharing of short glue clauses between workers.</div>
</td>
</tr>
<tr id="i222" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getShareLevelZeroBounds--">getShareLevelZeroBounds</a></span>()</code>
<div class="block">
 Allows sharing of the bounds of modified variables at level 0.</div>
</td>
</tr>
<tr id="i223" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getShareObjectiveBounds--">getShareObjectiveBounds</a></span>()</code>
<div class="block">
 Allows objective sharing between workers.</div>
</td>
</tr>
<tr id="i224" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getShavingSearchDeterministicTime--">getShavingSearchDeterministicTime</a></span>()</code>
<div class="block">
 Specifies the amount of deterministic time spent of each try at shaving a
 bound in the shaving search.</div>
</td>
</tr>
<tr id="i225" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getShavingSearchThreshold--">getShavingSearchThreshold</a></span>()</code>
<div class="block">
 Specifies the threshold between two modes in the shaving procedure.</div>
</td>
</tr>
<tr id="i226" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSolutionPoolSize--">getSolutionPoolSize</a></span>()</code>
<div class="block">
 Size of the top-n different solutions kept by the solver.</div>
</td>
</tr>
<tr id="i227" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getStopAfterFirstSolution--">getStopAfterFirstSolution</a></span>()</code>
<div class="block">
 For an optimization problem, stop the solver as soon as we have a solution.</div>
</td>
</tr>
<tr id="i228" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getStopAfterPresolve--">getStopAfterPresolve</a></span>()</code>
<div class="block">
 Mainly used when improving the presolver.</div>
</td>
</tr>
<tr id="i229" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getStopAfterRootPropagation--">getStopAfterRootPropagation</a></span>()</code>
<div class="block"><code>optional bool stop_after_root_propagation = 252 [default = false];</code></div>
</td>
</tr>
<tr id="i230" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getStrategyChangeIncreaseRatio--">getStrategyChangeIncreaseRatio</a></span>()</code>
<div class="block">
 The parameter num_conflicts_before_strategy_changes is increased by that
 much after each strategy change.</div>
</td>
</tr>
<tr id="i231" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParameters.html" title="class in com.google.ortools.sat">SatParameters</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolverParams-int-">getSubsolverParams</a></span>(int&nbsp;index)</code>
<div class="block">
 It is possible to specify additional subsolver configuration.</div>
</td>
</tr>
<tr id="i232" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolverParamsCount--">getSubsolverParamsCount</a></span>()</code>
<div class="block">
 It is possible to specify additional subsolver configuration.</div>
</td>
</tr>
<tr id="i233" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../com/google/ortools/sat/SatParameters.html" title="class in com.google.ortools.sat">SatParameters</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolverParamsList--">getSubsolverParamsList</a></span>()</code>
<div class="block">
 It is possible to specify additional subsolver configuration.</div>
</td>
</tr>
<tr id="i234" class="altColor">
<td class="colFirst"><code><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html" title="interface in com.google.ortools.sat">SatParametersOrBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolverParamsOrBuilder-int-">getSubsolverParamsOrBuilder</a></span>(int&nbsp;index)</code>
<div class="block">
 It is possible to specify additional subsolver configuration.</div>
</td>
</tr>
<tr id="i235" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;? extends <a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html" title="interface in com.google.ortools.sat">SatParametersOrBuilder</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolverParamsOrBuilderList--">getSubsolverParamsOrBuilderList</a></span>()</code>
<div class="block">
 It is possible to specify additional subsolver configuration.</div>
</td>
</tr>
<tr id="i236" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolvers-int-">getSubsolvers</a></span>(int&nbsp;index)</code>
<div class="block">
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters.</div>
</td>
</tr>
<tr id="i237" class="rowColor">
<td class="colFirst"><code>com.google.protobuf.ByteString</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolversBytes-int-">getSubsolversBytes</a></span>(int&nbsp;index)</code>
<div class="block">
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters.</div>
</td>
</tr>
<tr id="i238" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolversCount--">getSubsolversCount</a></span>()</code>
<div class="block">
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters.</div>
</td>
</tr>
<tr id="i239" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsolversList--">getSubsolversList</a></span>()</code>
<div class="block">
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters.</div>
</td>
</tr>
<tr id="i240" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSubsumptionDuringConflictAnalysis--">getSubsumptionDuringConflictAnalysis</a></span>()</code>
<div class="block">
 At a really low cost, during the 1-UIP conflict computation, it is easy to
 detect if some of the involved reasons are subsumed by the current
 conflict.</div>
</td>
</tr>
<tr id="i241" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSymmetryDetectionDeterministicTimeLimit--">getSymmetryDetectionDeterministicTimeLimit</a></span>()</code>
<div class="block">
 Deterministic time limit for symmetry detection.</div>
</td>
</tr>
<tr id="i242" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getSymmetryLevel--">getSymmetryLevel</a></span>()</code>
<div class="block">
 Whether we try to automatically detect the symmetries in a model and
 exploit them.</div>
</td>
</tr>
<tr id="i243" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getTableCompressionLevel--">getTableCompressionLevel</a></span>()</code>
<div class="block">
 How much we try to "compress" a table constraint.</div>
</td>
</tr>
<tr id="i244" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseAbslRandom--">getUseAbslRandom</a></span>()</code>
<div class="block"><code>optional bool use_absl_random = 180 [default = false];</code></div>
</td>
</tr>
<tr id="i245" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseAllDifferentForCircuit--">getUseAllDifferentForCircuit</a></span>()</code>
<div class="block">
 Turn on extra propagation for the circuit constraint.</div>
</td>
</tr>
<tr id="i246" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseAreaEnergeticReasoningInNoOverlap2D--">getUseAreaEnergeticReasoningInNoOverlap2D</a></span>()</code>
<div class="block">
 When this is true, the no_overlap_2d constraint is reinforced with
 an energetic reasoning that uses an area-based energy.</div>
</td>
</tr>
<tr id="i247" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseBlockingRestart--">getUseBlockingRestart</a></span>()</code>
<div class="block">
 Block a moving restart algorithm if the trail size of the current conflict
 is greater than the multiplier times the moving average of the trail size
 at the previous conflicts.</div>
</td>
</tr>
<tr id="i248" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseCombinedNoOverlap--">getUseCombinedNoOverlap</a></span>()</code>
<div class="block">
 This can be beneficial if there is a lot of no-overlap constraints but a
 relatively low number of different intervals in the problem.</div>
</td>
</tr>
<tr id="i249" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseConservativeScaleOverloadChecker--">getUseConservativeScaleOverloadChecker</a></span>()</code>
<div class="block">
 Enable a heuristic to solve cumulative constraints using a modified energy
 constraint.</div>
</td>
</tr>
<tr id="i250" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseDisjunctiveConstraintInCumulative--">getUseDisjunctiveConstraintInCumulative</a></span>()</code>
<div class="block">
 When this is true, the cumulative constraint is reinforced with propagators
 from the disjunctive constraint to improve the inference on a set of tasks
 that are disjunctive at the root of the problem.</div>
</td>
</tr>
<tr id="i251" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseDualSchedulingHeuristics--">getUseDualSchedulingHeuristics</a></span>()</code>
<div class="block">
 When set, it activates a few scheduling parameters to improve the lower
 bound of scheduling problems.</div>
</td>
</tr>
<tr id="i252" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseDynamicPrecedenceInCumulative--">getUseDynamicPrecedenceInCumulative</a></span>()</code>
<div class="block"><code>optional bool use_dynamic_precedence_in_cumulative = 268 [default = false];</code></div>
</td>
</tr>
<tr id="i253" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseDynamicPrecedenceInDisjunctive--">getUseDynamicPrecedenceInDisjunctive</a></span>()</code>
<div class="block">
 Whether we try to branch on decision "interval A before interval B" rather
 than on intervals bounds.</div>
</td>
</tr>
<tr id="i254" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseEnergeticReasoningInNoOverlap2D--">getUseEnergeticReasoningInNoOverlap2D</a></span>()</code>
<div class="block">
 When this is true, the no_overlap_2d constraint is reinforced with
 energetic reasoning.</div>
</td>
</tr>
<tr id="i255" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseErwaHeuristic--">getUseErwaHeuristic</a></span>()</code>
<div class="block">
 Whether we use the ERWA (Exponential Recency Weighted Average) heuristic as
 described in "Learning Rate Based Branching Heuristic for SAT solvers",
 J.H.Liang, V.</div>
</td>
</tr>
<tr id="i256" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseExactLpReason--">getUseExactLpReason</a></span>()</code>
<div class="block">
 The solver usually exploit the LP relaxation of a model.</div>
</td>
</tr>
<tr id="i257" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseExtendedProbing--">getUseExtendedProbing</a></span>()</code>
<div class="block">
 Use extended probing (probe bool_or, at_most_one, exactly_one).</div>
</td>
</tr>
<tr id="i258" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseFeasibilityJump--">getUseFeasibilityJump</a></span>()</code>
<div class="block">
 Parameters for an heuristic similar to the one described in the paper:
 "Feasibility Jump: an LP-free Lagrangian MIP heuristic", Bjrnar
 Luteberget, Giorgio Sartor, 2023, Mathematical Programming Computation.</div>
</td>
</tr>
<tr id="i259" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseFeasibilityPump--">getUseFeasibilityPump</a></span>()</code>
<div class="block">
 Adds a feasibility pump subsolver along with lns subsolvers.</div>
</td>
</tr>
<tr id="i260" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseHardPrecedencesInCumulative--">getUseHardPrecedencesInCumulative</a></span>()</code>
<div class="block">
 If true, detect and create constraint for integer variable that are "after"
 a set of intervals in the same cumulative constraint.</div>
</td>
</tr>
<tr id="i261" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseImpliedBounds--">getUseImpliedBounds</a></span>()</code>
<div class="block">
 Stores and exploits "implied-bounds" in the solver.</div>
</td>
</tr>
<tr id="i262" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseLbRelaxLns--">getUseLbRelaxLns</a></span>()</code>
<div class="block">
 Turns on neighborhood generator based on local branching LP.</div>
</td>
</tr>
<tr id="i263" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseLns--">getUseLns</a></span>()</code>
<div class="block">
 Testing parameters used to disable all lns workers.</div>
</td>
</tr>
<tr id="i264" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseLnsOnly--">getUseLnsOnly</a></span>()</code>
<div class="block">
 Experimental parameters to disable everything but lns.</div>
</td>
</tr>
<tr id="i265" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseLsOnly--">getUseLsOnly</a></span>()</code>
<div class="block">
 Disable every other type of subsolver, setting this turns CP-SAT into a
 pure local-search solver.</div>
</td>
</tr>
<tr id="i266" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseObjectiveLbSearch--">getUseObjectiveLbSearch</a></span>()</code>
<div class="block">
 If true, search will search in ascending max objective value (when
 minimizing) starting from the lower bound of the objective.</div>
</td>
</tr>
<tr id="i267" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseObjectiveShavingSearch--">getUseObjectiveShavingSearch</a></span>()</code>
<div class="block">
 This search differs from the previous search as it will not use assumptions
 to bound the objective, and it will recreate a full model with the
 hardcoded objective value.</div>
</td>
</tr>
<tr id="i268" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseOptimizationHints--">getUseOptimizationHints</a></span>()</code>
<div class="block">
 For an optimization problem, whether we follow some hints in order to find
 a better first solution.</div>
</td>
</tr>
<tr id="i269" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseOptionalVariables--">getUseOptionalVariables</a></span>()</code>
<div class="block">
 If true, we automatically detect variables whose constraint are always
 enforced by the same literal and we mark them as optional.</div>
</td>
</tr>
<tr id="i270" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseOverloadCheckerInCumulative--">getUseOverloadCheckerInCumulative</a></span>()</code>
<div class="block">
 When this is true, the cumulative constraint is reinforced with overload
 checking, i.e., an additional level of reasoning based on energy.</div>
</td>
</tr>
<tr id="i271" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUsePbResolution--">getUsePbResolution</a></span>()</code>
<div class="block">
 Whether to use pseudo-Boolean resolution to analyze a conflict.</div>
</td>
</tr>
<tr id="i272" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUsePhaseSaving--">getUsePhaseSaving</a></span>()</code>
<div class="block">
 If this is true, then the polarity of a variable will be the last value it
 was assigned to, or its default polarity if it was never assigned since the
 call to ResetDecisionHeuristic().</div>
</td>
</tr>
<tr id="i273" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUsePrecedencesInDisjunctiveConstraint--">getUsePrecedencesInDisjunctiveConstraint</a></span>()</code>
<div class="block">
 When this is true, then a disjunctive constraint will try to use the
 precedence relations between time intervals to propagate their bounds
 further.</div>
</td>
</tr>
<tr id="i274" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseProbingSearch--">getUseProbingSearch</a></span>()</code>
<div class="block">
 If true, search will continuously probe Boolean variables, and integer
 variable bounds.</div>
</td>
</tr>
<tr id="i275" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseRinsLns--">getUseRinsLns</a></span>()</code>
<div class="block">
 Turns on relaxation induced neighborhood generator.</div>
</td>
</tr>
<tr id="i276" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseSatInprocessing--">getUseSatInprocessing</a></span>()</code>
<div class="block">
 Enable or disable "inprocessing" which is some SAT presolving done at
 each restart to the root level.</div>
</td>
</tr>
<tr id="i277" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseSharedTreeSearch--">getUseSharedTreeSearch</a></span>()</code>
<div class="block">
 Set on shared subtree workers.</div>
</td>
</tr>
<tr id="i278" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseShavingInProbingSearch--">getUseShavingInProbingSearch</a></span>()</code>
<div class="block">
 Add a shaving phase (where the solver tries to prove that the lower or
 upper bound of a variable are infeasible) to the probing search.</div>
</td>
</tr>
<tr id="i279" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseStrongPropagationInDisjunctive--">getUseStrongPropagationInDisjunctive</a></span>()</code>
<div class="block">
 Enable stronger and more expensive propagation on no_overlap constraint.</div>
</td>
</tr>
<tr id="i280" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseSymmetryInLp--">getUseSymmetryInLp</a></span>()</code>
<div class="block">
 When we have symmetry, it is possible to "fold" all variables from the same
 orbit into a single variable, while having the same power of LP relaxation.</div>
</td>
</tr>
<tr id="i281" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseTimetableEdgeFindingInCumulative--">getUseTimetableEdgeFindingInCumulative</a></span>()</code>
<div class="block">
 When this is true, the cumulative constraint is reinforced with timetable
 edge finding, i.e., an additional level of reasoning based on the
 conjunction of energy and mandatory parts.</div>
</td>
</tr>
<tr id="i282" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseTimetablingInNoOverlap2D--">getUseTimetablingInNoOverlap2D</a></span>()</code>
<div class="block">
 When this is true, the no_overlap_2d constraint is reinforced with
 propagators from the cumulative constraints.</div>
</td>
</tr>
<tr id="i283" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseTryEdgeReasoningInNoOverlap2D--">getUseTryEdgeReasoningInNoOverlap2D</a></span>()</code>
<div class="block"><code>optional bool use_try_edge_reasoning_in_no_overlap_2d = 299 [default = false];</code></div>
</td>
</tr>
<tr id="i284" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getUseVariablesShavingSearch--">getUseVariablesShavingSearch</a></span>()</code>
<div class="block">
 This search takes all Boolean or integer variables, and maximize or
 minimize them in order to reduce their domain.</div>
</td>
</tr>
<tr id="i285" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getVariableActivityDecay--">getVariableActivityDecay</a></span>()</code>
<div class="block">
 Each time a conflict is found, the activities of some variables are
 increased by one.</div>
</td>
</tr>
<tr id="i286" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getViolationLsCompoundMoveProbability--">getViolationLsCompoundMoveProbability</a></span>()</code>
<div class="block">
 Probability of using compound move search each restart.</div>
</td>
</tr>
<tr id="i287" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#getViolationLsPerturbationPeriod--">getViolationLsPerturbationPeriod</a></span>()</code>
<div class="block">
 How long violation_ls should wait before perturbating a solution.</div>
</td>
</tr>
<tr id="i288" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAbsoluteGapLimit--">hasAbsoluteGapLimit</a></span>()</code>
<div class="block">
 Stop the search when the gap between the best feasible objective (O) and
 our best objective bound (B) is smaller than a limit.</div>
</td>
</tr>
<tr id="i289" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddCgCuts--">hasAddCgCuts</a></span>()</code>
<div class="block">
 Whether we generate and add Chvatal-Gomory cuts to the LP at root node.</div>
</td>
</tr>
<tr id="i290" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddCliqueCuts--">hasAddCliqueCuts</a></span>()</code>
<div class="block">
 Whether we generate clique cuts from the binary implication graph.</div>
</td>
</tr>
<tr id="i291" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddLinMaxCuts--">hasAddLinMaxCuts</a></span>()</code>
<div class="block">
 For the lin max constraints, generates the cuts described in "Strong
 mixed-integer programming formulations for trained neural networks" by Ross
 Anderson et.</div>
</td>
</tr>
<tr id="i292" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddLpConstraintsLazily--">hasAddLpConstraintsLazily</a></span>()</code>
<div class="block">
 If true, we start by an empty LP, and only add constraints not satisfied
 by the current LP solution batch by batch.</div>
</td>
</tr>
<tr id="i293" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddMirCuts--">hasAddMirCuts</a></span>()</code>
<div class="block">
 Whether we generate MIR cuts at root node.</div>
</td>
</tr>
<tr id="i294" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddObjectiveCut--">hasAddObjectiveCut</a></span>()</code>
<div class="block">
 When the LP objective is fractional, do we add the cut that forces the
 linear objective expression to be greater or equal to this fractional value
 rounded up?</div>
</td>
</tr>
<tr id="i295" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddRltCuts--">hasAddRltCuts</a></span>()</code>
<div class="block">
 Whether we generate RLT cuts.</div>
</td>
</tr>
<tr id="i296" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAddZeroHalfCuts--">hasAddZeroHalfCuts</a></span>()</code>
<div class="block">
 Whether we generate Zero-Half cuts at root node.</div>
</td>
</tr>
<tr id="i297" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAlsoBumpVariablesInConflictReasons--">hasAlsoBumpVariablesInConflictReasons</a></span>()</code>
<div class="block">
 When this is true, then the variables that appear in any of the reason of
 the variables in a conflict have their activity bumped.</div>
</td>
</tr>
<tr id="i298" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAtMostOneMaxExpansionSize--">hasAtMostOneMaxExpansionSize</a></span>()</code>
<div class="block">
 All at_most_one constraints with a size &lt;= param will be replaced by a
 quadratic number of binary implications.</div>
</td>
</tr>
<tr id="i299" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasAutoDetectGreaterThanAtLeastOneOf--">hasAutoDetectGreaterThanAtLeastOneOf</a></span>()</code>
<div class="block">
 If true, then the precedences propagator try to detect for each variable if
 it has a set of "optional incoming arc" for which at least one of them is
 present.</div>
</td>
</tr>
<tr id="i300" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasBinaryMinimizationAlgorithm--">hasBinaryMinimizationAlgorithm</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.BinaryMinizationAlgorithm binary_minimization_algorithm = 34 [default = BINARY_MINIMIZATION_FIRST];</code></div>
</td>
</tr>
<tr id="i301" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasBinarySearchNumConflicts--">hasBinarySearchNumConflicts</a></span>()</code>
<div class="block">
 If non-negative, perform a binary search on the objective variable in order
 to find an [min, max] interval outside of which the solver proved unsat/sat
 under this amount of conflict.</div>
</td>
</tr>
<tr id="i302" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasBlockingRestartMultiplier--">hasBlockingRestartMultiplier</a></span>()</code>
<div class="block"><code>optional double blocking_restart_multiplier = 66 [default = 1.4];</code></div>
</td>
</tr>
<tr id="i303" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasBlockingRestartWindowSize--">hasBlockingRestartWindowSize</a></span>()</code>
<div class="block"><code>optional int32 blocking_restart_window_size = 65 [default = 5000];</code></div>
</td>
</tr>
<tr id="i304" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasBooleanEncodingLevel--">hasBooleanEncodingLevel</a></span>()</code>
<div class="block">
 A non-negative level indicating how much we should try to fully encode
 Integer variables as Boolean.</div>
</td>
</tr>
<tr id="i305" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCatchSigintSignal--">hasCatchSigintSignal</a></span>()</code>
<div class="block">
 Indicates if the CP-SAT layer should catch Control-C (SIGINT) signals
 when calling solve.</div>
</td>
</tr>
<tr id="i306" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasClauseActivityDecay--">hasClauseActivityDecay</a></span>()</code>
<div class="block">
 Clause activity parameters (same effect as the one on the variables).</div>
</td>
</tr>
<tr id="i307" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasClauseCleanupLbdBound--">hasClauseCleanupLbdBound</a></span>()</code>
<div class="block">
 All the clauses with a LBD (literal blocks distance) lower or equal to this
 parameters will always be kept.</div>
</td>
</tr>
<tr id="i308" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasClauseCleanupOrdering--">hasClauseCleanupOrdering</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseOrdering clause_cleanup_ordering = 60 [default = CLAUSE_ACTIVITY];</code></div>
</td>
</tr>
<tr id="i309" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasClauseCleanupPeriod--">hasClauseCleanupPeriod</a></span>()</code>
<div class="block">
 Trigger a cleanup when this number of "deletable" clauses is learned.</div>
</td>
</tr>
<tr id="i310" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasClauseCleanupProtection--">hasClauseCleanupProtection</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseProtection clause_cleanup_protection = 58 [default = PROTECTION_NONE];</code></div>
</td>
</tr>
<tr id="i311" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasClauseCleanupRatio--">hasClauseCleanupRatio</a></span>()</code>
<div class="block">
 During a cleanup, if clause_cleanup_target is 0, we will delete the
 clause_cleanup_ratio of "deletable" clauses instead of aiming for a fixed
 target of clauses to keep.</div>
</td>
</tr>
<tr id="i312" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasClauseCleanupTarget--">hasClauseCleanupTarget</a></span>()</code>
<div class="block">
 During a cleanup, we will always keep that number of "deletable" clauses.</div>
</td>
</tr>
<tr id="i313" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasConvertIntervals--">hasConvertIntervals</a></span>()</code>
<div class="block">
 Temporary flag util the feature is more mature.</div>
</td>
</tr>
<tr id="i314" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCoreMinimizationLevel--">hasCoreMinimizationLevel</a></span>()</code>
<div class="block">
 If positive, we spend some effort on each core:
 - At level 1, we use a simple heuristic to try to minimize an UNSAT core</div>
</td>
</tr>
<tr id="i315" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCountAssumptionLevelsInLbd--">hasCountAssumptionLevelsInLbd</a></span>()</code>
<div class="block">
 Whether or not the assumption levels are taken into account during the LBD
 computation.</div>
</td>
</tr>
<tr id="i316" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCoverOptimization--">hasCoverOptimization</a></span>()</code>
<div class="block">
 If true, when the max-sat algo find a core, we compute the minimal number
 of literals in the core that needs to be true to have a feasible solution.</div>
</td>
</tr>
<tr id="i317" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCpModelPresolve--">hasCpModelPresolve</a></span>()</code>
<div class="block">
 Whether we presolve the cp_model before solving it.</div>
</td>
</tr>
<tr id="i318" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCpModelProbingLevel--">hasCpModelProbingLevel</a></span>()</code>
<div class="block">
 How much effort do we spend on probing. 0 disables it completely.</div>
</td>
</tr>
<tr id="i319" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCpModelUseSatPresolve--">hasCpModelUseSatPresolve</a></span>()</code>
<div class="block">
 Whether we also use the sat presolve when cp_model_presolve is true.</div>
</td>
</tr>
<tr id="i320" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCutActiveCountDecay--">hasCutActiveCountDecay</a></span>()</code>
<div class="block"><code>optional double cut_active_count_decay = 156 [default = 0.8];</code></div>
</td>
</tr>
<tr id="i321" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCutCleanupTarget--">hasCutCleanupTarget</a></span>()</code>
<div class="block">
 Target number of constraints to remove during cleanup.</div>
</td>
</tr>
<tr id="i322" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCutLevel--">hasCutLevel</a></span>()</code>
<div class="block">
 Control the global cut effort.</div>
</td>
</tr>
<tr id="i323" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasCutMaxActiveCountValue--">hasCutMaxActiveCountValue</a></span>()</code>
<div class="block">
 These parameters are similar to sat clause management activity parameters.</div>
</td>
</tr>
<tr id="i324" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDebugCrashIfPresolveBreaksHint--">hasDebugCrashIfPresolveBreaksHint</a></span>()</code>
<div class="block">
 Crash if presolve breaks a feasible hint.</div>
</td>
</tr>
<tr id="i325" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDebugCrashOnBadHint--">hasDebugCrashOnBadHint</a></span>()</code>
<div class="block">
 Crash if we do not manage to complete the hint into a full solution.</div>
</td>
</tr>
<tr id="i326" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDebugMaxNumPresolveOperations--">hasDebugMaxNumPresolveOperations</a></span>()</code>
<div class="block">
 If positive, try to stop just after that many presolve rules have been
 applied.</div>
</td>
</tr>
<tr id="i327" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDebugPostsolveWithFullSolver--">hasDebugPostsolveWithFullSolver</a></span>()</code>
<div class="block">
 We have two different postsolve code.</div>
</td>
</tr>
<tr id="i328" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDefaultRestartAlgorithms--">hasDefaultRestartAlgorithms</a></span>()</code>
<div class="block"><code>optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];</code></div>
</td>
</tr>
<tr id="i329" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDetectLinearizedProduct--">hasDetectLinearizedProduct</a></span>()</code>
<div class="block">
 Infer products of Boolean or of Boolean time IntegerVariable from the
 linear constrainst in the problem.</div>
</td>
</tr>
<tr id="i330" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDetectTableWithCost--">hasDetectTableWithCost</a></span>()</code>
<div class="block">
 If true, we detect variable that are unique to a table constraint and only
 there to encode a cost on each tuple.</div>
</td>
</tr>
<tr id="i331" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDisableConstraintExpansion--">hasDisableConstraintExpansion</a></span>()</code>
<div class="block">
 If true, it disable all constraint expansion.</div>
</td>
</tr>
<tr id="i332" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasDiversifyLnsParams--">hasDiversifyLnsParams</a></span>()</code>
<div class="block">
 If true, registers more lns subsolvers with different parameters.</div>
</td>
</tr>
<tr id="i333" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasEncodeComplexLinearConstraintWithInteger--">hasEncodeComplexLinearConstraintWithInteger</a></span>()</code>
<div class="block">
 Linear constraint with a complex right hand side (more than a single
 interval) need to be expanded, there is a couple of way to do that.</div>
</td>
</tr>
<tr id="i334" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasEncodeCumulativeAsReservoir--">hasEncodeCumulativeAsReservoir</a></span>()</code>
<div class="block">
 Encore cumulative with fixed demands and capacity as a reservoir
 constraint.</div>
</td>
</tr>
<tr id="i335" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasEnumerateAllSolutions--">hasEnumerateAllSolutions</a></span>()</code>
<div class="block">
 Whether we enumerate all solutions of a problem without objective.</div>
</td>
</tr>
<tr id="i336" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExpandAlldiffConstraints--">hasExpandAlldiffConstraints</a></span>()</code>
<div class="block">
 If true, expand all_different constraints that are not permutations.</div>
</td>
</tr>
<tr id="i337" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExpandReservoirConstraints--">hasExpandReservoirConstraints</a></span>()</code>
<div class="block">
 If true, expand the reservoir constraints by creating booleans for all
 possible precedences between event and encoding the constraint.</div>
</td>
</tr>
<tr id="i338" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExpandReservoirUsingCircuit--">hasExpandReservoirUsingCircuit</a></span>()</code>
<div class="block">
 Mainly useful for testing.</div>
</td>
</tr>
<tr id="i339" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExploitAllLpSolution--">hasExploitAllLpSolution</a></span>()</code>
<div class="block">
 If true and the Lp relaxation of the problem has a solution, try to exploit
 it.</div>
</td>
</tr>
<tr id="i340" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExploitAllPrecedences--">hasExploitAllPrecedences</a></span>()</code>
<div class="block"><code>optional bool exploit_all_precedences = 220 [default = false];</code></div>
</td>
</tr>
<tr id="i341" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExploitBestSolution--">hasExploitBestSolution</a></span>()</code>
<div class="block">
 When branching on a variable, follow the last best solution value.</div>
</td>
</tr>
<tr id="i342" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExploitIntegerLpSolution--">hasExploitIntegerLpSolution</a></span>()</code>
<div class="block">
 If true and the Lp relaxation of the problem has an integer optimal
 solution, try to exploit it.</div>
</td>
</tr>
<tr id="i343" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExploitObjective--">hasExploitObjective</a></span>()</code>
<div class="block">
 When branching an a variable that directly affect the objective,
 branch on the value that lead to the best objective first.</div>
</td>
</tr>
<tr id="i344" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasExploitRelaxationSolution--">hasExploitRelaxationSolution</a></span>()</code>
<div class="block">
 When branching on a variable, follow the last best relaxation solution
 value.</div>
</td>
</tr>
<tr id="i345" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpBatchDtime--">hasFeasibilityJumpBatchDtime</a></span>()</code>
<div class="block">
 How much dtime for each LS batch.</div>
</td>
</tr>
<tr id="i346" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpDecay--">hasFeasibilityJumpDecay</a></span>()</code>
<div class="block">
 On each restart, we randomly choose if we use decay (with this parameter)
 or no decay.</div>
</td>
</tr>
<tr id="i347" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpEnableRestarts--">hasFeasibilityJumpEnableRestarts</a></span>()</code>
<div class="block">
 When stagnating, feasibility jump will either restart from a default
 solution (with some possible randomization), or randomly pertubate the
 current solution.</div>
</td>
</tr>
<tr id="i348" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpLinearizationLevel--">hasFeasibilityJumpLinearizationLevel</a></span>()</code>
<div class="block">
 How much do we linearize the problem in the local search code.</div>
</td>
</tr>
<tr id="i349" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpMaxExpandedConstraintSize--">hasFeasibilityJumpMaxExpandedConstraintSize</a></span>()</code>
<div class="block">
 Maximum size of no_overlap or no_overlap_2d constraint for a quadratic
 expansion.</div>
</td>
</tr>
<tr id="i350" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpRestartFactor--">hasFeasibilityJumpRestartFactor</a></span>()</code>
<div class="block">
 This is a factor that directly influence the work before each restart.</div>
</td>
</tr>
<tr id="i351" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpVarPerburbationRangeRatio--">hasFeasibilityJumpVarPerburbationRangeRatio</a></span>()</code>
<div class="block">
 Max distance between the default value and the pertubated value relative to
 the range of the domain of the variable.</div>
</td>
</tr>
<tr id="i352" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFeasibilityJumpVarRandomizationProbability--">hasFeasibilityJumpVarRandomizationProbability</a></span>()</code>
<div class="block">
 Probability for a variable to have a non default value upon restarts or
 perturbations.</div>
</td>
</tr>
<tr id="i353" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFillAdditionalSolutionsInResponse--">hasFillAdditionalSolutionsInResponse</a></span>()</code>
<div class="block">
 If true, the final response addition_solutions field will be filled with
 all solutions from our solutions pool.</div>
</td>
</tr>
<tr id="i354" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFillTightenedDomainsInResponse--">hasFillTightenedDomainsInResponse</a></span>()</code>
<div class="block">
 If true, add information about the derived variable domains to the
 CpSolverResponse.</div>
</td>
</tr>
<tr id="i355" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFindBigLinearOverlap--">hasFindBigLinearOverlap</a></span>()</code>
<div class="block">
 Try to find large "rectangle" in the linear constraint matrix with
 identical lines.</div>
</td>
</tr>
<tr id="i356" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFindMultipleCores--">hasFindMultipleCores</a></span>()</code>
<div class="block">
 Whether we try to find more independent cores for a given set of
 assumptions in the core based max-SAT algorithms.</div>
</td>
</tr>
<tr id="i357" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFixVariablesToTheirHintedValue--">hasFixVariablesToTheirHintedValue</a></span>()</code>
<div class="block">
 If true, variables appearing in the solution hints will be fixed to their
 hinted value.</div>
</td>
</tr>
<tr id="i358" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasFpRounding--">hasFpRounding</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.FPRoundingMethod fp_rounding = 165 [default = PROPAGATION_ASSISTED];</code></div>
</td>
</tr>
<tr id="i359" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasGlucoseDecayIncrement--">hasGlucoseDecayIncrement</a></span>()</code>
<div class="block"><code>optional double glucose_decay_increment = 23 [default = 0.01];</code></div>
</td>
</tr>
<tr id="i360" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasGlucoseDecayIncrementPeriod--">hasGlucoseDecayIncrementPeriod</a></span>()</code>
<div class="block"><code>optional int32 glucose_decay_increment_period = 24 [default = 5000];</code></div>
</td>
</tr>
<tr id="i361" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasGlucoseMaxDecay--">hasGlucoseMaxDecay</a></span>()</code>
<div class="block">
 The activity starts at 0.8 and increment by 0.01 every 5000 conflicts until
 0.95.</div>
</td>
</tr>
<tr id="i362" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasHintConflictLimit--">hasHintConflictLimit</a></span>()</code>
<div class="block">
 Conflict limit used in the phase that exploit the solution hint.</div>
</td>
</tr>
<tr id="i363" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasIgnoreNames--">hasIgnoreNames</a></span>()</code>
<div class="block">
 If true, we don't keep names in our internal copy of the user given model.</div>
</td>
</tr>
<tr id="i364" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInferAllDiffs--">hasInferAllDiffs</a></span>()</code>
<div class="block">
 Run a max-clique code amongst all the x !</div>
</td>
</tr>
<tr id="i365" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInitialPolarity--">hasInitialPolarity</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.Polarity initial_polarity = 2 [default = POLARITY_FALSE];</code></div>
</td>
</tr>
<tr id="i366" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInitialVariablesActivity--">hasInitialVariablesActivity</a></span>()</code>
<div class="block">
 The initial value of the variables activity.</div>
</td>
</tr>
<tr id="i367" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInprocessingDtimeRatio--">hasInprocessingDtimeRatio</a></span>()</code>
<div class="block">
 Proportion of deterministic time we should spend on inprocessing.</div>
</td>
</tr>
<tr id="i368" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInprocessingMinimizationDtime--">hasInprocessingMinimizationDtime</a></span>()</code>
<div class="block">
 Parameters for an heuristic similar to the one described in "An effective
 learnt clause minimization approach for CDCL Sat Solvers",
 https://www.ijcai.org/proceedings/2017/0098.pdf

 This is the amount of dtime we should spend on this technique during each
 inprocessing phase.</div>
</td>
</tr>
<tr id="i369" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInprocessingMinimizationUseAllOrderings--">hasInprocessingMinimizationUseAllOrderings</a></span>()</code>
<div class="block"><code>optional bool inprocessing_minimization_use_all_orderings = 298 [default = false];</code></div>
</td>
</tr>
<tr id="i370" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInprocessingMinimizationUseConflictAnalysis--">hasInprocessingMinimizationUseConflictAnalysis</a></span>()</code>
<div class="block"><code>optional bool inprocessing_minimization_use_conflict_analysis = 297 [default = true];</code></div>
</td>
</tr>
<tr id="i371" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInprocessingProbingDtime--">hasInprocessingProbingDtime</a></span>()</code>
<div class="block">
 The amount of dtime we should spend on probing for each inprocessing round.</div>
</td>
</tr>
<tr id="i372" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInstantiateAllVariables--">hasInstantiateAllVariables</a></span>()</code>
<div class="block">
 If true, the solver will add a default integer branching strategy to the
 already defined search strategy.</div>
</td>
</tr>
<tr id="i373" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInterleaveBatchSize--">hasInterleaveBatchSize</a></span>()</code>
<div class="block"><code>optional int32 interleave_batch_size = 134 [default = 0];</code></div>
</td>
</tr>
<tr id="i374" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasInterleaveSearch--">hasInterleaveSearch</a></span>()</code>
<div class="block">
 Experimental.</div>
</td>
</tr>
<tr id="i375" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasKeepAllFeasibleSolutionsInPresolve--">hasKeepAllFeasibleSolutionsInPresolve</a></span>()</code>
<div class="block">
 If true, we disable the presolve reductions that remove feasible solutions
 from the search space.</div>
</td>
</tr>
<tr id="i376" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasKeepSymmetryInPresolve--">hasKeepSymmetryInPresolve</a></span>()</code>
<div class="block">
 Experimental.</div>
</td>
</tr>
<tr id="i377" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLbRelaxNumWorkersThreshold--">hasLbRelaxNumWorkersThreshold</a></span>()</code>
<div class="block">
 Only use lb-relax if we have at least that many workers.</div>
</td>
</tr>
<tr id="i378" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLinearizationLevel--">hasLinearizationLevel</a></span>()</code>
<div class="block">
 A non-negative level indicating the type of constraints we consider in the
 LP relaxation.</div>
</td>
</tr>
<tr id="i379" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLinearSplitSize--">hasLinearSplitSize</a></span>()</code>
<div class="block">
 Linear constraints that are not pseudo-Boolean and that are longer than
 this size will be split into sqrt(size) intermediate sums in order to have
 faster propation in the CP engine.</div>
</td>
</tr>
<tr id="i380" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLnsInitialDeterministicLimit--">hasLnsInitialDeterministicLimit</a></span>()</code>
<div class="block"><code>optional double lns_initial_deterministic_limit = 308 [default = 0.1];</code></div>
</td>
</tr>
<tr id="i381" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLnsInitialDifficulty--">hasLnsInitialDifficulty</a></span>()</code>
<div class="block">
 Initial parameters for neighborhood generation.</div>
</td>
</tr>
<tr id="i382" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLogPrefix--">hasLogPrefix</a></span>()</code>
<div class="block">
 Add a prefix to all logs.</div>
</td>
</tr>
<tr id="i383" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLogSearchProgress--">hasLogSearchProgress</a></span>()</code>
<div class="block">
 Whether the solver should log the search progress.</div>
</td>
</tr>
<tr id="i384" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLogSubsolverStatistics--">hasLogSubsolverStatistics</a></span>()</code>
<div class="block">
 Whether the solver should display per sub-solver search statistics.</div>
</td>
</tr>
<tr id="i385" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLogToResponse--">hasLogToResponse</a></span>()</code>
<div class="block">
 Log to response proto.</div>
</td>
</tr>
<tr id="i386" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLogToStdout--">hasLogToStdout</a></span>()</code>
<div class="block">
 Log to stdout.</div>
</td>
</tr>
<tr id="i387" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLpDualTolerance--">hasLpDualTolerance</a></span>()</code>
<div class="block"><code>optional double lp_dual_tolerance = 267 [default = 1e-07];</code></div>
</td>
</tr>
<tr id="i388" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasLpPrimalTolerance--">hasLpPrimalTolerance</a></span>()</code>
<div class="block">
 The internal LP tolerances used by CP-SAT.</div>
</td>
</tr>
<tr id="i389" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxAllDiffCutSize--">hasMaxAllDiffCutSize</a></span>()</code>
<div class="block">
 Cut generator for all diffs can add too many cuts for large all_diff
 constraints.</div>
</td>
</tr>
<tr id="i390" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxClauseActivityValue--">hasMaxClauseActivityValue</a></span>()</code>
<div class="block"><code>optional double max_clause_activity_value = 18 [default = 1e+20];</code></div>
</td>
</tr>
<tr id="i391" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxConsecutiveInactiveCount--">hasMaxConsecutiveInactiveCount</a></span>()</code>
<div class="block">
 If a constraint/cut in LP is not active for that many consecutive OPTIMAL
 solves, remove it from the LP.</div>
</td>
</tr>
<tr id="i392" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxCutRoundsAtLevelZero--">hasMaxCutRoundsAtLevelZero</a></span>()</code>
<div class="block">
 Max number of time we perform cut generation and resolve the LP at level 0.</div>
</td>
</tr>
<tr id="i393" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxDeterministicTime--">hasMaxDeterministicTime</a></span>()</code>
<div class="block">
 Maximum time allowed in deterministic time to solve a problem.</div>
</td>
</tr>
<tr id="i394" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxDomainSizeWhenEncodingEqNeqConstraints--">hasMaxDomainSizeWhenEncodingEqNeqConstraints</a></span>()</code>
<div class="block">
 When loading a*x + b*y ==/!</div>
</td>
</tr>
<tr id="i395" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaximumRegionsToSplitInDisconnectedNoOverlap2D--">hasMaximumRegionsToSplitInDisconnectedNoOverlap2D</a></span>()</code>
<div class="block">
 Detects when the space where items of a no_overlap_2d constraint can placed
 is disjoint (ie., fixed boxes split the domain).</div>
</td>
</tr>
<tr id="i396" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxIntegerRoundingScaling--">hasMaxIntegerRoundingScaling</a></span>()</code>
<div class="block">
 In the integer rounding procedure used for MIR and Gomory cut, the maximum
 "scaling" we use (must be positive).</div>
</td>
</tr>
<tr id="i397" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxLinMaxSizeForExpansion--">hasMaxLinMaxSizeForExpansion</a></span>()</code>
<div class="block">
 If the number of expressions in the lin_max is less that the max size
 parameter, model expansion replaces target = max(xi) by linear constraint
 with the introduction of new booleans bi such that bi =&gt; target == xi.</div>
</td>
</tr>
<tr id="i398" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxMemoryInMb--">hasMaxMemoryInMb</a></span>()</code>
<div class="block">
 Maximum memory allowed for the whole thread containing the solver.</div>
</td>
</tr>
<tr id="i399" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxNumberOfConflicts--">hasMaxNumberOfConflicts</a></span>()</code>
<div class="block">
 Maximum number of conflicts allowed to solve a problem.</div>
</td>
</tr>
<tr id="i400" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxNumCuts--">hasMaxNumCuts</a></span>()</code>
<div class="block">
 The limit on the number of cuts in our cut pool.</div>
</td>
</tr>
<tr id="i401" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxNumDeterministicBatches--">hasMaxNumDeterministicBatches</a></span>()</code>
<div class="block">
 Stops after that number of batches has been scheduled.</div>
</td>
</tr>
<tr id="i402" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxNumIntervalsForTimetableEdgeFinding--">hasMaxNumIntervalsForTimetableEdgeFinding</a></span>()</code>
<div class="block">
 Max number of intervals for the timetable_edge_finding algorithm to
 propagate.</div>
</td>
</tr>
<tr id="i403" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxPairsPairwiseReasoningInNoOverlap2D--">hasMaxPairsPairwiseReasoningInNoOverlap2D</a></span>()</code>
<div class="block">
 If the number of pairs to look is below this threshold, do an extra step of
 propagation in the no_overlap_2d constraint by looking at all pairs of
 intervals.</div>
</td>
</tr>
<tr id="i404" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxPresolveIterations--">hasMaxPresolveIterations</a></span>()</code>
<div class="block">
 In case of large reduction in a presolve iteration, we perform multiple
 presolve iterations.</div>
</td>
</tr>
<tr id="i405" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxSatAssumptionOrder--">hasMaxSatAssumptionOrder</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatAssumptionOrder max_sat_assumption_order = 51 [default = DEFAULT_ASSUMPTION_ORDER];</code></div>
</td>
</tr>
<tr id="i406" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxSatReverseAssumptionOrder--">hasMaxSatReverseAssumptionOrder</a></span>()</code>
<div class="block">
 If true, adds the assumption in the reverse order of the one defined by
 max_sat_assumption_order.</div>
</td>
</tr>
<tr id="i407" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxSatStratification--">hasMaxSatStratification</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatStratificationAlgorithm max_sat_stratification = 53 [default = STRATIFICATION_DESCENT];</code></div>
</td>
</tr>
<tr id="i408" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxSizeToCreatePrecedenceLiteralsInDisjunctive--">hasMaxSizeToCreatePrecedenceLiteralsInDisjunctive</a></span>()</code>
<div class="block">
 Create one literal for each disjunction of two pairs of tasks.</div>
</td>
</tr>
<tr id="i409" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxTimeInSeconds--">hasMaxTimeInSeconds</a></span>()</code>
<div class="block">
 Maximum time allowed in seconds to solve a problem.</div>
</td>
</tr>
<tr id="i410" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMaxVariableActivityValue--">hasMaxVariableActivityValue</a></span>()</code>
<div class="block"><code>optional double max_variable_activity_value = 16 [default = 1e+100];</code></div>
</td>
</tr>
<tr id="i411" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMergeAtMostOneWorkLimit--">hasMergeAtMostOneWorkLimit</a></span>()</code>
<div class="block"><code>optional double merge_at_most_one_work_limit = 146 [default = 100000000];</code></div>
</td>
</tr>
<tr id="i412" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMergeNoOverlapWorkLimit--">hasMergeNoOverlapWorkLimit</a></span>()</code>
<div class="block">
 During presolve, we use a maximum clique heuristic to merge together
 no-overlap constraints or at most one constraints.</div>
</td>
</tr>
<tr id="i413" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMinimizationAlgorithm--">hasMinimizationAlgorithm</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.ConflictMinimizationAlgorithm minimization_algorithm = 4 [default = RECURSIVE];</code></div>
</td>
</tr>
<tr id="i414" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMinimizeReductionDuringPbResolution--">hasMinimizeReductionDuringPbResolution</a></span>()</code>
<div class="block">
 A different algorithm during PB resolution.</div>
</td>
</tr>
<tr id="i415" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMinimizeSharedClauses--">hasMinimizeSharedClauses</a></span>()</code>
<div class="block">
 Minimize and detect subsumption of shared clauses immediately after they
 are imported.</div>
</td>
</tr>
<tr id="i416" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMinOrthogonalityForLpConstraints--">hasMinOrthogonalityForLpConstraints</a></span>()</code>
<div class="block">
 While adding constraints, skip the constraints which have orthogonality
 less than 'min_orthogonality_for_lp_constraints' with already added
 constraints during current call.</div>
</td>
</tr>
<tr id="i417" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipAutomaticallyScaleVariables--">hasMipAutomaticallyScaleVariables</a></span>()</code>
<div class="block">
 If true, some continuous variable might be automatically scaled.</div>
</td>
</tr>
<tr id="i418" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipCheckPrecision--">hasMipCheckPrecision</a></span>()</code>
<div class="block">
 As explained in mip_precision and mip_max_activity_exponent, we cannot
 always reach the wanted precision during scaling.</div>
</td>
</tr>
<tr id="i419" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipComputeTrueObjectiveBound--">hasMipComputeTrueObjectiveBound</a></span>()</code>
<div class="block">
 Even if we make big error when scaling the objective, we can always derive
 a correct lower bound on the original objective by using the exact lower
 bound on the scaled integer version of the objective.</div>
</td>
</tr>
<tr id="i420" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipDropTolerance--">hasMipDropTolerance</a></span>()</code>
<div class="block">
 Any value in the input mip with a magnitude lower than this will be set to
 zero.</div>
</td>
</tr>
<tr id="i421" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipMaxActivityExponent--">hasMipMaxActivityExponent</a></span>()</code>
<div class="block">
 To avoid integer overflow, we always force the maximum possible constraint
 activity (and objective value) according to the initial variable domain to
 be smaller than 2 to this given power.</div>
</td>
</tr>
<tr id="i422" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipMaxBound--">hasMipMaxBound</a></span>()</code>
<div class="block">
 We need to bound the maximum magnitude of the variables for CP-SAT, and
 that is the bound we use.</div>
</td>
</tr>
<tr id="i423" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipMaxValidMagnitude--">hasMipMaxValidMagnitude</a></span>()</code>
<div class="block">
 Any finite values in the input MIP must be below this threshold, otherwise
 the model will be reported invalid.</div>
</td>
</tr>
<tr id="i424" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipPresolveLevel--">hasMipPresolveLevel</a></span>()</code>
<div class="block">
 When solving a MIP, we do some basic floating point presolving before
 scaling the problem to integer to be handled by CP-SAT.</div>
</td>
</tr>
<tr id="i425" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipScaleLargeDomain--">hasMipScaleLargeDomain</a></span>()</code>
<div class="block">
 If this is false, then mip_var_scaling is only applied to variables with
 "small" domain.</div>
</td>
</tr>
<tr id="i426" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipTreatHighMagnitudeBoundsAsInfinity--">hasMipTreatHighMagnitudeBoundsAsInfinity</a></span>()</code>
<div class="block">
 By default, any variable/constraint bound with a finite value and a
 magnitude greater than the mip_max_valid_magnitude will result with a
 invalid model.</div>
</td>
</tr>
<tr id="i427" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipVarScaling--">hasMipVarScaling</a></span>()</code>
<div class="block">
 All continuous variable of the problem will be multiplied by this factor.</div>
</td>
</tr>
<tr id="i428" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasMipWantedPrecision--">hasMipWantedPrecision</a></span>()</code>
<div class="block">
 When scaling constraint with double coefficients to integer coefficients,
 we will multiply by a power of 2 and round the coefficients.</div>
</td>
</tr>
<tr id="i429" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasName--">hasName</a></span>()</code>
<div class="block">
 In some context, like in a portfolio of search, it makes sense to name a
 given parameters set for logging purpose.</div>
</td>
</tr>
<tr id="i430" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasNewConstraintsBatchSize--">hasNewConstraintsBatchSize</a></span>()</code>
<div class="block">
 Add that many lazy constraints (or cuts) at once in the LP.</div>
</td>
</tr>
<tr id="i431" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasNewLinearPropagation--">hasNewLinearPropagation</a></span>()</code>
<div class="block">
 The new linear propagation code treat all constraints at once and use
 an adaptation of Bellman-Ford-Tarjan to propagate constraint in a smarter
 order and potentially detect propagation cycle earlier.</div>
</td>
</tr>
<tr id="i432" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasNumConflictsBeforeStrategyChanges--">hasNumConflictsBeforeStrategyChanges</a></span>()</code>
<div class="block">
 After each restart, if the number of conflict since the last strategy
 change is greater that this, then we increment a "strategy_counter" that
 can be use to change the search strategy used by the following restarts.</div>
</td>
</tr>
<tr id="i433" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasNumFullSubsolvers--">hasNumFullSubsolvers</a></span>()</code>
<div class="block">
 We distinguish subsolvers that consume a full thread, and the ones that are
 always interleaved.</div>
</td>
</tr>
<tr id="i434" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasNumSearchWorkers--">hasNumSearchWorkers</a></span>()</code>
<div class="block"><code>optional int32 num_search_workers = 100 [default = 0];</code></div>
</td>
</tr>
<tr id="i435" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasNumViolationLs--">hasNumViolationLs</a></span>()</code>
<div class="block">
 This will create incomplete subsolvers (that are not LNS subsolvers)
 that use the feasibility jump code to find improving solution, treating
 the objective improvement as a hard constraint.</div>
</td>
</tr>
<tr id="i436" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasNumWorkers--">hasNumWorkers</a></span>()</code>
<div class="block">
 Specify the number of parallel workers (i.e. threads) to use during search.</div>
</td>
</tr>
<tr id="i437" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasOnlyAddCutsAtLevelZero--">hasOnlyAddCutsAtLevelZero</a></span>()</code>
<div class="block">
 For the cut that can be generated at any level, this control if we only
 try to generate them at the root node.</div>
</td>
</tr>
<tr id="i438" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasOnlySolveIp--">hasOnlySolveIp</a></span>()</code>
<div class="block">
 If one try to solve a MIP model with CP-SAT, because we assume all variable
 to be integer after scaling, we will not necessarily have the correct
 optimal.</div>
</td>
</tr>
<tr id="i439" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasOptimizeWithCore--">hasOptimizeWithCore</a></span>()</code>
<div class="block">
 The default optimization method is a simple "linear scan", each time trying
 to find a better solution than the previous one.</div>
</td>
</tr>
<tr id="i440" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasOptimizeWithLbTreeSearch--">hasOptimizeWithLbTreeSearch</a></span>()</code>
<div class="block">
 Do a more conventional tree search (by opposition to SAT based one) where
 we keep all the explored node in a tree.</div>
</td>
</tr>
<tr id="i441" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasOptimizeWithMaxHs--">hasOptimizeWithMaxHs</a></span>()</code>
<div class="block">
 This has no effect if optimize_with_core is false.</div>
</td>
</tr>
<tr id="i442" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPbCleanupIncrement--">hasPbCleanupIncrement</a></span>()</code>
<div class="block">
 Same as for the clauses, but for the learned pseudo-Boolean constraints.</div>
</td>
</tr>
<tr id="i443" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPbCleanupRatio--">hasPbCleanupRatio</a></span>()</code>
<div class="block"><code>optional double pb_cleanup_ratio = 47 [default = 0.5];</code></div>
</td>
</tr>
<tr id="i444" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPermutePresolveConstraintOrder--">hasPermutePresolveConstraintOrder</a></span>()</code>
<div class="block"><code>optional bool permute_presolve_constraint_order = 179 [default = false];</code></div>
</td>
</tr>
<tr id="i445" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPermuteVariableRandomly--">hasPermuteVariableRandomly</a></span>()</code>
<div class="block">
 This is mainly here to test the solver variability.</div>
</td>
</tr>
<tr id="i446" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPolarityExploitLsHints--">hasPolarityExploitLsHints</a></span>()</code>
<div class="block">
 If true and we have first solution LS workers, tries in some phase to
 follow a LS solutions that violates has litle constraints as possible.</div>
</td>
</tr>
<tr id="i447" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPolarityRephaseIncrement--">hasPolarityRephaseIncrement</a></span>()</code>
<div class="block">
 If non-zero, then we change the polarity heuristic after that many number
 of conflicts in an arithmetically increasing fashion.</div>
</td>
</tr>
<tr id="i448" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPolishLpSolution--">hasPolishLpSolution</a></span>()</code>
<div class="block">
 Whether we try to do a few degenerate iteration at the end of an LP solve
 to minimize the fractionality of the integer variable in the basis.</div>
</td>
</tr>
<tr id="i449" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPreferredVariableOrder--">hasPreferredVariableOrder</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.VariableOrder preferred_variable_order = 1 [default = IN_ORDER];</code></div>
</td>
</tr>
<tr id="i450" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveBlockedClause--">hasPresolveBlockedClause</a></span>()</code>
<div class="block">
 Whether we use an heuristic to detect some basic case of blocked clause
 in the SAT presolve.</div>
</td>
</tr>
<tr id="i451" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveBvaThreshold--">hasPresolveBvaThreshold</a></span>()</code>
<div class="block">
 Apply Bounded Variable Addition (BVA) if the number of clauses is reduced
 by stricly more than this threshold.</div>
</td>
</tr>
<tr id="i452" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveBveClauseWeight--">hasPresolveBveClauseWeight</a></span>()</code>
<div class="block">
 During presolve, we apply BVE only if this weight times the number of
 clauses plus the number of clause literals is not increased.</div>
</td>
</tr>
<tr id="i453" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveBveThreshold--">hasPresolveBveThreshold</a></span>()</code>
<div class="block">
 During presolve, only try to perform the bounded variable elimination (BVE)
 of a variable x if the number of occurrences of x times the number of
 occurrences of not(x) is not greater than this parameter.</div>
</td>
</tr>
<tr id="i454" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveExtractIntegerEnforcement--">hasPresolveExtractIntegerEnforcement</a></span>()</code>
<div class="block">
 If true, we will extract from linear constraints, enforcement literals of
 the form "integer variable at bound =&gt; simplified constraint".</div>
</td>
</tr>
<tr id="i455" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveInclusionWorkLimit--">hasPresolveInclusionWorkLimit</a></span>()</code>
<div class="block">
 A few presolve operations involve detecting constraints included in other
 constraint.</div>
</td>
</tr>
<tr id="i456" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveProbingDeterministicTimeLimit--">hasPresolveProbingDeterministicTimeLimit</a></span>()</code>
<div class="block"><code>optional double presolve_probing_deterministic_time_limit = 57 [default = 30];</code></div>
</td>
</tr>
<tr id="i457" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveSubstitutionLevel--">hasPresolveSubstitutionLevel</a></span>()</code>
<div class="block">
 How much substitution (also called free variable aggregation in MIP
 litterature) should we perform at presolve.</div>
</td>
</tr>
<tr id="i458" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPresolveUseBva--">hasPresolveUseBva</a></span>()</code>
<div class="block">
 Whether or not we use Bounded Variable Addition (BVA) in the presolve.</div>
</td>
</tr>
<tr id="i459" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasProbingDeterministicTimeLimit--">hasProbingDeterministicTimeLimit</a></span>()</code>
<div class="block">
 The maximum "deterministic" time limit to spend in probing.</div>
</td>
</tr>
<tr id="i460" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasProbingNumCombinationsLimit--">hasProbingNumCombinationsLimit</a></span>()</code>
<div class="block">
 How many combinations of pairs or triplets of variables we want to scan.</div>
</td>
</tr>
<tr id="i461" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPropagationLoopDetectionFactor--">hasPropagationLoopDetectionFactor</a></span>()</code>
<div class="block">
 Some search decisions might cause a really large number of propagations to
 happen when integer variables with large domains are only reduced by 1 at
 each step.</div>
</td>
</tr>
<tr id="i462" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPseudoCostReliabilityThreshold--">hasPseudoCostReliabilityThreshold</a></span>()</code>
<div class="block">
 The solver ignores the pseudo costs of variables with number of recordings
 less than this threshold.</div>
</td>
</tr>
<tr id="i463" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasPushAllTasksTowardStart--">hasPushAllTasksTowardStart</a></span>()</code>
<div class="block">
 Experimental code: specify if the objective pushes all tasks toward the
 start of the schedule.</div>
</td>
</tr>
<tr id="i464" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRandomBranchesRatio--">hasRandomBranchesRatio</a></span>()</code>
<div class="block">
 A number between 0 and 1 that indicates the proportion of branching
 variables that are selected randomly instead of choosing the first variable
 from the given variable_ordering strategy.</div>
</td>
</tr>
<tr id="i465" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRandomizeSearch--">hasRandomizeSearch</a></span>()</code>
<div class="block">
 Randomize fixed search.</div>
</td>
</tr>
<tr id="i466" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRandomPolarityRatio--">hasRandomPolarityRatio</a></span>()</code>
<div class="block">
 The proportion of polarity chosen at random.</div>
</td>
</tr>
<tr id="i467" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRandomSeed--">hasRandomSeed</a></span>()</code>
<div class="block">
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed.</div>
</td>
</tr>
<tr id="i468" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRelativeGapLimit--">hasRelativeGapLimit</a></span>()</code>
<div class="block"><code>optional double relative_gap_limit = 160 [default = 0];</code></div>
</td>
</tr>
<tr id="i469" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRemoveFixedVariablesEarly--">hasRemoveFixedVariablesEarly</a></span>()</code>
<div class="block">
 If cp_model_presolve is true and there is a large proportion of fixed
 variable after the first model copy, remap all the model to a dense set of
 variable before the full presolve even starts.</div>
</td>
</tr>
<tr id="i470" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRepairHint--">hasRepairHint</a></span>()</code>
<div class="block">
 If true, the solver tries to repair the solution given in the hint.</div>
</td>
</tr>
<tr id="i471" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRestartDlAverageRatio--">hasRestartDlAverageRatio</a></span>()</code>
<div class="block">
 In the moving average restart algorithms, a restart is triggered if the
 window average times this ratio is greater that the global average.</div>
</td>
</tr>
<tr id="i472" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRestartLbdAverageRatio--">hasRestartLbdAverageRatio</a></span>()</code>
<div class="block"><code>optional double restart_lbd_average_ratio = 71 [default = 1];</code></div>
</td>
</tr>
<tr id="i473" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRestartPeriod--">hasRestartPeriod</a></span>()</code>
<div class="block">
 Restart period for the FIXED_RESTART strategy.</div>
</td>
</tr>
<tr id="i474" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRestartRunningWindowSize--">hasRestartRunningWindowSize</a></span>()</code>
<div class="block">
 Size of the window for the moving average restarts.</div>
</td>
</tr>
<tr id="i475" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRootLpIterations--">hasRootLpIterations</a></span>()</code>
<div class="block">
 Even at the root node, we do not want to spend too much time on the LP if
 it is "difficult".</div>
</td>
</tr>
<tr id="i476" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRoutingCutDpEffort--">hasRoutingCutDpEffort</a></span>()</code>
<div class="block">
 The amount of "effort" to spend in dynamic programming for computing
 routing cuts.</div>
</td>
</tr>
<tr id="i477" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRoutingCutSubsetSizeForBinaryRelationBound--">hasRoutingCutSubsetSizeForBinaryRelationBound</a></span>()</code>
<div class="block">
 If the size of a subset of nodes of a RoutesConstraint is less than this
 value, use linear constraints of size 1 and 2 (such as capacity and time
 window constraints) enforced by the arc literals to compute cuts for this
 subset (unless the subset size is less than
 routing_cut_subset_size_for_tight_binary_relation_bound, in which case the
 corresponding algorithm is used instead).</div>
</td>
</tr>
<tr id="i478" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasRoutingCutSubsetSizeForTightBinaryRelationBound--">hasRoutingCutSubsetSizeForTightBinaryRelationBound</a></span>()</code>
<div class="block">
 Similar to above, but with a different algorithm producing better cuts, at
 the price of a higher O(2^n) complexity, where n is the subset size.</div>
</td>
</tr>
<tr id="i479" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSaveLpBasisInLbTreeSearch--">hasSaveLpBasisInLbTreeSearch</a></span>()</code>
<div class="block">
 Experimental.</div>
</td>
</tr>
<tr id="i480" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSearchBranching--">hasSearchBranching</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.SearchBranching search_branching = 82 [default = AUTOMATIC_SEARCH];</code></div>
</td>
</tr>
<tr id="i481" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSearchRandomVariablePoolSize--">hasSearchRandomVariablePoolSize</a></span>()</code>
<div class="block">
 Search randomization will collect the top
 'search_random_variable_pool_size' valued variables, and pick one randomly.</div>
</td>
</tr>
<tr id="i482" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasShareBinaryClauses--">hasShareBinaryClauses</a></span>()</code>
<div class="block">
 Allows sharing of new learned binary clause between workers.</div>
</td>
</tr>
<tr id="i483" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeBalanceTolerance--">hasSharedTreeBalanceTolerance</a></span>()</code>
<div class="block">
 How much deeper compared to the ideal max depth of the tree is considered
 "balanced" enough to still accept a split.</div>
</td>
</tr>
<tr id="i484" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeMaxNodesPerWorker--">hasSharedTreeMaxNodesPerWorker</a></span>()</code>
<div class="block">
 In order to limit total shared memory and communication overhead, limit the
 total number of nodes that may be generated in the shared tree.</div>
</td>
</tr>
<tr id="i485" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeNumWorkers--">hasSharedTreeNumWorkers</a></span>()</code>
<div class="block">
 Enables shared tree search.</div>
</td>
</tr>
<tr id="i486" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeOpenLeavesPerWorker--">hasSharedTreeOpenLeavesPerWorker</a></span>()</code>
<div class="block">
 How many open leaf nodes should the shared tree maintain per worker.</div>
</td>
</tr>
<tr id="i487" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeSplitStrategy--">hasSharedTreeSplitStrategy</a></span>()</code>
<div class="block"><code>optional .operations_research.sat.SatParameters.SharedTreeSplitStrategy shared_tree_split_strategy = 239 [default = SPLIT_STRATEGY_AUTO];</code></div>
</td>
</tr>
<tr id="i488" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeWorkerEnablePhaseSharing--">hasSharedTreeWorkerEnablePhaseSharing</a></span>()</code>
<div class="block">
 If true, shared tree workers share their target phase when returning an
 assigned subtree for the next worker to use.</div>
</td>
</tr>
<tr id="i489" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeWorkerEnableTrailSharing--">hasSharedTreeWorkerEnableTrailSharing</a></span>()</code>
<div class="block">
 If true, workers share more of the information from their local trail.</div>
</td>
</tr>
<tr id="i490" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSharedTreeWorkerMinRestartsPerSubtree--">hasSharedTreeWorkerMinRestartsPerSubtree</a></span>()</code>
<div class="block">
 Minimum restarts before a worker will replace a subtree
 that looks "bad" based on the average LBD of learned clauses.</div>
</td>
</tr>
<tr id="i491" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasShareGlueClauses--">hasShareGlueClauses</a></span>()</code>
<div class="block">
 Allows sharing of short glue clauses between workers.</div>
</td>
</tr>
<tr id="i492" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasShareLevelZeroBounds--">hasShareLevelZeroBounds</a></span>()</code>
<div class="block">
 Allows sharing of the bounds of modified variables at level 0.</div>
</td>
</tr>
<tr id="i493" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasShareObjectiveBounds--">hasShareObjectiveBounds</a></span>()</code>
<div class="block">
 Allows objective sharing between workers.</div>
</td>
</tr>
<tr id="i494" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasShavingSearchDeterministicTime--">hasShavingSearchDeterministicTime</a></span>()</code>
<div class="block">
 Specifies the amount of deterministic time spent of each try at shaving a
 bound in the shaving search.</div>
</td>
</tr>
<tr id="i495" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasShavingSearchThreshold--">hasShavingSearchThreshold</a></span>()</code>
<div class="block">
 Specifies the threshold between two modes in the shaving procedure.</div>
</td>
</tr>
<tr id="i496" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSolutionPoolSize--">hasSolutionPoolSize</a></span>()</code>
<div class="block">
 Size of the top-n different solutions kept by the solver.</div>
</td>
</tr>
<tr id="i497" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasStopAfterFirstSolution--">hasStopAfterFirstSolution</a></span>()</code>
<div class="block">
 For an optimization problem, stop the solver as soon as we have a solution.</div>
</td>
</tr>
<tr id="i498" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasStopAfterPresolve--">hasStopAfterPresolve</a></span>()</code>
<div class="block">
 Mainly used when improving the presolver.</div>
</td>
</tr>
<tr id="i499" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasStopAfterRootPropagation--">hasStopAfterRootPropagation</a></span>()</code>
<div class="block"><code>optional bool stop_after_root_propagation = 252 [default = false];</code></div>
</td>
</tr>
<tr id="i500" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasStrategyChangeIncreaseRatio--">hasStrategyChangeIncreaseRatio</a></span>()</code>
<div class="block">
 The parameter num_conflicts_before_strategy_changes is increased by that
 much after each strategy change.</div>
</td>
</tr>
<tr id="i501" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSubsumptionDuringConflictAnalysis--">hasSubsumptionDuringConflictAnalysis</a></span>()</code>
<div class="block">
 At a really low cost, during the 1-UIP conflict computation, it is easy to
 detect if some of the involved reasons are subsumed by the current
 conflict.</div>
</td>
</tr>
<tr id="i502" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSymmetryDetectionDeterministicTimeLimit--">hasSymmetryDetectionDeterministicTimeLimit</a></span>()</code>
<div class="block">
 Deterministic time limit for symmetry detection.</div>
</td>
</tr>
<tr id="i503" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasSymmetryLevel--">hasSymmetryLevel</a></span>()</code>
<div class="block">
 Whether we try to automatically detect the symmetries in a model and
 exploit them.</div>
</td>
</tr>
<tr id="i504" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasTableCompressionLevel--">hasTableCompressionLevel</a></span>()</code>
<div class="block">
 How much we try to "compress" a table constraint.</div>
</td>
</tr>
<tr id="i505" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseAbslRandom--">hasUseAbslRandom</a></span>()</code>
<div class="block"><code>optional bool use_absl_random = 180 [default = false];</code></div>
</td>
</tr>
<tr id="i506" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseAllDifferentForCircuit--">hasUseAllDifferentForCircuit</a></span>()</code>
<div class="block">
 Turn on extra propagation for the circuit constraint.</div>
</td>
</tr>
<tr id="i507" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseAreaEnergeticReasoningInNoOverlap2D--">hasUseAreaEnergeticReasoningInNoOverlap2D</a></span>()</code>
<div class="block">
 When this is true, the no_overlap_2d constraint is reinforced with
 an energetic reasoning that uses an area-based energy.</div>
</td>
</tr>
<tr id="i508" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseBlockingRestart--">hasUseBlockingRestart</a></span>()</code>
<div class="block">
 Block a moving restart algorithm if the trail size of the current conflict
 is greater than the multiplier times the moving average of the trail size
 at the previous conflicts.</div>
</td>
</tr>
<tr id="i509" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseCombinedNoOverlap--">hasUseCombinedNoOverlap</a></span>()</code>
<div class="block">
 This can be beneficial if there is a lot of no-overlap constraints but a
 relatively low number of different intervals in the problem.</div>
</td>
</tr>
<tr id="i510" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseConservativeScaleOverloadChecker--">hasUseConservativeScaleOverloadChecker</a></span>()</code>
<div class="block">
 Enable a heuristic to solve cumulative constraints using a modified energy
 constraint.</div>
</td>
</tr>
<tr id="i511" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseDisjunctiveConstraintInCumulative--">hasUseDisjunctiveConstraintInCumulative</a></span>()</code>
<div class="block">
 When this is true, the cumulative constraint is reinforced with propagators
 from the disjunctive constraint to improve the inference on a set of tasks
 that are disjunctive at the root of the problem.</div>
</td>
</tr>
<tr id="i512" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseDualSchedulingHeuristics--">hasUseDualSchedulingHeuristics</a></span>()</code>
<div class="block">
 When set, it activates a few scheduling parameters to improve the lower
 bound of scheduling problems.</div>
</td>
</tr>
<tr id="i513" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseDynamicPrecedenceInCumulative--">hasUseDynamicPrecedenceInCumulative</a></span>()</code>
<div class="block"><code>optional bool use_dynamic_precedence_in_cumulative = 268 [default = false];</code></div>
</td>
</tr>
<tr id="i514" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseDynamicPrecedenceInDisjunctive--">hasUseDynamicPrecedenceInDisjunctive</a></span>()</code>
<div class="block">
 Whether we try to branch on decision "interval A before interval B" rather
 than on intervals bounds.</div>
</td>
</tr>
<tr id="i515" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseEnergeticReasoningInNoOverlap2D--">hasUseEnergeticReasoningInNoOverlap2D</a></span>()</code>
<div class="block">
 When this is true, the no_overlap_2d constraint is reinforced with
 energetic reasoning.</div>
</td>
</tr>
<tr id="i516" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseErwaHeuristic--">hasUseErwaHeuristic</a></span>()</code>
<div class="block">
 Whether we use the ERWA (Exponential Recency Weighted Average) heuristic as
 described in "Learning Rate Based Branching Heuristic for SAT solvers",
 J.H.Liang, V.</div>
</td>
</tr>
<tr id="i517" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseExactLpReason--">hasUseExactLpReason</a></span>()</code>
<div class="block">
 The solver usually exploit the LP relaxation of a model.</div>
</td>
</tr>
<tr id="i518" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseExtendedProbing--">hasUseExtendedProbing</a></span>()</code>
<div class="block">
 Use extended probing (probe bool_or, at_most_one, exactly_one).</div>
</td>
</tr>
<tr id="i519" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseFeasibilityJump--">hasUseFeasibilityJump</a></span>()</code>
<div class="block">
 Parameters for an heuristic similar to the one described in the paper:
 "Feasibility Jump: an LP-free Lagrangian MIP heuristic", Bjrnar
 Luteberget, Giorgio Sartor, 2023, Mathematical Programming Computation.</div>
</td>
</tr>
<tr id="i520" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseFeasibilityPump--">hasUseFeasibilityPump</a></span>()</code>
<div class="block">
 Adds a feasibility pump subsolver along with lns subsolvers.</div>
</td>
</tr>
<tr id="i521" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseHardPrecedencesInCumulative--">hasUseHardPrecedencesInCumulative</a></span>()</code>
<div class="block">
 If true, detect and create constraint for integer variable that are "after"
 a set of intervals in the same cumulative constraint.</div>
</td>
</tr>
<tr id="i522" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseImpliedBounds--">hasUseImpliedBounds</a></span>()</code>
<div class="block">
 Stores and exploits "implied-bounds" in the solver.</div>
</td>
</tr>
<tr id="i523" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseLbRelaxLns--">hasUseLbRelaxLns</a></span>()</code>
<div class="block">
 Turns on neighborhood generator based on local branching LP.</div>
</td>
</tr>
<tr id="i524" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseLns--">hasUseLns</a></span>()</code>
<div class="block">
 Testing parameters used to disable all lns workers.</div>
</td>
</tr>
<tr id="i525" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseLnsOnly--">hasUseLnsOnly</a></span>()</code>
<div class="block">
 Experimental parameters to disable everything but lns.</div>
</td>
</tr>
<tr id="i526" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseLsOnly--">hasUseLsOnly</a></span>()</code>
<div class="block">
 Disable every other type of subsolver, setting this turns CP-SAT into a
 pure local-search solver.</div>
</td>
</tr>
<tr id="i527" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseObjectiveLbSearch--">hasUseObjectiveLbSearch</a></span>()</code>
<div class="block">
 If true, search will search in ascending max objective value (when
 minimizing) starting from the lower bound of the objective.</div>
</td>
</tr>
<tr id="i528" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseObjectiveShavingSearch--">hasUseObjectiveShavingSearch</a></span>()</code>
<div class="block">
 This search differs from the previous search as it will not use assumptions
 to bound the objective, and it will recreate a full model with the
 hardcoded objective value.</div>
</td>
</tr>
<tr id="i529" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseOptimizationHints--">hasUseOptimizationHints</a></span>()</code>
<div class="block">
 For an optimization problem, whether we follow some hints in order to find
 a better first solution.</div>
</td>
</tr>
<tr id="i530" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseOptionalVariables--">hasUseOptionalVariables</a></span>()</code>
<div class="block">
 If true, we automatically detect variables whose constraint are always
 enforced by the same literal and we mark them as optional.</div>
</td>
</tr>
<tr id="i531" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseOverloadCheckerInCumulative--">hasUseOverloadCheckerInCumulative</a></span>()</code>
<div class="block">
 When this is true, the cumulative constraint is reinforced with overload
 checking, i.e., an additional level of reasoning based on energy.</div>
</td>
</tr>
<tr id="i532" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUsePbResolution--">hasUsePbResolution</a></span>()</code>
<div class="block">
 Whether to use pseudo-Boolean resolution to analyze a conflict.</div>
</td>
</tr>
<tr id="i533" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUsePhaseSaving--">hasUsePhaseSaving</a></span>()</code>
<div class="block">
 If this is true, then the polarity of a variable will be the last value it
 was assigned to, or its default polarity if it was never assigned since the
 call to ResetDecisionHeuristic().</div>
</td>
</tr>
<tr id="i534" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUsePrecedencesInDisjunctiveConstraint--">hasUsePrecedencesInDisjunctiveConstraint</a></span>()</code>
<div class="block">
 When this is true, then a disjunctive constraint will try to use the
 precedence relations between time intervals to propagate their bounds
 further.</div>
</td>
</tr>
<tr id="i535" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseProbingSearch--">hasUseProbingSearch</a></span>()</code>
<div class="block">
 If true, search will continuously probe Boolean variables, and integer
 variable bounds.</div>
</td>
</tr>
<tr id="i536" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseRinsLns--">hasUseRinsLns</a></span>()</code>
<div class="block">
 Turns on relaxation induced neighborhood generator.</div>
</td>
</tr>
<tr id="i537" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseSatInprocessing--">hasUseSatInprocessing</a></span>()</code>
<div class="block">
 Enable or disable "inprocessing" which is some SAT presolving done at
 each restart to the root level.</div>
</td>
</tr>
<tr id="i538" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseSharedTreeSearch--">hasUseSharedTreeSearch</a></span>()</code>
<div class="block">
 Set on shared subtree workers.</div>
</td>
</tr>
<tr id="i539" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseShavingInProbingSearch--">hasUseShavingInProbingSearch</a></span>()</code>
<div class="block">
 Add a shaving phase (where the solver tries to prove that the lower or
 upper bound of a variable are infeasible) to the probing search.</div>
</td>
</tr>
<tr id="i540" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseStrongPropagationInDisjunctive--">hasUseStrongPropagationInDisjunctive</a></span>()</code>
<div class="block">
 Enable stronger and more expensive propagation on no_overlap constraint.</div>
</td>
</tr>
<tr id="i541" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseSymmetryInLp--">hasUseSymmetryInLp</a></span>()</code>
<div class="block">
 When we have symmetry, it is possible to "fold" all variables from the same
 orbit into a single variable, while having the same power of LP relaxation.</div>
</td>
</tr>
<tr id="i542" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseTimetableEdgeFindingInCumulative--">hasUseTimetableEdgeFindingInCumulative</a></span>()</code>
<div class="block">
 When this is true, the cumulative constraint is reinforced with timetable
 edge finding, i.e., an additional level of reasoning based on the
 conjunction of energy and mandatory parts.</div>
</td>
</tr>
<tr id="i543" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseTimetablingInNoOverlap2D--">hasUseTimetablingInNoOverlap2D</a></span>()</code>
<div class="block">
 When this is true, the no_overlap_2d constraint is reinforced with
 propagators from the cumulative constraints.</div>
</td>
</tr>
<tr id="i544" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseTryEdgeReasoningInNoOverlap2D--">hasUseTryEdgeReasoningInNoOverlap2D</a></span>()</code>
<div class="block"><code>optional bool use_try_edge_reasoning_in_no_overlap_2d = 299 [default = false];</code></div>
</td>
</tr>
<tr id="i545" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasUseVariablesShavingSearch--">hasUseVariablesShavingSearch</a></span>()</code>
<div class="block">
 This search takes all Boolean or integer variables, and maximize or
 minimize them in order to reduce their domain.</div>
</td>
</tr>
<tr id="i546" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasVariableActivityDecay--">hasVariableActivityDecay</a></span>()</code>
<div class="block">
 Each time a conflict is found, the activities of some variables are
 increased by one.</div>
</td>
</tr>
<tr id="i547" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasViolationLsCompoundMoveProbability--">hasViolationLsCompoundMoveProbability</a></span>()</code>
<div class="block">
 Probability of using compound move search each restart.</div>
</td>
</tr>
<tr id="i548" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html#hasViolationLsPerturbationPeriod--">hasViolationLsPerturbationPeriod</a></span>()</code>
<div class="block">
 How long violation_ls should wait before perturbating a solution.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.com.google.protobuf.MessageOrBuilder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageOrBuilder</h3>
<code>findInitializationErrors, getAllFields, getDefaultInstanceForType, getDescriptorForType, getField, getInitializationErrorString, getOneofFieldDescriptor, getRepeatedField, getRepeatedFieldCount, getUnknownFields, hasField, hasOneof</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.com.google.protobuf.MessageLiteOrBuilder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageLiteOrBuilder</h3>
<code>isInitialized</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="hasName--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasName</h4>
<pre>boolean&nbsp;hasName()</pre>
<div class="block"><pre>
 In some context, like in a portfolio of search, it makes sense to name a
 given parameters set for logging purpose.
 </pre>

 <code>optional string name = 171 [default = ""];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the name field is set.</dd>
</dl>
</li>
</ul>
<a name="getName--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getName</h4>
<pre>java.lang.String&nbsp;getName()</pre>
<div class="block"><pre>
 In some context, like in a portfolio of search, it makes sense to name a
 given parameters set for logging purpose.
 </pre>

 <code>optional string name = 171 [default = ""];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The name.</dd>
</dl>
</li>
</ul>
<a name="getNameBytes--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNameBytes</h4>
<pre>com.google.protobuf.ByteString&nbsp;getNameBytes()</pre>
<div class="block"><pre>
 In some context, like in a portfolio of search, it makes sense to name a
 given parameters set for logging purpose.
 </pre>

 <code>optional string name = 171 [default = ""];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bytes for name.</dd>
</dl>
</li>
</ul>
<a name="hasPreferredVariableOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPreferredVariableOrder</h4>
<pre>boolean&nbsp;hasPreferredVariableOrder()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.VariableOrder preferred_variable_order = 1 [default = IN_ORDER];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the preferredVariableOrder field is set.</dd>
</dl>
</li>
</ul>
<a name="getPreferredVariableOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPreferredVariableOrder</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.VariableOrder.html" title="enum in com.google.ortools.sat">SatParameters.VariableOrder</a>&nbsp;getPreferredVariableOrder()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.VariableOrder preferred_variable_order = 1 [default = IN_ORDER];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The preferredVariableOrder.</dd>
</dl>
</li>
</ul>
<a name="hasInitialPolarity--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialPolarity</h4>
<pre>boolean&nbsp;hasInitialPolarity()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.Polarity initial_polarity = 2 [default = POLARITY_FALSE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialPolarity field is set.</dd>
</dl>
</li>
</ul>
<a name="getInitialPolarity--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialPolarity</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.Polarity.html" title="enum in com.google.ortools.sat">SatParameters.Polarity</a>&nbsp;getInitialPolarity()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.Polarity initial_polarity = 2 [default = POLARITY_FALSE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialPolarity.</dd>
</dl>
</li>
</ul>
<a name="hasUsePhaseSaving--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUsePhaseSaving</h4>
<pre>boolean&nbsp;hasUsePhaseSaving()</pre>
<div class="block"><pre>
 If this is true, then the polarity of a variable will be the last value it
 was assigned to, or its default polarity if it was never assigned since the
 call to ResetDecisionHeuristic().

 Actually, we use a newer version where we follow the last value in the
 longest non-conflicting partial assignment in the current phase.

 This is called 'literal phase saving'. For details see 'A Lightweight
 Component Caching Scheme for Satisfiability Solvers' K. Pipatsrisawat and
 A.Darwiche, In 10th International Conference on Theory and Applications of
 Satisfiability Testing, 2007.
 </pre>

 <code>optional bool use_phase_saving = 44 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the usePhaseSaving field is set.</dd>
</dl>
</li>
</ul>
<a name="getUsePhaseSaving--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUsePhaseSaving</h4>
<pre>boolean&nbsp;getUsePhaseSaving()</pre>
<div class="block"><pre>
 If this is true, then the polarity of a variable will be the last value it
 was assigned to, or its default polarity if it was never assigned since the
 call to ResetDecisionHeuristic().

 Actually, we use a newer version where we follow the last value in the
 longest non-conflicting partial assignment in the current phase.

 This is called 'literal phase saving'. For details see 'A Lightweight
 Component Caching Scheme for Satisfiability Solvers' K. Pipatsrisawat and
 A.Darwiche, In 10th International Conference on Theory and Applications of
 Satisfiability Testing, 2007.
 </pre>

 <code>optional bool use_phase_saving = 44 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The usePhaseSaving.</dd>
</dl>
</li>
</ul>
<a name="hasPolarityRephaseIncrement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPolarityRephaseIncrement</h4>
<pre>boolean&nbsp;hasPolarityRephaseIncrement()</pre>
<div class="block"><pre>
 If non-zero, then we change the polarity heuristic after that many number
 of conflicts in an arithmetically increasing fashion. So x the first time,
 2 * x the second time, etc...
 </pre>

 <code>optional int32 polarity_rephase_increment = 168 [default = 1000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the polarityRephaseIncrement field is set.</dd>
</dl>
</li>
</ul>
<a name="getPolarityRephaseIncrement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPolarityRephaseIncrement</h4>
<pre>int&nbsp;getPolarityRephaseIncrement()</pre>
<div class="block"><pre>
 If non-zero, then we change the polarity heuristic after that many number
 of conflicts in an arithmetically increasing fashion. So x the first time,
 2 * x the second time, etc...
 </pre>

 <code>optional int32 polarity_rephase_increment = 168 [default = 1000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The polarityRephaseIncrement.</dd>
</dl>
</li>
</ul>
<a name="hasPolarityExploitLsHints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPolarityExploitLsHints</h4>
<pre>boolean&nbsp;hasPolarityExploitLsHints()</pre>
<div class="block"><pre>
 If true and we have first solution LS workers, tries in some phase to
 follow a LS solutions that violates has litle constraints as possible.
 </pre>

 <code>optional bool polarity_exploit_ls_hints = 309 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the polarityExploitLsHints field is set.</dd>
</dl>
</li>
</ul>
<a name="getPolarityExploitLsHints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPolarityExploitLsHints</h4>
<pre>boolean&nbsp;getPolarityExploitLsHints()</pre>
<div class="block"><pre>
 If true and we have first solution LS workers, tries in some phase to
 follow a LS solutions that violates has litle constraints as possible.
 </pre>

 <code>optional bool polarity_exploit_ls_hints = 309 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The polarityExploitLsHints.</dd>
</dl>
</li>
</ul>
<a name="hasRandomPolarityRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRandomPolarityRatio</h4>
<pre>boolean&nbsp;hasRandomPolarityRatio()</pre>
<div class="block"><pre>
 The proportion of polarity chosen at random. Note that this take
 precedence over the phase saving heuristic. This is different from
 initial_polarity:POLARITY_RANDOM because it will select a new random
 polarity each time the variable is branched upon instead of selecting one
 initially and then always taking this choice.
 </pre>

 <code>optional double random_polarity_ratio = 45 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the randomPolarityRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getRandomPolarityRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomPolarityRatio</h4>
<pre>double&nbsp;getRandomPolarityRatio()</pre>
<div class="block"><pre>
 The proportion of polarity chosen at random. Note that this take
 precedence over the phase saving heuristic. This is different from
 initial_polarity:POLARITY_RANDOM because it will select a new random
 polarity each time the variable is branched upon instead of selecting one
 initially and then always taking this choice.
 </pre>

 <code>optional double random_polarity_ratio = 45 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The randomPolarityRatio.</dd>
</dl>
</li>
</ul>
<a name="hasRandomBranchesRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRandomBranchesRatio</h4>
<pre>boolean&nbsp;hasRandomBranchesRatio()</pre>
<div class="block"><pre>
 A number between 0 and 1 that indicates the proportion of branching
 variables that are selected randomly instead of choosing the first variable
 from the given variable_ordering strategy.
 </pre>

 <code>optional double random_branches_ratio = 32 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the randomBranchesRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getRandomBranchesRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomBranchesRatio</h4>
<pre>double&nbsp;getRandomBranchesRatio()</pre>
<div class="block"><pre>
 A number between 0 and 1 that indicates the proportion of branching
 variables that are selected randomly instead of choosing the first variable
 from the given variable_ordering strategy.
 </pre>

 <code>optional double random_branches_ratio = 32 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The randomBranchesRatio.</dd>
</dl>
</li>
</ul>
<a name="hasUseErwaHeuristic--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseErwaHeuristic</h4>
<pre>boolean&nbsp;hasUseErwaHeuristic()</pre>
<div class="block"><pre>
 Whether we use the ERWA (Exponential Recency Weighted Average) heuristic as
 described in "Learning Rate Based Branching Heuristic for SAT solvers",
 J.H.Liang, V. Ganesh, P. Poupart, K.Czarnecki, SAT 2016.
 </pre>

 <code>optional bool use_erwa_heuristic = 75 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useErwaHeuristic field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseErwaHeuristic--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseErwaHeuristic</h4>
<pre>boolean&nbsp;getUseErwaHeuristic()</pre>
<div class="block"><pre>
 Whether we use the ERWA (Exponential Recency Weighted Average) heuristic as
 described in "Learning Rate Based Branching Heuristic for SAT solvers",
 J.H.Liang, V. Ganesh, P. Poupart, K.Czarnecki, SAT 2016.
 </pre>

 <code>optional bool use_erwa_heuristic = 75 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useErwaHeuristic.</dd>
</dl>
</li>
</ul>
<a name="hasInitialVariablesActivity--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialVariablesActivity</h4>
<pre>boolean&nbsp;hasInitialVariablesActivity()</pre>
<div class="block"><pre>
 The initial value of the variables activity. A non-zero value only make
 sense when use_erwa_heuristic is true. Experiments with a value of 1e-2
 together with the ERWA heuristic showed slighthly better result than simply
 using zero. The idea is that when the "learning rate" of a variable becomes
 lower than this value, then we prefer to branch on never explored before
 variables. This is not in the ERWA paper.
 </pre>

 <code>optional double initial_variables_activity = 76 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialVariablesActivity field is set.</dd>
</dl>
</li>
</ul>
<a name="getInitialVariablesActivity--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialVariablesActivity</h4>
<pre>double&nbsp;getInitialVariablesActivity()</pre>
<div class="block"><pre>
 The initial value of the variables activity. A non-zero value only make
 sense when use_erwa_heuristic is true. Experiments with a value of 1e-2
 together with the ERWA heuristic showed slighthly better result than simply
 using zero. The idea is that when the "learning rate" of a variable becomes
 lower than this value, then we prefer to branch on never explored before
 variables. This is not in the ERWA paper.
 </pre>

 <code>optional double initial_variables_activity = 76 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialVariablesActivity.</dd>
</dl>
</li>
</ul>
<a name="hasAlsoBumpVariablesInConflictReasons--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAlsoBumpVariablesInConflictReasons</h4>
<pre>boolean&nbsp;hasAlsoBumpVariablesInConflictReasons()</pre>
<div class="block"><pre>
 When this is true, then the variables that appear in any of the reason of
 the variables in a conflict have their activity bumped. This is addition to
 the variables in the conflict, and the one that were used during conflict
 resolution.
 </pre>

 <code>optional bool also_bump_variables_in_conflict_reasons = 77 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the alsoBumpVariablesInConflictReasons field is set.</dd>
</dl>
</li>
</ul>
<a name="getAlsoBumpVariablesInConflictReasons--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAlsoBumpVariablesInConflictReasons</h4>
<pre>boolean&nbsp;getAlsoBumpVariablesInConflictReasons()</pre>
<div class="block"><pre>
 When this is true, then the variables that appear in any of the reason of
 the variables in a conflict have their activity bumped. This is addition to
 the variables in the conflict, and the one that were used during conflict
 resolution.
 </pre>

 <code>optional bool also_bump_variables_in_conflict_reasons = 77 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The alsoBumpVariablesInConflictReasons.</dd>
</dl>
</li>
</ul>
<a name="hasMinimizationAlgorithm--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMinimizationAlgorithm</h4>
<pre>boolean&nbsp;hasMinimizationAlgorithm()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.ConflictMinimizationAlgorithm minimization_algorithm = 4 [default = RECURSIVE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the minimizationAlgorithm field is set.</dd>
</dl>
</li>
</ul>
<a name="getMinimizationAlgorithm--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinimizationAlgorithm</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.ConflictMinimizationAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.ConflictMinimizationAlgorithm</a>&nbsp;getMinimizationAlgorithm()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.ConflictMinimizationAlgorithm minimization_algorithm = 4 [default = RECURSIVE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The minimizationAlgorithm.</dd>
</dl>
</li>
</ul>
<a name="hasBinaryMinimizationAlgorithm--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasBinaryMinimizationAlgorithm</h4>
<pre>boolean&nbsp;hasBinaryMinimizationAlgorithm()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.BinaryMinizationAlgorithm binary_minimization_algorithm = 34 [default = BINARY_MINIMIZATION_FIRST];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the binaryMinimizationAlgorithm field is set.</dd>
</dl>
</li>
</ul>
<a name="getBinaryMinimizationAlgorithm--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBinaryMinimizationAlgorithm</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.BinaryMinizationAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.BinaryMinizationAlgorithm</a>&nbsp;getBinaryMinimizationAlgorithm()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.BinaryMinizationAlgorithm binary_minimization_algorithm = 34 [default = BINARY_MINIMIZATION_FIRST];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The binaryMinimizationAlgorithm.</dd>
</dl>
</li>
</ul>
<a name="hasSubsumptionDuringConflictAnalysis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSubsumptionDuringConflictAnalysis</h4>
<pre>boolean&nbsp;hasSubsumptionDuringConflictAnalysis()</pre>
<div class="block"><pre>
 At a really low cost, during the 1-UIP conflict computation, it is easy to
 detect if some of the involved reasons are subsumed by the current
 conflict. When this is true, such clauses are detached and later removed
 from the problem.
 </pre>

 <code>optional bool subsumption_during_conflict_analysis = 56 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the subsumptionDuringConflictAnalysis field is set.</dd>
</dl>
</li>
</ul>
<a name="getSubsumptionDuringConflictAnalysis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsumptionDuringConflictAnalysis</h4>
<pre>boolean&nbsp;getSubsumptionDuringConflictAnalysis()</pre>
<div class="block"><pre>
 At a really low cost, during the 1-UIP conflict computation, it is easy to
 detect if some of the involved reasons are subsumed by the current
 conflict. When this is true, such clauses are detached and later removed
 from the problem.
 </pre>

 <code>optional bool subsumption_during_conflict_analysis = 56 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The subsumptionDuringConflictAnalysis.</dd>
</dl>
</li>
</ul>
<a name="hasClauseCleanupPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasClauseCleanupPeriod</h4>
<pre>boolean&nbsp;hasClauseCleanupPeriod()</pre>
<div class="block"><pre>
 Trigger a cleanup when this number of "deletable" clauses is learned.
 </pre>

 <code>optional int32 clause_cleanup_period = 11 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the clauseCleanupPeriod field is set.</dd>
</dl>
</li>
</ul>
<a name="getClauseCleanupPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClauseCleanupPeriod</h4>
<pre>int&nbsp;getClauseCleanupPeriod()</pre>
<div class="block"><pre>
 Trigger a cleanup when this number of "deletable" clauses is learned.
 </pre>

 <code>optional int32 clause_cleanup_period = 11 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clauseCleanupPeriod.</dd>
</dl>
</li>
</ul>
<a name="hasClauseCleanupTarget--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasClauseCleanupTarget</h4>
<pre>boolean&nbsp;hasClauseCleanupTarget()</pre>
<div class="block"><pre>
 During a cleanup, we will always keep that number of "deletable" clauses.
 Note that this doesn't include the "protected" clauses.
 </pre>

 <code>optional int32 clause_cleanup_target = 13 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the clauseCleanupTarget field is set.</dd>
</dl>
</li>
</ul>
<a name="getClauseCleanupTarget--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClauseCleanupTarget</h4>
<pre>int&nbsp;getClauseCleanupTarget()</pre>
<div class="block"><pre>
 During a cleanup, we will always keep that number of "deletable" clauses.
 Note that this doesn't include the "protected" clauses.
 </pre>

 <code>optional int32 clause_cleanup_target = 13 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clauseCleanupTarget.</dd>
</dl>
</li>
</ul>
<a name="hasClauseCleanupRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasClauseCleanupRatio</h4>
<pre>boolean&nbsp;hasClauseCleanupRatio()</pre>
<div class="block"><pre>
 During a cleanup, if clause_cleanup_target is 0, we will delete the
 clause_cleanup_ratio of "deletable" clauses instead of aiming for a fixed
 target of clauses to keep.
 </pre>

 <code>optional double clause_cleanup_ratio = 190 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the clauseCleanupRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getClauseCleanupRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClauseCleanupRatio</h4>
<pre>double&nbsp;getClauseCleanupRatio()</pre>
<div class="block"><pre>
 During a cleanup, if clause_cleanup_target is 0, we will delete the
 clause_cleanup_ratio of "deletable" clauses instead of aiming for a fixed
 target of clauses to keep.
 </pre>

 <code>optional double clause_cleanup_ratio = 190 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clauseCleanupRatio.</dd>
</dl>
</li>
</ul>
<a name="hasClauseCleanupProtection--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasClauseCleanupProtection</h4>
<pre>boolean&nbsp;hasClauseCleanupProtection()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseProtection clause_cleanup_protection = 58 [default = PROTECTION_NONE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the clauseCleanupProtection field is set.</dd>
</dl>
</li>
</ul>
<a name="getClauseCleanupProtection--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClauseCleanupProtection</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.ClauseProtection.html" title="enum in com.google.ortools.sat">SatParameters.ClauseProtection</a>&nbsp;getClauseCleanupProtection()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseProtection clause_cleanup_protection = 58 [default = PROTECTION_NONE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clauseCleanupProtection.</dd>
</dl>
</li>
</ul>
<a name="hasClauseCleanupLbdBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasClauseCleanupLbdBound</h4>
<pre>boolean&nbsp;hasClauseCleanupLbdBound()</pre>
<div class="block"><pre>
 All the clauses with a LBD (literal blocks distance) lower or equal to this
 parameters will always be kept.
 </pre>

 <code>optional int32 clause_cleanup_lbd_bound = 59 [default = 5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the clauseCleanupLbdBound field is set.</dd>
</dl>
</li>
</ul>
<a name="getClauseCleanupLbdBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClauseCleanupLbdBound</h4>
<pre>int&nbsp;getClauseCleanupLbdBound()</pre>
<div class="block"><pre>
 All the clauses with a LBD (literal blocks distance) lower or equal to this
 parameters will always be kept.
 </pre>

 <code>optional int32 clause_cleanup_lbd_bound = 59 [default = 5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clauseCleanupLbdBound.</dd>
</dl>
</li>
</ul>
<a name="hasClauseCleanupOrdering--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasClauseCleanupOrdering</h4>
<pre>boolean&nbsp;hasClauseCleanupOrdering()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseOrdering clause_cleanup_ordering = 60 [default = CLAUSE_ACTIVITY];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the clauseCleanupOrdering field is set.</dd>
</dl>
</li>
</ul>
<a name="getClauseCleanupOrdering--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClauseCleanupOrdering</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.ClauseOrdering.html" title="enum in com.google.ortools.sat">SatParameters.ClauseOrdering</a>&nbsp;getClauseCleanupOrdering()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.ClauseOrdering clause_cleanup_ordering = 60 [default = CLAUSE_ACTIVITY];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clauseCleanupOrdering.</dd>
</dl>
</li>
</ul>
<a name="hasPbCleanupIncrement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPbCleanupIncrement</h4>
<pre>boolean&nbsp;hasPbCleanupIncrement()</pre>
<div class="block"><pre>
 Same as for the clauses, but for the learned pseudo-Boolean constraints.
 </pre>

 <code>optional int32 pb_cleanup_increment = 46 [default = 200];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the pbCleanupIncrement field is set.</dd>
</dl>
</li>
</ul>
<a name="getPbCleanupIncrement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPbCleanupIncrement</h4>
<pre>int&nbsp;getPbCleanupIncrement()</pre>
<div class="block"><pre>
 Same as for the clauses, but for the learned pseudo-Boolean constraints.
 </pre>

 <code>optional int32 pb_cleanup_increment = 46 [default = 200];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The pbCleanupIncrement.</dd>
</dl>
</li>
</ul>
<a name="hasPbCleanupRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPbCleanupRatio</h4>
<pre>boolean&nbsp;hasPbCleanupRatio()</pre>
<div class="block"><code>optional double pb_cleanup_ratio = 47 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the pbCleanupRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getPbCleanupRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPbCleanupRatio</h4>
<pre>double&nbsp;getPbCleanupRatio()</pre>
<div class="block"><code>optional double pb_cleanup_ratio = 47 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The pbCleanupRatio.</dd>
</dl>
</li>
</ul>
<a name="hasVariableActivityDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasVariableActivityDecay</h4>
<pre>boolean&nbsp;hasVariableActivityDecay()</pre>
<div class="block"><pre>
 Each time a conflict is found, the activities of some variables are
 increased by one. Then, the activity of all variables are multiplied by
 variable_activity_decay.

 To implement this efficiently, the activity of all the variables is not
 decayed at each conflict. Instead, the activity increment is multiplied by
 1 / decay. When an activity reach max_variable_activity_value, all the
 activity are multiplied by 1 / max_variable_activity_value.
 </pre>

 <code>optional double variable_activity_decay = 15 [default = 0.8];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the variableActivityDecay field is set.</dd>
</dl>
</li>
</ul>
<a name="getVariableActivityDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVariableActivityDecay</h4>
<pre>double&nbsp;getVariableActivityDecay()</pre>
<div class="block"><pre>
 Each time a conflict is found, the activities of some variables are
 increased by one. Then, the activity of all variables are multiplied by
 variable_activity_decay.

 To implement this efficiently, the activity of all the variables is not
 decayed at each conflict. Instead, the activity increment is multiplied by
 1 / decay. When an activity reach max_variable_activity_value, all the
 activity are multiplied by 1 / max_variable_activity_value.
 </pre>

 <code>optional double variable_activity_decay = 15 [default = 0.8];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The variableActivityDecay.</dd>
</dl>
</li>
</ul>
<a name="hasMaxVariableActivityValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxVariableActivityValue</h4>
<pre>boolean&nbsp;hasMaxVariableActivityValue()</pre>
<div class="block"><code>optional double max_variable_activity_value = 16 [default = 1e+100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxVariableActivityValue field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxVariableActivityValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxVariableActivityValue</h4>
<pre>double&nbsp;getMaxVariableActivityValue()</pre>
<div class="block"><code>optional double max_variable_activity_value = 16 [default = 1e+100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxVariableActivityValue.</dd>
</dl>
</li>
</ul>
<a name="hasGlucoseMaxDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasGlucoseMaxDecay</h4>
<pre>boolean&nbsp;hasGlucoseMaxDecay()</pre>
<div class="block"><pre>
 The activity starts at 0.8 and increment by 0.01 every 5000 conflicts until
 0.95. This "hack" seems to work well and comes from:

 Glucose 2.3 in the SAT 2013 Competition - SAT Competition 2013
 http://edacc4.informatik.uni-ulm.de/SC13/solver-description-download/136
 </pre>

 <code>optional double glucose_max_decay = 22 [default = 0.95];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the glucoseMaxDecay field is set.</dd>
</dl>
</li>
</ul>
<a name="getGlucoseMaxDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGlucoseMaxDecay</h4>
<pre>double&nbsp;getGlucoseMaxDecay()</pre>
<div class="block"><pre>
 The activity starts at 0.8 and increment by 0.01 every 5000 conflicts until
 0.95. This "hack" seems to work well and comes from:

 Glucose 2.3 in the SAT 2013 Competition - SAT Competition 2013
 http://edacc4.informatik.uni-ulm.de/SC13/solver-description-download/136
 </pre>

 <code>optional double glucose_max_decay = 22 [default = 0.95];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The glucoseMaxDecay.</dd>
</dl>
</li>
</ul>
<a name="hasGlucoseDecayIncrement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasGlucoseDecayIncrement</h4>
<pre>boolean&nbsp;hasGlucoseDecayIncrement()</pre>
<div class="block"><code>optional double glucose_decay_increment = 23 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the glucoseDecayIncrement field is set.</dd>
</dl>
</li>
</ul>
<a name="getGlucoseDecayIncrement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGlucoseDecayIncrement</h4>
<pre>double&nbsp;getGlucoseDecayIncrement()</pre>
<div class="block"><code>optional double glucose_decay_increment = 23 [default = 0.01];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The glucoseDecayIncrement.</dd>
</dl>
</li>
</ul>
<a name="hasGlucoseDecayIncrementPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasGlucoseDecayIncrementPeriod</h4>
<pre>boolean&nbsp;hasGlucoseDecayIncrementPeriod()</pre>
<div class="block"><code>optional int32 glucose_decay_increment_period = 24 [default = 5000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the glucoseDecayIncrementPeriod field is set.</dd>
</dl>
</li>
</ul>
<a name="getGlucoseDecayIncrementPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGlucoseDecayIncrementPeriod</h4>
<pre>int&nbsp;getGlucoseDecayIncrementPeriod()</pre>
<div class="block"><code>optional int32 glucose_decay_increment_period = 24 [default = 5000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The glucoseDecayIncrementPeriod.</dd>
</dl>
</li>
</ul>
<a name="hasClauseActivityDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasClauseActivityDecay</h4>
<pre>boolean&nbsp;hasClauseActivityDecay()</pre>
<div class="block"><pre>
 Clause activity parameters (same effect as the one on the variables).
 </pre>

 <code>optional double clause_activity_decay = 17 [default = 0.999];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the clauseActivityDecay field is set.</dd>
</dl>
</li>
</ul>
<a name="getClauseActivityDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getClauseActivityDecay</h4>
<pre>double&nbsp;getClauseActivityDecay()</pre>
<div class="block"><pre>
 Clause activity parameters (same effect as the one on the variables).
 </pre>

 <code>optional double clause_activity_decay = 17 [default = 0.999];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The clauseActivityDecay.</dd>
</dl>
</li>
</ul>
<a name="hasMaxClauseActivityValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxClauseActivityValue</h4>
<pre>boolean&nbsp;hasMaxClauseActivityValue()</pre>
<div class="block"><code>optional double max_clause_activity_value = 18 [default = 1e+20];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxClauseActivityValue field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxClauseActivityValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxClauseActivityValue</h4>
<pre>double&nbsp;getMaxClauseActivityValue()</pre>
<div class="block"><code>optional double max_clause_activity_value = 18 [default = 1e+20];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxClauseActivityValue.</dd>
</dl>
</li>
</ul>
<a name="getRestartAlgorithmsList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartAlgorithmsList</h4>
<pre>java.util.List&lt;<a href="../../../../com/google/ortools/sat/SatParameters.RestartAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.RestartAlgorithm</a>&gt;&nbsp;getRestartAlgorithmsList()</pre>
<div class="block"><pre>
 The restart strategies will change each time the strategy_counter is
 increased. The current strategy will simply be the one at index
 strategy_counter modulo the number of strategy. Note that if this list
 includes a NO_RESTART, nothing will change when it is reached because the
 strategy_counter will only increment after a restart.

 The idea of switching of search strategy tailored for SAT/UNSAT comes from
 Chanseok Oh with his COMiniSatPS solver, see http://cs.nyu.edu/~chanseok/.
 But more generally, it seems REALLY beneficial to try different strategy.
 </pre>

 <code>repeated .operations_research.sat.SatParameters.RestartAlgorithm restart_algorithms = 61;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list containing the restartAlgorithms.</dd>
</dl>
</li>
</ul>
<a name="getRestartAlgorithmsCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartAlgorithmsCount</h4>
<pre>int&nbsp;getRestartAlgorithmsCount()</pre>
<div class="block"><pre>
 The restart strategies will change each time the strategy_counter is
 increased. The current strategy will simply be the one at index
 strategy_counter modulo the number of strategy. Note that if this list
 includes a NO_RESTART, nothing will change when it is reached because the
 strategy_counter will only increment after a restart.

 The idea of switching of search strategy tailored for SAT/UNSAT comes from
 Chanseok Oh with his COMiniSatPS solver, see http://cs.nyu.edu/~chanseok/.
 But more generally, it seems REALLY beneficial to try different strategy.
 </pre>

 <code>repeated .operations_research.sat.SatParameters.RestartAlgorithm restart_algorithms = 61;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The count of restartAlgorithms.</dd>
</dl>
</li>
</ul>
<a name="getRestartAlgorithms-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartAlgorithms</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.RestartAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.RestartAlgorithm</a>&nbsp;getRestartAlgorithms(int&nbsp;index)</pre>
<div class="block"><pre>
 The restart strategies will change each time the strategy_counter is
 increased. The current strategy will simply be the one at index
 strategy_counter modulo the number of strategy. Note that if this list
 includes a NO_RESTART, nothing will change when it is reached because the
 strategy_counter will only increment after a restart.

 The idea of switching of search strategy tailored for SAT/UNSAT comes from
 Chanseok Oh with his COMiniSatPS solver, see http://cs.nyu.edu/~chanseok/.
 But more generally, it seems REALLY beneficial to try different strategy.
 </pre>

 <code>repeated .operations_research.sat.SatParameters.RestartAlgorithm restart_algorithms = 61;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the element to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The restartAlgorithms at the given index.</dd>
</dl>
</li>
</ul>
<a name="hasDefaultRestartAlgorithms--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDefaultRestartAlgorithms</h4>
<pre>boolean&nbsp;hasDefaultRestartAlgorithms()</pre>
<div class="block"><code>optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the defaultRestartAlgorithms field is set.</dd>
</dl>
</li>
</ul>
<a name="getDefaultRestartAlgorithms--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultRestartAlgorithms</h4>
<pre>java.lang.String&nbsp;getDefaultRestartAlgorithms()</pre>
<div class="block"><code>optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The defaultRestartAlgorithms.</dd>
</dl>
</li>
</ul>
<a name="getDefaultRestartAlgorithmsBytes--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultRestartAlgorithmsBytes</h4>
<pre>com.google.protobuf.ByteString&nbsp;getDefaultRestartAlgorithmsBytes()</pre>
<div class="block"><code>optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bytes for defaultRestartAlgorithms.</dd>
</dl>
</li>
</ul>
<a name="hasRestartPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRestartPeriod</h4>
<pre>boolean&nbsp;hasRestartPeriod()</pre>
<div class="block"><pre>
 Restart period for the FIXED_RESTART strategy. This is also the multiplier
 used by the LUBY_RESTART strategy.
 </pre>

 <code>optional int32 restart_period = 30 [default = 50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the restartPeriod field is set.</dd>
</dl>
</li>
</ul>
<a name="getRestartPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartPeriod</h4>
<pre>int&nbsp;getRestartPeriod()</pre>
<div class="block"><pre>
 Restart period for the FIXED_RESTART strategy. This is also the multiplier
 used by the LUBY_RESTART strategy.
 </pre>

 <code>optional int32 restart_period = 30 [default = 50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The restartPeriod.</dd>
</dl>
</li>
</ul>
<a name="hasRestartRunningWindowSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRestartRunningWindowSize</h4>
<pre>boolean&nbsp;hasRestartRunningWindowSize()</pre>
<div class="block"><pre>
 Size of the window for the moving average restarts.
 </pre>

 <code>optional int32 restart_running_window_size = 62 [default = 50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the restartRunningWindowSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getRestartRunningWindowSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartRunningWindowSize</h4>
<pre>int&nbsp;getRestartRunningWindowSize()</pre>
<div class="block"><pre>
 Size of the window for the moving average restarts.
 </pre>

 <code>optional int32 restart_running_window_size = 62 [default = 50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The restartRunningWindowSize.</dd>
</dl>
</li>
</ul>
<a name="hasRestartDlAverageRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRestartDlAverageRatio</h4>
<pre>boolean&nbsp;hasRestartDlAverageRatio()</pre>
<div class="block"><pre>
 In the moving average restart algorithms, a restart is triggered if the
 window average times this ratio is greater that the global average.
 </pre>

 <code>optional double restart_dl_average_ratio = 63 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the restartDlAverageRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getRestartDlAverageRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartDlAverageRatio</h4>
<pre>double&nbsp;getRestartDlAverageRatio()</pre>
<div class="block"><pre>
 In the moving average restart algorithms, a restart is triggered if the
 window average times this ratio is greater that the global average.
 </pre>

 <code>optional double restart_dl_average_ratio = 63 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The restartDlAverageRatio.</dd>
</dl>
</li>
</ul>
<a name="hasRestartLbdAverageRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRestartLbdAverageRatio</h4>
<pre>boolean&nbsp;hasRestartLbdAverageRatio()</pre>
<div class="block"><code>optional double restart_lbd_average_ratio = 71 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the restartLbdAverageRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getRestartLbdAverageRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartLbdAverageRatio</h4>
<pre>double&nbsp;getRestartLbdAverageRatio()</pre>
<div class="block"><code>optional double restart_lbd_average_ratio = 71 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The restartLbdAverageRatio.</dd>
</dl>
</li>
</ul>
<a name="hasUseBlockingRestart--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseBlockingRestart</h4>
<pre>boolean&nbsp;hasUseBlockingRestart()</pre>
<div class="block"><pre>
 Block a moving restart algorithm if the trail size of the current conflict
 is greater than the multiplier times the moving average of the trail size
 at the previous conflicts.
 </pre>

 <code>optional bool use_blocking_restart = 64 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useBlockingRestart field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseBlockingRestart--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseBlockingRestart</h4>
<pre>boolean&nbsp;getUseBlockingRestart()</pre>
<div class="block"><pre>
 Block a moving restart algorithm if the trail size of the current conflict
 is greater than the multiplier times the moving average of the trail size
 at the previous conflicts.
 </pre>

 <code>optional bool use_blocking_restart = 64 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useBlockingRestart.</dd>
</dl>
</li>
</ul>
<a name="hasBlockingRestartWindowSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasBlockingRestartWindowSize</h4>
<pre>boolean&nbsp;hasBlockingRestartWindowSize()</pre>
<div class="block"><code>optional int32 blocking_restart_window_size = 65 [default = 5000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the blockingRestartWindowSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getBlockingRestartWindowSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlockingRestartWindowSize</h4>
<pre>int&nbsp;getBlockingRestartWindowSize()</pre>
<div class="block"><code>optional int32 blocking_restart_window_size = 65 [default = 5000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The blockingRestartWindowSize.</dd>
</dl>
</li>
</ul>
<a name="hasBlockingRestartMultiplier--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasBlockingRestartMultiplier</h4>
<pre>boolean&nbsp;hasBlockingRestartMultiplier()</pre>
<div class="block"><code>optional double blocking_restart_multiplier = 66 [default = 1.4];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the blockingRestartMultiplier field is set.</dd>
</dl>
</li>
</ul>
<a name="getBlockingRestartMultiplier--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlockingRestartMultiplier</h4>
<pre>double&nbsp;getBlockingRestartMultiplier()</pre>
<div class="block"><code>optional double blocking_restart_multiplier = 66 [default = 1.4];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The blockingRestartMultiplier.</dd>
</dl>
</li>
</ul>
<a name="hasNumConflictsBeforeStrategyChanges--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumConflictsBeforeStrategyChanges</h4>
<pre>boolean&nbsp;hasNumConflictsBeforeStrategyChanges()</pre>
<div class="block"><pre>
 After each restart, if the number of conflict since the last strategy
 change is greater that this, then we increment a "strategy_counter" that
 can be use to change the search strategy used by the following restarts.
 </pre>

 <code>optional int32 num_conflicts_before_strategy_changes = 68 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numConflictsBeforeStrategyChanges field is set.</dd>
</dl>
</li>
</ul>
<a name="getNumConflictsBeforeStrategyChanges--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumConflictsBeforeStrategyChanges</h4>
<pre>int&nbsp;getNumConflictsBeforeStrategyChanges()</pre>
<div class="block"><pre>
 After each restart, if the number of conflict since the last strategy
 change is greater that this, then we increment a "strategy_counter" that
 can be use to change the search strategy used by the following restarts.
 </pre>

 <code>optional int32 num_conflicts_before_strategy_changes = 68 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numConflictsBeforeStrategyChanges.</dd>
</dl>
</li>
</ul>
<a name="hasStrategyChangeIncreaseRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasStrategyChangeIncreaseRatio</h4>
<pre>boolean&nbsp;hasStrategyChangeIncreaseRatio()</pre>
<div class="block"><pre>
 The parameter num_conflicts_before_strategy_changes is increased by that
 much after each strategy change.
 </pre>

 <code>optional double strategy_change_increase_ratio = 69 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the strategyChangeIncreaseRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getStrategyChangeIncreaseRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStrategyChangeIncreaseRatio</h4>
<pre>double&nbsp;getStrategyChangeIncreaseRatio()</pre>
<div class="block"><pre>
 The parameter num_conflicts_before_strategy_changes is increased by that
 much after each strategy change.
 </pre>

 <code>optional double strategy_change_increase_ratio = 69 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The strategyChangeIncreaseRatio.</dd>
</dl>
</li>
</ul>
<a name="hasMaxTimeInSeconds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxTimeInSeconds</h4>
<pre>boolean&nbsp;hasMaxTimeInSeconds()</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 The counter will starts at the beginning of the Solve() call.
 </pre>

 <code>optional double max_time_in_seconds = 36 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxTimeInSeconds field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxTimeInSeconds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxTimeInSeconds</h4>
<pre>double&nbsp;getMaxTimeInSeconds()</pre>
<div class="block"><pre>
 Maximum time allowed in seconds to solve a problem.
 The counter will starts at the beginning of the Solve() call.
 </pre>

 <code>optional double max_time_in_seconds = 36 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxTimeInSeconds.</dd>
</dl>
</li>
</ul>
<a name="hasMaxDeterministicTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxDeterministicTime</h4>
<pre>boolean&nbsp;hasMaxDeterministicTime()</pre>
<div class="block"><pre>
 Maximum time allowed in deterministic time to solve a problem.
 The deterministic time should be correlated with the real time used by the
 solver, the time unit being as close as possible to a second.
 </pre>

 <code>optional double max_deterministic_time = 67 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxDeterministicTime field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxDeterministicTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxDeterministicTime</h4>
<pre>double&nbsp;getMaxDeterministicTime()</pre>
<div class="block"><pre>
 Maximum time allowed in deterministic time to solve a problem.
 The deterministic time should be correlated with the real time used by the
 solver, the time unit being as close as possible to a second.
 </pre>

 <code>optional double max_deterministic_time = 67 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxDeterministicTime.</dd>
</dl>
</li>
</ul>
<a name="hasMaxNumDeterministicBatches--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumDeterministicBatches</h4>
<pre>boolean&nbsp;hasMaxNumDeterministicBatches()</pre>
<div class="block"><pre>
 Stops after that number of batches has been scheduled. This only make sense
 when interleave_search is true.
 </pre>

 <code>optional int32 max_num_deterministic_batches = 291 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumDeterministicBatches field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxNumDeterministicBatches--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumDeterministicBatches</h4>
<pre>int&nbsp;getMaxNumDeterministicBatches()</pre>
<div class="block"><pre>
 Stops after that number of batches has been scheduled. This only make sense
 when interleave_search is true.
 </pre>

 <code>optional int32 max_num_deterministic_batches = 291 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumDeterministicBatches.</dd>
</dl>
</li>
</ul>
<a name="hasMaxNumberOfConflicts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumberOfConflicts</h4>
<pre>boolean&nbsp;hasMaxNumberOfConflicts()</pre>
<div class="block"><pre>
 Maximum number of conflicts allowed to solve a problem.

 TODO(user): Maybe change the way the conflict limit is enforced?
 currently it is enforced on each independent internal SAT solve, rather
 than on the overall number of conflicts across all solves. So in the
 context of an optimization problem, this is not really usable directly by a
 client.
 </pre>

 <code>optional int64 max_number_of_conflicts = 37 [default = 9223372036854775807];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumberOfConflicts field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxNumberOfConflicts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumberOfConflicts</h4>
<pre>long&nbsp;getMaxNumberOfConflicts()</pre>
<div class="block"><pre>
 Maximum number of conflicts allowed to solve a problem.

 TODO(user): Maybe change the way the conflict limit is enforced?
 currently it is enforced on each independent internal SAT solve, rather
 than on the overall number of conflicts across all solves. So in the
 context of an optimization problem, this is not really usable directly by a
 client.
 </pre>

 <code>optional int64 max_number_of_conflicts = 37 [default = 9223372036854775807];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumberOfConflicts.</dd>
</dl>
</li>
</ul>
<a name="hasMaxMemoryInMb--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxMemoryInMb</h4>
<pre>boolean&nbsp;hasMaxMemoryInMb()</pre>
<div class="block"><pre>
 Maximum memory allowed for the whole thread containing the solver. The
 solver will abort as soon as it detects that this limit is crossed. As a
 result, this limit is approximative, but usually the solver will not go too
 much over.

 TODO(user): This is only used by the pure SAT solver, generalize to CP-SAT.
 </pre>

 <code>optional int64 max_memory_in_mb = 40 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxMemoryInMb field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxMemoryInMb--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxMemoryInMb</h4>
<pre>long&nbsp;getMaxMemoryInMb()</pre>
<div class="block"><pre>
 Maximum memory allowed for the whole thread containing the solver. The
 solver will abort as soon as it detects that this limit is crossed. As a
 result, this limit is approximative, but usually the solver will not go too
 much over.

 TODO(user): This is only used by the pure SAT solver, generalize to CP-SAT.
 </pre>

 <code>optional int64 max_memory_in_mb = 40 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxMemoryInMb.</dd>
</dl>
</li>
</ul>
<a name="hasAbsoluteGapLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAbsoluteGapLimit</h4>
<pre>boolean&nbsp;hasAbsoluteGapLimit()</pre>
<div class="block"><pre>
 Stop the search when the gap between the best feasible objective (O) and
 our best objective bound (B) is smaller than a limit.
 The exact definition is:
 - Absolute: abs(O - B)
 - Relative: abs(O - B) / max(1, abs(O)).

 Important: The relative gap depends on the objective offset! If you
 artificially shift the objective, you will get widely different value of
 the relative gap.

 Note that if the gap is reached, the search status will be OPTIMAL. But
 one can check the best objective bound to see the actual gap.

 If the objective is integer, then any absolute gap &lt; 1 will lead to a true
 optimal. If the objective is floating point, a gap of zero make little
 sense so is is why we use a non-zero default value. At the end of the
 search, we will display a warning if OPTIMAL is reported yet the gap is
 greater than this absolute gap.
 </pre>

 <code>optional double absolute_gap_limit = 159 [default = 0.0001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the absoluteGapLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getAbsoluteGapLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAbsoluteGapLimit</h4>
<pre>double&nbsp;getAbsoluteGapLimit()</pre>
<div class="block"><pre>
 Stop the search when the gap between the best feasible objective (O) and
 our best objective bound (B) is smaller than a limit.
 The exact definition is:
 - Absolute: abs(O - B)
 - Relative: abs(O - B) / max(1, abs(O)).

 Important: The relative gap depends on the objective offset! If you
 artificially shift the objective, you will get widely different value of
 the relative gap.

 Note that if the gap is reached, the search status will be OPTIMAL. But
 one can check the best objective bound to see the actual gap.

 If the objective is integer, then any absolute gap &lt; 1 will lead to a true
 optimal. If the objective is floating point, a gap of zero make little
 sense so is is why we use a non-zero default value. At the end of the
 search, we will display a warning if OPTIMAL is reported yet the gap is
 greater than this absolute gap.
 </pre>

 <code>optional double absolute_gap_limit = 159 [default = 0.0001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The absoluteGapLimit.</dd>
</dl>
</li>
</ul>
<a name="hasRelativeGapLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRelativeGapLimit</h4>
<pre>boolean&nbsp;hasRelativeGapLimit()</pre>
<div class="block"><code>optional double relative_gap_limit = 160 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the relativeGapLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getRelativeGapLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRelativeGapLimit</h4>
<pre>double&nbsp;getRelativeGapLimit()</pre>
<div class="block"><code>optional double relative_gap_limit = 160 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The relativeGapLimit.</dd>
</dl>
</li>
</ul>
<a name="hasRandomSeed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRandomSeed</h4>
<pre>boolean&nbsp;hasRandomSeed()</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.

 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 </pre>

 <code>optional int32 random_seed = 31 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the randomSeed field is set.</dd>
</dl>
</li>
</ul>
<a name="getRandomSeed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomSeed</h4>
<pre>int&nbsp;getRandomSeed()</pre>
<div class="block"><pre>
 At the beginning of each solve, the random number generator used in some
 part of the solver is reinitialized to this seed. If you change the random
 seed, the solver may make different choices during the solving process.

 For some problems, the running time may vary a lot depending on small
 change in the solving algorithm. Running the solver with different seeds
 enables to have more robust benchmarks when evaluating new features.
 </pre>

 <code>optional int32 random_seed = 31 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The randomSeed.</dd>
</dl>
</li>
</ul>
<a name="hasPermuteVariableRandomly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPermuteVariableRandomly</h4>
<pre>boolean&nbsp;hasPermuteVariableRandomly()</pre>
<div class="block"><pre>
 This is mainly here to test the solver variability. Note that in tests, if
 not explicitly set to false, all 3 options will be set to true so that
 clients do not rely on the solver returning a specific solution if they are
 many equivalent optimal solutions.
 </pre>

 <code>optional bool permute_variable_randomly = 178 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the permuteVariableRandomly field is set.</dd>
</dl>
</li>
</ul>
<a name="getPermuteVariableRandomly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPermuteVariableRandomly</h4>
<pre>boolean&nbsp;getPermuteVariableRandomly()</pre>
<div class="block"><pre>
 This is mainly here to test the solver variability. Note that in tests, if
 not explicitly set to false, all 3 options will be set to true so that
 clients do not rely on the solver returning a specific solution if they are
 many equivalent optimal solutions.
 </pre>

 <code>optional bool permute_variable_randomly = 178 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The permuteVariableRandomly.</dd>
</dl>
</li>
</ul>
<a name="hasPermutePresolveConstraintOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPermutePresolveConstraintOrder</h4>
<pre>boolean&nbsp;hasPermutePresolveConstraintOrder()</pre>
<div class="block"><code>optional bool permute_presolve_constraint_order = 179 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the permutePresolveConstraintOrder field is set.</dd>
</dl>
</li>
</ul>
<a name="getPermutePresolveConstraintOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPermutePresolveConstraintOrder</h4>
<pre>boolean&nbsp;getPermutePresolveConstraintOrder()</pre>
<div class="block"><code>optional bool permute_presolve_constraint_order = 179 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The permutePresolveConstraintOrder.</dd>
</dl>
</li>
</ul>
<a name="hasUseAbslRandom--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseAbslRandom</h4>
<pre>boolean&nbsp;hasUseAbslRandom()</pre>
<div class="block"><code>optional bool use_absl_random = 180 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useAbslRandom field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseAbslRandom--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseAbslRandom</h4>
<pre>boolean&nbsp;getUseAbslRandom()</pre>
<div class="block"><code>optional bool use_absl_random = 180 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useAbslRandom.</dd>
</dl>
</li>
</ul>
<a name="hasLogSearchProgress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogSearchProgress</h4>
<pre>boolean&nbsp;hasLogSearchProgress()</pre>
<div class="block"><pre>
 Whether the solver should log the search progress. This is the maing
 logging parameter and if this is false, none of the logging (callbacks,
 log_to_stdout, log_to_response, ...) will do anything.
 </pre>

 <code>optional bool log_search_progress = 41 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logSearchProgress field is set.</dd>
</dl>
</li>
</ul>
<a name="getLogSearchProgress--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogSearchProgress</h4>
<pre>boolean&nbsp;getLogSearchProgress()</pre>
<div class="block"><pre>
 Whether the solver should log the search progress. This is the maing
 logging parameter and if this is false, none of the logging (callbacks,
 log_to_stdout, log_to_response, ...) will do anything.
 </pre>

 <code>optional bool log_search_progress = 41 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logSearchProgress.</dd>
</dl>
</li>
</ul>
<a name="hasLogSubsolverStatistics--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogSubsolverStatistics</h4>
<pre>boolean&nbsp;hasLogSubsolverStatistics()</pre>
<div class="block"><pre>
 Whether the solver should display per sub-solver search statistics.
 This is only useful is log_search_progress is set to true, and if the
 number of search workers is &gt; 1. Note that in all case we display a bit
 of stats with one line per subsolver.
 </pre>

 <code>optional bool log_subsolver_statistics = 189 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logSubsolverStatistics field is set.</dd>
</dl>
</li>
</ul>
<a name="getLogSubsolverStatistics--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogSubsolverStatistics</h4>
<pre>boolean&nbsp;getLogSubsolverStatistics()</pre>
<div class="block"><pre>
 Whether the solver should display per sub-solver search statistics.
 This is only useful is log_search_progress is set to true, and if the
 number of search workers is &gt; 1. Note that in all case we display a bit
 of stats with one line per subsolver.
 </pre>

 <code>optional bool log_subsolver_statistics = 189 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logSubsolverStatistics.</dd>
</dl>
</li>
</ul>
<a name="hasLogPrefix--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogPrefix</h4>
<pre>boolean&nbsp;hasLogPrefix()</pre>
<div class="block"><pre>
 Add a prefix to all logs.
 </pre>

 <code>optional string log_prefix = 185 [default = ""];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logPrefix field is set.</dd>
</dl>
</li>
</ul>
<a name="getLogPrefix--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogPrefix</h4>
<pre>java.lang.String&nbsp;getLogPrefix()</pre>
<div class="block"><pre>
 Add a prefix to all logs.
 </pre>

 <code>optional string log_prefix = 185 [default = ""];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logPrefix.</dd>
</dl>
</li>
</ul>
<a name="getLogPrefixBytes--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogPrefixBytes</h4>
<pre>com.google.protobuf.ByteString&nbsp;getLogPrefixBytes()</pre>
<div class="block"><pre>
 Add a prefix to all logs.
 </pre>

 <code>optional string log_prefix = 185 [default = ""];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bytes for logPrefix.</dd>
</dl>
</li>
</ul>
<a name="hasLogToStdout--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogToStdout</h4>
<pre>boolean&nbsp;hasLogToStdout()</pre>
<div class="block"><pre>
 Log to stdout.
 </pre>

 <code>optional bool log_to_stdout = 186 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logToStdout field is set.</dd>
</dl>
</li>
</ul>
<a name="getLogToStdout--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogToStdout</h4>
<pre>boolean&nbsp;getLogToStdout()</pre>
<div class="block"><pre>
 Log to stdout.
 </pre>

 <code>optional bool log_to_stdout = 186 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logToStdout.</dd>
</dl>
</li>
</ul>
<a name="hasLogToResponse--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLogToResponse</h4>
<pre>boolean&nbsp;hasLogToResponse()</pre>
<div class="block"><pre>
 Log to response proto.
 </pre>

 <code>optional bool log_to_response = 187 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the logToResponse field is set.</dd>
</dl>
</li>
</ul>
<a name="getLogToResponse--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogToResponse</h4>
<pre>boolean&nbsp;getLogToResponse()</pre>
<div class="block"><pre>
 Log to response proto.
 </pre>

 <code>optional bool log_to_response = 187 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The logToResponse.</dd>
</dl>
</li>
</ul>
<a name="hasUsePbResolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUsePbResolution</h4>
<pre>boolean&nbsp;hasUsePbResolution()</pre>
<div class="block"><pre>
 Whether to use pseudo-Boolean resolution to analyze a conflict. Note that
 this option only make sense if your problem is modelized using
 pseudo-Boolean constraints. If you only have clauses, this shouldn't change
 anything (except slow the solver down).
 </pre>

 <code>optional bool use_pb_resolution = 43 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the usePbResolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getUsePbResolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUsePbResolution</h4>
<pre>boolean&nbsp;getUsePbResolution()</pre>
<div class="block"><pre>
 Whether to use pseudo-Boolean resolution to analyze a conflict. Note that
 this option only make sense if your problem is modelized using
 pseudo-Boolean constraints. If you only have clauses, this shouldn't change
 anything (except slow the solver down).
 </pre>

 <code>optional bool use_pb_resolution = 43 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The usePbResolution.</dd>
</dl>
</li>
</ul>
<a name="hasMinimizeReductionDuringPbResolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMinimizeReductionDuringPbResolution</h4>
<pre>boolean&nbsp;hasMinimizeReductionDuringPbResolution()</pre>
<div class="block"><pre>
 A different algorithm during PB resolution. It minimizes the number of
 calls to ReduceCoefficients() which can be time consuming. However, the
 search space will be different and if the coefficients are large, this may
 lead to integer overflows that could otherwise be prevented.
 </pre>

 <code>optional bool minimize_reduction_during_pb_resolution = 48 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the minimizeReductionDuringPbResolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getMinimizeReductionDuringPbResolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinimizeReductionDuringPbResolution</h4>
<pre>boolean&nbsp;getMinimizeReductionDuringPbResolution()</pre>
<div class="block"><pre>
 A different algorithm during PB resolution. It minimizes the number of
 calls to ReduceCoefficients() which can be time consuming. However, the
 search space will be different and if the coefficients are large, this may
 lead to integer overflows that could otherwise be prevented.
 </pre>

 <code>optional bool minimize_reduction_during_pb_resolution = 48 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The minimizeReductionDuringPbResolution.</dd>
</dl>
</li>
</ul>
<a name="hasCountAssumptionLevelsInLbd--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCountAssumptionLevelsInLbd</h4>
<pre>boolean&nbsp;hasCountAssumptionLevelsInLbd()</pre>
<div class="block"><pre>
 Whether or not the assumption levels are taken into account during the LBD
 computation. According to the reference below, not counting them improves
 the solver in some situation. Note that this only impact solves under
 assumptions.

 Gilles Audemard, Jean-Marie Lagniez, Laurent Simon, "Improving Glucose for
 Incremental SAT Solving with Assumptions: Application to MUS Extraction"
 Theory and Applications of Satisfiability Testing - SAT 2013, Lecture Notes
 in Computer Science Volume 7962, 2013, pp 309-317.
 </pre>

 <code>optional bool count_assumption_levels_in_lbd = 49 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the countAssumptionLevelsInLbd field is set.</dd>
</dl>
</li>
</ul>
<a name="getCountAssumptionLevelsInLbd--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCountAssumptionLevelsInLbd</h4>
<pre>boolean&nbsp;getCountAssumptionLevelsInLbd()</pre>
<div class="block"><pre>
 Whether or not the assumption levels are taken into account during the LBD
 computation. According to the reference below, not counting them improves
 the solver in some situation. Note that this only impact solves under
 assumptions.

 Gilles Audemard, Jean-Marie Lagniez, Laurent Simon, "Improving Glucose for
 Incremental SAT Solving with Assumptions: Application to MUS Extraction"
 Theory and Applications of Satisfiability Testing - SAT 2013, Lecture Notes
 in Computer Science Volume 7962, 2013, pp 309-317.
 </pre>

 <code>optional bool count_assumption_levels_in_lbd = 49 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The countAssumptionLevelsInLbd.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveBveThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveBveThreshold</h4>
<pre>boolean&nbsp;hasPresolveBveThreshold()</pre>
<div class="block"><pre>
 During presolve, only try to perform the bounded variable elimination (BVE)
 of a variable x if the number of occurrences of x times the number of
 occurrences of not(x) is not greater than this parameter.
 </pre>

 <code>optional int32 presolve_bve_threshold = 54 [default = 500];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveBveThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveBveThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveBveThreshold</h4>
<pre>int&nbsp;getPresolveBveThreshold()</pre>
<div class="block"><pre>
 During presolve, only try to perform the bounded variable elimination (BVE)
 of a variable x if the number of occurrences of x times the number of
 occurrences of not(x) is not greater than this parameter.
 </pre>

 <code>optional int32 presolve_bve_threshold = 54 [default = 500];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveBveThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveBveClauseWeight--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveBveClauseWeight</h4>
<pre>boolean&nbsp;hasPresolveBveClauseWeight()</pre>
<div class="block"><pre>
 During presolve, we apply BVE only if this weight times the number of
 clauses plus the number of clause literals is not increased.
 </pre>

 <code>optional int32 presolve_bve_clause_weight = 55 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveBveClauseWeight field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveBveClauseWeight--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveBveClauseWeight</h4>
<pre>int&nbsp;getPresolveBveClauseWeight()</pre>
<div class="block"><pre>
 During presolve, we apply BVE only if this weight times the number of
 clauses plus the number of clause literals is not increased.
 </pre>

 <code>optional int32 presolve_bve_clause_weight = 55 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveBveClauseWeight.</dd>
</dl>
</li>
</ul>
<a name="hasProbingDeterministicTimeLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasProbingDeterministicTimeLimit</h4>
<pre>boolean&nbsp;hasProbingDeterministicTimeLimit()</pre>
<div class="block"><pre>
 The maximum "deterministic" time limit to spend in probing. A value of
 zero will disable the probing.

 TODO(user): Clean up. The first one is used in CP-SAT, the other in pure
 SAT presolve.
 </pre>

 <code>optional double probing_deterministic_time_limit = 226 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the probingDeterministicTimeLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getProbingDeterministicTimeLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProbingDeterministicTimeLimit</h4>
<pre>double&nbsp;getProbingDeterministicTimeLimit()</pre>
<div class="block"><pre>
 The maximum "deterministic" time limit to spend in probing. A value of
 zero will disable the probing.

 TODO(user): Clean up. The first one is used in CP-SAT, the other in pure
 SAT presolve.
 </pre>

 <code>optional double probing_deterministic_time_limit = 226 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The probingDeterministicTimeLimit.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveProbingDeterministicTimeLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveProbingDeterministicTimeLimit</h4>
<pre>boolean&nbsp;hasPresolveProbingDeterministicTimeLimit()</pre>
<div class="block"><code>optional double presolve_probing_deterministic_time_limit = 57 [default = 30];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveProbingDeterministicTimeLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveProbingDeterministicTimeLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveProbingDeterministicTimeLimit</h4>
<pre>double&nbsp;getPresolveProbingDeterministicTimeLimit()</pre>
<div class="block"><code>optional double presolve_probing_deterministic_time_limit = 57 [default = 30];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveProbingDeterministicTimeLimit.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveBlockedClause--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveBlockedClause</h4>
<pre>boolean&nbsp;hasPresolveBlockedClause()</pre>
<div class="block"><pre>
 Whether we use an heuristic to detect some basic case of blocked clause
 in the SAT presolve.
 </pre>

 <code>optional bool presolve_blocked_clause = 88 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveBlockedClause field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveBlockedClause--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveBlockedClause</h4>
<pre>boolean&nbsp;getPresolveBlockedClause()</pre>
<div class="block"><pre>
 Whether we use an heuristic to detect some basic case of blocked clause
 in the SAT presolve.
 </pre>

 <code>optional bool presolve_blocked_clause = 88 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveBlockedClause.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveUseBva--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveUseBva</h4>
<pre>boolean&nbsp;hasPresolveUseBva()</pre>
<div class="block"><pre>
 Whether or not we use Bounded Variable Addition (BVA) in the presolve.
 </pre>

 <code>optional bool presolve_use_bva = 72 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveUseBva field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveUseBva--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveUseBva</h4>
<pre>boolean&nbsp;getPresolveUseBva()</pre>
<div class="block"><pre>
 Whether or not we use Bounded Variable Addition (BVA) in the presolve.
 </pre>

 <code>optional bool presolve_use_bva = 72 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveUseBva.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveBvaThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveBvaThreshold</h4>
<pre>boolean&nbsp;hasPresolveBvaThreshold()</pre>
<div class="block"><pre>
 Apply Bounded Variable Addition (BVA) if the number of clauses is reduced
 by stricly more than this threshold. The algorithm described in the paper
 uses 0, but quick experiments showed that 1 is a good value. It may not be
 worth it to add a new variable just to remove one clause.
 </pre>

 <code>optional int32 presolve_bva_threshold = 73 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveBvaThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveBvaThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveBvaThreshold</h4>
<pre>int&nbsp;getPresolveBvaThreshold()</pre>
<div class="block"><pre>
 Apply Bounded Variable Addition (BVA) if the number of clauses is reduced
 by stricly more than this threshold. The algorithm described in the paper
 uses 0, but quick experiments showed that 1 is a good value. It may not be
 worth it to add a new variable just to remove one clause.
 </pre>

 <code>optional int32 presolve_bva_threshold = 73 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveBvaThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasMaxPresolveIterations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxPresolveIterations</h4>
<pre>boolean&nbsp;hasMaxPresolveIterations()</pre>
<div class="block"><pre>
 In case of large reduction in a presolve iteration, we perform multiple
 presolve iterations. This parameter controls the maximum number of such
 presolve iterations.
 </pre>

 <code>optional int32 max_presolve_iterations = 138 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxPresolveIterations field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxPresolveIterations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxPresolveIterations</h4>
<pre>int&nbsp;getMaxPresolveIterations()</pre>
<div class="block"><pre>
 In case of large reduction in a presolve iteration, we perform multiple
 presolve iterations. This parameter controls the maximum number of such
 presolve iterations.
 </pre>

 <code>optional int32 max_presolve_iterations = 138 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxPresolveIterations.</dd>
</dl>
</li>
</ul>
<a name="hasCpModelPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCpModelPresolve</h4>
<pre>boolean&nbsp;hasCpModelPresolve()</pre>
<div class="block"><pre>
 Whether we presolve the cp_model before solving it.
 </pre>

 <code>optional bool cp_model_presolve = 86 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the cpModelPresolve field is set.</dd>
</dl>
</li>
</ul>
<a name="getCpModelPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCpModelPresolve</h4>
<pre>boolean&nbsp;getCpModelPresolve()</pre>
<div class="block"><pre>
 Whether we presolve the cp_model before solving it.
 </pre>

 <code>optional bool cp_model_presolve = 86 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cpModelPresolve.</dd>
</dl>
</li>
</ul>
<a name="hasCpModelProbingLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCpModelProbingLevel</h4>
<pre>boolean&nbsp;hasCpModelProbingLevel()</pre>
<div class="block"><pre>
 How much effort do we spend on probing. 0 disables it completely.
 </pre>

 <code>optional int32 cp_model_probing_level = 110 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the cpModelProbingLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getCpModelProbingLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCpModelProbingLevel</h4>
<pre>int&nbsp;getCpModelProbingLevel()</pre>
<div class="block"><pre>
 How much effort do we spend on probing. 0 disables it completely.
 </pre>

 <code>optional int32 cp_model_probing_level = 110 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cpModelProbingLevel.</dd>
</dl>
</li>
</ul>
<a name="hasCpModelUseSatPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCpModelUseSatPresolve</h4>
<pre>boolean&nbsp;hasCpModelUseSatPresolve()</pre>
<div class="block"><pre>
 Whether we also use the sat presolve when cp_model_presolve is true.
 </pre>

 <code>optional bool cp_model_use_sat_presolve = 93 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the cpModelUseSatPresolve field is set.</dd>
</dl>
</li>
</ul>
<a name="getCpModelUseSatPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCpModelUseSatPresolve</h4>
<pre>boolean&nbsp;getCpModelUseSatPresolve()</pre>
<div class="block"><pre>
 Whether we also use the sat presolve when cp_model_presolve is true.
 </pre>

 <code>optional bool cp_model_use_sat_presolve = 93 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cpModelUseSatPresolve.</dd>
</dl>
</li>
</ul>
<a name="hasRemoveFixedVariablesEarly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRemoveFixedVariablesEarly</h4>
<pre>boolean&nbsp;hasRemoveFixedVariablesEarly()</pre>
<div class="block"><pre>
 If cp_model_presolve is true and there is a large proportion of fixed
 variable after the first model copy, remap all the model to a dense set of
 variable before the full presolve even starts. This should help for LNS on
 large models.
 </pre>

 <code>optional bool remove_fixed_variables_early = 310 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the removeFixedVariablesEarly field is set.</dd>
</dl>
</li>
</ul>
<a name="getRemoveFixedVariablesEarly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRemoveFixedVariablesEarly</h4>
<pre>boolean&nbsp;getRemoveFixedVariablesEarly()</pre>
<div class="block"><pre>
 If cp_model_presolve is true and there is a large proportion of fixed
 variable after the first model copy, remap all the model to a dense set of
 variable before the full presolve even starts. This should help for LNS on
 large models.
 </pre>

 <code>optional bool remove_fixed_variables_early = 310 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The removeFixedVariablesEarly.</dd>
</dl>
</li>
</ul>
<a name="hasDetectTableWithCost--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDetectTableWithCost</h4>
<pre>boolean&nbsp;hasDetectTableWithCost()</pre>
<div class="block"><pre>
 If true, we detect variable that are unique to a table constraint and only
 there to encode a cost on each tuple. This is usually the case when a WCSP
 (weighted constraint program) is encoded into CP-SAT format.

 This can lead to a dramatic speed-up for such problems but is still
 experimental at this point.
 </pre>

 <code>optional bool detect_table_with_cost = 216 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the detectTableWithCost field is set.</dd>
</dl>
</li>
</ul>
<a name="getDetectTableWithCost--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDetectTableWithCost</h4>
<pre>boolean&nbsp;getDetectTableWithCost()</pre>
<div class="block"><pre>
 If true, we detect variable that are unique to a table constraint and only
 there to encode a cost on each tuple. This is usually the case when a WCSP
 (weighted constraint program) is encoded into CP-SAT format.

 This can lead to a dramatic speed-up for such problems but is still
 experimental at this point.
 </pre>

 <code>optional bool detect_table_with_cost = 216 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The detectTableWithCost.</dd>
</dl>
</li>
</ul>
<a name="hasTableCompressionLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasTableCompressionLevel</h4>
<pre>boolean&nbsp;hasTableCompressionLevel()</pre>
<div class="block"><pre>
 How much we try to "compress" a table constraint. Compressing more leads to
 less Booleans and faster propagation but can reduced the quality of the lp
 relaxation. Values goes from 0 to 3 where we always try to fully compress a
 table. At 2, we try to automatically decide if it is worth it.
 </pre>

 <code>optional int32 table_compression_level = 217 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the tableCompressionLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getTableCompressionLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTableCompressionLevel</h4>
<pre>int&nbsp;getTableCompressionLevel()</pre>
<div class="block"><pre>
 How much we try to "compress" a table constraint. Compressing more leads to
 less Booleans and faster propagation but can reduced the quality of the lp
 relaxation. Values goes from 0 to 3 where we always try to fully compress a
 table. At 2, we try to automatically decide if it is worth it.
 </pre>

 <code>optional int32 table_compression_level = 217 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The tableCompressionLevel.</dd>
</dl>
</li>
</ul>
<a name="hasExpandAlldiffConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExpandAlldiffConstraints</h4>
<pre>boolean&nbsp;hasExpandAlldiffConstraints()</pre>
<div class="block"><pre>
 If true, expand all_different constraints that are not permutations.
 Permutations (#Variables = #Values) are always expanded.
 </pre>

 <code>optional bool expand_alldiff_constraints = 170 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the expandAlldiffConstraints field is set.</dd>
</dl>
</li>
</ul>
<a name="getExpandAlldiffConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExpandAlldiffConstraints</h4>
<pre>boolean&nbsp;getExpandAlldiffConstraints()</pre>
<div class="block"><pre>
 If true, expand all_different constraints that are not permutations.
 Permutations (#Variables = #Values) are always expanded.
 </pre>

 <code>optional bool expand_alldiff_constraints = 170 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The expandAlldiffConstraints.</dd>
</dl>
</li>
</ul>
<a name="hasExpandReservoirConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExpandReservoirConstraints</h4>
<pre>boolean&nbsp;hasExpandReservoirConstraints()</pre>
<div class="block"><pre>
 If true, expand the reservoir constraints by creating booleans for all
 possible precedences between event and encoding the constraint.
 </pre>

 <code>optional bool expand_reservoir_constraints = 182 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the expandReservoirConstraints field is set.</dd>
</dl>
</li>
</ul>
<a name="getExpandReservoirConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExpandReservoirConstraints</h4>
<pre>boolean&nbsp;getExpandReservoirConstraints()</pre>
<div class="block"><pre>
 If true, expand the reservoir constraints by creating booleans for all
 possible precedences between event and encoding the constraint.
 </pre>

 <code>optional bool expand_reservoir_constraints = 182 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The expandReservoirConstraints.</dd>
</dl>
</li>
</ul>
<a name="hasExpandReservoirUsingCircuit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExpandReservoirUsingCircuit</h4>
<pre>boolean&nbsp;hasExpandReservoirUsingCircuit()</pre>
<div class="block"><pre>
 Mainly useful for testing.

 If this and expand_reservoir_constraints is true, we use a different
 encoding of the reservoir constraint using circuit instead of precedences.
 Note that this is usually slower, but can exercise different part of the
 solver. Note that contrary to the precedence encoding, this easily support
 variable demands.

 WARNING: with this encoding, the constraint takes a slightly different
 meaning. There must exist a permutation of the events occurring at the same
 time such that the level is within the reservoir after each of these events
 (in this permuted order). So we cannot have +100 and -100 at the same time
 if the level must be between 0 and 10 (as authorized by the reservoir
 constraint).
 </pre>

 <code>optional bool expand_reservoir_using_circuit = 288 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the expandReservoirUsingCircuit field is set.</dd>
</dl>
</li>
</ul>
<a name="getExpandReservoirUsingCircuit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExpandReservoirUsingCircuit</h4>
<pre>boolean&nbsp;getExpandReservoirUsingCircuit()</pre>
<div class="block"><pre>
 Mainly useful for testing.

 If this and expand_reservoir_constraints is true, we use a different
 encoding of the reservoir constraint using circuit instead of precedences.
 Note that this is usually slower, but can exercise different part of the
 solver. Note that contrary to the precedence encoding, this easily support
 variable demands.

 WARNING: with this encoding, the constraint takes a slightly different
 meaning. There must exist a permutation of the events occurring at the same
 time such that the level is within the reservoir after each of these events
 (in this permuted order). So we cannot have +100 and -100 at the same time
 if the level must be between 0 and 10 (as authorized by the reservoir
 constraint).
 </pre>

 <code>optional bool expand_reservoir_using_circuit = 288 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The expandReservoirUsingCircuit.</dd>
</dl>
</li>
</ul>
<a name="hasEncodeCumulativeAsReservoir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasEncodeCumulativeAsReservoir</h4>
<pre>boolean&nbsp;hasEncodeCumulativeAsReservoir()</pre>
<div class="block"><pre>
 Encore cumulative with fixed demands and capacity as a reservoir
 constraint. The only reason you might want to do that is to test the
 reservoir propagation code!
 </pre>

 <code>optional bool encode_cumulative_as_reservoir = 287 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the encodeCumulativeAsReservoir field is set.</dd>
</dl>
</li>
</ul>
<a name="getEncodeCumulativeAsReservoir--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEncodeCumulativeAsReservoir</h4>
<pre>boolean&nbsp;getEncodeCumulativeAsReservoir()</pre>
<div class="block"><pre>
 Encore cumulative with fixed demands and capacity as a reservoir
 constraint. The only reason you might want to do that is to test the
 reservoir propagation code!
 </pre>

 <code>optional bool encode_cumulative_as_reservoir = 287 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The encodeCumulativeAsReservoir.</dd>
</dl>
</li>
</ul>
<a name="hasMaxLinMaxSizeForExpansion--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxLinMaxSizeForExpansion</h4>
<pre>boolean&nbsp;hasMaxLinMaxSizeForExpansion()</pre>
<div class="block"><pre>
 If the number of expressions in the lin_max is less that the max size
 parameter, model expansion replaces target = max(xi) by linear constraint
 with the introduction of new booleans bi such that bi =&gt; target == xi.

 This is mainly for experimenting compared to a custom lin_max propagator.
 </pre>

 <code>optional int32 max_lin_max_size_for_expansion = 280 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxLinMaxSizeForExpansion field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxLinMaxSizeForExpansion--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxLinMaxSizeForExpansion</h4>
<pre>int&nbsp;getMaxLinMaxSizeForExpansion()</pre>
<div class="block"><pre>
 If the number of expressions in the lin_max is less that the max size
 parameter, model expansion replaces target = max(xi) by linear constraint
 with the introduction of new booleans bi such that bi =&gt; target == xi.

 This is mainly for experimenting compared to a custom lin_max propagator.
 </pre>

 <code>optional int32 max_lin_max_size_for_expansion = 280 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxLinMaxSizeForExpansion.</dd>
</dl>
</li>
</ul>
<a name="hasDisableConstraintExpansion--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDisableConstraintExpansion</h4>
<pre>boolean&nbsp;hasDisableConstraintExpansion()</pre>
<div class="block"><pre>
 If true, it disable all constraint expansion.
 This should only be used to test the presolve of expanded constraints.
 </pre>

 <code>optional bool disable_constraint_expansion = 181 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the disableConstraintExpansion field is set.</dd>
</dl>
</li>
</ul>
<a name="getDisableConstraintExpansion--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDisableConstraintExpansion</h4>
<pre>boolean&nbsp;getDisableConstraintExpansion()</pre>
<div class="block"><pre>
 If true, it disable all constraint expansion.
 This should only be used to test the presolve of expanded constraints.
 </pre>

 <code>optional bool disable_constraint_expansion = 181 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The disableConstraintExpansion.</dd>
</dl>
</li>
</ul>
<a name="hasEncodeComplexLinearConstraintWithInteger--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasEncodeComplexLinearConstraintWithInteger</h4>
<pre>boolean&nbsp;hasEncodeComplexLinearConstraintWithInteger()</pre>
<div class="block"><pre>
 Linear constraint with a complex right hand side (more than a single
 interval) need to be expanded, there is a couple of way to do that.
 </pre>

 <code>optional bool encode_complex_linear_constraint_with_integer = 223 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the encodeComplexLinearConstraintWithInteger field is set.</dd>
</dl>
</li>
</ul>
<a name="getEncodeComplexLinearConstraintWithInteger--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEncodeComplexLinearConstraintWithInteger</h4>
<pre>boolean&nbsp;getEncodeComplexLinearConstraintWithInteger()</pre>
<div class="block"><pre>
 Linear constraint with a complex right hand side (more than a single
 interval) need to be expanded, there is a couple of way to do that.
 </pre>

 <code>optional bool encode_complex_linear_constraint_with_integer = 223 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The encodeComplexLinearConstraintWithInteger.</dd>
</dl>
</li>
</ul>
<a name="hasMergeNoOverlapWorkLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMergeNoOverlapWorkLimit</h4>
<pre>boolean&nbsp;hasMergeNoOverlapWorkLimit()</pre>
<div class="block"><pre>
 During presolve, we use a maximum clique heuristic to merge together
 no-overlap constraints or at most one constraints. This code can be slow,
 so we have a limit in place on the number of explored nodes in the
 underlying graph. The internal limit is an int64, but we use double here to
 simplify manual input.
 </pre>

 <code>optional double merge_no_overlap_work_limit = 145 [default = 1000000000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mergeNoOverlapWorkLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getMergeNoOverlapWorkLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMergeNoOverlapWorkLimit</h4>
<pre>double&nbsp;getMergeNoOverlapWorkLimit()</pre>
<div class="block"><pre>
 During presolve, we use a maximum clique heuristic to merge together
 no-overlap constraints or at most one constraints. This code can be slow,
 so we have a limit in place on the number of explored nodes in the
 underlying graph. The internal limit is an int64, but we use double here to
 simplify manual input.
 </pre>

 <code>optional double merge_no_overlap_work_limit = 145 [default = 1000000000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mergeNoOverlapWorkLimit.</dd>
</dl>
</li>
</ul>
<a name="hasMergeAtMostOneWorkLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMergeAtMostOneWorkLimit</h4>
<pre>boolean&nbsp;hasMergeAtMostOneWorkLimit()</pre>
<div class="block"><code>optional double merge_at_most_one_work_limit = 146 [default = 100000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mergeAtMostOneWorkLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getMergeAtMostOneWorkLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMergeAtMostOneWorkLimit</h4>
<pre>double&nbsp;getMergeAtMostOneWorkLimit()</pre>
<div class="block"><code>optional double merge_at_most_one_work_limit = 146 [default = 100000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mergeAtMostOneWorkLimit.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveSubstitutionLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveSubstitutionLevel</h4>
<pre>boolean&nbsp;hasPresolveSubstitutionLevel()</pre>
<div class="block"><pre>
 How much substitution (also called free variable aggregation in MIP
 litterature) should we perform at presolve. This currently only concerns
 variable appearing only in linear constraints. For now the value 0 turns it
 off and any positive value performs substitution.
 </pre>

 <code>optional int32 presolve_substitution_level = 147 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveSubstitutionLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveSubstitutionLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveSubstitutionLevel</h4>
<pre>int&nbsp;getPresolveSubstitutionLevel()</pre>
<div class="block"><pre>
 How much substitution (also called free variable aggregation in MIP
 litterature) should we perform at presolve. This currently only concerns
 variable appearing only in linear constraints. For now the value 0 turns it
 off and any positive value performs substitution.
 </pre>

 <code>optional int32 presolve_substitution_level = 147 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveSubstitutionLevel.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveExtractIntegerEnforcement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveExtractIntegerEnforcement</h4>
<pre>boolean&nbsp;hasPresolveExtractIntegerEnforcement()</pre>
<div class="block"><pre>
 If true, we will extract from linear constraints, enforcement literals of
 the form "integer variable at bound =&gt; simplified constraint". This should
 always be beneficial except that we don't always handle them as efficiently
 as we could for now. This causes problem on manna81.mps (LP relaxation not
 as tight it seems) and on neos-3354841-apure.mps.gz (too many literals
 created this way).
 </pre>

 <code>optional bool presolve_extract_integer_enforcement = 174 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveExtractIntegerEnforcement field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveExtractIntegerEnforcement--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveExtractIntegerEnforcement</h4>
<pre>boolean&nbsp;getPresolveExtractIntegerEnforcement()</pre>
<div class="block"><pre>
 If true, we will extract from linear constraints, enforcement literals of
 the form "integer variable at bound =&gt; simplified constraint". This should
 always be beneficial except that we don't always handle them as efficiently
 as we could for now. This causes problem on manna81.mps (LP relaxation not
 as tight it seems) and on neos-3354841-apure.mps.gz (too many literals
 created this way).
 </pre>

 <code>optional bool presolve_extract_integer_enforcement = 174 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveExtractIntegerEnforcement.</dd>
</dl>
</li>
</ul>
<a name="hasPresolveInclusionWorkLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveInclusionWorkLimit</h4>
<pre>boolean&nbsp;hasPresolveInclusionWorkLimit()</pre>
<div class="block"><pre>
 A few presolve operations involve detecting constraints included in other
 constraint. Since there can be a quadratic number of such pairs, and
 processing them usually involve scanning them, the complexity of these
 operations can be big. This enforce a local deterministic limit on the
 number of entries scanned. Default is 1e8.

 A value of zero will disable these presolve rules completely.
 </pre>

 <code>optional int64 presolve_inclusion_work_limit = 201 [default = 100000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveInclusionWorkLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getPresolveInclusionWorkLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveInclusionWorkLimit</h4>
<pre>long&nbsp;getPresolveInclusionWorkLimit()</pre>
<div class="block"><pre>
 A few presolve operations involve detecting constraints included in other
 constraint. Since there can be a quadratic number of such pairs, and
 processing them usually involve scanning them, the complexity of these
 operations can be big. This enforce a local deterministic limit on the
 number of entries scanned. Default is 1e8.

 A value of zero will disable these presolve rules completely.
 </pre>

 <code>optional int64 presolve_inclusion_work_limit = 201 [default = 100000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveInclusionWorkLimit.</dd>
</dl>
</li>
</ul>
<a name="hasIgnoreNames--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasIgnoreNames</h4>
<pre>boolean&nbsp;hasIgnoreNames()</pre>
<div class="block"><pre>
 If true, we don't keep names in our internal copy of the user given model.
 </pre>

 <code>optional bool ignore_names = 202 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the ignoreNames field is set.</dd>
</dl>
</li>
</ul>
<a name="getIgnoreNames--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIgnoreNames</h4>
<pre>boolean&nbsp;getIgnoreNames()</pre>
<div class="block"><pre>
 If true, we don't keep names in our internal copy of the user given model.
 </pre>

 <code>optional bool ignore_names = 202 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The ignoreNames.</dd>
</dl>
</li>
</ul>
<a name="hasInferAllDiffs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInferAllDiffs</h4>
<pre>boolean&nbsp;hasInferAllDiffs()</pre>
<div class="block"><pre>
 Run a max-clique code amongst all the x != y we can find and try to infer
 set of variables that are all different. This allows to close neos16.mps
 for instance. Note that we only run this code if there is no all_diff
 already in the model so that if a user want to add some all_diff, we assume
 it is well done and do not try to add more.

 This will also detect and add no_overlap constraints, if all the relations
 x != y have "offsets" between them. I.e. x &gt; y + offset.
 </pre>

 <code>optional bool infer_all_diffs = 233 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the inferAllDiffs field is set.</dd>
</dl>
</li>
</ul>
<a name="getInferAllDiffs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInferAllDiffs</h4>
<pre>boolean&nbsp;getInferAllDiffs()</pre>
<div class="block"><pre>
 Run a max-clique code amongst all the x != y we can find and try to infer
 set of variables that are all different. This allows to close neos16.mps
 for instance. Note that we only run this code if there is no all_diff
 already in the model so that if a user want to add some all_diff, we assume
 it is well done and do not try to add more.

 This will also detect and add no_overlap constraints, if all the relations
 x != y have "offsets" between them. I.e. x &gt; y + offset.
 </pre>

 <code>optional bool infer_all_diffs = 233 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inferAllDiffs.</dd>
</dl>
</li>
</ul>
<a name="hasFindBigLinearOverlap--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFindBigLinearOverlap</h4>
<pre>boolean&nbsp;hasFindBigLinearOverlap()</pre>
<div class="block"><pre>
 Try to find large "rectangle" in the linear constraint matrix with
 identical lines. If such rectangle is big enough, we can introduce a new
 integer variable corresponding to the common expression and greatly reduce
 the number of non-zero.
 </pre>

 <code>optional bool find_big_linear_overlap = 234 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the findBigLinearOverlap field is set.</dd>
</dl>
</li>
</ul>
<a name="getFindBigLinearOverlap--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFindBigLinearOverlap</h4>
<pre>boolean&nbsp;getFindBigLinearOverlap()</pre>
<div class="block"><pre>
 Try to find large "rectangle" in the linear constraint matrix with
 identical lines. If such rectangle is big enough, we can introduce a new
 integer variable corresponding to the common expression and greatly reduce
 the number of non-zero.
 </pre>

 <code>optional bool find_big_linear_overlap = 234 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The findBigLinearOverlap.</dd>
</dl>
</li>
</ul>
<a name="hasUseSatInprocessing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseSatInprocessing</h4>
<pre>boolean&nbsp;hasUseSatInprocessing()</pre>
<div class="block"><pre>
 Enable or disable "inprocessing" which is some SAT presolving done at
 each restart to the root level.
 </pre>

 <code>optional bool use_sat_inprocessing = 163 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useSatInprocessing field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseSatInprocessing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseSatInprocessing</h4>
<pre>boolean&nbsp;getUseSatInprocessing()</pre>
<div class="block"><pre>
 Enable or disable "inprocessing" which is some SAT presolving done at
 each restart to the root level.
 </pre>

 <code>optional bool use_sat_inprocessing = 163 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useSatInprocessing.</dd>
</dl>
</li>
</ul>
<a name="hasInprocessingDtimeRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInprocessingDtimeRatio</h4>
<pre>boolean&nbsp;hasInprocessingDtimeRatio()</pre>
<div class="block"><pre>
 Proportion of deterministic time we should spend on inprocessing.
 At each "restart", if the proportion is below this ratio, we will do some
 inprocessing, otherwise, we skip it for this restart.
 </pre>

 <code>optional double inprocessing_dtime_ratio = 273 [default = 0.2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the inprocessingDtimeRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getInprocessingDtimeRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInprocessingDtimeRatio</h4>
<pre>double&nbsp;getInprocessingDtimeRatio()</pre>
<div class="block"><pre>
 Proportion of deterministic time we should spend on inprocessing.
 At each "restart", if the proportion is below this ratio, we will do some
 inprocessing, otherwise, we skip it for this restart.
 </pre>

 <code>optional double inprocessing_dtime_ratio = 273 [default = 0.2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inprocessingDtimeRatio.</dd>
</dl>
</li>
</ul>
<a name="hasInprocessingProbingDtime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInprocessingProbingDtime</h4>
<pre>boolean&nbsp;hasInprocessingProbingDtime()</pre>
<div class="block"><pre>
 The amount of dtime we should spend on probing for each inprocessing round.
 </pre>

 <code>optional double inprocessing_probing_dtime = 274 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the inprocessingProbingDtime field is set.</dd>
</dl>
</li>
</ul>
<a name="getInprocessingProbingDtime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInprocessingProbingDtime</h4>
<pre>double&nbsp;getInprocessingProbingDtime()</pre>
<div class="block"><pre>
 The amount of dtime we should spend on probing for each inprocessing round.
 </pre>

 <code>optional double inprocessing_probing_dtime = 274 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inprocessingProbingDtime.</dd>
</dl>
</li>
</ul>
<a name="hasInprocessingMinimizationDtime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInprocessingMinimizationDtime</h4>
<pre>boolean&nbsp;hasInprocessingMinimizationDtime()</pre>
<div class="block"><pre>
 Parameters for an heuristic similar to the one described in "An effective
 learnt clause minimization approach for CDCL Sat Solvers",
 https://www.ijcai.org/proceedings/2017/0098.pdf

 This is the amount of dtime we should spend on this technique during each
 inprocessing phase.

 The minimization technique is the same as the one used to minimize core in
 max-sat. We also minimize problem clauses and not just the learned clause
 that we keep forever like in the paper.
 </pre>

 <code>optional double inprocessing_minimization_dtime = 275 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the inprocessingMinimizationDtime field is set.</dd>
</dl>
</li>
</ul>
<a name="getInprocessingMinimizationDtime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInprocessingMinimizationDtime</h4>
<pre>double&nbsp;getInprocessingMinimizationDtime()</pre>
<div class="block"><pre>
 Parameters for an heuristic similar to the one described in "An effective
 learnt clause minimization approach for CDCL Sat Solvers",
 https://www.ijcai.org/proceedings/2017/0098.pdf

 This is the amount of dtime we should spend on this technique during each
 inprocessing phase.

 The minimization technique is the same as the one used to minimize core in
 max-sat. We also minimize problem clauses and not just the learned clause
 that we keep forever like in the paper.
 </pre>

 <code>optional double inprocessing_minimization_dtime = 275 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inprocessingMinimizationDtime.</dd>
</dl>
</li>
</ul>
<a name="hasInprocessingMinimizationUseConflictAnalysis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInprocessingMinimizationUseConflictAnalysis</h4>
<pre>boolean&nbsp;hasInprocessingMinimizationUseConflictAnalysis()</pre>
<div class="block"><code>optional bool inprocessing_minimization_use_conflict_analysis = 297 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the inprocessingMinimizationUseConflictAnalysis field is set.</dd>
</dl>
</li>
</ul>
<a name="getInprocessingMinimizationUseConflictAnalysis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInprocessingMinimizationUseConflictAnalysis</h4>
<pre>boolean&nbsp;getInprocessingMinimizationUseConflictAnalysis()</pre>
<div class="block"><code>optional bool inprocessing_minimization_use_conflict_analysis = 297 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inprocessingMinimizationUseConflictAnalysis.</dd>
</dl>
</li>
</ul>
<a name="hasInprocessingMinimizationUseAllOrderings--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInprocessingMinimizationUseAllOrderings</h4>
<pre>boolean&nbsp;hasInprocessingMinimizationUseAllOrderings()</pre>
<div class="block"><code>optional bool inprocessing_minimization_use_all_orderings = 298 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the inprocessingMinimizationUseAllOrderings field is set.</dd>
</dl>
</li>
</ul>
<a name="getInprocessingMinimizationUseAllOrderings--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInprocessingMinimizationUseAllOrderings</h4>
<pre>boolean&nbsp;getInprocessingMinimizationUseAllOrderings()</pre>
<div class="block"><code>optional bool inprocessing_minimization_use_all_orderings = 298 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inprocessingMinimizationUseAllOrderings.</dd>
</dl>
</li>
</ul>
<a name="hasNumWorkers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumWorkers</h4>
<pre>boolean&nbsp;hasNumWorkers()</pre>
<div class="block"><pre>
 Specify the number of parallel workers (i.e. threads) to use during search.
 This should usually be lower than your number of available cpus +
 hyperthread in your machine.

 A value of 0 means the solver will try to use all cores on the machine.
 A number of 1 means no parallelism.

 Note that 'num_workers' is the preferred name, but if it is set to zero,
 we will still read the deprecated 'num_search_workers'.

 As of 2020-04-10, if you're using SAT via MPSolver (to solve integer
 programs) this field is overridden with a value of 8, if the field is not
 set *explicitly*. Thus, always set this field explicitly or via
 MPSolver::SetNumThreads().
 </pre>

 <code>optional int32 num_workers = 206 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numWorkers field is set.</dd>
</dl>
</li>
</ul>
<a name="getNumWorkers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumWorkers</h4>
<pre>int&nbsp;getNumWorkers()</pre>
<div class="block"><pre>
 Specify the number of parallel workers (i.e. threads) to use during search.
 This should usually be lower than your number of available cpus +
 hyperthread in your machine.

 A value of 0 means the solver will try to use all cores on the machine.
 A number of 1 means no parallelism.

 Note that 'num_workers' is the preferred name, but if it is set to zero,
 we will still read the deprecated 'num_search_workers'.

 As of 2020-04-10, if you're using SAT via MPSolver (to solve integer
 programs) this field is overridden with a value of 8, if the field is not
 set *explicitly*. Thus, always set this field explicitly or via
 MPSolver::SetNumThreads().
 </pre>

 <code>optional int32 num_workers = 206 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numWorkers.</dd>
</dl>
</li>
</ul>
<a name="hasNumSearchWorkers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumSearchWorkers</h4>
<pre>boolean&nbsp;hasNumSearchWorkers()</pre>
<div class="block"><code>optional int32 num_search_workers = 100 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numSearchWorkers field is set.</dd>
</dl>
</li>
</ul>
<a name="getNumSearchWorkers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumSearchWorkers</h4>
<pre>int&nbsp;getNumSearchWorkers()</pre>
<div class="block"><code>optional int32 num_search_workers = 100 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numSearchWorkers.</dd>
</dl>
</li>
</ul>
<a name="hasNumFullSubsolvers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumFullSubsolvers</h4>
<pre>boolean&nbsp;hasNumFullSubsolvers()</pre>
<div class="block"><pre>
 We distinguish subsolvers that consume a full thread, and the ones that are
 always interleaved. If left at zero, we will fix this with a default
 formula that depends on num_workers. But if you start modifying what runs,
 you might want to fix that to a given value depending on the num_workers
 you use.
 </pre>

 <code>optional int32 num_full_subsolvers = 294 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numFullSubsolvers field is set.</dd>
</dl>
</li>
</ul>
<a name="getNumFullSubsolvers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumFullSubsolvers</h4>
<pre>int&nbsp;getNumFullSubsolvers()</pre>
<div class="block"><pre>
 We distinguish subsolvers that consume a full thread, and the ones that are
 always interleaved. If left at zero, we will fix this with a default
 formula that depends on num_workers. But if you start modifying what runs,
 you might want to fix that to a given value depending on the num_workers
 you use.
 </pre>

 <code>optional int32 num_full_subsolvers = 294 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numFullSubsolvers.</dd>
</dl>
</li>
</ul>
<a name="getSubsolversList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolversList</h4>
<pre>java.util.List&lt;java.lang.String&gt;&nbsp;getSubsolversList()</pre>
<div class="block"><pre>
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters. This field indicates the names of the parameters
 that are used in multithread. This only applies to "full" subsolvers.

 See cp_model_search.cc to see a list of the names and the default value (if
 left empty) that looks like:
 - default_lp           (linearization_level:1)
 - fixed                (only if fixed search specified or scheduling)
 - no_lp                (linearization_level:0)
 - max_lp               (linearization_level:2)
 - pseudo_costs         (only if objective, change search heuristic)
 - reduced_costs        (only if objective, change search heuristic)
 - quick_restart        (kind of probing)
 - quick_restart_no_lp  (kind of probing with linearization_level:0)
 - lb_tree_search       (to improve lower bound, MIP like tree search)
 - probing              (continuous probing and shaving)

 Also, note that some set of parameters will be ignored if they do not make
 sense. For instance if there is no objective, pseudo_cost or reduced_cost
 search will be ignored. Core based search will only work if the objective
 has many terms. If there is no fixed strategy fixed will be ignored. And so
 on.

 The order is important, as only the first num_full_subsolvers will be
 scheduled. You can see in the log which one are selected for a given run.
 </pre>

 <code>repeated string subsolvers = 207;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list containing the subsolvers.</dd>
</dl>
</li>
</ul>
<a name="getSubsolversCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolversCount</h4>
<pre>int&nbsp;getSubsolversCount()</pre>
<div class="block"><pre>
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters. This field indicates the names of the parameters
 that are used in multithread. This only applies to "full" subsolvers.

 See cp_model_search.cc to see a list of the names and the default value (if
 left empty) that looks like:
 - default_lp           (linearization_level:1)
 - fixed                (only if fixed search specified or scheduling)
 - no_lp                (linearization_level:0)
 - max_lp               (linearization_level:2)
 - pseudo_costs         (only if objective, change search heuristic)
 - reduced_costs        (only if objective, change search heuristic)
 - quick_restart        (kind of probing)
 - quick_restart_no_lp  (kind of probing with linearization_level:0)
 - lb_tree_search       (to improve lower bound, MIP like tree search)
 - probing              (continuous probing and shaving)

 Also, note that some set of parameters will be ignored if they do not make
 sense. For instance if there is no objective, pseudo_cost or reduced_cost
 search will be ignored. Core based search will only work if the objective
 has many terms. If there is no fixed strategy fixed will be ignored. And so
 on.

 The order is important, as only the first num_full_subsolvers will be
 scheduled. You can see in the log which one are selected for a given run.
 </pre>

 <code>repeated string subsolvers = 207;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The count of subsolvers.</dd>
</dl>
</li>
</ul>
<a name="getSubsolvers-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolvers</h4>
<pre>java.lang.String&nbsp;getSubsolvers(int&nbsp;index)</pre>
<div class="block"><pre>
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters. This field indicates the names of the parameters
 that are used in multithread. This only applies to "full" subsolvers.

 See cp_model_search.cc to see a list of the names and the default value (if
 left empty) that looks like:
 - default_lp           (linearization_level:1)
 - fixed                (only if fixed search specified or scheduling)
 - no_lp                (linearization_level:0)
 - max_lp               (linearization_level:2)
 - pseudo_costs         (only if objective, change search heuristic)
 - reduced_costs        (only if objective, change search heuristic)
 - quick_restart        (kind of probing)
 - quick_restart_no_lp  (kind of probing with linearization_level:0)
 - lb_tree_search       (to improve lower bound, MIP like tree search)
 - probing              (continuous probing and shaving)

 Also, note that some set of parameters will be ignored if they do not make
 sense. For instance if there is no objective, pseudo_cost or reduced_cost
 search will be ignored. Core based search will only work if the objective
 has many terms. If there is no fixed strategy fixed will be ignored. And so
 on.

 The order is important, as only the first num_full_subsolvers will be
 scheduled. You can see in the log which one are selected for a given run.
 </pre>

 <code>repeated string subsolvers = 207;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the element to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The subsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getSubsolversBytes-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolversBytes</h4>
<pre>com.google.protobuf.ByteString&nbsp;getSubsolversBytes(int&nbsp;index)</pre>
<div class="block"><pre>
 In multi-thread, the solver can be mainly seen as a portfolio of solvers
 with different parameters. This field indicates the names of the parameters
 that are used in multithread. This only applies to "full" subsolvers.

 See cp_model_search.cc to see a list of the names and the default value (if
 left empty) that looks like:
 - default_lp           (linearization_level:1)
 - fixed                (only if fixed search specified or scheduling)
 - no_lp                (linearization_level:0)
 - max_lp               (linearization_level:2)
 - pseudo_costs         (only if objective, change search heuristic)
 - reduced_costs        (only if objective, change search heuristic)
 - quick_restart        (kind of probing)
 - quick_restart_no_lp  (kind of probing with linearization_level:0)
 - lb_tree_search       (to improve lower bound, MIP like tree search)
 - probing              (continuous probing and shaving)

 Also, note that some set of parameters will be ignored if they do not make
 sense. For instance if there is no objective, pseudo_cost or reduced_cost
 search will be ignored. Core based search will only work if the objective
 has many terms. If there is no fixed strategy fixed will be ignored. And so
 on.

 The order is important, as only the first num_full_subsolvers will be
 scheduled. You can see in the log which one are selected for a given run.
 </pre>

 <code>repeated string subsolvers = 207;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the value to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bytes of the subsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getExtraSubsolversList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExtraSubsolversList</h4>
<pre>java.util.List&lt;java.lang.String&gt;&nbsp;getExtraSubsolversList()</pre>
<div class="block"><pre>
 A convenient way to add more workers types.
 These will be added at the beginning of the list.
 </pre>

 <code>repeated string extra_subsolvers = 219;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list containing the extraSubsolvers.</dd>
</dl>
</li>
</ul>
<a name="getExtraSubsolversCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExtraSubsolversCount</h4>
<pre>int&nbsp;getExtraSubsolversCount()</pre>
<div class="block"><pre>
 A convenient way to add more workers types.
 These will be added at the beginning of the list.
 </pre>

 <code>repeated string extra_subsolvers = 219;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The count of extraSubsolvers.</dd>
</dl>
</li>
</ul>
<a name="getExtraSubsolvers-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExtraSubsolvers</h4>
<pre>java.lang.String&nbsp;getExtraSubsolvers(int&nbsp;index)</pre>
<div class="block"><pre>
 A convenient way to add more workers types.
 These will be added at the beginning of the list.
 </pre>

 <code>repeated string extra_subsolvers = 219;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the element to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The extraSubsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getExtraSubsolversBytes-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExtraSubsolversBytes</h4>
<pre>com.google.protobuf.ByteString&nbsp;getExtraSubsolversBytes(int&nbsp;index)</pre>
<div class="block"><pre>
 A convenient way to add more workers types.
 These will be added at the beginning of the list.
 </pre>

 <code>repeated string extra_subsolvers = 219;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the value to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bytes of the extraSubsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getIgnoreSubsolversList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIgnoreSubsolversList</h4>
<pre>java.util.List&lt;java.lang.String&gt;&nbsp;getIgnoreSubsolversList()</pre>
<div class="block"><pre>
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing. Each string is interpreted as a "glob", so we
 support '*' and '?'.

 The way this work is that we will only accept a name that match a filter
 pattern (if non-empty) and do not match an ignore pattern. Note also that
 these fields work on LNS or LS names even if these are currently not
 specified via the subsolvers field.
 </pre>

 <code>repeated string ignore_subsolvers = 209;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list containing the ignoreSubsolvers.</dd>
</dl>
</li>
</ul>
<a name="getIgnoreSubsolversCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIgnoreSubsolversCount</h4>
<pre>int&nbsp;getIgnoreSubsolversCount()</pre>
<div class="block"><pre>
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing. Each string is interpreted as a "glob", so we
 support '*' and '?'.

 The way this work is that we will only accept a name that match a filter
 pattern (if non-empty) and do not match an ignore pattern. Note also that
 these fields work on LNS or LS names even if these are currently not
 specified via the subsolvers field.
 </pre>

 <code>repeated string ignore_subsolvers = 209;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The count of ignoreSubsolvers.</dd>
</dl>
</li>
</ul>
<a name="getIgnoreSubsolvers-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIgnoreSubsolvers</h4>
<pre>java.lang.String&nbsp;getIgnoreSubsolvers(int&nbsp;index)</pre>
<div class="block"><pre>
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing. Each string is interpreted as a "glob", so we
 support '*' and '?'.

 The way this work is that we will only accept a name that match a filter
 pattern (if non-empty) and do not match an ignore pattern. Note also that
 these fields work on LNS or LS names even if these are currently not
 specified via the subsolvers field.
 </pre>

 <code>repeated string ignore_subsolvers = 209;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the element to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The ignoreSubsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getIgnoreSubsolversBytes-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIgnoreSubsolversBytes</h4>
<pre>com.google.protobuf.ByteString&nbsp;getIgnoreSubsolversBytes(int&nbsp;index)</pre>
<div class="block"><pre>
 Rather than fully specifying subsolvers, it is often convenient to just
 remove the ones that are not useful on a given problem or only keep
 specific ones for testing. Each string is interpreted as a "glob", so we
 support '*' and '?'.

 The way this work is that we will only accept a name that match a filter
 pattern (if non-empty) and do not match an ignore pattern. Note also that
 these fields work on LNS or LS names even if these are currently not
 specified via the subsolvers field.
 </pre>

 <code>repeated string ignore_subsolvers = 209;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the value to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bytes of the ignoreSubsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getFilterSubsolversList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFilterSubsolversList</h4>
<pre>java.util.List&lt;java.lang.String&gt;&nbsp;getFilterSubsolversList()</pre>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list containing the filterSubsolvers.</dd>
</dl>
</li>
</ul>
<a name="getFilterSubsolversCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFilterSubsolversCount</h4>
<pre>int&nbsp;getFilterSubsolversCount()</pre>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The count of filterSubsolvers.</dd>
</dl>
</li>
</ul>
<a name="getFilterSubsolvers-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFilterSubsolvers</h4>
<pre>java.lang.String&nbsp;getFilterSubsolvers(int&nbsp;index)</pre>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the element to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The filterSubsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getFilterSubsolversBytes-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFilterSubsolversBytes</h4>
<pre>com.google.protobuf.ByteString&nbsp;getFilterSubsolversBytes(int&nbsp;index)</pre>
<div class="block"><code>repeated string filter_subsolvers = 293;</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the value to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bytes of the filterSubsolvers at the given index.</dd>
</dl>
</li>
</ul>
<a name="getSubsolverParamsList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolverParamsList</h4>
<pre>java.util.List&lt;<a href="../../../../com/google/ortools/sat/SatParameters.html" title="class in com.google.ortools.sat">SatParameters</a>&gt;&nbsp;getSubsolverParamsList()</pre>
<div class="block"><pre>
 It is possible to specify additional subsolver configuration. These can be
 referred by their params.name() in the fields above. Note that only the
 specified field will "overwrite" the ones of the base parameter. If a
 subsolver_params has the name of an existing subsolver configuration, the
 named parameters will be merged into the subsolver configuration.
 </pre>

 <code>repeated .operations_research.sat.SatParameters subsolver_params = 210;</code></div>
</li>
</ul>
<a name="getSubsolverParams-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolverParams</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.html" title="class in com.google.ortools.sat">SatParameters</a>&nbsp;getSubsolverParams(int&nbsp;index)</pre>
<div class="block"><pre>
 It is possible to specify additional subsolver configuration. These can be
 referred by their params.name() in the fields above. Note that only the
 specified field will "overwrite" the ones of the base parameter. If a
 subsolver_params has the name of an existing subsolver configuration, the
 named parameters will be merged into the subsolver configuration.
 </pre>

 <code>repeated .operations_research.sat.SatParameters subsolver_params = 210;</code></div>
</li>
</ul>
<a name="getSubsolverParamsCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolverParamsCount</h4>
<pre>int&nbsp;getSubsolverParamsCount()</pre>
<div class="block"><pre>
 It is possible to specify additional subsolver configuration. These can be
 referred by their params.name() in the fields above. Note that only the
 specified field will "overwrite" the ones of the base parameter. If a
 subsolver_params has the name of an existing subsolver configuration, the
 named parameters will be merged into the subsolver configuration.
 </pre>

 <code>repeated .operations_research.sat.SatParameters subsolver_params = 210;</code></div>
</li>
</ul>
<a name="getSubsolverParamsOrBuilderList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolverParamsOrBuilderList</h4>
<pre>java.util.List&lt;? extends <a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html" title="interface in com.google.ortools.sat">SatParametersOrBuilder</a>&gt;&nbsp;getSubsolverParamsOrBuilderList()</pre>
<div class="block"><pre>
 It is possible to specify additional subsolver configuration. These can be
 referred by their params.name() in the fields above. Note that only the
 specified field will "overwrite" the ones of the base parameter. If a
 subsolver_params has the name of an existing subsolver configuration, the
 named parameters will be merged into the subsolver configuration.
 </pre>

 <code>repeated .operations_research.sat.SatParameters subsolver_params = 210;</code></div>
</li>
</ul>
<a name="getSubsolverParamsOrBuilder-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubsolverParamsOrBuilder</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParametersOrBuilder.html" title="interface in com.google.ortools.sat">SatParametersOrBuilder</a>&nbsp;getSubsolverParamsOrBuilder(int&nbsp;index)</pre>
<div class="block"><pre>
 It is possible to specify additional subsolver configuration. These can be
 referred by their params.name() in the fields above. Note that only the
 specified field will "overwrite" the ones of the base parameter. If a
 subsolver_params has the name of an existing subsolver configuration, the
 named parameters will be merged into the subsolver configuration.
 </pre>

 <code>repeated .operations_research.sat.SatParameters subsolver_params = 210;</code></div>
</li>
</ul>
<a name="hasInterleaveSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInterleaveSearch</h4>
<pre>boolean&nbsp;hasInterleaveSearch()</pre>
<div class="block"><pre>
 Experimental. If this is true, then we interleave all our major search
 strategy and distribute the work amongst num_workers.

 The search is deterministic (independently of num_workers!), and we
 schedule and wait for interleave_batch_size task to be completed before
 synchronizing and scheduling the next batch of tasks.
 </pre>

 <code>optional bool interleave_search = 136 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the interleaveSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getInterleaveSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInterleaveSearch</h4>
<pre>boolean&nbsp;getInterleaveSearch()</pre>
<div class="block"><pre>
 Experimental. If this is true, then we interleave all our major search
 strategy and distribute the work amongst num_workers.

 The search is deterministic (independently of num_workers!), and we
 schedule and wait for interleave_batch_size task to be completed before
 synchronizing and scheduling the next batch of tasks.
 </pre>

 <code>optional bool interleave_search = 136 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The interleaveSearch.</dd>
</dl>
</li>
</ul>
<a name="hasInterleaveBatchSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInterleaveBatchSize</h4>
<pre>boolean&nbsp;hasInterleaveBatchSize()</pre>
<div class="block"><code>optional int32 interleave_batch_size = 134 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the interleaveBatchSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getInterleaveBatchSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInterleaveBatchSize</h4>
<pre>int&nbsp;getInterleaveBatchSize()</pre>
<div class="block"><code>optional int32 interleave_batch_size = 134 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The interleaveBatchSize.</dd>
</dl>
</li>
</ul>
<a name="hasShareObjectiveBounds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasShareObjectiveBounds</h4>
<pre>boolean&nbsp;hasShareObjectiveBounds()</pre>
<div class="block"><pre>
 Allows objective sharing between workers.
 </pre>

 <code>optional bool share_objective_bounds = 113 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the shareObjectiveBounds field is set.</dd>
</dl>
</li>
</ul>
<a name="getShareObjectiveBounds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getShareObjectiveBounds</h4>
<pre>boolean&nbsp;getShareObjectiveBounds()</pre>
<div class="block"><pre>
 Allows objective sharing between workers.
 </pre>

 <code>optional bool share_objective_bounds = 113 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The shareObjectiveBounds.</dd>
</dl>
</li>
</ul>
<a name="hasShareLevelZeroBounds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasShareLevelZeroBounds</h4>
<pre>boolean&nbsp;hasShareLevelZeroBounds()</pre>
<div class="block"><pre>
 Allows sharing of the bounds of modified variables at level 0.
 </pre>

 <code>optional bool share_level_zero_bounds = 114 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the shareLevelZeroBounds field is set.</dd>
</dl>
</li>
</ul>
<a name="getShareLevelZeroBounds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getShareLevelZeroBounds</h4>
<pre>boolean&nbsp;getShareLevelZeroBounds()</pre>
<div class="block"><pre>
 Allows sharing of the bounds of modified variables at level 0.
 </pre>

 <code>optional bool share_level_zero_bounds = 114 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The shareLevelZeroBounds.</dd>
</dl>
</li>
</ul>
<a name="hasShareBinaryClauses--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasShareBinaryClauses</h4>
<pre>boolean&nbsp;hasShareBinaryClauses()</pre>
<div class="block"><pre>
 Allows sharing of new learned binary clause between workers.
 </pre>

 <code>optional bool share_binary_clauses = 203 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the shareBinaryClauses field is set.</dd>
</dl>
</li>
</ul>
<a name="getShareBinaryClauses--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getShareBinaryClauses</h4>
<pre>boolean&nbsp;getShareBinaryClauses()</pre>
<div class="block"><pre>
 Allows sharing of new learned binary clause between workers.
 </pre>

 <code>optional bool share_binary_clauses = 203 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The shareBinaryClauses.</dd>
</dl>
</li>
</ul>
<a name="hasShareGlueClauses--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasShareGlueClauses</h4>
<pre>boolean&nbsp;hasShareGlueClauses()</pre>
<div class="block"><pre>
 Allows sharing of short glue clauses between workers.
 Implicitly disabled if share_binary_clauses is false.
 </pre>

 <code>optional bool share_glue_clauses = 285 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the shareGlueClauses field is set.</dd>
</dl>
</li>
</ul>
<a name="getShareGlueClauses--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getShareGlueClauses</h4>
<pre>boolean&nbsp;getShareGlueClauses()</pre>
<div class="block"><pre>
 Allows sharing of short glue clauses between workers.
 Implicitly disabled if share_binary_clauses is false.
 </pre>

 <code>optional bool share_glue_clauses = 285 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The shareGlueClauses.</dd>
</dl>
</li>
</ul>
<a name="hasMinimizeSharedClauses--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMinimizeSharedClauses</h4>
<pre>boolean&nbsp;hasMinimizeSharedClauses()</pre>
<div class="block"><pre>
 Minimize and detect subsumption of shared clauses immediately after they
 are imported.
 </pre>

 <code>optional bool minimize_shared_clauses = 300 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the minimizeSharedClauses field is set.</dd>
</dl>
</li>
</ul>
<a name="getMinimizeSharedClauses--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinimizeSharedClauses</h4>
<pre>boolean&nbsp;getMinimizeSharedClauses()</pre>
<div class="block"><pre>
 Minimize and detect subsumption of shared clauses immediately after they
 are imported.
 </pre>

 <code>optional bool minimize_shared_clauses = 300 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The minimizeSharedClauses.</dd>
</dl>
</li>
</ul>
<a name="hasDebugPostsolveWithFullSolver--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDebugPostsolveWithFullSolver</h4>
<pre>boolean&nbsp;hasDebugPostsolveWithFullSolver()</pre>
<div class="block"><pre>
 We have two different postsolve code. The default one should be better and
 it allows for a more powerful presolve, but it can be useful to postsolve
 using the full solver instead.
 </pre>

 <code>optional bool debug_postsolve_with_full_solver = 162 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the debugPostsolveWithFullSolver field is set.</dd>
</dl>
</li>
</ul>
<a name="getDebugPostsolveWithFullSolver--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDebugPostsolveWithFullSolver</h4>
<pre>boolean&nbsp;getDebugPostsolveWithFullSolver()</pre>
<div class="block"><pre>
 We have two different postsolve code. The default one should be better and
 it allows for a more powerful presolve, but it can be useful to postsolve
 using the full solver instead.
 </pre>

 <code>optional bool debug_postsolve_with_full_solver = 162 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The debugPostsolveWithFullSolver.</dd>
</dl>
</li>
</ul>
<a name="hasDebugMaxNumPresolveOperations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDebugMaxNumPresolveOperations</h4>
<pre>boolean&nbsp;hasDebugMaxNumPresolveOperations()</pre>
<div class="block"><pre>
 If positive, try to stop just after that many presolve rules have been
 applied. This is mainly useful for debugging presolve.
 </pre>

 <code>optional int32 debug_max_num_presolve_operations = 151 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the debugMaxNumPresolveOperations field is set.</dd>
</dl>
</li>
</ul>
<a name="getDebugMaxNumPresolveOperations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDebugMaxNumPresolveOperations</h4>
<pre>int&nbsp;getDebugMaxNumPresolveOperations()</pre>
<div class="block"><pre>
 If positive, try to stop just after that many presolve rules have been
 applied. This is mainly useful for debugging presolve.
 </pre>

 <code>optional int32 debug_max_num_presolve_operations = 151 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The debugMaxNumPresolveOperations.</dd>
</dl>
</li>
</ul>
<a name="hasDebugCrashOnBadHint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDebugCrashOnBadHint</h4>
<pre>boolean&nbsp;hasDebugCrashOnBadHint()</pre>
<div class="block"><pre>
 Crash if we do not manage to complete the hint into a full solution.
 </pre>

 <code>optional bool debug_crash_on_bad_hint = 195 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the debugCrashOnBadHint field is set.</dd>
</dl>
</li>
</ul>
<a name="getDebugCrashOnBadHint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDebugCrashOnBadHint</h4>
<pre>boolean&nbsp;getDebugCrashOnBadHint()</pre>
<div class="block"><pre>
 Crash if we do not manage to complete the hint into a full solution.
 </pre>

 <code>optional bool debug_crash_on_bad_hint = 195 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The debugCrashOnBadHint.</dd>
</dl>
</li>
</ul>
<a name="hasDebugCrashIfPresolveBreaksHint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDebugCrashIfPresolveBreaksHint</h4>
<pre>boolean&nbsp;hasDebugCrashIfPresolveBreaksHint()</pre>
<div class="block"><pre>
 Crash if presolve breaks a feasible hint.
 </pre>

 <code>optional bool debug_crash_if_presolve_breaks_hint = 306 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the debugCrashIfPresolveBreaksHint field is set.</dd>
</dl>
</li>
</ul>
<a name="getDebugCrashIfPresolveBreaksHint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDebugCrashIfPresolveBreaksHint</h4>
<pre>boolean&nbsp;getDebugCrashIfPresolveBreaksHint()</pre>
<div class="block"><pre>
 Crash if presolve breaks a feasible hint.
 </pre>

 <code>optional bool debug_crash_if_presolve_breaks_hint = 306 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The debugCrashIfPresolveBreaksHint.</dd>
</dl>
</li>
</ul>
<a name="hasUseOptimizationHints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseOptimizationHints</h4>
<pre>boolean&nbsp;hasUseOptimizationHints()</pre>
<div class="block"><pre>
 For an optimization problem, whether we follow some hints in order to find
 a better first solution. For a variable with hint, the solver will always
 try to follow the hint. It will revert to the variable_branching default
 otherwise.
 </pre>

 <code>optional bool use_optimization_hints = 35 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useOptimizationHints field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseOptimizationHints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseOptimizationHints</h4>
<pre>boolean&nbsp;getUseOptimizationHints()</pre>
<div class="block"><pre>
 For an optimization problem, whether we follow some hints in order to find
 a better first solution. For a variable with hint, the solver will always
 try to follow the hint. It will revert to the variable_branching default
 otherwise.
 </pre>

 <code>optional bool use_optimization_hints = 35 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useOptimizationHints.</dd>
</dl>
</li>
</ul>
<a name="hasCoreMinimizationLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCoreMinimizationLevel</h4>
<pre>boolean&nbsp;hasCoreMinimizationLevel()</pre>
<div class="block"><pre>
 If positive, we spend some effort on each core:
 - At level 1, we use a simple heuristic to try to minimize an UNSAT core.
 - At level 2, we use propagation to minimize the core but also identify
 literal in at most one relationship in this core.
 </pre>

 <code>optional int32 core_minimization_level = 50 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the coreMinimizationLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getCoreMinimizationLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCoreMinimizationLevel</h4>
<pre>int&nbsp;getCoreMinimizationLevel()</pre>
<div class="block"><pre>
 If positive, we spend some effort on each core:
 - At level 1, we use a simple heuristic to try to minimize an UNSAT core.
 - At level 2, we use propagation to minimize the core but also identify
 literal in at most one relationship in this core.
 </pre>

 <code>optional int32 core_minimization_level = 50 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The coreMinimizationLevel.</dd>
</dl>
</li>
</ul>
<a name="hasFindMultipleCores--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFindMultipleCores</h4>
<pre>boolean&nbsp;hasFindMultipleCores()</pre>
<div class="block"><pre>
 Whether we try to find more independent cores for a given set of
 assumptions in the core based max-SAT algorithms.
 </pre>

 <code>optional bool find_multiple_cores = 84 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the findMultipleCores field is set.</dd>
</dl>
</li>
</ul>
<a name="getFindMultipleCores--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFindMultipleCores</h4>
<pre>boolean&nbsp;getFindMultipleCores()</pre>
<div class="block"><pre>
 Whether we try to find more independent cores for a given set of
 assumptions in the core based max-SAT algorithms.
 </pre>

 <code>optional bool find_multiple_cores = 84 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The findMultipleCores.</dd>
</dl>
</li>
</ul>
<a name="hasCoverOptimization--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCoverOptimization</h4>
<pre>boolean&nbsp;hasCoverOptimization()</pre>
<div class="block"><pre>
 If true, when the max-sat algo find a core, we compute the minimal number
 of literals in the core that needs to be true to have a feasible solution.
 This is also called core exhaustion in more recent max-SAT papers.
 </pre>

 <code>optional bool cover_optimization = 89 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the coverOptimization field is set.</dd>
</dl>
</li>
</ul>
<a name="getCoverOptimization--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCoverOptimization</h4>
<pre>boolean&nbsp;getCoverOptimization()</pre>
<div class="block"><pre>
 If true, when the max-sat algo find a core, we compute the minimal number
 of literals in the core that needs to be true to have a feasible solution.
 This is also called core exhaustion in more recent max-SAT papers.
 </pre>

 <code>optional bool cover_optimization = 89 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The coverOptimization.</dd>
</dl>
</li>
</ul>
<a name="hasMaxSatAssumptionOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxSatAssumptionOrder</h4>
<pre>boolean&nbsp;hasMaxSatAssumptionOrder()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatAssumptionOrder max_sat_assumption_order = 51 [default = DEFAULT_ASSUMPTION_ORDER];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxSatAssumptionOrder field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxSatAssumptionOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxSatAssumptionOrder</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.MaxSatAssumptionOrder.html" title="enum in com.google.ortools.sat">SatParameters.MaxSatAssumptionOrder</a>&nbsp;getMaxSatAssumptionOrder()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatAssumptionOrder max_sat_assumption_order = 51 [default = DEFAULT_ASSUMPTION_ORDER];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxSatAssumptionOrder.</dd>
</dl>
</li>
</ul>
<a name="hasMaxSatReverseAssumptionOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxSatReverseAssumptionOrder</h4>
<pre>boolean&nbsp;hasMaxSatReverseAssumptionOrder()</pre>
<div class="block"><pre>
 If true, adds the assumption in the reverse order of the one defined by
 max_sat_assumption_order.
 </pre>

 <code>optional bool max_sat_reverse_assumption_order = 52 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxSatReverseAssumptionOrder field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxSatReverseAssumptionOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxSatReverseAssumptionOrder</h4>
<pre>boolean&nbsp;getMaxSatReverseAssumptionOrder()</pre>
<div class="block"><pre>
 If true, adds the assumption in the reverse order of the one defined by
 max_sat_assumption_order.
 </pre>

 <code>optional bool max_sat_reverse_assumption_order = 52 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxSatReverseAssumptionOrder.</dd>
</dl>
</li>
</ul>
<a name="hasMaxSatStratification--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxSatStratification</h4>
<pre>boolean&nbsp;hasMaxSatStratification()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatStratificationAlgorithm max_sat_stratification = 53 [default = STRATIFICATION_DESCENT];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxSatStratification field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxSatStratification--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxSatStratification</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.MaxSatStratificationAlgorithm.html" title="enum in com.google.ortools.sat">SatParameters.MaxSatStratificationAlgorithm</a>&nbsp;getMaxSatStratification()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.MaxSatStratificationAlgorithm max_sat_stratification = 53 [default = STRATIFICATION_DESCENT];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxSatStratification.</dd>
</dl>
</li>
</ul>
<a name="hasPropagationLoopDetectionFactor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPropagationLoopDetectionFactor</h4>
<pre>boolean&nbsp;hasPropagationLoopDetectionFactor()</pre>
<div class="block"><pre>
 Some search decisions might cause a really large number of propagations to
 happen when integer variables with large domains are only reduced by 1 at
 each step. If we propagate more than the number of variable times this
 parameters we try to take counter-measure. Setting this to 0.0 disable this
 feature.

 TODO(user): Setting this to something like 10 helps in most cases, but the
 code is currently buggy and can cause the solve to enter a bad state where
 no progress is made.
 </pre>

 <code>optional double propagation_loop_detection_factor = 221 [default = 10];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the propagationLoopDetectionFactor field is set.</dd>
</dl>
</li>
</ul>
<a name="getPropagationLoopDetectionFactor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPropagationLoopDetectionFactor</h4>
<pre>double&nbsp;getPropagationLoopDetectionFactor()</pre>
<div class="block"><pre>
 Some search decisions might cause a really large number of propagations to
 happen when integer variables with large domains are only reduced by 1 at
 each step. If we propagate more than the number of variable times this
 parameters we try to take counter-measure. Setting this to 0.0 disable this
 feature.

 TODO(user): Setting this to something like 10 helps in most cases, but the
 code is currently buggy and can cause the solve to enter a bad state where
 no progress is made.
 </pre>

 <code>optional double propagation_loop_detection_factor = 221 [default = 10];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The propagationLoopDetectionFactor.</dd>
</dl>
</li>
</ul>
<a name="hasUsePrecedencesInDisjunctiveConstraint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUsePrecedencesInDisjunctiveConstraint</h4>
<pre>boolean&nbsp;hasUsePrecedencesInDisjunctiveConstraint()</pre>
<div class="block"><pre>
 When this is true, then a disjunctive constraint will try to use the
 precedence relations between time intervals to propagate their bounds
 further. For instance if task A and B are both before C and task A and B
 are in disjunction, then we can deduce that task C must start after
 duration(A) + duration(B) instead of simply max(duration(A), duration(B)),
 provided that the start time for all task was currently zero.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_precedences_in_disjunctive_constraint = 74 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the usePrecedencesInDisjunctiveConstraint field is set.</dd>
</dl>
</li>
</ul>
<a name="getUsePrecedencesInDisjunctiveConstraint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUsePrecedencesInDisjunctiveConstraint</h4>
<pre>boolean&nbsp;getUsePrecedencesInDisjunctiveConstraint()</pre>
<div class="block"><pre>
 When this is true, then a disjunctive constraint will try to use the
 precedence relations between time intervals to propagate their bounds
 further. For instance if task A and B are both before C and task A and B
 are in disjunction, then we can deduce that task C must start after
 duration(A) + duration(B) instead of simply max(duration(A), duration(B)),
 provided that the start time for all task was currently zero.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_precedences_in_disjunctive_constraint = 74 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The usePrecedencesInDisjunctiveConstraint.</dd>
</dl>
</li>
</ul>
<a name="hasMaxSizeToCreatePrecedenceLiteralsInDisjunctive--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxSizeToCreatePrecedenceLiteralsInDisjunctive</h4>
<pre>boolean&nbsp;hasMaxSizeToCreatePrecedenceLiteralsInDisjunctive()</pre>
<div class="block"><pre>
 Create one literal for each disjunction of two pairs of tasks. This slows
 down the solve time, but improves the lower bound of the objective in the
 makespan case. This will be triggered if the number of intervals is less or
 equal than the parameter and if use_strong_propagation_in_disjunctive is
 true.
 </pre>

 <code>optional int32 max_size_to_create_precedence_literals_in_disjunctive = 229 [default = 60];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxSizeToCreatePrecedenceLiteralsInDisjunctive field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxSizeToCreatePrecedenceLiteralsInDisjunctive--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxSizeToCreatePrecedenceLiteralsInDisjunctive</h4>
<pre>int&nbsp;getMaxSizeToCreatePrecedenceLiteralsInDisjunctive()</pre>
<div class="block"><pre>
 Create one literal for each disjunction of two pairs of tasks. This slows
 down the solve time, but improves the lower bound of the objective in the
 makespan case. This will be triggered if the number of intervals is less or
 equal than the parameter and if use_strong_propagation_in_disjunctive is
 true.
 </pre>

 <code>optional int32 max_size_to_create_precedence_literals_in_disjunctive = 229 [default = 60];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxSizeToCreatePrecedenceLiteralsInDisjunctive.</dd>
</dl>
</li>
</ul>
<a name="hasUseStrongPropagationInDisjunctive--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseStrongPropagationInDisjunctive</h4>
<pre>boolean&nbsp;hasUseStrongPropagationInDisjunctive()</pre>
<div class="block"><pre>
 Enable stronger and more expensive propagation on no_overlap constraint.
 </pre>

 <code>optional bool use_strong_propagation_in_disjunctive = 230 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useStrongPropagationInDisjunctive field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseStrongPropagationInDisjunctive--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseStrongPropagationInDisjunctive</h4>
<pre>boolean&nbsp;getUseStrongPropagationInDisjunctive()</pre>
<div class="block"><pre>
 Enable stronger and more expensive propagation on no_overlap constraint.
 </pre>

 <code>optional bool use_strong_propagation_in_disjunctive = 230 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useStrongPropagationInDisjunctive.</dd>
</dl>
</li>
</ul>
<a name="hasUseDynamicPrecedenceInDisjunctive--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDynamicPrecedenceInDisjunctive</h4>
<pre>boolean&nbsp;hasUseDynamicPrecedenceInDisjunctive()</pre>
<div class="block"><pre>
 Whether we try to branch on decision "interval A before interval B" rather
 than on intervals bounds. This usually works better, but slow down a bit
 the time to find the first solution.

 These parameters are still EXPERIMENTAL, the result should be correct, but
 it some corner cases, they can cause some failing CHECK in the solver.
 </pre>

 <code>optional bool use_dynamic_precedence_in_disjunctive = 263 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDynamicPrecedenceInDisjunctive field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseDynamicPrecedenceInDisjunctive--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDynamicPrecedenceInDisjunctive</h4>
<pre>boolean&nbsp;getUseDynamicPrecedenceInDisjunctive()</pre>
<div class="block"><pre>
 Whether we try to branch on decision "interval A before interval B" rather
 than on intervals bounds. This usually works better, but slow down a bit
 the time to find the first solution.

 These parameters are still EXPERIMENTAL, the result should be correct, but
 it some corner cases, they can cause some failing CHECK in the solver.
 </pre>

 <code>optional bool use_dynamic_precedence_in_disjunctive = 263 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDynamicPrecedenceInDisjunctive.</dd>
</dl>
</li>
</ul>
<a name="hasUseDynamicPrecedenceInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDynamicPrecedenceInCumulative</h4>
<pre>boolean&nbsp;hasUseDynamicPrecedenceInCumulative()</pre>
<div class="block"><code>optional bool use_dynamic_precedence_in_cumulative = 268 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDynamicPrecedenceInCumulative field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseDynamicPrecedenceInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDynamicPrecedenceInCumulative</h4>
<pre>boolean&nbsp;getUseDynamicPrecedenceInCumulative()</pre>
<div class="block"><code>optional bool use_dynamic_precedence_in_cumulative = 268 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDynamicPrecedenceInCumulative.</dd>
</dl>
</li>
</ul>
<a name="hasUseOverloadCheckerInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseOverloadCheckerInCumulative</h4>
<pre>boolean&nbsp;hasUseOverloadCheckerInCumulative()</pre>
<div class="block"><pre>
 When this is true, the cumulative constraint is reinforced with overload
 checking, i.e., an additional level of reasoning based on energy. This
 additional level supplements the default level of reasoning as well as
 timetable edge finding.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_overload_checker_in_cumulative = 78 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useOverloadCheckerInCumulative field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseOverloadCheckerInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseOverloadCheckerInCumulative</h4>
<pre>boolean&nbsp;getUseOverloadCheckerInCumulative()</pre>
<div class="block"><pre>
 When this is true, the cumulative constraint is reinforced with overload
 checking, i.e., an additional level of reasoning based on energy. This
 additional level supplements the default level of reasoning as well as
 timetable edge finding.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_overload_checker_in_cumulative = 78 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useOverloadCheckerInCumulative.</dd>
</dl>
</li>
</ul>
<a name="hasUseConservativeScaleOverloadChecker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseConservativeScaleOverloadChecker</h4>
<pre>boolean&nbsp;hasUseConservativeScaleOverloadChecker()</pre>
<div class="block"><pre>
 Enable a heuristic to solve cumulative constraints using a modified energy
 constraint. We modify the usual energy definition by applying a
 super-additive function (also called "conservative scale" or "dual-feasible
 function") to the demand and the durations of the tasks.

 This heuristic is fast but for most problems it does not help much to find
 a solution.
 </pre>

 <code>optional bool use_conservative_scale_overload_checker = 286 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useConservativeScaleOverloadChecker field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseConservativeScaleOverloadChecker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseConservativeScaleOverloadChecker</h4>
<pre>boolean&nbsp;getUseConservativeScaleOverloadChecker()</pre>
<div class="block"><pre>
 Enable a heuristic to solve cumulative constraints using a modified energy
 constraint. We modify the usual energy definition by applying a
 super-additive function (also called "conservative scale" or "dual-feasible
 function") to the demand and the durations of the tasks.

 This heuristic is fast but for most problems it does not help much to find
 a solution.
 </pre>

 <code>optional bool use_conservative_scale_overload_checker = 286 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useConservativeScaleOverloadChecker.</dd>
</dl>
</li>
</ul>
<a name="hasUseTimetableEdgeFindingInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseTimetableEdgeFindingInCumulative</h4>
<pre>boolean&nbsp;hasUseTimetableEdgeFindingInCumulative()</pre>
<div class="block"><pre>
 When this is true, the cumulative constraint is reinforced with timetable
 edge finding, i.e., an additional level of reasoning based on the
 conjunction of energy and mandatory parts. This additional level
 supplements the default level of reasoning as well as overload_checker.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_timetable_edge_finding_in_cumulative = 79 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useTimetableEdgeFindingInCumulative field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseTimetableEdgeFindingInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseTimetableEdgeFindingInCumulative</h4>
<pre>boolean&nbsp;getUseTimetableEdgeFindingInCumulative()</pre>
<div class="block"><pre>
 When this is true, the cumulative constraint is reinforced with timetable
 edge finding, i.e., an additional level of reasoning based on the
 conjunction of energy and mandatory parts. This additional level
 supplements the default level of reasoning as well as overload_checker.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_timetable_edge_finding_in_cumulative = 79 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useTimetableEdgeFindingInCumulative.</dd>
</dl>
</li>
</ul>
<a name="hasMaxNumIntervalsForTimetableEdgeFinding--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumIntervalsForTimetableEdgeFinding</h4>
<pre>boolean&nbsp;hasMaxNumIntervalsForTimetableEdgeFinding()</pre>
<div class="block"><pre>
 Max number of intervals for the timetable_edge_finding algorithm to
 propagate. A value of 0 disables the constraint.
 </pre>

 <code>optional int32 max_num_intervals_for_timetable_edge_finding = 260 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumIntervalsForTimetableEdgeFinding field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxNumIntervalsForTimetableEdgeFinding--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumIntervalsForTimetableEdgeFinding</h4>
<pre>int&nbsp;getMaxNumIntervalsForTimetableEdgeFinding()</pre>
<div class="block"><pre>
 Max number of intervals for the timetable_edge_finding algorithm to
 propagate. A value of 0 disables the constraint.
 </pre>

 <code>optional int32 max_num_intervals_for_timetable_edge_finding = 260 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumIntervalsForTimetableEdgeFinding.</dd>
</dl>
</li>
</ul>
<a name="hasUseHardPrecedencesInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseHardPrecedencesInCumulative</h4>
<pre>boolean&nbsp;hasUseHardPrecedencesInCumulative()</pre>
<div class="block"><pre>
 If true, detect and create constraint for integer variable that are "after"
 a set of intervals in the same cumulative constraint.

 Experimental: by default we just use "direct" precedences. If
 exploit_all_precedences is true, we explore the full precedence graph. This
 assumes we have a DAG otherwise it fails.
 </pre>

 <code>optional bool use_hard_precedences_in_cumulative = 215 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useHardPrecedencesInCumulative field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseHardPrecedencesInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseHardPrecedencesInCumulative</h4>
<pre>boolean&nbsp;getUseHardPrecedencesInCumulative()</pre>
<div class="block"><pre>
 If true, detect and create constraint for integer variable that are "after"
 a set of intervals in the same cumulative constraint.

 Experimental: by default we just use "direct" precedences. If
 exploit_all_precedences is true, we explore the full precedence graph. This
 assumes we have a DAG otherwise it fails.
 </pre>

 <code>optional bool use_hard_precedences_in_cumulative = 215 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useHardPrecedencesInCumulative.</dd>
</dl>
</li>
</ul>
<a name="hasExploitAllPrecedences--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitAllPrecedences</h4>
<pre>boolean&nbsp;hasExploitAllPrecedences()</pre>
<div class="block"><code>optional bool exploit_all_precedences = 220 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitAllPrecedences field is set.</dd>
</dl>
</li>
</ul>
<a name="getExploitAllPrecedences--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitAllPrecedences</h4>
<pre>boolean&nbsp;getExploitAllPrecedences()</pre>
<div class="block"><code>optional bool exploit_all_precedences = 220 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitAllPrecedences.</dd>
</dl>
</li>
</ul>
<a name="hasUseDisjunctiveConstraintInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDisjunctiveConstraintInCumulative</h4>
<pre>boolean&nbsp;hasUseDisjunctiveConstraintInCumulative()</pre>
<div class="block"><pre>
 When this is true, the cumulative constraint is reinforced with propagators
 from the disjunctive constraint to improve the inference on a set of tasks
 that are disjunctive at the root of the problem. This additional level
 supplements the default level of reasoning.

 Propagators of the cumulative constraint will not be used at all if all the
 tasks are disjunctive at root node.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_disjunctive_constraint_in_cumulative = 80 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDisjunctiveConstraintInCumulative field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseDisjunctiveConstraintInCumulative--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDisjunctiveConstraintInCumulative</h4>
<pre>boolean&nbsp;getUseDisjunctiveConstraintInCumulative()</pre>
<div class="block"><pre>
 When this is true, the cumulative constraint is reinforced with propagators
 from the disjunctive constraint to improve the inference on a set of tasks
 that are disjunctive at the root of the problem. This additional level
 supplements the default level of reasoning.

 Propagators of the cumulative constraint will not be used at all if all the
 tasks are disjunctive at root node.

 This always result in better propagation, but it is usually slow, so
 depending on the problem, turning this off may lead to a faster solution.
 </pre>

 <code>optional bool use_disjunctive_constraint_in_cumulative = 80 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDisjunctiveConstraintInCumulative.</dd>
</dl>
</li>
</ul>
<a name="hasUseTimetablingInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseTimetablingInNoOverlap2D</h4>
<pre>boolean&nbsp;hasUseTimetablingInNoOverlap2D()</pre>
<div class="block"><pre>
 When this is true, the no_overlap_2d constraint is reinforced with
 propagators from the cumulative constraints. It consists of ignoring the
 position of rectangles in one position and projecting the no_overlap_2d on
 the other dimension to create a cumulative constraint. This is done on both
 axis. This additional level supplements the default level of reasoning.
 </pre>

 <code>optional bool use_timetabling_in_no_overlap_2d = 200 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useTimetablingInNoOverlap2d field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseTimetablingInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseTimetablingInNoOverlap2D</h4>
<pre>boolean&nbsp;getUseTimetablingInNoOverlap2D()</pre>
<div class="block"><pre>
 When this is true, the no_overlap_2d constraint is reinforced with
 propagators from the cumulative constraints. It consists of ignoring the
 position of rectangles in one position and projecting the no_overlap_2d on
 the other dimension to create a cumulative constraint. This is done on both
 axis. This additional level supplements the default level of reasoning.
 </pre>

 <code>optional bool use_timetabling_in_no_overlap_2d = 200 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useTimetablingInNoOverlap2d.</dd>
</dl>
</li>
</ul>
<a name="hasUseEnergeticReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseEnergeticReasoningInNoOverlap2D</h4>
<pre>boolean&nbsp;hasUseEnergeticReasoningInNoOverlap2D()</pre>
<div class="block"><pre>
 When this is true, the no_overlap_2d constraint is reinforced with
 energetic reasoning. This additional level supplements the default level of
 reasoning.
 </pre>

 <code>optional bool use_energetic_reasoning_in_no_overlap_2d = 213 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useEnergeticReasoningInNoOverlap2d field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseEnergeticReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseEnergeticReasoningInNoOverlap2D</h4>
<pre>boolean&nbsp;getUseEnergeticReasoningInNoOverlap2D()</pre>
<div class="block"><pre>
 When this is true, the no_overlap_2d constraint is reinforced with
 energetic reasoning. This additional level supplements the default level of
 reasoning.
 </pre>

 <code>optional bool use_energetic_reasoning_in_no_overlap_2d = 213 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useEnergeticReasoningInNoOverlap2d.</dd>
</dl>
</li>
</ul>
<a name="hasUseAreaEnergeticReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseAreaEnergeticReasoningInNoOverlap2D</h4>
<pre>boolean&nbsp;hasUseAreaEnergeticReasoningInNoOverlap2D()</pre>
<div class="block"><pre>
 When this is true, the no_overlap_2d constraint is reinforced with
 an energetic reasoning that uses an area-based energy. This can be combined
 with the two other overlap heuristics above.
 </pre>

 <code>optional bool use_area_energetic_reasoning_in_no_overlap_2d = 271 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useAreaEnergeticReasoningInNoOverlap2d field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseAreaEnergeticReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseAreaEnergeticReasoningInNoOverlap2D</h4>
<pre>boolean&nbsp;getUseAreaEnergeticReasoningInNoOverlap2D()</pre>
<div class="block"><pre>
 When this is true, the no_overlap_2d constraint is reinforced with
 an energetic reasoning that uses an area-based energy. This can be combined
 with the two other overlap heuristics above.
 </pre>

 <code>optional bool use_area_energetic_reasoning_in_no_overlap_2d = 271 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useAreaEnergeticReasoningInNoOverlap2d.</dd>
</dl>
</li>
</ul>
<a name="hasUseTryEdgeReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseTryEdgeReasoningInNoOverlap2D</h4>
<pre>boolean&nbsp;hasUseTryEdgeReasoningInNoOverlap2D()</pre>
<div class="block"><code>optional bool use_try_edge_reasoning_in_no_overlap_2d = 299 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useTryEdgeReasoningInNoOverlap2d field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseTryEdgeReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseTryEdgeReasoningInNoOverlap2D</h4>
<pre>boolean&nbsp;getUseTryEdgeReasoningInNoOverlap2D()</pre>
<div class="block"><code>optional bool use_try_edge_reasoning_in_no_overlap_2d = 299 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useTryEdgeReasoningInNoOverlap2d.</dd>
</dl>
</li>
</ul>
<a name="hasMaxPairsPairwiseReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxPairsPairwiseReasoningInNoOverlap2D</h4>
<pre>boolean&nbsp;hasMaxPairsPairwiseReasoningInNoOverlap2D()</pre>
<div class="block"><pre>
 If the number of pairs to look is below this threshold, do an extra step of
 propagation in the no_overlap_2d constraint by looking at all pairs of
 intervals.
 </pre>

 <code>optional int32 max_pairs_pairwise_reasoning_in_no_overlap_2d = 276 [default = 1250];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxPairsPairwiseReasoningInNoOverlap2d field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxPairsPairwiseReasoningInNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxPairsPairwiseReasoningInNoOverlap2D</h4>
<pre>int&nbsp;getMaxPairsPairwiseReasoningInNoOverlap2D()</pre>
<div class="block"><pre>
 If the number of pairs to look is below this threshold, do an extra step of
 propagation in the no_overlap_2d constraint by looking at all pairs of
 intervals.
 </pre>

 <code>optional int32 max_pairs_pairwise_reasoning_in_no_overlap_2d = 276 [default = 1250];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxPairsPairwiseReasoningInNoOverlap2d.</dd>
</dl>
</li>
</ul>
<a name="hasMaximumRegionsToSplitInDisconnectedNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaximumRegionsToSplitInDisconnectedNoOverlap2D</h4>
<pre>boolean&nbsp;hasMaximumRegionsToSplitInDisconnectedNoOverlap2D()</pre>
<div class="block"><pre>
 Detects when the space where items of a no_overlap_2d constraint can placed
 is disjoint (ie., fixed boxes split the domain). When it is the case, we
 can introduce a boolean for each pair &lt;item, component&gt; encoding whether
 the item is in the component or not. Then we replace the original
 no_overlap_2d constraint by one no_overlap_2d constraint for each
 component, with the new booleans as the enforcement_literal of the
 intervals. This is equivalent to expanding the original no_overlap_2d
 constraint into a bin packing problem with each connected component being a
 bin. This heuristic is only done when the number of regions to split
 is less than this parameter and &lt;= 1 disables it.
 </pre>

 <code>optional int32 maximum_regions_to_split_in_disconnected_no_overlap_2d = 315 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maximumRegionsToSplitInDisconnectedNoOverlap2d field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaximumRegionsToSplitInDisconnectedNoOverlap2D--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaximumRegionsToSplitInDisconnectedNoOverlap2D</h4>
<pre>int&nbsp;getMaximumRegionsToSplitInDisconnectedNoOverlap2D()</pre>
<div class="block"><pre>
 Detects when the space where items of a no_overlap_2d constraint can placed
 is disjoint (ie., fixed boxes split the domain). When it is the case, we
 can introduce a boolean for each pair &lt;item, component&gt; encoding whether
 the item is in the component or not. Then we replace the original
 no_overlap_2d constraint by one no_overlap_2d constraint for each
 component, with the new booleans as the enforcement_literal of the
 intervals. This is equivalent to expanding the original no_overlap_2d
 constraint into a bin packing problem with each connected component being a
 bin. This heuristic is only done when the number of regions to split
 is less than this parameter and &lt;= 1 disables it.
 </pre>

 <code>optional int32 maximum_regions_to_split_in_disconnected_no_overlap_2d = 315 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maximumRegionsToSplitInDisconnectedNoOverlap2d.</dd>
</dl>
</li>
</ul>
<a name="hasUseDualSchedulingHeuristics--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDualSchedulingHeuristics</h4>
<pre>boolean&nbsp;hasUseDualSchedulingHeuristics()</pre>
<div class="block"><pre>
 When set, it activates a few scheduling parameters to improve the lower
 bound of scheduling problems. This is only effective with multiple workers
 as it modifies the reduced_cost, lb_tree_search, and probing workers.
 </pre>

 <code>optional bool use_dual_scheduling_heuristics = 214 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDualSchedulingHeuristics field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseDualSchedulingHeuristics--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDualSchedulingHeuristics</h4>
<pre>boolean&nbsp;getUseDualSchedulingHeuristics()</pre>
<div class="block"><pre>
 When set, it activates a few scheduling parameters to improve the lower
 bound of scheduling problems. This is only effective with multiple workers
 as it modifies the reduced_cost, lb_tree_search, and probing workers.
 </pre>

 <code>optional bool use_dual_scheduling_heuristics = 214 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDualSchedulingHeuristics.</dd>
</dl>
</li>
</ul>
<a name="hasUseAllDifferentForCircuit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseAllDifferentForCircuit</h4>
<pre>boolean&nbsp;hasUseAllDifferentForCircuit()</pre>
<div class="block"><pre>
 Turn on extra propagation for the circuit constraint.
 This can be quite slow.
 </pre>

 <code>optional bool use_all_different_for_circuit = 311 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useAllDifferentForCircuit field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseAllDifferentForCircuit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseAllDifferentForCircuit</h4>
<pre>boolean&nbsp;getUseAllDifferentForCircuit()</pre>
<div class="block"><pre>
 Turn on extra propagation for the circuit constraint.
 This can be quite slow.
 </pre>

 <code>optional bool use_all_different_for_circuit = 311 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useAllDifferentForCircuit.</dd>
</dl>
</li>
</ul>
<a name="hasRoutingCutSubsetSizeForBinaryRelationBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRoutingCutSubsetSizeForBinaryRelationBound</h4>
<pre>boolean&nbsp;hasRoutingCutSubsetSizeForBinaryRelationBound()</pre>
<div class="block"><pre>
 If the size of a subset of nodes of a RoutesConstraint is less than this
 value, use linear constraints of size 1 and 2 (such as capacity and time
 window constraints) enforced by the arc literals to compute cuts for this
 subset (unless the subset size is less than
 routing_cut_subset_size_for_tight_binary_relation_bound, in which case the
 corresponding algorithm is used instead). The algorithm for these cuts has
 a O(n^3) complexity, where n is the subset size. Hence the value of this
 parameter should not be too large (e.g. 10 or 20).
 </pre>

 <code>optional int32 routing_cut_subset_size_for_binary_relation_bound = 312 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the routingCutSubsetSizeForBinaryRelationBound field is set.</dd>
</dl>
</li>
</ul>
<a name="getRoutingCutSubsetSizeForBinaryRelationBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRoutingCutSubsetSizeForBinaryRelationBound</h4>
<pre>int&nbsp;getRoutingCutSubsetSizeForBinaryRelationBound()</pre>
<div class="block"><pre>
 If the size of a subset of nodes of a RoutesConstraint is less than this
 value, use linear constraints of size 1 and 2 (such as capacity and time
 window constraints) enforced by the arc literals to compute cuts for this
 subset (unless the subset size is less than
 routing_cut_subset_size_for_tight_binary_relation_bound, in which case the
 corresponding algorithm is used instead). The algorithm for these cuts has
 a O(n^3) complexity, where n is the subset size. Hence the value of this
 parameter should not be too large (e.g. 10 or 20).
 </pre>

 <code>optional int32 routing_cut_subset_size_for_binary_relation_bound = 312 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The routingCutSubsetSizeForBinaryRelationBound.</dd>
</dl>
</li>
</ul>
<a name="hasRoutingCutSubsetSizeForTightBinaryRelationBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRoutingCutSubsetSizeForTightBinaryRelationBound</h4>
<pre>boolean&nbsp;hasRoutingCutSubsetSizeForTightBinaryRelationBound()</pre>
<div class="block"><pre>
 Similar to above, but with a different algorithm producing better cuts, at
 the price of a higher O(2^n) complexity, where n is the subset size. Hence
 the value of this parameter should be small (e.g. less than 10).
 </pre>

 <code>optional int32 routing_cut_subset_size_for_tight_binary_relation_bound = 313 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the routingCutSubsetSizeForTightBinaryRelationBound field is set.</dd>
</dl>
</li>
</ul>
<a name="getRoutingCutSubsetSizeForTightBinaryRelationBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRoutingCutSubsetSizeForTightBinaryRelationBound</h4>
<pre>int&nbsp;getRoutingCutSubsetSizeForTightBinaryRelationBound()</pre>
<div class="block"><pre>
 Similar to above, but with a different algorithm producing better cuts, at
 the price of a higher O(2^n) complexity, where n is the subset size. Hence
 the value of this parameter should be small (e.g. less than 10).
 </pre>

 <code>optional int32 routing_cut_subset_size_for_tight_binary_relation_bound = 313 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The routingCutSubsetSizeForTightBinaryRelationBound.</dd>
</dl>
</li>
</ul>
<a name="hasRoutingCutDpEffort--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRoutingCutDpEffort</h4>
<pre>boolean&nbsp;hasRoutingCutDpEffort()</pre>
<div class="block"><pre>
 The amount of "effort" to spend in dynamic programming for computing
 routing cuts. This is in term of basic operations needed by the algorithm
 in the worst case, so a value like 1e8 should take less than a second to
 compute.
 </pre>

 <code>optional double routing_cut_dp_effort = 314 [default = 10000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the routingCutDpEffort field is set.</dd>
</dl>
</li>
</ul>
<a name="getRoutingCutDpEffort--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRoutingCutDpEffort</h4>
<pre>double&nbsp;getRoutingCutDpEffort()</pre>
<div class="block"><pre>
 The amount of "effort" to spend in dynamic programming for computing
 routing cuts. This is in term of basic operations needed by the algorithm
 in the worst case, so a value like 1e8 should take less than a second to
 compute.
 </pre>

 <code>optional double routing_cut_dp_effort = 314 [default = 10000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The routingCutDpEffort.</dd>
</dl>
</li>
</ul>
<a name="hasSearchBranching--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSearchBranching</h4>
<pre>boolean&nbsp;hasSearchBranching()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.SearchBranching search_branching = 82 [default = AUTOMATIC_SEARCH];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the searchBranching field is set.</dd>
</dl>
</li>
</ul>
<a name="getSearchBranching--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSearchBranching</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.SearchBranching.html" title="enum in com.google.ortools.sat">SatParameters.SearchBranching</a>&nbsp;getSearchBranching()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.SearchBranching search_branching = 82 [default = AUTOMATIC_SEARCH];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The searchBranching.</dd>
</dl>
</li>
</ul>
<a name="hasHintConflictLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasHintConflictLimit</h4>
<pre>boolean&nbsp;hasHintConflictLimit()</pre>
<div class="block"><pre>
 Conflict limit used in the phase that exploit the solution hint.
 </pre>

 <code>optional int32 hint_conflict_limit = 153 [default = 10];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the hintConflictLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getHintConflictLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHintConflictLimit</h4>
<pre>int&nbsp;getHintConflictLimit()</pre>
<div class="block"><pre>
 Conflict limit used in the phase that exploit the solution hint.
 </pre>

 <code>optional int32 hint_conflict_limit = 153 [default = 10];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The hintConflictLimit.</dd>
</dl>
</li>
</ul>
<a name="hasRepairHint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRepairHint</h4>
<pre>boolean&nbsp;hasRepairHint()</pre>
<div class="block"><pre>
 If true, the solver tries to repair the solution given in the hint. This
 search terminates after the 'hint_conflict_limit' is reached and the solver
 switches to regular search. If false, then  we do a FIXED_SEARCH using the
 hint until the hint_conflict_limit is reached.
 </pre>

 <code>optional bool repair_hint = 167 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the repairHint field is set.</dd>
</dl>
</li>
</ul>
<a name="getRepairHint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRepairHint</h4>
<pre>boolean&nbsp;getRepairHint()</pre>
<div class="block"><pre>
 If true, the solver tries to repair the solution given in the hint. This
 search terminates after the 'hint_conflict_limit' is reached and the solver
 switches to regular search. If false, then  we do a FIXED_SEARCH using the
 hint until the hint_conflict_limit is reached.
 </pre>

 <code>optional bool repair_hint = 167 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The repairHint.</dd>
</dl>
</li>
</ul>
<a name="hasFixVariablesToTheirHintedValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFixVariablesToTheirHintedValue</h4>
<pre>boolean&nbsp;hasFixVariablesToTheirHintedValue()</pre>
<div class="block"><pre>
 If true, variables appearing in the solution hints will be fixed to their
 hinted value.
 </pre>

 <code>optional bool fix_variables_to_their_hinted_value = 192 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the fixVariablesToTheirHintedValue field is set.</dd>
</dl>
</li>
</ul>
<a name="getFixVariablesToTheirHintedValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFixVariablesToTheirHintedValue</h4>
<pre>boolean&nbsp;getFixVariablesToTheirHintedValue()</pre>
<div class="block"><pre>
 If true, variables appearing in the solution hints will be fixed to their
 hinted value.
 </pre>

 <code>optional bool fix_variables_to_their_hinted_value = 192 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The fixVariablesToTheirHintedValue.</dd>
</dl>
</li>
</ul>
<a name="hasUseProbingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseProbingSearch</h4>
<pre>boolean&nbsp;hasUseProbingSearch()</pre>
<div class="block"><pre>
 If true, search will continuously probe Boolean variables, and integer
 variable bounds. This parameter is set to true in parallel on the probing
 worker.
 </pre>

 <code>optional bool use_probing_search = 176 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useProbingSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseProbingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseProbingSearch</h4>
<pre>boolean&nbsp;getUseProbingSearch()</pre>
<div class="block"><pre>
 If true, search will continuously probe Boolean variables, and integer
 variable bounds. This parameter is set to true in parallel on the probing
 worker.
 </pre>

 <code>optional bool use_probing_search = 176 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useProbingSearch.</dd>
</dl>
</li>
</ul>
<a name="hasUseExtendedProbing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseExtendedProbing</h4>
<pre>boolean&nbsp;hasUseExtendedProbing()</pre>
<div class="block"><pre>
 Use extended probing (probe bool_or, at_most_one, exactly_one).
 </pre>

 <code>optional bool use_extended_probing = 269 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useExtendedProbing field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseExtendedProbing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseExtendedProbing</h4>
<pre>boolean&nbsp;getUseExtendedProbing()</pre>
<div class="block"><pre>
 Use extended probing (probe bool_or, at_most_one, exactly_one).
 </pre>

 <code>optional bool use_extended_probing = 269 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useExtendedProbing.</dd>
</dl>
</li>
</ul>
<a name="hasProbingNumCombinationsLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasProbingNumCombinationsLimit</h4>
<pre>boolean&nbsp;hasProbingNumCombinationsLimit()</pre>
<div class="block"><pre>
 How many combinations of pairs or triplets of variables we want to scan.
 </pre>

 <code>optional int32 probing_num_combinations_limit = 272 [default = 20000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the probingNumCombinationsLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getProbingNumCombinationsLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProbingNumCombinationsLimit</h4>
<pre>int&nbsp;getProbingNumCombinationsLimit()</pre>
<div class="block"><pre>
 How many combinations of pairs or triplets of variables we want to scan.
 </pre>

 <code>optional int32 probing_num_combinations_limit = 272 [default = 20000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The probingNumCombinationsLimit.</dd>
</dl>
</li>
</ul>
<a name="hasUseShavingInProbingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseShavingInProbingSearch</h4>
<pre>boolean&nbsp;hasUseShavingInProbingSearch()</pre>
<div class="block"><pre>
 Add a shaving phase (where the solver tries to prove that the lower or
 upper bound of a variable are infeasible) to the probing search.
 </pre>

 <code>optional bool use_shaving_in_probing_search = 204 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useShavingInProbingSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseShavingInProbingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseShavingInProbingSearch</h4>
<pre>boolean&nbsp;getUseShavingInProbingSearch()</pre>
<div class="block"><pre>
 Add a shaving phase (where the solver tries to prove that the lower or
 upper bound of a variable are infeasible) to the probing search.
 </pre>

 <code>optional bool use_shaving_in_probing_search = 204 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useShavingInProbingSearch.</dd>
</dl>
</li>
</ul>
<a name="hasShavingSearchDeterministicTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasShavingSearchDeterministicTime</h4>
<pre>boolean&nbsp;hasShavingSearchDeterministicTime()</pre>
<div class="block"><pre>
 Specifies the amount of deterministic time spent of each try at shaving a
 bound in the shaving search.
 </pre>

 <code>optional double shaving_search_deterministic_time = 205 [default = 0.001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the shavingSearchDeterministicTime field is set.</dd>
</dl>
</li>
</ul>
<a name="getShavingSearchDeterministicTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getShavingSearchDeterministicTime</h4>
<pre>double&nbsp;getShavingSearchDeterministicTime()</pre>
<div class="block"><pre>
 Specifies the amount of deterministic time spent of each try at shaving a
 bound in the shaving search.
 </pre>

 <code>optional double shaving_search_deterministic_time = 205 [default = 0.001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The shavingSearchDeterministicTime.</dd>
</dl>
</li>
</ul>
<a name="hasShavingSearchThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasShavingSearchThreshold</h4>
<pre>boolean&nbsp;hasShavingSearchThreshold()</pre>
<div class="block"><pre>
 Specifies the threshold between two modes in the shaving procedure.
 If the range of the variable/objective is less than this threshold, then
 the shaving procedure will try to remove values one by one. Otherwise, it
 will try to remove one range at a time.
 </pre>

 <code>optional int64 shaving_search_threshold = 290 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the shavingSearchThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getShavingSearchThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getShavingSearchThreshold</h4>
<pre>long&nbsp;getShavingSearchThreshold()</pre>
<div class="block"><pre>
 Specifies the threshold between two modes in the shaving procedure.
 If the range of the variable/objective is less than this threshold, then
 the shaving procedure will try to remove values one by one. Otherwise, it
 will try to remove one range at a time.
 </pre>

 <code>optional int64 shaving_search_threshold = 290 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The shavingSearchThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasUseObjectiveLbSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseObjectiveLbSearch</h4>
<pre>boolean&nbsp;hasUseObjectiveLbSearch()</pre>
<div class="block"><pre>
 If true, search will search in ascending max objective value (when
 minimizing) starting from the lower bound of the objective.
 </pre>

 <code>optional bool use_objective_lb_search = 228 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useObjectiveLbSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseObjectiveLbSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseObjectiveLbSearch</h4>
<pre>boolean&nbsp;getUseObjectiveLbSearch()</pre>
<div class="block"><pre>
 If true, search will search in ascending max objective value (when
 minimizing) starting from the lower bound of the objective.
 </pre>

 <code>optional bool use_objective_lb_search = 228 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useObjectiveLbSearch.</dd>
</dl>
</li>
</ul>
<a name="hasUseObjectiveShavingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseObjectiveShavingSearch</h4>
<pre>boolean&nbsp;hasUseObjectiveShavingSearch()</pre>
<div class="block"><pre>
 This search differs from the previous search as it will not use assumptions
 to bound the objective, and it will recreate a full model with the
 hardcoded objective value.
 </pre>

 <code>optional bool use_objective_shaving_search = 253 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useObjectiveShavingSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseObjectiveShavingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseObjectiveShavingSearch</h4>
<pre>boolean&nbsp;getUseObjectiveShavingSearch()</pre>
<div class="block"><pre>
 This search differs from the previous search as it will not use assumptions
 to bound the objective, and it will recreate a full model with the
 hardcoded objective value.
 </pre>

 <code>optional bool use_objective_shaving_search = 253 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useObjectiveShavingSearch.</dd>
</dl>
</li>
</ul>
<a name="hasUseVariablesShavingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseVariablesShavingSearch</h4>
<pre>boolean&nbsp;hasUseVariablesShavingSearch()</pre>
<div class="block"><pre>
 This search takes all Boolean or integer variables, and maximize or
 minimize them in order to reduce their domain.
 </pre>

 <code>optional bool use_variables_shaving_search = 289 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useVariablesShavingSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseVariablesShavingSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseVariablesShavingSearch</h4>
<pre>boolean&nbsp;getUseVariablesShavingSearch()</pre>
<div class="block"><pre>
 This search takes all Boolean or integer variables, and maximize or
 minimize them in order to reduce their domain.
 </pre>

 <code>optional bool use_variables_shaving_search = 289 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useVariablesShavingSearch.</dd>
</dl>
</li>
</ul>
<a name="hasPseudoCostReliabilityThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPseudoCostReliabilityThreshold</h4>
<pre>boolean&nbsp;hasPseudoCostReliabilityThreshold()</pre>
<div class="block"><pre>
 The solver ignores the pseudo costs of variables with number of recordings
 less than this threshold.
 </pre>

 <code>optional int64 pseudo_cost_reliability_threshold = 123 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the pseudoCostReliabilityThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getPseudoCostReliabilityThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPseudoCostReliabilityThreshold</h4>
<pre>long&nbsp;getPseudoCostReliabilityThreshold()</pre>
<div class="block"><pre>
 The solver ignores the pseudo costs of variables with number of recordings
 less than this threshold.
 </pre>

 <code>optional int64 pseudo_cost_reliability_threshold = 123 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The pseudoCostReliabilityThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasOptimizeWithCore--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasOptimizeWithCore</h4>
<pre>boolean&nbsp;hasOptimizeWithCore()</pre>
<div class="block"><pre>
 The default optimization method is a simple "linear scan", each time trying
 to find a better solution than the previous one. If this is true, then we
 use a core-based approach (like in max-SAT) when we try to increase the
 lower bound instead.
 </pre>

 <code>optional bool optimize_with_core = 83 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the optimizeWithCore field is set.</dd>
</dl>
</li>
</ul>
<a name="getOptimizeWithCore--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimizeWithCore</h4>
<pre>boolean&nbsp;getOptimizeWithCore()</pre>
<div class="block"><pre>
 The default optimization method is a simple "linear scan", each time trying
 to find a better solution than the previous one. If this is true, then we
 use a core-based approach (like in max-SAT) when we try to increase the
 lower bound instead.
 </pre>

 <code>optional bool optimize_with_core = 83 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The optimizeWithCore.</dd>
</dl>
</li>
</ul>
<a name="hasOptimizeWithLbTreeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasOptimizeWithLbTreeSearch</h4>
<pre>boolean&nbsp;hasOptimizeWithLbTreeSearch()</pre>
<div class="block"><pre>
 Do a more conventional tree search (by opposition to SAT based one) where
 we keep all the explored node in a tree. This is meant to be used in a
 portfolio and focus on improving the objective lower bound. Keeping the
 whole tree allow us to report a better objective lower bound coming from
 the worst open node in the tree.
 </pre>

 <code>optional bool optimize_with_lb_tree_search = 188 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the optimizeWithLbTreeSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getOptimizeWithLbTreeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimizeWithLbTreeSearch</h4>
<pre>boolean&nbsp;getOptimizeWithLbTreeSearch()</pre>
<div class="block"><pre>
 Do a more conventional tree search (by opposition to SAT based one) where
 we keep all the explored node in a tree. This is meant to be used in a
 portfolio and focus on improving the objective lower bound. Keeping the
 whole tree allow us to report a better objective lower bound coming from
 the worst open node in the tree.
 </pre>

 <code>optional bool optimize_with_lb_tree_search = 188 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The optimizeWithLbTreeSearch.</dd>
</dl>
</li>
</ul>
<a name="hasSaveLpBasisInLbTreeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSaveLpBasisInLbTreeSearch</h4>
<pre>boolean&nbsp;hasSaveLpBasisInLbTreeSearch()</pre>
<div class="block"><pre>
 Experimental. Save the current LP basis at each node of the search tree so
 that when we jump around, we can load it and reduce the number of LP
 iterations needed.

 It currently works okay if we do not change the lp with cuts or
 simplification... More work is needed to make it robust in all cases.
 </pre>

 <code>optional bool save_lp_basis_in_lb_tree_search = 284 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the saveLpBasisInLbTreeSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getSaveLpBasisInLbTreeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSaveLpBasisInLbTreeSearch</h4>
<pre>boolean&nbsp;getSaveLpBasisInLbTreeSearch()</pre>
<div class="block"><pre>
 Experimental. Save the current LP basis at each node of the search tree so
 that when we jump around, we can load it and reduce the number of LP
 iterations needed.

 It currently works okay if we do not change the lp with cuts or
 simplification... More work is needed to make it robust in all cases.
 </pre>

 <code>optional bool save_lp_basis_in_lb_tree_search = 284 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The saveLpBasisInLbTreeSearch.</dd>
</dl>
</li>
</ul>
<a name="hasBinarySearchNumConflicts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasBinarySearchNumConflicts</h4>
<pre>boolean&nbsp;hasBinarySearchNumConflicts()</pre>
<div class="block"><pre>
 If non-negative, perform a binary search on the objective variable in order
 to find an [min, max] interval outside of which the solver proved unsat/sat
 under this amount of conflict. This can quickly reduce the objective domain
 on some problems.
 </pre>

 <code>optional int32 binary_search_num_conflicts = 99 [default = -1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the binarySearchNumConflicts field is set.</dd>
</dl>
</li>
</ul>
<a name="getBinarySearchNumConflicts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBinarySearchNumConflicts</h4>
<pre>int&nbsp;getBinarySearchNumConflicts()</pre>
<div class="block"><pre>
 If non-negative, perform a binary search on the objective variable in order
 to find an [min, max] interval outside of which the solver proved unsat/sat
 under this amount of conflict. This can quickly reduce the objective domain
 on some problems.
 </pre>

 <code>optional int32 binary_search_num_conflicts = 99 [default = -1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The binarySearchNumConflicts.</dd>
</dl>
</li>
</ul>
<a name="hasOptimizeWithMaxHs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasOptimizeWithMaxHs</h4>
<pre>boolean&nbsp;hasOptimizeWithMaxHs()</pre>
<div class="block"><pre>
 This has no effect if optimize_with_core is false. If true, use a different
 core-based algorithm similar to the max-HS algo for max-SAT. This is a
 hybrid MIP/CP approach and it uses a MIP solver in addition to the CP/SAT
 one. This is also related to the PhD work of tobyodavies&#64;
 "Automatic Logic-Based Benders Decomposition with MiniZinc"
 http://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14489
 </pre>

 <code>optional bool optimize_with_max_hs = 85 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the optimizeWithMaxHs field is set.</dd>
</dl>
</li>
</ul>
<a name="getOptimizeWithMaxHs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimizeWithMaxHs</h4>
<pre>boolean&nbsp;getOptimizeWithMaxHs()</pre>
<div class="block"><pre>
 This has no effect if optimize_with_core is false. If true, use a different
 core-based algorithm similar to the max-HS algo for max-SAT. This is a
 hybrid MIP/CP approach and it uses a MIP solver in addition to the CP/SAT
 one. This is also related to the PhD work of tobyodavies&#64;
 "Automatic Logic-Based Benders Decomposition with MiniZinc"
 http://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14489
 </pre>

 <code>optional bool optimize_with_max_hs = 85 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The optimizeWithMaxHs.</dd>
</dl>
</li>
</ul>
<a name="hasUseFeasibilityJump--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseFeasibilityJump</h4>
<pre>boolean&nbsp;hasUseFeasibilityJump()</pre>
<div class="block"><pre>
 Parameters for an heuristic similar to the one described in the paper:
 "Feasibility Jump: an LP-free Lagrangian MIP heuristic", Bjrnar
 Luteberget, Giorgio Sartor, 2023, Mathematical Programming Computation.
 </pre>

 <code>optional bool use_feasibility_jump = 265 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useFeasibilityJump field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseFeasibilityJump--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseFeasibilityJump</h4>
<pre>boolean&nbsp;getUseFeasibilityJump()</pre>
<div class="block"><pre>
 Parameters for an heuristic similar to the one described in the paper:
 "Feasibility Jump: an LP-free Lagrangian MIP heuristic", Bjrnar
 Luteberget, Giorgio Sartor, 2023, Mathematical Programming Computation.
 </pre>

 <code>optional bool use_feasibility_jump = 265 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useFeasibilityJump.</dd>
</dl>
</li>
</ul>
<a name="hasUseLsOnly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseLsOnly</h4>
<pre>boolean&nbsp;hasUseLsOnly()</pre>
<div class="block"><pre>
 Disable every other type of subsolver, setting this turns CP-SAT into a
 pure local-search solver.
 </pre>

 <code>optional bool use_ls_only = 240 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useLsOnly field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseLsOnly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseLsOnly</h4>
<pre>boolean&nbsp;getUseLsOnly()</pre>
<div class="block"><pre>
 Disable every other type of subsolver, setting this turns CP-SAT into a
 pure local-search solver.
 </pre>

 <code>optional bool use_ls_only = 240 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useLsOnly.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpDecay</h4>
<pre>boolean&nbsp;hasFeasibilityJumpDecay()</pre>
<div class="block"><pre>
 On each restart, we randomly choose if we use decay (with this parameter)
 or no decay.
 </pre>

 <code>optional double feasibility_jump_decay = 242 [default = 0.95];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpDecay field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpDecay</h4>
<pre>double&nbsp;getFeasibilityJumpDecay()</pre>
<div class="block"><pre>
 On each restart, we randomly choose if we use decay (with this parameter)
 or no decay.
 </pre>

 <code>optional double feasibility_jump_decay = 242 [default = 0.95];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpDecay.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpLinearizationLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpLinearizationLevel</h4>
<pre>boolean&nbsp;hasFeasibilityJumpLinearizationLevel()</pre>
<div class="block"><pre>
 How much do we linearize the problem in the local search code.
 </pre>

 <code>optional int32 feasibility_jump_linearization_level = 257 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpLinearizationLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpLinearizationLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpLinearizationLevel</h4>
<pre>int&nbsp;getFeasibilityJumpLinearizationLevel()</pre>
<div class="block"><pre>
 How much do we linearize the problem in the local search code.
 </pre>

 <code>optional int32 feasibility_jump_linearization_level = 257 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpLinearizationLevel.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpRestartFactor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpRestartFactor</h4>
<pre>boolean&nbsp;hasFeasibilityJumpRestartFactor()</pre>
<div class="block"><pre>
 This is a factor that directly influence the work before each restart.
 Increasing it leads to longer restart.
 </pre>

 <code>optional int32 feasibility_jump_restart_factor = 258 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpRestartFactor field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpRestartFactor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpRestartFactor</h4>
<pre>int&nbsp;getFeasibilityJumpRestartFactor()</pre>
<div class="block"><pre>
 This is a factor that directly influence the work before each restart.
 Increasing it leads to longer restart.
 </pre>

 <code>optional int32 feasibility_jump_restart_factor = 258 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpRestartFactor.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpBatchDtime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpBatchDtime</h4>
<pre>boolean&nbsp;hasFeasibilityJumpBatchDtime()</pre>
<div class="block"><pre>
 How much dtime for each LS batch.
 </pre>

 <code>optional double feasibility_jump_batch_dtime = 292 [default = 0.1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpBatchDtime field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpBatchDtime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpBatchDtime</h4>
<pre>double&nbsp;getFeasibilityJumpBatchDtime()</pre>
<div class="block"><pre>
 How much dtime for each LS batch.
 </pre>

 <code>optional double feasibility_jump_batch_dtime = 292 [default = 0.1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpBatchDtime.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpVarRandomizationProbability--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpVarRandomizationProbability</h4>
<pre>boolean&nbsp;hasFeasibilityJumpVarRandomizationProbability()</pre>
<div class="block"><pre>
 Probability for a variable to have a non default value upon restarts or
 perturbations.
 </pre>

 <code>optional double feasibility_jump_var_randomization_probability = 247 [default = 0.05];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpVarRandomizationProbability field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpVarRandomizationProbability--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpVarRandomizationProbability</h4>
<pre>double&nbsp;getFeasibilityJumpVarRandomizationProbability()</pre>
<div class="block"><pre>
 Probability for a variable to have a non default value upon restarts or
 perturbations.
 </pre>

 <code>optional double feasibility_jump_var_randomization_probability = 247 [default = 0.05];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpVarRandomizationProbability.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpVarPerburbationRangeRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpVarPerburbationRangeRatio</h4>
<pre>boolean&nbsp;hasFeasibilityJumpVarPerburbationRangeRatio()</pre>
<div class="block"><pre>
 Max distance between the default value and the pertubated value relative to
 the range of the domain of the variable.
 </pre>

 <code>optional double feasibility_jump_var_perburbation_range_ratio = 248 [default = 0.2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpVarPerburbationRangeRatio field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpVarPerburbationRangeRatio--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpVarPerburbationRangeRatio</h4>
<pre>double&nbsp;getFeasibilityJumpVarPerburbationRangeRatio()</pre>
<div class="block"><pre>
 Max distance between the default value and the pertubated value relative to
 the range of the domain of the variable.
 </pre>

 <code>optional double feasibility_jump_var_perburbation_range_ratio = 248 [default = 0.2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpVarPerburbationRangeRatio.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpEnableRestarts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpEnableRestarts</h4>
<pre>boolean&nbsp;hasFeasibilityJumpEnableRestarts()</pre>
<div class="block"><pre>
 When stagnating, feasibility jump will either restart from a default
 solution (with some possible randomization), or randomly pertubate the
 current solution. This parameter selects the first option.
 </pre>

 <code>optional bool feasibility_jump_enable_restarts = 250 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpEnableRestarts field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpEnableRestarts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpEnableRestarts</h4>
<pre>boolean&nbsp;getFeasibilityJumpEnableRestarts()</pre>
<div class="block"><pre>
 When stagnating, feasibility jump will either restart from a default
 solution (with some possible randomization), or randomly pertubate the
 current solution. This parameter selects the first option.
 </pre>

 <code>optional bool feasibility_jump_enable_restarts = 250 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpEnableRestarts.</dd>
</dl>
</li>
</ul>
<a name="hasFeasibilityJumpMaxExpandedConstraintSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFeasibilityJumpMaxExpandedConstraintSize</h4>
<pre>boolean&nbsp;hasFeasibilityJumpMaxExpandedConstraintSize()</pre>
<div class="block"><pre>
 Maximum size of no_overlap or no_overlap_2d constraint for a quadratic
 expansion. This might look a lot, but by expanding such constraint, we get
 a linear time evaluation per single variable moves instead of a slow O(n
 log n) one.
 </pre>

 <code>optional int32 feasibility_jump_max_expanded_constraint_size = 264 [default = 500];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the feasibilityJumpMaxExpandedConstraintSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getFeasibilityJumpMaxExpandedConstraintSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFeasibilityJumpMaxExpandedConstraintSize</h4>
<pre>int&nbsp;getFeasibilityJumpMaxExpandedConstraintSize()</pre>
<div class="block"><pre>
 Maximum size of no_overlap or no_overlap_2d constraint for a quadratic
 expansion. This might look a lot, but by expanding such constraint, we get
 a linear time evaluation per single variable moves instead of a slow O(n
 log n) one.
 </pre>

 <code>optional int32 feasibility_jump_max_expanded_constraint_size = 264 [default = 500];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The feasibilityJumpMaxExpandedConstraintSize.</dd>
</dl>
</li>
</ul>
<a name="hasNumViolationLs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumViolationLs</h4>
<pre>boolean&nbsp;hasNumViolationLs()</pre>
<div class="block"><pre>
 This will create incomplete subsolvers (that are not LNS subsolvers)
 that use the feasibility jump code to find improving solution, treating
 the objective improvement as a hard constraint.
 </pre>

 <code>optional int32 num_violation_ls = 244 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numViolationLs field is set.</dd>
</dl>
</li>
</ul>
<a name="getNumViolationLs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumViolationLs</h4>
<pre>int&nbsp;getNumViolationLs()</pre>
<div class="block"><pre>
 This will create incomplete subsolvers (that are not LNS subsolvers)
 that use the feasibility jump code to find improving solution, treating
 the objective improvement as a hard constraint.
 </pre>

 <code>optional int32 num_violation_ls = 244 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numViolationLs.</dd>
</dl>
</li>
</ul>
<a name="hasViolationLsPerturbationPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasViolationLsPerturbationPeriod</h4>
<pre>boolean&nbsp;hasViolationLsPerturbationPeriod()</pre>
<div class="block"><pre>
 How long violation_ls should wait before perturbating a solution.
 </pre>

 <code>optional int32 violation_ls_perturbation_period = 249 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the violationLsPerturbationPeriod field is set.</dd>
</dl>
</li>
</ul>
<a name="getViolationLsPerturbationPeriod--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getViolationLsPerturbationPeriod</h4>
<pre>int&nbsp;getViolationLsPerturbationPeriod()</pre>
<div class="block"><pre>
 How long violation_ls should wait before perturbating a solution.
 </pre>

 <code>optional int32 violation_ls_perturbation_period = 249 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The violationLsPerturbationPeriod.</dd>
</dl>
</li>
</ul>
<a name="hasViolationLsCompoundMoveProbability--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasViolationLsCompoundMoveProbability</h4>
<pre>boolean&nbsp;hasViolationLsCompoundMoveProbability()</pre>
<div class="block"><pre>
 Probability of using compound move search each restart.
 TODO(user): Add reference to paper when published.
 </pre>

 <code>optional double violation_ls_compound_move_probability = 259 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the violationLsCompoundMoveProbability field is set.</dd>
</dl>
</li>
</ul>
<a name="getViolationLsCompoundMoveProbability--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getViolationLsCompoundMoveProbability</h4>
<pre>double&nbsp;getViolationLsCompoundMoveProbability()</pre>
<div class="block"><pre>
 Probability of using compound move search each restart.
 TODO(user): Add reference to paper when published.
 </pre>

 <code>optional double violation_ls_compound_move_probability = 259 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The violationLsCompoundMoveProbability.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeNumWorkers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeNumWorkers</h4>
<pre>boolean&nbsp;hasSharedTreeNumWorkers()</pre>
<div class="block"><pre>
 Enables shared tree search.
 If positive, start this many complete worker threads to explore a shared
 search tree. These workers communicate objective bounds and simple decision
 nogoods relating to the shared prefix of the tree, and will avoid exploring
 the same subtrees as one another.
 Specifying a negative number uses a heuristic to select an appropriate
 number of shared tree workeres based on the total number of workers.
 </pre>

 <code>optional int32 shared_tree_num_workers = 235 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeNumWorkers field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeNumWorkers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeNumWorkers</h4>
<pre>int&nbsp;getSharedTreeNumWorkers()</pre>
<div class="block"><pre>
 Enables shared tree search.
 If positive, start this many complete worker threads to explore a shared
 search tree. These workers communicate objective bounds and simple decision
 nogoods relating to the shared prefix of the tree, and will avoid exploring
 the same subtrees as one another.
 Specifying a negative number uses a heuristic to select an appropriate
 number of shared tree workeres based on the total number of workers.
 </pre>

 <code>optional int32 shared_tree_num_workers = 235 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeNumWorkers.</dd>
</dl>
</li>
</ul>
<a name="hasUseSharedTreeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseSharedTreeSearch</h4>
<pre>boolean&nbsp;hasUseSharedTreeSearch()</pre>
<div class="block"><pre>
 Set on shared subtree workers. Users should not set this directly.
 </pre>

 <code>optional bool use_shared_tree_search = 236 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useSharedTreeSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseSharedTreeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseSharedTreeSearch</h4>
<pre>boolean&nbsp;getUseSharedTreeSearch()</pre>
<div class="block"><pre>
 Set on shared subtree workers. Users should not set this directly.
 </pre>

 <code>optional bool use_shared_tree_search = 236 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useSharedTreeSearch.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeWorkerMinRestartsPerSubtree--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeWorkerMinRestartsPerSubtree</h4>
<pre>boolean&nbsp;hasSharedTreeWorkerMinRestartsPerSubtree()</pre>
<div class="block"><pre>
 Minimum restarts before a worker will replace a subtree
 that looks "bad" based on the average LBD of learned clauses.
 </pre>

 <code>optional int32 shared_tree_worker_min_restarts_per_subtree = 282 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeWorkerMinRestartsPerSubtree field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeWorkerMinRestartsPerSubtree--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeWorkerMinRestartsPerSubtree</h4>
<pre>int&nbsp;getSharedTreeWorkerMinRestartsPerSubtree()</pre>
<div class="block"><pre>
 Minimum restarts before a worker will replace a subtree
 that looks "bad" based on the average LBD of learned clauses.
 </pre>

 <code>optional int32 shared_tree_worker_min_restarts_per_subtree = 282 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeWorkerMinRestartsPerSubtree.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeWorkerEnableTrailSharing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeWorkerEnableTrailSharing</h4>
<pre>boolean&nbsp;hasSharedTreeWorkerEnableTrailSharing()</pre>
<div class="block"><pre>
 If true, workers share more of the information from their local trail.
 Specifically, literals implied by the shared tree decisions.
 </pre>

 <code>optional bool shared_tree_worker_enable_trail_sharing = 295 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeWorkerEnableTrailSharing field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeWorkerEnableTrailSharing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeWorkerEnableTrailSharing</h4>
<pre>boolean&nbsp;getSharedTreeWorkerEnableTrailSharing()</pre>
<div class="block"><pre>
 If true, workers share more of the information from their local trail.
 Specifically, literals implied by the shared tree decisions.
 </pre>

 <code>optional bool shared_tree_worker_enable_trail_sharing = 295 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeWorkerEnableTrailSharing.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeWorkerEnablePhaseSharing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeWorkerEnablePhaseSharing</h4>
<pre>boolean&nbsp;hasSharedTreeWorkerEnablePhaseSharing()</pre>
<div class="block"><pre>
 If true, shared tree workers share their target phase when returning an
 assigned subtree for the next worker to use.
 </pre>

 <code>optional bool shared_tree_worker_enable_phase_sharing = 304 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeWorkerEnablePhaseSharing field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeWorkerEnablePhaseSharing--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeWorkerEnablePhaseSharing</h4>
<pre>boolean&nbsp;getSharedTreeWorkerEnablePhaseSharing()</pre>
<div class="block"><pre>
 If true, shared tree workers share their target phase when returning an
 assigned subtree for the next worker to use.
 </pre>

 <code>optional bool shared_tree_worker_enable_phase_sharing = 304 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeWorkerEnablePhaseSharing.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeOpenLeavesPerWorker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeOpenLeavesPerWorker</h4>
<pre>boolean&nbsp;hasSharedTreeOpenLeavesPerWorker()</pre>
<div class="block"><pre>
 How many open leaf nodes should the shared tree maintain per worker.
 </pre>

 <code>optional double shared_tree_open_leaves_per_worker = 281 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeOpenLeavesPerWorker field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeOpenLeavesPerWorker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeOpenLeavesPerWorker</h4>
<pre>double&nbsp;getSharedTreeOpenLeavesPerWorker()</pre>
<div class="block"><pre>
 How many open leaf nodes should the shared tree maintain per worker.
 </pre>

 <code>optional double shared_tree_open_leaves_per_worker = 281 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeOpenLeavesPerWorker.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeMaxNodesPerWorker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeMaxNodesPerWorker</h4>
<pre>boolean&nbsp;hasSharedTreeMaxNodesPerWorker()</pre>
<div class="block"><pre>
 In order to limit total shared memory and communication overhead, limit the
 total number of nodes that may be generated in the shared tree. If the
 shared tree runs out of unassigned leaves, workers act as portfolio
 workers. Note: this limit includes interior nodes, not just leaves.
 </pre>

 <code>optional int32 shared_tree_max_nodes_per_worker = 238 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeMaxNodesPerWorker field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeMaxNodesPerWorker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeMaxNodesPerWorker</h4>
<pre>int&nbsp;getSharedTreeMaxNodesPerWorker()</pre>
<div class="block"><pre>
 In order to limit total shared memory and communication overhead, limit the
 total number of nodes that may be generated in the shared tree. If the
 shared tree runs out of unassigned leaves, workers act as portfolio
 workers. Note: this limit includes interior nodes, not just leaves.
 </pre>

 <code>optional int32 shared_tree_max_nodes_per_worker = 238 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeMaxNodesPerWorker.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeSplitStrategy--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeSplitStrategy</h4>
<pre>boolean&nbsp;hasSharedTreeSplitStrategy()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.SharedTreeSplitStrategy shared_tree_split_strategy = 239 [default = SPLIT_STRATEGY_AUTO];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeSplitStrategy field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeSplitStrategy--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeSplitStrategy</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.SharedTreeSplitStrategy.html" title="enum in com.google.ortools.sat">SatParameters.SharedTreeSplitStrategy</a>&nbsp;getSharedTreeSplitStrategy()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.SharedTreeSplitStrategy shared_tree_split_strategy = 239 [default = SPLIT_STRATEGY_AUTO];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeSplitStrategy.</dd>
</dl>
</li>
</ul>
<a name="hasSharedTreeBalanceTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSharedTreeBalanceTolerance</h4>
<pre>boolean&nbsp;hasSharedTreeBalanceTolerance()</pre>
<div class="block"><pre>
 How much deeper compared to the ideal max depth of the tree is considered
 "balanced" enough to still accept a split. Without such a tolerance,
 sometimes the tree can only be split by a single worker, and they may not
 generate a split for some time. In contrast, with a tolerance of 1, at
 least half of all workers should be able to split the tree as soon as a
 split becomes required. This only has an effect on
 SPLIT_STRATEGY_BALANCED_TREE and SPLIT_STRATEGY_DISCREPANCY.
 </pre>

 <code>optional int32 shared_tree_balance_tolerance = 305 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sharedTreeBalanceTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getSharedTreeBalanceTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSharedTreeBalanceTolerance</h4>
<pre>int&nbsp;getSharedTreeBalanceTolerance()</pre>
<div class="block"><pre>
 How much deeper compared to the ideal max depth of the tree is considered
 "balanced" enough to still accept a split. Without such a tolerance,
 sometimes the tree can only be split by a single worker, and they may not
 generate a split for some time. In contrast, with a tolerance of 1, at
 least half of all workers should be able to split the tree as soon as a
 split becomes required. This only has an effect on
 SPLIT_STRATEGY_BALANCED_TREE and SPLIT_STRATEGY_DISCREPANCY.
 </pre>

 <code>optional int32 shared_tree_balance_tolerance = 305 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sharedTreeBalanceTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasEnumerateAllSolutions--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasEnumerateAllSolutions</h4>
<pre>boolean&nbsp;hasEnumerateAllSolutions()</pre>
<div class="block"><pre>
 Whether we enumerate all solutions of a problem without objective. Note
 that setting this to true automatically disable some presolve reduction
 that can remove feasible solution. That is it has the same effect as
 setting keep_all_feasible_solutions_in_presolve.

 TODO(user): Do not do that and let the user choose what behavior is best by
 setting keep_all_feasible_solutions_in_presolve ?
 </pre>

 <code>optional bool enumerate_all_solutions = 87 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the enumerateAllSolutions field is set.</dd>
</dl>
</li>
</ul>
<a name="getEnumerateAllSolutions--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEnumerateAllSolutions</h4>
<pre>boolean&nbsp;getEnumerateAllSolutions()</pre>
<div class="block"><pre>
 Whether we enumerate all solutions of a problem without objective. Note
 that setting this to true automatically disable some presolve reduction
 that can remove feasible solution. That is it has the same effect as
 setting keep_all_feasible_solutions_in_presolve.

 TODO(user): Do not do that and let the user choose what behavior is best by
 setting keep_all_feasible_solutions_in_presolve ?
 </pre>

 <code>optional bool enumerate_all_solutions = 87 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The enumerateAllSolutions.</dd>
</dl>
</li>
</ul>
<a name="hasKeepAllFeasibleSolutionsInPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasKeepAllFeasibleSolutionsInPresolve</h4>
<pre>boolean&nbsp;hasKeepAllFeasibleSolutionsInPresolve()</pre>
<div class="block"><pre>
 If true, we disable the presolve reductions that remove feasible solutions
 from the search space. Such solution are usually dominated by a "better"
 solution that is kept, but depending on the situation, we might want to
 keep all solutions.

 A trivial example is when a variable is unused. If this is true, then the
 presolve will not fix it to an arbitrary value and it will stay in the
 search space.
 </pre>

 <code>optional bool keep_all_feasible_solutions_in_presolve = 173 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the keepAllFeasibleSolutionsInPresolve field is set.</dd>
</dl>
</li>
</ul>
<a name="getKeepAllFeasibleSolutionsInPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getKeepAllFeasibleSolutionsInPresolve</h4>
<pre>boolean&nbsp;getKeepAllFeasibleSolutionsInPresolve()</pre>
<div class="block"><pre>
 If true, we disable the presolve reductions that remove feasible solutions
 from the search space. Such solution are usually dominated by a "better"
 solution that is kept, but depending on the situation, we might want to
 keep all solutions.

 A trivial example is when a variable is unused. If this is true, then the
 presolve will not fix it to an arbitrary value and it will stay in the
 search space.
 </pre>

 <code>optional bool keep_all_feasible_solutions_in_presolve = 173 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The keepAllFeasibleSolutionsInPresolve.</dd>
</dl>
</li>
</ul>
<a name="hasFillTightenedDomainsInResponse--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFillTightenedDomainsInResponse</h4>
<pre>boolean&nbsp;hasFillTightenedDomainsInResponse()</pre>
<div class="block"><pre>
 If true, add information about the derived variable domains to the
 CpSolverResponse. It is an option because it makes the response slighly
 bigger and there is a bit more work involved during the postsolve to
 construct it, but it should still have a low overhead. See the
 tightened_variables field in CpSolverResponse for more details.
 </pre>

 <code>optional bool fill_tightened_domains_in_response = 132 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the fillTightenedDomainsInResponse field is set.</dd>
</dl>
</li>
</ul>
<a name="getFillTightenedDomainsInResponse--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFillTightenedDomainsInResponse</h4>
<pre>boolean&nbsp;getFillTightenedDomainsInResponse()</pre>
<div class="block"><pre>
 If true, add information about the derived variable domains to the
 CpSolverResponse. It is an option because it makes the response slighly
 bigger and there is a bit more work involved during the postsolve to
 construct it, but it should still have a low overhead. See the
 tightened_variables field in CpSolverResponse for more details.
 </pre>

 <code>optional bool fill_tightened_domains_in_response = 132 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The fillTightenedDomainsInResponse.</dd>
</dl>
</li>
</ul>
<a name="hasFillAdditionalSolutionsInResponse--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFillAdditionalSolutionsInResponse</h4>
<pre>boolean&nbsp;hasFillAdditionalSolutionsInResponse()</pre>
<div class="block"><pre>
 If true, the final response addition_solutions field will be filled with
 all solutions from our solutions pool.

 Note that if both this field and enumerate_all_solutions is true, we will
 copy to the pool all of the solution found. So if solution_pool_size is big
 enough, you can get all solutions this way instead of using the solution
 callback.

 Note that this only affect the "final" solution, not the one passed to the
 solution callbacks.
 </pre>

 <code>optional bool fill_additional_solutions_in_response = 194 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the fillAdditionalSolutionsInResponse field is set.</dd>
</dl>
</li>
</ul>
<a name="getFillAdditionalSolutionsInResponse--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFillAdditionalSolutionsInResponse</h4>
<pre>boolean&nbsp;getFillAdditionalSolutionsInResponse()</pre>
<div class="block"><pre>
 If true, the final response addition_solutions field will be filled with
 all solutions from our solutions pool.

 Note that if both this field and enumerate_all_solutions is true, we will
 copy to the pool all of the solution found. So if solution_pool_size is big
 enough, you can get all solutions this way instead of using the solution
 callback.

 Note that this only affect the "final" solution, not the one passed to the
 solution callbacks.
 </pre>

 <code>optional bool fill_additional_solutions_in_response = 194 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The fillAdditionalSolutionsInResponse.</dd>
</dl>
</li>
</ul>
<a name="hasInstantiateAllVariables--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInstantiateAllVariables</h4>
<pre>boolean&nbsp;hasInstantiateAllVariables()</pre>
<div class="block"><pre>
 If true, the solver will add a default integer branching strategy to the
 already defined search strategy. If not, some variable might still not be
 fixed at the end of the search. For now we assume these variable can just
 be set to their lower bound.
 </pre>

 <code>optional bool instantiate_all_variables = 106 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the instantiateAllVariables field is set.</dd>
</dl>
</li>
</ul>
<a name="getInstantiateAllVariables--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInstantiateAllVariables</h4>
<pre>boolean&nbsp;getInstantiateAllVariables()</pre>
<div class="block"><pre>
 If true, the solver will add a default integer branching strategy to the
 already defined search strategy. If not, some variable might still not be
 fixed at the end of the search. For now we assume these variable can just
 be set to their lower bound.
 </pre>

 <code>optional bool instantiate_all_variables = 106 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The instantiateAllVariables.</dd>
</dl>
</li>
</ul>
<a name="hasAutoDetectGreaterThanAtLeastOneOf--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAutoDetectGreaterThanAtLeastOneOf</h4>
<pre>boolean&nbsp;hasAutoDetectGreaterThanAtLeastOneOf()</pre>
<div class="block"><pre>
 If true, then the precedences propagator try to detect for each variable if
 it has a set of "optional incoming arc" for which at least one of them is
 present. This is usually useful to have but can be slow on model with a lot
 of precedence.
 </pre>

 <code>optional bool auto_detect_greater_than_at_least_one_of = 95 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the autoDetectGreaterThanAtLeastOneOf field is set.</dd>
</dl>
</li>
</ul>
<a name="getAutoDetectGreaterThanAtLeastOneOf--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAutoDetectGreaterThanAtLeastOneOf</h4>
<pre>boolean&nbsp;getAutoDetectGreaterThanAtLeastOneOf()</pre>
<div class="block"><pre>
 If true, then the precedences propagator try to detect for each variable if
 it has a set of "optional incoming arc" for which at least one of them is
 present. This is usually useful to have but can be slow on model with a lot
 of precedence.
 </pre>

 <code>optional bool auto_detect_greater_than_at_least_one_of = 95 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The autoDetectGreaterThanAtLeastOneOf.</dd>
</dl>
</li>
</ul>
<a name="hasStopAfterFirstSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasStopAfterFirstSolution</h4>
<pre>boolean&nbsp;hasStopAfterFirstSolution()</pre>
<div class="block"><pre>
 For an optimization problem, stop the solver as soon as we have a solution.
 </pre>

 <code>optional bool stop_after_first_solution = 98 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the stopAfterFirstSolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getStopAfterFirstSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStopAfterFirstSolution</h4>
<pre>boolean&nbsp;getStopAfterFirstSolution()</pre>
<div class="block"><pre>
 For an optimization problem, stop the solver as soon as we have a solution.
 </pre>

 <code>optional bool stop_after_first_solution = 98 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The stopAfterFirstSolution.</dd>
</dl>
</li>
</ul>
<a name="hasStopAfterPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasStopAfterPresolve</h4>
<pre>boolean&nbsp;hasStopAfterPresolve()</pre>
<div class="block"><pre>
 Mainly used when improving the presolver. When true, stops the solver after
 the presolve is complete (or after loading and root level propagation).
 </pre>

 <code>optional bool stop_after_presolve = 149 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the stopAfterPresolve field is set.</dd>
</dl>
</li>
</ul>
<a name="getStopAfterPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStopAfterPresolve</h4>
<pre>boolean&nbsp;getStopAfterPresolve()</pre>
<div class="block"><pre>
 Mainly used when improving the presolver. When true, stops the solver after
 the presolve is complete (or after loading and root level propagation).
 </pre>

 <code>optional bool stop_after_presolve = 149 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The stopAfterPresolve.</dd>
</dl>
</li>
</ul>
<a name="hasStopAfterRootPropagation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasStopAfterRootPropagation</h4>
<pre>boolean&nbsp;hasStopAfterRootPropagation()</pre>
<div class="block"><code>optional bool stop_after_root_propagation = 252 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the stopAfterRootPropagation field is set.</dd>
</dl>
</li>
</ul>
<a name="getStopAfterRootPropagation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStopAfterRootPropagation</h4>
<pre>boolean&nbsp;getStopAfterRootPropagation()</pre>
<div class="block"><code>optional bool stop_after_root_propagation = 252 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The stopAfterRootPropagation.</dd>
</dl>
</li>
</ul>
<a name="hasLnsInitialDifficulty--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLnsInitialDifficulty</h4>
<pre>boolean&nbsp;hasLnsInitialDifficulty()</pre>
<div class="block"><pre>
 Initial parameters for neighborhood generation.
 </pre>

 <code>optional double lns_initial_difficulty = 307 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the lnsInitialDifficulty field is set.</dd>
</dl>
</li>
</ul>
<a name="getLnsInitialDifficulty--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLnsInitialDifficulty</h4>
<pre>double&nbsp;getLnsInitialDifficulty()</pre>
<div class="block"><pre>
 Initial parameters for neighborhood generation.
 </pre>

 <code>optional double lns_initial_difficulty = 307 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The lnsInitialDifficulty.</dd>
</dl>
</li>
</ul>
<a name="hasLnsInitialDeterministicLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLnsInitialDeterministicLimit</h4>
<pre>boolean&nbsp;hasLnsInitialDeterministicLimit()</pre>
<div class="block"><code>optional double lns_initial_deterministic_limit = 308 [default = 0.1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the lnsInitialDeterministicLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getLnsInitialDeterministicLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLnsInitialDeterministicLimit</h4>
<pre>double&nbsp;getLnsInitialDeterministicLimit()</pre>
<div class="block"><code>optional double lns_initial_deterministic_limit = 308 [default = 0.1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The lnsInitialDeterministicLimit.</dd>
</dl>
</li>
</ul>
<a name="hasUseLns--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseLns</h4>
<pre>boolean&nbsp;hasUseLns()</pre>
<div class="block"><pre>
 Testing parameters used to disable all lns workers.
 </pre>

 <code>optional bool use_lns = 283 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useLns field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseLns--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseLns</h4>
<pre>boolean&nbsp;getUseLns()</pre>
<div class="block"><pre>
 Testing parameters used to disable all lns workers.
 </pre>

 <code>optional bool use_lns = 283 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useLns.</dd>
</dl>
</li>
</ul>
<a name="hasUseLnsOnly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseLnsOnly</h4>
<pre>boolean&nbsp;hasUseLnsOnly()</pre>
<div class="block"><pre>
 Experimental parameters to disable everything but lns.
 </pre>

 <code>optional bool use_lns_only = 101 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useLnsOnly field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseLnsOnly--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseLnsOnly</h4>
<pre>boolean&nbsp;getUseLnsOnly()</pre>
<div class="block"><pre>
 Experimental parameters to disable everything but lns.
 </pre>

 <code>optional bool use_lns_only = 101 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useLnsOnly.</dd>
</dl>
</li>
</ul>
<a name="hasSolutionPoolSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolutionPoolSize</h4>
<pre>boolean&nbsp;hasSolutionPoolSize()</pre>
<div class="block"><pre>
 Size of the top-n different solutions kept by the solver.
 This parameter must be &gt; 0.
 Currently this only impact the "base" solution chosen for a LNS fragment.
 </pre>

 <code>optional int32 solution_pool_size = 193 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the solutionPoolSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getSolutionPoolSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSolutionPoolSize</h4>
<pre>int&nbsp;getSolutionPoolSize()</pre>
<div class="block"><pre>
 Size of the top-n different solutions kept by the solver.
 This parameter must be &gt; 0.
 Currently this only impact the "base" solution chosen for a LNS fragment.
 </pre>

 <code>optional int32 solution_pool_size = 193 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The solutionPoolSize.</dd>
</dl>
</li>
</ul>
<a name="hasUseRinsLns--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseRinsLns</h4>
<pre>boolean&nbsp;hasUseRinsLns()</pre>
<div class="block"><pre>
 Turns on relaxation induced neighborhood generator.
 </pre>

 <code>optional bool use_rins_lns = 129 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useRinsLns field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseRinsLns--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseRinsLns</h4>
<pre>boolean&nbsp;getUseRinsLns()</pre>
<div class="block"><pre>
 Turns on relaxation induced neighborhood generator.
 </pre>

 <code>optional bool use_rins_lns = 129 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useRinsLns.</dd>
</dl>
</li>
</ul>
<a name="hasUseFeasibilityPump--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseFeasibilityPump</h4>
<pre>boolean&nbsp;hasUseFeasibilityPump()</pre>
<div class="block"><pre>
 Adds a feasibility pump subsolver along with lns subsolvers.
 </pre>

 <code>optional bool use_feasibility_pump = 164 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useFeasibilityPump field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseFeasibilityPump--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseFeasibilityPump</h4>
<pre>boolean&nbsp;getUseFeasibilityPump()</pre>
<div class="block"><pre>
 Adds a feasibility pump subsolver along with lns subsolvers.
 </pre>

 <code>optional bool use_feasibility_pump = 164 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useFeasibilityPump.</dd>
</dl>
</li>
</ul>
<a name="hasUseLbRelaxLns--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseLbRelaxLns</h4>
<pre>boolean&nbsp;hasUseLbRelaxLns()</pre>
<div class="block"><pre>
 Turns on neighborhood generator based on local branching LP. Based on Huang
 et al., "Local Branching Relaxation Heuristics for Integer Linear
 Programs", 2023.
 </pre>

 <code>optional bool use_lb_relax_lns = 255 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useLbRelaxLns field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseLbRelaxLns--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseLbRelaxLns</h4>
<pre>boolean&nbsp;getUseLbRelaxLns()</pre>
<div class="block"><pre>
 Turns on neighborhood generator based on local branching LP. Based on Huang
 et al., "Local Branching Relaxation Heuristics for Integer Linear
 Programs", 2023.
 </pre>

 <code>optional bool use_lb_relax_lns = 255 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useLbRelaxLns.</dd>
</dl>
</li>
</ul>
<a name="hasLbRelaxNumWorkersThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLbRelaxNumWorkersThreshold</h4>
<pre>boolean&nbsp;hasLbRelaxNumWorkersThreshold()</pre>
<div class="block"><pre>
 Only use lb-relax if we have at least that many workers.
 </pre>

 <code>optional int32 lb_relax_num_workers_threshold = 296 [default = 16];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the lbRelaxNumWorkersThreshold field is set.</dd>
</dl>
</li>
</ul>
<a name="getLbRelaxNumWorkersThreshold--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLbRelaxNumWorkersThreshold</h4>
<pre>int&nbsp;getLbRelaxNumWorkersThreshold()</pre>
<div class="block"><pre>
 Only use lb-relax if we have at least that many workers.
 </pre>

 <code>optional int32 lb_relax_num_workers_threshold = 296 [default = 16];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The lbRelaxNumWorkersThreshold.</dd>
</dl>
</li>
</ul>
<a name="hasFpRounding--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFpRounding</h4>
<pre>boolean&nbsp;hasFpRounding()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.FPRoundingMethod fp_rounding = 165 [default = PROPAGATION_ASSISTED];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the fpRounding field is set.</dd>
</dl>
</li>
</ul>
<a name="getFpRounding--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFpRounding</h4>
<pre><a href="../../../../com/google/ortools/sat/SatParameters.FPRoundingMethod.html" title="enum in com.google.ortools.sat">SatParameters.FPRoundingMethod</a>&nbsp;getFpRounding()</pre>
<div class="block"><code>optional .operations_research.sat.SatParameters.FPRoundingMethod fp_rounding = 165 [default = PROPAGATION_ASSISTED];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The fpRounding.</dd>
</dl>
</li>
</ul>
<a name="hasDiversifyLnsParams--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDiversifyLnsParams</h4>
<pre>boolean&nbsp;hasDiversifyLnsParams()</pre>
<div class="block"><pre>
 If true, registers more lns subsolvers with different parameters.
 </pre>

 <code>optional bool diversify_lns_params = 137 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the diversifyLnsParams field is set.</dd>
</dl>
</li>
</ul>
<a name="getDiversifyLnsParams--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDiversifyLnsParams</h4>
<pre>boolean&nbsp;getDiversifyLnsParams()</pre>
<div class="block"><pre>
 If true, registers more lns subsolvers with different parameters.
 </pre>

 <code>optional bool diversify_lns_params = 137 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The diversifyLnsParams.</dd>
</dl>
</li>
</ul>
<a name="hasRandomizeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRandomizeSearch</h4>
<pre>boolean&nbsp;hasRandomizeSearch()</pre>
<div class="block"><pre>
 Randomize fixed search.
 </pre>

 <code>optional bool randomize_search = 103 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the randomizeSearch field is set.</dd>
</dl>
</li>
</ul>
<a name="getRandomizeSearch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomizeSearch</h4>
<pre>boolean&nbsp;getRandomizeSearch()</pre>
<div class="block"><pre>
 Randomize fixed search.
 </pre>

 <code>optional bool randomize_search = 103 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The randomizeSearch.</dd>
</dl>
</li>
</ul>
<a name="hasSearchRandomVariablePoolSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSearchRandomVariablePoolSize</h4>
<pre>boolean&nbsp;hasSearchRandomVariablePoolSize()</pre>
<div class="block"><pre>
 Search randomization will collect the top
 'search_random_variable_pool_size' valued variables, and pick one randomly.
 The value of the variable is specific to each strategy.
 </pre>

 <code>optional int64 search_random_variable_pool_size = 104 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the searchRandomVariablePoolSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getSearchRandomVariablePoolSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSearchRandomVariablePoolSize</h4>
<pre>long&nbsp;getSearchRandomVariablePoolSize()</pre>
<div class="block"><pre>
 Search randomization will collect the top
 'search_random_variable_pool_size' valued variables, and pick one randomly.
 The value of the variable is specific to each strategy.
 </pre>

 <code>optional int64 search_random_variable_pool_size = 104 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The searchRandomVariablePoolSize.</dd>
</dl>
</li>
</ul>
<a name="hasPushAllTasksTowardStart--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPushAllTasksTowardStart</h4>
<pre>boolean&nbsp;hasPushAllTasksTowardStart()</pre>
<div class="block"><pre>
 Experimental code: specify if the objective pushes all tasks toward the
 start of the schedule.
 </pre>

 <code>optional bool push_all_tasks_toward_start = 262 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the pushAllTasksTowardStart field is set.</dd>
</dl>
</li>
</ul>
<a name="getPushAllTasksTowardStart--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPushAllTasksTowardStart</h4>
<pre>boolean&nbsp;getPushAllTasksTowardStart()</pre>
<div class="block"><pre>
 Experimental code: specify if the objective pushes all tasks toward the
 start of the schedule.
 </pre>

 <code>optional bool push_all_tasks_toward_start = 262 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The pushAllTasksTowardStart.</dd>
</dl>
</li>
</ul>
<a name="hasUseOptionalVariables--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseOptionalVariables</h4>
<pre>boolean&nbsp;hasUseOptionalVariables()</pre>
<div class="block"><pre>
 If true, we automatically detect variables whose constraint are always
 enforced by the same literal and we mark them as optional. This allows
 to propagate them as if they were present in some situation.

 TODO(user): This is experimental and seems to lead to wrong optimal in
 some situation. It should however gives correct solutions. Fix.
 </pre>

 <code>optional bool use_optional_variables = 108 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useOptionalVariables field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseOptionalVariables--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseOptionalVariables</h4>
<pre>boolean&nbsp;getUseOptionalVariables()</pre>
<div class="block"><pre>
 If true, we automatically detect variables whose constraint are always
 enforced by the same literal and we mark them as optional. This allows
 to propagate them as if they were present in some situation.

 TODO(user): This is experimental and seems to lead to wrong optimal in
 some situation. It should however gives correct solutions. Fix.
 </pre>

 <code>optional bool use_optional_variables = 108 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useOptionalVariables.</dd>
</dl>
</li>
</ul>
<a name="hasUseExactLpReason--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseExactLpReason</h4>
<pre>boolean&nbsp;hasUseExactLpReason()</pre>
<div class="block"><pre>
 The solver usually exploit the LP relaxation of a model. If this option is
 true, then whatever is infered by the LP will be used like an heuristic to
 compute EXACT propagation on the IP. So with this option, there is no
 numerical imprecision issues.
 </pre>

 <code>optional bool use_exact_lp_reason = 109 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useExactLpReason field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseExactLpReason--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseExactLpReason</h4>
<pre>boolean&nbsp;getUseExactLpReason()</pre>
<div class="block"><pre>
 The solver usually exploit the LP relaxation of a model. If this option is
 true, then whatever is infered by the LP will be used like an heuristic to
 compute EXACT propagation on the IP. So with this option, there is no
 numerical imprecision issues.
 </pre>

 <code>optional bool use_exact_lp_reason = 109 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useExactLpReason.</dd>
</dl>
</li>
</ul>
<a name="hasUseCombinedNoOverlap--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseCombinedNoOverlap</h4>
<pre>boolean&nbsp;hasUseCombinedNoOverlap()</pre>
<div class="block"><pre>
 This can be beneficial if there is a lot of no-overlap constraints but a
 relatively low number of different intervals in the problem. Like 1000
 intervals, but 1M intervals in the no-overlap constraints covering them.
 </pre>

 <code>optional bool use_combined_no_overlap = 133 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useCombinedNoOverlap field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseCombinedNoOverlap--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseCombinedNoOverlap</h4>
<pre>boolean&nbsp;getUseCombinedNoOverlap()</pre>
<div class="block"><pre>
 This can be beneficial if there is a lot of no-overlap constraints but a
 relatively low number of different intervals in the problem. Like 1000
 intervals, but 1M intervals in the no-overlap constraints covering them.
 </pre>

 <code>optional bool use_combined_no_overlap = 133 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useCombinedNoOverlap.</dd>
</dl>
</li>
</ul>
<a name="hasAtMostOneMaxExpansionSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAtMostOneMaxExpansionSize</h4>
<pre>boolean&nbsp;hasAtMostOneMaxExpansionSize()</pre>
<div class="block"><pre>
 All at_most_one constraints with a size &lt;= param will be replaced by a
 quadratic number of binary implications.
 </pre>

 <code>optional int32 at_most_one_max_expansion_size = 270 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the atMostOneMaxExpansionSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getAtMostOneMaxExpansionSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAtMostOneMaxExpansionSize</h4>
<pre>int&nbsp;getAtMostOneMaxExpansionSize()</pre>
<div class="block"><pre>
 All at_most_one constraints with a size &lt;= param will be replaced by a
 quadratic number of binary implications.
 </pre>

 <code>optional int32 at_most_one_max_expansion_size = 270 [default = 3];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The atMostOneMaxExpansionSize.</dd>
</dl>
</li>
</ul>
<a name="hasCatchSigintSignal--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCatchSigintSignal</h4>
<pre>boolean&nbsp;hasCatchSigintSignal()</pre>
<div class="block"><pre>
 Indicates if the CP-SAT layer should catch Control-C (SIGINT) signals
 when calling solve. If set, catching the SIGINT signal will terminate the
 search gracefully, as if a time limit was reached.
 </pre>

 <code>optional bool catch_sigint_signal = 135 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the catchSigintSignal field is set.</dd>
</dl>
</li>
</ul>
<a name="getCatchSigintSignal--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCatchSigintSignal</h4>
<pre>boolean&nbsp;getCatchSigintSignal()</pre>
<div class="block"><pre>
 Indicates if the CP-SAT layer should catch Control-C (SIGINT) signals
 when calling solve. If set, catching the SIGINT signal will terminate the
 search gracefully, as if a time limit was reached.
 </pre>

 <code>optional bool catch_sigint_signal = 135 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The catchSigintSignal.</dd>
</dl>
</li>
</ul>
<a name="hasUseImpliedBounds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseImpliedBounds</h4>
<pre>boolean&nbsp;hasUseImpliedBounds()</pre>
<div class="block"><pre>
 Stores and exploits "implied-bounds" in the solver. That is, relations of
 the form literal =&gt; (var &gt;= bound). This is currently used to derive
 stronger cuts.
 </pre>

 <code>optional bool use_implied_bounds = 144 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useImpliedBounds field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseImpliedBounds--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseImpliedBounds</h4>
<pre>boolean&nbsp;getUseImpliedBounds()</pre>
<div class="block"><pre>
 Stores and exploits "implied-bounds" in the solver. That is, relations of
 the form literal =&gt; (var &gt;= bound). This is currently used to derive
 stronger cuts.
 </pre>

 <code>optional bool use_implied_bounds = 144 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useImpliedBounds.</dd>
</dl>
</li>
</ul>
<a name="hasPolishLpSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPolishLpSolution</h4>
<pre>boolean&nbsp;hasPolishLpSolution()</pre>
<div class="block"><pre>
 Whether we try to do a few degenerate iteration at the end of an LP solve
 to minimize the fractionality of the integer variable in the basis. This
 helps on some problems, but not so much on others. It also cost of bit of
 time to do such polish step.
 </pre>

 <code>optional bool polish_lp_solution = 175 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the polishLpSolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getPolishLpSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPolishLpSolution</h4>
<pre>boolean&nbsp;getPolishLpSolution()</pre>
<div class="block"><pre>
 Whether we try to do a few degenerate iteration at the end of an LP solve
 to minimize the fractionality of the integer variable in the basis. This
 helps on some problems, but not so much on others. It also cost of bit of
 time to do such polish step.
 </pre>

 <code>optional bool polish_lp_solution = 175 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The polishLpSolution.</dd>
</dl>
</li>
</ul>
<a name="hasLpPrimalTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLpPrimalTolerance</h4>
<pre>boolean&nbsp;hasLpPrimalTolerance()</pre>
<div class="block"><pre>
 The internal LP tolerances used by CP-SAT. These applies to the internal
 and scaled problem. If the domains of your variables are large it might be
 good to use lower tolerances. If your problem is binary with low
 coefficients, it might be good to use higher ones to speed-up the lp
 solves.
 </pre>

 <code>optional double lp_primal_tolerance = 266 [default = 1e-07];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the lpPrimalTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getLpPrimalTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLpPrimalTolerance</h4>
<pre>double&nbsp;getLpPrimalTolerance()</pre>
<div class="block"><pre>
 The internal LP tolerances used by CP-SAT. These applies to the internal
 and scaled problem. If the domains of your variables are large it might be
 good to use lower tolerances. If your problem is binary with low
 coefficients, it might be good to use higher ones to speed-up the lp
 solves.
 </pre>

 <code>optional double lp_primal_tolerance = 266 [default = 1e-07];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The lpPrimalTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasLpDualTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLpDualTolerance</h4>
<pre>boolean&nbsp;hasLpDualTolerance()</pre>
<div class="block"><code>optional double lp_dual_tolerance = 267 [default = 1e-07];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the lpDualTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getLpDualTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLpDualTolerance</h4>
<pre>double&nbsp;getLpDualTolerance()</pre>
<div class="block"><code>optional double lp_dual_tolerance = 267 [default = 1e-07];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The lpDualTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasConvertIntervals--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasConvertIntervals</h4>
<pre>boolean&nbsp;hasConvertIntervals()</pre>
<div class="block"><pre>
 Temporary flag util the feature is more mature. This convert intervals to
 the newer proto format that support affine start/var/end instead of just
 variables.
 </pre>

 <code>optional bool convert_intervals = 177 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the convertIntervals field is set.</dd>
</dl>
</li>
</ul>
<a name="getConvertIntervals--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConvertIntervals</h4>
<pre>boolean&nbsp;getConvertIntervals()</pre>
<div class="block"><pre>
 Temporary flag util the feature is more mature. This convert intervals to
 the newer proto format that support affine start/var/end instead of just
 variables.
 </pre>

 <code>optional bool convert_intervals = 177 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The convertIntervals.</dd>
</dl>
</li>
</ul>
<a name="hasSymmetryLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSymmetryLevel</h4>
<pre>boolean&nbsp;hasSymmetryLevel()</pre>
<div class="block"><pre>
 Whether we try to automatically detect the symmetries in a model and
 exploit them. Currently, at level 1 we detect them in presolve and try
 to fix Booleans. At level 2, we also do some form of dynamic symmetry
 breaking during search. At level 3, we also detect symmetries for very
 large models, which can be slow. At level 4, we try to break as much
 symmetry as possible in presolve.
 </pre>

 <code>optional int32 symmetry_level = 183 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the symmetryLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getSymmetryLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSymmetryLevel</h4>
<pre>int&nbsp;getSymmetryLevel()</pre>
<div class="block"><pre>
 Whether we try to automatically detect the symmetries in a model and
 exploit them. Currently, at level 1 we detect them in presolve and try
 to fix Booleans. At level 2, we also do some form of dynamic symmetry
 breaking during search. At level 3, we also detect symmetries for very
 large models, which can be slow. At level 4, we try to break as much
 symmetry as possible in presolve.
 </pre>

 <code>optional int32 symmetry_level = 183 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The symmetryLevel.</dd>
</dl>
</li>
</ul>
<a name="hasUseSymmetryInLp--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseSymmetryInLp</h4>
<pre>boolean&nbsp;hasUseSymmetryInLp()</pre>
<div class="block"><pre>
 When we have symmetry, it is possible to "fold" all variables from the same
 orbit into a single variable, while having the same power of LP relaxation.
 This can help significantly on symmetric problem. However there is
 currently a bit of overhead as the rest of the solver need to do some
 translation between the folded LP and the rest of the problem.
 </pre>

 <code>optional bool use_symmetry_in_lp = 301 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useSymmetryInLp field is set.</dd>
</dl>
</li>
</ul>
<a name="getUseSymmetryInLp--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseSymmetryInLp</h4>
<pre>boolean&nbsp;getUseSymmetryInLp()</pre>
<div class="block"><pre>
 When we have symmetry, it is possible to "fold" all variables from the same
 orbit into a single variable, while having the same power of LP relaxation.
 This can help significantly on symmetric problem. However there is
 currently a bit of overhead as the rest of the solver need to do some
 translation between the folded LP and the rest of the problem.
 </pre>

 <code>optional bool use_symmetry_in_lp = 301 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useSymmetryInLp.</dd>
</dl>
</li>
</ul>
<a name="hasKeepSymmetryInPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasKeepSymmetryInPresolve</h4>
<pre>boolean&nbsp;hasKeepSymmetryInPresolve()</pre>
<div class="block"><pre>
 Experimental. This will compute the symmetry of the problem once and for
 all. All presolve operations we do should keep the symmetry group intact
 or modify it properly. For now we have really little support for this. We
 will disable a bunch of presolve operations that could be supported.
 </pre>

 <code>optional bool keep_symmetry_in_presolve = 303 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the keepSymmetryInPresolve field is set.</dd>
</dl>
</li>
</ul>
<a name="getKeepSymmetryInPresolve--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getKeepSymmetryInPresolve</h4>
<pre>boolean&nbsp;getKeepSymmetryInPresolve()</pre>
<div class="block"><pre>
 Experimental. This will compute the symmetry of the problem once and for
 all. All presolve operations we do should keep the symmetry group intact
 or modify it properly. For now we have really little support for this. We
 will disable a bunch of presolve operations that could be supported.
 </pre>

 <code>optional bool keep_symmetry_in_presolve = 303 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The keepSymmetryInPresolve.</dd>
</dl>
</li>
</ul>
<a name="hasSymmetryDetectionDeterministicTimeLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSymmetryDetectionDeterministicTimeLimit</h4>
<pre>boolean&nbsp;hasSymmetryDetectionDeterministicTimeLimit()</pre>
<div class="block"><pre>
 Deterministic time limit for symmetry detection.
 </pre>

 <code>optional double symmetry_detection_deterministic_time_limit = 302 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the symmetryDetectionDeterministicTimeLimit field is set.</dd>
</dl>
</li>
</ul>
<a name="getSymmetryDetectionDeterministicTimeLimit--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSymmetryDetectionDeterministicTimeLimit</h4>
<pre>double&nbsp;getSymmetryDetectionDeterministicTimeLimit()</pre>
<div class="block"><pre>
 Deterministic time limit for symmetry detection.
 </pre>

 <code>optional double symmetry_detection_deterministic_time_limit = 302 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The symmetryDetectionDeterministicTimeLimit.</dd>
</dl>
</li>
</ul>
<a name="hasNewLinearPropagation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNewLinearPropagation</h4>
<pre>boolean&nbsp;hasNewLinearPropagation()</pre>
<div class="block"><pre>
 The new linear propagation code treat all constraints at once and use
 an adaptation of Bellman-Ford-Tarjan to propagate constraint in a smarter
 order and potentially detect propagation cycle earlier.
 </pre>

 <code>optional bool new_linear_propagation = 224 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the newLinearPropagation field is set.</dd>
</dl>
</li>
</ul>
<a name="getNewLinearPropagation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNewLinearPropagation</h4>
<pre>boolean&nbsp;getNewLinearPropagation()</pre>
<div class="block"><pre>
 The new linear propagation code treat all constraints at once and use
 an adaptation of Bellman-Ford-Tarjan to propagate constraint in a smarter
 order and potentially detect propagation cycle earlier.
 </pre>

 <code>optional bool new_linear_propagation = 224 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newLinearPropagation.</dd>
</dl>
</li>
</ul>
<a name="hasLinearSplitSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLinearSplitSize</h4>
<pre>boolean&nbsp;hasLinearSplitSize()</pre>
<div class="block"><pre>
 Linear constraints that are not pseudo-Boolean and that are longer than
 this size will be split into sqrt(size) intermediate sums in order to have
 faster propation in the CP engine.
 </pre>

 <code>optional int32 linear_split_size = 256 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the linearSplitSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getLinearSplitSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLinearSplitSize</h4>
<pre>int&nbsp;getLinearSplitSize()</pre>
<div class="block"><pre>
 Linear constraints that are not pseudo-Boolean and that are longer than
 this size will be split into sqrt(size) intermediate sums in order to have
 faster propation in the CP engine.
 </pre>

 <code>optional int32 linear_split_size = 256 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The linearSplitSize.</dd>
</dl>
</li>
</ul>
<a name="hasLinearizationLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLinearizationLevel</h4>
<pre>boolean&nbsp;hasLinearizationLevel()</pre>
<div class="block"><pre>
 A non-negative level indicating the type of constraints we consider in the
 LP relaxation. At level zero, no LP relaxation is used. At level 1, only
 the linear constraint and full encoding are added. At level 2, we also add
 all the Boolean constraints.
 </pre>

 <code>optional int32 linearization_level = 90 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the linearizationLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getLinearizationLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLinearizationLevel</h4>
<pre>int&nbsp;getLinearizationLevel()</pre>
<div class="block"><pre>
 A non-negative level indicating the type of constraints we consider in the
 LP relaxation. At level zero, no LP relaxation is used. At level 1, only
 the linear constraint and full encoding are added. At level 2, we also add
 all the Boolean constraints.
 </pre>

 <code>optional int32 linearization_level = 90 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The linearizationLevel.</dd>
</dl>
</li>
</ul>
<a name="hasBooleanEncodingLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasBooleanEncodingLevel</h4>
<pre>boolean&nbsp;hasBooleanEncodingLevel()</pre>
<div class="block"><pre>
 A non-negative level indicating how much we should try to fully encode
 Integer variables as Boolean.
 </pre>

 <code>optional int32 boolean_encoding_level = 107 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the booleanEncodingLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getBooleanEncodingLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBooleanEncodingLevel</h4>
<pre>int&nbsp;getBooleanEncodingLevel()</pre>
<div class="block"><pre>
 A non-negative level indicating how much we should try to fully encode
 Integer variables as Boolean.
 </pre>

 <code>optional int32 boolean_encoding_level = 107 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The booleanEncodingLevel.</dd>
</dl>
</li>
</ul>
<a name="hasMaxDomainSizeWhenEncodingEqNeqConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxDomainSizeWhenEncodingEqNeqConstraints</h4>
<pre>boolean&nbsp;hasMaxDomainSizeWhenEncodingEqNeqConstraints()</pre>
<div class="block"><pre>
 When loading a*x + b*y ==/!= c when x and y are both fully encoded.
 The solver may decide to replace the linear equation by a set of clauses.
 This is triggered if the sizes of the domains of x and y are below the
 threshold.
 </pre>

 <code>optional int32 max_domain_size_when_encoding_eq_neq_constraints = 191 [default = 16];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxDomainSizeWhenEncodingEqNeqConstraints field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxDomainSizeWhenEncodingEqNeqConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxDomainSizeWhenEncodingEqNeqConstraints</h4>
<pre>int&nbsp;getMaxDomainSizeWhenEncodingEqNeqConstraints()</pre>
<div class="block"><pre>
 When loading a*x + b*y ==/!= c when x and y are both fully encoded.
 The solver may decide to replace the linear equation by a set of clauses.
 This is triggered if the sizes of the domains of x and y are below the
 threshold.
 </pre>

 <code>optional int32 max_domain_size_when_encoding_eq_neq_constraints = 191 [default = 16];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxDomainSizeWhenEncodingEqNeqConstraints.</dd>
</dl>
</li>
</ul>
<a name="hasMaxNumCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxNumCuts</h4>
<pre>boolean&nbsp;hasMaxNumCuts()</pre>
<div class="block"><pre>
 The limit on the number of cuts in our cut pool. When this is reached we do
 not generate cuts anymore.

 TODO(user): We should probably remove this parameters, and just always
 generate cuts but only keep the best n or something.
 </pre>

 <code>optional int32 max_num_cuts = 91 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxNumCuts field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxNumCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxNumCuts</h4>
<pre>int&nbsp;getMaxNumCuts()</pre>
<div class="block"><pre>
 The limit on the number of cuts in our cut pool. When this is reached we do
 not generate cuts anymore.

 TODO(user): We should probably remove this parameters, and just always
 generate cuts but only keep the best n or something.
 </pre>

 <code>optional int32 max_num_cuts = 91 [default = 10000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxNumCuts.</dd>
</dl>
</li>
</ul>
<a name="hasCutLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCutLevel</h4>
<pre>boolean&nbsp;hasCutLevel()</pre>
<div class="block"><pre>
 Control the global cut effort. Zero will turn off all cut. For now we just
 have one level. Note also that most cuts are only used at linearization
 level &gt;= 2.
 </pre>

 <code>optional int32 cut_level = 196 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the cutLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getCutLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCutLevel</h4>
<pre>int&nbsp;getCutLevel()</pre>
<div class="block"><pre>
 Control the global cut effort. Zero will turn off all cut. For now we just
 have one level. Note also that most cuts are only used at linearization
 level &gt;= 2.
 </pre>

 <code>optional int32 cut_level = 196 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cutLevel.</dd>
</dl>
</li>
</ul>
<a name="hasOnlyAddCutsAtLevelZero--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasOnlyAddCutsAtLevelZero</h4>
<pre>boolean&nbsp;hasOnlyAddCutsAtLevelZero()</pre>
<div class="block"><pre>
 For the cut that can be generated at any level, this control if we only
 try to generate them at the root node.
 </pre>

 <code>optional bool only_add_cuts_at_level_zero = 92 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the onlyAddCutsAtLevelZero field is set.</dd>
</dl>
</li>
</ul>
<a name="getOnlyAddCutsAtLevelZero--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnlyAddCutsAtLevelZero</h4>
<pre>boolean&nbsp;getOnlyAddCutsAtLevelZero()</pre>
<div class="block"><pre>
 For the cut that can be generated at any level, this control if we only
 try to generate them at the root node.
 </pre>

 <code>optional bool only_add_cuts_at_level_zero = 92 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The onlyAddCutsAtLevelZero.</dd>
</dl>
</li>
</ul>
<a name="hasAddObjectiveCut--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddObjectiveCut</h4>
<pre>boolean&nbsp;hasAddObjectiveCut()</pre>
<div class="block"><pre>
 When the LP objective is fractional, do we add the cut that forces the
 linear objective expression to be greater or equal to this fractional value
 rounded up? We can always do that since our objective is integer, and
 combined with MIR heuristic to reduce the coefficient of such cut, it can
 help.
 </pre>

 <code>optional bool add_objective_cut = 197 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addObjectiveCut field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddObjectiveCut--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddObjectiveCut</h4>
<pre>boolean&nbsp;getAddObjectiveCut()</pre>
<div class="block"><pre>
 When the LP objective is fractional, do we add the cut that forces the
 linear objective expression to be greater or equal to this fractional value
 rounded up? We can always do that since our objective is integer, and
 combined with MIR heuristic to reduce the coefficient of such cut, it can
 help.
 </pre>

 <code>optional bool add_objective_cut = 197 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addObjectiveCut.</dd>
</dl>
</li>
</ul>
<a name="hasAddCgCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddCgCuts</h4>
<pre>boolean&nbsp;hasAddCgCuts()</pre>
<div class="block"><pre>
 Whether we generate and add Chvatal-Gomory cuts to the LP at root node.
 Note that for now, this is not heavily tuned.
 </pre>

 <code>optional bool add_cg_cuts = 117 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addCgCuts field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddCgCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddCgCuts</h4>
<pre>boolean&nbsp;getAddCgCuts()</pre>
<div class="block"><pre>
 Whether we generate and add Chvatal-Gomory cuts to the LP at root node.
 Note that for now, this is not heavily tuned.
 </pre>

 <code>optional bool add_cg_cuts = 117 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addCgCuts.</dd>
</dl>
</li>
</ul>
<a name="hasAddMirCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddMirCuts</h4>
<pre>boolean&nbsp;hasAddMirCuts()</pre>
<div class="block"><pre>
 Whether we generate MIR cuts at root node.
 Note that for now, this is not heavily tuned.
 </pre>

 <code>optional bool add_mir_cuts = 120 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addMirCuts field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddMirCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddMirCuts</h4>
<pre>boolean&nbsp;getAddMirCuts()</pre>
<div class="block"><pre>
 Whether we generate MIR cuts at root node.
 Note that for now, this is not heavily tuned.
 </pre>

 <code>optional bool add_mir_cuts = 120 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addMirCuts.</dd>
</dl>
</li>
</ul>
<a name="hasAddZeroHalfCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddZeroHalfCuts</h4>
<pre>boolean&nbsp;hasAddZeroHalfCuts()</pre>
<div class="block"><pre>
 Whether we generate Zero-Half cuts at root node.
 Note that for now, this is not heavily tuned.
 </pre>

 <code>optional bool add_zero_half_cuts = 169 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addZeroHalfCuts field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddZeroHalfCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddZeroHalfCuts</h4>
<pre>boolean&nbsp;getAddZeroHalfCuts()</pre>
<div class="block"><pre>
 Whether we generate Zero-Half cuts at root node.
 Note that for now, this is not heavily tuned.
 </pre>

 <code>optional bool add_zero_half_cuts = 169 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addZeroHalfCuts.</dd>
</dl>
</li>
</ul>
<a name="hasAddCliqueCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddCliqueCuts</h4>
<pre>boolean&nbsp;hasAddCliqueCuts()</pre>
<div class="block"><pre>
 Whether we generate clique cuts from the binary implication graph. Note
 that as the search goes on, this graph will contains new binary clauses
 learned by the SAT engine.
 </pre>

 <code>optional bool add_clique_cuts = 172 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addCliqueCuts field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddCliqueCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddCliqueCuts</h4>
<pre>boolean&nbsp;getAddCliqueCuts()</pre>
<div class="block"><pre>
 Whether we generate clique cuts from the binary implication graph. Note
 that as the search goes on, this graph will contains new binary clauses
 learned by the SAT engine.
 </pre>

 <code>optional bool add_clique_cuts = 172 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addCliqueCuts.</dd>
</dl>
</li>
</ul>
<a name="hasAddRltCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddRltCuts</h4>
<pre>boolean&nbsp;hasAddRltCuts()</pre>
<div class="block"><pre>
 Whether we generate RLT cuts. This is still experimental but can help on
 binary problem with a lot of clauses of size 3.
 </pre>

 <code>optional bool add_rlt_cuts = 279 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addRltCuts field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddRltCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddRltCuts</h4>
<pre>boolean&nbsp;getAddRltCuts()</pre>
<div class="block"><pre>
 Whether we generate RLT cuts. This is still experimental but can help on
 binary problem with a lot of clauses of size 3.
 </pre>

 <code>optional bool add_rlt_cuts = 279 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addRltCuts.</dd>
</dl>
</li>
</ul>
<a name="hasMaxAllDiffCutSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxAllDiffCutSize</h4>
<pre>boolean&nbsp;hasMaxAllDiffCutSize()</pre>
<div class="block"><pre>
 Cut generator for all diffs can add too many cuts for large all_diff
 constraints. This parameter restricts the large all_diff constraints to
 have a cut generator.
 </pre>

 <code>optional int32 max_all_diff_cut_size = 148 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxAllDiffCutSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxAllDiffCutSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxAllDiffCutSize</h4>
<pre>int&nbsp;getMaxAllDiffCutSize()</pre>
<div class="block"><pre>
 Cut generator for all diffs can add too many cuts for large all_diff
 constraints. This parameter restricts the large all_diff constraints to
 have a cut generator.
 </pre>

 <code>optional int32 max_all_diff_cut_size = 148 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxAllDiffCutSize.</dd>
</dl>
</li>
</ul>
<a name="hasAddLinMaxCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddLinMaxCuts</h4>
<pre>boolean&nbsp;hasAddLinMaxCuts()</pre>
<div class="block"><pre>
 For the lin max constraints, generates the cuts described in "Strong
 mixed-integer programming formulations for trained neural networks" by Ross
 Anderson et. (https://arxiv.org/pdf/1811.01988.pdf)
 </pre>

 <code>optional bool add_lin_max_cuts = 152 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addLinMaxCuts field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddLinMaxCuts--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddLinMaxCuts</h4>
<pre>boolean&nbsp;getAddLinMaxCuts()</pre>
<div class="block"><pre>
 For the lin max constraints, generates the cuts described in "Strong
 mixed-integer programming formulations for trained neural networks" by Ross
 Anderson et. (https://arxiv.org/pdf/1811.01988.pdf)
 </pre>

 <code>optional bool add_lin_max_cuts = 152 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addLinMaxCuts.</dd>
</dl>
</li>
</ul>
<a name="hasMaxIntegerRoundingScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxIntegerRoundingScaling</h4>
<pre>boolean&nbsp;hasMaxIntegerRoundingScaling()</pre>
<div class="block"><pre>
 In the integer rounding procedure used for MIR and Gomory cut, the maximum
 "scaling" we use (must be positive). The lower this is, the lower the
 integer coefficients of the cut will be. Note that cut generated by lower
 values are not necessarily worse than cut generated by larger value. There
 is no strict dominance relationship.

 Setting this to 2 result in the "strong fractional rouding" of Letchford
 and Lodi.
 </pre>

 <code>optional int32 max_integer_rounding_scaling = 119 [default = 600];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxIntegerRoundingScaling field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxIntegerRoundingScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxIntegerRoundingScaling</h4>
<pre>int&nbsp;getMaxIntegerRoundingScaling()</pre>
<div class="block"><pre>
 In the integer rounding procedure used for MIR and Gomory cut, the maximum
 "scaling" we use (must be positive). The lower this is, the lower the
 integer coefficients of the cut will be. Note that cut generated by lower
 values are not necessarily worse than cut generated by larger value. There
 is no strict dominance relationship.

 Setting this to 2 result in the "strong fractional rouding" of Letchford
 and Lodi.
 </pre>

 <code>optional int32 max_integer_rounding_scaling = 119 [default = 600];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxIntegerRoundingScaling.</dd>
</dl>
</li>
</ul>
<a name="hasAddLpConstraintsLazily--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAddLpConstraintsLazily</h4>
<pre>boolean&nbsp;hasAddLpConstraintsLazily()</pre>
<div class="block"><pre>
 If true, we start by an empty LP, and only add constraints not satisfied
 by the current LP solution batch by batch. A constraint that is only added
 like this is known as a "lazy" constraint in the literature, except that we
 currently consider all constraints as lazy here.
 </pre>

 <code>optional bool add_lp_constraints_lazily = 112 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the addLpConstraintsLazily field is set.</dd>
</dl>
</li>
</ul>
<a name="getAddLpConstraintsLazily--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAddLpConstraintsLazily</h4>
<pre>boolean&nbsp;getAddLpConstraintsLazily()</pre>
<div class="block"><pre>
 If true, we start by an empty LP, and only add constraints not satisfied
 by the current LP solution batch by batch. A constraint that is only added
 like this is known as a "lazy" constraint in the literature, except that we
 currently consider all constraints as lazy here.
 </pre>

 <code>optional bool add_lp_constraints_lazily = 112 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The addLpConstraintsLazily.</dd>
</dl>
</li>
</ul>
<a name="hasRootLpIterations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRootLpIterations</h4>
<pre>boolean&nbsp;hasRootLpIterations()</pre>
<div class="block"><pre>
 Even at the root node, we do not want to spend too much time on the LP if
 it is "difficult". So we solve it in "chunks" of that many iterations. The
 solve will be continued down in the tree or the next time we go back to the
 root node.
 </pre>

 <code>optional int32 root_lp_iterations = 227 [default = 2000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the rootLpIterations field is set.</dd>
</dl>
</li>
</ul>
<a name="getRootLpIterations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRootLpIterations</h4>
<pre>int&nbsp;getRootLpIterations()</pre>
<div class="block"><pre>
 Even at the root node, we do not want to spend too much time on the LP if
 it is "difficult". So we solve it in "chunks" of that many iterations. The
 solve will be continued down in the tree or the next time we go back to the
 root node.
 </pre>

 <code>optional int32 root_lp_iterations = 227 [default = 2000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The rootLpIterations.</dd>
</dl>
</li>
</ul>
<a name="hasMinOrthogonalityForLpConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMinOrthogonalityForLpConstraints</h4>
<pre>boolean&nbsp;hasMinOrthogonalityForLpConstraints()</pre>
<div class="block"><pre>
 While adding constraints, skip the constraints which have orthogonality
 less than 'min_orthogonality_for_lp_constraints' with already added
 constraints during current call. Orthogonality is defined as 1 -
 cosine(vector angle between constraints). A value of zero disable this
 feature.
 </pre>

 <code>optional double min_orthogonality_for_lp_constraints = 115 [default = 0.05];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the minOrthogonalityForLpConstraints field is set.</dd>
</dl>
</li>
</ul>
<a name="getMinOrthogonalityForLpConstraints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMinOrthogonalityForLpConstraints</h4>
<pre>double&nbsp;getMinOrthogonalityForLpConstraints()</pre>
<div class="block"><pre>
 While adding constraints, skip the constraints which have orthogonality
 less than 'min_orthogonality_for_lp_constraints' with already added
 constraints during current call. Orthogonality is defined as 1 -
 cosine(vector angle between constraints). A value of zero disable this
 feature.
 </pre>

 <code>optional double min_orthogonality_for_lp_constraints = 115 [default = 0.05];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The minOrthogonalityForLpConstraints.</dd>
</dl>
</li>
</ul>
<a name="hasMaxCutRoundsAtLevelZero--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxCutRoundsAtLevelZero</h4>
<pre>boolean&nbsp;hasMaxCutRoundsAtLevelZero()</pre>
<div class="block"><pre>
 Max number of time we perform cut generation and resolve the LP at level 0.
 </pre>

 <code>optional int32 max_cut_rounds_at_level_zero = 154 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxCutRoundsAtLevelZero field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxCutRoundsAtLevelZero--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxCutRoundsAtLevelZero</h4>
<pre>int&nbsp;getMaxCutRoundsAtLevelZero()</pre>
<div class="block"><pre>
 Max number of time we perform cut generation and resolve the LP at level 0.
 </pre>

 <code>optional int32 max_cut_rounds_at_level_zero = 154 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxCutRoundsAtLevelZero.</dd>
</dl>
</li>
</ul>
<a name="hasMaxConsecutiveInactiveCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMaxConsecutiveInactiveCount</h4>
<pre>boolean&nbsp;hasMaxConsecutiveInactiveCount()</pre>
<div class="block"><pre>
 If a constraint/cut in LP is not active for that many consecutive OPTIMAL
 solves, remove it from the LP. Note that it might be added again later if
 it become violated by the current LP solution.
 </pre>

 <code>optional int32 max_consecutive_inactive_count = 121 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the maxConsecutiveInactiveCount field is set.</dd>
</dl>
</li>
</ul>
<a name="getMaxConsecutiveInactiveCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxConsecutiveInactiveCount</h4>
<pre>int&nbsp;getMaxConsecutiveInactiveCount()</pre>
<div class="block"><pre>
 If a constraint/cut in LP is not active for that many consecutive OPTIMAL
 solves, remove it from the LP. Note that it might be added again later if
 it become violated by the current LP solution.
 </pre>

 <code>optional int32 max_consecutive_inactive_count = 121 [default = 100];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The maxConsecutiveInactiveCount.</dd>
</dl>
</li>
</ul>
<a name="hasCutMaxActiveCountValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCutMaxActiveCountValue</h4>
<pre>boolean&nbsp;hasCutMaxActiveCountValue()</pre>
<div class="block"><pre>
 These parameters are similar to sat clause management activity parameters.
 They are effective only if the number of generated cuts exceed the storage
 limit. Default values are based on a few experiments on miplib instances.
 </pre>

 <code>optional double cut_max_active_count_value = 155 [default = 10000000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the cutMaxActiveCountValue field is set.</dd>
</dl>
</li>
</ul>
<a name="getCutMaxActiveCountValue--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCutMaxActiveCountValue</h4>
<pre>double&nbsp;getCutMaxActiveCountValue()</pre>
<div class="block"><pre>
 These parameters are similar to sat clause management activity parameters.
 They are effective only if the number of generated cuts exceed the storage
 limit. Default values are based on a few experiments on miplib instances.
 </pre>

 <code>optional double cut_max_active_count_value = 155 [default = 10000000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cutMaxActiveCountValue.</dd>
</dl>
</li>
</ul>
<a name="hasCutActiveCountDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCutActiveCountDecay</h4>
<pre>boolean&nbsp;hasCutActiveCountDecay()</pre>
<div class="block"><code>optional double cut_active_count_decay = 156 [default = 0.8];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the cutActiveCountDecay field is set.</dd>
</dl>
</li>
</ul>
<a name="getCutActiveCountDecay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCutActiveCountDecay</h4>
<pre>double&nbsp;getCutActiveCountDecay()</pre>
<div class="block"><code>optional double cut_active_count_decay = 156 [default = 0.8];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cutActiveCountDecay.</dd>
</dl>
</li>
</ul>
<a name="hasCutCleanupTarget--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasCutCleanupTarget</h4>
<pre>boolean&nbsp;hasCutCleanupTarget()</pre>
<div class="block"><pre>
 Target number of constraints to remove during cleanup.
 </pre>

 <code>optional int32 cut_cleanup_target = 157 [default = 1000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the cutCleanupTarget field is set.</dd>
</dl>
</li>
</ul>
<a name="getCutCleanupTarget--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCutCleanupTarget</h4>
<pre>int&nbsp;getCutCleanupTarget()</pre>
<div class="block"><pre>
 Target number of constraints to remove during cleanup.
 </pre>

 <code>optional int32 cut_cleanup_target = 157 [default = 1000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cutCleanupTarget.</dd>
</dl>
</li>
</ul>
<a name="hasNewConstraintsBatchSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNewConstraintsBatchSize</h4>
<pre>boolean&nbsp;hasNewConstraintsBatchSize()</pre>
<div class="block"><pre>
 Add that many lazy constraints (or cuts) at once in the LP. Note that at
 the beginning of the solve, we do add more than this.
 </pre>

 <code>optional int32 new_constraints_batch_size = 122 [default = 50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the newConstraintsBatchSize field is set.</dd>
</dl>
</li>
</ul>
<a name="getNewConstraintsBatchSize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNewConstraintsBatchSize</h4>
<pre>int&nbsp;getNewConstraintsBatchSize()</pre>
<div class="block"><pre>
 Add that many lazy constraints (or cuts) at once in the LP. Note that at
 the beginning of the solve, we do add more than this.
 </pre>

 <code>optional int32 new_constraints_batch_size = 122 [default = 50];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The newConstraintsBatchSize.</dd>
</dl>
</li>
</ul>
<a name="hasExploitIntegerLpSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitIntegerLpSolution</h4>
<pre>boolean&nbsp;hasExploitIntegerLpSolution()</pre>
<div class="block"><pre>
 If true and the Lp relaxation of the problem has an integer optimal
 solution, try to exploit it. Note that since the LP relaxation may not
 contain all the constraints, such a solution is not necessarily a solution
 of the full problem.
 </pre>

 <code>optional bool exploit_integer_lp_solution = 94 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitIntegerLpSolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getExploitIntegerLpSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitIntegerLpSolution</h4>
<pre>boolean&nbsp;getExploitIntegerLpSolution()</pre>
<div class="block"><pre>
 If true and the Lp relaxation of the problem has an integer optimal
 solution, try to exploit it. Note that since the LP relaxation may not
 contain all the constraints, such a solution is not necessarily a solution
 of the full problem.
 </pre>

 <code>optional bool exploit_integer_lp_solution = 94 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitIntegerLpSolution.</dd>
</dl>
</li>
</ul>
<a name="hasExploitAllLpSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitAllLpSolution</h4>
<pre>boolean&nbsp;hasExploitAllLpSolution()</pre>
<div class="block"><pre>
 If true and the Lp relaxation of the problem has a solution, try to exploit
 it. This is same as above except in this case the lp solution might not be
 an integer solution.
 </pre>

 <code>optional bool exploit_all_lp_solution = 116 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitAllLpSolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getExploitAllLpSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitAllLpSolution</h4>
<pre>boolean&nbsp;getExploitAllLpSolution()</pre>
<div class="block"><pre>
 If true and the Lp relaxation of the problem has a solution, try to exploit
 it. This is same as above except in this case the lp solution might not be
 an integer solution.
 </pre>

 <code>optional bool exploit_all_lp_solution = 116 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitAllLpSolution.</dd>
</dl>
</li>
</ul>
<a name="hasExploitBestSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitBestSolution</h4>
<pre>boolean&nbsp;hasExploitBestSolution()</pre>
<div class="block"><pre>
 When branching on a variable, follow the last best solution value.
 </pre>

 <code>optional bool exploit_best_solution = 130 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitBestSolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getExploitBestSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitBestSolution</h4>
<pre>boolean&nbsp;getExploitBestSolution()</pre>
<div class="block"><pre>
 When branching on a variable, follow the last best solution value.
 </pre>

 <code>optional bool exploit_best_solution = 130 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitBestSolution.</dd>
</dl>
</li>
</ul>
<a name="hasExploitRelaxationSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitRelaxationSolution</h4>
<pre>boolean&nbsp;hasExploitRelaxationSolution()</pre>
<div class="block"><pre>
 When branching on a variable, follow the last best relaxation solution
 value. We use the relaxation with the tightest bound on the objective as
 the best relaxation solution.
 </pre>

 <code>optional bool exploit_relaxation_solution = 161 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitRelaxationSolution field is set.</dd>
</dl>
</li>
</ul>
<a name="getExploitRelaxationSolution--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitRelaxationSolution</h4>
<pre>boolean&nbsp;getExploitRelaxationSolution()</pre>
<div class="block"><pre>
 When branching on a variable, follow the last best relaxation solution
 value. We use the relaxation with the tightest bound on the objective as
 the best relaxation solution.
 </pre>

 <code>optional bool exploit_relaxation_solution = 161 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitRelaxationSolution.</dd>
</dl>
</li>
</ul>
<a name="hasExploitObjective--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasExploitObjective</h4>
<pre>boolean&nbsp;hasExploitObjective()</pre>
<div class="block"><pre>
 When branching an a variable that directly affect the objective,
 branch on the value that lead to the best objective first.
 </pre>

 <code>optional bool exploit_objective = 131 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the exploitObjective field is set.</dd>
</dl>
</li>
</ul>
<a name="getExploitObjective--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExploitObjective</h4>
<pre>boolean&nbsp;getExploitObjective()</pre>
<div class="block"><pre>
 When branching an a variable that directly affect the objective,
 branch on the value that lead to the best objective first.
 </pre>

 <code>optional bool exploit_objective = 131 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The exploitObjective.</dd>
</dl>
</li>
</ul>
<a name="hasDetectLinearizedProduct--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDetectLinearizedProduct</h4>
<pre>boolean&nbsp;hasDetectLinearizedProduct()</pre>
<div class="block"><pre>
 Infer products of Boolean or of Boolean time IntegerVariable from the
 linear constrainst in the problem. This can be used in some cuts, altough
 for now we don't really exploit it.
 </pre>

 <code>optional bool detect_linearized_product = 277 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the detectLinearizedProduct field is set.</dd>
</dl>
</li>
</ul>
<a name="getDetectLinearizedProduct--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDetectLinearizedProduct</h4>
<pre>boolean&nbsp;getDetectLinearizedProduct()</pre>
<div class="block"><pre>
 Infer products of Boolean or of Boolean time IntegerVariable from the
 linear constrainst in the problem. This can be used in some cuts, altough
 for now we don't really exploit it.
 </pre>

 <code>optional bool detect_linearized_product = 277 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The detectLinearizedProduct.</dd>
</dl>
</li>
</ul>
<a name="hasMipMaxBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipMaxBound</h4>
<pre>boolean&nbsp;hasMipMaxBound()</pre>
<div class="block"><pre>
 We need to bound the maximum magnitude of the variables for CP-SAT, and
 that is the bound we use. If the MIP model expect larger variable value in
 the solution, then the converted model will likely not be relevant.
 </pre>

 <code>optional double mip_max_bound = 124 [default = 10000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipMaxBound field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipMaxBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipMaxBound</h4>
<pre>double&nbsp;getMipMaxBound()</pre>
<div class="block"><pre>
 We need to bound the maximum magnitude of the variables for CP-SAT, and
 that is the bound we use. If the MIP model expect larger variable value in
 the solution, then the converted model will likely not be relevant.
 </pre>

 <code>optional double mip_max_bound = 124 [default = 10000000];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipMaxBound.</dd>
</dl>
</li>
</ul>
<a name="hasMipVarScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipVarScaling</h4>
<pre>boolean&nbsp;hasMipVarScaling()</pre>
<div class="block"><pre>
 All continuous variable of the problem will be multiplied by this factor.
 By default, we don't do any variable scaling and rely on the MIP model to
 specify continuous variable domain with the wanted precision.
 </pre>

 <code>optional double mip_var_scaling = 125 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipVarScaling field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipVarScaling--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipVarScaling</h4>
<pre>double&nbsp;getMipVarScaling()</pre>
<div class="block"><pre>
 All continuous variable of the problem will be multiplied by this factor.
 By default, we don't do any variable scaling and rely on the MIP model to
 specify continuous variable domain with the wanted precision.
 </pre>

 <code>optional double mip_var_scaling = 125 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipVarScaling.</dd>
</dl>
</li>
</ul>
<a name="hasMipScaleLargeDomain--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipScaleLargeDomain</h4>
<pre>boolean&nbsp;hasMipScaleLargeDomain()</pre>
<div class="block"><pre>
 If this is false, then mip_var_scaling is only applied to variables with
 "small" domain. If it is true, we scale all floating point variable
 independenlty of their domain.
 </pre>

 <code>optional bool mip_scale_large_domain = 225 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipScaleLargeDomain field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipScaleLargeDomain--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipScaleLargeDomain</h4>
<pre>boolean&nbsp;getMipScaleLargeDomain()</pre>
<div class="block"><pre>
 If this is false, then mip_var_scaling is only applied to variables with
 "small" domain. If it is true, we scale all floating point variable
 independenlty of their domain.
 </pre>

 <code>optional bool mip_scale_large_domain = 225 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipScaleLargeDomain.</dd>
</dl>
</li>
</ul>
<a name="hasMipAutomaticallyScaleVariables--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipAutomaticallyScaleVariables</h4>
<pre>boolean&nbsp;hasMipAutomaticallyScaleVariables()</pre>
<div class="block"><pre>
 If true, some continuous variable might be automatically scaled. For now,
 this is only the case where we detect that a variable is actually an
 integer multiple of a constant. For instance, variables of the form k * 0.5
 are quite frequent, and if we detect this, we will scale such variable
 domain by 2 to make it implied integer.
 </pre>

 <code>optional bool mip_automatically_scale_variables = 166 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipAutomaticallyScaleVariables field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipAutomaticallyScaleVariables--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipAutomaticallyScaleVariables</h4>
<pre>boolean&nbsp;getMipAutomaticallyScaleVariables()</pre>
<div class="block"><pre>
 If true, some continuous variable might be automatically scaled. For now,
 this is only the case where we detect that a variable is actually an
 integer multiple of a constant. For instance, variables of the form k * 0.5
 are quite frequent, and if we detect this, we will scale such variable
 domain by 2 to make it implied integer.
 </pre>

 <code>optional bool mip_automatically_scale_variables = 166 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipAutomaticallyScaleVariables.</dd>
</dl>
</li>
</ul>
<a name="hasOnlySolveIp--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasOnlySolveIp</h4>
<pre>boolean&nbsp;hasOnlySolveIp()</pre>
<div class="block"><pre>
 If one try to solve a MIP model with CP-SAT, because we assume all variable
 to be integer after scaling, we will not necessarily have the correct
 optimal. Note however that all feasible solutions are valid since we will
 just solve a more restricted version of the original problem.

 This parameters is here to prevent user to think the solution is optimal
 when it might not be. One will need to manually set this to false to solve
 a MIP model where the optimal might be different.

 Note that this is tested after some MIP presolve steps, so even if not
 all original variable are integer, we might end up with a pure IP after
 presolve and after implied integer detection.
 </pre>

 <code>optional bool only_solve_ip = 222 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the onlySolveIp field is set.</dd>
</dl>
</li>
</ul>
<a name="getOnlySolveIp--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOnlySolveIp</h4>
<pre>boolean&nbsp;getOnlySolveIp()</pre>
<div class="block"><pre>
 If one try to solve a MIP model with CP-SAT, because we assume all variable
 to be integer after scaling, we will not necessarily have the correct
 optimal. Note however that all feasible solutions are valid since we will
 just solve a more restricted version of the original problem.

 This parameters is here to prevent user to think the solution is optimal
 when it might not be. One will need to manually set this to false to solve
 a MIP model where the optimal might be different.

 Note that this is tested after some MIP presolve steps, so even if not
 all original variable are integer, we might end up with a pure IP after
 presolve and after implied integer detection.
 </pre>

 <code>optional bool only_solve_ip = 222 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The onlySolveIp.</dd>
</dl>
</li>
</ul>
<a name="hasMipWantedPrecision--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipWantedPrecision</h4>
<pre>boolean&nbsp;hasMipWantedPrecision()</pre>
<div class="block"><pre>
 When scaling constraint with double coefficients to integer coefficients,
 we will multiply by a power of 2 and round the coefficients. We will choose
 the lowest power such that we have no potential overflow (see
 mip_max_activity_exponent) and the worst case constraint activity error
 does not exceed this threshold.

 Note that we also detect constraint with rational coefficients and scale
 them accordingly when it seems better instead of using a power of 2.

 We also relax all constraint bounds by this absolute value. For pure
 integer constraint, if this value if lower than one, this will not change
 anything. However it is needed when scaling MIP problems.

 If we manage to scale a constraint correctly, the maximum error we can make
 will be twice this value (once for the scaling error and once for the
 relaxed bounds). If we are not able to scale that well, we will display
 that fact but still scale as best as we can.
 </pre>

 <code>optional double mip_wanted_precision = 126 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipWantedPrecision field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipWantedPrecision--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipWantedPrecision</h4>
<pre>double&nbsp;getMipWantedPrecision()</pre>
<div class="block"><pre>
 When scaling constraint with double coefficients to integer coefficients,
 we will multiply by a power of 2 and round the coefficients. We will choose
 the lowest power such that we have no potential overflow (see
 mip_max_activity_exponent) and the worst case constraint activity error
 does not exceed this threshold.

 Note that we also detect constraint with rational coefficients and scale
 them accordingly when it seems better instead of using a power of 2.

 We also relax all constraint bounds by this absolute value. For pure
 integer constraint, if this value if lower than one, this will not change
 anything. However it is needed when scaling MIP problems.

 If we manage to scale a constraint correctly, the maximum error we can make
 will be twice this value (once for the scaling error and once for the
 relaxed bounds). If we are not able to scale that well, we will display
 that fact but still scale as best as we can.
 </pre>

 <code>optional double mip_wanted_precision = 126 [default = 1e-06];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipWantedPrecision.</dd>
</dl>
</li>
</ul>
<a name="hasMipMaxActivityExponent--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipMaxActivityExponent</h4>
<pre>boolean&nbsp;hasMipMaxActivityExponent()</pre>
<div class="block"><pre>
 To avoid integer overflow, we always force the maximum possible constraint
 activity (and objective value) according to the initial variable domain to
 be smaller than 2 to this given power. Because of this, we cannot always
 reach the "mip_wanted_precision" parameter above.

 This can go as high as 62, but some internal algo currently abort early if
 they might run into integer overflow, so it is better to keep it a bit
 lower than this.
 </pre>

 <code>optional int32 mip_max_activity_exponent = 127 [default = 53];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipMaxActivityExponent field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipMaxActivityExponent--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipMaxActivityExponent</h4>
<pre>int&nbsp;getMipMaxActivityExponent()</pre>
<div class="block"><pre>
 To avoid integer overflow, we always force the maximum possible constraint
 activity (and objective value) according to the initial variable domain to
 be smaller than 2 to this given power. Because of this, we cannot always
 reach the "mip_wanted_precision" parameter above.

 This can go as high as 62, but some internal algo currently abort early if
 they might run into integer overflow, so it is better to keep it a bit
 lower than this.
 </pre>

 <code>optional int32 mip_max_activity_exponent = 127 [default = 53];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipMaxActivityExponent.</dd>
</dl>
</li>
</ul>
<a name="hasMipCheckPrecision--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipCheckPrecision</h4>
<pre>boolean&nbsp;hasMipCheckPrecision()</pre>
<div class="block"><pre>
 As explained in mip_precision and mip_max_activity_exponent, we cannot
 always reach the wanted precision during scaling. We use this threshold to
 enphasize in the logs when the precision seems bad.
 </pre>

 <code>optional double mip_check_precision = 128 [default = 0.0001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipCheckPrecision field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipCheckPrecision--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipCheckPrecision</h4>
<pre>double&nbsp;getMipCheckPrecision()</pre>
<div class="block"><pre>
 As explained in mip_precision and mip_max_activity_exponent, we cannot
 always reach the wanted precision during scaling. We use this threshold to
 enphasize in the logs when the precision seems bad.
 </pre>

 <code>optional double mip_check_precision = 128 [default = 0.0001];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipCheckPrecision.</dd>
</dl>
</li>
</ul>
<a name="hasMipComputeTrueObjectiveBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipComputeTrueObjectiveBound</h4>
<pre>boolean&nbsp;hasMipComputeTrueObjectiveBound()</pre>
<div class="block"><pre>
 Even if we make big error when scaling the objective, we can always derive
 a correct lower bound on the original objective by using the exact lower
 bound on the scaled integer version of the objective. This should be fast,
 but if you don't care about having a precise lower bound, you can turn it
 off.
 </pre>

 <code>optional bool mip_compute_true_objective_bound = 198 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipComputeTrueObjectiveBound field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipComputeTrueObjectiveBound--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipComputeTrueObjectiveBound</h4>
<pre>boolean&nbsp;getMipComputeTrueObjectiveBound()</pre>
<div class="block"><pre>
 Even if we make big error when scaling the objective, we can always derive
 a correct lower bound on the original objective by using the exact lower
 bound on the scaled integer version of the objective. This should be fast,
 but if you don't care about having a precise lower bound, you can turn it
 off.
 </pre>

 <code>optional bool mip_compute_true_objective_bound = 198 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipComputeTrueObjectiveBound.</dd>
</dl>
</li>
</ul>
<a name="hasMipMaxValidMagnitude--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipMaxValidMagnitude</h4>
<pre>boolean&nbsp;hasMipMaxValidMagnitude()</pre>
<div class="block"><pre>
 Any finite values in the input MIP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. We are a bit more
 defensive, but in practice, users shouldn't use super large values in a
 MIP.
 </pre>

 <code>optional double mip_max_valid_magnitude = 199 [default = 1e+20];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipMaxValidMagnitude field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipMaxValidMagnitude--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipMaxValidMagnitude</h4>
<pre>double&nbsp;getMipMaxValidMagnitude()</pre>
<div class="block"><pre>
 Any finite values in the input MIP must be below this threshold, otherwise
 the model will be reported invalid. This is needed to avoid floating point
 overflow when evaluating bounds * coeff for instance. We are a bit more
 defensive, but in practice, users shouldn't use super large values in a
 MIP.
 </pre>

 <code>optional double mip_max_valid_magnitude = 199 [default = 1e+20];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipMaxValidMagnitude.</dd>
</dl>
</li>
</ul>
<a name="hasMipTreatHighMagnitudeBoundsAsInfinity--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipTreatHighMagnitudeBoundsAsInfinity</h4>
<pre>boolean&nbsp;hasMipTreatHighMagnitudeBoundsAsInfinity()</pre>
<div class="block"><pre>
 By default, any variable/constraint bound with a finite value and a
 magnitude greater than the mip_max_valid_magnitude will result with a
 invalid model. This flags change the behavior such that such bounds are
 silently transformed to + or -.

 It is recommended to keep it at false, and create valid bounds.
 </pre>

 <code>optional bool mip_treat_high_magnitude_bounds_as_infinity = 278 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipTreatHighMagnitudeBoundsAsInfinity field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipTreatHighMagnitudeBoundsAsInfinity--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipTreatHighMagnitudeBoundsAsInfinity</h4>
<pre>boolean&nbsp;getMipTreatHighMagnitudeBoundsAsInfinity()</pre>
<div class="block"><pre>
 By default, any variable/constraint bound with a finite value and a
 magnitude greater than the mip_max_valid_magnitude will result with a
 invalid model. This flags change the behavior such that such bounds are
 silently transformed to + or -.

 It is recommended to keep it at false, and create valid bounds.
 </pre>

 <code>optional bool mip_treat_high_magnitude_bounds_as_infinity = 278 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipTreatHighMagnitudeBoundsAsInfinity.</dd>
</dl>
</li>
</ul>
<a name="hasMipDropTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipDropTolerance</h4>
<pre>boolean&nbsp;hasMipDropTolerance()</pre>
<div class="block"><pre>
 Any value in the input mip with a magnitude lower than this will be set to
 zero. This is to avoid some issue in LP presolving.
 </pre>

 <code>optional double mip_drop_tolerance = 232 [default = 1e-16];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipDropTolerance field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipDropTolerance--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMipDropTolerance</h4>
<pre>double&nbsp;getMipDropTolerance()</pre>
<div class="block"><pre>
 Any value in the input mip with a magnitude lower than this will be set to
 zero. This is to avoid some issue in LP presolving.
 </pre>

 <code>optional double mip_drop_tolerance = 232 [default = 1e-16];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipDropTolerance.</dd>
</dl>
</li>
</ul>
<a name="hasMipPresolveLevel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMipPresolveLevel</h4>
<pre>boolean&nbsp;hasMipPresolveLevel()</pre>
<div class="block"><pre>
 When solving a MIP, we do some basic floating point presolving before
 scaling the problem to integer to be handled by CP-SAT. This control how
 much of that presolve we do. It can help to better scale floating point
 model, but it is not always behaving nicely.
 </pre>

 <code>optional int32 mip_presolve_level = 261 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the mipPresolveLevel field is set.</dd>
</dl>
</li>
</ul>
<a name="getMipPresolveLevel--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getMipPresolveLevel</h4>
<pre>int&nbsp;getMipPresolveLevel()</pre>
<div class="block"><pre>
 When solving a MIP, we do some basic floating point presolving before
 scaling the problem to integer to be handled by CP-SAT. This control how
 much of that presolve we do. It can help to better scale floating point
 model, but it is not always behaving nicely.
 </pre>

 <code>optional int32 mip_presolve_level = 261 [default = 2];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The mipPresolveLevel.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/SatParametersOrBuilder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/ortools/sat/SatParameters.VariableOrder.html" title="enum in com.google.ortools.sat"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../com/google/ortools/sat/SatParametersOuterClass.html" title="class in com.google.ortools.sat"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/ortools/sat/SatParametersOrBuilder.html" target="_top">Frames</a></li>
<li><a href="SatParametersOrBuilder.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2025. All rights reserved.</small></p>
</body>
</html>
