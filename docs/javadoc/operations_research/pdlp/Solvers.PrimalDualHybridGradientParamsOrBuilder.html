<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.18) on Fri Mar 10 09:56:32 CET 2023 -->
<title>Solvers.PrimalDualHybridGradientParamsOrBuilder (com.google.ortools:ortools-java 9.6.2534 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2023-03-10">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Solvers.PrimalDualHybridGradientParamsOrBuilder (com.google.ortools:ortools-java 9.6.2534 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6,"i23":6,"i24":6,"i25":6,"i26":6,"i27":6,"i28":6,"i29":6,"i30":6,"i31":6,"i32":6,"i33":6,"i34":6,"i35":6,"i36":6,"i37":6,"i38":6,"i39":6,"i40":6,"i41":6,"i42":6,"i43":6,"i44":6,"i45":6,"i46":6,"i47":6,"i48":6,"i49":6,"i50":6,"i51":6,"i52":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Solvers.PrimalDualHybridGradientParamsOrBuilder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">operations_research.pdlp</a></div>
<h2 title="Interface Solvers.PrimalDualHybridGradientParamsOrBuilder" class="title">Interface Solvers.PrimalDualHybridGradientParamsOrBuilder</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd><code>com.google.protobuf.MessageLiteOrBuilder</code>, <code>com.google.protobuf.MessageOrBuilder</code></dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="Solvers.PrimalDualHybridGradientParams.html" title="class in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams</a></code>, <code><a href="Solvers.PrimalDualHybridGradientParams.Builder.html" title="class in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.Builder</a></code></dd>
</dl>
<dl>
<dt>Enclosing class:</dt>
<dd><a href="Solvers.html" title="class in operations_research.pdlp">Solvers</a></dd>
</dl>
<hr>
<pre>public static interface <span class="typeNameLabel">Solvers.PrimalDualHybridGradientParamsOrBuilder</span>
extends com.google.protobuf.MessageOrBuilder</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="Solvers.AdaptiveLinesearchParams.html" title="class in operations_research.pdlp">Solvers.AdaptiveLinesearchParams</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAdaptiveLinesearchParameters()">getAdaptiveLinesearchParameters</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.AdaptiveLinesearchParams adaptive_linesearch_parameters = 18;</code></div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="Solvers.AdaptiveLinesearchParamsOrBuilder.html" title="interface in operations_research.pdlp">Solvers.AdaptiveLinesearchParamsOrBuilder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAdaptiveLinesearchParametersOrBuilder()">getAdaptiveLinesearchParametersOrBuilder</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.AdaptiveLinesearchParams adaptive_linesearch_parameters = 18;</code></div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDiagonalQpTrustRegionSolverTolerance()">getDiagonalQpTrustRegionSolverTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The solve tolerance of the experimental trust region solver for diagonal
 QPs, controlling the accuracy of binary search over a one-dimensional
 scaling parameter.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getHandleSomePrimalGradientsOnFiniteBoundsAsResiduals()">getHandleSomePrimalGradientsOnFiniteBoundsAsResiduals</a></span>()</code></th>
<td class="colLast">
<div class="block">
 See https://developers.google.com/optimization/lp/pdlp_math for notation.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInfiniteConstraintBoundThreshold()">getInfiniteConstraintBoundThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When computing relative feasibility norms, constraint bounds with absolute
 value at least this threshold are treated as infinite, and hence not
 included in the relative feasibility norm.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInitialPrimalWeight()">getInitialPrimalWeight</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The initial value of the primal weight (i.e., the ratio of primal and dual
 step sizes).</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInitialStepSizeScaling()">getInitialStepSizeScaling</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Scaling factor applied to the initial step size (all step sizes if
 linesearch_rule == CONSTANT_STEP_SIZE_RULE).</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getL2NormRescaling()">getL2NormRescaling</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, applies L_2 norm rescaling after the Ruiz rescaling.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="Solvers.PrimalDualHybridGradientParams.LinesearchRule.html" title="enum in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.LinesearchRule</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLinesearchRule()">getLinesearchRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Linesearch rule applied at each major iteration.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLInfRuizIterations()">getLInfRuizIterations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of L_infinity Ruiz rescaling iterations to apply to the constraint
 matrix.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMajorIterationFrequency()">getMajorIterationFrequency</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The frequency at which extra work is performed to make major algorithmic
 decisions, e.g., performing restarts and updating the primal weight.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="Solvers.MalitskyPockParams.html" title="class in operations_research.pdlp">Solvers.MalitskyPockParams</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMalitskyPockParameters()">getMalitskyPockParameters</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.MalitskyPockParams malitsky_pock_parameters = 19;</code></div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="Solvers.MalitskyPockParamsOrBuilder.html" title="interface in operations_research.pdlp">Solvers.MalitskyPockParamsOrBuilder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMalitskyPockParametersOrBuilder()">getMalitskyPockParametersOrBuilder</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.MalitskyPockParams malitsky_pock_parameters = 19;</code></div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNecessaryReductionForRestart()">getNecessaryReductionForRestart</a></span>()</code></th>
<td class="colLast">
<div class="block">
 For ADAPTIVE_HEURISTIC only: A relative reduction in the potential function
 by this amount triggers a restart if, additionally, the quality of the
 iterates appears to be getting worse.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNumShards()">getNumShards</a></span>()</code></th>
<td class="colLast">
<div class="block">
 For more efficient parallel computation, the matrices and vectors are
 divided (virtually) into num_shards shards.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNumThreads()">getNumThreads</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The number of threads to use.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Solvers.PrimalDualHybridGradientParams.PresolveOptions.html" title="class in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.PresolveOptions</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPresolveOptions()">getPresolveOptions</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.PresolveOptions presolve_options = 16;</code></div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="Solvers.PrimalDualHybridGradientParams.PresolveOptionsOrBuilder.html" title="interface in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.PresolveOptionsOrBuilder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPresolveOptionsOrBuilder()">getPresolveOptionsOrBuilder</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.PresolveOptions presolve_options = 16;</code></div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPrimalWeightUpdateSmoothing()">getPrimalWeightUpdateSmoothing</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This parameter controls exponential smoothing of log(primal_weight) when a
 primal weight update occurs (i.e., when the ratio of primal and dual step
 sizes is adjusted).</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRandomProjectionSeeds(int)">getRandomProjectionSeeds</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">
 Seeds for generating (pseudo-)random projections of iterates during
 termination checks.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRandomProjectionSeedsCount()">getRandomProjectionSeedsCount</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Seeds for generating (pseudo-)random projections of iterates during
 termination checks.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Integer&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRandomProjectionSeedsList()">getRandomProjectionSeedsList</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Seeds for generating (pseudo-)random projections of iterates during
 termination checks.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRecordIterationStats()">getRecordIterationStats</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, the iteration_stats field of the SolveLog output will be populated
 at every iteration.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="Solvers.PrimalDualHybridGradientParams.RestartStrategy.html" title="enum in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.RestartStrategy</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRestartStrategy()">getRestartStrategy</a></span>()</code></th>
<td class="colLast">
<div class="block">
 NO_RESTARTS and EVERY_MAJOR_ITERATION occasionally outperform the default.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSufficientReductionForRestart()">getSufficientReductionForRestart</a></span>()</code></th>
<td class="colLast">
<div class="block">
 For ADAPTIVE_HEURISTIC and ADAPTIVE_DISTANCE_BASED only: A relative
 reduction in the potential function by this amount always triggers a
 restart.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTerminationCheckFrequency()">getTerminationCheckFrequency</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The frequency (based on a counter reset every major iteration) to check for
 termination (involves extra work) and log iteration stats.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="Solvers.TerminationCriteria.html" title="class in operations_research.pdlp">Solvers.TerminationCriteria</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTerminationCriteria()">getTerminationCriteria</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.TerminationCriteria termination_criteria = 1;</code></div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="Solvers.TerminationCriteriaOrBuilder.html" title="interface in operations_research.pdlp">Solvers.TerminationCriteriaOrBuilder</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTerminationCriteriaOrBuilder()">getTerminationCriteriaOrBuilder</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.TerminationCriteria termination_criteria = 1;</code></div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUseDiagonalQpTrustRegionSolver()">getUseDiagonalQpTrustRegionSolver</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When solving QPs with diagonal objective matrices, this option can be
 turned on to enable an experimental solver that avoids linearization of the
 quadratic term.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getVerbosityLevel()">getVerbosityLevel</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The verbosity of logging.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasAdaptiveLinesearchParameters()">hasAdaptiveLinesearchParameters</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.AdaptiveLinesearchParams adaptive_linesearch_parameters = 18;</code></div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasDiagonalQpTrustRegionSolverTolerance()">hasDiagonalQpTrustRegionSolverTolerance</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The solve tolerance of the experimental trust region solver for diagonal
 QPs, controlling the accuracy of binary search over a one-dimensional
 scaling parameter.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasHandleSomePrimalGradientsOnFiniteBoundsAsResiduals()">hasHandleSomePrimalGradientsOnFiniteBoundsAsResiduals</a></span>()</code></th>
<td class="colLast">
<div class="block">
 See https://developers.google.com/optimization/lp/pdlp_math for notation.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasInfiniteConstraintBoundThreshold()">hasInfiniteConstraintBoundThreshold</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When computing relative feasibility norms, constraint bounds with absolute
 value at least this threshold are treated as infinite, and hence not
 included in the relative feasibility norm.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasInitialPrimalWeight()">hasInitialPrimalWeight</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The initial value of the primal weight (i.e., the ratio of primal and dual
 step sizes).</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasInitialStepSizeScaling()">hasInitialStepSizeScaling</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Scaling factor applied to the initial step size (all step sizes if
 linesearch_rule == CONSTANT_STEP_SIZE_RULE).</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasL2NormRescaling()">hasL2NormRescaling</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, applies L_2 norm rescaling after the Ruiz rescaling.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasLinesearchRule()">hasLinesearchRule</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Linesearch rule applied at each major iteration.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasLInfRuizIterations()">hasLInfRuizIterations</a></span>()</code></th>
<td class="colLast">
<div class="block">
 Number of L_infinity Ruiz rescaling iterations to apply to the constraint
 matrix.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMajorIterationFrequency()">hasMajorIterationFrequency</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The frequency at which extra work is performed to make major algorithmic
 decisions, e.g., performing restarts and updating the primal weight.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasMalitskyPockParameters()">hasMalitskyPockParameters</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.MalitskyPockParams malitsky_pock_parameters = 19;</code></div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasNecessaryReductionForRestart()">hasNecessaryReductionForRestart</a></span>()</code></th>
<td class="colLast">
<div class="block">
 For ADAPTIVE_HEURISTIC only: A relative reduction in the potential function
 by this amount triggers a restart if, additionally, the quality of the
 iterates appears to be getting worse.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasNumShards()">hasNumShards</a></span>()</code></th>
<td class="colLast">
<div class="block">
 For more efficient parallel computation, the matrices and vectors are
 divided (virtually) into num_shards shards.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasNumThreads()">hasNumThreads</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The number of threads to use.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasPresolveOptions()">hasPresolveOptions</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.PresolveOptions presolve_options = 16;</code></div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasPrimalWeightUpdateSmoothing()">hasPrimalWeightUpdateSmoothing</a></span>()</code></th>
<td class="colLast">
<div class="block">
 This parameter controls exponential smoothing of log(primal_weight) when a
 primal weight update occurs (i.e., when the ratio of primal and dual step
 sizes is adjusted).</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRecordIterationStats()">hasRecordIterationStats</a></span>()</code></th>
<td class="colLast">
<div class="block">
 If true, the iteration_stats field of the SolveLog output will be populated
 at every iteration.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRestartStrategy()">hasRestartStrategy</a></span>()</code></th>
<td class="colLast">
<div class="block">
 NO_RESTARTS and EVERY_MAJOR_ITERATION occasionally outperform the default.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasSufficientReductionForRestart()">hasSufficientReductionForRestart</a></span>()</code></th>
<td class="colLast">
<div class="block">
 For ADAPTIVE_HEURISTIC and ADAPTIVE_DISTANCE_BASED only: A relative
 reduction in the potential function by this amount always triggers a
 restart.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasTerminationCheckFrequency()">hasTerminationCheckFrequency</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The frequency (based on a counter reset every major iteration) to check for
 termination (involves extra work) and log iteration stats.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasTerminationCriteria()">hasTerminationCriteria</a></span>()</code></th>
<td class="colLast">
<div class="block"><code>optional .operations_research.pdlp.TerminationCriteria termination_criteria = 1;</code></div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUseDiagonalQpTrustRegionSolver()">hasUseDiagonalQpTrustRegionSolver</a></span>()</code></th>
<td class="colLast">
<div class="block">
 When solving QPs with diagonal objective matrices, this option can be
 turned on to enable an experimental solver that avoids linearization of the
 quadratic term.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasVerbosityLevel()">hasVerbosityLevel</a></span>()</code></th>
<td class="colLast">
<div class="block">
 The verbosity of logging.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.google.protobuf.MessageLiteOrBuilder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageLiteOrBuilder</h3>
<code>isInitialized</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.com.google.protobuf.MessageOrBuilder">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;com.google.protobuf.MessageOrBuilder</h3>
<code>findInitializationErrors, getAllFields, getDefaultInstanceForType, getDescriptorForType, getField, getInitializationErrorString, getOneofFieldDescriptor, getRepeatedField, getRepeatedFieldCount, getUnknownFields, hasField, hasOneof</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="hasTerminationCriteria()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasTerminationCriteria</h4>
<pre class="methodSignature">boolean&nbsp;hasTerminationCriteria()</pre>
<div class="block"><code>optional .operations_research.pdlp.TerminationCriteria termination_criteria = 1;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the terminationCriteria field is set.</dd>
</dl>
</li>
</ul>
<a id="getTerminationCriteria()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTerminationCriteria</h4>
<pre class="methodSignature"><a href="Solvers.TerminationCriteria.html" title="class in operations_research.pdlp">Solvers.TerminationCriteria</a>&nbsp;getTerminationCriteria()</pre>
<div class="block"><code>optional .operations_research.pdlp.TerminationCriteria termination_criteria = 1;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The terminationCriteria.</dd>
</dl>
</li>
</ul>
<a id="getTerminationCriteriaOrBuilder()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTerminationCriteriaOrBuilder</h4>
<pre class="methodSignature"><a href="Solvers.TerminationCriteriaOrBuilder.html" title="interface in operations_research.pdlp">Solvers.TerminationCriteriaOrBuilder</a>&nbsp;getTerminationCriteriaOrBuilder()</pre>
<div class="block"><code>optional .operations_research.pdlp.TerminationCriteria termination_criteria = 1;</code></div>
</li>
</ul>
<a id="hasNumThreads()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumThreads</h4>
<pre class="methodSignature">boolean&nbsp;hasNumThreads()</pre>
<div class="block"><pre>
 The number of threads to use. Must be positive.
 Try various values of num_threads, up to the number of physical cores.
 Performance may not be monotonically increasing with the number of threads
 because of memory bandwidth limitations.
 </pre>

 <code>optional int32 num_threads = 2 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numThreads field is set.</dd>
</dl>
</li>
</ul>
<a id="getNumThreads()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumThreads</h4>
<pre class="methodSignature">int&nbsp;getNumThreads()</pre>
<div class="block"><pre>
 The number of threads to use. Must be positive.
 Try various values of num_threads, up to the number of physical cores.
 Performance may not be monotonically increasing with the number of threads
 because of memory bandwidth limitations.
 </pre>

 <code>optional int32 num_threads = 2 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numThreads.</dd>
</dl>
</li>
</ul>
<a id="hasNumShards()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNumShards</h4>
<pre class="methodSignature">boolean&nbsp;hasNumShards()</pre>
<div class="block"><pre>
 For more efficient parallel computation, the matrices and vectors are
 divided (virtually) into num_shards shards. Results are computed
 independently for each shard and then combined. As a consequence, the order
 of computation, and hence floating point roundoff, depends on the number of
 shards so reproducible results require using the same value for num_shards.
 However, for efficiency num_shards should a be at least num_threads, and
 preferably at least 4*num_threads to allow better load balancing. If
 num_shards is positive, the computation will use that many shards.
 Otherwise a default that depends on num_threads will be used.
 </pre>

 <code>optional int32 num_shards = 27 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the numShards field is set.</dd>
</dl>
</li>
</ul>
<a id="getNumShards()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumShards</h4>
<pre class="methodSignature">int&nbsp;getNumShards()</pre>
<div class="block"><pre>
 For more efficient parallel computation, the matrices and vectors are
 divided (virtually) into num_shards shards. Results are computed
 independently for each shard and then combined. As a consequence, the order
 of computation, and hence floating point roundoff, depends on the number of
 shards so reproducible results require using the same value for num_shards.
 However, for efficiency num_shards should a be at least num_threads, and
 preferably at least 4*num_threads to allow better load balancing. If
 num_shards is positive, the computation will use that many shards.
 Otherwise a default that depends on num_threads will be used.
 </pre>

 <code>optional int32 num_shards = 27 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The numShards.</dd>
</dl>
</li>
</ul>
<a id="hasRecordIterationStats()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRecordIterationStats</h4>
<pre class="methodSignature">boolean&nbsp;hasRecordIterationStats()</pre>
<div class="block"><pre>
 If true, the iteration_stats field of the SolveLog output will be populated
 at every iteration. Note that we only compute solution statistics at
 termination checks. Setting this parameter to true may substantially
 increase the size of the output.
 </pre>

 <code>optional bool record_iteration_stats = 3;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the recordIterationStats field is set.</dd>
</dl>
</li>
</ul>
<a id="getRecordIterationStats()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRecordIterationStats</h4>
<pre class="methodSignature">boolean&nbsp;getRecordIterationStats()</pre>
<div class="block"><pre>
 If true, the iteration_stats field of the SolveLog output will be populated
 at every iteration. Note that we only compute solution statistics at
 termination checks. Setting this parameter to true may substantially
 increase the size of the output.
 </pre>

 <code>optional bool record_iteration_stats = 3;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The recordIterationStats.</dd>
</dl>
</li>
</ul>
<a id="hasVerbosityLevel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasVerbosityLevel</h4>
<pre class="methodSignature">boolean&nbsp;hasVerbosityLevel()</pre>
<div class="block"><pre>
 The verbosity of logging.
 0: No informational logging. (Errors are logged.)
 1: Summary statistics only. No iteration-level details.
 2: A table of iteration-level statistics is logged.
    (See ToShortString() in primal_dual_hybrid_gradient.cc).
 3: A more detailed table of iteration-level statistics is logged.
    (See ToString() in primal_dual_hybrid_gradient.cc).
 4: For iteration-level details, prints the statistics of both the average
    (prefixed with A) and the current iterate (prefixed with C). Also prints
    internal algorithmic state and details.
 Logging at levels 2-4 also includes messages from level 1.
 </pre>

 <code>optional int32 verbosity_level = 26 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the verbosityLevel field is set.</dd>
</dl>
</li>
</ul>
<a id="getVerbosityLevel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVerbosityLevel</h4>
<pre class="methodSignature">int&nbsp;getVerbosityLevel()</pre>
<div class="block"><pre>
 The verbosity of logging.
 0: No informational logging. (Errors are logged.)
 1: Summary statistics only. No iteration-level details.
 2: A table of iteration-level statistics is logged.
    (See ToShortString() in primal_dual_hybrid_gradient.cc).
 3: A more detailed table of iteration-level statistics is logged.
    (See ToString() in primal_dual_hybrid_gradient.cc).
 4: For iteration-level details, prints the statistics of both the average
    (prefixed with A) and the current iterate (prefixed with C). Also prints
    internal algorithmic state and details.
 Logging at levels 2-4 also includes messages from level 1.
 </pre>

 <code>optional int32 verbosity_level = 26 [default = 0];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The verbosityLevel.</dd>
</dl>
</li>
</ul>
<a id="hasMajorIterationFrequency()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMajorIterationFrequency</h4>
<pre class="methodSignature">boolean&nbsp;hasMajorIterationFrequency()</pre>
<div class="block"><pre>
 The frequency at which extra work is performed to make major algorithmic
 decisions, e.g., performing restarts and updating the primal weight. Major
 iterations also trigger a termination check. For best performance using the
 NO_RESTARTS or EVERY_MAJOR_ITERATION rule, one should perform a log-scale
 grid search over this parameter, for example, over powers of two.
 ADAPTIVE_HEURISTIC is mostly insensitive to this value.
 </pre>

 <code>optional int32 major_iteration_frequency = 4 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the majorIterationFrequency field is set.</dd>
</dl>
</li>
</ul>
<a id="getMajorIterationFrequency()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMajorIterationFrequency</h4>
<pre class="methodSignature">int&nbsp;getMajorIterationFrequency()</pre>
<div class="block"><pre>
 The frequency at which extra work is performed to make major algorithmic
 decisions, e.g., performing restarts and updating the primal weight. Major
 iterations also trigger a termination check. For best performance using the
 NO_RESTARTS or EVERY_MAJOR_ITERATION rule, one should perform a log-scale
 grid search over this parameter, for example, over powers of two.
 ADAPTIVE_HEURISTIC is mostly insensitive to this value.
 </pre>

 <code>optional int32 major_iteration_frequency = 4 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The majorIterationFrequency.</dd>
</dl>
</li>
</ul>
<a id="hasTerminationCheckFrequency()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasTerminationCheckFrequency</h4>
<pre class="methodSignature">boolean&nbsp;hasTerminationCheckFrequency()</pre>
<div class="block"><pre>
 The frequency (based on a counter reset every major iteration) to check for
 termination (involves extra work) and log iteration stats. Termination
 checks do not affect algorithmic progress unless termination is triggered.
 </pre>

 <code>optional int32 termination_check_frequency = 5 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the terminationCheckFrequency field is set.</dd>
</dl>
</li>
</ul>
<a id="getTerminationCheckFrequency()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTerminationCheckFrequency</h4>
<pre class="methodSignature">int&nbsp;getTerminationCheckFrequency()</pre>
<div class="block"><pre>
 The frequency (based on a counter reset every major iteration) to check for
 termination (involves extra work) and log iteration stats. Termination
 checks do not affect algorithmic progress unless termination is triggered.
 </pre>

 <code>optional int32 termination_check_frequency = 5 [default = 64];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The terminationCheckFrequency.</dd>
</dl>
</li>
</ul>
<a id="hasRestartStrategy()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRestartStrategy</h4>
<pre class="methodSignature">boolean&nbsp;hasRestartStrategy()</pre>
<div class="block"><pre>
 NO_RESTARTS and EVERY_MAJOR_ITERATION occasionally outperform the default.
 If using a strategy other than ADAPTIVE_HEURISTIC, you must also tune
 major_iteration_frequency.
 </pre>

 <code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.RestartStrategy restart_strategy = 6 [default = ADAPTIVE_HEURISTIC];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the restartStrategy field is set.</dd>
</dl>
</li>
</ul>
<a id="getRestartStrategy()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRestartStrategy</h4>
<pre class="methodSignature"><a href="Solvers.PrimalDualHybridGradientParams.RestartStrategy.html" title="enum in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.RestartStrategy</a>&nbsp;getRestartStrategy()</pre>
<div class="block"><pre>
 NO_RESTARTS and EVERY_MAJOR_ITERATION occasionally outperform the default.
 If using a strategy other than ADAPTIVE_HEURISTIC, you must also tune
 major_iteration_frequency.
 </pre>

 <code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.RestartStrategy restart_strategy = 6 [default = ADAPTIVE_HEURISTIC];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The restartStrategy.</dd>
</dl>
</li>
</ul>
<a id="hasPrimalWeightUpdateSmoothing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPrimalWeightUpdateSmoothing</h4>
<pre class="methodSignature">boolean&nbsp;hasPrimalWeightUpdateSmoothing()</pre>
<div class="block"><pre>
 This parameter controls exponential smoothing of log(primal_weight) when a
 primal weight update occurs (i.e., when the ratio of primal and dual step
 sizes is adjusted). At 0.0, the primal weight will be frozen at its initial
 value and there will be no dynamic updates in the algorithm. At 1.0, there
 is no smoothing in the updates. The default of 0.5 generally performs well,
 but has been observed on occasion to trigger unstable swings in the primal
 weight. We recommend also trying 0.0 (disabling primal weight updates), in
 which case you must also tune initial_primal_weight.
 </pre>

 <code>optional double primal_weight_update_smoothing = 7 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the primalWeightUpdateSmoothing field is set.</dd>
</dl>
</li>
</ul>
<a id="getPrimalWeightUpdateSmoothing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPrimalWeightUpdateSmoothing</h4>
<pre class="methodSignature">double&nbsp;getPrimalWeightUpdateSmoothing()</pre>
<div class="block"><pre>
 This parameter controls exponential smoothing of log(primal_weight) when a
 primal weight update occurs (i.e., when the ratio of primal and dual step
 sizes is adjusted). At 0.0, the primal weight will be frozen at its initial
 value and there will be no dynamic updates in the algorithm. At 1.0, there
 is no smoothing in the updates. The default of 0.5 generally performs well,
 but has been observed on occasion to trigger unstable swings in the primal
 weight. We recommend also trying 0.0 (disabling primal weight updates), in
 which case you must also tune initial_primal_weight.
 </pre>

 <code>optional double primal_weight_update_smoothing = 7 [default = 0.5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The primalWeightUpdateSmoothing.</dd>
</dl>
</li>
</ul>
<a id="hasInitialPrimalWeight()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialPrimalWeight</h4>
<pre class="methodSignature">boolean&nbsp;hasInitialPrimalWeight()</pre>
<div class="block"><pre>
 The initial value of the primal weight (i.e., the ratio of primal and dual
 step sizes). The primal weight remains fixed throughout the solve if
 primal_weight_update_smoothing = 0.0. If unset, the default is the ratio of
 the norm of the objective vector to the L2 norm of the combined constraint
 bounds vector (as defined above). If this ratio is not finite and positive,
 then the default is 1.0 instead. For tuning, try powers of 10, for example,
 from 10^{-6} to 10^6.
 </pre>

 <code>optional double initial_primal_weight = 8;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialPrimalWeight field is set.</dd>
</dl>
</li>
</ul>
<a id="getInitialPrimalWeight()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialPrimalWeight</h4>
<pre class="methodSignature">double&nbsp;getInitialPrimalWeight()</pre>
<div class="block"><pre>
 The initial value of the primal weight (i.e., the ratio of primal and dual
 step sizes). The primal weight remains fixed throughout the solve if
 primal_weight_update_smoothing = 0.0. If unset, the default is the ratio of
 the norm of the objective vector to the L2 norm of the combined constraint
 bounds vector (as defined above). If this ratio is not finite and positive,
 then the default is 1.0 instead. For tuning, try powers of 10, for example,
 from 10^{-6} to 10^6.
 </pre>

 <code>optional double initial_primal_weight = 8;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialPrimalWeight.</dd>
</dl>
</li>
</ul>
<a id="hasPresolveOptions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPresolveOptions</h4>
<pre class="methodSignature">boolean&nbsp;hasPresolveOptions()</pre>
<div class="block"><code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.PresolveOptions presolve_options = 16;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the presolveOptions field is set.</dd>
</dl>
</li>
</ul>
<a id="getPresolveOptions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveOptions</h4>
<pre class="methodSignature"><a href="Solvers.PrimalDualHybridGradientParams.PresolveOptions.html" title="class in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.PresolveOptions</a>&nbsp;getPresolveOptions()</pre>
<div class="block"><code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.PresolveOptions presolve_options = 16;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The presolveOptions.</dd>
</dl>
</li>
</ul>
<a id="getPresolveOptionsOrBuilder()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPresolveOptionsOrBuilder</h4>
<pre class="methodSignature"><a href="Solvers.PrimalDualHybridGradientParams.PresolveOptionsOrBuilder.html" title="interface in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.PresolveOptionsOrBuilder</a>&nbsp;getPresolveOptionsOrBuilder()</pre>
<div class="block"><code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.PresolveOptions presolve_options = 16;</code></div>
</li>
</ul>
<a id="hasLInfRuizIterations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLInfRuizIterations</h4>
<pre class="methodSignature">boolean&nbsp;hasLInfRuizIterations()</pre>
<div class="block"><pre>
 Number of L_infinity Ruiz rescaling iterations to apply to the constraint
 matrix. Zero disables this rescaling pass. Recommended values to try when
 tuning are 0, 5, and 10.
 </pre>

 <code>optional int32 l_inf_ruiz_iterations = 9 [default = 5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the lInfRuizIterations field is set.</dd>
</dl>
</li>
</ul>
<a id="getLInfRuizIterations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLInfRuizIterations</h4>
<pre class="methodSignature">int&nbsp;getLInfRuizIterations()</pre>
<div class="block"><pre>
 Number of L_infinity Ruiz rescaling iterations to apply to the constraint
 matrix. Zero disables this rescaling pass. Recommended values to try when
 tuning are 0, 5, and 10.
 </pre>

 <code>optional int32 l_inf_ruiz_iterations = 9 [default = 5];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The lInfRuizIterations.</dd>
</dl>
</li>
</ul>
<a id="hasL2NormRescaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasL2NormRescaling</h4>
<pre class="methodSignature">boolean&nbsp;hasL2NormRescaling()</pre>
<div class="block"><pre>
 If true, applies L_2 norm rescaling after the Ruiz rescaling. Heuristically
 this has been found to help convergence.
 </pre>

 <code>optional bool l2_norm_rescaling = 10 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the l2NormRescaling field is set.</dd>
</dl>
</li>
</ul>
<a id="getL2NormRescaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getL2NormRescaling</h4>
<pre class="methodSignature">boolean&nbsp;getL2NormRescaling()</pre>
<div class="block"><pre>
 If true, applies L_2 norm rescaling after the Ruiz rescaling. Heuristically
 this has been found to help convergence.
 </pre>

 <code>optional bool l2_norm_rescaling = 10 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The l2NormRescaling.</dd>
</dl>
</li>
</ul>
<a id="hasSufficientReductionForRestart()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSufficientReductionForRestart</h4>
<pre class="methodSignature">boolean&nbsp;hasSufficientReductionForRestart()</pre>
<div class="block"><pre>
 For ADAPTIVE_HEURISTIC and ADAPTIVE_DISTANCE_BASED only: A relative
 reduction in the potential function by this amount always triggers a
 restart. Must be between 0.0 and 1.0.
 </pre>

 <code>optional double sufficient_reduction_for_restart = 11 [default = 0.1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the sufficientReductionForRestart field is set.</dd>
</dl>
</li>
</ul>
<a id="getSufficientReductionForRestart()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSufficientReductionForRestart</h4>
<pre class="methodSignature">double&nbsp;getSufficientReductionForRestart()</pre>
<div class="block"><pre>
 For ADAPTIVE_HEURISTIC and ADAPTIVE_DISTANCE_BASED only: A relative
 reduction in the potential function by this amount always triggers a
 restart. Must be between 0.0 and 1.0.
 </pre>

 <code>optional double sufficient_reduction_for_restart = 11 [default = 0.1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sufficientReductionForRestart.</dd>
</dl>
</li>
</ul>
<a id="hasNecessaryReductionForRestart()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNecessaryReductionForRestart</h4>
<pre class="methodSignature">boolean&nbsp;hasNecessaryReductionForRestart()</pre>
<div class="block"><pre>
 For ADAPTIVE_HEURISTIC only: A relative reduction in the potential function
 by this amount triggers a restart if, additionally, the quality of the
 iterates appears to be getting worse. The value must be in the interval
 [sufficient_reduction_for_restart, 1). Smaller values make restarts less
 frequent, and larger values make them more frequent.
 </pre>

 <code>optional double necessary_reduction_for_restart = 17 [default = 0.9];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the necessaryReductionForRestart field is set.</dd>
</dl>
</li>
</ul>
<a id="getNecessaryReductionForRestart()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNecessaryReductionForRestart</h4>
<pre class="methodSignature">double&nbsp;getNecessaryReductionForRestart()</pre>
<div class="block"><pre>
 For ADAPTIVE_HEURISTIC only: A relative reduction in the potential function
 by this amount triggers a restart if, additionally, the quality of the
 iterates appears to be getting worse. The value must be in the interval
 [sufficient_reduction_for_restart, 1). Smaller values make restarts less
 frequent, and larger values make them more frequent.
 </pre>

 <code>optional double necessary_reduction_for_restart = 17 [default = 0.9];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The necessaryReductionForRestart.</dd>
</dl>
</li>
</ul>
<a id="hasLinesearchRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasLinesearchRule</h4>
<pre class="methodSignature">boolean&nbsp;hasLinesearchRule()</pre>
<div class="block"><pre>
 Linesearch rule applied at each major iteration.
 </pre>

 <code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.LinesearchRule linesearch_rule = 12 [default = ADAPTIVE_LINESEARCH_RULE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the linesearchRule field is set.</dd>
</dl>
</li>
</ul>
<a id="getLinesearchRule()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLinesearchRule</h4>
<pre class="methodSignature"><a href="Solvers.PrimalDualHybridGradientParams.LinesearchRule.html" title="enum in operations_research.pdlp">Solvers.PrimalDualHybridGradientParams.LinesearchRule</a>&nbsp;getLinesearchRule()</pre>
<div class="block"><pre>
 Linesearch rule applied at each major iteration.
 </pre>

 <code>optional .operations_research.pdlp.PrimalDualHybridGradientParams.LinesearchRule linesearch_rule = 12 [default = ADAPTIVE_LINESEARCH_RULE];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The linesearchRule.</dd>
</dl>
</li>
</ul>
<a id="hasAdaptiveLinesearchParameters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasAdaptiveLinesearchParameters</h4>
<pre class="methodSignature">boolean&nbsp;hasAdaptiveLinesearchParameters()</pre>
<div class="block"><code>optional .operations_research.pdlp.AdaptiveLinesearchParams adaptive_linesearch_parameters = 18;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the adaptiveLinesearchParameters field is set.</dd>
</dl>
</li>
</ul>
<a id="getAdaptiveLinesearchParameters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAdaptiveLinesearchParameters</h4>
<pre class="methodSignature"><a href="Solvers.AdaptiveLinesearchParams.html" title="class in operations_research.pdlp">Solvers.AdaptiveLinesearchParams</a>&nbsp;getAdaptiveLinesearchParameters()</pre>
<div class="block"><code>optional .operations_research.pdlp.AdaptiveLinesearchParams adaptive_linesearch_parameters = 18;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The adaptiveLinesearchParameters.</dd>
</dl>
</li>
</ul>
<a id="getAdaptiveLinesearchParametersOrBuilder()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAdaptiveLinesearchParametersOrBuilder</h4>
<pre class="methodSignature"><a href="Solvers.AdaptiveLinesearchParamsOrBuilder.html" title="interface in operations_research.pdlp">Solvers.AdaptiveLinesearchParamsOrBuilder</a>&nbsp;getAdaptiveLinesearchParametersOrBuilder()</pre>
<div class="block"><code>optional .operations_research.pdlp.AdaptiveLinesearchParams adaptive_linesearch_parameters = 18;</code></div>
</li>
</ul>
<a id="hasMalitskyPockParameters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMalitskyPockParameters</h4>
<pre class="methodSignature">boolean&nbsp;hasMalitskyPockParameters()</pre>
<div class="block"><code>optional .operations_research.pdlp.MalitskyPockParams malitsky_pock_parameters = 19;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the malitskyPockParameters field is set.</dd>
</dl>
</li>
</ul>
<a id="getMalitskyPockParameters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMalitskyPockParameters</h4>
<pre class="methodSignature"><a href="Solvers.MalitskyPockParams.html" title="class in operations_research.pdlp">Solvers.MalitskyPockParams</a>&nbsp;getMalitskyPockParameters()</pre>
<div class="block"><code>optional .operations_research.pdlp.MalitskyPockParams malitsky_pock_parameters = 19;</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The malitskyPockParameters.</dd>
</dl>
</li>
</ul>
<a id="getMalitskyPockParametersOrBuilder()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMalitskyPockParametersOrBuilder</h4>
<pre class="methodSignature"><a href="Solvers.MalitskyPockParamsOrBuilder.html" title="interface in operations_research.pdlp">Solvers.MalitskyPockParamsOrBuilder</a>&nbsp;getMalitskyPockParametersOrBuilder()</pre>
<div class="block"><code>optional .operations_research.pdlp.MalitskyPockParams malitsky_pock_parameters = 19;</code></div>
</li>
</ul>
<a id="hasInitialStepSizeScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInitialStepSizeScaling</h4>
<pre class="methodSignature">boolean&nbsp;hasInitialStepSizeScaling()</pre>
<div class="block"><pre>
 Scaling factor applied to the initial step size (all step sizes if
 linesearch_rule == CONSTANT_STEP_SIZE_RULE).
 </pre>

 <code>optional double initial_step_size_scaling = 25 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the initialStepSizeScaling field is set.</dd>
</dl>
</li>
</ul>
<a id="getInitialStepSizeScaling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInitialStepSizeScaling</h4>
<pre class="methodSignature">double&nbsp;getInitialStepSizeScaling()</pre>
<div class="block"><pre>
 Scaling factor applied to the initial step size (all step sizes if
 linesearch_rule == CONSTANT_STEP_SIZE_RULE).
 </pre>

 <code>optional double initial_step_size_scaling = 25 [default = 1];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The initialStepSizeScaling.</dd>
</dl>
</li>
</ul>
<a id="getRandomProjectionSeedsList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomProjectionSeedsList</h4>
<pre class="methodSignature">java.util.List&lt;java.lang.Integer&gt;&nbsp;getRandomProjectionSeedsList()</pre>
<div class="block"><pre>
 Seeds for generating (pseudo-)random projections of iterates during
 termination checks. For each seed, the projection of the primal and dual
 solutions onto random planes in primal and dual space will be computed and
 added the IterationStats if record_iteration_stats is true. The random
 planes generated will be determined by the seeds, the primal and dual
 dimensions, and num_threads.
 </pre>

 <code>repeated int32 random_projection_seeds = 28 [packed = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list containing the randomProjectionSeeds.</dd>
</dl>
</li>
</ul>
<a id="getRandomProjectionSeedsCount()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomProjectionSeedsCount</h4>
<pre class="methodSignature">int&nbsp;getRandomProjectionSeedsCount()</pre>
<div class="block"><pre>
 Seeds for generating (pseudo-)random projections of iterates during
 termination checks. For each seed, the projection of the primal and dual
 solutions onto random planes in primal and dual space will be computed and
 added the IterationStats if record_iteration_stats is true. The random
 planes generated will be determined by the seeds, the primal and dual
 dimensions, and num_threads.
 </pre>

 <code>repeated int32 random_projection_seeds = 28 [packed = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The count of randomProjectionSeeds.</dd>
</dl>
</li>
</ul>
<a id="getRandomProjectionSeeds(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRandomProjectionSeeds</h4>
<pre class="methodSignature">int&nbsp;getRandomProjectionSeeds&#8203;(int&nbsp;index)</pre>
<div class="block"><pre>
 Seeds for generating (pseudo-)random projections of iterates during
 termination checks. For each seed, the projection of the primal and dual
 solutions onto random planes in primal and dual space will be computed and
 added the IterationStats if record_iteration_stats is true. The random
 planes generated will be determined by the seeds, the primal and dual
 dimensions, and num_threads.
 </pre>

 <code>repeated int32 random_projection_seeds = 28 [packed = true];</code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index of the element to return.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The randomProjectionSeeds at the given index.</dd>
</dl>
</li>
</ul>
<a id="hasInfiniteConstraintBoundThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasInfiniteConstraintBoundThreshold</h4>
<pre class="methodSignature">boolean&nbsp;hasInfiniteConstraintBoundThreshold()</pre>
<div class="block"><pre>
 When computing relative feasibility norms, constraint bounds with absolute
 value at least this threshold are treated as infinite, and hence not
 included in the relative feasibility norm.
 NOTE: This affects only the relative convergence criteria (and problem
 statistics LOG()ed at the start of the run). A smaller value makes the
 relative convergence criteria stronger.
 </pre>

 <code>optional double infinite_constraint_bound_threshold = 22 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the infiniteConstraintBoundThreshold field is set.</dd>
</dl>
</li>
</ul>
<a id="getInfiniteConstraintBoundThreshold()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInfiniteConstraintBoundThreshold</h4>
<pre class="methodSignature">double&nbsp;getInfiniteConstraintBoundThreshold()</pre>
<div class="block"><pre>
 When computing relative feasibility norms, constraint bounds with absolute
 value at least this threshold are treated as infinite, and hence not
 included in the relative feasibility norm.
 NOTE: This affects only the relative convergence criteria (and problem
 statistics LOG()ed at the start of the run). A smaller value makes the
 relative convergence criteria stronger.
 </pre>

 <code>optional double infinite_constraint_bound_threshold = 22 [default = inf];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The infiniteConstraintBoundThreshold.</dd>
</dl>
</li>
</ul>
<a id="hasHandleSomePrimalGradientsOnFiniteBoundsAsResiduals()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasHandleSomePrimalGradientsOnFiniteBoundsAsResiduals</h4>
<pre class="methodSignature">boolean&nbsp;hasHandleSomePrimalGradientsOnFiniteBoundsAsResiduals()</pre>
<div class="block"><pre>
 See https://developers.google.com/optimization/lp/pdlp_math for notation.
 handle_some_primal_gradients_on_finite_bounds_as_residuals controls for
 which primal variables i the term (l^v_i)^T[r_i]_+  (u^v_i)^T[r_i]_ in
 the theoretical dual objective is included in PDLP's dual objective and
 which are excluded from the dual objective with r_i accounted separately as
 contributing to the dual residual. This parameter has no effect on the
 primal and dual solution found after t iterations; it only affects when
 termination occurs and reported statistics.
 When (l^v_i)^T[r_i]_+  (u^v_i)^T[r_i]_ is infinite due to an infinite
 variable bound the term is always treated as a residual (to keep the dual
 objective finite) regardless of the value of
 handle_some_primal_gradients_on_finite_bounds_as_residuals.
 When handle_some_primal_gradients_on_finite_bounds_as_residuals is false no
 finite terms are accounted as residuals.
 When handle_some_primal_gradients_on_finite_bounds_as_residuals is true,
 finite terms with |x_i - b_i| &gt; |x_i| (where x_i is the variable's value
 and b_i is l^v_i if r_i &gt; 0 and u^v_i otherwise) are counted as residuals.
 Setting this to true can substantially reduce the duality gap at the
 expense of increasing the dual residual.
 </pre>

 <code>optional bool handle_some_primal_gradients_on_finite_bounds_as_residuals = 29 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the handleSomePrimalGradientsOnFiniteBoundsAsResiduals field is set.</dd>
</dl>
</li>
</ul>
<a id="getHandleSomePrimalGradientsOnFiniteBoundsAsResiduals()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHandleSomePrimalGradientsOnFiniteBoundsAsResiduals</h4>
<pre class="methodSignature">boolean&nbsp;getHandleSomePrimalGradientsOnFiniteBoundsAsResiduals()</pre>
<div class="block"><pre>
 See https://developers.google.com/optimization/lp/pdlp_math for notation.
 handle_some_primal_gradients_on_finite_bounds_as_residuals controls for
 which primal variables i the term (l^v_i)^T[r_i]_+  (u^v_i)^T[r_i]_ in
 the theoretical dual objective is included in PDLP's dual objective and
 which are excluded from the dual objective with r_i accounted separately as
 contributing to the dual residual. This parameter has no effect on the
 primal and dual solution found after t iterations; it only affects when
 termination occurs and reported statistics.
 When (l^v_i)^T[r_i]_+  (u^v_i)^T[r_i]_ is infinite due to an infinite
 variable bound the term is always treated as a residual (to keep the dual
 objective finite) regardless of the value of
 handle_some_primal_gradients_on_finite_bounds_as_residuals.
 When handle_some_primal_gradients_on_finite_bounds_as_residuals is false no
 finite terms are accounted as residuals.
 When handle_some_primal_gradients_on_finite_bounds_as_residuals is true,
 finite terms with |x_i - b_i| &gt; |x_i| (where x_i is the variable's value
 and b_i is l^v_i if r_i &gt; 0 and u^v_i otherwise) are counted as residuals.
 Setting this to true can substantially reduce the duality gap at the
 expense of increasing the dual residual.
 </pre>

 <code>optional bool handle_some_primal_gradients_on_finite_bounds_as_residuals = 29 [default = true];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The handleSomePrimalGradientsOnFiniteBoundsAsResiduals.</dd>
</dl>
</li>
</ul>
<a id="hasUseDiagonalQpTrustRegionSolver()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUseDiagonalQpTrustRegionSolver</h4>
<pre class="methodSignature">boolean&nbsp;hasUseDiagonalQpTrustRegionSolver()</pre>
<div class="block"><pre>
 When solving QPs with diagonal objective matrices, this option can be
 turned on to enable an experimental solver that avoids linearization of the
 quadratic term. The `diagonal_qp_solver_accuracy` parameter controls the
 solve accuracy.
 TODO(user): Turn this option on by default for quadratic
 programs after numerical evaluation.
 </pre>

 <code>optional bool use_diagonal_qp_trust_region_solver = 23 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the useDiagonalQpTrustRegionSolver field is set.</dd>
</dl>
</li>
</ul>
<a id="getUseDiagonalQpTrustRegionSolver()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUseDiagonalQpTrustRegionSolver</h4>
<pre class="methodSignature">boolean&nbsp;getUseDiagonalQpTrustRegionSolver()</pre>
<div class="block"><pre>
 When solving QPs with diagonal objective matrices, this option can be
 turned on to enable an experimental solver that avoids linearization of the
 quadratic term. The `diagonal_qp_solver_accuracy` parameter controls the
 solve accuracy.
 TODO(user): Turn this option on by default for quadratic
 programs after numerical evaluation.
 </pre>

 <code>optional bool use_diagonal_qp_trust_region_solver = 23 [default = false];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The useDiagonalQpTrustRegionSolver.</dd>
</dl>
</li>
</ul>
<a id="hasDiagonalQpTrustRegionSolverTolerance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasDiagonalQpTrustRegionSolverTolerance</h4>
<pre class="methodSignature">boolean&nbsp;hasDiagonalQpTrustRegionSolverTolerance()</pre>
<div class="block"><pre>
 The solve tolerance of the experimental trust region solver for diagonal
 QPs, controlling the accuracy of binary search over a one-dimensional
 scaling parameter. Smaller values imply smaller relative error of the final
 solution vector.
 TODO(user): Find an expression for the final relative error.
 </pre>

 <code>optional double diagonal_qp_trust_region_solver_tolerance = 24 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the diagonalQpTrustRegionSolverTolerance field is set.</dd>
</dl>
</li>
</ul>
<a id="getDiagonalQpTrustRegionSolverTolerance()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getDiagonalQpTrustRegionSolverTolerance</h4>
<pre class="methodSignature">double&nbsp;getDiagonalQpTrustRegionSolverTolerance()</pre>
<div class="block"><pre>
 The solve tolerance of the experimental trust region solver for diagonal
 QPs, controlling the accuracy of binary search over a one-dimensional
 scaling parameter. Smaller values imply smaller relative error of the final
 solution vector.
 TODO(user): Find an expression for the final relative error.
 </pre>

 <code>optional double diagonal_qp_trust_region_solver_tolerance = 24 [default = 1e-08];</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The diagonalQpTrustRegionSolverTolerance.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Solvers.PrimalDualHybridGradientParamsOrBuilder.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2023. All rights reserved.</small></p>
</footer>
</body>
</html>
