<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceoperations__research_1_1sat.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator.html">AllDifferentBoundsPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html">AllDifferentConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="#adac2a1cac1b45c80f43ebd78490468a8">AllDifferentAC()</a>.  <a href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ArcGraphNeighborhoodGenerator.html">ArcGraphNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ArcWithLpValue.html">ArcWithLpValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1AssignmentInfo.html">AssignmentInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a variable assignment.  <a href="structoperations__research_1_1sat_1_1AssignmentInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1AssignmentType.html">AssignmentType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1AssignmentView.html">AssignmentView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1AutomatonConstraint.html">AutomatonConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1BaseEvent.html">BaseEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal methods and data structures, useful for testing.  <a href="structoperations__research_1_1sat_1_1BaseEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BasicKnapsackSolver.html">BasicKnapsackSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary clause. This is used by <a class="el" href="classoperations__research_1_1sat_1_1BinaryClauseManager.html" title="A simple class to manage a set of binary clauses.">BinaryClauseManager</a>.  <a href="structoperations__research_1_1sat_1_1BinaryClause.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryClauseManager.html">BinaryClauseManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class to manage a set of binary clauses.  <a href="classoperations__research_1_1sat_1_1BinaryClauseManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">BinaryImplicationGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryRelationRepository.html">BinaryRelationRepository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1BinaryTreeNode.html">BinaryTreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BlockedClauseSimplifier.html">BlockedClauseSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerVariable.html">BooleanOrIntegerVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BooleanXorPropagator.html">BooleanXorPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BoolRLTCutHelper.html">BoolRLTCutHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BoundedVariableElimination.html">BoundedVariableElimination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1BruteForceResult.html">BruteForceResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1CachedIntervalData.html">CachedIntervalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1CachedTaskBounds.html">CachedTaskBounds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem.html">CanonicalBooleanLinearProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CapacityProfile.html">CapacityProfile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CircuitConstraint.html">CircuitConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CircuitCoveringPropagator.html">CircuitCoveringPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html">CircuitPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ClauseInfo.html">ClauseInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html">ClauseManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ClauseWithOneMissingHasher.html">ClauseWithOneMissingHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to help detects clauses that differ on a single literal.  <a href="classoperations__research_1_1sat_1_1ClauseWithOneMissingHasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ColumnEqForDuplicateDetection.html">ColumnEqForDuplicateDetection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ColumnHashForDuplicateDetection.html">ColumnHashForDuplicateDetection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CombinedDisjunctive.html">CombinedDisjunctive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompactVectorVector.html">CompactVectorVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledAllDiffConstraint.html">CompiledAllDiffConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledBoolXorConstraint.html">CompiledBoolXorConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The violation of a bool_xor constraint is 0 or 1.  <a href="classoperations__research_1_1sat_1_1CompiledBoolXorConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledCircuitConstraint.html">CompiledCircuitConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1sat_1_1CompiledCircuitConstraint.html" title="--— CompiledCircuitConstraint --—">CompiledCircuitConstraint</a> --&mdash;  <a href="classoperations__research_1_1sat_1_1CompiledCircuitConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledConstraint.html">CompiledConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of a generic (non linear) constraint for the <a class="el" href="classoperations__research_1_1sat_1_1LsEvaluator.html">LsEvaluator</a>.  <a href="classoperations__research_1_1sat_1_1CompiledConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledConstraintWithProto.html">CompiledConstraintWithProto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledIntDivConstraint.html">CompiledIntDivConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledIntModConstraint.html">CompiledIntModConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledIntProdConstraint.html">CompiledIntProdConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledLinMaxConstraint.html">CompiledLinMaxConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledNoOverlap2dConstraint.html">CompiledNoOverlap2dConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompiledReservoirConstraint.html">CompiledReservoirConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CompoundMoveBuilder.html">CompoundMoveBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ConstraintGraphNeighborhoodGenerator.html">ConstraintGraphNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ConstraintPropagationOrder.html">ConstraintPropagationOrder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ContinuousProber.html">ContinuousProber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html">CoreBasedOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html">CoverCutHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to find knapsack cover cuts.  <a href="classoperations__research_1_1sat_1_1CoverCutHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelBuilder.html">CpModelBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelMapping.html">CpModelMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html">CpModelPresolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelProtoWrapper.html">CpModelProtoWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implement the implicit contract needed by the <a class="el" href="classoperations__research_1_1sat_1_1SatCnfReader.html">SatCnfReader</a> class.  <a href="classoperations__research_1_1sat_1_1CpModelProtoWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelView.html">CpModelView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1CtEvent.html">CtEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CumulativeConstraint.html">CumulativeConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CumulativeDualFeasibleEnergyConstraint.html">CumulativeDualFeasibleEnergyConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="#a6f7364044e91bc377aa1c354e8fa892a">AddCumulativeOverloadCheckerDff()</a>.  <a href="classoperations__research_1_1sat_1_1CumulativeDualFeasibleEnergyConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CumulativeEnergyConstraint.html">CumulativeEnergyConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="#ae9833301c095ba1cd286e7be7ed2515e">AddCumulativeOverloadChecker()</a>.  <a href="classoperations__research_1_1sat_1_1CumulativeEnergyConstraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint.html">CumulativeIsAfterSubsetConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1CutData.html">CutData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our cut are always of the form linear_expression &lt;= rhs.  <a href="structoperations__research_1_1sat_1_1CutData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CutDataBuilder.html">CutDataBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores temporaries used to build or manipulate a <a class="el" href="structoperations__research_1_1sat_1_1CutData.html" title="Our cut are always of the form linear_expression &lt;= rhs.">CutData</a>.  <a href="classoperations__research_1_1sat_1_1CutDataBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1DebugSolution.html">DebugSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator.html">DecompositionGraphNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1DelayedRootLevelDeduction.html">DelayedRootLevelDeduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DFFComposedF2F0.html">DFFComposedF2F0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1DiffnBaseEvent.html">DiffnBaseEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal methods and data structures, useful for testing.  <a href="structoperations__research_1_1sat_1_1DiffnBaseEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1DiffnCtEvent.html">DiffnCtEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1DiffnEnergyEvent.html">DiffnEnergyEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1DiophantineSolution.html">DiophantineSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1Disjoint2dPackingResult.html">Disjoint2dPackingResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveDetectablePrecedences.html">DisjunctiveDetectablePrecedences</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveEdgeFinding.html">DisjunctiveEdgeFinding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveNotLast.html">DisjunctiveNotLast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveOverloadChecker.html">DisjunctiveOverloadChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DisjunctivePrecedences.html">DisjunctivePrecedences</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveSimplePrecedences.html">DisjunctiveSimplePrecedences</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveWithTwoItems.html">DisjunctiveWithTwoItems</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DivisionPropagator.html">DivisionPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html">DomainDeductions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DratChecker.html">DratChecker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DratWriter.html">DratWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html">DualBoundStrengthening</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1DualFeasibleFunctionF0.html">DualFeasibleFunctionF0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ElementEncodings.html">ElementEncodings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1EnergyEvent.html">EnergyEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1EnforcementPropagator.html">EnforcementPropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is meant as an helper to deal with enforcement for any constraint.  <a href="classoperations__research_1_1sat_1_1EnforcementPropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ExponentialMovingAverage.html">ExponentialMovingAverage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1FeasibilityJumpSolver.html">FeasibilityJumpSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1FeasibilityPump.html">FeasibilityPump</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1FindRectanglesResult.html">FindRectanglesResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1FirstFewValues.html">FirstFewValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1FixedCapacityVector.html">FixedCapacityVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1FixedDivisionPropagator.html">FixedDivisionPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1FixedModuloPropagator.html">FixedModuloPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1FullIntegerPrecedence.html">FullIntegerPrecedence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">GenericLiteralWatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector.html">GreaterThanAtLeastOneOfDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator.html">GreaterThanAtLeastOneOfPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1HittingSetOptimizer.html">HittingSetOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IdentityMap.html">IdentityMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ImpliedBoundEntry.html">ImpliedBoundEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html">ImpliedBounds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html">ImpliedBoundsProcessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1InclusionDetector.html">InclusionDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IncrementalAverage.html">IncrementalAverage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages incremental averages.  <a href="classoperations__research_1_1sat_1_1IncrementalAverage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html">IndexedInterval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1IndexReferences.html">IndexReferences</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html">Inprocessing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1IntegerDomains.html">IntegerDomains</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerRoundingCutHelper.html">IntegerRoundingCutHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html">IntegerSearchHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An helper class to share the code used by the different kind of search.  <a href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1IntervalDefinition.html">IntervalDefinition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html">IntervalsRepository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntervalVar.html">IntervalVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntVar.html">IntVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1JumpTable.html">JumpTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LazyReasonInterface.html">LazyReasonInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html">LbTreeSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LevelZeroCallbackHelper.html">LevelZeroCallbackHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LevelZeroEquality.html">LevelZeroEquality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearBooleanProblemWrapper.html">LinearBooleanProblemWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implement the implicit contract needed by the <a class="el" href="classoperations__research_1_1sat_1_1SatCnfReader.html">SatCnfReader</a> class.  <a href="classoperations__research_1_1sat_1_1LinearBooleanProblemWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html">LinearConstraintBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html">LinearConstraintPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintSymmetrizer.html">LinearConstraintSymmetrizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html">LinearIncrementalEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearModel.html">LinearModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html">LinearProgrammingConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraintCollection.html">LinearProgrammingConstraintCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that stores the collection of all LP constraints in a model.  <a href="classoperations__research_1_1sat_1_1LinearProgrammingConstraintCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingDispatcher.html">LinearProgrammingDispatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html">LinearPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LinearTerm.html">LinearTerm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LinMinPropagator.html">LinMinPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a term in a pseudo-Boolean formula.  <a href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LocalBranchingLpBasedNeighborhoodGenerator.html">LocalBranchingLpBasedNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LsCounters.html">LsCounters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LsEvaluator.html">LsEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LsOptions.html">LsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parameters used by the local search code.  <a href="structoperations__research_1_1sat_1_1LsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1LsState.html">LsState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1MandatoryOverlapPropagator.html">MandatoryOverlapPropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposed for testing.  <a href="classoperations__research_1_1sat_1_1MandatoryOverlapPropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1MaxBoundedSubsetSum.html">MaxBoundedSubsetSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1MaxBoundedSubsetSumExact.html">MaxBoundedSubsetSumExact</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to MaxBoundedSubsetSum() above but use a different algo.  <a href="classoperations__research_1_1sat_1_1MaxBoundedSubsetSumExact.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1MinOutgoingFlowHelper.html">MinOutgoingFlowHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1MinPropagator.html">MinPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ModelCopy.html">ModelCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ModelLpValues.html">ModelLpValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ModelLpVariableMapping.html">ModelLpVariableMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ModelRandomGenerator.html">ModelRandomGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ModelReducedCosts.html">ModelReducedCosts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="structoperations__research_1_1sat_1_1ModelLpValues.html">ModelLpValues</a> for reduced costs.  <a href="structoperations__research_1_1sat_1_1ModelReducedCosts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ModelSharedTimeLimit.html">ModelSharedTimeLimit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The model "singleton" shared time limit.  <a href="classoperations__research_1_1sat_1_1ModelSharedTimeLimit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1MultipleCircuitConstraint.html">MultipleCircuitConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html">MutableUpperBoundedLinearConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html">Neighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html" title="Neighborhood returned by Neighborhood generators.">Neighborhood</a> returned by <a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html" title="Neighborhood returned by Neighborhood generators.">Neighborhood</a> generators.  <a href="structoperations__research_1_1sat_1_1Neighborhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGenerator.html">NeighborhoodGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a CpModelProto neighborhood generator.  <a href="classoperations__research_1_1sat_1_1NeighborhoodGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html">NeighborhoodGeneratorHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Neighbours.html">Neighbours</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NoCyclePropagator.html">NoCyclePropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce the fact that there is no cycle in the given directed graph.  <a href="classoperations__research_1_1sat_1_1NoCyclePropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NonOverlappingRectanglesDisjunctivePropagator.html">NonOverlappingRectanglesDisjunctivePropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NonOverlappingRectanglesEnergyPropagator.html">NonOverlappingRectanglesEnergyPropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates using a box energy reasoning.  <a href="classoperations__research_1_1sat_1_1NonOverlappingRectanglesEnergyPropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraint.html">NoOverlap2DConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlapBetweenTwoIntervals.html">NoOverlapBetweenTwoIntervals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ObjectiveDefinition.html">ObjectiveDefinition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ObjectiveEncoder.html">ObjectiveEncoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ObjectiveShavingSolver.html">ObjectiveShavingSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1OpbReader.html">OpbReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1OrthogonalPackingInfeasibilityDetector.html">OrthogonalPackingInfeasibilityDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1OrthogonalPackingOptions.html">OrthogonalPackingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1OrthogonalPackingResult.html">OrthogonalPackingResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1PairwiseRestriction.html">PairwiseRestriction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html">PbConstraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1PbConstraintsEnqueueHelper.html">PbConstraintsEnqueueHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Percentile.html">Percentile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1PermutableEvent.html">PermutableEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1PermutableItem.html">PermutableItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1PostsolveClauses.html">PostsolveClauses</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html">PrecedenceRelations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html">PrecedencesPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PresolveTimer.html">PresolveTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Prober.html">Prober</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html">ProbingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ProbingRectangle.html">ProbingRectangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ProductDecomposer.html">ProductDecomposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to express a product as a linear constraint.  <a href="classoperations__research_1_1sat_1_1ProductDecomposer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html">ProductDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ProductPropagator.html">ProductPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PropagationGraph.html">PropagationGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1PropagationStatistics.html">PropagationStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class to display statistics at the end if &ndash;v=1.  <a href="structoperations__research_1_1sat_1_1PropagationStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PropagatorInterface.html">PropagatorInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for CP like propagators.  <a href="classoperations__research_1_1sat_1_1PropagatorInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ProtoLiteral.html">ProtoLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ProtoTrail.html">ProtoTrail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1PseudoCosts.html">PseudoCosts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1PushedSolutionPointers.html">PushedSolutionPointers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RandomIntervalSchedulingNeighborhoodGenerator.html">RandomIntervalSchedulingNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RandomPrecedenceSchedulingNeighborhoodGenerator.html">RandomPrecedenceSchedulingNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RandomPrecedencesPackingNeighborhoodGenerator.html">RandomPrecedencesPackingNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RandomRectanglesPackingNeighborhoodGenerator.html">RandomRectanglesPackingNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1Rectangle32.html">Rectangle32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RectanglePairwisePropagator.html">RectanglePairwisePropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagator that compares the boxes pairwise.  <a href="classoperations__research_1_1sat_1_1RectanglePairwisePropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RectanglesPackingRelaxOneNeighborhoodGenerator.html">RectanglesPackingRelaxOneNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RectanglesPackingRelaxTwoNeighborhoodsGenerator.html">RectanglesPackingRelaxTwoNeighborhoodsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ReducedDomainNeighborhood.html">ReducedDomainNeighborhood</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1Relation.html">Relation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RelaxationInducedNeighborhoodGenerator.html">RelaxationInducedNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator.html">RelaxRandomConstraintsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomVariablesGenerator.html">RelaxRandomVariablesGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ReservoirConstraint.html">ReservoirConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ReservoirTimeTabling.html">ReservoirTimeTabling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RestartPolicy.html">RestartPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contain the logic to decide when to restart a SAT tree search.  <a href="classoperations__research_1_1sat_1_1RestartPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RevIntegerValueRepository.html">RevIntegerValueRepository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RevIntRepository.html">RevIntRepository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RoundingDualFeasibleFunction.html">RoundingDualFeasibleFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RoundingDualFeasibleFunctionPowerOfTwo.html">RoundingDualFeasibleFunctionPowerOfTwo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above for k = 2^log2_k.  <a href="classoperations__research_1_1sat_1_1RoundingDualFeasibleFunctionPowerOfTwo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1RoundingOptions.html">RoundingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RoutingFullPathNeighborhoodGenerator.html">RoutingFullPathNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RoutingPathNeighborhoodGenerator.html">RoutingPathNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1RoutingRandomNeighborhoodGenerator.html">RoutingRandomNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatClause.html">SatClause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatCnfReader.html">SatCnfReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html">SatDecisionPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html">SatPostsolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SatPresolveOptions.html">SatPresolveOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html">SatPresolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all the SAT constraints.  <a href="classoperations__research_1_1sat_1_1SatPropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SavedLiteral.html">SavedLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SavedVariable.html">SavedVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ScatteredIntegerVector.html">ScatteredIntegerVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SccGraph.html">SccGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingResourceWindowsNeighborhoodGenerator.html">SchedulingResourceWindowsNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingTimeWindowNeighborhoodGenerator.html">SchedulingTimeWindowNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SearchHeuristics.html">SearchHeuristics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ShapePath.html">ShapePath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html">SharedBoundsManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SharedClasses.html">SharedClasses</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html">SharedClausesManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedIncompleteSolutionManager.html">SharedIncompleteSolutionManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedLPSolutionRepository.html">SharedLPSolutionRepository</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solutions coming from the LP.  <a href="classoperations__research_1_1sat_1_1SharedLPSolutionRepository.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedLsSolutionRepository.html">SharedLsSolutionRepository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedLsStates.html">SharedLsStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared set of local search states that we work on.  <a href="classoperations__research_1_1sat_1_1SharedLsStates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html">SharedSolutionRepository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedStatistics.html">SharedStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class to add statistics by name and print them at the end.  <a href="classoperations__research_1_1sat_1_1SharedStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedStatTables.html">SharedStatTables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the table we display after the solver is done.  <a href="classoperations__research_1_1sat_1_1SharedStatTables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedTreeManager.html">SharedTreeManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SharedTreeWorker.html">SharedTreeWorker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SingleShape.html">SingleShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SlicePackingNeighborhoodGenerator.html">SlicePackingNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SolutionCrush.html">SolutionCrush</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SortedSubsetSums.html">SortedSubsetSums</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yet another variant of <a class="el" href="classoperations__research_1_1sat_1_1FirstFewValues.html">FirstFewValues</a> or <a class="el" href="classoperations__research_1_1sat_1_1MaxBoundedSubsetSum.html">MaxBoundedSubsetSum</a>.  <a href="classoperations__research_1_1sat_1_1SortedSubsetSums.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SquarePropagator.html">SquarePropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html">StampingSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SubsetsDetector.html">SubsetsDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SubsolverNameFilter.html">SubsolverNameFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class used to filter executed subsolver names.  <a href="classoperations__research_1_1sat_1_1SubsolverNameFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SumOfAllDiffLowerBounder.html">SumOfAllDiffLowerBounder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for the AllDiff cut generator.  <a href="classoperations__research_1_1sat_1_1SumOfAllDiffLowerBounder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SweepLineIntervalTree.html">SweepLineIntervalTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SymmetryPropagator.html">SymmetryPropagator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SynchronizationPoint.html">SynchronizationPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper to add a synchronization point in the list of subsolvers.  <a href="classoperations__research_1_1sat_1_1SynchronizationPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1TableConstraint.html">TableConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1TaskSet.html">TaskSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1TaskTime.html">TaskTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ThetaLambdaTree.html">ThetaLambdaTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1TimeTableEdgeFinding.html">TimeTableEdgeFinding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1TimeTablingPerTask.html">TimeTablingPerTask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1TopN.html">TopN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">TopNCuts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1TryEdgeRectanglePropagator.html">TryEdgeRectanglePropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposed for testing.  <a href="classoperations__research_1_1sat_1_1TryEdgeRectanglePropagator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1UniqueClauseStream.html">UniqueClauseStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html">UpperBoundedLinearConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value and a literal.  <a href="structoperations__research_1_1sat_1_1ValueLiteralPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1VarDomainWrapper.html">VarDomainWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">VarDomination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1VariableGraphNeighborhoodGenerator.html">VariableGraphNeighborhoodGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1VariablesShavingSolver.html">VariablesShavingSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1VariableWithSameReasonIdentifier.html">VariableWithSameReasonIdentifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1VarValue.html">VarValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores one variable and its strategy value.  <a href="structoperations__research_1_1sat_1_1VarValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1VectorWithSparseUsage.html">VectorWithSparseUsage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html">ZeroHalfCutHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acd5fcd5e44b4b153afface289223dd33" id="r_acd5fcd5e44b4b153afface289223dd33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd5fcd5e44b4b153afface289223dd33">InlinedIntegerLiteralVector</a> = absl::InlinedVector&lt;<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>, 2&gt;</td></tr>
<tr class="separator:acd5fcd5e44b4b153afface289223dd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdc7202e90489453a3bad10f80f09b2" id="r_a5bdc7202e90489453a3bad10f80f09b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bdc7202e90489453a3bad10f80f09b2">InlinedIntegerValueVector</a></td></tr>
<tr class="separator:a5bdc7202e90489453a3bad10f80f09b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee23a6099757399dc02f68671fdb1d8" id="r_aeee23a6099757399dc02f68671fdb1d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeee23a6099757399dc02f68671fdb1d8">IntegerSumLE</a> = <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html">LinearConstraintPropagator</a>&lt;false&gt;</td></tr>
<tr class="separator:aeee23a6099757399dc02f68671fdb1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d80cf31433a6fc4056d15b5a9b719" id="r_ae30d80cf31433a6fc4056d15b5a9b719"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae30d80cf31433a6fc4056d15b5a9b719">IntegerSumLE128</a> = <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html">LinearConstraintPropagator</a>&lt;true&gt;</td></tr>
<tr class="separator:ae30d80cf31433a6fc4056d15b5a9b719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac235bd48eb39d15cc101516dc1e90" id="r_a0cac235bd48eb39d15cc101516dc1e90"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a></td></tr>
<tr class="separator:a0cac235bd48eb39d15cc101516dc1e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac235bd48eb39d15cc101516dc1e90" id="r_a0cac235bd48eb39d15cc101516dc1e90"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a></td></tr>
<tr class="separator:a0cac235bd48eb39d15cc101516dc1e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac235bd48eb39d15cc101516dc1e90" id="r_a0cac235bd48eb39d15cc101516dc1e90"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a></td></tr>
<tr class="separator:a0cac235bd48eb39d15cc101516dc1e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af43f853fdcf6994d2f1be241dd31d517" id="r_af43f853fdcf6994d2f1be241dd31d517"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af43f853fdcf6994d2f1be241dd31d517">EdgePosition</a> { <a class="el" href="#af43f853fdcf6994d2f1be241dd31d517a54dcb6d08ed106f80fb990c7e3d0e664">TOP</a> = 0
, <a class="el" href="#af43f853fdcf6994d2f1be241dd31d517a827d78bc9456a96bb4bd6f24a16ba895">RIGHT</a> = 1
, <a class="el" href="#af43f853fdcf6994d2f1be241dd31d517a879102c2cd3aef9e791f8cc518a04246">BOTTOM</a> = 2
, <a class="el" href="#af43f853fdcf6994d2f1be241dd31d517abb6bcae1852328684a190019a45167c2">LEFT</a> = 3
 }</td></tr>
<tr class="separator:af43f853fdcf6994d2f1be241dd31d517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd6f4cf7fb7b9e5d8788c7bb25b51ce" id="r_a6cd6f4cf7fb7b9e5d8788c7bb25b51ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51ce">SatFormat</a> { <a class="el" href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51ceafb2fc4a1eedd6bb627ed650068e1d808">DIMACS</a>
, <a class="el" href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51cea3dbd66c668bbf5fe6e580ad1ac38c9d8">DRAT</a>
 }</td></tr>
<tr class="memdesc:a6cd6f4cf7fb7b9e5d8788c7bb25b51ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The file formats that can be used to save a list of clauses.  <a href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51ce">More...</a><br /></td></tr>
<tr class="separator:a6cd6f4cf7fb7b9e5d8788c7bb25b51ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a62b204187763884e737d2f51aad8a" id="r_aa4a62b204187763884e737d2f51aad8a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4a62b204187763884e737d2f51aad8a">EnforcementStatus</a> { <a class="el" href="#aa4a62b204187763884e737d2f51aad8aadeab83d56dee7ab418359a59b4ff2eb0">IS_FALSE</a> = 0
, <a class="el" href="#aa4a62b204187763884e737d2f51aad8aace72848e83395346e4d3f58ccc6443d6">CANNOT_PROPAGATE</a> = 1
, <a class="el" href="#aa4a62b204187763884e737d2f51aad8aadfc44107d47903d2049d949e3b75065b">CAN_PROPAGATE</a> = 2
, <a class="el" href="#aa4a62b204187763884e737d2f51aad8aa4530573eddfc960e31ffd5624a07362d">IS_ENFORCED</a> = 3
 }</td></tr>
<tr class="separator:aa4a62b204187763884e737d2f51aad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e549ab3da5547f8c99169f6e26ec4e" id="r_af0e549ab3da5547f8c99169f6e26ec4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0e549ab3da5547f8c99169f6e26ec4e">IntegerVariablesToAddMask</a> { <a class="el" href="#af0e549ab3da5547f8c99169f6e26ec4ea5d612278e0fdd4dc98f532671a3d0b78">kStart</a> = 1 &lt;&lt; 0
, <a class="el" href="#af0e549ab3da5547f8c99169f6e26ec4eaca82d053e92486cbd854145d55e23dcd">kEnd</a> = 1 &lt;&lt; 1
, <a class="el" href="#af0e549ab3da5547f8c99169f6e26ec4ea1d016c585206cd74e630da3eb44a548e">kSize</a> = 1 &lt;&lt; 2
, <a class="el" href="#af0e549ab3da5547f8c99169f6e26ec4ea9ee08791f261c45b978bb0fcecbcbd32">kPresence</a> = 1 &lt;&lt; 3
 }</td></tr>
<tr class="memdesc:af0e549ab3da5547f8c99169f6e26ec4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts helpers.  <a href="#af0e549ab3da5547f8c99169f6e26ec4e">More...</a><br /></td></tr>
<tr class="separator:af0e549ab3da5547f8c99169f6e26ec4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55066a2cd55290e5cc385fbc363205" id="r_a1f55066a2cd55290e5cc385fbc363205"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f55066a2cd55290e5cc385fbc363205">ConstraintStatus</a> </td></tr>
<tr class="separator:a1f55066a2cd55290e5cc385fbc363205"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af4bda4a1e891ce16104b476b327af01e" id="r_af4bda4a1e891ce16104b476b327af01e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4bda4a1e891ce16104b476b327af01e">ProcessFloatingPointOVariablesAndObjective</a> (<a class="el" href="classoperations__research_1_1fz_1_1Model.html">fz::Model</a> *fz_model)</td></tr>
<tr class="separator:af4bda4a1e891ce16104b476b327af01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635874624086317f36f097b23b84d3eb" id="r_a635874624086317f36f097b23b84d3eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a635874624086317f36f097b23b84d3eb">SolveFzWithCpModelProto</a> (const <a class="el" href="classoperations__research_1_1fz_1_1Model.html">fz::Model</a> &amp;model, const <a class="el" href="structoperations__research_1_1fz_1_1FlatzincSatParameters.html">fz::FlatzincSatParameters</a> &amp;p, const std::string &amp;sat_params, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *solution_logger)</td></tr>
<tr class="memdesc:a635874624086317f36f097b23b84d3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the given flatzinc model using the CP-SAT solver.  <br /></td></tr>
<tr class="separator:a635874624086317f36f097b23b84d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9083888ba1b046703d2402a1a0994c" id="r_a7f9083888ba1b046703d2402a1a0994c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f9083888ba1b046703d2402a1a0994c">CreateAndRegisterMandatoryOverlapPropagator</a> (<a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">GenericLiteralWatcher</a> *watcher, int priority)</td></tr>
<tr class="separator:a7f9083888ba1b046703d2402a1a0994c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea8930e8c4adb6e5ffbf8a747049423" id="r_a1ea8930e8c4adb6e5ffbf8a747049423"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ea8930e8c4adb6e5ffbf8a747049423">GenerateNonConflictingRectangles</a> (int num_rectangles, absl::BitGenRef random)</td></tr>
<tr class="separator:a1ea8930e8c4adb6e5ffbf8a747049423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d194228f8d909459b83d199ba60493" id="r_a40d194228f8d909459b83d199ba60493"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40d194228f8d909459b83d199ba60493">GenerateNonConflictingRectanglesWithPacking</a> (std::pair&lt; IntegerValue, IntegerValue &gt; bb, int average_num_boxes, absl::BitGenRef random)</td></tr>
<tr class="separator:a40d194228f8d909459b83d199ba60493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e031be8d985befef7e59fe56356746" id="r_af0e031be8d985befef7e59fe56356746"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0e031be8d985befef7e59fe56356746">MakeItemsFromRectangles</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles, double slack_factor, absl::BitGenRef random)</td></tr>
<tr class="separator:af0e031be8d985befef7e59fe56356746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47a8fc574385d4cfed0a85234e8d0fd" id="r_ac47a8fc574385d4cfed0a85234e8d0fd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac47a8fc574385d4cfed0a85234e8d0fd">GenerateItemsRectanglesWithNoPairwiseConflict</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles, double slack_factor, absl::BitGenRef random)</td></tr>
<tr class="separator:ac47a8fc574385d4cfed0a85234e8d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98d2da0f736d2f7782c371adc0ff004" id="r_ab98d2da0f736d2f7782c371adc0ff004"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab98d2da0f736d2f7782c371adc0ff004">GenerateItemsRectanglesWithNoPairwisePropagation</a> (int num_rectangles, double slack_factor, absl::BitGenRef random)</td></tr>
<tr class="separator:ab98d2da0f736d2f7782c371adc0ff004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80355280b6a679a0e89bbeb71708f5cf" id="r_a80355280b6a679a0e89bbeb71708f5cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80355280b6a679a0e89bbeb71708f5cf">Preprocess</a> (absl::Span&lt; <a class="el" href="structoperations__research_1_1sat_1_1PermutableItem.html">PermutableItem</a> &gt; &amp;items, std::pair&lt; IntegerValue, IntegerValue &gt; &amp;bounding_box_size, int max_complexity)</td></tr>
<tr class="memdesc:a80355280b6a679a0e89bbeb71708f5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposed for testing.  <br /></td></tr>
<tr class="separator:a80355280b6a679a0e89bbeb71708f5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a25604744319c8a83fee36c10ff29f3" id="r_a4a25604744319c8a83fee36c10ff29f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1BruteForceResult.html">BruteForceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a25604744319c8a83fee36c10ff29f3">BruteForceOrthogonalPacking</a> (absl::Span&lt; const IntegerValue &gt; sizes_x, absl::Span&lt; const IntegerValue &gt; sizes_y, std::pair&lt; IntegerValue, IntegerValue &gt; bounding_box_size, int max_complexity)</td></tr>
<tr class="separator:a4a25604744319c8a83fee36c10ff29f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7dd0a73fe3618ca37a526969940761" id="r_aef7dd0a73fe3618ca37a526969940761"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef7dd0a73fe3618ca37a526969940761">PresolveFixed2dRectangles</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt; non_fixed_boxes, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *fixed_boxes)</td></tr>
<tr class="separator:aef7dd0a73fe3618ca37a526969940761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf29f7195014635a66a11fb41c254022" id="r_aaf29f7195014635a66a11fb41c254022"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf29f7195014635a66a11fb41c254022">ReduceNumberofBoxesGreedy</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *mandatory_rectangles, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *optional_rectangles)</td></tr>
<tr class="separator:aaf29f7195014635a66a11fb41c254022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee4308da9f3f45757bd8dde329cd0f9" id="r_acee4308da9f3f45757bd8dde329cd0f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Neighbours.html">Neighbours</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acee4308da9f3f45757bd8dde329cd0f9">BuildNeighboursGraph</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles)</td></tr>
<tr class="separator:acee4308da9f3f45757bd8dde329cd0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b69b90d6f71d58555815dec71d7126" id="r_a10b69b90d6f71d58555815dec71d7126"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b69b90d6f71d58555815dec71d7126">SplitInConnectedComponents</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Neighbours.html">Neighbours</a> &amp;neighbours)</td></tr>
<tr class="separator:a10b69b90d6f71d58555815dec71d7126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcc287ff62e3f8a4059720ec600fb79" id="r_a6dcc287ff62e3f8a4059720ec600fb79"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1SingleShape.html">SingleShape</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dcc287ff62e3f8a4059720ec600fb79">BoxesToShapes</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles, const <a class="el" href="classoperations__research_1_1sat_1_1Neighbours.html">Neighbours</a> &amp;neighbours)</td></tr>
<tr class="separator:a6dcc287ff62e3f8a4059720ec600fb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6def9f0c4da45842811ae480b12cd69" id="r_ab6def9f0c4da45842811ae480b12cd69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6def9f0c4da45842811ae480b12cd69">CutShapeIntoRectangles</a> (<a class="el" href="structoperations__research_1_1sat_1_1SingleShape.html">SingleShape</a> shape)</td></tr>
<tr class="separator:ab6def9f0c4da45842811ae480b12cd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7b47f29a76a183bf462cff8ec583e8" id="r_a0d7b47f29a76a183bf462cff8ec583e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7b47f29a76a183bf462cff8ec583e8">ReduceNumberOfBoxesExactMandatory</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *mandatory_rectangles, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *optional_rectangles)</td></tr>
<tr class="separator:a0d7b47f29a76a183bf462cff8ec583e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5b31875c1bdb84fd6ab2c57ba49a46" id="r_a7d5b31875c1bdb84fd6ab2c57ba49a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1Disjoint2dPackingResult.html">Disjoint2dPackingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d5b31875c1bdb84fd6ab2c57ba49a46">DetectDisjointRegionIn2dPacking</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt; non_fixed_boxes, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; fixed_boxes, int max_num_components)</td></tr>
<tr class="separator:a7d5b31875c1bdb84fd6ab2c57ba49a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac846743f0e786064c9d27ad91c7176a7" id="r_ac846743f0e786064c9d27ad91c7176a7"><td class="memTemplParams" colspan="2">template&lt;typename Sink&gt; </td></tr>
<tr class="memitem:ac846743f0e786064c9d27ad91c7176a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac846743f0e786064c9d27ad91c7176a7">AbslStringify</a> (Sink &amp;sink, <a class="el" href="#af43f853fdcf6994d2f1be241dd31d517">EdgePosition</a> e)</td></tr>
<tr class="separator:ac846743f0e786064c9d27ad91c7176a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959b472b3acf1de55a0d0c63b829ba7" id="r_a3959b472b3acf1de55a0d0c63b829ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3959b472b3acf1de55a0d0c63b829ba7">CreateAndRegisterTryEdgePropagator</a> (<a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">GenericLiteralWatcher</a> *watcher, int priority)</td></tr>
<tr class="separator:a3959b472b3acf1de55a0d0c63b829ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6288159500a998e1cf1ed597f17685bd" id="r_a6288159500a998e1cf1ed597f17685bd"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6288159500a998e1cf1ed597f17685bd">AllDifferentBinary</a> (absl::Span&lt; const IntegerVariable &gt; vars)</td></tr>
<tr class="separator:a6288159500a998e1cf1ed597f17685bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f2411ce337c1a67a4f1b2995f1f572" id="r_ae2f2411ce337c1a67a4f1b2995f1f572"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2f2411ce337c1a67a4f1b2995f1f572">AllDifferentOnBounds</a> (const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;expressions)</td></tr>
<tr class="separator:ae2f2411ce337c1a67a4f1b2995f1f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e01906c319c6ec58f26043d973916" id="r_a089e01906c319c6ec58f26043d973916"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a089e01906c319c6ec58f26043d973916">AllDifferentOnBounds</a> (absl::Span&lt; const IntegerVariable &gt; vars)</td></tr>
<tr class="separator:a089e01906c319c6ec58f26043d973916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac2a1cac1b45c80f43ebd78490468a8" id="r_adac2a1cac1b45c80f43ebd78490468a8"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adac2a1cac1b45c80f43ebd78490468a8">AllDifferentAC</a> (absl::Span&lt; const IntegerVariable &gt; variables)</td></tr>
<tr class="separator:adac2a1cac1b45c80f43ebd78490468a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df0c7e4537cd6479226c6262db24f18" id="r_a2df0c7e4537cd6479226c6262db24f18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2df0c7e4537cd6479226c6262db24f18">ExtractAssignment</a> (const LinearBooleanProblem &amp;problem, const <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp;solver, std::vector&lt; bool &gt; *assignment)</td></tr>
<tr class="separator:a2df0c7e4537cd6479226c6262db24f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe077e9fb0115e89e7e4cb9623b2d61a" id="r_abe077e9fb0115e89e7e4cb9623b2d61a"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe077e9fb0115e89e7e4cb9623b2d61a">ValidateBooleanProblem</a> (const LinearBooleanProblem &amp;problem)</td></tr>
<tr class="separator:abe077e9fb0115e89e7e4cb9623b2d61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a27047f906404c42b0f59a34ec50377" id="r_a7a27047f906404c42b0f59a34ec50377"><td class="memItemLeft" align="right" valign="top">CpModelProto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a27047f906404c42b0f59a34ec50377">BooleanProblemToCpModelproto</a> (const LinearBooleanProblem &amp;problem)</td></tr>
<tr class="separator:a7a27047f906404c42b0f59a34ec50377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d84927df689473b8cf695784f58140" id="r_a67d84927df689473b8cf695784f58140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67d84927df689473b8cf695784f58140">ChangeOptimizationDirection</a> (LinearBooleanProblem *problem)</td></tr>
<tr class="separator:a67d84927df689473b8cf695784f58140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df7b56e0026b783deeeff20487de7cf" id="r_a0df7b56e0026b783deeeff20487de7cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0df7b56e0026b783deeeff20487de7cf">LoadBooleanProblem</a> (const LinearBooleanProblem &amp;problem, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="memdesc:a0df7b56e0026b783deeeff20487de7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a BooleanProblem into a given <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> instance.  <br /></td></tr>
<tr class="separator:a0df7b56e0026b783deeeff20487de7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274467bd0b939aa8e494e2ed82404ffd" id="r_a274467bd0b939aa8e494e2ed82404ffd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a274467bd0b939aa8e494e2ed82404ffd">LoadAndConsumeBooleanProblem</a> (LinearBooleanProblem *problem, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:a274467bd0b939aa8e494e2ed82404ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f15cad54562c8611ebe62208a22b44" id="r_ae3f15cad54562c8611ebe62208a22b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3f15cad54562c8611ebe62208a22b44">UseObjectiveForSatAssignmentPreference</a> (const LinearBooleanProblem &amp;problem, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:ae3f15cad54562c8611ebe62208a22b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f424cb0f7d850405f57f24fd74c9304" id="r_a5f424cb0f7d850405f57f24fd74c9304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f424cb0f7d850405f57f24fd74c9304">AddObjectiveUpperBound</a> (const LinearBooleanProblem &amp;problem, Coefficient upper_bound, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="memdesc:a5f424cb0f7d850405f57f24fd74c9304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that the objective is smaller than the given upper bound.  <br /></td></tr>
<tr class="separator:a5f424cb0f7d850405f57f24fd74c9304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa66ad3013c6ba16dda49461da34ef" id="r_a02aa66ad3013c6ba16dda49461da34ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02aa66ad3013c6ba16dda49461da34ef">AddObjectiveConstraint</a> (const LinearBooleanProblem &amp;problem, bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:a02aa66ad3013c6ba16dda49461da34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a94daf3536dd065dd3d6660e14ae43" id="r_ad8a94daf3536dd065dd3d6660e14ae43"><td class="memItemLeft" align="right" valign="top">Coefficient&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a94daf3536dd065dd3d6660e14ae43">ComputeObjectiveValue</a> (const LinearBooleanProblem &amp;problem, const std::vector&lt; bool &gt; &amp;assignment)</td></tr>
<tr class="memdesc:ad8a94daf3536dd065dd3d6660e14ae43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective value under the current assignment.  <br /></td></tr>
<tr class="separator:ad8a94daf3536dd065dd3d6660e14ae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5488433478bfcf730825b9221e2d5e" id="r_abe5488433478bfcf730825b9221e2d5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe5488433478bfcf730825b9221e2d5e">IsAssignmentValid</a> (const LinearBooleanProblem &amp;problem, const std::vector&lt; bool &gt; &amp;assignment)</td></tr>
<tr class="memdesc:abe5488433478bfcf730825b9221e2d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that an assignment is valid for the given BooleanProblem.  <br /></td></tr>
<tr class="separator:abe5488433478bfcf730825b9221e2d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18679d8902d037df4ad5371ab25ad435" id="r_a18679d8902d037df4ad5371ab25ad435"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18679d8902d037df4ad5371ab25ad435">LinearBooleanProblemToCnfString</a> (const LinearBooleanProblem &amp;problem)</td></tr>
<tr class="separator:a18679d8902d037df4ad5371ab25ad435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208ca223ea68cdf0a4c3a3d69403be4d" id="r_a208ca223ea68cdf0a4c3a3d69403be4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a208ca223ea68cdf0a4c3a3d69403be4d">StoreAssignment</a> (const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp;assignment, BooleanAssignment *output)</td></tr>
<tr class="separator:a208ca223ea68cdf0a4c3a3d69403be4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443952c1a8ca3d057c079644f71dc0fd" id="r_a443952c1a8ca3d057c079644f71dc0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a443952c1a8ca3d057c079644f71dc0fd">ExtractSubproblem</a> (const LinearBooleanProblem &amp;problem, const std::vector&lt; int &gt; &amp;constraint_indices, LinearBooleanProblem *subproblem)</td></tr>
<tr class="memdesc:a443952c1a8ca3d057c079644f71dc0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sub-problem formed by the constraints with given indices.  <br /></td></tr>
<tr class="separator:a443952c1a8ca3d057c079644f71dc0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a840612629fd37d42870c23e183609" id="r_af2a840612629fd37d42870c23e183609"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a>&gt; </td></tr>
<tr class="memitem:af2a840612629fd37d42870c23e183609"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2a840612629fd37d42870c23e183609">GenerateGraphForSymmetryDetection</a> (const LinearBooleanProblem &amp;problem, std::vector&lt; int &gt; *initial_equivalence_classes)</td></tr>
<tr class="separator:af2a840612629fd37d42870c23e183609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398107d209dc3d829796a9060faa8501" id="r_a398107d209dc3d829796a9060faa8501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a398107d209dc3d829796a9060faa8501">MakeAllLiteralsPositive</a> (LinearBooleanProblem *problem)</td></tr>
<tr class="separator:a398107d209dc3d829796a9060faa8501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75271e8da6c6cb4c5c87226e150d47d7" id="r_a75271e8da6c6cb4c5c87226e150d47d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75271e8da6c6cb4c5c87226e150d47d7">FindLinearBooleanProblemSymmetries</a> (const LinearBooleanProblem &amp;problem, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *generators)</td></tr>
<tr class="separator:a75271e8da6c6cb4c5c87226e150d47d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1133b1086a2b84ebae1661a744df5a50" id="r_a1133b1086a2b84ebae1661a744df5a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1133b1086a2b84ebae1661a744df5a50">ApplyLiteralMappingToBooleanProblem</a> (const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; LiteralIndex, LiteralIndex &gt; &amp;mapping, LinearBooleanProblem *problem)</td></tr>
<tr class="separator:a1133b1086a2b84ebae1661a744df5a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a37142e38a0a290d70b030405db801" id="r_a60a37142e38a0a290d70b030405db801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a37142e38a0a290d70b030405db801">ProbeAndSimplifyProblem</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html">SatPostsolver</a> *postsolver, LinearBooleanProblem *problem)</td></tr>
<tr class="separator:a60a37142e38a0a290d70b030405db801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bcd287bd18e3a940d997aafb9321a9" id="r_a16bcd287bd18e3a940d997aafb9321a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16bcd287bd18e3a940d997aafb9321a9">AddOffsetAndScaleObjectiveValue</a> (const LinearBooleanProblem &amp;problem, Coefficient v)</td></tr>
<tr class="memdesc:a16bcd287bd18e3a940d997aafb9321a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the offset and returns the scaled version of the given objective value.  <br /></td></tr>
<tr class="separator:a16bcd287bd18e3a940d997aafb9321a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1465f989d9ff7138b62c25eea5ab1a" id="r_a2d1465f989d9ff7138b62c25eea5ab1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d1465f989d9ff7138b62c25eea5ab1a">SolveCpModelWithParameters</a> (const void *creq, int creq_len, const void *cparams, int cparams_len, void **cres, int *cres_len)</td></tr>
<tr class="separator:a2d1465f989d9ff7138b62c25eea5ab1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dc756eed847e0f0f77824695b24943" id="r_ac9dc756eed847e0f0f77824695b24943"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9dc756eed847e0f0f77824695b24943">SolveCpNewAtomicBool</a> ()</td></tr>
<tr class="separator:ac9dc756eed847e0f0f77824695b24943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0df7f3393a26a60e4a6816a21ea5c3" id="r_acf0df7f3393a26a60e4a6816a21ea5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf0df7f3393a26a60e4a6816a21ea5c3">SolveCpDestroyAtomicBool</a> (void *const atomic_bool)</td></tr>
<tr class="separator:acf0df7f3393a26a60e4a6816a21ea5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4101b7d436bf6e0a4414490bf987c18a" id="r_a4101b7d436bf6e0a4414490bf987c18a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4101b7d436bf6e0a4414490bf987c18a">SolveCpStopSolve</a> (void *const atomic_bool)</td></tr>
<tr class="separator:a4101b7d436bf6e0a4414490bf987c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4a6a05ee3d12f1391ed11f529907ff" id="r_a1a4a6a05ee3d12f1391ed11f529907ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4a6a05ee3d12f1391ed11f529907ff">SolveCpInterruptible</a> (void *const limit_reached, const void *creq, int creq_len, const void *cparams, int cparams_len, void **cres, int *cres_len)</td></tr>
<tr class="separator:a1a4a6a05ee3d12f1391ed11f529907ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad991297f9637c704d1824dc9513ab8b8" id="r_ad991297f9637c704d1824dc9513ab8b8"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad991297f9637c704d1824dc9513ab8b8">ExactlyOnePerRowAndPerColumn</a> (absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; graph)</td></tr>
<tr class="separator:ad991297f9637c704d1824dc9513ab8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3609d4b9a2bd583c9daaa19a2f27e711" id="r_a3609d4b9a2bd583c9daaa19a2f27e711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3609d4b9a2bd583c9daaa19a2f27e711">LoadSubcircuitConstraint</a> (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, bool multiple_subcircuit_through_zero)</td></tr>
<tr class="separator:a3609d4b9a2bd583c9daaa19a2f27e711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eccc333150afd49596f53fec23d2a4b" id="r_a6eccc333150afd49596f53fec23d2a4b"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eccc333150afd49596f53fec23d2a4b">CircuitCovering</a> (absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; graph, absl::Span&lt; const int &gt; distinguished_nodes)</td></tr>
<tr class="separator:a6eccc333150afd49596f53fec23d2a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d56da965ecd3194b8aa8683f8e5e09" id="r_a91d56da965ecd3194b8aa8683f8e5e09"><td class="memTemplParams" colspan="2">template&lt;class IntContainer&gt; </td></tr>
<tr class="memitem:a91d56da965ecd3194b8aa8683f8e5e09"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91d56da965ecd3194b8aa8683f8e5e09">ReindexArcs</a> (IntContainer *tails, IntContainer *heads, absl::flat_hash_map&lt; int, int &gt; *mapping_output=nullptr)</td></tr>
<tr class="separator:a91d56da965ecd3194b8aa8683f8e5e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0699275a4e8ee3496cef3657c360ad2b" id="r_a0699275a4e8ee3496cef3657c360ad2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0699275a4e8ee3496cef3657c360ad2b">TrySolution</a> (const CpModelProto &amp;model, absl::Span&lt; const int64_t &gt; <a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>, absl::Span&lt; const int64_t &gt; new_solution, absl::Span&lt; const int64_t &gt; base_solution, std::vector&lt; int64_t &gt; *new_combined_solution)</td></tr>
<tr class="separator:a0699275a4e8ee3496cef3657c360ad2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f3aff918cf9fa95f5922cbb93d125e" id="r_a84f3aff918cf9fa95f5922cbb93d125e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84f3aff918cf9fa95f5922cbb93d125e">FindCombinedSolution</a> (const CpModelProto &amp;model, absl::Span&lt; const int64_t &gt; new_solution, absl::Span&lt; const int64_t &gt; base_solution, const <a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *response_manager, std::string *solution_info)</td></tr>
<tr class="separator:a84f3aff918cf9fa95f5922cbb93d125e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4192af14f7971beec13bcd9dc390487" id="r_ad4192af14f7971beec13bcd9dc390487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1PushedSolutionPointers.html">PushedSolutionPointers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4192af14f7971beec13bcd9dc390487">PushAndMaybeCombineSolution</a> (<a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *response_manager, const CpModelProto &amp;model_proto, absl::Span&lt; const int64_t &gt; new_solution, const std::string &amp;solution_info, absl::Span&lt; const int64_t &gt; base_solution, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ad4192af14f7971beec13bcd9dc390487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248f26fb2b8d0a4b25994f904c80150" id="r_a2248f26fb2b8d0a4b25994f904c80150"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2248f26fb2b8d0a4b25994f904c80150">OverlapOfTwoIntervals</a> (const ConstraintProto &amp;interval1, const ConstraintProto &amp;interval2, absl::Span&lt; const int64_t &gt; <a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>)</td></tr>
<tr class="memdesc:a2248f26fb2b8d0a4b25994f904c80150"><td class="mdescLeft">&#160;</td><td class="mdescRight">--&mdash; <a class="el" href="classoperations__research_1_1sat_1_1CompiledNoOverlap2dConstraint.html">CompiledNoOverlap2dConstraint</a> --&mdash;  <br /></td></tr>
<tr class="separator:a2248f26fb2b8d0a4b25994f904c80150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9543ecb1cf6d394e2919cedde21cf6ed" id="r_a9543ecb1cf6d394e2919cedde21cf6ed"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9543ecb1cf6d394e2919cedde21cf6ed">NoOverlapMinRepairDistance</a> (const ConstraintProto &amp;interval1, const ConstraintProto &amp;interval2, absl::Span&lt; const int64_t &gt; <a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>)</td></tr>
<tr class="separator:a9543ecb1cf6d394e2919cedde21cf6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5bbe785cc30e5861b5e0e161a998c" id="r_a1fe5bbe785cc30e5861b5e0e161a998c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe5bbe785cc30e5861b5e0e161a998c">AddCircuitFlowConstraints</a> (<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html">LinearIncrementalEvaluator</a> &amp;linear_evaluator, const ConstraintProto &amp;ct_proto)</td></tr>
<tr class="separator:a1fe5bbe785cc30e5861b5e0e161a998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d28f8e2aa38a7c39feee848168a26c" id="r_ac4d28f8e2aa38a7c39feee848168a26c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; IntegerValue &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4d28f8e2aa38a7c39feee848168a26c">ToIntegerValueVector</a> (absl::Span&lt; const int64_t &gt; <a class="el" href="parser_8yy_8cc.html#a5a634cf4429798b1c921a81de8250051">input</a>)</td></tr>
<tr class="separator:ac4d28f8e2aa38a7c39feee848168a26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1281483ec40c05251f937bf10b25603d" id="r_a1281483ec40c05251f937bf10b25603d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1281483ec40c05251f937bf10b25603d">LiteralXorIs</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;literals, bool value)</td></tr>
<tr class="memdesc:a1281483ec40c05251f937bf10b25603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces the XOR of a set of literals to be equal to the given value.  <br /></td></tr>
<tr class="separator:a1281483ec40c05251f937bf10b25603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecdc69e06c5414f4e20a755b94f70f7" id="r_a0ecdc69e06c5414f4e20a755b94f70f7"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ecdc69e06c5414f4e20a755b94f70f7">GreaterThanAtLeastOneOf</a> (IntegerVariable target_var, const absl::Span&lt; const IntegerVariable &gt; vars, const absl::Span&lt; const IntegerValue &gt; offsets, const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; selectors, const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcements)</td></tr>
<tr class="separator:a0ecdc69e06c5414f4e20a755b94f70f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1920a590c197db1c4cb7beac6cf4a4f6" id="r_a1920a590c197db1c4cb7beac6cf4a4f6"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1920a590c197db1c4cb7beac6cf4a4f6">PartialIsOneOfVar</a> (IntegerVariable target_var, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; selectors)</td></tr>
<tr class="separator:a1920a590c197db1c4cb7beac6cf4a4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3de118c1f8dd5a7ec21704e05684b9" id="r_a5e3de118c1f8dd5a7ec21704e05684b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e3de118c1f8dd5a7ec21704e05684b9">Not</a> (<a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a> x)</td></tr>
<tr class="separator:a5e3de118c1f8dd5a7ec21704e05684b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807d4ae4dc98ad0c05fa05c3f1dfabc9" id="r_a807d4ae4dc98ad0c05fa05c3f1dfabc9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a807d4ae4dc98ad0c05fa05c3f1dfabc9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a> &amp;var)</td></tr>
<tr class="separator:a807d4ae4dc98ad0c05fa05c3f1dfabc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007d129b4917935f84c9ae0823c2cb11" id="r_a007d129b4917935f84c9ae0823c2cb11"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a007d129b4917935f84c9ae0823c2cb11">VarDebugString</a> (const CpModelProto &amp;proto, int index)</td></tr>
<tr class="separator:a007d129b4917935f84c9ae0823c2cb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1b0a196a70f7edd0ff1bc0250e76ac" id="r_a0c1b0a196a70f7edd0ff1bc0250e76ac"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c1b0a196a70f7edd0ff1bc0250e76ac">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classoperations__research_1_1sat_1_1IntVar.html">IntVar</a> &amp;var)</td></tr>
<tr class="separator:a0c1b0a196a70f7edd0ff1bc0250e76ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616a1843aa394d2d018e052050588bb2" id="r_a616a1843aa394d2d018e052050588bb2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a616a1843aa394d2d018e052050588bb2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;e)</td></tr>
<tr class="separator:a616a1843aa394d2d018e052050588bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1168782300a1c64e854ec6f1ead1ea" id="r_a4c1168782300a1c64e854ec6f1ead1ea"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c1168782300a1c64e854ec6f1ead1ea">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;e)</td></tr>
<tr class="separator:a4c1168782300a1c64e854ec6f1ead1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeefd0a183a2d1c9f09fec0aa52b200a" id="r_afeefd0a183a2d1c9f09fec0aa52b200a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeefd0a183a2d1c9f09fec0aa52b200a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classoperations__research_1_1sat_1_1IntervalVar.html">IntervalVar</a> &amp;var)</td></tr>
<tr class="separator:afeefd0a183a2d1c9f09fec0aa52b200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fe86bc876c281163a053a9581346c3" id="r_ab6fe86bc876c281163a053a9581346c3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6fe86bc876c281163a053a9581346c3">SolutionIntegerValue</a> (const CpSolverResponse &amp;r, const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab6fe86bc876c281163a053a9581346c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the value of an linear expression in a solver response.  <br /></td></tr>
<tr class="separator:ab6fe86bc876c281163a053a9581346c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa415e372a9d64eede869ed98666c29c" id="r_afa415e372a9d64eede869ed98666c29c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa415e372a9d64eede869ed98666c29c">SolutionBooleanValue</a> (const CpSolverResponse &amp;r, <a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a> x)</td></tr>
<tr class="memdesc:afa415e372a9d64eede869ed98666c29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the value of a Boolean literal in a solver response.  <br /></td></tr>
<tr class="separator:afa415e372a9d64eede869ed98666c29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb67cecc84690abd0a358d0e2c9cd7c" id="r_aadb67cecc84690abd0a358d0e2c9cd7c"><td class="memTemplParams" colspan="2">template&lt;typename H&gt; </td></tr>
<tr class="memitem:aadb67cecc84690abd0a358d0e2c9cd7c"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadb67cecc84690abd0a358d0e2c9cd7c">AbslHashValue</a> (H h, const <a class="el" href="classoperations__research_1_1sat_1_1IntVar.html">IntVar</a> &amp;<a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>)</td></tr>
<tr class="memdesc:aadb67cecc84690abd0a358d0e2c9cd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">&ndash; ABSL HASHING SUPPORT --------------------------------------------------&mdash;  <br /></td></tr>
<tr class="separator:aadb67cecc84690abd0a358d0e2c9cd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa34d9202fc74c65575e29c573ee5900" id="r_aaa34d9202fc74c65575e29c573ee5900"><td class="memTemplParams" colspan="2">template&lt;typename H&gt; </td></tr>
<tr class="memitem:aaa34d9202fc74c65575e29c573ee5900"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa34d9202fc74c65575e29c573ee5900">AbslHashValue</a> (H h, const <a class="el" href="classoperations__research_1_1sat_1_1IntervalVar.html">IntervalVar</a> &amp;<a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>)</td></tr>
<tr class="separator:aaa34d9202fc74c65575e29c573ee5900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f6d80163fd6aa41fec7ebf8e27949a" id="r_a49f6d80163fd6aa41fec7ebf8e27949a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f6d80163fd6aa41fec7ebf8e27949a">operator-</a> (<a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> expr)</td></tr>
<tr class="separator:a49f6d80163fd6aa41fec7ebf8e27949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d680e53b769b0bf60b6613d27994df" id="r_a14d680e53b769b0bf60b6613d27994df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14d680e53b769b0bf60b6613d27994df">operator+</a> (const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a14d680e53b769b0bf60b6613d27994df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c3650a2627f7072b46545ba712da1c" id="r_a70c3650a2627f7072b46545ba712da1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70c3650a2627f7072b46545ba712da1c">operator+</a> (<a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a70c3650a2627f7072b46545ba712da1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d9b25ef5642c457636001e9393034e" id="r_af5d9b25ef5642c457636001e9393034e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d9b25ef5642c457636001e9393034e">operator+</a> (const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:af5d9b25ef5642c457636001e9393034e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a296a3b389239ce1ffef3527bfa1e3" id="r_a12a296a3b389239ce1ffef3527bfa1e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12a296a3b389239ce1ffef3527bfa1e3">operator+</a> (<a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a12a296a3b389239ce1ffef3527bfa1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd485d7f6b2ccacff90294455d30ae5" id="r_aedd485d7f6b2ccacff90294455d30ae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedd485d7f6b2ccacff90294455d30ae5">operator-</a> (const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:aedd485d7f6b2ccacff90294455d30ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d4cee395c01f64847f322fd74f3613" id="r_a62d4cee395c01f64847f322fd74f3613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62d4cee395c01f64847f322fd74f3613">operator-</a> (<a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a62d4cee395c01f64847f322fd74f3613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1083f8028e54d27eec081e45d92da3da" id="r_a1083f8028e54d27eec081e45d92da3da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1083f8028e54d27eec081e45d92da3da">operator-</a> (const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a1083f8028e54d27eec081e45d92da3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29f5117f4220225e73e5984196315a7" id="r_ab29f5117f4220225e73e5984196315a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29f5117f4220225e73e5984196315a7">operator-</a> (<a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:ab29f5117f4220225e73e5984196315a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e220860af1fa89265bd640ab575c94" id="r_ae5e220860af1fa89265bd640ab575c94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5e220860af1fa89265bd640ab575c94">operator*</a> (<a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> expr, int64_t factor)</td></tr>
<tr class="separator:ae5e220860af1fa89265bd640ab575c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b127fca095a77a5c789d443f522fbbb" id="r_a1b127fca095a77a5c789d443f522fbbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b127fca095a77a5c789d443f522fbbb">operator*</a> (int64_t factor, <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> expr)</td></tr>
<tr class="separator:a1b127fca095a77a5c789d443f522fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef55954ce104b703b05f5a926a55c52" id="r_a3ef55954ce104b703b05f5a926a55c52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ef55954ce104b703b05f5a926a55c52">operator-</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> expr)</td></tr>
<tr class="memdesc:a3ef55954ce104b703b05f5a926a55c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>.  <br /></td></tr>
<tr class="separator:a3ef55954ce104b703b05f5a926a55c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedef397b25c1cc6909adcae18a820e9" id="r_adedef397b25c1cc6909adcae18a820e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adedef397b25c1cc6909adcae18a820e9">operator+</a> (const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:adedef397b25c1cc6909adcae18a820e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23499bc93d6b2ab81e91ea946e2780c8" id="r_a23499bc93d6b2ab81e91ea946e2780c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23499bc93d6b2ab81e91ea946e2780c8">operator+</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a23499bc93d6b2ab81e91ea946e2780c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdaf49a2294d9fd664ce3ad0360d501" id="r_a0bdaf49a2294d9fd664ce3ad0360d501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bdaf49a2294d9fd664ce3ad0360d501">operator+</a> (const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a0bdaf49a2294d9fd664ce3ad0360d501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5317d7f37f16096d85dfc5a7f05bed77" id="r_a5317d7f37f16096d85dfc5a7f05bed77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5317d7f37f16096d85dfc5a7f05bed77">operator+</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a5317d7f37f16096d85dfc5a7f05bed77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60111592f54952fd8d14692750ac5617" id="r_a60111592f54952fd8d14692750ac5617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60111592f54952fd8d14692750ac5617">operator+</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> expr, double rhs)</td></tr>
<tr class="separator:a60111592f54952fd8d14692750ac5617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8958bf1527cb994a0d7553282dd731f2" id="r_a8958bf1527cb994a0d7553282dd731f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8958bf1527cb994a0d7553282dd731f2">operator+</a> (double lhs, <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> expr)</td></tr>
<tr class="separator:a8958bf1527cb994a0d7553282dd731f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed1cd9aca1c45ff97111ebfe1d8c555" id="r_a1ed1cd9aca1c45ff97111ebfe1d8c555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ed1cd9aca1c45ff97111ebfe1d8c555">operator-</a> (const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:a1ed1cd9aca1c45ff97111ebfe1d8c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade32b256f6277fd7a7e52c3a17128b96" id="r_ade32b256f6277fd7a7e52c3a17128b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade32b256f6277fd7a7e52c3a17128b96">operator-</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;lhs, const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;rhs)</td></tr>
<tr class="separator:ade32b256f6277fd7a7e52c3a17128b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a77b7fe5f2ae90130d7f9cf20a995a" id="r_a37a77b7fe5f2ae90130d7f9cf20a995a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37a77b7fe5f2ae90130d7f9cf20a995a">operator-</a> (const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a37a77b7fe5f2ae90130d7f9cf20a995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90add9340d2579eed96c65f248306982" id="r_a90add9340d2579eed96c65f248306982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90add9340d2579eed96c65f248306982">operator-</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;lhs, <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a90add9340d2579eed96c65f248306982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cbabfb6c894b12ffb48181248c2c87" id="r_a49cbabfb6c894b12ffb48181248c2c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49cbabfb6c894b12ffb48181248c2c87">operator-</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> epxr, double rhs)</td></tr>
<tr class="separator:a49cbabfb6c894b12ffb48181248c2c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962810e4d6e648b9bdd8a6147e6ecd8c" id="r_a962810e4d6e648b9bdd8a6147e6ecd8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962810e4d6e648b9bdd8a6147e6ecd8c">operator-</a> (double lhs, <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> expr)</td></tr>
<tr class="separator:a962810e4d6e648b9bdd8a6147e6ecd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad89939d32828716e2f01940e81ce4a" id="r_a8ad89939d32828716e2f01940e81ce4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad89939d32828716e2f01940e81ce4a">operator*</a> (<a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> expr, double factor)</td></tr>
<tr class="separator:a8ad89939d32828716e2f01940e81ce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f88f13d009bea305340ad747262317" id="r_ac5f88f13d009bea305340ad747262317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f88f13d009bea305340ad747262317">operator*</a> (double factor, <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> expr)</td></tr>
<tr class="separator:ac5f88f13d009bea305340ad747262317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b1038b63ced09f0c7239a726dbe790" id="r_a94b1038b63ced09f0c7239a726dbe790"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94b1038b63ced09f0c7239a726dbe790">PossibleIntegerOverflow</a> (const CpModelProto &amp;model, absl::Span&lt; const int &gt; vars, absl::Span&lt; const int64_t &gt; coeffs, int64_t offset)</td></tr>
<tr class="separator:a94b1038b63ced09f0c7239a726dbe790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eec7d4958da587ee893e334ab7756cc" id="r_a2eec7d4958da587ee893e334ab7756cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eec7d4958da587ee893e334ab7756cc">ValidateCpModel</a> (const CpModelProto &amp;model, bool after_presolve)</td></tr>
<tr class="separator:a2eec7d4958da587ee893e334ab7756cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2073b9c892ac56b197b31cb583e25f3d" id="r_a2073b9c892ac56b197b31cb583e25f3d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2073b9c892ac56b197b31cb583e25f3d">ValidateInputCpModel</a> (const SatParameters &amp;params, const CpModelProto &amp;model)</td></tr>
<tr class="separator:a2073b9c892ac56b197b31cb583e25f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f808a9d169b2b074a23d52cc86f18aa" id="r_a3f808a9d169b2b074a23d52cc86f18aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f808a9d169b2b074a23d52cc86f18aa">ConstraintIsFeasible</a> (const CpModelProto &amp;model, const ConstraintProto &amp;constraint, absl::Span&lt; const int64_t &gt; variable_values)</td></tr>
<tr class="separator:a3f808a9d169b2b074a23d52cc86f18aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336d2faa10d80d646232f5e6d91891d4" id="r_a336d2faa10d80d646232f5e6d91891d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a336d2faa10d80d646232f5e6d91891d4">SolutionIsFeasible</a> (const CpModelProto &amp;model, absl::Span&lt; const int64_t &gt; variable_values, const CpModelProto *mapping_proto, const std::vector&lt; int &gt; *postsolve_mapping)</td></tr>
<tr class="separator:a336d2faa10d80d646232f5e6d91891d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc46bf1380ba6450d83513096326146" id="r_a4cc46bf1380ba6450d83513096326146"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc46bf1380ba6450d83513096326146">ImportModelWithBasicPresolveIntoContext</a> (const CpModelProto &amp;in_model, <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a4cc46bf1380ba6450d83513096326146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456dcb4946579eafb5e3ce4059b5a6be" id="r_a456dcb4946579eafb5e3ce4059b5a6be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a456dcb4946579eafb5e3ce4059b5a6be">ImportModelAndDomainsWithBasicPresolveIntoContext</a> (const CpModelProto &amp;in_model, absl::Span&lt; const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; domains, std::function&lt; bool(int)&gt; active_constraints, <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a456dcb4946579eafb5e3ce4059b5a6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5349a83e5dcf17ebb4862cd15f9d595" id="r_ab5349a83e5dcf17ebb4862cd15f9d595"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5349a83e5dcf17ebb4862cd15f9d595">CopyEverythingExceptVariablesAndConstraintsFieldsIntoContext</a> (const CpModelProto &amp;in_model, <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="memdesc:ab5349a83e5dcf17ebb4862cd15f9d595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the non constraint, non variables part of the model.  <br /></td></tr>
<tr class="separator:ab5349a83e5dcf17ebb4862cd15f9d595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313297bca1475c995d9a4139cb790cc8" id="r_a313297bca1475c995d9a4139cb790cc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a313297bca1475c995d9a4139cb790cc8">ExpandCpModel</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a313297bca1475c995d9a4139cb790cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9665c030067d31a2aa2c9376228eab59" id="r_a9665c030067d31a2aa2c9376228eab59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9665c030067d31a2aa2c9376228eab59">FinalExpansionForLinearConstraint</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a9665c030067d31a2aa2c9376228eab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6fa507fbbee0406152f493e0dfb95b" id="r_a4f6fa507fbbee0406152f493e0dfb95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html">Neighborhood</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f6fa507fbbee0406152f493e0dfb95b">GenerateSchedulingNeighborhoodFromIntervalPrecedences</a> (const absl::Span&lt; const std::pair&lt; int, int &gt; &gt; precedences, const CpSolverResponse &amp;initial_solution, const <a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html">NeighborhoodGeneratorHelper</a> &amp;helper)</td></tr>
<tr class="separator:a4f6fa507fbbee0406152f493e0dfb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6078c1c54d29bceb642ec436017a3093" id="r_a6078c1c54d29bceb642ec436017a3093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html">Neighborhood</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6078c1c54d29bceb642ec436017a3093">GenerateSchedulingNeighborhoodFromRelaxedIntervals</a> (absl::Span&lt; const int &gt; intervals_to_relax, absl::Span&lt; const int &gt; variables_to_fix, const CpSolverResponse &amp;initial_solution, absl::BitGenRef random, const <a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html">NeighborhoodGeneratorHelper</a> &amp;helper)</td></tr>
<tr class="separator:a6078c1c54d29bceb642ec436017a3093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e5d5cb3e7eb43191d094fc4752b5c6" id="r_a47e5d5cb3e7eb43191d094fc4752b5c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e5d5cb3e7eb43191d094fc4752b5c6">LoadVariables</a> (const CpModelProto &amp;model_proto, bool view_all_booleans_as_integers, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a47e5d5cb3e7eb43191d094fc4752b5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c230730625662a2a2032da620b6c6e" id="r_a64c230730625662a2a2032da620b6c6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64c230730625662a2a2032da620b6c6e">LoadBooleanSymmetries</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a64c230730625662a2a2032da620b6c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa73e23a5cfae0eaf253c2e2518e05e7" id="r_afa73e23a5cfae0eaf253c2e2518e05e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa73e23a5cfae0eaf253c2e2518e05e7">ExtractEncoding</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:afa73e23a5cfae0eaf253c2e2518e05e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89efb582832622f508e29d0c32f56ca9" id="r_a89efb582832622f508e29d0c32f56ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89efb582832622f508e29d0c32f56ca9">ExtractElementEncoding</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a89efb582832622f508e29d0c32f56ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ebf465eb7ccee4f79a5b8cfccfe7d9" id="r_ad1ebf465eb7ccee4f79a5b8cfccfe7d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1ebf465eb7ccee4f79a5b8cfccfe7d9">PropagateEncodingFromEquivalenceRelations</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:ad1ebf465eb7ccee4f79a5b8cfccfe7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3216f11aeb59c8cd63d2a1e8cdc6d47b" id="r_a3216f11aeb59c8cd63d2a1e8cdc6d47b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3216f11aeb59c8cd63d2a1e8cdc6d47b">DetectOptionalVariables</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="memdesc:a3216f11aeb59c8cd63d2a1e8cdc6d47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically detect optional variables.  <br /></td></tr>
<tr class="separator:a3216f11aeb59c8cd63d2a1e8cdc6d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e8cb71b79a363fcf4e3f5bc91a0cda" id="r_a77e8cb71b79a363fcf4e3f5bc91a0cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77e8cb71b79a363fcf4e3f5bc91a0cda">AddFullEncodingFromSearchBranching</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a77e8cb71b79a363fcf4e3f5bc91a0cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32358b01352ff3e6ccb494789264ae00" id="r_a32358b01352ff3e6ccb494789264ae00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32358b01352ff3e6ccb494789264ae00">LoadBoolOrConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a32358b01352ff3e6ccb494789264ae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29def40923c6b49578f7f0b8658bbf1" id="r_ab29def40923c6b49578f7f0b8658bbf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29def40923c6b49578f7f0b8658bbf1">LoadBoolAndConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:ab29def40923c6b49578f7f0b8658bbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ba965c06434561f068b227d5b1f8a3" id="r_a74ba965c06434561f068b227d5b1f8a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ba965c06434561f068b227d5b1f8a3">LoadAtMostOneConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a74ba965c06434561f068b227d5b1f8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83d747b5d6d82dc4e1c55d9f69d8626" id="r_ab83d747b5d6d82dc4e1c55d9f69d8626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab83d747b5d6d82dc4e1c55d9f69d8626">LoadExactlyOneConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:ab83d747b5d6d82dc4e1c55d9f69d8626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0677696952c26c0cfdd5b8336ad991f8" id="r_a0677696952c26c0cfdd5b8336ad991f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0677696952c26c0cfdd5b8336ad991f8">LoadBoolXorConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a0677696952c26c0cfdd5b8336ad991f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af162f5376a8d8234b9287b5c8163c1" id="r_a2af162f5376a8d8234b9287b5c8163c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af162f5376a8d8234b9287b5c8163c1">SplitAndLoadIntermediateConstraints</a> (bool lb_required, bool ub_required, std::vector&lt; IntegerVariable &gt; *vars, std::vector&lt; int64_t &gt; *coeffs, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a2af162f5376a8d8234b9287b5c8163c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade08c3522dfce173ee1fd50fab3bd3c0" id="r_ade08c3522dfce173ee1fd50fab3bd3c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade08c3522dfce173ee1fd50fab3bd3c0">LoadLinearConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:ade08c3522dfce173ee1fd50fab3bd3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bcd1e78c91d4c861a784deb8a9f80" id="r_a968bcd1e78c91d4c861a784deb8a9f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a968bcd1e78c91d4c861a784deb8a9f80">LoadAllDiffConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a968bcd1e78c91d4c861a784deb8a9f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a700cf4c7395801227fff94daf5cd64" id="r_a2a700cf4c7395801227fff94daf5cd64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a700cf4c7395801227fff94daf5cd64">LoadIntProdConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a2a700cf4c7395801227fff94daf5cd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff17ce80f88bebcf893741c5e86b7275" id="r_aff17ce80f88bebcf893741c5e86b7275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff17ce80f88bebcf893741c5e86b7275">LoadIntDivConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:aff17ce80f88bebcf893741c5e86b7275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6444401c2185cb6968a3a526951d23" id="r_a5a6444401c2185cb6968a3a526951d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6444401c2185cb6968a3a526951d23">LoadIntModConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a5a6444401c2185cb6968a3a526951d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23861bab6341cfcfeeff90c2b3e3ab7e" id="r_a23861bab6341cfcfeeff90c2b3e3ab7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23861bab6341cfcfeeff90c2b3e3ab7e">LoadLinMaxConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a23861bab6341cfcfeeff90c2b3e3ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932e7e363476a4eacd4422cd2d7f055f" id="r_a932e7e363476a4eacd4422cd2d7f055f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a932e7e363476a4eacd4422cd2d7f055f">LoadNoOverlapConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a932e7e363476a4eacd4422cd2d7f055f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3625f2ac6b65996775a6f9f41035711" id="r_aa3625f2ac6b65996775a6f9f41035711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3625f2ac6b65996775a6f9f41035711">LoadNoOverlap2dConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:aa3625f2ac6b65996775a6f9f41035711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f6cec7e46c76f4cd934fe0207a53eb" id="r_a10f6cec7e46c76f4cd934fe0207a53eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10f6cec7e46c76f4cd934fe0207a53eb">LoadCumulativeConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a10f6cec7e46c76f4cd934fe0207a53eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903ac568c6e118231b7e22a7d1ee7974" id="r_a903ac568c6e118231b7e22a7d1ee7974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a903ac568c6e118231b7e22a7d1ee7974">LoadReservoirConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a903ac568c6e118231b7e22a7d1ee7974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89da239e75747c3187c2c4bfa2bacf85" id="r_a89da239e75747c3187c2c4bfa2bacf85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89da239e75747c3187c2c4bfa2bacf85">LoadCircuitConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a89da239e75747c3187c2c4bfa2bacf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a2aae922f1cb8ec020517dfd5a103c" id="r_a71a2aae922f1cb8ec020517dfd5a103c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71a2aae922f1cb8ec020517dfd5a103c">LoadRoutesConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a71a2aae922f1cb8ec020517dfd5a103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5df13048ddce1b84667d805c764dd8" id="r_ace5df13048ddce1b84667d805c764dd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace5df13048ddce1b84667d805c764dd8">LoadConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:ace5df13048ddce1b84667d805c764dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1f1cd3466f640c86fd2df798db0198" id="r_a8c1f1cd3466f640c86fd2df798db0198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c1f1cd3466f640c86fd2df798db0198">LoadIntMinConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a8c1f1cd3466f640c86fd2df798db0198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7fee6509920049d61a48cbd0edf30a" id="r_aca7fee6509920049d61a48cbd0edf30a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca7fee6509920049d61a48cbd0edf30a">LoadIntMaxConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:aca7fee6509920049d61a48cbd0edf30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1b3ad033e2499a4d815f4e98eba795" id="r_a0a1b3ad033e2499a4d815f4e98eba795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a1b3ad033e2499a4d815f4e98eba795">LoadCircuitCoveringConstraint</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a0a1b3ad033e2499a4d815f4e98eba795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67697c2e8ba7d65eff35db17d7b94a9" id="r_ab67697c2e8ba7d65eff35db17d7b94a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67697c2e8ba7d65eff35db17d7b94a9">PostsolveClause</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="separator:ab67697c2e8ba7d65eff35db17d7b94a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62feb42f880fdeb019acf6a06cff70c1" id="r_a62feb42f880fdeb019acf6a06cff70c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62feb42f880fdeb019acf6a06cff70c1">PostsolveExactlyOne</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="separator:a62feb42f880fdeb019acf6a06cff70c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e2ec8896aa53a5c58f86dfd68e6f19" id="r_a73e2ec8896aa53a5c58f86dfd68e6f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73e2ec8896aa53a5c58f86dfd68e6f19">SetEnforcementLiteralToFalse</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="separator:a73e2ec8896aa53a5c58f86dfd68e6f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951d3606d9c0c92204c310b911bf0e7" id="r_a1951d3606d9c0c92204c310b911bf0e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1951d3606d9c0c92204c310b911bf0e7">PostsolveLinear</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="separator:a1951d3606d9c0c92204c310b911bf0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b855c27a037ed3eec043f0f0f25e2e" id="r_a86b855c27a037ed3eec043f0f0f25e2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86b855c27a037ed3eec043f0f0f25e2e">PostsolveLinMax</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="separator:a86b855c27a037ed3eec043f0f0f25e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1743e4469ce5d2535719981c49544a5d" id="r_a1743e4469ce5d2535719981c49544a5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1743e4469ce5d2535719981c49544a5d">PostsolveElement</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="separator:a1743e4469ce5d2535719981c49544a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf05e16c4d9a267526d3edaec410dd32" id="r_aaf05e16c4d9a267526d3edaec410dd32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf05e16c4d9a267526d3edaec410dd32">PostsolveIntMod</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="memdesc:aaf05e16c4d9a267526d3edaec410dd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">We only support assigning to an affine target.  <br /></td></tr>
<tr class="separator:aaf05e16c4d9a267526d3edaec410dd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74933f0fe5e619ae684cba634094a7a8" id="r_a74933f0fe5e619ae684cba634094a7a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74933f0fe5e619ae684cba634094a7a8">PostsolveIntProd</a> (const ConstraintProto &amp;ct, std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *domains)</td></tr>
<tr class="memdesc:a74933f0fe5e619ae684cba634094a7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">We only support assigning to an affine target.  <br /></td></tr>
<tr class="separator:a74933f0fe5e619ae684cba634094a7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba206d3b30a8812e9fae0e74c7277ad9" id="r_aba206d3b30a8812e9fae0e74c7277ad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba206d3b30a8812e9fae0e74c7277ad9">PostsolveResponse</a> (const int64_t num_variables_in_original_model, const CpModelProto &amp;mapping_proto, absl::Span&lt; const int &gt; postsolve_mapping, std::vector&lt; int64_t &gt; *<a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>)</td></tr>
<tr class="separator:aba206d3b30a8812e9fae0e74c7277ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee030f8f392170e436c92454e2a7fbc5" id="r_aee030f8f392170e436c92454e2a7fbc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee030f8f392170e436c92454e2a7fbc5">FillTightenedDomainInResponse</a> (const CpModelProto &amp;original_model, const CpModelProto &amp;mapping_proto, absl::Span&lt; const int &gt; postsolve_mapping, absl::Span&lt; const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; search_domains, CpSolverResponse *response, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:aee030f8f392170e436c92454e2a7fbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385fff0913c87d0912b88d59d7dcfc7a" id="r_a385fff0913c87d0912b88d59d7dcfc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a385fff0913c87d0912b88d59d7dcfc7a">EvaluateImpliedIntProdDomain</a> (const LinearArgumentProto &amp;expr, const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;context)</td></tr>
<tr class="separator:a385fff0913c87d0912b88d59d7dcfc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae90163b3b1ba74569501c3a9d3e6d6" id="r_a5ae90163b3b1ba74569501c3a9d3e6d6"><td class="memItemLeft" align="right" valign="top">CpSolverStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae90163b3b1ba74569501c3a9d3e6d6">PresolveCpModel</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context, std::vector&lt; int &gt; *postsolve_mapping)</td></tr>
<tr class="memdesc:a5ae90163b3b1ba74569501c3a9d3e6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper to call the full presolve.  <br /></td></tr>
<tr class="separator:a5ae90163b3b1ba74569501c3a9d3e6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2440a5de857e7ceae843c21bc723167c" id="r_a2440a5de857e7ceae843c21bc723167c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2440a5de857e7ceae843c21bc723167c">ApplyVariableMapping</a> (absl::Span&lt; int &gt; mapping, std::vector&lt; int &gt; *reverse_mapping, CpModelProto *proto)</td></tr>
<tr class="separator:a2440a5de857e7ceae843c21bc723167c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4999dc16f55afa8c5d30a733a26e3d" id="r_a2e4999dc16f55afa8c5d30a733a26e3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e4999dc16f55afa8c5d30a733a26e3d">FindDuplicateConstraints</a> (const CpModelProto &amp;model_proto, bool ignore_enforcement)</td></tr>
<tr class="separator:a2e4999dc16f55afa8c5d30a733a26e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab621abdbab919d365ca747aebdd2ff74" id="r_ab621abdbab919d365ca747aebdd2ff74"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab621abdbab919d365ca747aebdd2ff74">ConstructUserSearchStrategy</a> (const CpModelProto &amp;cp_model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:ab621abdbab919d365ca747aebdd2ff74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the search strategy specified in the given CpModelProto.  <br /></td></tr>
<tr class="separator:ab621abdbab919d365ca747aebdd2ff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807f0da8a99a471e809213176132588f" id="r_a807f0da8a99a471e809213176132588f"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a807f0da8a99a471e809213176132588f">ConstructHeuristicSearchStrategy</a> (const CpModelProto &amp;cp_model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a807f0da8a99a471e809213176132588f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search strategy tailored for the current model.  <br /></td></tr>
<tr class="separator:a807f0da8a99a471e809213176132588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aa243acb668c453deb8600ab80b38a" id="r_a40aa243acb668c453deb8600ab80b38a"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40aa243acb668c453deb8600ab80b38a">ConstructIntegerCompletionSearchStrategy</a> (absl::Span&lt; const IntegerVariable &gt; variable_mapping, IntegerVariable objective_var, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a40aa243acb668c453deb8600ab80b38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an integer completion search strategy.  <br /></td></tr>
<tr class="separator:a40aa243acb668c453deb8600ab80b38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5465fbc93435e155dd99a36283155a5c" id="r_a5465fbc93435e155dd99a36283155a5c"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5465fbc93435e155dd99a36283155a5c">ConstructHintSearchStrategy</a> (const CpModelProto &amp;cp_model_proto, <a class="el" href="classoperations__research_1_1sat_1_1CpModelMapping.html">CpModelMapping</a> *mapping, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a5465fbc93435e155dd99a36283155a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search strategy that follow the hint from the model.  <br /></td></tr>
<tr class="separator:a5465fbc93435e155dd99a36283155a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50803a36792e1ce5b1dfada9166766a7" id="r_a50803a36792e1ce5b1dfada9166766a7"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50803a36792e1ce5b1dfada9166766a7">ConstructFixedSearchStrategy</a> (std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; user_search, std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; heuristic_search, std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; integer_completion)</td></tr>
<tr class="separator:a50803a36792e1ce5b1dfada9166766a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0255a3e8ee357c78aba5982ed7045d0" id="r_af0255a3e8ee357c78aba5982ed7045d0"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0255a3e8ee357c78aba5982ed7045d0">InstrumentSearchStrategy</a> (const CpModelProto &amp;cp_model_proto, absl::Span&lt; const IntegerVariable &gt; variable_mapping, std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; instrumented_strategy, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:af0255a3e8ee357c78aba5982ed7045d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f0522b87e92a3a69cd92fe98af4be7" id="r_ae2f0522b87e92a3a69cd92fe98af4be7"><td class="memItemLeft" align="right" valign="top">absl::flat_hash_map&lt; std::string, SatParameters &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2f0522b87e92a3a69cd92fe98af4be7">GetNamedParameters</a> (SatParameters base_params)</td></tr>
<tr class="separator:ae2f0522b87e92a3a69cd92fe98af4be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3beb2acf8977c52500de3ebe170d24" id="r_a2d3beb2acf8977c52500de3ebe170d24"><td class="memItemLeft" align="right" valign="top">std::vector&lt; SatParameters &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d3beb2acf8977c52500de3ebe170d24">GetFullWorkerParameters</a> (const SatParameters &amp;base_params, const CpModelProto &amp;cp_model, int num_already_present, <a class="el" href="classoperations__research_1_1sat_1_1SubsolverNameFilter.html">SubsolverNameFilter</a> *filter)</td></tr>
<tr class="separator:a2d3beb2acf8977c52500de3ebe170d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab3041ce22f8dfd13a0bab64f7fd6bb" id="r_a8ab3041ce22f8dfd13a0bab64f7fd6bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; SatParameters &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ab3041ce22f8dfd13a0bab64f7fd6bb">GetFirstSolutionBaseParams</a> (const SatParameters &amp;base_params)</td></tr>
<tr class="separator:a8ab3041ce22f8dfd13a0bab64f7fd6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a1dd9bf60ce8490922e3f1148524e8" id="r_ab3a1dd9bf60ce8490922e3f1148524e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; SatParameters &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3a1dd9bf60ce8490922e3f1148524e8">RepeatParameters</a> (absl::Span&lt; const SatParameters &gt; base_params, int num_params_to_generate)</td></tr>
<tr class="separator:ab3a1dd9bf60ce8490922e3f1148524e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864c163d77d4ede1b9111a426493a497" id="r_a864c163d77d4ede1b9111a426493a497"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a864c163d77d4ede1b9111a426493a497">CpSatSolverVersion</a> ()</td></tr>
<tr class="memdesc:a864c163d77d4ede1b9111a426493a497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that describes the version of the solver.  <br /></td></tr>
<tr class="separator:a864c163d77d4ede1b9111a426493a497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287579e5f181fc7c89feccf1128faffb" id="r_a287579e5f181fc7c89feccf1128faffb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a287579e5f181fc7c89feccf1128faffb">CpModelStats</a> (const CpModelProto &amp;model)</td></tr>
<tr class="memdesc:a287579e5f181fc7c89feccf1128faffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with some statistics on the given CpModelProto.  <br /></td></tr>
<tr class="separator:a287579e5f181fc7c89feccf1128faffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af443c47f14a044d69553b02337b5dc52" id="r_af443c47f14a044d69553b02337b5dc52"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af443c47f14a044d69553b02337b5dc52">CpSolverResponseStats</a> (const CpSolverResponse &amp;response, bool has_objective)</td></tr>
<tr class="separator:af443c47f14a044d69553b02337b5dc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13630b39d297fb31cc3c151ff02dcc0" id="r_ad13630b39d297fb31cc3c151ff02dcc0"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad13630b39d297fb31cc3c151ff02dcc0">NewFeasibleSolutionObserver</a> (const std::function&lt; void(const CpSolverResponse &amp;response)&gt; &amp;callback)</td></tr>
<tr class="separator:ad13630b39d297fb31cc3c151ff02dcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e12611a48297771228ed1bb6971fe1" id="r_aa7e12611a48297771228ed1bb6971fe1"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7e12611a48297771228ed1bb6971fe1">NewFeasibleSolutionLogCallback</a> (const std::function&lt; std::string(const CpSolverResponse &amp;response)&gt; &amp;callback)</td></tr>
<tr class="separator:aa7e12611a48297771228ed1bb6971fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8bc70ae581d62f20820eebbb17407e" id="r_a9e8bc70ae581d62f20820eebbb17407e"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e8bc70ae581d62f20820eebbb17407e">NewBestBoundCallback</a> (const std::function&lt; void(double)&gt; &amp;callback)</td></tr>
<tr class="separator:a9e8bc70ae581d62f20820eebbb17407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10700832ca6bc420f2931eb707957b0b" id="r_a10700832ca6bc420f2931eb707957b0b"><td class="memItemLeft" align="right" valign="top">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10700832ca6bc420f2931eb707957b0b">NewSatParameters</a> (const std::string &amp;params)</td></tr>
<tr class="separator:a10700832ca6bc420f2931eb707957b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd54ab16ebc1bd6fa80d1e23ab79adc" id="r_a4bd54ab16ebc1bd6fa80d1e23ab79adc"><td class="memItemLeft" align="right" valign="top">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd54ab16ebc1bd6fa80d1e23ab79adc">NewSatParameters</a> (const sat::SatParameters &amp;parameters)</td></tr>
<tr class="separator:a4bd54ab16ebc1bd6fa80d1e23ab79adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d67b9c66f1cb9c1dcc3415cd5af11bf" id="r_a9d67b9c66f1cb9c1dcc3415cd5af11bf"><td class="memItemLeft" align="right" valign="top">CpSolverResponse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d67b9c66f1cb9c1dcc3415cd5af11bf">SolveCpModel</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a9d67b9c66f1cb9c1dcc3415cd5af11bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d851f944ab4f305c3d9f8df99b7bf8" id="r_a09d851f944ab4f305c3d9f8df99b7bf8"><td class="memItemLeft" align="right" valign="top">CpSolverResponse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d851f944ab4f305c3d9f8df99b7bf8">Solve</a> (const CpModelProto &amp;model_proto)</td></tr>
<tr class="memdesc:a09d851f944ab4f305c3d9f8df99b7bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the given CpModelProto and returns an instance of CpSolverResponse.  <br /></td></tr>
<tr class="separator:a09d851f944ab4f305c3d9f8df99b7bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3062797aa0396abf37dbcc99a746f12" id="r_aa3062797aa0396abf37dbcc99a746f12"><td class="memItemLeft" align="right" valign="top">CpSolverResponse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3062797aa0396abf37dbcc99a746f12">SolveWithParameters</a> (const CpModelProto &amp;model_proto, const SatParameters &amp;params)</td></tr>
<tr class="memdesc:aa3062797aa0396abf37dbcc99a746f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the given CpModelProto with the given parameters.  <br /></td></tr>
<tr class="separator:aa3062797aa0396abf37dbcc99a746f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c27ecb43d6486c1a70e022b4aad39" id="r_af52c27ecb43d6486c1a70e022b4aad39"><td class="memItemLeft" align="right" valign="top">CpSolverResponse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af52c27ecb43d6486c1a70e022b4aad39">SolveWithParameters</a> (const CpModelProto &amp;model_proto, const std::string &amp;params)</td></tr>
<tr class="separator:af52c27ecb43d6486c1a70e022b4aad39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ebf478f1fa693dd01867071080203" id="r_a277ebf478f1fa693dd01867071080203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277ebf478f1fa693dd01867071080203">LoadAndSolveCpModelForTest</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a277ebf478f1fa693dd01867071080203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf4fa68898b3aaa2e6de2b5d3064580" id="r_adbf4fa68898b3aaa2e6de2b5d3064580"><td class="memItemLeft" align="right" valign="top">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf4fa68898b3aaa2e6de2b5d3064580">NewSatParameters</a> (const SatParameters &amp;parameters)</td></tr>
<tr class="separator:adbf4fa68898b3aaa2e6de2b5d3064580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7deb7ec52ad9f39b76e7c44200af8c" id="r_aba7deb7ec52ad9f39b76e7c44200af8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba7deb7ec52ad9f39b76e7c44200af8c">LoadDebugSolution</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:aba7deb7ec52ad9f39b76e7c44200af8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5631139e1ab47ec3f8f2273fa476d62e" id="r_a5631139e1ab47ec3f8f2273fa476d62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5631139e1ab47ec3f8f2273fa476d62e">InitializeDebugSolution</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a5631139e1ab47ec3f8f2273fa476d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9697a77db1ba2b0a9055c7a71fe666" id="r_a0c9697a77db1ba2b0a9055c7a71fe666"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9697a77db1ba2b0a9055c7a71fe666">GetSolutionValues</a> (const CpModelProto &amp;model_proto, const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;model)</td></tr>
<tr class="separator:a0c9697a77db1ba2b0a9055c7a71fe666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceadbdc1d18fb949cc787a53e656d65a" id="r_aceadbdc1d18fb949cc787a53e656d65a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceadbdc1d18fb949cc787a53e656d65a">RegisterVariableBoundsLevelZeroExport</a> (const CpModelProto &amp;, <a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html">SharedBoundsManager</a> *shared_bounds_manager, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:aceadbdc1d18fb949cc787a53e656d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad591ae16ce115e2dbd3b2501845377c2" id="r_ad591ae16ce115e2dbd3b2501845377c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad591ae16ce115e2dbd3b2501845377c2">RegisterVariableBoundsLevelZeroImport</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html">SharedBoundsManager</a> *shared_bounds_manager, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ad591ae16ce115e2dbd3b2501845377c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41d718cabb8c89ffce625c35e884080" id="r_ae41d718cabb8c89ffce625c35e884080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae41d718cabb8c89ffce625c35e884080">RegisterObjectiveBestBoundExport</a> (IntegerVariable objective_var, <a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *shared_response_manager, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ae41d718cabb8c89ffce625c35e884080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f656cdcbe318b6a953aff7907fe3d32" id="r_a4f656cdcbe318b6a953aff7907fe3d32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f656cdcbe318b6a953aff7907fe3d32">RegisterObjectiveBoundsImport</a> (<a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *shared_response_manager, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a4f656cdcbe318b6a953aff7907fe3d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63074e2e2521d97be10a61595f59d165" id="r_a63074e2e2521d97be10a61595f59d165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63074e2e2521d97be10a61595f59d165">RegisterClausesExport</a> (int id, <a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html">SharedClausesManager</a> *shared_clauses_manager, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a63074e2e2521d97be10a61595f59d165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback that will export good clauses discovered during search.  <br /></td></tr>
<tr class="separator:a63074e2e2521d97be10a61595f59d165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9354f9bc95baa7e65765e065b38fefc" id="r_ae9354f9bc95baa7e65765e065b38fefc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9354f9bc95baa7e65765e065b38fefc">RegisterClausesLevelZeroImport</a> (int id, <a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html">SharedClausesManager</a> *shared_clauses_manager, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ae9354f9bc95baa7e65765e065b38fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efa4af8efff3dc82feb1add05075c63" id="r_a1efa4af8efff3dc82feb1add05075c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1efa4af8efff3dc82feb1add05075c63">LoadBaseModel</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a1efa4af8efff3dc82feb1add05075c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8470e9ca1358898a2c52fc76bcd9c45d" id="r_a8470e9ca1358898a2c52fc76bcd9c45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8470e9ca1358898a2c52fc76bcd9c45d">LoadFeasibilityPump</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a8470e9ca1358898a2c52fc76bcd9c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81c56ee655b074e6d565cd223a70024" id="r_ad81c56ee655b074e6d565cd223a70024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad81c56ee655b074e6d565cd223a70024">LoadCpModel</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ad81c56ee655b074e6d565cd223a70024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11198d99e855837fa730eb6a5097a801" id="r_a11198d99e855837fa730eb6a5097a801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11198d99e855837fa730eb6a5097a801">SolveLoadedCpModel</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a11198d99e855837fa730eb6a5097a801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37f2f037c1a414988b378b00ae80dcf" id="r_ab37f2f037c1a414988b378b00ae80dcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37f2f037c1a414988b378b00ae80dcf">QuickSolveWithHint</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ab37f2f037c1a414988b378b00ae80dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633a2eb5447b0e49f8958cb4bb4b7a44" id="r_a633a2eb5447b0e49f8958cb4bb4b7a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a633a2eb5447b0e49f8958cb4bb4b7a44">MinimizeL1DistanceWithHint</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a633a2eb5447b0e49f8958cb4bb4b7a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c02c475828b411a8dbd4b3c399eb251" id="r_a5c02c475828b411a8dbd4b3c399eb251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c02c475828b411a8dbd4b3c399eb251">PostsolveResponseWithFullSolver</a> (int num_variables_in_original_model, CpModelProto mapping_proto, absl::Span&lt; const int &gt; postsolve_mapping, std::vector&lt; int64_t &gt; *<a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>)</td></tr>
<tr class="separator:a5c02c475828b411a8dbd4b3c399eb251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bd81a63601be208cff5d7d34f6a5db" id="r_ad2bd81a63601be208cff5d7d34f6a5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2bd81a63601be208cff5d7d34f6a5db">PostsolveResponseWrapper</a> (const SatParameters &amp;params, int num_variable_in_original_model, const CpModelProto &amp;mapping_proto, absl::Span&lt; const int &gt; postsolve_mapping, std::vector&lt; int64_t &gt; *<a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>)</td></tr>
<tr class="separator:ad2bd81a63601be208cff5d7d34f6a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de52a1eb284f2cf6e20a2a0e713f092" id="r_a9de52a1eb284f2cf6e20a2a0e713f092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de52a1eb284f2cf6e20a2a0e713f092">AdaptGlobalParameters</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a9de52a1eb284f2cf6e20a2a0e713f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16bafcf3c5377ed905021a96f93bdcf" id="r_ae16bafcf3c5377ed905021a96f93bdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae16bafcf3c5377ed905021a96f93bdcf">FindCpModelSymmetries</a> (const SatParameters &amp;params, const CpModelProto &amp;problem, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *generators, double deterministic_limit, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:ae16bafcf3c5377ed905021a96f93bdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71dfa5c438ceb1f2474eea8ceb3c4ad" id="r_aa71dfa5c438ceb1f2474eea8ceb3c4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa71dfa5c438ceb1f2474eea8ceb3c4ad">DetectAndAddSymmetryToProto</a> (const SatParameters &amp;params, CpModelProto *proto, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="memdesc:aa71dfa5c438ceb1f2474eea8ceb3c4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects symmetries and fill the symmetry field.  <br /></td></tr>
<tr class="separator:aa71dfa5c438ceb1f2474eea8ceb3c4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3423c28a2a00161e74d9c6e0174bcbf6" id="r_a3423c28a2a00161e74d9c6e0174bcbf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3423c28a2a00161e74d9c6e0174bcbf6">DetectAndExploitSymmetriesInPresolve</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a3423c28a2a00161e74d9c6e0174bcbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7287180e6e143d0a2c6f6e6c206cc656" id="r_a7287180e6e143d0a2c6f6e6c206cc656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7287180e6e143d0a2c6f6e6c206cc656">FilterOrbitOnUnusedOrFixedVariables</a> (SymmetryProto *symmetry, <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a7287180e6e143d0a2c6f6e6c206cc656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf265c6d5bebf939210d9b8ce6943fd" id="r_afaf265c6d5bebf939210d9b8ce6943fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaf265c6d5bebf939210d9b8ce6943fd">CanonicalizeTable</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context, ConstraintProto *ct)</td></tr>
<tr class="separator:afaf265c6d5bebf939210d9b8ce6943fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a88950631a19f96084df07209e43d30" id="r_a1a88950631a19f96084df07209e43d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a88950631a19f96084df07209e43d30">CompressTuples</a> (absl::Span&lt; const int64_t &gt; domain_sizes, std::vector&lt; std::vector&lt; int64_t &gt; &gt; *tuples)</td></tr>
<tr class="separator:a1a88950631a19f96084df07209e43d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bf1351ffa74960b3040a96ddc37468" id="r_a36bf1351ffa74960b3040a96ddc37468"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; absl::InlinedVector&lt; int64_t, 2 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36bf1351ffa74960b3040a96ddc37468">FullyCompressTuples</a> (absl::Span&lt; const int64_t &gt; domain_sizes, std::vector&lt; std::vector&lt; int64_t &gt; &gt; *tuples)</td></tr>
<tr class="separator:a36bf1351ffa74960b3040a96ddc37468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8873d5bb4db4affe6faa2da6553882a" id="r_ad8873d5bb4db4affe6faa2da6553882a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8873d5bb4db4affe6faa2da6553882a">PropagateAutomaton</a> (const AutomatonConstraintProto &amp;proto, const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;context, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *states, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *labels)</td></tr>
<tr class="memdesc:ad8873d5bb4db4affe6faa2da6553882a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills and propagates the set of reachable states/labels.  <br /></td></tr>
<tr class="separator:ad8873d5bb4db4affe6faa2da6553882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568e140395471f0f24820941dd72edaf" id="r_a568e140395471f0f24820941dd72edaf"><td class="memItemLeft" align="right" valign="top">CpModelProto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a568e140395471f0f24820941dd72edaf">Random3SatProblem</a> (int num_variables, double proportion_of_constraints)</td></tr>
<tr class="separator:a568e140395471f0f24820941dd72edaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cdb025832191e49e0643dc6ed4a6ed" id="r_a93cdb025832191e49e0643dc6ed4a6ed"><td class="memItemLeft" align="right" valign="top">CpModelProto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93cdb025832191e49e0643dc6ed4a6ed">RandomLinearProblem</a> (int num_variables, int num_constraints)</td></tr>
<tr class="separator:a93cdb025832191e49e0643dc6ed4a6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7d45e5b1ef013bac04bd33de575589" id="r_abe7d45e5b1ef013bac04bd33de575589"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe7d45e5b1ef013bac04bd33de575589">LinearExpressionGcd</a> (const LinearExpressionProto &amp;expr, int64_t gcd)</td></tr>
<tr class="separator:abe7d45e5b1ef013bac04bd33de575589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace619cca537761022dff4ee830354f19" id="r_ace619cca537761022dff4ee830354f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace619cca537761022dff4ee830354f19">DivideLinearExpression</a> (int64_t divisor, LinearExpressionProto *expr)</td></tr>
<tr class="separator:ace619cca537761022dff4ee830354f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df75a9e906f53495a7f7f56c782361" id="r_a02df75a9e906f53495a7f7f56c782361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02df75a9e906f53495a7f7f56c782361">SetToNegatedLinearExpression</a> (const LinearExpressionProto &amp;input_expr, LinearExpressionProto *output_negated_expr)</td></tr>
<tr class="memdesc:a02df75a9e906f53495a7f7f56c782361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the target as negated ref.  <br /></td></tr>
<tr class="separator:a02df75a9e906f53495a7f7f56c782361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafd68a229d8e8b0893f2f0720e08332" id="r_aeafd68a229d8e8b0893f2f0720e08332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IndexReferences.html">IndexReferences</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeafd68a229d8e8b0893f2f0720e08332">GetReferencesUsedByConstraint</a> (const ConstraintProto &amp;ct)</td></tr>
<tr class="separator:aeafd68a229d8e8b0893f2f0720e08332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5582ef17b5b0f85e9a1b382b6acfa1bc" id="r_a5582ef17b5b0f85e9a1b382b6acfa1bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5582ef17b5b0f85e9a1b382b6acfa1bc">GetReferencesUsedByConstraint</a> (const ConstraintProto &amp;ct, std::vector&lt; int &gt; *variables, std::vector&lt; int &gt; *literals)</td></tr>
<tr class="separator:a5582ef17b5b0f85e9a1b382b6acfa1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac103fdbdb9184cf86d2cfadf95b0dd67" id="r_ac103fdbdb9184cf86d2cfadf95b0dd67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac103fdbdb9184cf86d2cfadf95b0dd67">ApplyToAllLiteralIndices</a> (const std::function&lt; void(int *)&gt; &amp;f, ConstraintProto *ct)</td></tr>
<tr class="separator:ac103fdbdb9184cf86d2cfadf95b0dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af703c0ffe9861cc773696e46ccff0a5f" id="r_af703c0ffe9861cc773696e46ccff0a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af703c0ffe9861cc773696e46ccff0a5f">ApplyToAllVariableIndices</a> (const std::function&lt; void(int *)&gt; &amp;f, ConstraintProto *ct)</td></tr>
<tr class="separator:af703c0ffe9861cc773696e46ccff0a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4659306bddf893dc09c5cd493f9a1fd4" id="r_a4659306bddf893dc09c5cd493f9a1fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4659306bddf893dc09c5cd493f9a1fd4">ApplyToAllIntervalIndices</a> (const std::function&lt; void(int *)&gt; &amp;f, ConstraintProto *ct)</td></tr>
<tr class="separator:a4659306bddf893dc09c5cd493f9a1fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77c8edd75ecda9e91f2a9a02af6adca" id="r_ab77c8edd75ecda9e91f2a9a02af6adca"><td class="memItemLeft" align="right" valign="top">absl::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab77c8edd75ecda9e91f2a9a02af6adca">ConstraintCaseName</a> (ConstraintProto::ConstraintCase constraint_case)</td></tr>
<tr class="separator:ab77c8edd75ecda9e91f2a9a02af6adca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82863d7b3a08b5b2267b69b737034076" id="r_a82863d7b3a08b5b2267b69b737034076"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82863d7b3a08b5b2267b69b737034076">UsedVariables</a> (const ConstraintProto &amp;ct)</td></tr>
<tr class="separator:a82863d7b3a08b5b2267b69b737034076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869d0ba93c0a19641fc4d0cdaf5b7233" id="r_a869d0ba93c0a19641fc4d0cdaf5b7233"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a869d0ba93c0a19641fc4d0cdaf5b7233">UsedIntervals</a> (const ConstraintProto &amp;ct)</td></tr>
<tr class="memdesc:a869d0ba93c0a19641fc4d0cdaf5b7233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sorted list of interval used by a constraint.  <br /></td></tr>
<tr class="separator:a869d0ba93c0a19641fc4d0cdaf5b7233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2979162c101d957e47f1ad97155a023e" id="r_a2979162c101d957e47f1ad97155a023e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2979162c101d957e47f1ad97155a023e">ComputeInnerObjective</a> (const CpObjectiveProto &amp;objective, absl::Span&lt; const int64_t &gt; <a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>)</td></tr>
<tr class="separator:a2979162c101d957e47f1ad97155a023e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc34dbcdae318ae9788e4448a65acecc" id="r_abc34dbcdae318ae9788e4448a65acecc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc34dbcdae318ae9788e4448a65acecc">ExpressionContainsSingleRef</a> (const LinearExpressionProto &amp;expr)</td></tr>
<tr class="memdesc:abc34dbcdae318ae9788e4448a65acecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a linear expression can be reduced to a single ref.  <br /></td></tr>
<tr class="separator:abc34dbcdae318ae9788e4448a65acecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf12df936171c3abd17cf962264dcb" id="r_a75cf12df936171c3abd17cf962264dcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75cf12df936171c3abd17cf962264dcb">ExpressionIsAffine</a> (const LinearExpressionProto &amp;expr)</td></tr>
<tr class="memdesc:a75cf12df936171c3abd17cf962264dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the expression is affine or constant.  <br /></td></tr>
<tr class="separator:a75cf12df936171c3abd17cf962264dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c22b7b182ddb7070f175bb325162c" id="r_ad06c22b7b182ddb7070f175bb325162c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad06c22b7b182ddb7070f175bb325162c">GetSingleRefFromExpression</a> (const LinearExpressionProto &amp;expr)</td></tr>
<tr class="separator:ad06c22b7b182ddb7070f175bb325162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0555e63b6d9d9bd5f3d04b7657bffbf" id="r_ad0555e63b6d9d9bd5f3d04b7657bffbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0555e63b6d9d9bd5f3d04b7657bffbf">AddLinearExpressionToLinearConstraint</a> (const LinearExpressionProto &amp;expr, int64_t coefficient, LinearConstraintProto *linear)</td></tr>
<tr class="separator:ad0555e63b6d9d9bd5f3d04b7657bffbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93bc80e68e10802d7a3db30f74c83a9" id="r_af93bc80e68e10802d7a3db30f74c83a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af93bc80e68e10802d7a3db30f74c83a9">AddWeightedLiteralToLinearConstraint</a> (int lit, int64_t coeff, LinearConstraintProto *linear, int64_t *offset)</td></tr>
<tr class="separator:af93bc80e68e10802d7a3db30f74c83a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a3e74f9172260076d4dfae8a4f4af" id="r_a491a3e74f9172260076d4dfae8a4f4af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491a3e74f9172260076d4dfae8a4f4af">SafeAddLinearExpressionToLinearConstraint</a> (const LinearExpressionProto &amp;expr, int64_t coefficient, LinearConstraintProto *linear)</td></tr>
<tr class="memdesc:a491a3e74f9172260076d4dfae8a4f4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same method, but returns if the addition was possible without overflowing.  <br /></td></tr>
<tr class="separator:a491a3e74f9172260076d4dfae8a4f4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae704c82581dd897d1fe09e8a3435077a" id="r_ae704c82581dd897d1fe09e8a3435077a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae704c82581dd897d1fe09e8a3435077a">LinearExpressionProtosAreEqual</a> (const LinearExpressionProto &amp;a, const LinearExpressionProto &amp;<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t b_scaling=1)</td></tr>
<tr class="memdesc:ae704c82581dd897d1fe09e8a3435077a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff a == b * b_scaling.  <br /></td></tr>
<tr class="separator:ae704c82581dd897d1fe09e8a3435077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f1774c343aaebb5a3d9686e12e7f7e" id="r_a70f1774c343aaebb5a3d9686e12e7f7e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70f1774c343aaebb5a3d9686e12e7f7e">FingerprintExpression</a> (const LinearExpressionProto &amp;lin, uint64_t seed)</td></tr>
<tr class="memdesc:a70f1774c343aaebb5a3d9686e12e7f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stable fingerprint of a linear expression.  <br /></td></tr>
<tr class="separator:a70f1774c343aaebb5a3d9686e12e7f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7492392221bdfcc832cce2d93c9b681c" id="r_a7492392221bdfcc832cce2d93c9b681c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7492392221bdfcc832cce2d93c9b681c">FingerprintModel</a> (const CpModelProto &amp;model, uint64_t seed=<a class="el" href="#a12e7f8bfb4546fdd870155aea927cbd2">kDefaultFingerprintSeed</a>)</td></tr>
<tr class="memdesc:a7492392221bdfcc832cce2d93c9b681c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stable fingerprint of a model.  <br /></td></tr>
<tr class="separator:a7492392221bdfcc832cce2d93c9b681c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fb16cf2994009c7ab17facafbb2760" id="r_ab4fb16cf2994009c7ab17facafbb2760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4fb16cf2994009c7ab17facafbb2760">SetupTextFormatPrinter</a> (google::protobuf::TextFormat::Printer *printer)</td></tr>
<tr class="separator:ab4fb16cf2994009c7ab17facafbb2760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da39a32345d2a2c18a62bb356bfd3b3" id="r_a6da39a32345d2a2c18a62bb356bfd3b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6da39a32345d2a2c18a62bb356bfd3b3">ConvertCpModelProtoToCnf</a> (const CpModelProto &amp;cp_model, std::string *out)</td></tr>
<tr class="separator:a6da39a32345d2a2c18a62bb356bfd3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448193df35c1e481b2ad18e0fb097d8a" id="r_a448193df35c1e481b2ad18e0fb097d8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448193df35c1e481b2ad18e0fb097d8a">CombineSeed</a> (int base_seed, int64_t delta)</td></tr>
<tr class="memdesc:a448193df35c1e481b2ad18e0fb097d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">We assume delta &gt;= 0 and we only use the low bit of delta.  <br /></td></tr>
<tr class="separator:a448193df35c1e481b2ad18e0fb097d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0803b8198728cd4f6e58498d9c60091" id="r_ae0803b8198728cd4f6e58498d9c60091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0803b8198728cd4f6e58498d9c60091">NegatedRef</a> (int ref)</td></tr>
<tr class="memdesc:ae0803b8198728cd4f6e58498d9c60091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small utility functions to deal with negative variable/literal references.  <br /></td></tr>
<tr class="separator:ae0803b8198728cd4f6e58498d9c60091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbc8ad33149d45a6e6fcd8b72fd68ed" id="r_acdbc8ad33149d45a6e6fcd8b72fd68ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdbc8ad33149d45a6e6fcd8b72fd68ed">PositiveRef</a> (int ref)</td></tr>
<tr class="separator:acdbc8ad33149d45a6e6fcd8b72fd68ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217338425de4389014563f1f24331713" id="r_a217338425de4389014563f1f24331713"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a217338425de4389014563f1f24331713">RefIsPositive</a> (int ref)</td></tr>
<tr class="separator:a217338425de4389014563f1f24331713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a3b266d8c6dfab1c14baa6c04e2333" id="r_a42a3b266d8c6dfab1c14baa6c04e2333"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42a3b266d8c6dfab1c14baa6c04e2333">HasEnforcementLiteral</a> (const ConstraintProto &amp;ct)</td></tr>
<tr class="memdesc:a42a3b266d8c6dfab1c14baa6c04e2333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small utility functions to deal with half-reified constraints.  <br /></td></tr>
<tr class="separator:a42a3b266d8c6dfab1c14baa6c04e2333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff14ec933b464328de54c33e81429a9" id="r_adff14ec933b464328de54c33e81429a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adff14ec933b464328de54c33e81429a9">EnforcementLiteral</a> (const ConstraintProto &amp;ct)</td></tr>
<tr class="separator:adff14ec933b464328de54c33e81429a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae242b79514feb483756fd8dedd385742" id="r_ae242b79514feb483756fd8dedd385742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae242b79514feb483756fd8dedd385742">InsertVariablesFromInterval</a> (const CpModelProto &amp;model_proto, int index, <a class="el" href="classoperations__research_1_1Bitset64.html">Bitset64</a>&lt; int &gt; &amp;output)</td></tr>
<tr class="memdesc:ae242b79514feb483756fd8dedd385742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert/Remove variables from an interval constraint into a bitset.  <br /></td></tr>
<tr class="separator:ae242b79514feb483756fd8dedd385742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1926dfe1e50b0db22cd629022d4be102" id="r_a1926dfe1e50b0db22cd629022d4be102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1926dfe1e50b0db22cd629022d4be102">RemoveVariablesFromInterval</a> (const CpModelProto &amp;model_proto, int index, <a class="el" href="classoperations__research_1_1Bitset64.html">Bitset64</a>&lt; int &gt; &amp;output)</td></tr>
<tr class="separator:a1926dfe1e50b0db22cd629022d4be102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46540a899ab5e8fe1b55e12da55cbbe0" id="r_a46540a899ab5e8fe1b55e12da55cbbe0"><td class="memTemplParams" colspan="2">template&lt;typename ProtoWithDomain&gt; </td></tr>
<tr class="memitem:a46540a899ab5e8fe1b55e12da55cbbe0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46540a899ab5e8fe1b55e12da55cbbe0">DomainInProtoContains</a> (const ProtoWithDomain &amp;proto, int64_t value)</td></tr>
<tr class="separator:a46540a899ab5e8fe1b55e12da55cbbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901c19b12842f8af153e588a689a90b5" id="r_a901c19b12842f8af153e588a689a90b5"><td class="memTemplParams" colspan="2">template&lt;typename ProtoWithDomain&gt; </td></tr>
<tr class="memitem:a901c19b12842f8af153e588a689a90b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a901c19b12842f8af153e588a689a90b5">FillDomainInProto</a> (const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain, ProtoWithDomain *proto)</td></tr>
<tr class="memdesc:a901c19b12842f8af153e588a689a90b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> into the domain field of a proto.  <br /></td></tr>
<tr class="separator:a901c19b12842f8af153e588a689a90b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1240060466ba48a36a4b36379bce26a" id="r_ab1240060466ba48a36a4b36379bce26a"><td class="memTemplParams" colspan="2">template&lt;typename ProtoWithDomain&gt; </td></tr>
<tr class="memitem:ab1240060466ba48a36a4b36379bce26a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1240060466ba48a36a4b36379bce26a">ReadDomainFromProto</a> (const ProtoWithDomain &amp;proto)</td></tr>
<tr class="memdesc:ab1240060466ba48a36a4b36379bce26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> from the domain field of a proto.  <br /></td></tr>
<tr class="separator:ab1240060466ba48a36a4b36379bce26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1129274beafb17b41ac2fa278de60c" id="r_afc1129274beafb17b41ac2fa278de60c"><td class="memTemplParams" colspan="2">template&lt;typename ProtoWithDomain&gt; </td></tr>
<tr class="memitem:afc1129274beafb17b41ac2fa278de60c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc1129274beafb17b41ac2fa278de60c">AllValuesInDomain</a> (const ProtoWithDomain &amp;proto)</td></tr>
<tr class="separator:afc1129274beafb17b41ac2fa278de60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7910e5ccb41edc8f442a682890cb31" id="r_a6c7910e5ccb41edc8f442a682890cb31"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c7910e5ccb41edc8f442a682890cb31">ScaleObjectiveValue</a> (const CpObjectiveProto &amp;proto, int64_t value)</td></tr>
<tr class="memdesc:a6c7910e5ccb41edc8f442a682890cb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales back a objective value to a double value from the original model.  <br /></td></tr>
<tr class="separator:a6c7910e5ccb41edc8f442a682890cb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d99a59590707fcc7bbd11e1ca5804f" id="r_ad0d99a59590707fcc7bbd11e1ca5804f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d99a59590707fcc7bbd11e1ca5804f">ScaleInnerObjectiveValue</a> (const CpObjectiveProto &amp;proto, int64_t value)</td></tr>
<tr class="memdesc:ad0d99a59590707fcc7bbd11e1ca5804f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="#a6c7910e5ccb41edc8f442a682890cb31" title="Scales back a objective value to a double value from the original model.">ScaleObjectiveValue()</a> but uses the integer version.  <br /></td></tr>
<tr class="separator:ad0d99a59590707fcc7bbd11e1ca5804f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff712b32e44ffd2e7f40042330bf2ad" id="r_a1ff712b32e44ffd2e7f40042330bf2ad"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff712b32e44ffd2e7f40042330bf2ad">UnscaleObjectiveValue</a> (const CpObjectiveProto &amp;proto, double value)</td></tr>
<tr class="memdesc:a1ff712b32e44ffd2e7f40042330bf2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the objective scaling and offset from the given value.  <br /></td></tr>
<tr class="separator:a1ff712b32e44ffd2e7f40042330bf2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4b741a4583b289c5116e9f3ca38477" id="r_aaa4b741a4583b289c5116e9f3ca38477"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4b741a4583b289c5116e9f3ca38477">AffineExpressionValueAt</a> (const LinearExpressionProto &amp;expr, int64_t value)</td></tr>
<tr class="memdesc:aaa4b741a4583b289c5116e9f3ca38477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates an affine expression at the given value.  <br /></td></tr>
<tr class="separator:aaa4b741a4583b289c5116e9f3ca38477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53df1021ad3dff678c212d37692b8677" id="r_a53df1021ad3dff678c212d37692b8677"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53df1021ad3dff678c212d37692b8677">GetInnerVarValue</a> (const LinearExpressionProto &amp;expr, int64_t value)</td></tr>
<tr class="separator:a53df1021ad3dff678c212d37692b8677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb36a73833ef551ae994e2343cfff440" id="r_afb36a73833ef551ae994e2343cfff440"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb36a73833ef551ae994e2343cfff440">AffineExpressionContainsVar</a> (const LinearExpressionProto &amp;expr, int var)</td></tr>
<tr class="memdesc:afb36a73833ef551ae994e2343cfff440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the expression is a * var + b.  <br /></td></tr>
<tr class="separator:afb36a73833ef551ae994e2343cfff440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1263f7cb0bf4a69c2981e643af985f5" id="r_ab1263f7cb0bf4a69c2981e643af985f5"><td class="memTemplParams" colspan="2">template&lt;class ExpressionList&gt; </td></tr>
<tr class="memitem:ab1263f7cb0bf4a69c2981e643af985f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1263f7cb0bf4a69c2981e643af985f5">ExpressionsContainsOnlyOneVar</a> (const ExpressionList &amp;exprs)</td></tr>
<tr class="memdesc:ab1263f7cb0bf4a69c2981e643af985f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exactly one variable appearing in all the expressions.  <br /></td></tr>
<tr class="separator:ab1263f7cb0bf4a69c2981e643af985f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1352f3fb2b6e1a4186a12473bb2b6d8e" id="r_a1352f3fb2b6e1a4186a12473bb2b6d8e"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a1352f3fb2b6e1a4186a12473bb2b6d8e"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1352f3fb2b6e1a4186a12473bb2b6d8e">FingerprintRepeatedField</a> (const google::protobuf::RepeatedField&lt; T &gt; &amp;sequence, uint64_t seed)</td></tr>
<tr class="separator:a1352f3fb2b6e1a4186a12473bb2b6d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6494711186bdd07baa40f2f99718de24" id="r_a6494711186bdd07baa40f2f99718de24"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a6494711186bdd07baa40f2f99718de24"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6494711186bdd07baa40f2f99718de24">FingerprintSingleField</a> (const T &amp;field, uint64_t seed)</td></tr>
<tr class="separator:a6494711186bdd07baa40f2f99718de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46450179bd4a1af484e23da5557aef2a" id="r_a46450179bd4a1af484e23da5557aef2a"><td class="memTemplParams" colspan="2">template&lt;class M&gt; </td></tr>
<tr class="memitem:a46450179bd4a1af484e23da5557aef2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46450179bd4a1af484e23da5557aef2a">WriteModelProtoToFile</a> (const M &amp;proto, absl::string_view filename)</td></tr>
<tr class="separator:a46450179bd4a1af484e23da5557aef2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b20ba2e68f06f165c023e5833e1d3b3" id="r_a2b20ba2e68f06f165c023e5833e1d3b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b20ba2e68f06f165c023e5833e1d3b3">operator==</a> (const BoolArgumentProto &amp;lhs, const BoolArgumentProto &amp;rhs)</td></tr>
<tr class="separator:a2b20ba2e68f06f165c023e5833e1d3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add639177aff4867e35bbc198c9bbff7e" id="r_add639177aff4867e35bbc198c9bbff7e"><td class="memTemplParams" colspan="2">template&lt;typename H&gt; </td></tr>
<tr class="memitem:add639177aff4867e35bbc198c9bbff7e"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add639177aff4867e35bbc198c9bbff7e">AbslHashValue</a> (H h, const BoolArgumentProto &amp;m)</td></tr>
<tr class="separator:add639177aff4867e35bbc198c9bbff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db1bfd158b39da039bdfc275e767ee9" id="r_a0db1bfd158b39da039bdfc275e767ee9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db1bfd158b39da039bdfc275e767ee9">operator==</a> (const LinearConstraintProto &amp;lhs, const LinearConstraintProto &amp;rhs)</td></tr>
<tr class="separator:a0db1bfd158b39da039bdfc275e767ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbce8f787bce863c63e07c6dd101be2" id="r_a5fbce8f787bce863c63e07c6dd101be2"><td class="memTemplParams" colspan="2">template&lt;typename H&gt; </td></tr>
<tr class="memitem:a5fbce8f787bce863c63e07c6dd101be2"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5fbce8f787bce863c63e07c6dd101be2">AbslHashValue</a> (H h, const LinearConstraintProto &amp;m)</td></tr>
<tr class="separator:a5fbce8f787bce863c63e07c6dd101be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9a3f85b1ced1ed86954a6d4d620fbd" id="r_ace9a3f85b1ced1ed86954a6d4d620fbd"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9a3f85b1ced1ed86954a6d4d620fbd">Cumulative</a> (const std::vector&lt; IntervalVariable &gt; &amp;vars, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; demands, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper)</td></tr>
<tr class="separator:ace9a3f85b1ced1ed86954a6d4d620fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd474f9fa4e5ea4cb65ec7d38c5018" id="r_adadd474f9fa4e5ea4cb65ec7d38c5018"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adadd474f9fa4e5ea4cb65ec7d38c5018">CumulativeTimeDecomposition</a> (absl::Span&lt; const IntervalVariable &gt; vars, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; demands, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper)</td></tr>
<tr class="separator:adadd474f9fa4e5ea4cb65ec7d38c5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cda77b951e195fa78d14b3afd30578" id="r_a19cda77b951e195fa78d14b3afd30578"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19cda77b951e195fa78d14b3afd30578">CumulativeUsingReservoir</a> (absl::Span&lt; const IntervalVariable &gt; vars, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; demands, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper=nullptr)</td></tr>
<tr class="memdesc:a19cda77b951e195fa78d14b3afd30578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another testing code, same assumptions as the <a class="el" href="#adadd474f9fa4e5ea4cb65ec7d38c5018">CumulativeTimeDecomposition()</a>.  <br /></td></tr>
<tr class="separator:a19cda77b951e195fa78d14b3afd30578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9833301c095ba1cd286e7be7ed2515e" id="r_ae9833301c095ba1cd286e7be7ed2515e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9833301c095ba1cd286e7be7ed2515e">AddCumulativeOverloadChecker</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ae9833301c095ba1cd286e7be7ed2515e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7364044e91bc377aa1c354e8fa892a" id="r_a6f7364044e91bc377aa1c354e8fa892a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f7364044e91bc377aa1c354e8fa892a">AddCumulativeOverloadCheckerDff</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a6f7364044e91bc377aa1c354e8fa892a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab085f4bfc568341a61b1a178fb718d" id="r_a1ab085f4bfc568341a61b1a178fb718d"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ab085f4bfc568341a61b1a178fb718d">GetFactorT</a> (IntegerValue rhs_remainder, IntegerValue divisor, IntegerValue max_magnitude)</td></tr>
<tr class="separator:a1ab085f4bfc568341a61b1a178fb718d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1020b89b12f653b1ea0dd0d595557e" id="r_afa1020b89b12f653b1ea0dd0d595557e"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerValue(IntegerValue)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa1020b89b12f653b1ea0dd0d595557e">GetSuperAdditiveRoundingFunction</a> (IntegerValue rhs_remainder, IntegerValue divisor, IntegerValue t, IntegerValue max_scaling)</td></tr>
<tr class="separator:afa1020b89b12f653b1ea0dd0d595557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7876cef7b031a084f24b5c5898c9710c" id="r_a7876cef7b031a084f24b5c5898c9710c"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerValue(IntegerValue)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7876cef7b031a084f24b5c5898c9710c">GetSuperAdditiveStrengtheningFunction</a> (IntegerValue positive_rhs, IntegerValue min_magnitude)</td></tr>
<tr class="separator:a7876cef7b031a084f24b5c5898c9710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadc8829018c149d88271978270bf822" id="r_adadc8829018c149d88271978270bf822"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerValue(IntegerValue)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adadc8829018c149d88271978270bf822">GetSuperAdditiveStrengtheningMirFunction</a> (IntegerValue positive_rhs, IntegerValue scaling)</td></tr>
<tr class="separator:adadc8829018c149d88271978270bf822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28abd2fe9199829f0c98ade48cfe459c" id="r_a28abd2fe9199829f0c98ade48cfe459c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28abd2fe9199829f0c98ade48cfe459c">CreatePositiveMultiplicationCutGenerator</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> z, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> x, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> y, int linearization_level, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a28abd2fe9199829f0c98ade48cfe459c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cut generator for z = x * y (x and y &gt;= 0).  <br /></td></tr>
<tr class="separator:a28abd2fe9199829f0c98ade48cfe459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae754b2aa285603335beca4d62587cc" id="r_a9ae754b2aa285603335beca4d62587cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ae754b2aa285603335beca4d62587cc">ComputeHyperplanAboveSquare</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> x, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> square, IntegerValue x_lb, IntegerValue x_ub, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a9ae754b2aa285603335beca4d62587cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c493e48e51fd4f652fbca14b34d587" id="r_a32c493e48e51fd4f652fbca14b34d587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c493e48e51fd4f652fbca14b34d587">ComputeHyperplanBelowSquare</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> x, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> square, IntegerValue x_value, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a32c493e48e51fd4f652fbca14b34d587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79af46d14a4530c0bf34132ff038b181" id="r_a79af46d14a4530c0bf34132ff038b181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79af46d14a4530c0bf34132ff038b181">CreateSquareCutGenerator</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> y, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> x, int linearization_level, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a79af46d14a4530c0bf34132ff038b181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79480946db118d243932e4b85e7e2fe3" id="r_a79480946db118d243932e4b85e7e2fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79480946db118d243932e4b85e7e2fe3">CreateAllDifferentCutGenerator</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; exprs, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a79480946db118d243932e4b85e7e2fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c901078d9cbbd1d172c40c979daa86f" id="r_a6c901078d9cbbd1d172c40c979daa86f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c901078d9cbbd1d172c40c979daa86f">CreateLinMaxCutGenerator</a> (const IntegerVariable target, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt; exprs, absl::Span&lt; const IntegerVariable &gt; z_vars, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a6c901078d9cbbd1d172c40c979daa86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1490b1b035faf1abe0893610f0bc0d90" id="r_a1490b1b035faf1abe0893610f0bc0d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1490b1b035faf1abe0893610f0bc0d90">BuildMaxAffineUpConstraint</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;target, IntegerVariable var, absl::Span&lt; const std::pair&lt; IntegerValue, IntegerValue &gt; &gt; affines, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html">LinearConstraintBuilder</a> *builder)</td></tr>
<tr class="separator:a1490b1b035faf1abe0893610f0bc0d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f489d29b6f16fd7ee68f7435bfffa59" id="r_a8f489d29b6f16fd7ee68f7435bfffa59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f489d29b6f16fd7ee68f7435bfffa59">CreateMaxAffineCutGenerator</a> (<a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> target, IntegerVariable var, std::vector&lt; std::pair&lt; IntegerValue, IntegerValue &gt; &gt; affines, const std::string cut_name, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a8f489d29b6f16fd7ee68f7435bfffa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c70694f9f0f67ba168f9b981735c05a" id="r_a7c70694f9f0f67ba168f9b981735c05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c70694f9f0f67ba168f9b981735c05a">CreateCliqueCutGenerator</a> (absl::Span&lt; const IntegerVariable &gt; base_variables, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a7c70694f9f0f67ba168f9b981735c05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6957a99e6ed65e43b44bf86a846822c" id="r_ad6957a99e6ed65e43b44bf86a846822c"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerValue(IntegerValue)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6957a99e6ed65e43b44bf86a846822c">ExtendNegativeFunction</a> (std::function&lt; IntegerValue(IntegerValue)&gt; base_f, IntegerValue period)</td></tr>
<tr class="separator:ad6957a99e6ed65e43b44bf86a846822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5886b2abb94aab5d08b1997d6bbbcf0" id="r_ab5886b2abb94aab5d08b1997d6bbbcf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5886b2abb94aab5d08b1997d6bbbcf0">AddNonOverlappingRectangles</a> (const std::vector&lt; IntervalVariable &gt; &amp;x, const std::vector&lt; IntervalVariable &gt; &amp;y, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ab5886b2abb94aab5d08b1997d6bbbcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645a56c08ee13df54ea959184ffea321" id="r_a645a56c08ee13df54ea959184ffea321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645a56c08ee13df54ea959184ffea321">GenerateNoOverlap2dEnergyCut</a> (absl::Span&lt; const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt; &gt; energies, absl::Span&lt; const int &gt; rectangles, absl::string_view cut_name, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *x_helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *y_helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *y_demands_helper)</td></tr>
<tr class="separator:a645a56c08ee13df54ea959184ffea321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7ca84b359f0e49b63ece216db6c944" id="r_a2b7ca84b359f0e49b63ece216db6c944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b7ca84b359f0e49b63ece216db6c944">CreateNoOverlap2dEnergyCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a2b7ca84b359f0e49b63ece216db6c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98231785656155f51bdfef3c63bc0127" id="r_a98231785656155f51bdfef3c63bc0127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98231785656155f51bdfef3c63bc0127">CreateNoOverlap2dCompletionTimeCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a98231785656155f51bdfef3c63bc0127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ebac5ff9b5521ef368606a16ca84ce" id="r_a37ebac5ff9b5521ef368606a16ca84ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1CompactVectorVector.html">CompactVectorVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37ebac5ff9b5521ef368606a16ca84ce">GetOverlappingRectangleComponents</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles)</td></tr>
<tr class="separator:a37ebac5ff9b5521ef368606a16ca84ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dc2fa5d4896cd17270cf7d40099e08" id="r_a89dc2fa5d4896cd17270cf7d40099e08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89dc2fa5d4896cd17270cf7d40099e08">ReportEnergyConflict</a> (<a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> bounding_box, absl::Span&lt; const int &gt; boxes, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *x, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *y)</td></tr>
<tr class="separator:a89dc2fa5d4896cd17270cf7d40099e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b5831e3d961be1c87854578abfa197" id="r_aa7b5831e3d961be1c87854578abfa197"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7b5831e3d961be1c87854578abfa197">BoxesAreInEnergyConflict</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles, absl::Span&lt; const IntegerValue &gt; energies, absl::Span&lt; const int &gt; boxes, <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> *conflict)</td></tr>
<tr class="separator:aa7b5831e3d961be1c87854578abfa197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f4e0c653d01e67ff65ec40eb96e2e5" id="r_a43f4e0c653d01e67ff65ec40eb96e2e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43f4e0c653d01e67ff65ec40eb96e2e5">AnalyzeIntervals</a> (bool transpose, absl::Span&lt; const int &gt; local_boxes, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles, absl::Span&lt; const IntegerValue &gt; rectangle_energies, IntegerValue *x_threshold, IntegerValue *y_threshold, <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> *conflict)</td></tr>
<tr class="separator:a43f4e0c653d01e67ff65ec40eb96e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0be3244a48d1875afbbb1fa690d743" id="r_a3f0be3244a48d1875afbbb1fa690d743"><td class="memItemLeft" align="right" valign="top">absl::Span&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f0be3244a48d1875afbbb1fa690d743">FilterBoxesAndRandomize</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; cached_rectangles, absl::Span&lt; int &gt; boxes, IntegerValue threshold_x, IntegerValue threshold_y, absl::BitGenRef random)</td></tr>
<tr class="separator:a3f0be3244a48d1875afbbb1fa690d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f440f63eee04ede634a116041adf7b" id="r_a56f440f63eee04ede634a116041adf7b"><td class="memItemLeft" align="right" valign="top">absl::Span&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56f440f63eee04ede634a116041adf7b">FilterBoxesThatAreTooLarge</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; cached_rectangles, absl::Span&lt; const IntegerValue &gt; energies, absl::Span&lt; int &gt; boxes)</td></tr>
<tr class="separator:a56f440f63eee04ede634a116041adf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca3e1768bf680ee6b3bbec72f4d0955" id="r_a7ca3e1768bf680ee6b3bbec72f4d0955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca3e1768bf680ee6b3bbec72f4d0955">ConstructOverlappingSets</a> (absl::Span&lt; <a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html">IndexedInterval</a> &gt; intervals, <a class="el" href="classoperations__research_1_1sat_1_1CompactVectorVector.html">CompactVectorVector</a>&lt; int &gt; *result, absl::Span&lt; const int &gt; order)</td></tr>
<tr class="separator:a7ca3e1768bf680ee6b3bbec72f4d0955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6c4aa7b48dc203f11f4be4581dbdd6" id="r_ada6c4aa7b48dc203f11f4be4581dbdd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada6c4aa7b48dc203f11f4be4581dbdd6">GetOverlappingIntervalComponents</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html">IndexedInterval</a> &gt; *intervals, std::vector&lt; std::vector&lt; int &gt; &gt; *components)</td></tr>
<tr class="separator:ada6c4aa7b48dc203f11f4be4581dbdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632e976a0e61c8dc649c0fcb4d3cc324" id="r_a632e976a0e61c8dc649c0fcb4d3cc324"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a632e976a0e61c8dc649c0fcb4d3cc324">GetIntervalArticulationPoints</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html">IndexedInterval</a> &gt; *intervals)</td></tr>
<tr class="separator:a632e976a0e61c8dc649c0fcb4d3cc324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15a14c74b4a487e85d5feb27e6ecb7" id="r_a6e15a14c74b4a487e85d5feb27e6ecb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e15a14c74b4a487e85d5feb27e6ecb7">AppendPairwiseRestrictions</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt; items, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1PairwiseRestriction.html">PairwiseRestriction</a> &gt; *result)</td></tr>
<tr class="separator:a6e15a14c74b4a487e85d5feb27e6ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c9d3c5559f8abe31853de852a29cc4" id="r_ac4c9d3c5559f8abe31853de852a29cc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4c9d3c5559f8abe31853de852a29cc4">AppendPairwiseRestrictions</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt; items, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt; other_items, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1PairwiseRestriction.html">PairwiseRestriction</a> &gt; *result)</td></tr>
<tr class="separator:ac4c9d3c5559f8abe31853de852a29cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6111749765bdc417d6faab8b21bebe1" id="r_ad6111749765bdc417d6faab8b21bebe1"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6111749765bdc417d6faab8b21bebe1">Smallest1DIntersection</a> (IntegerValue range_min, IntegerValue range_max, IntegerValue size, IntegerValue interval_min, IntegerValue interval_max)</td></tr>
<tr class="separator:ad6111749765bdc417d6faab8b21bebe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c95d68b46f17e3aa215ce63ea446514" id="r_a9c95d68b46f17e3aa215ce63ea446514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1FindRectanglesResult.html">FindRectanglesResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c95d68b46f17e3aa215ce63ea446514">FindRectanglesWithEnergyConflictMC</a> (const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt; &amp;intervals, absl::BitGenRef random, double temperature, double candidate_energy_usage_factor)</td></tr>
<tr class="separator:a9c95d68b46f17e3aa215ce63ea446514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd788eac051abcdab1ccdf96fb223e5" id="r_afcd788eac051abcdab1ccdf96fb223e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcd788eac051abcdab1ccdf96fb223e5">RenderDot</a> (std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; bb, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; <a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>, std::string_view extra_dot_payload)</td></tr>
<tr class="separator:afcd788eac051abcdab1ccdf96fb223e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557dbf01937df17542da0144682913cd" id="r_a557dbf01937df17542da0144682913cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a557dbf01937df17542da0144682913cd">FindEmptySpaces</a> (const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;bounding_box, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; ocupied_rectangles)</td></tr>
<tr class="separator:a557dbf01937df17542da0144682913cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de14d43c9cfa1c3df4c349eae8bae9c" id="r_a9de14d43c9cfa1c3df4c349eae8bae9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de14d43c9cfa1c3df4c349eae8bae9c">PavedRegionDifference</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; original_region, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; area_to_remove)</td></tr>
<tr class="separator:a9de14d43c9cfa1c3df4c349eae8bae9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a029475f2aeb7c0836c71197e45029" id="r_a90a029475f2aeb7c0836c71197e45029"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90a029475f2aeb7c0836c71197e45029">FindPartialRectangleIntersectionsImpl</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle32.html">Rectangle32</a> &gt; rectangles, int32_t y_max)</td></tr>
<tr class="separator:a90a029475f2aeb7c0836c71197e45029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd64e55540ba0780860b048ebe2810bc" id="r_acd64e55540ba0780860b048ebe2810bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd64e55540ba0780860b048ebe2810bc">FindPartialRectangleIntersections</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles)</td></tr>
<tr class="separator:acd64e55540ba0780860b048ebe2810bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfb3b053c2a90810e5d46bcd80f450f" id="r_a4dfb3b053c2a90810e5d46bcd80f450f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dfb3b053c2a90810e5d46bcd80f450f">FindOneIntersectionIfPresent</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles)</td></tr>
<tr class="separator:a4dfb3b053c2a90810e5d46bcd80f450f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cf3e62055df8605ab8f160c4557591" id="r_ac9cf3e62055df8605ab8f160c4557591"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9cf3e62055df8605ab8f160c4557591">FindOneIntersectionIfPresentWithZeroArea</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; rectangles)</td></tr>
<tr class="separator:ac9cf3e62055df8605ab8f160c4557591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8262482191c38e5e1490922b9d1c5f" id="r_a6c8262482191c38e5e1490922b9d1c5f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c8262482191c38e5e1490922b9d1c5f">CenterToCenterL2Distance</a> (const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;a, const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a6c8262482191c38e5e1490922b9d1c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 distance between the centers of the two rectangles.  <br /></td></tr>
<tr class="separator:a6c8262482191c38e5e1490922b9d1c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5038b1e77ef9a49c65fe0571c6b764d6" id="r_a5038b1e77ef9a49c65fe0571c6b764d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5038b1e77ef9a49c65fe0571c6b764d6">CenterToCenterLInfinityDistance</a> (const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;a, const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="separator:a5038b1e77ef9a49c65fe0571c6b764d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3c2a027271b5ffacc61124c8fc0f24" id="r_a1b3c2a027271b5ffacc61124c8fc0f24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3c2a027271b5ffacc61124c8fc0f24">RegionIncludesOther</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; region, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; other)</td></tr>
<tr class="memdesc:a1b3c2a027271b5ffacc61124c8fc0f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two regions must be defined by non-overlapping rectangles.  <br /></td></tr>
<tr class="separator:a1b3c2a027271b5ffacc61124c8fc0f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611f7231b53b78245f5464fdbc2375a4" id="r_a611f7231b53b78245f5464fdbc2375a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a611f7231b53b78245f5464fdbc2375a4">ReduceModuloBasis</a> (absl::Span&lt; const std::vector&lt; absl::int128 &gt; &gt; basis, const int elements_to_consider, std::vector&lt; absl::int128 &gt; &amp;v)</td></tr>
<tr class="separator:a611f7231b53b78245f5464fdbc2375a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6433b3a01c71cd754d3d710f345b4c0" id="r_af6433b3a01c71cd754d3d710f345b4c0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6433b3a01c71cd754d3d710f345b4c0">GreedyFastDecreasingGcd</a> (const absl::Span&lt; const int64_t &gt; coeffs)</td></tr>
<tr class="separator:af6433b3a01c71cd754d3d710f345b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a3828d1897a92ece5fd4f6018fe3da" id="r_a43a3828d1897a92ece5fd4f6018fe3da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1DiophantineSolution.html">DiophantineSolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43a3828d1897a92ece5fd4f6018fe3da">SolveDiophantine</a> (absl::Span&lt; const int64_t &gt; coeffs, int64_t rhs, absl::Span&lt; const int64_t &gt; var_lbs, absl::Span&lt; const int64_t &gt; var_ubs)</td></tr>
<tr class="separator:a43a3828d1897a92ece5fd4f6018fe3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5fc3553106ac67afaf0b8525d7f110" id="r_add5fc3553106ac67afaf0b8525d7f110"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add5fc3553106ac67afaf0b8525d7f110">floor</a> (|P|/2)&lt;</td></tr>
<tr class="separator:add5fc3553106ac67afaf0b8525d7f110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab304db27f5c4170f35583c69269394" id="r_a9ab304db27f5c4170f35583c69269394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab304db27f5c4170f35583c69269394">AddDisjunctive</a> (const std::vector&lt; IntervalVariable &gt; &amp;intervals, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a9ab304db27f5c4170f35583c69269394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66c711944582345e467efd1d25eb48e" id="r_ae66c711944582345e467efd1d25eb48e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66c711944582345e467efd1d25eb48e">AddDisjunctiveWithBooleanPrecedencesOnly</a> (absl::Span&lt; const IntervalVariable &gt; intervals, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ae66c711944582345e467efd1d25eb48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63affeaff6ccd82933aa13529338857" id="r_ac63affeaff6ccd82933aa13529338857"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac63affeaff6ccd82933aa13529338857">ContainsLiteral</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; clause, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> literal)</td></tr>
<tr class="separator:ac63affeaff6ccd82933aa13529338857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518eef034832dda8fbc0df67737c35b" id="r_a3518eef034832dda8fbc0df67737c35b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3518eef034832dda8fbc0df67737c35b">Resolve</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; clause, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; other_clause, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> complementary_literal, <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> *assignment, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *resolvent)</td></tr>
<tr class="separator:a3518eef034832dda8fbc0df67737c35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23349cb008ced3bcc44ff0213b12a656" id="r_a23349cb008ced3bcc44ff0213b12a656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23349cb008ced3bcc44ff0213b12a656">AddProblemClauses</a> (const std::string &amp;file_path, <a class="el" href="classoperations__research_1_1sat_1_1DratChecker.html">DratChecker</a> *drat_checker)</td></tr>
<tr class="separator:a23349cb008ced3bcc44ff0213b12a656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd62b999813ebc36c91f4d49d06aff4" id="r_a1fd62b999813ebc36c91f4d49d06aff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fd62b999813ebc36c91f4d49d06aff4">AddInferedAndDeletedClauses</a> (const std::string &amp;file_path, <a class="el" href="classoperations__research_1_1sat_1_1DratChecker.html">DratChecker</a> *drat_checker)</td></tr>
<tr class="separator:a1fd62b999813ebc36c91f4d49d06aff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89916cb29dee74465f5d966707a34845" id="r_a89916cb29dee74465f5d966707a34845"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89916cb29dee74465f5d966707a34845">PrintClauses</a> (const std::string &amp;file_path, <a class="el" href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51ce">SatFormat</a> format, absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; clauses, int num_variables)</td></tr>
<tr class="separator:a89916cb29dee74465f5d966707a34845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e75372160364c7130866052ddade46b" id="r_a0e75372160364c7130866052ddade46b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e75372160364c7130866052ddade46b">DEFINE_STRONG_INDEX_TYPE</a> (ClauseIndex)</td></tr>
<tr class="memdesc:a0e75372160364c7130866052ddade46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a clause (&gt;= 0).  <br /></td></tr>
<tr class="separator:a0e75372160364c7130866052ddade46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb42181de5b23ba7b5df37fe1676a3" id="r_affcb42181de5b23ba7b5df37fe1676a3"><td class="memItemLeft" align="right" valign="top">const ClauseIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcb42181de5b23ba7b5df37fe1676a3">kNoClauseIndex</a> (-1)</td></tr>
<tr class="separator:affcb42181de5b23ba7b5df37fe1676a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b60373d086b4bfab3d7eef132513733" id="r_a7b60373d086b4bfab3d7eef132513733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b60373d086b4bfab3d7eef132513733">LazyMerge</a> (<a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *a, <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:a7b60373d086b4bfab3d7eef132513733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad715c4b2444c3b6fb162bc2382a2248e" id="r_ad715c4b2444c3b6fb162bc2382a2248e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad715c4b2444c3b6fb162bc2382a2248e">IncreaseNodeSize</a> (<a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *node, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:ad715c4b2444c3b6fb162bc2382a2248e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2c3a42e94b355db103786dd526e2ea" id="r_a7c2c3a42e94b355db103786dd526e2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c2c3a42e94b355db103786dd526e2ea">FullMerge</a> (Coefficient upper_bound, <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *a, <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:a7c2c3a42e94b355db103786dd526e2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b03a3ba7d84e291889f64f0897c5518" id="r_a0b03a3ba7d84e291889f64f0897c5518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b03a3ba7d84e291889f64f0897c5518">MergeAllNodesWithDeque</a> (Coefficient upper_bound, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;nodes, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver, std::deque&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> &gt; *repository)</td></tr>
<tr class="separator:a0b03a3ba7d84e291889f64f0897c5518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953eef5429c8eee49950f3f28f22ca09" id="r_a953eef5429c8eee49950f3f28f22ca09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a953eef5429c8eee49950f3f28f22ca09">LazyMergeAllNodeWithPQAndIncreaseLb</a> (Coefficient weight, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;nodes, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver, std::deque&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> &gt; *repository)</td></tr>
<tr class="separator:a953eef5429c8eee49950f3f28f22ca09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7c0126948e1cf811fc9fe8519915e5" id="r_a4c7c0126948e1cf811fc9fe8519915e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c7c0126948e1cf811fc9fe8519915e5">ReduceNodes</a> (Coefficient upper_bound, Coefficient *lower_bound, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; *nodes, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:a4c7c0126948e1cf811fc9fe8519915e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe04b2641ce52e27d22fd205da99f06" id="r_a1fe04b2641ce52e27d22fd205da99f06"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe04b2641ce52e27d22fd205da99f06">ExtractAssumptions</a> (Coefficient stratified_lower_bound, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;nodes, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:a1fe04b2641ce52e27d22fd205da99f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cf8284db404ce0040808a1d62f0c10" id="r_a55cf8284db404ce0040808a1d62f0c10"><td class="memItemLeft" align="right" valign="top">Coefficient&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55cf8284db404ce0040808a1d62f0c10">ComputeCoreMinWeight</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;nodes, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; core)</td></tr>
<tr class="separator:a55cf8284db404ce0040808a1d62f0c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af483d3fee5a1d84f115a3797cddbd98c" id="r_af483d3fee5a1d84f115a3797cddbd98c"><td class="memItemLeft" align="right" valign="top">Coefficient&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af483d3fee5a1d84f115a3797cddbd98c">MaxNodeWeightSmallerThan</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;nodes, Coefficient upper_bound)</td></tr>
<tr class="separator:af483d3fee5a1d84f115a3797cddbd98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5783ecb0b6b7f12fc2ea70339ec7acd" id="r_aa5783ecb0b6b7f12fc2ea70339ec7acd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5783ecb0b6b7f12fc2ea70339ec7acd">TryToReconcileEncodings</a> (const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;size2_affine, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;affine, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; affine_var_encoding, bool put_affine_left_in_result, <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> *integer_encoder)</td></tr>
<tr class="separator:aa5783ecb0b6b7f12fc2ea70339ec7acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bb893f521052633be884ab5a14a566" id="r_a20bb893f521052633be884ab5a14a566"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20bb893f521052633be884ab5a14a566">TryToReconcileSize2Encodings</a> (const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;left, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;right, <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> *integer_encoder)</td></tr>
<tr class="separator:a20bb893f521052633be884ab5a14a566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c32a6d4b37adef70ebfc92eabf05b4" id="r_ac5c32a6d4b37adef70ebfc92eabf05b4"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:ac5c32a6d4b37adef70ebfc92eabf05b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5c32a6d4b37adef70ebfc92eabf05b4">InclusionDetector</a> (const Storage &amp;storage) -&gt; InclusionDetector&lt; Storage &gt;</td></tr>
<tr class="memdesc:ac5c32a6d4b37adef70ebfc92eabf05b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <br /></td></tr>
<tr class="separator:ac5c32a6d4b37adef70ebfc92eabf05b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdca64632fe6eb1a4fed67843084620f" id="r_acdca64632fe6eb1a4fed67843084620f"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:acdca64632fe6eb1a4fed67843084620f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acdca64632fe6eb1a4fed67843084620f">SubsetsDetector</a> (const Storage &amp;storage) -&gt; SubsetsDetector&lt; Storage &gt;</td></tr>
<tr class="separator:acdca64632fe6eb1a4fed67843084620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be15b4e667753185cda0c0d9315b5ad" id="r_a3be15b4e667753185cda0c0d9315b5ad"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be15b4e667753185cda0c0d9315b5ad">ComputeSignatureAndMaxElement</a> (absl::Span&lt; const int &gt; elements)</td></tr>
<tr class="separator:a3be15b4e667753185cda0c0d9315b5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437aa190248b2ee0c2971fa058512f71" id="r_a437aa190248b2ee0c2971fa058512f71"><td class="memItemLeft" align="right" valign="top">std::vector&lt; IntegerVariable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437aa190248b2ee0c2971fa058512f71">NegationOf</a> (absl::Span&lt; const IntegerVariable &gt; vars)</td></tr>
<tr class="memdesc:a437aa190248b2ee0c2971fa058512f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of the negated variables.  <br /></td></tr>
<tr class="separator:a437aa190248b2ee0c2971fa058512f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f0092047d7e82e9fdb7f6b1235947c" id="r_ad4f0092047d7e82e9fdb7f6b1235947c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f0092047d7e82e9fdb7f6b1235947c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &amp;p)</td></tr>
<tr class="separator:ad4f0092047d7e82e9fdb7f6b1235947c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb95842130bc03177260ad20464bdbf" id="r_a3cb95842130bc03177260ad20464bdbf"><td class="memItemLeft" align="right" valign="top">std::function&lt; BooleanVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cb95842130bc03177260ad20464bdbf">NewBooleanVariable</a> ()</td></tr>
<tr class="separator:a3cb95842130bc03177260ad20464bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64664019450638ab96732f0b59ea015b" id="r_a64664019450638ab96732f0b59ea015b"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64664019450638ab96732f0b59ea015b">ConstantIntegerVariable</a> (int64_t value)</td></tr>
<tr class="separator:a64664019450638ab96732f0b59ea015b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab186c7ad5f0930615f096f56e1499d30" id="r_ab186c7ad5f0930615f096f56e1499d30"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab186c7ad5f0930615f096f56e1499d30">NewIntegerVariable</a> (int64_t lb, int64_t ub)</td></tr>
<tr class="separator:ab186c7ad5f0930615f096f56e1499d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7052daba281884bb077df08cb581cb31" id="r_a7052daba281884bb077df08cb581cb31"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7052daba281884bb077df08cb581cb31">NewIntegerVariable</a> (const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain)</td></tr>
<tr class="separator:a7052daba281884bb077df08cb581cb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe56022a1da9877153f91ab02f433dba" id="r_afe56022a1da9877153f91ab02f433dba"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe56022a1da9877153f91ab02f433dba">CreateNewIntegerVariableFromLiteral</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:afe56022a1da9877153f91ab02f433dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c9f843d5f82c4cf6e958a4062e5a7" id="r_a050c9f843d5f82c4cf6e958a4062e5a7"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a050c9f843d5f82c4cf6e958a4062e5a7">NewIntegerVariableFromLiteral</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit)</td></tr>
<tr class="separator:a050c9f843d5f82c4cf6e958a4062e5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad49ae9019c528851f6fd084479a567" id="r_a3ad49ae9019c528851f6fd084479a567"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ad49ae9019c528851f6fd084479a567">LowerBound</a> (IntegerVariable v)</td></tr>
<tr class="separator:a3ad49ae9019c528851f6fd084479a567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e815eb2193f1bb6903274c7f0859cd7" id="r_a9e815eb2193f1bb6903274c7f0859cd7"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e815eb2193f1bb6903274c7f0859cd7">UpperBound</a> (IntegerVariable v)</td></tr>
<tr class="separator:a9e815eb2193f1bb6903274c7f0859cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3c6ea5e2b95e4d7e45d6146c61c2ce" id="r_a4d3c6ea5e2b95e4d7e45d6146c61c2ce"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d3c6ea5e2b95e4d7e45d6146c61c2ce">IsFixed</a> (IntegerVariable v)</td></tr>
<tr class="separator:a4d3c6ea5e2b95e4d7e45d6146c61c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eab70b5ead3894afac4d4fff0fd984" id="r_a96eab70b5ead3894afac4d4fff0fd984"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96eab70b5ead3894afac4d4fff0fd984">Value</a> (IntegerVariable v)</td></tr>
<tr class="memdesc:a96eab70b5ead3894afac4d4fff0fd984"><td class="mdescLeft">&#160;</td><td class="mdescRight">This checks that the variable is fixed.  <br /></td></tr>
<tr class="separator:a96eab70b5ead3894afac4d4fff0fd984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba1ab2a4a6cdc0ea4324d409ddbe7e" id="r_ab3ba1ab2a4a6cdc0ea4324d409ddbe7e"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3ba1ab2a4a6cdc0ea4324d409ddbe7e">GreaterOrEqual</a> (IntegerVariable v, int64_t lb)</td></tr>
<tr class="separator:ab3ba1ab2a4a6cdc0ea4324d409ddbe7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f35d207f7fbd9abc30ced851352b069" id="r_a3f35d207f7fbd9abc30ced851352b069"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f35d207f7fbd9abc30ced851352b069">LowerOrEqual</a> (IntegerVariable v, int64_t ub)</td></tr>
<tr class="separator:a3f35d207f7fbd9abc30ced851352b069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134ba4c37e543cb80c698555b6ae89f8" id="r_a134ba4c37e543cb80c698555b6ae89f8"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a134ba4c37e543cb80c698555b6ae89f8">Equality</a> (IntegerVariable v, int64_t value)</td></tr>
<tr class="memdesc:a134ba4c37e543cb80c698555b6ae89f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix v to a given value.  <br /></td></tr>
<tr class="separator:a134ba4c37e543cb80c698555b6ae89f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca12ac764578209e7eaa692a9029635" id="r_a5ca12ac764578209e7eaa692a9029635"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca12ac764578209e7eaa692a9029635">Implication</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>)</td></tr>
<tr class="separator:a5ca12ac764578209e7eaa692a9029635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39ed3f215af8b2d35da4d2a52254c42" id="r_ad39ed3f215af8b2d35da4d2a52254c42"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39ed3f215af8b2d35da4d2a52254c42">ImpliesInInterval</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> in_interval, IntegerVariable v, int64_t lb, int64_t ub)</td></tr>
<tr class="memdesc:ad39ed3f215af8b2d35da4d2a52254c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">in_interval =&gt; v in [lb, ub].  <br /></td></tr>
<tr class="separator:ad39ed3f215af8b2d35da4d2a52254c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0185d084af6ad784edced90f45174133" id="r_a0185d084af6ad784edced90f45174133"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt;(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0185d084af6ad784edced90f45174133">FullyEncodeVariable</a> (IntegerVariable var)</td></tr>
<tr class="separator:a0185d084af6ad784edced90f45174133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abf8d5e7d838d6348a6b5b7101a0b04" id="r_a2abf8d5e7d838d6348a6b5b7101a0b04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2abf8d5e7d838d6348a6b5b7101a0b04">DEFINE_STRONG_INT64_TYPE</a> (IntegerValue)</td></tr>
<tr class="separator:a2abf8d5e7d838d6348a6b5b7101a0b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1227e67513602591fb959e35c9de66e8" id="r_a1227e67513602591fb959e35c9de66e8"><td class="memItemLeft" align="right" valign="top">constexpr IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1227e67513602591fb959e35c9de66e8">kMaxIntegerValue</a> (std::numeric_limits&lt; IntegerValue::ValueType &gt;::max() - 1)</td></tr>
<tr class="separator:a1227e67513602591fb959e35c9de66e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5316808a2d5007c3b489e844801385e5" id="r_a5316808a2d5007c3b489e844801385e5"><td class="memItemLeft" align="right" valign="top">constexpr IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5316808a2d5007c3b489e844801385e5">kMinIntegerValue</a> (-kMaxIntegerValue.value())</td></tr>
<tr class="separator:a5316808a2d5007c3b489e844801385e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed77a1a7675c2f8568529a5a16247ec1" id="r_aed77a1a7675c2f8568529a5a16247ec1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed77a1a7675c2f8568529a5a16247ec1">ToDouble</a> (IntegerValue value)</td></tr>
<tr class="separator:aed77a1a7675c2f8568529a5a16247ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e30e51173c7e43a8c0b4668d5e3f050" id="r_a1e30e51173c7e43a8c0b4668d5e3f050"><td class="memTemplParams" colspan="2">template&lt;class IntType&gt; </td></tr>
<tr class="memitem:a1e30e51173c7e43a8c0b4668d5e3f050"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e30e51173c7e43a8c0b4668d5e3f050">IntTypeAbs</a> (IntType t)</td></tr>
<tr class="separator:a1e30e51173c7e43a8c0b4668d5e3f050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b96869d2a821cf1d2e6099e7a0f51b" id="r_a29b96869d2a821cf1d2e6099e7a0f51b"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29b96869d2a821cf1d2e6099e7a0f51b">CeilRatio</a> (IntegerValue dividend, IntegerValue positive_divisor)</td></tr>
<tr class="separator:a29b96869d2a821cf1d2e6099e7a0f51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07823d046b027c81155f8a2f322cf813" id="r_a07823d046b027c81155f8a2f322cf813"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07823d046b027c81155f8a2f322cf813">FloorRatio</a> (IntegerValue dividend, IntegerValue positive_divisor)</td></tr>
<tr class="separator:a07823d046b027c81155f8a2f322cf813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5808dd3a993daef4c5d5e427097180" id="r_aeb5808dd3a993daef4c5d5e427097180"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb5808dd3a993daef4c5d5e427097180">CapProdI</a> (IntegerValue a, IntegerValue <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:aeb5808dd3a993daef4c5d5e427097180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overflows and saturated arithmetic.  <br /></td></tr>
<tr class="separator:aeb5808dd3a993daef4c5d5e427097180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cf8fbd59474ff6b4a19b2add7d2f4a" id="r_ae6cf8fbd59474ff6b4a19b2add7d2f4a"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6cf8fbd59474ff6b4a19b2add7d2f4a">CapSubI</a> (IntegerValue a, IntegerValue <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="separator:ae6cf8fbd59474ff6b4a19b2add7d2f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92716c99d1629cbb8717b4e0dec1dbc7" id="r_a92716c99d1629cbb8717b4e0dec1dbc7"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92716c99d1629cbb8717b4e0dec1dbc7">CapAddI</a> (IntegerValue a, IntegerValue <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="separator:a92716c99d1629cbb8717b4e0dec1dbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa12deefa498c86a88f95cd7d221381" id="r_a2aa12deefa498c86a88f95cd7d221381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aa12deefa498c86a88f95cd7d221381">ProdOverflow</a> (IntegerValue t, IntegerValue value)</td></tr>
<tr class="separator:a2aa12deefa498c86a88f95cd7d221381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae756efa08d99803bb3fe591d43940a5b" id="r_ae756efa08d99803bb3fe591d43940a5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae756efa08d99803bb3fe591d43940a5b">AtMinOrMaxInt64I</a> (IntegerValue t)</td></tr>
<tr class="separator:ae756efa08d99803bb3fe591d43940a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f714c395df7a814ed067125f567a0d" id="r_a83f714c395df7a814ed067125f567a0d"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83f714c395df7a814ed067125f567a0d">PositiveRemainder</a> (IntegerValue dividend, IntegerValue positive_divisor)</td></tr>
<tr class="separator:a83f714c395df7a814ed067125f567a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19454de69c01843c000fbf4f96fc99f1" id="r_a19454de69c01843c000fbf4f96fc99f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19454de69c01843c000fbf4f96fc99f1">AddTo</a> (IntegerValue a, IntegerValue *result)</td></tr>
<tr class="separator:a19454de69c01843c000fbf4f96fc99f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9e8fab437ba44c91b0493a74cde263" id="r_a0c9e8fab437ba44c91b0493a74cde263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9e8fab437ba44c91b0493a74cde263">AddProductTo</a> (IntegerValue a, IntegerValue <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, IntegerValue *result)</td></tr>
<tr class="memdesc:a0c9e8fab437ba44c91b0493a74cde263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes result += a * b, and return false iff there is an overflow.  <br /></td></tr>
<tr class="separator:a0c9e8fab437ba44c91b0493a74cde263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0223d339c204a71da3ff69acf246e355" id="r_a0223d339c204a71da3ff69acf246e355"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0223d339c204a71da3ff69acf246e355">AddSquareTo</a> (IntegerValue a, IntegerValue *result)</td></tr>
<tr class="memdesc:a0223d339c204a71da3ff69acf246e355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes result += a * a, and return false iff there is an overflow.  <br /></td></tr>
<tr class="separator:a0223d339c204a71da3ff69acf246e355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda1319282a2ed2307e06999f1e8e1f8" id="r_adda1319282a2ed2307e06999f1e8e1f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda1319282a2ed2307e06999f1e8e1f8">DEFINE_STRONG_INDEX_TYPE</a> (IntegerVariable)</td></tr>
<tr class="separator:adda1319282a2ed2307e06999f1e8e1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd8c44473618b7eafd33ba978db2f06" id="r_a5bd8c44473618b7eafd33ba978db2f06"><td class="memItemLeft" align="right" valign="top">const IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bd8c44473618b7eafd33ba978db2f06">kNoIntegerVariable</a> (-1)</td></tr>
<tr class="separator:a5bd8c44473618b7eafd33ba978db2f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829dfffce41f532b7ca32665750a1ec2" id="r_a829dfffce41f532b7ca32665750a1ec2"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a829dfffce41f532b7ca32665750a1ec2">NegationOf</a> (IntegerVariable <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>)</td></tr>
<tr class="separator:a829dfffce41f532b7ca32665750a1ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2544d2a3a5ef4c78f8e5891f104ab41" id="r_ae2544d2a3a5ef4c78f8e5891f104ab41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2544d2a3a5ef4c78f8e5891f104ab41">VariableIsPositive</a> (IntegerVariable <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>)</td></tr>
<tr class="separator:ae2544d2a3a5ef4c78f8e5891f104ab41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ac774d4646a83631f8117f4ea03f5" id="r_a7f1ac774d4646a83631f8117f4ea03f5"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f1ac774d4646a83631f8117f4ea03f5">PositiveVariable</a> (IntegerVariable <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>)</td></tr>
<tr class="separator:a7f1ac774d4646a83631f8117f4ea03f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ab2033e6dfb7bc18d684852cccc8fa" id="r_a57ab2033e6dfb7bc18d684852cccc8fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57ab2033e6dfb7bc18d684852cccc8fa">DEFINE_STRONG_INDEX_TYPE</a> (PositiveOnlyIndex)</td></tr>
<tr class="memdesc:a57ab2033e6dfb7bc18d684852cccc8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special type for storing only one thing for var and NegationOf(var).  <br /></td></tr>
<tr class="separator:a57ab2033e6dfb7bc18d684852cccc8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf09b937c4d7439804c0fc61afcb7008" id="r_acf09b937c4d7439804c0fc61afcb7008"><td class="memItemLeft" align="right" valign="top">PositiveOnlyIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf09b937c4d7439804c0fc61afcb7008">GetPositiveOnlyIndex</a> (IntegerVariable var)</td></tr>
<tr class="separator:acf09b937c4d7439804c0fc61afcb7008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429d1fd54b5becc39e4cfbc608d7d70a" id="r_a429d1fd54b5becc39e4cfbc608d7d70a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a429d1fd54b5becc39e4cfbc608d7d70a">IntegerTermDebugString</a> (IntegerVariable var, IntegerValue coeff)</td></tr>
<tr class="separator:a429d1fd54b5becc39e4cfbc608d7d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af861617ac8f6ef74fe77c789248b86" id="r_a0af861617ac8f6ef74fe77c789248b86"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0af861617ac8f6ef74fe77c789248b86">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit)</td></tr>
<tr class="separator:a0af861617ac8f6ef74fe77c789248b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646ee3cd14af2a14066c6cd56f7f242b" id="r_a646ee3cd14af2a14066c6cd56f7f242b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a646ee3cd14af2a14066c6cd56f7f242b">operator&lt;&lt;</a> (std::ostream &amp;os, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; literals)</td></tr>
<tr class="separator:a646ee3cd14af2a14066c6cd56f7f242b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac160d1b2e1f1e1291af8c4dc333e3007" id="r_ac160d1b2e1f1e1291af8c4dc333e3007"><td class="memTemplParams" colspan="2">template&lt;typename H&gt; </td></tr>
<tr class="memitem:ac160d1b2e1f1e1291af8c4dc333e3007"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac160d1b2e1f1e1291af8c4dc333e3007">AbslHashValue</a> (H h, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;e)</td></tr>
<tr class="separator:ac160d1b2e1f1e1291af8c4dc333e3007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b04eae7b76b3c8989b8ac5753cbc16" id="r_ad5b04eae7b76b3c8989b8ac5753cbc16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5b04eae7b76b3c8989b8ac5753cbc16">DEFINE_STRONG_INDEX_TYPE</a> (IntervalVariable)</td></tr>
<tr class="separator:ad5b04eae7b76b3c8989b8ac5753cbc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcbeecb5d63f15f9f4c79c2ffa08777" id="r_a5dcbeecb5d63f15f9f4c79c2ffa08777"><td class="memItemLeft" align="right" valign="top">const IntervalVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dcbeecb5d63f15f9f4c79c2ffa08777">kNoIntervalVariable</a> (-1)</td></tr>
<tr class="separator:a5dcbeecb5d63f15f9f4c79c2ffa08777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1ffcc62b140fdca347aa4e5c381b3b" id="r_aff1ffcc62b140fdca347aa4e5c381b3b"><td class="memTemplParams" colspan="2">template&lt;typename VectorInt&gt; </td></tr>
<tr class="memitem:aff1ffcc62b140fdca347aa4e5c381b3b"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff1ffcc62b140fdca347aa4e5c381b3b">WeightedSumLowerOrEqual</a> (absl::Span&lt; const IntegerVariable &gt; vars, const VectorInt &amp;coefficients, int64_t upper_bound)</td></tr>
<tr class="memdesc:aff1ffcc62b140fdca347aa4e5c381b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted sum &lt;= constant.  <br /></td></tr>
<tr class="separator:aff1ffcc62b140fdca347aa4e5c381b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2f7e39e8f0fd691b6efe8f2ff4c86a" id="r_a2c2f7e39e8f0fd691b6efe8f2ff4c86a"><td class="memTemplParams" colspan="2">template&lt;typename VectorInt&gt; </td></tr>
<tr class="memitem:a2c2f7e39e8f0fd691b6efe8f2ff4c86a"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c2f7e39e8f0fd691b6efe8f2ff4c86a">WeightedSumGreaterOrEqual</a> (absl::Span&lt; const IntegerVariable &gt; vars, const VectorInt &amp;coefficients, int64_t lower_bound)</td></tr>
<tr class="memdesc:a2c2f7e39e8f0fd691b6efe8f2ff4c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted sum &gt;= constant.  <br /></td></tr>
<tr class="separator:a2c2f7e39e8f0fd691b6efe8f2ff4c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0524e31331a03f6d21a75bc4421aeb" id="r_a4a0524e31331a03f6d21a75bc4421aeb"><td class="memTemplParams" colspan="2">template&lt;typename VectorInt&gt; </td></tr>
<tr class="memitem:a4a0524e31331a03f6d21a75bc4421aeb"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4a0524e31331a03f6d21a75bc4421aeb">FixedWeightedSum</a> (absl::Span&lt; const IntegerVariable &gt; vars, const VectorInt &amp;coefficients, int64_t value)</td></tr>
<tr class="memdesc:a4a0524e31331a03f6d21a75bc4421aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted sum == constant.  <br /></td></tr>
<tr class="separator:a4a0524e31331a03f6d21a75bc4421aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919cb1a74305a95883f51e95343ac474" id="r_a919cb1a74305a95883f51e95343ac474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a919cb1a74305a95883f51e95343ac474">AddWeightedSumLowerOrEqual</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const int64_t &gt; coefficients, int64_t upper_bound, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a919cb1a74305a95883f51e95343ac474"><td class="mdescLeft">&#160;</td><td class="mdescRight">enforcement_literals =&gt; sum &lt;= upper_bound  <br /></td></tr>
<tr class="separator:a919cb1a74305a95883f51e95343ac474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1d6efbba26f23c1ce5565db2f78747" id="r_adf1d6efbba26f23c1ce5565db2f78747"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf1d6efbba26f23c1ce5565db2f78747">AddWeightedSumGreaterOrEqual</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const int64_t &gt; coefficients, int64_t lower_bound, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:adf1d6efbba26f23c1ce5565db2f78747"><td class="mdescLeft">&#160;</td><td class="mdescRight">enforcement_literals =&gt; sum &gt;= lower_bound  <br /></td></tr>
<tr class="separator:adf1d6efbba26f23c1ce5565db2f78747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789b92ff0403313af6cb313636d1317" id="r_a6789b92ff0403313af6cb313636d1317"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6789b92ff0403313af6cb313636d1317">ConditionalWeightedSumLowerOrEqual</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const int64_t &gt; coefficients, int64_t upper_bound)</td></tr>
<tr class="separator:a6789b92ff0403313af6cb313636d1317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965ac7991d6f213cb8398a43575dbf6d" id="r_a965ac7991d6f213cb8398a43575dbf6d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a965ac7991d6f213cb8398a43575dbf6d">ConditionalWeightedSumGreaterOrEqual</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const int64_t &gt; coefficients, int64_t upper_bound)</td></tr>
<tr class="separator:a965ac7991d6f213cb8398a43575dbf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4da650bfcb86c00bee1df0ab0cc953" id="r_a4b4da650bfcb86c00bee1df0ab0cc953"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b4da650bfcb86c00bee1df0ab0cc953">LoadConditionalLinearConstraint</a> (const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;cst, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a4b4da650bfcb86c00bee1df0ab0cc953"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> version.  <br /></td></tr>
<tr class="separator:a4b4da650bfcb86c00bee1df0ab0cc953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899896953b6215b01cb0b85caa96bebe" id="r_a899896953b6215b01cb0b85caa96bebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a899896953b6215b01cb0b85caa96bebe">LoadLinearConstraint</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;cst, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a899896953b6215b01cb0b85caa96bebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e70b48ffc73d9b4346b4415c3b799b6" id="r_a7e70b48ffc73d9b4346b4415c3b799b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e70b48ffc73d9b4346b4415c3b799b6">AddConditionalAffinePrecedence</a> (const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> left, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> right, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a7e70b48ffc73d9b4346b4415c3b799b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8af8f787d40f2ccb96beb5306c913c5" id="r_ad8af8f787d40f2ccb96beb5306c913c5"><td class="memTemplParams" colspan="2">template&lt;typename VectorInt&gt; </td></tr>
<tr class="memitem:ad8af8f787d40f2ccb96beb5306c913c5"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8af8f787d40f2ccb96beb5306c913c5">NewWeightedSum</a> (const VectorInt &amp;coefficients, const std::vector&lt; IntegerVariable &gt; &amp;vars)</td></tr>
<tr class="separator:ad8af8f787d40f2ccb96beb5306c913c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfd851680124f48adf731a43c644ca4" id="r_aecfd851680124f48adf731a43c644ca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecfd851680124f48adf731a43c644ca4">AddIsEqualToMinOf</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;min_expr, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt; exprs, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:aecfd851680124f48adf731a43c644ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b280638f4df989a78aa0774e48160" id="r_a4d7b280638f4df989a78aa0774e48160"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d7b280638f4df989a78aa0774e48160">IsEqualToMinOf</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;min_expr, const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt; &amp;exprs)</td></tr>
<tr class="separator:a4d7b280638f4df989a78aa0774e48160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838ae1c98a62762620ef82e362c4ad8c" id="r_a838ae1c98a62762620ef82e362c4ad8c"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a838ae1c98a62762620ef82e362c4ad8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a838ae1c98a62762620ef82e362c4ad8c">RegisterAndTransferOwnership</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, T *ct)</td></tr>
<tr class="separator:a838ae1c98a62762620ef82e362c4ad8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee7c83ad06fb9a710a64f3ff79b4289" id="r_a2ee7c83ad06fb9a710a64f3ff79b4289"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ee7c83ad06fb9a710a64f3ff79b4289">ProductConstraint</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> a, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> p)</td></tr>
<tr class="memdesc:a2ee7c83ad06fb9a710a64f3ff79b4289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint: a * b = p.  <br /></td></tr>
<tr class="separator:a2ee7c83ad06fb9a710a64f3ff79b4289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8e3999c6efdf2b47d4379b3eb9c85e" id="r_a6d8e3999c6efdf2b47d4379b3eb9c85e"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d8e3999c6efdf2b47d4379b3eb9c85e">DivisionConstraint</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> num, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> denom, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> div)</td></tr>
<tr class="memdesc:a6d8e3999c6efdf2b47d4379b3eb9c85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint: num / denom = div. (denom &gt; 0).  <br /></td></tr>
<tr class="separator:a6d8e3999c6efdf2b47d4379b3eb9c85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ea57d3df7b63f7be86a96eca1d0cf8" id="r_a41ea57d3df7b63f7be86a96eca1d0cf8"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41ea57d3df7b63f7be86a96eca1d0cf8">FixedDivisionConstraint</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> a, IntegerValue <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> c)</td></tr>
<tr class="memdesc:a41ea57d3df7b63f7be86a96eca1d0cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint: a / b = c where b is a constant.  <br /></td></tr>
<tr class="separator:a41ea57d3df7b63f7be86a96eca1d0cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f0785106a02e030ddee919ff33bd0d" id="r_ad9f0785106a02e030ddee919ff33bd0d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9f0785106a02e030ddee919ff33bd0d">FixedModuloConstraint</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> a, IntegerValue <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> c)</td></tr>
<tr class="memdesc:ad9f0785106a02e030ddee919ff33bd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint: a % b = c where b is a constant.  <br /></td></tr>
<tr class="separator:ad9f0785106a02e030ddee919ff33bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb183ffafc072d9fd0d52c6cc355993" id="r_a6bb183ffafc072d9fd0d52c6cc355993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bb183ffafc072d9fd0d52c6cc355993">AtMinValue</a> (IntegerVariable var, <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *integer_trail)</td></tr>
<tr class="separator:a6bb183ffafc072d9fd0d52c6cc355993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bf93441e3921c23e072061b83abb08" id="r_a65bf93441e3921c23e072061b83abb08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65bf93441e3921c23e072061b83abb08">ChooseBestObjectiveValue</a> (IntegerVariable var, <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *integer_trail, <a class="el" href="structoperations__research_1_1sat_1_1ObjectiveDefinition.html">ObjectiveDefinition</a> *objective_definition)</td></tr>
<tr class="memdesc:a65bf93441e3921c23e072061b83abb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a variable appear in the objective, branch on its best objective value.  <br /></td></tr>
<tr class="separator:a65bf93441e3921c23e072061b83abb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa27df9712553f45eb84d209a92ca8b" id="r_aeaa27df9712553f45eb84d209a92ca8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaa27df9712553f45eb84d209a92ca8b">GreaterOrEqualToMiddleValue</a> (IntegerVariable var, <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *integer_trail)</td></tr>
<tr class="separator:aeaa27df9712553f45eb84d209a92ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad725b9adf7aec4dc6bc11e925973dc87" id="r_ad725b9adf7aec4dc6bc11e925973dc87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad725b9adf7aec4dc6bc11e925973dc87">SplitAroundGivenValue</a> (IntegerVariable var, IntegerValue value, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ad725b9adf7aec4dc6bc11e925973dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5154a61154ff9b3522e0c0eba7ed0319" id="r_a5154a61154ff9b3522e0c0eba7ed0319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5154a61154ff9b3522e0c0eba7ed0319">SplitAroundLpValue</a> (IntegerVariable var, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a5154a61154ff9b3522e0c0eba7ed0319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a25d47a029efe205efbc015f7c7e7c" id="r_ac4a25d47a029efe205efbc015f7c7e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4a25d47a029efe205efbc015f7c7e7c">SplitUsingBestSolutionValueInRepository</a> (IntegerVariable var, const <a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html">SharedSolutionRepository</a>&lt; int64_t &gt; &amp;solution_repo, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ac4a25d47a029efe205efbc015f7c7e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a1d7fdb9ee5a88b771b2965bf18596" id="r_a28a1d7fdb9ee5a88b771b2965bf18596"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a1d7fdb9ee5a88b771b2965bf18596">FirstUnassignedVarAtItsMinHeuristic</a> (absl::Span&lt; const IntegerVariable &gt; vars, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a28a1d7fdb9ee5a88b771b2965bf18596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af302dfe77be22de2fdecf4d3fa3e42be" id="r_af302dfe77be22de2fdecf4d3fa3e42be"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af302dfe77be22de2fdecf4d3fa3e42be">MostFractionalHeuristic</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:af302dfe77be22de2fdecf4d3fa3e42be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the variable with most fractional LP value.  <br /></td></tr>
<tr class="separator:af302dfe77be22de2fdecf4d3fa3e42be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417435f5c8fe96aa65045dd286a33503" id="r_a417435f5c8fe96aa65045dd286a33503"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a417435f5c8fe96aa65045dd286a33503">BoolPseudoCostHeuristic</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a417435f5c8fe96aa65045dd286a33503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ec04c047ef7bfe5cfa06c17ff0c76d" id="r_ae9ec04c047ef7bfe5cfa06c17ff0c76d"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ec04c047ef7bfe5cfa06c17ff0c76d">LpPseudoCostHeuristic</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ae9ec04c047ef7bfe5cfa06c17ff0c76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c23af10324a7d8e255e789fa0e2eb15" id="r_a5c23af10324a7d8e255e789fa0e2eb15"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c23af10324a7d8e255e789fa0e2eb15">UnassignedVarWithLowestMinAtItsMinHeuristic</a> (absl::Span&lt; const IntegerVariable &gt; vars, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a5c23af10324a7d8e255e789fa0e2eb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af804e16573254d0396f897b201736f6a" id="r_af804e16573254d0396f897b201736f6a"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af804e16573254d0396f897b201736f6a">SequentialSearch</a> (std::vector&lt; std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &gt; heuristics)</td></tr>
<tr class="separator:af804e16573254d0396f897b201736f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4accab74442b986ddcc870636b232756" id="r_a4accab74442b986ddcc870636b232756"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4accab74442b986ddcc870636b232756">SequentialValueSelection</a> (std::vector&lt; std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>(IntegerVariable)&gt; &gt; value_selection_heuristics, std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; var_selection_heuristic, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a4accab74442b986ddcc870636b232756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8088e9f55c5b4430a04da7e3367f32d" id="r_ac8088e9f55c5b4430a04da7e3367f32d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8088e9f55c5b4430a04da7e3367f32d">LinearizedPartIsLarge</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ac8088e9f55c5b4430a04da7e3367f32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8e9410f7631560e2efea8f401e5aa1" id="r_a4f8e9410f7631560e2efea8f401e5aa1"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f8e9410f7631560e2efea8f401e5aa1">IntegerValueSelectionHeuristic</a> (std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; var_selection_heuristic, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a4f8e9410f7631560e2efea8f401e5aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddc23780eb0fa31082a04cc6e345d31" id="r_aaddc23780eb0fa31082a04cc6e345d31"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaddc23780eb0fa31082a04cc6e345d31">SatSolverHeuristic</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:aaddc23780eb0fa31082a04cc6e345d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a> advised by the underlying SAT solver.  <br /></td></tr>
<tr class="separator:aaddc23780eb0fa31082a04cc6e345d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfc95b7fb811709c6763963bee970a4" id="r_a4bfc95b7fb811709c6763963bee970a4"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bfc95b7fb811709c6763963bee970a4">ShaveObjectiveLb</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a4bfc95b7fb811709c6763963bee970a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb3adbf30215f4aafac3f24caf00f84" id="r_a7bb3adbf30215f4aafac3f24caf00f84"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb3adbf30215f4aafac3f24caf00f84">PseudoCost</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a7bb3adbf30215f4aafac3f24caf00f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b41013bb2f7709a99765d5c491f381" id="r_a85b41013bb2f7709a99765d5c491f381"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85b41013bb2f7709a99765d5c491f381">SchedulingSearchHeuristic</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a85b41013bb2f7709a99765d5c491f381"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple heuristic for scheduling models.  <br /></td></tr>
<tr class="separator:a85b41013bb2f7709a99765d5c491f381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33798fe85208035f149a5c124b89b7b4" id="r_a33798fe85208035f149a5c124b89b7b4"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33798fe85208035f149a5c124b89b7b4">DisjunctivePrecedenceSearchHeuristic</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a33798fe85208035f149a5c124b89b7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af421daf12e0e45a0bb3cc7655cd443cc" id="r_af421daf12e0e45a0bb3cc7655cd443cc"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af421daf12e0e45a0bb3cc7655cd443cc">CumulativePrecedenceSearchHeuristic</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:af421daf12e0e45a0bb3cc7655cd443cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b9ed2c9fd55af7cfd4effe1ad5a5d6" id="r_ac2b9ed2c9fd55af7cfd4effe1ad5a5d6"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2b9ed2c9fd55af7cfd4effe1ad5a5d6">RandomizeOnRestartHeuristic</a> (bool lns_mode, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ac2b9ed2c9fd55af7cfd4effe1ad5a5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac679551eb33dd7fd5168a8d0ab74c82c" id="r_ac679551eb33dd7fd5168a8d0ab74c82c"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac679551eb33dd7fd5168a8d0ab74c82c">FollowHint</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerVariable.html">BooleanOrIntegerVariable</a> &gt; vars, absl::Span&lt; const IntegerValue &gt; values, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ac679551eb33dd7fd5168a8d0ab74c82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed30948924c0d2d512eec06d24353f" id="r_ab2ed30948924c0d2d512eec06d24353f"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ed30948924c0d2d512eec06d24353f">RestartEveryKFailures</a> (int k, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="memdesc:ab2ed30948924c0d2d512eec06d24353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A restart policy that restarts every k failures.  <br /></td></tr>
<tr class="separator:ab2ed30948924c0d2d512eec06d24353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae838746224cfa12487aab4a0d10aa3ce" id="r_ae838746224cfa12487aab4a0d10aa3ce"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae838746224cfa12487aab4a0d10aa3ce">SatSolverRestartPolicy</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:ae838746224cfa12487aab4a0d10aa3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">A restart policy that uses the underlying sat solver's policy.  <br /></td></tr>
<tr class="separator:ae838746224cfa12487aab4a0d10aa3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ac4c44a4524b21806a1ae9839bc5bd" id="r_a08ac4c44a4524b21806a1ae9839bc5bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08ac4c44a4524b21806a1ae9839bc5bd">ConfigureSearchHeuristics</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a08ac4c44a4524b21806a1ae9839bc5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37db01bf814ae23bd4a029c9cee80992" id="r_a37db01bf814ae23bd4a029c9cee80992"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37db01bf814ae23bd4a029c9cee80992">CompleteHeuristics</a> (absl::Span&lt; const std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &gt; incomplete_heuristics, const std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &amp;completion_heuristic)</td></tr>
<tr class="separator:a37db01bf814ae23bd4a029c9cee80992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ce3f7172b49fd16513489bdb4ca32" id="r_ade6ce3f7172b49fd16513489bdb4ca32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade6ce3f7172b49fd16513489bdb4ca32">ResetAndSolveIntegerProblem</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;assumptions, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ade6ce3f7172b49fd16513489bdb4ca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d12c07dbcc1ac097e51359ac299aea" id="r_a78d12c07dbcc1ac097e51359ac299aea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78d12c07dbcc1ac097e51359ac299aea">SolveIntegerProblemWithLazyEncoding</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a78d12c07dbcc1ac097e51359ac299aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872297a32bd1f4a91bbcebd1c47b3751" id="r_a872297a32bd1f4a91bbcebd1c47b3751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a872297a32bd1f4a91bbcebd1c47b3751">SplitDomainUsingBestSolutionValue</a> (IntegerVariable var, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a872297a32bd1f4a91bbcebd1c47b3751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba58497e1b2f2b732475d5796dbbbce6" id="r_aba58497e1b2f2b732475d5796dbbbce6"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba58497e1b2f2b732475d5796dbbbce6">MinSize</a> (IntervalVariable v)</td></tr>
<tr class="separator:aba58497e1b2f2b732475d5796dbbbce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c78f247ab4f6f3851944098fd5b1b8c" id="r_a0c78f247ab4f6f3851944098fd5b1b8c"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c78f247ab4f6f3851944098fd5b1b8c">MaxSize</a> (IntervalVariable v)</td></tr>
<tr class="separator:a0c78f247ab4f6f3851944098fd5b1b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66328f1be79a54762cba9067ad806cc" id="r_ad66328f1be79a54762cba9067ad806cc"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad66328f1be79a54762cba9067ad806cc">IsOptional</a> (IntervalVariable v)</td></tr>
<tr class="separator:ad66328f1be79a54762cba9067ad806cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9cdbedf84c94259e56684fd18eab1b" id="r_a1f9cdbedf84c94259e56684fd18eab1b"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f9cdbedf84c94259e56684fd18eab1b">IsPresentLiteral</a> (IntervalVariable v)</td></tr>
<tr class="separator:a1f9cdbedf84c94259e56684fd18eab1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507bc1fac620b6d08f573ae738141bd9" id="r_a507bc1fac620b6d08f573ae738141bd9"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a507bc1fac620b6d08f573ae738141bd9">NewInterval</a> (int64_t min_start, int64_t max_end, int64_t size)</td></tr>
<tr class="separator:a507bc1fac620b6d08f573ae738141bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4ffaa0c34c37b593d23503c35eaa5" id="r_a10d4ffaa0c34c37b593d23503c35eaa5"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10d4ffaa0c34c37b593d23503c35eaa5">NewInterval</a> (IntegerVariable start, IntegerVariable end, IntegerVariable size)</td></tr>
<tr class="separator:a10d4ffaa0c34c37b593d23503c35eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414c2de7ad2f1703693fab810bc4f197" id="r_a414c2de7ad2f1703693fab810bc4f197"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a414c2de7ad2f1703693fab810bc4f197">NewIntervalWithVariableSize</a> (int64_t min_start, int64_t max_end, int64_t min_size, int64_t max_size)</td></tr>
<tr class="separator:a414c2de7ad2f1703693fab810bc4f197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca9c8d3f9284a57a274895d29add611" id="r_a7ca9c8d3f9284a57a274895d29add611"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca9c8d3f9284a57a274895d29add611">NewOptionalInterval</a> (int64_t min_start, int64_t max_end, int64_t size, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> is_present)</td></tr>
<tr class="separator:a7ca9c8d3f9284a57a274895d29add611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d43a4a505cac54beae16c1a91ee3ca" id="r_a62d43a4a505cac54beae16c1a91ee3ca"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62d43a4a505cac54beae16c1a91ee3ca">NewOptionalInterval</a> (IntegerVariable start, IntegerVariable end, IntegerVariable size, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> is_present)</td></tr>
<tr class="separator:a62d43a4a505cac54beae16c1a91ee3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e864568827fc45afc655a9967d5f6c" id="r_a13e864568827fc45afc655a9967d5f6c"><td class="memItemLeft" align="right" valign="top">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13e864568827fc45afc655a9967d5f6c">NewOptionalIntervalWithVariableSize</a> (int64_t min_start, int64_t max_end, int64_t min_size, int64_t max_size, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> is_present)</td></tr>
<tr class="separator:a13e864568827fc45afc655a9967d5f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82da37638ef0ea4f3caa6c2fceb22b09" id="r_a82da37638ef0ea4f3caa6c2fceb22b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82da37638ef0ea4f3caa6c2fceb22b09">AppendVariablesFromCapacityAndDemands</a> (const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands_helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, std::vector&lt; IntegerVariable &gt; *vars)</td></tr>
<tr class="separator:a82da37638ef0ea4f3caa6c2fceb22b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03415c6fcb9dedc9b88bb92ae45b46a8" id="r_a03415c6fcb9dedc9b88bb92ae45b46a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03415c6fcb9dedc9b88bb92ae45b46a8">ComputeActivity</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;constraint, const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;values)</td></tr>
<tr class="separator:a03415c6fcb9dedc9b88bb92ae45b46a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268155d48da53ccd81c49ee890c8e75f" id="r_a268155d48da53ccd81c49ee890c8e75f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a268155d48da53ccd81c49ee890c8e75f">ComputeL2Norm</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;constraint)</td></tr>
<tr class="memdesc:a268155d48da53ccd81c49ee890c8e75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sqrt(sum square(coeff)).  <br /></td></tr>
<tr class="separator:a268155d48da53ccd81c49ee890c8e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be9ba98c31d692caf42401992a0b4c3" id="r_a3be9ba98c31d692caf42401992a0b4c3"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be9ba98c31d692caf42401992a0b4c3">ComputeInfinityNorm</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;constraint)</td></tr>
<tr class="memdesc:a3be9ba98c31d692caf42401992a0b4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum absolute value of the coefficients.  <br /></td></tr>
<tr class="separator:a3be9ba98c31d692caf42401992a0b4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb476403c2ecaebf0c38e03a0e770c40" id="r_afb476403c2ecaebf0c38e03a0e770c40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb476403c2ecaebf0c38e03a0e770c40">ScalarProduct</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;ct1, const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;ct2)</td></tr>
<tr class="separator:afb476403c2ecaebf0c38e03a0e770c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0ece2fd7a5f1c4ff26f8caade0d798" id="r_a0f0ece2fd7a5f1c4ff26f8caade0d798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f0ece2fd7a5f1c4ff26f8caade0d798">DivideByGCD</a> (<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *constraint)</td></tr>
<tr class="separator:a0f0ece2fd7a5f1c4ff26f8caade0d798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a88781ba518fe1373e2bbe36aeb8132" id="r_a3a88781ba518fe1373e2bbe36aeb8132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a88781ba518fe1373e2bbe36aeb8132">RemoveZeroTerms</a> (<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *constraint)</td></tr>
<tr class="memdesc:a3a88781ba518fe1373e2bbe36aeb8132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entries with a coefficient of zero.  <br /></td></tr>
<tr class="separator:a3a88781ba518fe1373e2bbe36aeb8132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7265fc0e5f5f1ad098805c5029a82fc0" id="r_a7265fc0e5f5f1ad098805c5029a82fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7265fc0e5f5f1ad098805c5029a82fc0">MakeAllCoefficientsPositive</a> (<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *constraint)</td></tr>
<tr class="memdesc:a7265fc0e5f5f1ad098805c5029a82fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes all coefficients positive by transforming a variable to its negation.  <br /></td></tr>
<tr class="separator:a7265fc0e5f5f1ad098805c5029a82fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad094633975889f2d6cc0f93a91355528" id="r_ad094633975889f2d6cc0f93a91355528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad094633975889f2d6cc0f93a91355528">MakeAllVariablesPositive</a> (<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *constraint)</td></tr>
<tr class="memdesc:ad094633975889f2d6cc0f93a91355528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes all variables "positive" by transforming a variable to its negation.  <br /></td></tr>
<tr class="separator:ad094633975889f2d6cc0f93a91355528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbad520b0fd87f997fd2de7eeff9e848" id="r_adbad520b0fd87f997fd2de7eeff9e848"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbad520b0fd87f997fd2de7eeff9e848">NoDuplicateVariable</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;ct)</td></tr>
<tr class="memdesc:adbad520b0fd87f997fd2de7eeff9e848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if duplicate variables are found in ct.  <br /></td></tr>
<tr class="separator:adbad520b0fd87f997fd2de7eeff9e848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83443be9bcc967eec871d47ead6bfb73" id="r_a83443be9bcc967eec871d47ead6bfb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83443be9bcc967eec871d47ead6bfb73">CanonicalizeExpr</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;expr)</td></tr>
<tr class="separator:a83443be9bcc967eec871d47ead6bfb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad582c9543b77917ac1084bbfda601f5e" id="r_ad582c9543b77917ac1084bbfda601f5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad582c9543b77917ac1084bbfda601f5e">ValidateLinearConstraintForOverflow</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;constraint, const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;integer_trail)</td></tr>
<tr class="separator:ad582c9543b77917ac1084bbfda601f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64e33318b5b09f0c9008950d29a0a7e" id="r_ac64e33318b5b09f0c9008950d29a0a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac64e33318b5b09f0c9008950d29a0a7e">NegationOf</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;expr)</td></tr>
<tr class="memdesc:ac64e33318b5b09f0c9008950d29a0a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preserves canonicality.  <br /></td></tr>
<tr class="separator:ac64e33318b5b09f0c9008950d29a0a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f5fc24892786308e339b0865309580" id="r_ac1f5fc24892786308e339b0865309580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f5fc24892786308e339b0865309580">PositiveVarExpr</a> (const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;expr)</td></tr>
<tr class="memdesc:ac1f5fc24892786308e339b0865309580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the same expression with positive variables.  <br /></td></tr>
<tr class="separator:ac1f5fc24892786308e339b0865309580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc41fb817d6b7c21672487bb6d451170" id="r_acc41fb817d6b7c21672487bb6d451170"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc41fb817d6b7c21672487bb6d451170">GetCoefficient</a> (const IntegerVariable var, const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;expr)</td></tr>
<tr class="separator:acc41fb817d6b7c21672487bb6d451170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cb284d48d84c21b02978fca95825c0" id="r_ad4cb284d48d84c21b02978fca95825c0"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4cb284d48d84c21b02978fca95825c0">GetCoefficientOfPositiveVar</a> (const IntegerVariable var, const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;expr)</td></tr>
<tr class="separator:ad4cb284d48d84c21b02978fca95825c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62555e26e4185c3c441e9222914b4186" id="r_a62555e26e4185c3c441e9222914b4186"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62555e26e4185c3c441e9222914b4186">PossibleOverflow</a> (const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;integer_trail, const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;constraint)</td></tr>
<tr class="separator:a62555e26e4185c3c441e9222914b4186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff9b7f7a0e15c369487e0c089dba1a2" id="r_a9ff9b7f7a0e15c369487e0c089dba1a2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff9b7f7a0e15c369487e0c089dba1a2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;ct)</td></tr>
<tr class="separator:a9ff9b7f7a0e15c369487e0c089dba1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dda16556ea20503fe019addd42f605" id="r_a71dda16556ea20503fe019addd42f605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71dda16556ea20503fe019addd42f605">CleanTermsAndFillConstraint</a> (std::vector&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; *terms, <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> *output)</td></tr>
<tr class="separator:a71dda16556ea20503fe019addd42f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8b9aa5e8f896a552de39960a007b86" id="r_a9a8b9aa5e8f896a552de39960a007b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a8b9aa5e8f896a552de39960a007b86">CleanTermsAndFillConstraint</a> (std::vector&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; *terms, <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *output)</td></tr>
<tr class="separator:a9a8b9aa5e8f896a552de39960a007b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887f6ed27a01ab3f1e1e9a7e93bd6624" id="r_a887f6ed27a01ab3f1e1e9a7e93bd6624"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887f6ed27a01ab3f1e1e9a7e93bd6624">MergePositiveVariableTermsAndCheckForOverflow</a> (std::vector&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; *terms, <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *output)</td></tr>
<tr class="separator:a887f6ed27a01ab3f1e1e9a7e93bd6624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf9d9d5996eef7d0e67d446d906bad5" id="r_a2cf9d9d5996eef7d0e67d446d906bad5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cf9d9d5996eef7d0e67d446d906bad5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="#aa4a62b204187763884e737d2f51aad8a">EnforcementStatus</a> &amp;e)</td></tr>
<tr class="separator:a2cf9d9d5996eef7d0e67d446d906bad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ed833632a191f0950ce1f9e80a9ccd" id="r_aa6ed833632a191f0950ce1f9e80a9ccd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6ed833632a191f0950ce1f9e80a9ccd">DEFINE_STRONG_INDEX_TYPE</a> (EnforcementId)</td></tr>
<tr class="separator:aa6ed833632a191f0950ce1f9e80a9ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a1aaff5bb36f1dfaf3daea8d5a076e" id="r_af8a1aaff5bb36f1dfaf3daea8d5a076e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8a1aaff5bb36f1dfaf3daea8d5a076e">AppendRelaxationForEqualityEncoding</a> (IntegerVariable var, const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation, int *num_tight, int *num_loose)</td></tr>
<tr class="separator:af8a1aaff5bb36f1dfaf3daea8d5a076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9cc392315b2fc7a18a373f496fe2b4" id="r_a7a9cc392315b2fc7a18a373f496fe2b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a9cc392315b2fc7a18a373f496fe2b4">AppendPartialGreaterThanEncodingRelaxation</a> (IntegerVariable var, const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a7a9cc392315b2fc7a18a373f496fe2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37670be970e606ec82f0b4bf5087f68" id="r_af37670be970e606ec82f0b4bf5087f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af37670be970e606ec82f0b4bf5087f68">AppendBoolOrRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:af37670be970e606ec82f0b4bf5087f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac506719ca656893d93a2a6c940999265" id="r_ac506719ca656893d93a2a6c940999265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac506719ca656893d93a2a6c940999265">AppendBoolAndRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation, <a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a> *activity_helper)</td></tr>
<tr class="separator:ac506719ca656893d93a2a6c940999265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad309491270e74f942fb302a8159eac96" id="r_ad309491270e74f942fb302a8159eac96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad309491270e74f942fb302a8159eac96">AppendAtMostOneRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:ad309491270e74f942fb302a8159eac96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d9be5c1f94fcd416e5f582a8581789" id="r_a12d9be5c1f94fcd416e5f582a8581789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12d9be5c1f94fcd416e5f582a8581789">AppendExactlyOneRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a12d9be5c1f94fcd416e5f582a8581789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fd4466b012022bab0c5c1839c77890" id="r_ae3fd4466b012022bab0c5c1839c77890"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3fd4466b012022bab0c5c1839c77890">CreateAlternativeLiteralsWithView</a> (int num_literals, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:ae3fd4466b012022bab0c5c1839c77890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a4bad5ce59206034ac6d535f65e30f" id="r_a96a4bad5ce59206034ac6d535f65e30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a4bad5ce59206034ac6d535f65e30f">AppendCircuitRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="memdesc:a96a4bad5ce59206034ac6d535f65e30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routing relaxation and cut generators.  <br /></td></tr>
<tr class="separator:a96a4bad5ce59206034ac6d535f65e30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f1824d3cc82601b5f801b74817b734" id="r_a22f1824d3cc82601b5f801b74817b734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f1824d3cc82601b5f801b74817b734">AppendRoutesRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a22f1824d3cc82601b5f801b74817b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b27558e7f0de02ffe3b7ff5929423f" id="r_a31b27558e7f0de02ffe3b7ff5929423f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31b27558e7f0de02ffe3b7ff5929423f">AddCircuitCutGenerator</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a31b27558e7f0de02ffe3b7ff5929423f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54db560e2cc153bb0ebc331f4e06ff97" id="r_a54db560e2cc153bb0ebc331f4e06ff97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54db560e2cc153bb0ebc331f4e06ff97">AddRoutesCutGenerator</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a54db560e2cc153bb0ebc331f4e06ff97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a4aa8393ef1f42790017ac2ef3d0e" id="r_a175a4aa8393ef1f42790017ac2ef3d0e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a175a4aa8393ef1f42790017ac2ef3d0e">DetectMakespan</a> (absl::Span&lt; const IntervalVariable &gt; intervals, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; demands, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a175a4aa8393ef1f42790017ac2ef3d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f93f235ccfb4d327b3e8ed40e43e3b" id="r_a04f93f235ccfb4d327b3e8ed40e43e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f93f235ccfb4d327b3e8ed40e43e3b">AppendNoOverlapRelaxationAndCutGenerator</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a04f93f235ccfb4d327b3e8ed40e43e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a55eff323f285ad2bc39449ca4623ae" id="r_a0a55eff323f285ad2bc39449ca4623ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a55eff323f285ad2bc39449ca4623ae">AppendCumulativeRelaxationAndCutGenerator</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a0a55eff323f285ad2bc39449ca4623ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799cf49d8b3bb7f3ede756a639e6662c" id="r_a799cf49d8b3bb7f3ede756a639e6662c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a799cf49d8b3bb7f3ede756a639e6662c">AddCumulativeRelaxation</a> (const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands, const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;makespan, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="memdesc:a799cf49d8b3bb7f3ede756a639e6662c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling relaxations and cut generators.  <br /></td></tr>
<tr class="separator:a799cf49d8b3bb7f3ede756a639e6662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e74cc2980a61d204f2d57d0add635de" id="r_a9e74cc2980a61d204f2d57d0add635de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e74cc2980a61d204f2d57d0add635de">AppendNoOverlap2dRelaxationForComponent</a> (absl::Span&lt; const int &gt; component, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *no_overlap_helper, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager, <a class="el" href="classoperations__research_1_1sat_1_1ProductDecomposer.html">ProductDecomposer</a> *product_decomposer)</td></tr>
<tr class="separator:a9e74cc2980a61d204f2d57d0add635de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdadae230cef47ac321c22a5a880a85f" id="r_acdadae230cef47ac321c22a5a880a85f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdadae230cef47ac321c22a5a880a85f">AppendNoOverlap2dRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="memdesc:acdadae230cef47ac321c22a5a880a85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the energetic relaxation sum(areas) &lt;= bounding box area.  <br /></td></tr>
<tr class="separator:acdadae230cef47ac321c22a5a880a85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87160f650c0f35013f055fb81b3dfd30" id="r_a87160f650c0f35013f055fb81b3dfd30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87160f650c0f35013f055fb81b3dfd30">AppendLinMaxRelaxationPart1</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a87160f650c0f35013f055fb81b3dfd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d126152f7618c43746d3f56577b803e" id="r_a9d126152f7618c43746d3f56577b803e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d126152f7618c43746d3f56577b803e">AppendMaxAffineRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a9d126152f7618c43746d3f56577b803e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e13273db243ecd0a444852de48bd929" id="r_a2e13273db243ecd0a444852de48bd929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e13273db243ecd0a444852de48bd929">AddMaxAffineCutGenerator</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a2e13273db243ecd0a444852de48bd929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2184e325fd181f15124aa91c55fb0159" id="r_a2184e325fd181f15124aa91c55fb0159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2184e325fd181f15124aa91c55fb0159">AppendLinMaxRelaxationPart2</a> (IntegerVariable target, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; alternative_literals, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt; exprs, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a2184e325fd181f15124aa91c55fb0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d3ac4927f1adbca821091239fc06c7" id="r_a42d3ac4927f1adbca821091239fc06c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42d3ac4927f1adbca821091239fc06c7">AppendLinearConstraintRelaxation</a> (const ConstraintProto &amp;ct, bool linearize_enforced_constraints, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation, <a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a> *activity_helper)</td></tr>
<tr class="separator:a42d3ac4927f1adbca821091239fc06c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e710c5266505c51982912036c840755" id="r_a7e710c5266505c51982912036c840755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e710c5266505c51982912036c840755">TryToLinearizeConstraint</a> (const CpModelProto &amp;model_proto, const ConstraintProto &amp;ct, int linearization_level, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation, <a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a> *helper=nullptr)</td></tr>
<tr class="memdesc:a7e710c5266505c51982912036c840755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linearization of different types of constraints.  <br /></td></tr>
<tr class="separator:a7e710c5266505c51982912036c840755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcd5302962cdb3bacde2ad477e5a187" id="r_a4dcd5302962cdb3bacde2ad477e5a187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dcd5302962cdb3bacde2ad477e5a187">AddIntProdCutGenerator</a> (const ConstraintProto &amp;ct, int linearization_level, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="memdesc:a4dcd5302962cdb3bacde2ad477e5a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cut generators.  <br /></td></tr>
<tr class="separator:a4dcd5302962cdb3bacde2ad477e5a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd42a035a99f910066d0a0356eff9ed6" id="r_abd42a035a99f910066d0a0356eff9ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd42a035a99f910066d0a0356eff9ed6">AppendSquareRelaxation</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:abd42a035a99f910066d0a0356eff9ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4310ba75873366ba7995ff9a669628" id="r_a0f4310ba75873366ba7995ff9a669628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f4310ba75873366ba7995ff9a669628">AddSquareCutGenerator</a> (const ConstraintProto &amp;ct, int linearization_level, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a0f4310ba75873366ba7995ff9a669628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4059e332187f15cc9dae9d2fd5ae48" id="r_aca4059e332187f15cc9dae9d2fd5ae48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca4059e332187f15cc9dae9d2fd5ae48">AddAllDiffRelaxationAndCutGenerator</a> (const ConstraintProto &amp;ct, int linearization_level, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:aca4059e332187f15cc9dae9d2fd5ae48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc92e600d7a70f5525d8c2998008a136" id="r_abc92e600d7a70f5525d8c2998008a136"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc92e600d7a70f5525d8c2998008a136">IntervalIsVariable</a> (const IntervalVariable interval, <a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html">IntervalsRepository</a> *intervals_repository)</td></tr>
<tr class="separator:abc92e600d7a70f5525d8c2998008a136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d332fb3ba7ede461acce753a5ea568" id="r_a20d332fb3ba7ede461acce753a5ea568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20d332fb3ba7ede461acce753a5ea568">AddCumulativeCutGenerator</a> (const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands_helper, const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;makespan, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a20d332fb3ba7ede461acce753a5ea568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad768da30abda81f190eb895f7a5d01e8" id="r_ad768da30abda81f190eb895f7a5d01e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad768da30abda81f190eb895f7a5d01e8">AddNoOverlapCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;makespan, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:ad768da30abda81f190eb895f7a5d01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfe32d132bfd8ab3a12b34d6fefcfe7" id="r_addfe32d132bfd8ab3a12b34d6fefcfe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addfe32d132bfd8ab3a12b34d6fefcfe7">AddNoOverlap2dCutGenerator</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:addfe32d132bfd8ab3a12b34d6fefcfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0e8ef0b1ad01ad3a9aae0a009e5f13" id="r_abf0e8ef0b1ad01ad3a9aae0a009e5f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf0e8ef0b1ad01ad3a9aae0a009e5f13">AddLinMaxCutGenerator</a> (const ConstraintProto &amp;ct, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:abf0e8ef0b1ad01ad3a9aae0a009e5f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c02b5f23ff755783f84c851f8dcbb2" id="r_a99c02b5f23ff755783f84c851f8dcbb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99c02b5f23ff755783f84c851f8dcbb2">AppendElementEncodingRelaxation</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m, <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *relaxation)</td></tr>
<tr class="separator:a99c02b5f23ff755783f84c851f8dcbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cc8829256ea003a3f538b06d3a3a74" id="r_a34cc8829256ea003a3f538b06d3a3a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34cc8829256ea003a3f538b06d3a3a74">ComputeLinearRelaxation</a> (const CpModelProto &amp;model_proto, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="memdesc:a34cc8829256ea003a3f538b06d3a3a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the linear relaxation of a CpModelProto.  <br /></td></tr>
<tr class="separator:a34cc8829256ea003a3f538b06d3a3a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d384c7c56f3027894875278e4b9526" id="r_ad6d384c7c56f3027894875278e4b9526"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6d384c7c56f3027894875278e4b9526">ScaleContinuousVariables</a> (double scaling, double max_bound, MPModelProto *mp_model)</td></tr>
<tr class="separator:ad6d384c7c56f3027894875278e4b9526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa3c7d5ae90dfbcdf080ee3cefbedda" id="r_a2fa3c7d5ae90dfbcdf080ee3cefbedda"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fa3c7d5ae90dfbcdf080ee3cefbedda">FindRationalFactor</a> (double x, int64_t limit, double tolerance)</td></tr>
<tr class="separator:a2fa3c7d5ae90dfbcdf080ee3cefbedda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416207a1e2a7eb94bd6c36442802ed96" id="r_a416207a1e2a7eb94bd6c36442802ed96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a416207a1e2a7eb94bd6c36442802ed96">MakeBoundsOfIntegerVariablesInteger</a> (const SatParameters &amp;params, MPModelProto *mp_model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a416207a1e2a7eb94bd6c36442802ed96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e72e8b29637efc57d3d9489078a5748" id="r_a5e72e8b29637efc57d3d9489078a5748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e72e8b29637efc57d3d9489078a5748">ChangeLargeBoundsToInfinity</a> (double max_magnitude, MPModelProto *mp_model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a5e72e8b29637efc57d3d9489078a5748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8d6bd2036aaa59c3719954e5262c5a" id="r_a7d8d6bd2036aaa59c3719954e5262c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d8d6bd2036aaa59c3719954e5262c5a">RemoveNearZeroTerms</a> (const SatParameters &amp;params, MPModelProto *mp_model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a7d8d6bd2036aaa59c3719954e5262c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63eebc797e29eb26229f5787cdf5212" id="r_af63eebc797e29eb26229f5787cdf5212"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af63eebc797e29eb26229f5787cdf5212">MPModelProtoValidationBeforeConversion</a> (const SatParameters &amp;params, const MPModelProto &amp;mp_model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:af63eebc797e29eb26229f5787cdf5212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753e3aea07903c667891eb57036d26de" id="r_a753e3aea07903c667891eb57036d26de"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a753e3aea07903c667891eb57036d26de">DetectImpliedIntegers</a> (MPModelProto *mp_model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a753e3aea07903c667891eb57036d26de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f79d28fdcdb115fb186792a0c215540" id="r_a0f79d28fdcdb115fb186792a0c215540"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f79d28fdcdb115fb186792a0c215540">FindBestScalingAndComputeErrors</a> (absl::Span&lt; const double &gt; coefficients, absl::Span&lt; const double &gt; lower_bounds, absl::Span&lt; const double &gt; upper_bounds, int64_t max_absolute_activity, double wanted_absolute_activity_precision, double *relative_coeff_error, double *scaled_sum_error)</td></tr>
<tr class="separator:a0f79d28fdcdb115fb186792a0c215540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d32bfb7e130364f3dd94087b686b6f5" id="r_a2d32bfb7e130364f3dd94087b686b6f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d32bfb7e130364f3dd94087b686b6f5">ConvertMPModelProtoToCpModelProto</a> (const SatParameters &amp;params, const MPModelProto &amp;mp_model, CpModelProto *cp_model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a2d32bfb7e130364f3dd94087b686b6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c41d8a7687386839ef94182e3badb9" id="r_ac9c41d8a7687386839ef94182e3badb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9c41d8a7687386839ef94182e3badb9">ConvertCpModelProtoToMPModelProto</a> (const CpModelProto &amp;<a class="el" href="parser_8yy_8cc.html#a5a634cf4429798b1c921a81de8250051">input</a>, MPModelProto *output)</td></tr>
<tr class="separator:ac9c41d8a7687386839ef94182e3badb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628fdf755d7e7ca380fce027615b10dc" id="r_a628fdf755d7e7ca380fce027615b10dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a628fdf755d7e7ca380fce027615b10dc">ScaleAndSetObjective</a> (const SatParameters &amp;params, absl::Span&lt; const std::pair&lt; int, double &gt; &gt; objective, double objective_offset, bool maximize, CpModelProto *cp_model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a628fdf755d7e7ca380fce027615b10dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97f36cf2700f25a17eb5f3370df6b11" id="r_aa97f36cf2700f25a17eb5f3370df6b11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa97f36cf2700f25a17eb5f3370df6b11">ConvertBinaryMPModelProtoToBooleanProblem</a> (const MPModelProto &amp;mp_model, LinearBooleanProblem *problem)</td></tr>
<tr class="separator:aa97f36cf2700f25a17eb5f3370df6b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3813521303490a81cc8585dc4dc13daa" id="r_a3813521303490a81cc8585dc4dc13daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3813521303490a81cc8585dc4dc13daa">ConvertBooleanProblemToLinearProgram</a> (const LinearBooleanProblem &amp;problem, <a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html">glop::LinearProgram</a> *lp)</td></tr>
<tr class="memdesc:a3813521303490a81cc8585dc4dc13daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Boolean optimization problem to its lp formulation.  <br /></td></tr>
<tr class="separator:a3813521303490a81cc8585dc4dc13daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47959359a009b02531ab19f206cdd54" id="r_ac47959359a009b02531ab19f206cdd54"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac47959359a009b02531ab19f206cdd54">ComputeTrueObjectiveLowerBound</a> (const CpModelProto &amp;model_proto_with_floating_point_objective, const CpObjectiveProto &amp;integer_objective, const int64_t inner_integer_objective_lower_bound)</td></tr>
<tr class="separator:ac47959359a009b02531ab19f206cdd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6ba15542ec5d59958de53c92279b2a" id="r_a4d6ba15542ec5d59958de53c92279b2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d6ba15542ec5d59958de53c92279b2a">MinimizeCoreWithPropagation</a> (<a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *limit, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *core)</td></tr>
<tr class="separator:a4d6ba15542ec5d59958de53c92279b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ad40efdac4d337987b0ca306aa7bd6" id="r_a56ad40efdac4d337987b0ca306aa7bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56ad40efdac4d337987b0ca306aa7bd6">MinimizeCoreWithSearch</a> (<a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *limit, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *core)</td></tr>
<tr class="separator:a56ad40efdac4d337987b0ca306aa7bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f7eb19b1030f3da667a3914c7ba666" id="r_a98f7eb19b1030f3da667a3914c7ba666"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98f7eb19b1030f3da667a3914c7ba666">ProbeLiteral</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> assumption, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver)</td></tr>
<tr class="separator:a98f7eb19b1030f3da667a3914c7ba666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546e46146833c0fe056cccbbdc65fb11" id="r_a546e46146833c0fe056cccbbdc65fb11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a546e46146833c0fe056cccbbdc65fb11">FilterAssignedLiteral</a> (const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp;assignment, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *core)</td></tr>
<tr class="memdesc:a546e46146833c0fe056cccbbdc65fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">A core cannot be all true.  <br /></td></tr>
<tr class="separator:a546e46146833c0fe056cccbbdc65fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab231dff94744f73429364e7180b1397f" id="r_ab231dff94744f73429364e7180b1397f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab231dff94744f73429364e7180b1397f">MinimizeIntegerVariableWithLinearScanAndLazyEncoding</a> (IntegerVariable objective_var, const std::function&lt; void()&gt; &amp;feasible_solution_observer, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ab231dff94744f73429364e7180b1397f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed01516ad5ceb238e62df4fdebfb054e" id="r_aed01516ad5ceb238e62df4fdebfb054e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed01516ad5ceb238e62df4fdebfb054e">RestrictObjectiveDomainWithBinarySearch</a> (IntegerVariable objective_var, const std::function&lt; void()&gt; &amp;feasible_solution_observer, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:aed01516ad5ceb238e62df4fdebfb054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3e424a9963561cbd837b7a293b416e" id="r_a7a3e424a9963561cbd837b7a293b416e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a3e424a9963561cbd837b7a293b416e">PresolveBooleanLinearExpression</a> (std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *literals, std::vector&lt; Coefficient &gt; *coefficients, Coefficient *offset)</td></tr>
<tr class="separator:a7a3e424a9963561cbd837b7a293b416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f1b6bbf960239725bec385f09a5b14" id="r_a80f1b6bbf960239725bec385f09a5b14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80f1b6bbf960239725bec385f09a5b14">ValidateParameters</a> (const SatParameters &amp;params)</td></tr>
<tr class="separator:a80f1b6bbf960239725bec385f09a5b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0ad26c40a4024f160695f2a504ff0a" id="r_afe0ad26c40a4024f160695f2a504ff0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe0ad26c40a4024f160695f2a504ff0a">ComputeBooleanLinearExpressionCanonicalForm</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *cst, Coefficient *bound_shift, Coefficient *max_value)</td></tr>
<tr class="separator:afe0ad26c40a4024f160695f2a504ff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afc11a07067fde98c2b4aa8c03b0cc0" id="r_a2afc11a07067fde98c2b4aa8c03b0cc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2afc11a07067fde98c2b4aa8c03b0cc0">ApplyLiteralMapping</a> (const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; LiteralIndex, LiteralIndex &gt; &amp;mapping, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *cst, Coefficient *bound_shift, Coefficient *max_value)</td></tr>
<tr class="separator:a2afc11a07067fde98c2b4aa8c03b0cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937ae99fd6f6c445a8aad34f04222a1a" id="r_a937ae99fd6f6c445a8aad34f04222a1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a937ae99fd6f6c445a8aad34f04222a1a">BooleanLinearExpressionIsCanonical</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; cst)</td></tr>
<tr class="memdesc:a937ae99fd6f6c445a8aad34f04222a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the Boolean linear expression is in canonical form.  <br /></td></tr>
<tr class="separator:a937ae99fd6f6c445a8aad34f04222a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0479a7ca6dd22cbabccdf623aea07315" id="r_a0479a7ca6dd22cbabccdf623aea07315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0479a7ca6dd22cbabccdf623aea07315">SimplifyCanonicalBooleanLinearConstraint</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *cst, Coefficient *rhs)</td></tr>
<tr class="separator:a0479a7ca6dd22cbabccdf623aea07315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c84ab8a0590875d286e1d518b804c9" id="r_aa6c84ab8a0590875d286e1d518b804c9"><td class="memItemLeft" align="right" valign="top">Coefficient&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6c84ab8a0590875d286e1d518b804c9">ComputeCanonicalRhs</a> (Coefficient upper_bound, Coefficient bound_shift, Coefficient max_value)</td></tr>
<tr class="separator:aa6c84ab8a0590875d286e1d518b804c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530ca58b0a7104b907a8933f8704dce8" id="r_a530ca58b0a7104b907a8933f8704dce8"><td class="memItemLeft" align="right" valign="top">Coefficient&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a530ca58b0a7104b907a8933f8704dce8">ComputeNegatedCanonicalRhs</a> (Coefficient lower_bound, Coefficient bound_shift, Coefficient max_value)</td></tr>
<tr class="separator:a530ca58b0a7104b907a8933f8704dce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8aa4554e45ceae93cb84e3be5cf151" id="r_aba8aa4554e45ceae93cb84e3be5cf151"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba8aa4554e45ceae93cb84e3be5cf151">DEFINE_STRONG_INT64_TYPE</a> (Coefficient)</td></tr>
<tr class="separator:aba8aa4554e45ceae93cb84e3be5cf151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd482f2c4b9533b4d1f7379a578e9b18" id="r_afd482f2c4b9533b4d1f7379a578e9b18"><td class="memItemLeft" align="right" valign="top">const Coefficient&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd482f2c4b9533b4d1f7379a578e9b18">kCoefficientMax</a> (std::numeric_limits&lt; Coefficient::ValueType &gt;::max())</td></tr>
<tr class="separator:afd482f2c4b9533b4d1f7379a578e9b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5729c9f2cd9c6c4897cd486978291a" id="r_adf5729c9f2cd9c6c4897cd486978291a"><td class="memTemplParams" colspan="2">template&lt;typename H&gt; </td></tr>
<tr class="memitem:adf5729c9f2cd9c6c4897cd486978291a"><td class="memTemplItemLeft" align="right" valign="top">H&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf5729c9f2cd9c6c4897cd486978291a">AbslHashValue</a> (H h, const <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &amp;term)</td></tr>
<tr class="separator:adf5729c9f2cd9c6c4897cd486978291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9035e7022f44a62d30b9ae6050d57a4" id="r_ae9035e7022f44a62d30b9ae6050d57a4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9035e7022f44a62d30b9ae6050d57a4">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> term)</td></tr>
<tr class="separator:ae9035e7022f44a62d30b9ae6050d57a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e17af099eed64300c03a7bc945171f4" id="r_a4e17af099eed64300c03a7bc945171f4"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e17af099eed64300c03a7bc945171f4">LowerOrEqual</a> (IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a4e17af099eed64300c03a7bc945171f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt;= b.  <br /></td></tr>
<tr class="separator:a4e17af099eed64300c03a7bc945171f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2656f8b95d75b4ba12494e5fc3bc573d" id="r_a2656f8b95d75b4ba12494e5fc3bc573d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2656f8b95d75b4ba12494e5fc3bc573d">LowerOrEqualWithOffset</a> (IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t offset)</td></tr>
<tr class="memdesc:a2656f8b95d75b4ba12494e5fc3bc573d"><td class="mdescLeft">&#160;</td><td class="mdescRight">a + offset &lt;= b.  <br /></td></tr>
<tr class="separator:a2656f8b95d75b4ba12494e5fc3bc573d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ca976dc541e339d8e37f865108a1a" id="r_a3b1ca976dc541e339d8e37f865108a1a"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1ca976dc541e339d8e37f865108a1a">AffineCoeffOneLowerOrEqualWithOffset</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> a, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t offset)</td></tr>
<tr class="memdesc:a3b1ca976dc541e339d8e37f865108a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a + offset &lt;= b. (when a and b are of the form 1 * var + offset).  <br /></td></tr>
<tr class="separator:a3b1ca976dc541e339d8e37f865108a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6541cdba8310f4fcbc8d8737cd29afa" id="r_af6541cdba8310f4fcbc8d8737cd29afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6541cdba8310f4fcbc8d8737cd29afa">AddConditionalSum2LowerOrEqual</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t ub, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:af6541cdba8310f4fcbc8d8737cd29afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">l =&gt; (a + b &lt;= ub).  <br /></td></tr>
<tr class="separator:af6541cdba8310f4fcbc8d8737cd29afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3913e8754c767cf5b0be9282bd4c6fe" id="r_ad3913e8754c767cf5b0be9282bd4c6fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3913e8754c767cf5b0be9282bd4c6fe">AddConditionalSum3LowerOrEqual</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, IntegerVariable c, int64_t ub, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ad3913e8754c767cf5b0be9282bd4c6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ee72b20ff7dd9d0285e8fb535b8229" id="r_a46ee72b20ff7dd9d0285e8fb535b8229"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46ee72b20ff7dd9d0285e8fb535b8229">GreaterOrEqual</a> (IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a46ee72b20ff7dd9d0285e8fb535b8229"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt;= b.  <br /></td></tr>
<tr class="separator:a46ee72b20ff7dd9d0285e8fb535b8229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385d140d4f7ca2544f0ef33e71965793" id="r_a385d140d4f7ca2544f0ef33e71965793"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a385d140d4f7ca2544f0ef33e71965793">Equality</a> (IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a385d140d4f7ca2544f0ef33e71965793"><td class="mdescLeft">&#160;</td><td class="mdescRight">a == b.  <br /></td></tr>
<tr class="separator:a385d140d4f7ca2544f0ef33e71965793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768255abe58acbda21da0438875ed315" id="r_a768255abe58acbda21da0438875ed315"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a768255abe58acbda21da0438875ed315">EqualityWithOffset</a> (IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t offset)</td></tr>
<tr class="memdesc:a768255abe58acbda21da0438875ed315"><td class="mdescLeft">&#160;</td><td class="mdescRight">a + offset == b.  <br /></td></tr>
<tr class="separator:a768255abe58acbda21da0438875ed315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9deb88b5fd44c96982ebf16eee8ddd2" id="r_af9deb88b5fd44c96982ebf16eee8ddd2"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9deb88b5fd44c96982ebf16eee8ddd2">ConditionalLowerOrEqualWithOffset</a> (IntegerVariable a, IntegerVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t offset, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> is_le)</td></tr>
<tr class="memdesc:af9deb88b5fd44c96982ebf16eee8ddd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_le =&gt; (a + offset &lt;= b).  <br /></td></tr>
<tr class="separator:af9deb88b5fd44c96982ebf16eee8ddd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efa47c328d4e70fd3337a8e70c947b0" id="r_a5efa47c328d4e70fd3337a8e70c947b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5efa47c328d4e70fd3337a8e70c947b0">ScaleFloatingPointObjective</a> (const SatParameters &amp;params, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger, CpModelProto *proto)</td></tr>
<tr class="separator:a5efa47c328d4e70fd3337a8e70c947b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f015dd7f088e0a586993ec925a94ced" id="r_a0f015dd7f088e0a586993ec925a94ced"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f015dd7f088e0a586993ec925a94ced">LoadModelForProbing</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *local_model)</td></tr>
<tr class="separator:a0f015dd7f088e0a586993ec925a94ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c33159d33daea6d86cc399b37e8b20" id="r_af8c33159d33daea6d86cc399b37e8b20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8c33159d33daea6d86cc399b37e8b20">LoadModelForPresolve</a> (const CpModelProto &amp;model_proto, SatParameters params, <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *local_model, absl::string_view name_for_logging)</td></tr>
<tr class="separator:af8c33159d33daea6d86cc399b37e8b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016498efd7ac3ee90eb0d00b38b0d061" id="r_a016498efd7ac3ee90eb0d00b38b0d061"><td class="memTemplParams" colspan="2">template&lt;typename ProtoWithVarsAndCoeffs, typename PresolveContextT&gt; </td></tr>
<tr class="memitem:a016498efd7ac3ee90eb0d00b38b0d061"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a016498efd7ac3ee90eb0d00b38b0d061">CanonicalizeLinearExpressionInternal</a> (absl::Span&lt; const int &gt; enforcements, ProtoWithVarsAndCoeffs *proto, int64_t *offset, std::vector&lt; std::pair&lt; int, int64_t &gt; &gt; *tmp_terms, PresolveContextT *context)</td></tr>
<tr class="separator:a016498efd7ac3ee90eb0d00b38b0d061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add50a2f0b709713e4943459a845da887" id="r_add50a2f0b709713e4943459a845da887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add50a2f0b709713e4943459a845da887">CreateValidModelWithSingleConstraint</a> (const ConstraintProto &amp;ct, const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context, std::vector&lt; int &gt; *variable_mapping, CpModelProto *mini_model)</td></tr>
<tr class="separator:add50a2f0b709713e4943459a845da887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d484b274f754affced447d310b8b612" id="r_a7d484b274f754affced447d310b8b612"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d484b274f754affced447d310b8b612">AddLinearConstraintMultiple</a> (int64_t factor, const ConstraintProto &amp;to_add, ConstraintProto *to_modify)</td></tr>
<tr class="separator:a7d484b274f754affced447d310b8b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6ebcd354f4957a3e7bf72b45b9408d" id="r_a6e6ebcd354f4957a3e7bf72b45b9408d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e6ebcd354f4957a3e7bf72b45b9408d">SubstituteVariable</a> (int var, int64_t var_coeff_in_definition, const ConstraintProto &amp;definition, ConstraintProto *ct)</td></tr>
<tr class="separator:a6e6ebcd354f4957a3e7bf72b45b9408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5aedd2ff7497d3def1e999afd71f6f" id="r_a0e5aedd2ff7497d3def1e999afd71f6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e5aedd2ff7497d3def1e999afd71f6f">FindSingleLinearDifference</a> (const LinearConstraintProto &amp;lin1, const LinearConstraintProto &amp;lin2, int *var1, int64_t *coeff1, int *var2, int64_t *coeff2)</td></tr>
<tr class="memdesc:a0e5aedd2ff7497d3def1e999afd71f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#ab84b1a369118c0ee55fd26133eb9bcc4">LinearsDifferAtOneTerm()</a> below but also fills the differing terms.  <br /></td></tr>
<tr class="separator:a0e5aedd2ff7497d3def1e999afd71f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445ddafc05cd8e1a75db81c1c4426179" id="r_a445ddafc05cd8e1a75db81c1c4426179"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a445ddafc05cd8e1a75db81c1c4426179">ClauseIsEnforcementImpliesLiteral</a> (absl::Span&lt; const int &gt; clause, absl::Span&lt; const int &gt; enforcement, int literal)</td></tr>
<tr class="separator:a445ddafc05cd8e1a75db81c1c4426179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84b1a369118c0ee55fd26133eb9bcc4" id="r_ab84b1a369118c0ee55fd26133eb9bcc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab84b1a369118c0ee55fd26133eb9bcc4">LinearsDifferAtOneTerm</a> (const LinearConstraintProto &amp;lin1, const LinearConstraintProto &amp;lin2)</td></tr>
<tr class="separator:ab84b1a369118c0ee55fd26133eb9bcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b169dd6f3e2bd0b684265da6a28d6ed" id="r_a7b169dd6f3e2bd0b684265da6a28d6ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b169dd6f3e2bd0b684265da6a28d6ed">LookForTrivialSatSolution</a> (double deterministic_time_limit, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a7b169dd6f3e2bd0b684265da6a28d6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d08e5135a1ae71b571b14fbff3381b" id="r_ac9d08e5135a1ae71b571b14fbff3381b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9d08e5135a1ae71b571b14fbff3381b">FailedLiteralProbingRound</a> (<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html">ProbingOptions</a> options, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ac9d08e5135a1ae71b571b14fbff3381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89c95fd9e5fe8176a7807d92872972e" id="r_ab89c95fd9e5fe8176a7807d92872972e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab89c95fd9e5fe8176a7807d92872972e">SUniv</a> (int <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>)</td></tr>
<tr class="separator:ab89c95fd9e5fe8176a7807d92872972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774bb7b95d0309e6e4448b044b88c456" id="r_a774bb7b95d0309e6e4448b044b88c456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774bb7b95d0309e6e4448b044b88c456">RecordLPRelaxationValues</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="memdesc:a774bb7b95d0309e6e4448b044b88c456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the current LP solution to the pool.  <br /></td></tr>
<tr class="separator:a774bb7b95d0309e6e4448b044b88c456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6dfa125801eb330bfe3c8ece4751a4" id="r_a2d6dfa125801eb330bfe3c8ece4751a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1ReducedDomainNeighborhood.html">ReducedDomainNeighborhood</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d6dfa125801eb330bfe3c8ece4751a4">GetRinsRensNeighborhood</a> (const <a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *response_manager, const <a class="el" href="classoperations__research_1_1sat_1_1SharedLPSolutionRepository.html">SharedLPSolutionRepository</a> *lp_solutions, <a class="el" href="classoperations__research_1_1sat_1_1SharedIncompleteSolutionManager.html">SharedIncompleteSolutionManager</a> *incomplete_solutions, double difficulty, absl::BitGenRef random)</td></tr>
<tr class="separator:a2d6dfa125801eb330bfe3c8ece4751a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d88eb1ae1d8e5ab4507b8f809f2672" id="r_ae8d88eb1ae1d8e5ab4507b8f809f2672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8d88eb1ae1d8e5ab4507b8f809f2672">GenerateInterestingSubsets</a> (int num_nodes, absl::Span&lt; const std::pair&lt; int, int &gt; &gt; arcs, int stop_at_num_components, std::vector&lt; int &gt; *subset_data, std::vector&lt; absl::Span&lt; const int &gt; &gt; *subsets)</td></tr>
<tr class="separator:ae8d88eb1ae1d8e5ab4507b8f809f2672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb8d3a8598889ab54b14dd56b56ae1b" id="r_adeb8d3a8598889ab54b14dd56b56ae1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeb8d3a8598889ab54b14dd56b56ae1b">ExtractAllSubsetsFromForest</a> (absl::Span&lt; const int &gt; parent, std::vector&lt; int &gt; *subset_data, std::vector&lt; absl::Span&lt; const int &gt; &gt; *subsets, int node_limit)</td></tr>
<tr class="separator:adeb8d3a8598889ab54b14dd56b56ae1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d74e0ba57b88249516ace1c6d2dc546" id="r_a2d74e0ba57b88249516ace1c6d2dc546"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d74e0ba57b88249516ace1c6d2dc546">ComputeGomoryHuTree</a> (int num_nodes, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ArcWithLpValue.html">ArcWithLpValue</a> &gt; relevant_arcs)</td></tr>
<tr class="separator:a2d74e0ba57b88249516ace1c6d2dc546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd12533c5931b78650aebe211dd51e" id="r_ac0cd12533c5931b78650aebe211dd51e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0cd12533c5931b78650aebe211dd51e">SymmetrizeArcs</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ArcWithLpValue.html">ArcWithLpValue</a> &gt; *arcs)</td></tr>
<tr class="separator:ac0cd12533c5931b78650aebe211dd51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af306b332a6cfbebe5858dcdedfdfb132" id="r_af306b332a6cfbebe5858dcdedfdfb132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af306b332a6cfbebe5858dcdedfdfb132">SeparateSubtourInequalities</a> (OutgoingCutHelper &amp;helper, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager)</td></tr>
<tr class="separator:af306b332a6cfbebe5858dcdedfdfb132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a3f925228a72fd13718b740037c2a8" id="r_a29a3f925228a72fd13718b740037c2a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29a3f925228a72fd13718b740037c2a8">CreateStronglyConnectedGraphCutGenerator</a> (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a29a3f925228a72fd13718b740037c2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6247f9f44748b4ed51106c8a13d879b6" id="r_a6247f9f44748b4ed51106c8a13d879b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6247f9f44748b4ed51106c8a13d879b6">CreateCVRPCutGenerator</a> (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals, absl::Span&lt; const int64_t &gt; demands, int64_t capacity, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a6247f9f44748b4ed51106c8a13d879b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab771e6d4ef64d782505e2abdc6c0dbe3" id="r_ab771e6d4ef64d782505e2abdc6c0dbe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab771e6d4ef64d782505e2abdc6c0dbe3">SeparateFlowInequalities</a> (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;lp_values, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ab771e6d4ef64d782505e2abdc6c0dbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88677d1180474733727feff2bbca0d31" id="r_a88677d1180474733727feff2bbca0d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88677d1180474733727feff2bbca0d31">CreateFlowCutGenerator</a> (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a88677d1180474733727feff2bbca0d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee6af9b585a14fcbbbedee050b6c934" id="r_a5ee6af9b585a14fcbbbedee050b6c934"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ee6af9b585a14fcbbbedee050b6c934">DEFINE_STRONG_INDEX_TYPE</a> (BooleanVariable)</td></tr>
<tr class="memdesc:a5ee6af9b585a14fcbbbedee050b6c934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a variable (&gt;= 0).  <br /></td></tr>
<tr class="separator:a5ee6af9b585a14fcbbbedee050b6c934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67896a84f6372a648154c5770a0ae0" id="r_add67896a84f6372a648154c5770a0ae0"><td class="memItemLeft" align="right" valign="top">const BooleanVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add67896a84f6372a648154c5770a0ae0">kNoBooleanVariable</a> (-1)</td></tr>
<tr class="separator:add67896a84f6372a648154c5770a0ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eac46edfbe4bab27e13aebe3805a558" id="r_a2eac46edfbe4bab27e13aebe3805a558"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eac46edfbe4bab27e13aebe3805a558">DEFINE_STRONG_INDEX_TYPE</a> (LiteralIndex)</td></tr>
<tr class="memdesc:a2eac46edfbe4bab27e13aebe3805a558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of a literal (&gt;= 0), see <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> below.  <br /></td></tr>
<tr class="separator:a2eac46edfbe4bab27e13aebe3805a558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbcb7017d468a17bdb30252af5c6c31" id="r_a2dbcb7017d468a17bdb30252af5c6c31"><td class="memItemLeft" align="right" valign="top">const LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dbcb7017d468a17bdb30252af5c6c31">kNoLiteralIndex</a> (-1)</td></tr>
<tr class="separator:a2dbcb7017d468a17bdb30252af5c6c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab45c5256e605ee3da3bf3abd1df2e1" id="r_a7ab45c5256e605ee3da3bf3abd1df2e1"><td class="memItemLeft" align="right" valign="top">const LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ab45c5256e605ee3da3bf3abd1df2e1">kTrueLiteralIndex</a> (-2)</td></tr>
<tr class="separator:a7ab45c5256e605ee3da3bf3abd1df2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969b5056550d96847f8c35f19fd17f50" id="r_a969b5056550d96847f8c35f19fd17f50"><td class="memItemLeft" align="right" valign="top">const LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a969b5056550d96847f8c35f19fd17f50">kFalseLiteralIndex</a> (-3)</td></tr>
<tr class="separator:a969b5056550d96847f8c35f19fd17f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac642826c64ada206ceeec3c813a803a" id="r_aac642826c64ada206ceeec3c813a803a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac642826c64ada206ceeec3c813a803a">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> literal)</td></tr>
<tr class="separator:aac642826c64ada206ceeec3c813a803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2504820cc3e3ae89718cf6d15632da1b" id="r_a2504820cc3e3ae89718cf6d15632da1b"><td class="memTemplParams" colspan="2">template&lt;typename Sink, typename... T&gt; </td></tr>
<tr class="memitem:a2504820cc3e3ae89718cf6d15632da1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2504820cc3e3ae89718cf6d15632da1b">AbslStringify</a> (Sink &amp;sink, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> arg)</td></tr>
<tr class="separator:a2504820cc3e3ae89718cf6d15632da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddf9ebf6ced32e8fef8475caa357c2" id="r_a38ddf9ebf6ced32e8fef8475caa357c2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38ddf9ebf6ced32e8fef8475caa357c2">operator&lt;&lt;</a> (std::ostream &amp;os, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:a38ddf9ebf6ced32e8fef8475caa357c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af49d12cb0a07cd82e3498380f43a2e" id="r_a9af49d12cb0a07cd82e3498380f43a2e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9af49d12cb0a07cd82e3498380f43a2e">Literals</a> (absl::Span&lt; const int &gt; <a class="el" href="parser_8yy_8cc.html#a5a634cf4429798b1c921a81de8250051">input</a>)</td></tr>
<tr class="separator:a9af49d12cb0a07cd82e3498380f43a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215d34ee33b3afef47b10eef03beb7e1" id="r_a215d34ee33b3afef47b10eef03beb7e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215d34ee33b3afef47b10eef03beb7e1">SatStatusString</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> status)</td></tr>
<tr class="memdesc:a215d34ee33b3afef47b10eef03beb7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>.  <br /></td></tr>
<tr class="separator:a215d34ee33b3afef47b10eef03beb7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af004193a12bf9ed78b295e7f7cb51e6f" id="r_af004193a12bf9ed78b295e7f7cb51e6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af004193a12bf9ed78b295e7f7cb51e6f">MinimizeCore</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *core)</td></tr>
<tr class="separator:af004193a12bf9ed78b295e7f7cb51e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac341ac6090ff0bed8ad2231c94cd3bfc" id="r_ac341ac6090ff0bed8ad2231c94cd3bfc"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac341ac6090ff0bed8ad2231c94cd3bfc">BooleanLinearConstraint</a> (int64_t lower_bound, int64_t upper_bound, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *cst)</td></tr>
<tr class="separator:ac341ac6090ff0bed8ad2231c94cd3bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf691c03cf07937979c23faa67c29d70" id="r_abf691c03cf07937979c23faa67c29d70"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf691c03cf07937979c23faa67c29d70">CardinalityConstraint</a> (int64_t lower_bound, int64_t upper_bound, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:abf691c03cf07937979c23faa67c29d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7ff8fbf0c457648f4944b2d27c0135" id="r_abf7ff8fbf0c457648f4944b2d27c0135"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7ff8fbf0c457648f4944b2d27c0135">ExactlyOneConstraint</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:abf7ff8fbf0c457648f4944b2d27c0135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb2c90348e89a1658dc828e9449d926" id="r_aafb2c90348e89a1658dc828e9449d926"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafb2c90348e89a1658dc828e9449d926">AtMostOneConstraint</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:aafb2c90348e89a1658dc828e9449d926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37093a0df3cca500d5f58b1d5482bdc6" id="r_a37093a0df3cca500d5f58b1d5482bdc6"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37093a0df3cca500d5f58b1d5482bdc6">ClauseConstraint</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:a37093a0df3cca500d5f58b1d5482bdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e39cef45870bebda662477a8d6771" id="r_a641e39cef45870bebda662477a8d6771"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a641e39cef45870bebda662477a8d6771">Implication</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> a, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a641e39cef45870bebda662477a8d6771"><td class="mdescLeft">&#160;</td><td class="mdescRight">a =&gt; b.  <br /></td></tr>
<tr class="separator:a641e39cef45870bebda662477a8d6771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe51896137f1dc2c0e707695a04183a" id="r_a1fe51896137f1dc2c0e707695a04183a"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe51896137f1dc2c0e707695a04183a">Equality</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> a, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a1fe51896137f1dc2c0e707695a04183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a == b.  <br /></td></tr>
<tr class="separator:a1fe51896137f1dc2c0e707695a04183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43cf9354e7156908e6587958694c5b4" id="r_ae43cf9354e7156908e6587958694c5b4"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae43cf9354e7156908e6587958694c5b4">ReifiedBoolOr</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> r)</td></tr>
<tr class="memdesc:ae43cf9354e7156908e6587958694c5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">r &lt;=&gt; (at least one literal is true). This is a reified clause.  <br /></td></tr>
<tr class="separator:ae43cf9354e7156908e6587958694c5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393ff6c6adb9d243cd4b7b7e445a3c23" id="r_a393ff6c6adb9d243cd4b7b7e445a3c23"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a393ff6c6adb9d243cd4b7b7e445a3c23">EnforcedClause</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; enforcement_literals, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; clause)</td></tr>
<tr class="memdesc:a393ff6c6adb9d243cd4b7b7e445a3c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">enforcement_literals =&gt; clause.  <br /></td></tr>
<tr class="separator:a393ff6c6adb9d243cd4b7b7e445a3c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536dbee8dfbb862d59d1d213a0c53772" id="r_a536dbee8dfbb862d59d1d213a0c53772"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a536dbee8dfbb862d59d1d213a0c53772">ReifiedBoolAnd</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> r)</td></tr>
<tr class="separator:a536dbee8dfbb862d59d1d213a0c53772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e7ea663f64c733766811e8f20a6a13" id="r_a52e7ea663f64c733766811e8f20a6a13"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e7ea663f64c733766811e8f20a6a13">ReifiedBoolLe</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> a, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> r)</td></tr>
<tr class="memdesc:a52e7ea663f64c733766811e8f20a6a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">r &lt;=&gt; (a &lt;= b).  <br /></td></tr>
<tr class="separator:a52e7ea663f64c733766811e8f20a6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa275108375324277e2d6399f6119513" id="r_aaa275108375324277e2d6399f6119513"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa275108375324277e2d6399f6119513">Value</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l)</td></tr>
<tr class="memdesc:aaa275108375324277e2d6399f6119513"><td class="mdescLeft">&#160;</td><td class="mdescRight">This checks that the variable is fixed.  <br /></td></tr>
<tr class="separator:aaa275108375324277e2d6399f6119513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3318619f57025ab3d6474542d64994" id="r_a1a3318619f57025ab3d6474542d64994"><td class="memItemLeft" align="right" valign="top">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a3318619f57025ab3d6474542d64994">Value</a> (BooleanVariable <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a1a3318619f57025ab3d6474542d64994"><td class="mdescLeft">&#160;</td><td class="mdescRight">This checks that the variable is fixed.  <br /></td></tr>
<tr class="separator:a1a3318619f57025ab3d6474542d64994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5713162a0aa0aa8ce18c442afc26254" id="r_ae5713162a0aa0aa8ce18c442afc26254"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5713162a0aa0aa8ce18c442afc26254">ExcludeCurrentSolutionAndBacktrack</a> ()</td></tr>
<tr class="separator:ae5713162a0aa0aa8ce18c442afc26254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba4fb23e5a8ee32e9a2c807ee82b4c4" id="r_a9ba4fb23e5a8ee32e9a2c807ee82b4c4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ba4fb23e5a8ee32e9a2c807ee82b4c4">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> status)</td></tr>
<tr class="separator:a9ba4fb23e5a8ee32e9a2c807ee82b4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c07c2911bf5d9a1225cd3789ff0499" id="r_a79c07c2911bf5d9a1225cd3789ff0499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79c07c2911bf5d9a1225cd3789ff0499">GenerateCumulativeEnergeticCutsWithMakespanAndFixedCapacity</a> (absl::string_view cut_name, const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1EnergyEvent.html">EnergyEvent</a> &gt; events, IntegerValue capacity, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> makespan, <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *<a class="el" href="linear__solver_2solve_8cc.html#a5924b2104bcf836d8c82d6d5b6bf4b36">time_limit</a>, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager)</td></tr>
<tr class="separator:a79c07c2911bf5d9a1225cd3789ff0499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa6389f471e5868e779c07148e4ee4" id="r_a3cfa6389f471e5868e779c07148e4ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cfa6389f471e5868e779c07148e4ee4">GenerateCumulativeEnergeticCuts</a> (absl::string_view cut_name, const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1EnergyEvent.html">EnergyEvent</a> &gt; events, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *<a class="el" href="linear__solver_2solve_8cc.html#a5924b2104bcf836d8c82d6d5b6bf4b36">time_limit</a>, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager)</td></tr>
<tr class="separator:a3cfa6389f471e5868e779c07148e4ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cafa81679ac10c971927ca17ec7f2e" id="r_a55cafa81679ac10c971927ca17ec7f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55cafa81679ac10c971927ca17ec7f2e">CreateCumulativeEnergyCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands_helper, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;makespan, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a55cafa81679ac10c971927ca17ec7f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20782292f65eff3a95731906141a718" id="r_ab20782292f65eff3a95731906141a718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab20782292f65eff3a95731906141a718">CreateNoOverlapEnergyCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;makespan, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ab20782292f65eff3a95731906141a718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808babe15ef3ed46b6b0fdc42653e1da" id="r_a808babe15ef3ed46b6b0fdc42653e1da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a808babe15ef3ed46b6b0fdc42653e1da">CreateCumulativeTimeTableCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands_helper, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a808babe15ef3ed46b6b0fdc42653e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e2846c953a0da80fa787daddb78be7" id="r_a24e2846c953a0da80fa787daddb78be7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24e2846c953a0da80fa787daddb78be7">GenerateCutsBetweenPairOfNonOverlappingTasks</a> (absl::string_view cut_name, const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CachedIntervalData.html">CachedIntervalData</a> &gt; events, IntegerValue capacity_max, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager)</td></tr>
<tr class="separator:a24e2846c953a0da80fa787daddb78be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3472d7c626a01bde822df5443fc76d87" id="r_a3472d7c626a01bde822df5443fc76d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3472d7c626a01bde822df5443fc76d87">CreateCumulativePrecedenceCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands_helper, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a3472d7c626a01bde822df5443fc76d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe41a207e47ea846654b9cb973c0b4b5" id="r_abe41a207e47ea846654b9cb973c0b4b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe41a207e47ea846654b9cb973c0b4b5">CreateNoOverlapPrecedenceCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:abe41a207e47ea846654b9cb973c0b4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc1657dd321ca86c667f100053768da" id="r_a8dc1657dd321ca86c667f100053768da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dc1657dd321ca86c667f100053768da">ComputeMinSumOfWeightedEndMins</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1PermutableEvent.html">PermutableEvent</a> &gt; &amp;events, IntegerValue capacity_max, IntegerValue &amp;min_sum_of_end_mins, IntegerValue &amp;min_sum_of_weighted_end_mins, IntegerValue unweighted_threshold, IntegerValue weighted_threshold)</td></tr>
<tr class="separator:a8dc1657dd321ca86c667f100053768da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c4d8406e1afd37e5a99ed333207f32" id="r_a53c4d8406e1afd37e5a99ed333207f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c4d8406e1afd37e5a99ed333207f32">GenerateShortCompletionTimeCutsWithExactBound</a> (const std::string &amp;cut_name, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CtEvent.html">CtEvent</a> &gt; events, IntegerValue capacity_max, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager)</td></tr>
<tr class="separator:a53c4d8406e1afd37e5a99ed333207f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8cabd3d98b36018d409338a6875acc" id="r_a0f8cabd3d98b36018d409338a6875acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f8cabd3d98b36018d409338a6875acc">GenerateCompletionTimeCutsWithEnergy</a> (absl::string_view cut_name, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CtEvent.html">CtEvent</a> &gt; events, IntegerValue capacity_max, bool skip_low_sizes, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *manager)</td></tr>
<tr class="separator:a0f8cabd3d98b36018d409338a6875acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb41d6a99bb282019a1a7efc6250ce5" id="r_a8bb41d6a99bb282019a1a7efc6250ce5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb41d6a99bb282019a1a7efc6250ce5">CreateNoOverlapCompletionTimeCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a8bb41d6a99bb282019a1a7efc6250ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfc8799f2e7ffc634715e6524db3077" id="r_a0dfc8799f2e7ffc634715e6524db3077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dfc8799f2e7ffc634715e6524db3077">CreateCumulativeCompletionTimeCutGenerator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *demands_helper, const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;capacity, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a0dfc8799f2e7ffc634715e6524db3077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a9258290419e520e0cb578b6bc3cf0" id="r_af6a9258290419e520e0cb578b6bc3cf0"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6a9258290419e520e0cb578b6bc3cf0">ComputeEnergyMinInWindow</a> (IntegerValue start_min, IntegerValue start_max, IntegerValue end_min, IntegerValue end_max, IntegerValue size_min, IntegerValue demand_min, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt; filtered_energy, IntegerValue window_start, IntegerValue window_end)</td></tr>
<tr class="separator:af6a9258290419e520e0cb578b6bc3cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7809e48d0dc20fb3c356a429c4f2d56a" id="r_a7809e48d0dc20fb3c356a429c4f2d56a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7809e48d0dc20fb3c356a429c4f2d56a">AddIntegerVariableFromIntervals</a> (const <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *helper, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, std::vector&lt; IntegerVariable &gt; *vars, int mask)</td></tr>
<tr class="separator:a7809e48d0dc20fb3c356a429c4f2d56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab649ca11fd81e049dc7a8c0dd1104b5b" id="r_ab649ca11fd81e049dc7a8c0dd1104b5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab649ca11fd81e049dc7a8c0dd1104b5b">SimplifyClause</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;a, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, LiteralIndex *opposite_literal, int64_t *num_inspected_literals)</td></tr>
<tr class="separator:ab649ca11fd81e049dc7a8c0dd1104b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a3f2af6ea15181591a33edda577652" id="r_a63a3f2af6ea15181591a33edda577652"><td class="memItemLeft" align="right" valign="top">LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63a3f2af6ea15181591a33edda577652">DifferAtGivenLiteral</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;a, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l)</td></tr>
<tr class="separator:a63a3f2af6ea15181591a33edda577652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6db4124c1030575ede339b237d9e68" id="r_adb6db4124c1030575ede339b237d9e68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb6db4124c1030575ede339b237d9e68">ComputeResolvant</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> x, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;a, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *out)</td></tr>
<tr class="separator:adb6db4124c1030575ede339b237d9e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e10d7ec51fc3637bb6d86f3703ab80" id="r_aa4e10d7ec51fc3637bb6d86f3703ab80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4e10d7ec51fc3637bb6d86f3703ab80">ComputeResolvantSize</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> x, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;a, const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="separator:aa4e10d7ec51fc3637bb6d86f3703ab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af37fab5c93f2f256ff65457866fb4" id="r_a76af37fab5c93f2f256ff65457866fb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76af37fab5c93f2f256ff65457866fb4">ProbeAndFindEquivalentLiteral</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *solver, <a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html">SatPostsolver</a> *postsolver, <a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *drat_proof_handler, <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; LiteralIndex, LiteralIndex &gt; *mapping, <a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *logger)</td></tr>
<tr class="separator:a76af37fab5c93f2f256ff65457866fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f7fad019ed1def27f3b582c050b3a6" id="r_ae4f7fad019ed1def27f3b582c050b3a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4f7fad019ed1def27f3b582c050b3a6">SequentialLoop</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> &gt; &gt; &amp;subsolvers)</td></tr>
<tr class="separator:ae4f7fad019ed1def27f3b582c050b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb6813fa96405f91b0c930ce00356f3" id="r_a7bb6813fa96405f91b0c930ce00356f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb6813fa96405f91b0c930ce00356f3">DeterministicLoop</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> &gt; &gt; &amp;subsolvers, int num_threads, int batch_size, int max_num_batches)</td></tr>
<tr class="separator:a7bb6813fa96405f91b0c930ce00356f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be20b017a46b4e9d7097ee32622eba8" id="r_a8be20b017a46b4e9d7097ee32622eba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be20b017a46b4e9d7097ee32622eba8">NonDeterministicLoop</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> &gt; &gt; &amp;subsolvers, const int num_threads, <a class="el" href="classoperations__research_1_1sat_1_1ModelSharedTimeLimit.html">ModelSharedTimeLimit</a> *<a class="el" href="linear__solver_2solve_8cc.html#a5924b2104bcf836d8c82d6d5b6bf4b36">time_limit</a>)</td></tr>
<tr class="separator:a8be20b017a46b4e9d7097ee32622eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35ceb34b6366add1981140f6a173339" id="r_ae35ceb34b6366add1981140f6a173339"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35ceb34b6366add1981140f6a173339">BasicOrbitopeExtraction</a> (absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; generators)</td></tr>
<tr class="separator:ae35ceb34b6366add1981140f6a173339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cc7ff53b39b6a28e821bc428dcb331" id="r_aa8cc7ff53b39b6a28e821bc428dcb331"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8cc7ff53b39b6a28e821bc428dcb331">GetOrbits</a> (int n, absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; generators)</td></tr>
<tr class="separator:aa8cc7ff53b39b6a28e821bc428dcb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8a370fc5dabda472b2004e14fd6a0a" id="r_a0c8a370fc5dabda472b2004e14fd6a0a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c8a370fc5dabda472b2004e14fd6a0a">GetOrbitopeOrbits</a> (int n, absl::Span&lt; const std::vector&lt; int &gt; &gt; orbitope)</td></tr>
<tr class="separator:a0c8a370fc5dabda472b2004e14fd6a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd9e4dc35b02efb37cf01da2bac1743" id="r_a1bd9e4dc35b02efb37cf01da2bac1743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bd9e4dc35b02efb37cf01da2bac1743">GetSchreierVectorAndOrbit</a> (int point, absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; generators, std::vector&lt; int &gt; *schrier_vector, std::vector&lt; int &gt; *orbit)</td></tr>
<tr class="separator:a1bd9e4dc35b02efb37cf01da2bac1743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582f0961633776a7a3e0933052435137" id="r_a582f0961633776a7a3e0933052435137"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a582f0961633776a7a3e0933052435137">TracePoint</a> (int point, absl::Span&lt; const int &gt; schrier_vector, absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; generators)</td></tr>
<tr class="separator:a582f0961633776a7a3e0933052435137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9d3bcc4628aa9439abe33d70b372e" id="r_ad9c9d3bcc4628aa9439abe33d70b372e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c9d3bcc4628aa9439abe33d70b372e">CreateSparsePermutationFromProto</a> (int n, const SparsePermutationProto &amp;proto)</td></tr>
<tr class="memdesc:ad9c9d3bcc4628aa9439abe33d70b372e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> on [0, n) from its proto representation.  <br /></td></tr>
<tr class="separator:ad9c9d3bcc4628aa9439abe33d70b372e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc9e60de9ebec04b0d8e62c0bcd7aa1" id="r_a8fc9e60de9ebec04b0d8e62c0bcd7aa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fc9e60de9ebec04b0d8e62c0bcd7aa1">TransformToGeneratorOfStabilizer</a> (int to_stabilize, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *generators)</td></tr>
<tr class="separator:a8fc9e60de9ebec04b0d8e62c0bcd7aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834cefc490c4046ce63a4c58da9e8ea4" id="r_a834cefc490c4046ce63a4c58da9e8ea4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a834cefc490c4046ce63a4c58da9e8ea4">ExtractSubSolverName</a> (const std::string &amp;improvement_info)</td></tr>
<tr class="separator:a834cefc490c4046ce63a4c58da9e8ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d113c6e0193be7420f842f6f392189f" id="r_a3d113c6e0193be7420f842f6f392189f"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d113c6e0193be7420f842f6f392189f">LiteralTableConstraint</a> (absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; literal_tuples, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; line_literals)</td></tr>
<tr class="separator:a3d113c6e0193be7420f842f6f392189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7beb472425b294af9b102a4a98f42c" id="r_a8b7beb472425b294af9b102a4a98f42c"><td class="memTemplParams" colspan="2">template&lt;typename IntegerType&gt; </td></tr>
<tr class="memitem:a8b7beb472425b294af9b102a4a98f42c"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntegerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b7beb472425b294af9b102a4a98f42c">IntegerTypeMinimumValue</a> ()</td></tr>
<tr class="memdesc:a8b7beb472425b294af9b102a4a98f42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimal value of an envelope, for instance the envelope of the empty set.  <br /></td></tr>
<tr class="separator:a8b7beb472425b294af9b102a4a98f42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb08d14503090b0fcd0cff9e37013c7" id="r_a9fb08d14503090b0fcd0cff9e37013c7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9fb08d14503090b0fcd0cff9e37013c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntegerValue&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fb08d14503090b0fcd0cff9e37013c7">IntegerTypeMinimumValue</a> ()</td></tr>
<tr class="separator:a9fb08d14503090b0fcd0cff9e37013c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c15896347fcf9c21fce30a6dfa9da2" id="r_ad3c15896347fcf9c21fce30a6dfa9da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3c15896347fcf9c21fce30a6dfa9da2">AddReservoirConstraint</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; times, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; deltas, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; presences, int64_t min_level, int64_t max_level, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:ad3c15896347fcf9c21fce30a6dfa9da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a7a53b2e474d3d5c602030c5c449e9" id="r_a88a7a53b2e474d3d5c602030c5c449e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a7a53b2e474d3d5c602030c5c449e9">FormatCounter</a> (int64_t num)</td></tr>
<tr class="memdesc:a88a7a53b2e474d3d5c602030c5c449e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a positive number with separators for easier reading (ex: 1'348'065).  <br /></td></tr>
<tr class="separator:a88a7a53b2e474d3d5c602030c5c449e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7414c91f17a6ff5a2621fa05fedf7da" id="r_af7414c91f17a6ff5a2621fa05fedf7da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7414c91f17a6ff5a2621fa05fedf7da">FormatTable</a> (std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;table, int spacing)</td></tr>
<tr class="separator:af7414c91f17a6ff5a2621fa05fedf7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2421e921ab494e0c666f6d7ed2a7e432" id="r_a2421e921ab494e0c666f6d7ed2a7e432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2421e921ab494e0c666f6d7ed2a7e432">RandomizeDecisionHeuristic</a> (absl::BitGenRef random, SatParameters *parameters)</td></tr>
<tr class="memdesc:a2421e921ab494e0c666f6d7ed2a7e432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes the decision heuristic of the given SatParameters.  <br /></td></tr>
<tr class="separator:a2421e921ab494e0c666f6d7ed2a7e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a998a24858a532c80b11c1d015e76db" id="r_a4a998a24858a532c80b11c1d015e76db"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a998a24858a532c80b11c1d015e76db">ModularInverse</a> (int64_t x, int64_t m)</td></tr>
<tr class="separator:a4a998a24858a532c80b11c1d015e76db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac435c5e5536231b2542ba53f100c3936" id="r_ac435c5e5536231b2542ba53f100c3936"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac435c5e5536231b2542ba53f100c3936">PositiveMod</a> (int64_t x, int64_t m)</td></tr>
<tr class="memdesc:ac435c5e5536231b2542ba53f100c3936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just returns x % m but with a result always in [0, m).  <br /></td></tr>
<tr class="separator:ac435c5e5536231b2542ba53f100c3936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345bada8924ba2bf94e22f85916b23ad" id="r_a345bada8924ba2bf94e22f85916b23ad"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a345bada8924ba2bf94e22f85916b23ad">ProductWithModularInverse</a> (int64_t coeff, int64_t mod, int64_t rhs)</td></tr>
<tr class="separator:a345bada8924ba2bf94e22f85916b23ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eb7909877704c304f50d65dd5c0052" id="r_a34eb7909877704c304f50d65dd5c0052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34eb7909877704c304f50d65dd5c0052">SolveDiophantineEquationOfSizeTwo</a> (int64_t &amp;a, int64_t &amp;<a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t &amp;cte, int64_t &amp;x0, int64_t &amp;y0)</td></tr>
<tr class="separator:a34eb7909877704c304f50d65dd5c0052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cbc97ff49b1aed57ea5e8f82cf9534" id="r_aa5cbc97ff49b1aed57ea5e8f82cf9534"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5cbc97ff49b1aed57ea5e8f82cf9534">DiophantineEquationOfSizeTwoHasSolutionInDomain</a> (const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;x, int64_t a, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;y, int64_t <a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int64_t cte)</td></tr>
<tr class="separator:aa5cbc97ff49b1aed57ea5e8f82cf9534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392d70cc768a13de271f87123513acf2" id="r_a392d70cc768a13de271f87123513acf2"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a392d70cc768a13de271f87123513acf2">FloorSquareRoot</a> (int64_t a)</td></tr>
<tr class="memdesc:a392d70cc768a13de271f87123513acf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The argument must be non-negative.  <br /></td></tr>
<tr class="separator:a392d70cc768a13de271f87123513acf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5064fe335d0bd2f67a8c9e3e132b4f" id="r_a3f5064fe335d0bd2f67a8c9e3e132b4f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f5064fe335d0bd2f67a8c9e3e132b4f">CeilSquareRoot</a> (int64_t a)</td></tr>
<tr class="separator:a3f5064fe335d0bd2f67a8c9e3e132b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45b9df04a0d18b7a12d062c2e7982c6" id="r_ab45b9df04a0d18b7a12d062c2e7982c6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab45b9df04a0d18b7a12d062c2e7982c6">ClosestMultiple</a> (int64_t value, int64_t base)</td></tr>
<tr class="separator:ab45b9df04a0d18b7a12d062c2e7982c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcd7f361a263decf1acd1f3aa585706" id="r_acfcd7f361a263decf1acd1f3aa585706"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfcd7f361a263decf1acd1f3aa585706">LinearInequalityCanBeReducedWithClosestMultiple</a> (int64_t base, absl::Span&lt; const int64_t &gt; coeffs, absl::Span&lt; const int64_t &gt; lbs, absl::Span&lt; const int64_t &gt; ubs, int64_t rhs, int64_t *new_rhs)</td></tr>
<tr class="separator:acfcd7f361a263decf1acd1f3aa585706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40dd9970adbe462e75e6074f8896e76" id="r_ad40dd9970adbe462e75e6074f8896e76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40dd9970adbe462e75e6074f8896e76">MoveOneUnprocessedLiteralLast</a> (const absl::btree_set&lt; LiteralIndex &gt; &amp;processed, int relevant_prefix_size, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *literals)</td></tr>
<tr class="separator:ad40dd9970adbe462e75e6074f8896e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc73d43252c02a3d538fd5bbf1f2aec" id="r_a7fc73d43252c02a3d538fd5bbf1f2aec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fc73d43252c02a3d538fd5bbf1f2aec">WeightedPick</a> (absl::Span&lt; const double &gt; <a class="el" href="parser_8yy_8cc.html#a5a634cf4429798b1c921a81de8250051">input</a>, absl::BitGenRef random)</td></tr>
<tr class="separator:a7fc73d43252c02a3d538fd5bbf1f2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce32567c40d90f074ff693fa483ba9c" id="r_adce32567c40d90f074ff693fa483ba9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; absl::Span&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adce32567c40d90f074ff693fa483ba9c">AtMostOneDecomposition</a> (const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;graph, absl::BitGenRef random, std::vector&lt; int &gt; *buffer)</td></tr>
<tr class="separator:adce32567c40d90f074ff693fa483ba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41bef85b701ac3dd74b685f5232b96b" id="r_af41bef85b701ac3dd74b685f5232b96b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41bef85b701ac3dd74b685f5232b96b">FormatName</a> (absl::string_view name)</td></tr>
<tr class="memdesc:af41bef85b701ac3dd74b685f5232b96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to format our table first row entry.  <br /></td></tr>
<tr class="separator:af41bef85b701ac3dd74b685f5232b96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8687ebf06d20e5b9fb4e461fc6f949a6" id="r_a8687ebf06d20e5b9fb4e461fc6f949a6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8687ebf06d20e5b9fb4e461fc6f949a6">SafeDoubleToInt64</a> (double value)</td></tr>
<tr class="separator:a8687ebf06d20e5b9fb4e461fc6f949a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e355cfd816df871c404e097c4b02696" id="r_a4e355cfd816df871c404e097c4b02696"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e355cfd816df871c404e097c4b02696">IsNegatableInt64</a> (absl::int128 x)</td></tr>
<tr class="memdesc:a4e355cfd816df871c404e097c4b02696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether a int128 can be casted to a int64_t that can be negated.  <br /></td></tr>
<tr class="separator:a4e355cfd816df871c404e097c4b02696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5275984bb2d64275b69e881316b7f34" id="r_ab5275984bb2d64275b69e881316b7f34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5275984bb2d64275b69e881316b7f34">ScanModelForDominanceDetection</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;context, <a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">VarDomination</a> *var_domination)</td></tr>
<tr class="separator:ab5275984bb2d64275b69e881316b7f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b440ecab00a601d5643f21df87c7cc6" id="r_a7b440ecab00a601d5643f21df87c7cc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b440ecab00a601d5643f21df87c7cc6">ScanModelForDualBoundStrengthening</a> (const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;context, <a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html">DualBoundStrengthening</a> *dual_bound_strengthening)</td></tr>
<tr class="memdesc:a7b440ecab00a601d5643f21df87c7cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan the model so that dual_bound_strengthening.Strenghten() works.  <br /></td></tr>
<tr class="separator:a7b440ecab00a601d5643f21df87c7cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265b8cf37f58fb2c78b247a6412ce519" id="r_a265b8cf37f58fb2c78b247a6412ce519"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265b8cf37f58fb2c78b247a6412ce519">ExploitDominanceRelations</a> (const <a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">VarDomination</a> &amp;var_domination, <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a265b8cf37f58fb2c78b247a6412ce519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1227e67513602591fb959e35c9de66e8" id="r_a1227e67513602591fb959e35c9de66e8"><td class="memItemLeft" align="right" valign="top">constexpr IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1227e67513602591fb959e35c9de66e8">kMaxIntegerValue</a> (std::numeric_limits&lt; IntegerValue::ValueType &gt;::max() - 1)</td></tr>
<tr class="separator:a1227e67513602591fb959e35c9de66e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5316808a2d5007c3b489e844801385e5" id="r_a5316808a2d5007c3b489e844801385e5"><td class="memItemLeft" align="right" valign="top">constexpr IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5316808a2d5007c3b489e844801385e5">kMinIntegerValue</a> (-kMaxIntegerValue.value())</td></tr>
<tr class="separator:a5316808a2d5007c3b489e844801385e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10700832ca6bc420f2931eb707957b0b" id="r_a10700832ca6bc420f2931eb707957b0b"><td class="memItemLeft" align="right" valign="top">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10700832ca6bc420f2931eb707957b0b">NewSatParameters</a> (const std::string &amp;params)</td></tr>
<tr class="separator:a10700832ca6bc420f2931eb707957b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c65bcf51a7c679ad0159e09ecfb3fc" id="r_a88c65bcf51a7c679ad0159e09ecfb3fc"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a>&gt; </td></tr>
<tr class="memitem:a88c65bcf51a7c679ad0159e09ecfb3fc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88c65bcf51a7c679ad0159e09ecfb3fc">RemapGraph</a> (const <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a> &amp;graph, absl::Span&lt; const int &gt; new_node_index)</td></tr>
<tr class="separator:a88c65bcf51a7c679ad0159e09ecfb3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad0e83800af0856c335c499d4bf32c900" id="r_ad0e83800af0856c335c499d4bf32c900"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0e83800af0856c335c499d4bf32c900">kMaxProblemSize</a> = 16</td></tr>
<tr class="separator:ad0e83800af0856c335c499d4bf32c900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0703b6fa9bb29801da1f26884386e05f" id="r_a0703b6fa9bb29801da1f26884386e05f"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0703b6fa9bb29801da1f26884386e05f">kTableAnyValue</a> = std::numeric_limits&lt;int64_t&gt;::min()</td></tr>
<tr class="separator:a0703b6fa9bb29801da1f26884386e05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7f8bfb4546fdd870155aea927cbd2" id="r_a12e7f8bfb4546fdd870155aea927cbd2"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12e7f8bfb4546fdd870155aea927cbd2">kDefaultFingerprintSeed</a> = 0xa5b85c5e198ed849</td></tr>
<tr class="memdesc:a12e7f8bfb4546fdd870155aea927cbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default seed for fingerprints.  <br /></td></tr>
<tr class="separator:a12e7f8bfb4546fdd870155aea927cbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c36038a18f65060a8232934b26cb7e" id="r_ab0c36038a18f65060a8232934b26cb7e"><td class="memItemLeft" align="right" valign="top">for&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a> = 0 ... k-2</td></tr>
<tr class="separator:ab0c36038a18f65060a8232934b26cb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea68c208c5e7f0abb9afc90d9188d3d4" id="r_aea68c208c5e7f0abb9afc90d9188d3d4"><td class="memItemLeft" align="right" valign="top">for&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea68c208c5e7f0abb9afc90d9188d3d4">b</a> [<a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>][j] = 0 <a class="el" href="parser_8yy_8cc.html#a33e91cd0cef6786e9e3a27ac67707207">if</a> j &gt; <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>+1</td></tr>
<tr class="separator:aea68c208c5e7f0abb9afc90d9188d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e34d84dd16d6b24f271692624c394" id="r_a9b7e34d84dd16d6b24f271692624c394"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b7e34d84dd16d6b24f271692624c394">kObjectiveConstraint</a> = -1</td></tr>
<tr class="memdesc:a9b7e34d84dd16d6b24f271692624c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use some special constraint index in our variable &lt;-&gt; constraint graph.  <br /></td></tr>
<tr class="separator:a9b7e34d84dd16d6b24f271692624c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3872788ea20ace515221011452ce03" id="r_a7e3872788ea20ace515221011452ce03"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e3872788ea20ace515221011452ce03">kAffineRelationConstraint</a> = -2</td></tr>
<tr class="separator:a7e3872788ea20ace515221011452ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808ec1fa0c9026293a5f6f0fc5e1236e" id="r_a808ec1fa0c9026293a5f6f0fc5e1236e"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a808ec1fa0c9026293a5f6f0fc5e1236e">kAssumptionsConstraint</a> = -3</td></tr>
<tr class="separator:a808ec1fa0c9026293a5f6f0fc5e1236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc68c12bf322c82aee0e2ccb202945d9" id="r_acc68c12bf322c82aee0e2ccb202945d9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc68c12bf322c82aee0e2ccb202945d9">kUnsatTrailIndex</a> = -1</td></tr>
<tr class="memdesc:acc68c12bf322c82aee0e2ccb202945d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant used by the EnqueueDecision*() API.  <br /></td></tr>
<tr class="separator:acc68c12bf322c82aee0e2ccb202945d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073868a91ec87d04bc963609af7806b6" id="r_a073868a91ec87d04bc963609af7806b6"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073868a91ec87d04bc963609af7806b6">kInfinity</a></td></tr>
<tr class="memdesc:a073868a91ec87d04bc963609af7806b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinity for type <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>.  <br /></td></tr>
<tr class="separator:a073868a91ec87d04bc963609af7806b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Solution Feasibility.</p>
<p>At the end of presolve, the mapping model is initialized to contains all the variable from the original model + the one created during presolve expand. It also contains the tightened domains. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0cac235bd48eb39d15cc101516dc1e90" name="a0cac235bd48eb39d15cc101516dc1e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac235bd48eb39d15cc101516dc1e90">&#9670;&#160;</a></span>Fractional <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">operations_research::glop::Fractional</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> denotes the type of numbers on which the computations are performed. This is defined as double here, but it could as well be float, DoubleDouble, QuadDouble, or infinite-precision rationals. Floating-point representations are binary fractional numbers, thus the name. (See <a href="http://en.wikipedia.org/wiki/Fraction_(mathematics)">http://en.wikipedia.org/wiki/Fraction_(mathematics)</a> .) </p>

<p class="definition">Definition at line <a class="el" href="lp__types_8h_source.html#l00081">81</a> of file <a class="el" href="lp__types_8h_source.html">lp_types.h</a>.</p>

</div>
</div>
<a id="a0cac235bd48eb39d15cc101516dc1e90" name="a0cac235bd48eb39d15cc101516dc1e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac235bd48eb39d15cc101516dc1e90">&#9670;&#160;</a></span>Fractional <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">operations_research::glop::Fractional</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> denotes the type of numbers on which the computations are performed. This is defined as double here, but it could as well be float, DoubleDouble, QuadDouble, or infinite-precision rationals. Floating-point representations are binary fractional numbers, thus the name. (See <a href="http://en.wikipedia.org/wiki/Fraction_(mathematics)">http://en.wikipedia.org/wiki/Fraction_(mathematics)</a> .) </p>

<p class="definition">Definition at line <a class="el" href="lp__types_8h_source.html#l00081">81</a> of file <a class="el" href="lp__types_8h_source.html">lp_types.h</a>.</p>

</div>
</div>
<a id="a0cac235bd48eb39d15cc101516dc1e90" name="a0cac235bd48eb39d15cc101516dc1e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac235bd48eb39d15cc101516dc1e90">&#9670;&#160;</a></span>Fractional <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">operations_research::glop::Fractional</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> denotes the type of numbers on which the computations are performed. This is defined as double here, but it could as well be float, DoubleDouble, QuadDouble, or infinite-precision rationals. Floating-point representations are binary fractional numbers, thus the name. (See <a href="http://en.wikipedia.org/wiki/Fraction_(mathematics)">http://en.wikipedia.org/wiki/Fraction_(mathematics)</a> .) </p>

<p class="definition">Definition at line <a class="el" href="lp__types_8h_source.html#l00081">81</a> of file <a class="el" href="lp__types_8h_source.html">lp_types.h</a>.</p>

</div>
</div>
<a id="acd5fcd5e44b4b153afface289223dd33" name="acd5fcd5e44b4b153afface289223dd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5fcd5e44b4b153afface289223dd33">&#9670;&#160;</a></span>InlinedIntegerLiteralVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acd5fcd5e44b4b153afface289223dd33">operations_research::sat::InlinedIntegerLiteralVector</a> = absl::InlinedVector&lt;<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00051">51</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a5bdc7202e90489453a3bad10f80f09b2" name="a5bdc7202e90489453a3bad10f80f09b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdc7202e90489453a3bad10f80f09b2">&#9670;&#160;</a></span>InlinedIntegerValueVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5bdc7202e90489453a3bad10f80f09b2">operations_research::sat::InlinedIntegerValueVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    absl::InlinedVector&lt;std::pair&lt;IntegerVariable, IntegerValue&gt;, 2&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00052">52</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aeee23a6099757399dc02f68671fdb1d8" name="aeee23a6099757399dc02f68671fdb1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee23a6099757399dc02f68671fdb1d8">&#9670;&#160;</a></span>IntegerSumLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aeee23a6099757399dc02f68671fdb1d8">operations_research::sat::IntegerSumLE</a> = <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html">LinearConstraintPropagator</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00163">163</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="ae30d80cf31433a6fc4056d15b5a9b719" name="ae30d80cf31433a6fc4056d15b5a9b719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30d80cf31433a6fc4056d15b5a9b719">&#9670;&#160;</a></span>IntegerSumLE128</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae30d80cf31433a6fc4056d15b5a9b719">operations_research::sat::IntegerSumLE128</a> = <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html">LinearConstraintPropagator</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00164">164</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1f55066a2cd55290e5cc385fbc363205" name="a1f55066a2cd55290e5cc385fbc363205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f55066a2cd55290e5cc385fbc363205">&#9670;&#160;</a></span>ConstraintStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceoperations__research_1_1glop.html#a1f55066a2cd55290e5cc385fbc363205">operations_research::glop::ConstraintStatus</a> : int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Different constraints statuses. The meaning is the same for the constraint activity relative to its bounds as it is for a variable value relative to its bounds. Actually, this is the VariableStatus of the slack variable associated to a constraint modulo a change of sign. The difference is that because of precision error, a constraint activity cannot exactly be equal to one of its bounds or to zero. </p>

<p class="definition">Definition at line <a class="el" href="lp__types_8h_source.html#l00234">234</a> of file <a class="el" href="lp__types_8h_source.html">lp_types.h</a>.</p>

</div>
</div>
<a id="af43f853fdcf6994d2f1be241dd31d517" name="af43f853fdcf6994d2f1be241dd31d517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43f853fdcf6994d2f1be241dd31d517">&#9670;&#160;</a></span>EdgePosition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af43f853fdcf6994d2f1be241dd31d517">operations_research::sat::EdgePosition</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af43f853fdcf6994d2f1be241dd31d517a54dcb6d08ed106f80fb990c7e3d0e664" name="af43f853fdcf6994d2f1be241dd31d517a54dcb6d08ed106f80fb990c7e3d0e664"></a>TOP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af43f853fdcf6994d2f1be241dd31d517a827d78bc9456a96bb4bd6f24a16ba895" name="af43f853fdcf6994d2f1be241dd31d517a827d78bc9456a96bb4bd6f24a16ba895"></a>RIGHT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af43f853fdcf6994d2f1be241dd31d517a879102c2cd3aef9e791f8cc518a04246" name="af43f853fdcf6994d2f1be241dd31d517a879102c2cd3aef9e791f8cc518a04246"></a>BOTTOM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af43f853fdcf6994d2f1be241dd31d517abb6bcae1852328684a190019a45167c2" name="af43f853fdcf6994d2f1be241dd31d517abb6bcae1852328684a190019a45167c2"></a>LEFT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8h_source.html#l00129">129</a> of file <a class="el" href="2d__rectangle__presolve_8h_source.html">2d_rectangle_presolve.h</a>.</p>

</div>
</div>
<a id="aa4a62b204187763884e737d2f51aad8a" name="aa4a62b204187763884e737d2f51aad8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a62b204187763884e737d2f51aad8a">&#9670;&#160;</a></span>EnforcementStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aa4a62b204187763884e737d2f51aad8a">operations_research::sat::EnforcementStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enforced constraint can be in one of these 4 states. </p><dl class="section note"><dt>Note</dt><dd>we rely on the integer encoding to take 2 bits for optimization. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa4a62b204187763884e737d2f51aad8aadeab83d56dee7ab418359a59b4ff2eb0" name="aa4a62b204187763884e737d2f51aad8aadeab83d56dee7ab418359a59b4ff2eb0"></a>IS_FALSE&#160;</td><td class="fielddoc"><p>One enforcement literal is false. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4a62b204187763884e737d2f51aad8aace72848e83395346e4d3f58ccc6443d6" name="aa4a62b204187763884e737d2f51aad8aace72848e83395346e4d3f58ccc6443d6"></a>CANNOT_PROPAGATE&#160;</td><td class="fielddoc"><p>More than two literals are unassigned. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4a62b204187763884e737d2f51aad8aadfc44107d47903d2049d949e3b75065b" name="aa4a62b204187763884e737d2f51aad8aadfc44107d47903d2049d949e3b75065b"></a>CAN_PROPAGATE&#160;</td><td class="fielddoc"><p>All enforcement literals are true but one. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa4a62b204187763884e737d2f51aad8aa4530573eddfc960e31ffd5624a07362d" name="aa4a62b204187763884e737d2f51aad8aa4530573eddfc960e31ffd5624a07362d"></a>IS_ENFORCED&#160;</td><td class="fielddoc"><p>All enforcement literals are true. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__propagation_8h_source.html#l00051">51</a> of file <a class="el" href="linear__propagation_8h_source.html">linear_propagation.h</a>.</p>

</div>
</div>
<a id="af0e549ab3da5547f8c99169f6e26ec4e" name="af0e549ab3da5547f8c99169f6e26ec4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e549ab3da5547f8c99169f6e26ec4e">&#9670;&#160;</a></span>IntegerVariablesToAddMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af0e549ab3da5547f8c99169f6e26ec4e">operations_research::sat::IntegerVariablesToAddMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts helpers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af0e549ab3da5547f8c99169f6e26ec4ea5d612278e0fdd4dc98f532671a3d0b78" name="af0e549ab3da5547f8c99169f6e26ec4ea5d612278e0fdd4dc98f532671a3d0b78"></a>kStart&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af0e549ab3da5547f8c99169f6e26ec4eaca82d053e92486cbd854145d55e23dcd" name="af0e549ab3da5547f8c99169f6e26ec4eaca82d053e92486cbd854145d55e23dcd"></a>kEnd&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af0e549ab3da5547f8c99169f6e26ec4ea1d016c585206cd74e630da3eb44a548e" name="af0e549ab3da5547f8c99169f6e26ec4ea1d016c585206cd74e630da3eb44a548e"></a>kSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af0e549ab3da5547f8c99169f6e26ec4ea9ee08791f261c45b978bb0fcecbcbd32" name="af0e549ab3da5547f8c99169f6e26ec4ea9ee08791f261c45b978bb0fcecbcbd32"></a>kPresence&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="scheduling__helpers_8h_source.html#l00788">788</a> of file <a class="el" href="scheduling__helpers_8h_source.html">scheduling_helpers.h</a>.</p>

</div>
</div>
<a id="a6cd6f4cf7fb7b9e5d8788c7bb25b51ce" name="a6cd6f4cf7fb7b9e5d8788c7bb25b51ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51ce">&#9670;&#160;</a></span>SatFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51ce">operations_research::sat::SatFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The file formats that can be used to save a list of clauses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6cd6f4cf7fb7b9e5d8788c7bb25b51ceafb2fc4a1eedd6bb627ed650068e1d808" name="a6cd6f4cf7fb7b9e5d8788c7bb25b51ceafb2fc4a1eedd6bb627ed650068e1d808"></a>DIMACS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6cd6f4cf7fb7b9e5d8788c7bb25b51cea3dbd66c668bbf5fe6e580ad1ac38c9d8" name="a6cd6f4cf7fb7b9e5d8788c7bb25b51cea3dbd66c668bbf5fe6e580ad1ac38c9d8"></a>DRAT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="drat__checker_8h_source.html#l00333">333</a> of file <a class="el" href="drat__checker_8h_source.html">drat_checker.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac160d1b2e1f1e1291af8c4dc333e3007" name="ac160d1b2e1f1e1291af8c4dc333e3007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac160d1b2e1f1e1291af8c4dc333e3007">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H operations_research::sat::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00328">328</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="add639177aff4867e35bbc198c9bbff7e" name="add639177aff4867e35bbc198c9bbff7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add639177aff4867e35bbc198c9bbff7e">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H operations_research::sat::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoolArgumentProto &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00365">365</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="aaa34d9202fc74c65575e29c573ee5900" name="aaa34d9202fc74c65575e29c573ee5900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa34d9202fc74c65575e29c573ee5900">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H operations_research::sat::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntervalVar.html">IntervalVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l00520">520</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="aadb67cecc84690abd0a358d0e2c9cd7c" name="aadb67cecc84690abd0a358d0e2c9cd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb67cecc84690abd0a358d0e2c9cd7c">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H operations_research::sat::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntVar.html">IntVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&ndash; ABSL HASHING SUPPORT --------------------------------------------------&mdash; </p>

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l00515">515</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a5fbce8f787bce863c63e07c6dd101be2" name="a5fbce8f787bce863c63e07c6dd101be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbce8f787bce863c63e07c6dd101be2">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H operations_research::sat::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00387">387</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="adf5729c9f2cd9c6c4897cd486978291a" name="adf5729c9f2cd9c6c4897cd486978291a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5729c9f2cd9c6c4897cd486978291a">&#9670;&#160;</a></span>AbslHashValue() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename H&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">H operations_research::sat::AbslHashValue </td>
          <td>(</td>
          <td class="paramtype">H</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>term</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pb__constraint_8h_source.html#l00064">64</a> of file <a class="el" href="pb__constraint_8h_source.html">pb_constraint.h</a>.</p>

</div>
</div>
<a id="ac846743f0e786064c9d27ad91c7176a7" name="ac846743f0e786064c9d27ad91c7176a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac846743f0e786064c9d27ad91c7176a7">&#9670;&#160;</a></span>AbslStringify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sink&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AbslStringify </td>
          <td>(</td>
          <td class="paramtype">Sink &amp;</td>          <td class="paramname"><span class="paramname"><em>sink</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af43f853fdcf6994d2f1be241dd31d517">EdgePosition</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8h_source.html#l00132">132</a> of file <a class="el" href="2d__rectangle__presolve_8h_source.html">2d_rectangle_presolve.h</a>.</p>

</div>
</div>
<a id="a2504820cc3e3ae89718cf6d15632da1b" name="a2504820cc3e3ae89718cf6d15632da1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2504820cc3e3ae89718cf6d15632da1b">&#9670;&#160;</a></span>AbslStringify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sink, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AbslStringify </td>
          <td>(</td>
          <td class="paramtype">Sink &amp;</td>          <td class="paramname"><span class="paramname"><em>sink</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__base_8h_source.html#l00123">123</a> of file <a class="el" href="sat__base_8h_source.html">sat_base.h</a>.</p>

</div>
</div>
<a id="a9de52a1eb284f2cf6e20a2a0e713f092" name="a9de52a1eb284f2cf6e20a2a0e713f092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de52a1eb284f2cf6e20a2a0e713f092">&#9670;&#160;</a></span>AdaptGlobalParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AdaptGlobalParameters </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update params.num_workers() if the old field was used.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001576">Todo</a></b></dt><dd>(user): This was the old behavior, but consider switching this to just a warning? it might be a valid usage to enumerate all solution of a presolved model. </dd></dl>
<p>Initialize the number of workers if set to 0.</p>
<p>Sometimes, hardware_concurrency will return 0. So always default to 1.</p>
<p>We currently only use the feasibility pump or rins/rens if it is enabled and some other parameters are not on.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001577">Todo</a></b></dt><dd>(user): for now this is not deterministic so we disable it on interleave search. Fix. </dd></dl>
<p>We disable this if the global param asked for no LP.</p>
<p>Disable shared bounds if we are in single thread and we are not tightening the domains.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01880">1880</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="aca4059e332187f15cc9dae9d2fd5ae48" name="aca4059e332187f15cc9dae9d2fd5ae48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4059e332187f15cc9dae9d2fd5ae48">&#9670;&#160;</a></span>AddAllDiffRelaxationAndCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddAllDiffRelaxationAndCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>linearization_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build union of affine expressions domains to check if this is a permutation.</p>
<p>In case of a permutation, the linear constraint is tight.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01607">1607</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a31b27558e7f0de02ffe3b7ff5929423f" name="a31b27558e7f0de02ffe3b7ff5929423f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b27558e7f0de02ffe3b7ff5929423f">&#9670;&#160;</a></span>AddCircuitCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddCircuitCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00581">581</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a1fe5bbe785cc30e5861b5e0e161a998c" name="a1fe5bbe785cc30e5861b5e0e161a998c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5bbe785cc30e5861b5e0e161a998c">&#9670;&#160;</a></span>AddCircuitFlowConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddCircuitFlowConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html">LinearIncrementalEvaluator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_evaluator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct_proto</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__violation_8cc_source.html#l01446">1446</a> of file <a class="el" href="constraint__violation_8cc_source.html">constraint_violation.cc</a>.</p>

</div>
</div>
<a id="a7e70b48ffc73d9b4346b4415c3b799b6" name="a7e70b48ffc73d9b4346b4415c3b799b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e70b48ffc73d9b4346b4415c3b799b6">&#9670;&#160;</a></span>AddConditionalAffinePrecedence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddConditionalAffinePrecedence </td>
          <td>(</td>
          <td class="paramtype">const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00666">666</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="af6541cdba8310f4fcbc8d8737cd29afa" name="af6541cdba8310f4fcbc8d8737cd29afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6541cdba8310f4fcbc8d8737cd29afa">&#9670;&#160;</a></span>AddConditionalSum2LowerOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddConditionalSum2LowerOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>l =&gt; (a + b &lt;= ub). </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002191">Todo</a></b></dt><dd>(user): Refactor to be sure we do not miss any level zero relations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00653">653</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="ad3913e8754c767cf5b0be9282bd4c6fe" name="ad3913e8754c767cf5b0be9282bd4c6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3913e8754c767cf5b0be9282bd4c6fe">&#9670;&#160;</a></span>AddConditionalSum3LowerOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddConditionalSum3LowerOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>l =&gt; (a + b + c &lt;= ub).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002192">Todo</a></b></dt><dd>(user): Use level zero bounds to infer binary precedence relations? </dd></dl>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00670">670</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="a20d332fb3ba7ede461acce753a5ea568" name="a20d332fb3ba7ede461acce753a5ea568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d332fb3ba7ede461acce753a5ea568">&#9670;&#160;</a></span>AddCumulativeCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddCumulativeCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>makespan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if at least one rectangle has a variable size, is optional, or if the demand or the capacity are variable.</p>
<p>Checks variable demand.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01673">1673</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="ae9833301c095ba1cd286e7be7ed2515e" name="ae9833301c095ba1cd286e7be7ed2515e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9833301c095ba1cd286e7be7ed2515e">&#9670;&#160;</a></span>AddCumulativeOverloadChecker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddCumulativeOverloadChecker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enforces the existence of a preemptive schedule where every task is executed inside its interval, using energy units of the resource during execution.</p>
<p>Important: This only uses the energies min/max and not the actual demand of a task. It can thus be used in some non-conventional situation.</p>
<p>All energy expression are assumed to take a non-negative value; if the energy of a task is 0, the task can run anywhere. The schedule never uses more than capacity units of energy at a given time.</p>
<p>This is mathematically equivalent to making a model with energy(task) different tasks with demand and size 1, but is much more efficient, since it uses O(<code>tasks</code>) variables instead of O(sum_{task} |energy(task)|). </p>

<p class="definition">Definition at line <a class="el" href="cumulative__energy_8cc_source.html#l00043">43</a> of file <a class="el" href="cumulative__energy_8cc_source.html">cumulative_energy.cc</a>.</p>

</div>
</div>
<a id="a6f7364044e91bc377aa1c354e8fa892a" name="a6f7364044e91bc377aa1c354e8fa892a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7364044e91bc377aa1c354e8fa892a">&#9670;&#160;</a></span>AddCumulativeOverloadCheckerDff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddCumulativeOverloadCheckerDff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but applying a Dual Feasible Function (also known as a conservative scale) before looking for overload. </p>

<p class="definition">Definition at line <a class="el" href="cumulative__energy_8cc_source.html#l00054">54</a> of file <a class="el" href="cumulative__energy_8cc_source.html">cumulative_energy.cc</a>.</p>

</div>
</div>
<a id="a799cf49d8b3bb7f3ede756a639e6662c" name="a799cf49d8b3bb7f3ede756a639e6662c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799cf49d8b3bb7f3ede756a639e6662c">&#9670;&#160;</a></span>AddCumulativeRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddCumulativeRelaxation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>makespan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling relaxations and cut generators. </p>
<p>This relaxation will compute the bounding box of all tasks in the cumulative, and add the constraint that the sum of energies of each task must fit in the capacity * span area.</p>
<p>Adds linearization of cumulative constraints.The second part adds an energetic equation linking the duration of all potential tasks to the actual span * capacity of the cumulative constraint. It uses the makespan to compute the span of the constraint if defined. </p>
<p>There are no active intervals, no need to add the relaxation.</p>
<p>If nothing is variable, and the coefficients cannot be reduced, the linear relaxation will already be enforced by the scheduling propagators.</p>
<p>Specialized case 1: sizes are fixed with a non 1 gcd and no makespan.</p>
<p>We can simplify the capacity only if it is fixed. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002046">Todo</a></b></dt><dd>(user): We could use (capacity / demands_gcd) * demands_gcd. </dd></dl>
<p>Copy the decomposed energy.</p>
<p>The energy is defined if the vector is not empty. Let's reduce the coefficients.</p>
<p>We know the size is fixed.</p>
<p>Add the available energy of the cumulative.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002047">Todo</a></b></dt><dd>(user): Implement demands_gcd != 1 &amp;&amp; capacity is fixed. </dd></dl>
<p>The energy is defined if the vector is not empty.</p>
<p>The energy is not a decomposed product, but it could still be constant or linear. If not, a McCormick relaxation will be introduced. AddQuadraticLowerBound() supports all cases.</p>
<p>Create and link span_start and span_end to the starts and ends of the tasks.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002048">Todo</a></b></dt><dd>(user): In some cases, we could have only one task that can be first. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00797">797</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a9ab304db27f5c4170f35583c69269394" name="a9ab304db27f5c4170f35583c69269394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab304db27f5c4170f35583c69269394">&#9670;&#160;</a></span>AddDisjunctive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddDisjunctive </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IntervalVariable &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>intervals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enforces a disjunctive (or no overlap) constraint on the given interval variables. The intervals are interpreted as [start, end) and the constraint enforces that no time point belongs to two intervals.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001734">Todo</a></b></dt><dd>(user): This is not completely true for empty intervals (start == end). Make sure such intervals are ignored by the constraint. </dd></dl>
<p>Depending on the parameters, create all pair of conditional precedences. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001713">Todo</a></b></dt><dd>(user): create them dynamically instead? </dd></dl>
<p>Experiments to use the timetable only to propagate the disjunctive.</p>
<p>We decided to create the propagators in this particular order, but it shouldn't matter much because of the different priorities used.</p>
<p>This one will not propagate anything if we added all precedence literals since the linear propagator will already do that in that case.</p>
<p>Only one direction is needed by this one.</p>
<dl class="section note"><dt>Note</dt><dd>we keep this one even when there is just two intervals. This is because it might push a variable that is after both of the intervals using the fact that they are in disjunction.</dd></dl>

<p class="definition">Definition at line <a class="el" href="disjunctive_8cc_source.html#l00040">40</a> of file <a class="el" href="disjunctive_8cc_source.html">disjunctive.cc</a>.</p>

</div>
</div>
<a id="ae66c711944582345e467efd1d25eb48e" name="ae66c711944582345e467efd1d25eb48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66c711944582345e467efd1d25eb48e">&#9670;&#160;</a></span>AddDisjunctiveWithBooleanPrecedencesOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddDisjunctiveWithBooleanPrecedencesOnly </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntervalVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>intervals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates Boolean variables for all the possible precedences of the form (task i is before task j) and forces that, for each couple of task (i,j), either i is before j or j is before i. Do not create any other propagators. </p>

<p class="definition">Definition at line <a class="el" href="disjunctive_8cc_source.html#l00156">156</a> of file <a class="el" href="disjunctive_8cc_source.html">disjunctive.cc</a>.</p>

</div>
</div>
<a id="a77e8cb71b79a363fcf4e3f5bc91a0cda" name="a77e8cb71b79a363fcf4e3f5bc91a0cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e8cb71b79a363fcf4e3f5bc91a0cda">&#9670;&#160;</a></span>AddFullEncodingFromSearchBranching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddFullEncodingFromSearchBranching </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inspect the search strategy stored in the model, and adds a full encoding to variables appearing in a SELECT_MEDIAN_VALUE search strategy if the search branching is set to FIXED_SEARCH. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00984">984</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a1fd62b999813ebc36c91f4d49d06aff4" name="a1fd62b999813ebc36c91f4d49d06aff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd62b999813ebc36c91f4d49d06aff4">&#9670;&#160;</a></span>AddInferedAndDeletedClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddInferedAndDeletedClauses </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DratChecker.html">DratChecker</a> *</td>          <td class="paramname"><span class="paramname"><em>drat_checker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds to the given drat checker the infered and deleted clauses from the file at the given path, which must be in DRAT format. Returns true iff the file was successfully parsed. </p>

<p class="definition">Definition at line <a class="el" href="drat__checker_8cc_source.html#l00564">564</a> of file <a class="el" href="drat__checker_8cc_source.html">drat_checker.cc</a>.</p>

</div>
</div>
<a id="a7809e48d0dc20fb3c356a429c4f2d56a" name="a7809e48d0dc20fb3c356a429c4f2d56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7809e48d0dc20fb3c356a429c4f2d56a">&#9670;&#160;</a></span>AddIntegerVariableFromIntervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddIntegerVariableFromIntervals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IntegerVariable &gt; *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="scheduling__helpers_8cc_source.html#l00991">991</a> of file <a class="el" href="scheduling__helpers_8cc_source.html">scheduling_helpers.cc</a>.</p>

</div>
</div>
<a id="a4dcd5302962cdb3bacde2ad477e5a187" name="a4dcd5302962cdb3bacde2ad477e5a187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcd5302962cdb3bacde2ad477e5a187">&#9670;&#160;</a></span>AddIntProdCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddIntProdCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>linearization_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cut generators. </p>
<p><a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a> is z == x * y.</p>
<p>We currently only support variables with non-negative domains.</p>
<p>Change signs to return to the case where all variables are a domain with non negative values only.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01505">1505</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="aecfd851680124f48adf731a43c644ca4" name="aecfd851680124f48adf731a43c644ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfd851680124f48adf731a43c644ca4">&#9670;&#160;</a></span>AddIsEqualToMinOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddIsEqualToMinOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min_expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Expresses the fact that an existing integer variable is equal to the minimum of linear expressions. Assumes Canonical expressions (all positive coefficients). </p>
<p>Create a new variable if the expression is not just a single variable.</p>
<p>min_var = min_expr</p>
<p>Add for all i, min &lt;= exprs[i].</p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00715">715</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a7d484b274f754affced447d310b8b612" name="a7d484b274f754affced447d310b8b612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d484b274f754affced447d310b8b612">&#9670;&#160;</a></span>AddLinearConstraintMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddLinearConstraintMultiple </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>to_add</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>to_modify</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does "to_modify += factor * to_add". Both constraint must be linear. Returns false and does not change anything in case of overflow.</p>
<dl class="section note"><dt>Note</dt><dd>the enforcement literals (if any) are ignored and left untouched. </dd></dl>
<p>Copy to_modify terms.</p>
<p>Add factor * to_add and check first kind of overflow.</p>
<p>Merge terms, return false if we get an overflow here.</p>
<p>Copy terms.</p>
<p>Write new rhs. We want to be exact during the multiplication. Note that in practice this domain is fixed, so this will always be the case.</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00182">182</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="ad0555e63b6d9d9bd5f3d04b7657bffbf" name="ad0555e63b6d9d9bd5f3d04b7657bffbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0555e63b6d9d9bd5f3d04b7657bffbf">&#9670;&#160;</a></span>AddLinearExpressionToLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddLinearExpressionToLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coefficient</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>linear</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a linear expression proto to a linear constraint in place.</p>
<p>Important: The domain must already be set, otherwise the offset will be lost. We also do not do any duplicate detection, so the constraint might need presolving afterwards. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00631">631</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="abf0e8ef0b1ad01ad3a9aae0a009e5f13" name="abf0e8ef0b1ad01ad3a9aae0a009e5f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0e8ef0b1ad01ad3a9aae0a009e5f13">&#9670;&#160;</a></span>AddLinMaxCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddLinMaxCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002057">Todo</a></b></dt><dd>(user): Support linearization of general target expression. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cut generator requires all expressions to contain only positive vars.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002058">Todo</a></b></dt><dd>(user): Move this out of here.</dd></dl>
<p>Add initial big-M linear relaxation. z_vars[i] == 1 &lt;=&gt; target = exprs[i].</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01780">1780</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a2e13273db243ecd0a444852de48bd929" name="a2e13273db243ecd0a444852de48bd929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e13273db243ecd0a444852de48bd929">&#9670;&#160;</a></span>AddMaxAffineCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddMaxAffineCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the target is constant, propagation is enough.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01140">1140</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="ab5886b2abb94aab5d08b1997d6bbbcf0" name="ab5886b2abb94aab5d08b1997d6bbbcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5886b2abb94aab5d08b1997d6bbbcf0">&#9670;&#160;</a></span>AddNonOverlappingRectangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddNonOverlappingRectangles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IntervalVariable &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IntervalVariable &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enforces that the boxes with corners in (x, y), (x + dx, y), (x, y + dy) and (x + dx, y + dy) do not overlap. </p>
<p>We must first check if the cumulative relaxation is possible.</p>
<p>Abort as the task would be conditioned by two literals.</p>
<p>We cannot use x_size as the demand of the cumulative based on the y_intervals.</p>
<p>We cannot use y_size as the demand of the cumulative based on the y_intervals.</p>

<p class="definition">Definition at line <a class="el" href="sat_2diffn_8cc_source.html#l00150">150</a> of file <a class="el" href="sat_2diffn_8cc_source.html">diffn.cc</a>.</p>

</div>
</div>
<a id="addfe32d132bfd8ab3a12b34d6fefcfe7" name="addfe32d132bfd8ab3a12b34d6fefcfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfe32d132bfd8ab3a12b34d6fefcfe7">&#9670;&#160;</a></span>AddNoOverlap2dCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddNoOverlap2dCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if at least one rectangle has a variable dimension or is optional.</p>
<p>Ignore absent rectangles.</p>
<p>Checks non-present intervals.</p>
<p>Checks variable sized intervals.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01730">1730</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="ad768da30abda81f190eb895f7a5d01e8" name="ad768da30abda81f190eb895f7a5d01e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad768da30abda81f190eb895f7a5d01e8">&#9670;&#160;</a></span>AddNoOverlapCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddNoOverlapCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>makespan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if at least one rectangle has a variable size or is optional.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01707">1707</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a02aa66ad3013c6ba16dda49461da34ef" name="a02aa66ad3013c6ba16dda49461da34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa66ad3013c6ba16dda49461da34ef">&#9670;&#160;</a></span>AddObjectiveConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddObjectiveConstraint </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the constraint that the objective is smaller or equals to the given upper bound. </p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00349">349</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a5f424cb0f7d850405f57f24fd74c9304" name="a5f424cb0f7d850405f57f24fd74c9304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f424cb0f7d850405f57f24fd74c9304">&#9670;&#160;</a></span>AddObjectiveUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddObjectiveUpperBound </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that the objective is smaller than the given upper bound. </p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00341">341</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a16bcd287bd18e3a940d997aafb9321a9" name="a16bcd287bd18e3a940d997aafb9321a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bcd287bd18e3a940d997aafb9321a9">&#9670;&#160;</a></span>AddOffsetAndScaleObjectiveValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::AddOffsetAndScaleObjectiveValue </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the offset and returns the scaled version of the given objective value. </p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8h_source.html#l00039">39</a> of file <a class="el" href="boolean__problem_8h_source.html">boolean_problem.h</a>.</p>

</div>
</div>
<a id="a23349cb008ced3bcc44ff0213b12a656" name="a23349cb008ced3bcc44ff0213b12a656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23349cb008ced3bcc44ff0213b12a656">&#9670;&#160;</a></span>AddProblemClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddProblemClauses </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DratChecker.html">DratChecker</a> *</td>          <td class="paramname"><span class="paramname"><em>drat_checker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds to the given drat checker the problem clauses from the file at the given path, which must be in DIMACS format. Returns true iff the file was successfully parsed. </p>
<p>Ignore empty and comment lines.</p>

<p class="definition">Definition at line <a class="el" href="drat__checker_8cc_source.html#l00515">515</a> of file <a class="el" href="drat__checker_8cc_source.html">drat_checker.cc</a>.</p>

</div>
</div>
<a id="a0c9e8fab437ba44c91b0493a74cde263" name="a0c9e8fab437ba44c91b0493a74cde263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9e8fab437ba44c91b0493a74cde263">&#9670;&#160;</a></span>AddProductTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddProductTo </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes result += a * b, and return false iff there is an overflow. </p>

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00134">134</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="ad3c15896347fcf9c21fce30a6dfa9da2" name="ad3c15896347fcf9c21fce30a6dfa9da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c15896347fcf9c21fce30a6dfa9da2">&#9670;&#160;</a></span>AddReservoirConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddReservoirConstraint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>times</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>deltas</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>presences</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a reservoir constraint to the model. Note that to account for level not containing zero at time zero, we might needs to create an artificial fixed event.</p>
<p>This instantiate one or more <a class="el" href="classoperations__research_1_1sat_1_1ReservoirTimeTabling.html">ReservoirTimeTabling</a> class to perform the propagation. </p>
<p>We only create a side if it can fail.</p>

<p class="definition">Definition at line <a class="el" href="timetable_8cc_source.html#l00032">32</a> of file <a class="el" href="timetable_8cc_source.html">timetable.cc</a>.</p>

</div>
</div>
<a id="a54db560e2cc153bb0ebc331f4e06ff97" name="a54db560e2cc153bb0ebc331f4e06ff97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54db560e2cc153bb0ebc331f4e06ff97">&#9670;&#160;</a></span>AddRoutesCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddRoutesCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00595">595</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a0f4310ba75873366ba7995ff9a669628" name="a0f4310ba75873366ba7995ff9a669628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4310ba75873366ba7995ff9a669628">&#9670;&#160;</a></span>AddSquareCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddSquareCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>linearization_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a> is square == x * x.</p>
<p>We currently only support variables with non-negative domains.</p>
<p>Change the sigh of x if its domain is non-positive.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01583">1583</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a0223d339c204a71da3ff69acf246e355" name="a0223d339c204a71da3ff69acf246e355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0223d339c204a71da3ff69acf246e355">&#9670;&#160;</a></span>AddSquareTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddSquareTo </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes result += a * a, and return false iff there is an overflow. </p>

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00144">144</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a19454de69c01843c000fbf4f96fc99f1" name="a19454de69c01843c000fbf4f96fc99f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19454de69c01843c000fbf4f96fc99f1">&#9670;&#160;</a></span>AddTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AddTo </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00125">125</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="af93bc80e68e10802d7a3db30f74c83a9" name="af93bc80e68e10802d7a3db30f74c83a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93bc80e68e10802d7a3db30f74c83a9">&#9670;&#160;</a></span>AddWeightedLiteralToLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddWeightedLiteralToLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>linear</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but with a single term (lit, coeff). Note that lit can be negative. The offset is relative to the linear expression (and should be negated when added to the rhs of the linear constraint proto). </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00646">646</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="adf1d6efbba26f23c1ce5565db2f78747" name="adf1d6efbba26f23c1ce5565db2f78747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1d6efbba26f23c1ce5565db2f78747">&#9670;&#160;</a></span>AddWeightedSumGreaterOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddWeightedSumGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enforcement_literals =&gt; sum &gt;= lower_bound </p>
<p>We just negate everything and use an &lt;= constraint.</p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00587">587</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a919cb1a74305a95883f51e95343ac474" name="a919cb1a74305a95883f51e95343ac474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919cb1a74305a95883f51e95343ac474">&#9670;&#160;</a></span>AddWeightedSumLowerOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AddWeightedSumLowerOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enforcement_literals =&gt; sum &lt;= upper_bound </p>
<p>Linear1.</p>
<p>Detect precedences with 2 and 3 terms.</p>
<p>If value == min(expression), then we can avoid creating the sum.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001853">Todo</a></b></dt><dd>(user): Deal with the case with no enforcement literal, in case the presolve was turned off? </dd></dl>
<p>Tricky: as we create integer literal, we might propagate stuff and the bounds might change, so if the expression_min increase with the bound we use, then the literal must be false.</p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00471">471</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a3b1ca976dc541e339d8e37f865108a1a" name="a3b1ca976dc541e339d8e37f865108a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1ca976dc541e339d8e37f865108a1a">&#9670;&#160;</a></span>AffineCoeffOneLowerOrEqualWithOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::AffineCoeffOneLowerOrEqualWithOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a + offset &lt;= b. (when a and b are of the form 1 * var + offset). </p>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00638">638</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="afb36a73833ef551ae994e2343cfff440" name="afb36a73833ef551ae994e2343cfff440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb36a73833ef551ae994e2343cfff440">&#9670;&#160;</a></span>AffineExpressionContainsVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AffineExpressionContainsVar </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the expression is a * var + b. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00237">237</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="aaa4b741a4583b289c5116e9f3ca38477" name="aaa4b741a4583b289c5116e9f3ca38477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4b741a4583b289c5116e9f3ca38477">&#9670;&#160;</a></span>AffineExpressionValueAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::AffineExpressionValueAt </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates an affine expression at the given value. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00220">220</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="adac2a1cac1b45c80f43ebd78490468a8" name="adac2a1cac1b45c80f43ebd78490468a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac2a1cac1b45c80f43ebd78490468a8">&#9670;&#160;</a></span>AllDifferentAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::AllDifferentAC </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>variables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constraint forces all variables to take different values. This is meant to be used as a complement to an alldifferent decomposition like <a class="el" href="#a6288159500a998e1cf1ed597f17685bd">AllDifferentBinary()</a>: DO NOT USE WITHOUT ONE. Doing the filtering that the decomposition can do with an appropriate algorithm should be cheaper and yield more accurate explanations.</p>
<p>It uses the matching algorithm described in Regin at AAAI1994: "A filtering algorithm for constraints of difference in CSPs".</p>
<p>This will fully encode variables. </p>

<p class="definition">Definition at line <a class="el" href="all__different_8cc_source.html#l00104">104</a> of file <a class="el" href="all__different_8cc_source.html">all_different.cc</a>.</p>

</div>
</div>
<a id="a6288159500a998e1cf1ed597f17685bd" name="a6288159500a998e1cf1ed597f17685bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6288159500a998e1cf1ed597f17685bd">&#9670;&#160;</a></span>AllDifferentBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::AllDifferentBinary </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enforces that the given tuple of variables takes different values. This fully encodes all the variables and simply enforces a &lt;= 1 constraint on each possible values. </p>
<p>Fully encode all the given variables and construct a mapping value -&gt; List of literal each indicating that a given variable takes this value.</p>
<dl class="section note"><dt>Note</dt><dd>we use a map to always add the constraints in the same order.</dd></dl>
<p>Add an at most one constraint for each value.</p>
<p>If the number of values is equal to the number of variables, we have a permutation. We can add a bool_or for each literals attached to a value.</p>

<p class="definition">Definition at line <a class="el" href="all__different_8cc_source.html#l00041">41</a> of file <a class="el" href="all__different_8cc_source.html">all_different.cc</a>.</p>

</div>
</div>
<a id="a089e01906c319c6ec58f26043d973916" name="a089e01906c319c6ec58f26043d973916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089e01906c319c6ec58f26043d973916">&#9670;&#160;</a></span>AllDifferentOnBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::AllDifferentOnBounds </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enforces that the given tuple of variables takes different values. Same as <a class="el" href="#a6288159500a998e1cf1ed597f17685bd">AllDifferentBinary()</a> but use a different propagator that only enforce the so called "bound consistency" on the variable domains.</p>
<p>Compared to <a class="el" href="#a6288159500a998e1cf1ed597f17685bd">AllDifferentBinary()</a> this doesn't require fully encoding the variables and it is also quite fast. Note that the propagation is different, this will not remove already taken values from inside a domain, but it will propagates more the domain bounds. </p>

<p class="definition">Definition at line <a class="el" href="all__different_8cc_source.html#l00087">87</a> of file <a class="el" href="all__different_8cc_source.html">all_different.cc</a>.</p>

</div>
</div>
<a id="ae2f2411ce337c1a67a4f1b2995f1f572" name="ae2f2411ce337c1a67a4f1b2995f1f572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f2411ce337c1a67a4f1b2995f1f572">&#9670;&#160;</a></span>AllDifferentOnBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::AllDifferentOnBounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="all__different_8cc_source.html#l00076">76</a> of file <a class="el" href="all__different_8cc_source.html">all_different.cc</a>.</p>

</div>
</div>
<a id="afc1129274beafb17b41ac2fa278de60c" name="afc1129274beafb17b41ac2fa278de60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1129274beafb17b41ac2fa278de60c">&#9670;&#160;</a></span>AllValuesInDomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoWithDomain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int64_t &gt; operations_research::sat::AllValuesInDomain </td>
          <td>(</td>
          <td class="paramtype">const ProtoWithDomain &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the list of values in a given domain. This will fail if the domain contains more than one millions values.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001623">Todo</a></b></dt><dd>(user): work directly on the <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> class instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00158">158</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a43f4e0c653d01e67ff65ec40eb96e2e5" name="a43f4e0c653d01e67ff65ec40eb96e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f4e0c653d01e67ff65ec40eb96e2e5">&#9670;&#160;</a></span>AnalyzeIntervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AnalyzeIntervals </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>transpose</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangle_energies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue *</td>          <td class="paramname"><span class="paramname"><em>x_threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue *</td>          <td class="paramname"><span class="paramname"><em>y_threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> *</td>          <td class="paramname"><span class="paramname"><em>conflict</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A O(n^2) algorithm to analyze all the relevant X intervals and infer a threshold of the y size of a bounding box after which there is no point checking for energy overload.</p>
<p>Returns false on conflict, and fill the bounding box that caused the conflict.</p>
<p>If transpose is true, we analyze the relevant Y intervals instead. </p>
<p>First, we compute the possible x_min values (removing duplicates). We also sort the relevant tasks by their x_max.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001707">Todo</a></b></dt><dd>(user): If the number of unique x_max is smaller than the number of unique x_min, it is better to do it the other way around. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>for the same end_max, the order change our heuristic to evaluate the max_conflict_height.</dd></dl>
<p>The maximum y dimension of a bounding area for which there is a potential conflict.</p>
<p>This is currently only used for logging.</p>
<p>All quantities at index j correspond to the interval [starts[j], x_max].</p>
<p>Sentinel.</p>
<p>Iterate over all boxes by increasing x_max values.</p>
<p>Add this box contribution to all the [starts[j], x_max] intervals.</p>
<p>If the new box is disjoint in y from the ones added so far, there cannot be a new conflict involving this box, so we skip until we add new boxes.</p>
<p>We have a conflict.</p>
<p>Because we currently do not have a conflict involving the new box, the only way to have one is to remove enough energy to reduce the y domain.</p>
<p>In this case, we need to remove at least old_energy_at_max to have a conflict.</p>
<p>If the new box height is above the conflict_height, do not count it now. We only need to consider conflict involving the new box.</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00238">238</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="ad309491270e74f942fb302a8159eac96" name="ad309491270e74f942fb302a8159eac96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad309491270e74f942fb302a8159eac96">&#9670;&#160;</a></span>AppendAtMostOneRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendAtMostOneRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00422">422</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="ac506719ca656893d93a2a6c940999265" name="ac506719ca656893d93a2a6c940999265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac506719ca656893d93a2a6c940999265">&#9670;&#160;</a></span>AppendBoolAndRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendBoolAndRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>activity_helper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002041">Todo</a></b></dt><dd>(user): These constraints can be many, and if they are not regrouped in big at most ones, then they should probably only added lazily as cuts. Regroup this with future clique-cut separation logic.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>for the case with only one enforcement, what we do below is already done by the clique merging code.</dd></dl>
<p>If we have many_literals =&gt; many_fixed literal, it is important to try to use a tight big-M if we can. This is important on neos-957323.pb.gz for instance.</p>
<p>We split the literal into disjoint AMO and we encode each with sum Not(literals) &lt;= sum Not(enforcement)</p>
<dl class="section note"><dt>Note</dt><dd>what we actually do is use the decomposition into at most one and add a constraint for each part rather than just adding the sum of them.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002042">Todo</a></b></dt><dd>(user): More generally, do not miss the same structure if the bool_and was expanded into many clauses!</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002043">Todo</a></b></dt><dd>(user): It is not 100% clear that just not adding one constraint is worse. Relaxation is worse, but then we have less constraint. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00353">353</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="af37670be970e606ec82f0b4bf5087f68" name="af37670be970e606ec82f0b4bf5087f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37670be970e606ec82f0b4bf5087f68">&#9670;&#160;</a></span>AppendBoolOrRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendBoolOrRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00339">339</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a96a4bad5ce59206034ac6d535f65e30f" name="a96a4bad5ce59206034ac6d535f65e30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a4bad5ce59206034ac6d535f65e30f">&#9670;&#160;</a></span>AppendCircuitRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendCircuitRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routing relaxation and cut generators. </p>
<p>Each node must have exactly one incoming and one outgoing arc (note that it can be the unique self-arc of this node too).</p>
<p>We separate the two constraints.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00493">493</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a0a55eff323f285ad2bc39449ca4623ae" name="a0a55eff323f285ad2bc39449ca4623ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a55eff323f285ad2bc39449ca4623ae">&#9670;&#160;</a></span>AppendCumulativeRelaxationAndCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendCumulativeRelaxationAndCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds linearization of cumulative constraints.The second part adds an energetic equation linking the duration of all potential tasks to the actual span * capacity of the cumulative constraint. </p>
<p>We remove the makespan data from the intervals the demands vector.</p>
<p>We try to linearize the energy of each task (size * demand).</p>
<p>We can now add the relaxation and the cut generators.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00754">754</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a99c02b5f23ff755783f84c851f8dcbb2" name="a99c02b5f23ff755783f84c851f8dcbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c02b5f23ff755783f84c851f8dcbb2">&#9670;&#160;</a></span>AppendElementEncodingRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendElementEncodingRelaxation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we have an exactly one between literals l_i, and each l_i =&gt; var == value_i, then we can add a strong linear relaxation: var = sum l_i * value_i.</p>
<p>This codes detect this and add the corresponding linear equations.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002059">Todo</a></b></dt><dd>(user): We can do something similar with just an at most one, however it is harder to detect that if all literal are false then none of the implied value can be taken. </dd></dl>
<p>If the term has no view, we abort.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01830">1830</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a12d9be5c1f94fcd416e5f582a8581789" name="a12d9be5c1f94fcd416e5f582a8581789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d9be5c1f94fcd416e5f582a8581789">&#9670;&#160;</a></span>AppendExactlyOneRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendExactlyOneRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We just encode the at most one part that might be partially linearized later.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00431">431</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a42d3ac4927f1adbca821091239fc06c7" name="a42d3ac4927f1adbca821091239fc06c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d3ac4927f1adbca821091239fc06c7">&#9670;&#160;</a></span>AppendLinearConstraintRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendLinearConstraintRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>linearize_enforced_constraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>activity_helper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends linear constraints to the relaxation. This also handles the relaxation of linear constraints with enforcement literals. A linear constraint lb &lt;= ax &lt;= ub with enforcement literals {ei} is relaxed as following. lb &lt;= (Sum Negated(ei) * (lb - implied_lb)) + ax &lt;= inf -inf &lt;= (Sum Negated(ei) * (ub - implied_ub)) + ax &lt;= ub Where implied_lb and implied_ub are trivial lower and upper bounds of the constraint. </p>
<dl class="section note"><dt>Note</dt><dd>we ignore the holes in the domain.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002051">Todo</a></b></dt><dd>(user): In <a class="el" href="#ade08c3522dfce173ee1fd50fab3bd3c0">LoadLinearConstraint()</a> we already created intermediate Booleans for each disjoint interval, we should reuse them here if possible.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002052">Todo</a></b></dt><dd>(user): process the "at most one" part of a == 1 separately? </dd></dl>
<p>Reified version.</p>
<p>We linearize fully reified constraints of size 1 all together for a given variable. But we need to process half-reified ones or constraint with more than one enforcement.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002053">Todo</a></b></dt><dd>(user): Use cleaner "already loaded" logic, and mark as such constraint already encoded by code like <a class="el" href="#af8a1aaff5bb36f1dfaf3daea8d5a076e">AppendRelaxationForEqualityEncoding()</a>. </dd></dl>
<p>Compute min/max activity.</p>
<p>Everything here should have a view.</p>
<p>And(ei) =&gt; terms &gt;= rhs_domain_min &lt;=&gt; Sum_i (~ei * (rhs_domain_min - min_activity)) + terms &gt;= rhs_domain_min</p>
<p>And(ei) =&gt; terms &lt;= rhs_domain_max &lt;=&gt; Sum_i (~ei * (rhs_domain_max - max_activity)) + terms &lt;= rhs_domain_max</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01238">1238</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a87160f650c0f35013f055fb81b3dfd30" name="a87160f650c0f35013f055fb81b3dfd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87160f650c0f35013f055fb81b3dfd30">&#9670;&#160;</a></span>AppendLinMaxRelaxationPart1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendLinMaxRelaxationPart1 </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds linearization of int max constraints. Returns a vector of z vars such that: z_vars[l] == 1 &lt;=&gt; target = exprs[l].</p>
<p>Consider the Lin Max constraint with d expressions and n variables in the form: target = max {exprs[l] = Sum (wli * xi + bl)}. l in {1,..,d}. Li = lower bound of xi Ui = upper bound of xi. Let zl be in {0,1} for all l in {1,..,d}. The target = exprs[l] when zl = 1.</p>
<p>The following is a valid linearization for Lin Max. target &gt;= exprs[l], for all l in {1,..,d} target &lt;= Sum_i(wki * xi) + Sum_l((Nkl + bl) * zl), for all k in {1,..,d} Where Nkl is a large number defined as: Nkl = Sum_i(max((wli - wki)*Li, (wli - wki)*Ui)) = Sum (max corner difference for variable i, target expr k, max expr l) Reference: "Strong mixed-integer programming formulations for trained neural
networks" by Ross Anderson et. (<a href="https://arxiv.org/pdf/1811.01988.pdf">https://arxiv.org/pdf/1811.01988.pdf</a>). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002066">Todo</a></b></dt><dd>(user): Support linear expression as target. </dd></dl>
<p>We want to linearize target = max(exprs[1], exprs[2], ..., exprs[d]). Part 1: Encode target &gt;= max(exprs[1], exprs[2], ..., exprs[d])</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01098">1098</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a2184e325fd181f15124aa91c55fb0159" name="a2184e325fd181f15124aa91c55fb0159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2184e325fd181f15124aa91c55fb0159">&#9670;&#160;</a></span>AppendLinMaxRelaxationPart2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendLinMaxRelaxationPart2 </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>alternative_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Part 2: Encode upper bound on X.</p>
<p>Add linking constraint to the CP solver sum zi = 1 and for all i, zi =&gt; max = expr_i. </p>
<p>First add the CP constraints.</p>
<p>For the relaxation, we use different constraints with a stronger linear relaxation as explained in the .h</p>
<p>Cache coefficients. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002050">Todo</a></b></dt><dd>(user): Remove hash_map ? </dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01164">1164</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a9d126152f7618c43746d3f56577b803e" name="a9d126152f7618c43746d3f56577b803e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d126152f7618c43746d3f56577b803e">&#9670;&#160;</a></span>AppendMaxAffineRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendMaxAffineRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002049">Todo</a></b></dt><dd>(user): experiment with: 1) remove this code 2) keep this code 3) remove this code and create the cut generator at level 1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only works if all affine expressions share the same variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01120">1120</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="acdadae230cef47ac321c22a5a880a85f" name="acdadae230cef47ac321c22a5a880a85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdadae230cef47ac321c22a5a880a85f">&#9670;&#160;</a></span>AppendNoOverlap2dRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendNoOverlap2dRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the energetic relaxation sum(areas) &lt;= bounding box area. </p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01055">1055</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a9e74cc2980a61d204f2d57d0add635de" name="a9e74cc2980a61d204f2d57d0add635de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e74cc2980a61d204f2d57d0add635de">&#9670;&#160;</a></span>AppendNoOverlap2dRelaxationForComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendNoOverlap2dRelaxationForComponent </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>component</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>no_overlap_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1ProductDecomposer.html">ProductDecomposer</a> *</td>          <td class="paramname"><span class="paramname"><em>product_decomposer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can happen if the box must be absent.</p>
<p>All boxes must be absent.</p>
<p>We have only one active literal.</p>
<p>Not including the term if we don't have a view is ok.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00987">987</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a04f93f235ccfb4d327b3e8ed40e43e3b" name="a04f93f235ccfb4d327b3e8ed40e43e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f93f235ccfb4d327b3e8ed40e43e3b">&#9670;&#160;</a></span>AppendNoOverlapRelaxationAndCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendNoOverlapRelaxationAndCutGenerator </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds linearization of no overlap constraints. It adds an energetic equation linking the duration of all potential tasks to the actual span of the no overlap constraint. </p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00717">717</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="ac4c9d3c5559f8abe31853de852a29cc4" name="ac4c9d3c5559f8abe31853de852a29cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c9d3c5559f8abe31853de852a29cc4">&#9670;&#160;</a></span>AppendPairwiseRestrictions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendPairwiseRestrictions </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>items</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>other_items</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1PairwiseRestriction.html">PairwiseRestriction</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but test <code>items</code> against <code>other_items</code> and append the restrictions found to <code>result</code>. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00663">663</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a6e15a14c74b4a487e85d5feb27e6ecb7" name="a6e15a14c74b4a487e85d5feb27e6ecb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15a14c74b4a487e85d5feb27e6ecb7">&#9670;&#160;</a></span>AppendPairwiseRestrictions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendPairwiseRestrictions </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>items</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1PairwiseRestriction.html">PairwiseRestriction</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find pair of items that are either in conflict or could have their range shrinked to avoid conflict. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00654">654</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a7a9cc392315b2fc7a18a373f496fe2b4" name="a7a9cc392315b2fc7a18a373f496fe2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9cc392315b2fc7a18a373f496fe2b4">&#9670;&#160;</a></span>AppendPartialGreaterThanEncodingRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendPartialGreaterThanEncodingRelaxation </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a different relaxation that use a partial set of literal li such that (li &lt;=&gt; var &gt;= xi). In which case we use the following encoding:</p><ul>
<li>li &gt;= l_{i+1} for all possible i. Note that the xi need to be sorted.</li>
<li>var &gt;= min + l0 * (x0 - min) + Sum_{i&gt;0} li * (xi - x_{i-1})</li>
<li>and same as above for NegationOf(var) for the upper bound.</li>
</ul>
<p>Like for <a class="el" href="#af8a1aaff5bb36f1dfaf3daea8d5a076e">AppendRelaxationForEqualityEncoding()</a> we skip any li that do not have an integer view. </p>
<p>Start by the var &gt;= side. And also add the implications between used literals.</p>
<p>Skip the entry if the literal doesn't have a view.</p>
<p>Add var &lt;= prev_var, which is the same as var + not(prev_var) &lt;= 1</p>
<dl class="section note"><dt>Note</dt><dd>by construction, this shouldn't be able to overflow.</dd></dl>
<p>Do the same for the var &lt;= side by using NegationOfVar(). </p><dl class="section note"><dt>Note</dt><dd>we do not need to add the implications between literals again.</dd></dl>
<p>Skip the entry if the literal doesn't have a view.</p>
<dl class="section note"><dt>Note</dt><dd>by construction, this shouldn't be able to overflow.</dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00268">268</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="af8a1aaff5bb36f1dfaf3daea8d5a076e" name="af8a1aaff5bb36f1dfaf3daea8d5a076e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a1aaff5bb36f1dfaf3daea8d5a076e">&#9670;&#160;</a></span>AppendRelaxationForEqualityEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendRelaxationForEqualityEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num_tight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num_loose</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks at all the encoding literal (li &lt;=&gt; var == value_i) that have a view and add a linear relaxation of their relationship with var.</p>
<p>If the encoding is full, we can just add:</p><ul>
<li>Sum li == 1</li>
<li>var == min_value + Sum li * (value_i - min_value)</li>
</ul>
<p>When the set of such encoding literals do not cover the full domain of var, we do something a bit more involved. Let min_not_encoded/max_not_encoded the min and max value of the domain of var that is NOT part of the encoding. We add:</p><ul>
<li>Sum li &lt;= 1</li>
<li>var &gt;= (Sum li * value_i) + (1 - Sum li) * min_not_encoded</li>
<li>var &lt;= (Sum li * value_i) + (1 - Sum li) * max_not_encoded</li>
</ul>
<p>Note of the special case where min_not_encoded == max_not_encoded that kind of reduce to the full encoding, except with a different "rhs" value.</p>
<p>We also increment the corresponding counter if we added something. We consider the relaxation "tight" if the encoding was full or if min_not_encoded == max_not_encoded. </p>
<dl class="section note"><dt>Note</dt><dd>we skip pairs that do not have an Integer view.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002040">Todo</a></b></dt><dd>(user): PartialDomainEncoding() filter pair corresponding to literal set to false, however the initial variable <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> is not always updated. As a result, these min/max can be larger than in reality. Try to fix this even if in practice this is a rare occurrence, as the presolve should have propagated most of what we can. </dd></dl>
<p>This means that there are no non-encoded value and we have a full encoding. We substract the minimum value to reduce its size.</p>
<p>It is possible that the linear1 encoding respect our overflow precondition but not the Var = sum bool * value one. In this case, we just don't encode it this way. Hopefully, most normal model will not run into this.</p>
<p>In this special case, the two constraints below can be merged into an equality: var = rhs + sum l_i * (value_i - rhs).</p>
<p>min + sum l_i * (value_i - min) &lt;= var. </p><dl class="section note"><dt>Note</dt><dd>this might overflow in corner cases, so we need to prevent that.</dd></dl>
<p>var &lt;= max + sum l_i * (value_i - max). </p><dl class="section note"><dt>Note</dt><dd>this might overflow in corner cases, so we need to prevent that.</dd>
<dd>
empty/trivial constraints will be filtered later.</dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00142">142</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a22f1824d3cc82601b5f801b74817b734" name="a22f1824d3cc82601b5f801b74817b734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f1824d3cc82601b5f801b74817b734">&#9670;&#160;</a></span>AppendRoutesRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendRoutesRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each node except node zero must have exactly one incoming and one outgoing arc (note that it can be the unique self-arc of this node too). For node zero, the number of incoming arcs should be the same as the number of outgoing arcs.</p>
<p>We separate the two constraints.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00531">531</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="abd42a035a99f910066d0a0356eff9ed6" name="abd42a035a99f910066d0a0356eff9ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd42a035a99f910066d0a0356eff9ed6">&#9670;&#160;</a></span>AppendSquareRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendSquareRelaxation </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a> is square == x * x.</p>
<p>We currently only support variables with non-negative domains.</p>
<p>Change the sigh of x if its domain is non-positive.</p>
<p>Check for potential overflows.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002056">Todo</a></b></dt><dd>(user): We could add all or some below_hyperplans. </dd></dl>
<p>The hyperplan will use x_ub - 1 and x_ub.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01541">1541</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a82da37638ef0ea4f3caa6c2fceb22b09" name="a82da37638ef0ea4f3caa6c2fceb22b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82da37638ef0ea4f3caa6c2fceb22b09">&#9670;&#160;</a></span>AppendVariablesFromCapacityAndDemands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::AppendVariablesFromCapacityAndDemands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IntegerVariable &gt; *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="scheduling__helpers_8cc_source.html#l01022">1022</a> of file <a class="el" href="scheduling__helpers_8cc_source.html">scheduling_helpers.cc</a>.</p>

</div>
</div>
<a id="a2afc11a07067fde98c2b4aa8c03b0cc0" name="a2afc11a07067fde98c2b4aa8c03b0cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afc11a07067fde98c2b4aa8c03b0cc0">&#9670;&#160;</a></span>ApplyLiteralMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ApplyLiteralMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; LiteralIndex, LiteralIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient *</td>          <td class="paramname"><span class="paramname"><em>bound_shift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient *</td>          <td class="paramname"><span class="paramname"><em>max_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps all the literals of the given constraint using the given mapping. The mapping may map a literal index to kTrueLiteralIndex or kFalseLiteralIndex in which case the literal will be considered fixed to the appropriate value.</p>
<dl class="section note"><dt>Note</dt><dd>this function also canonicalizes the constraint and updates bound_shift and max_value like <a class="el" href="#afe0ad26c40a4024f160695f2a504ff0a">ComputeBooleanLinearExpressionCanonicalForm()</a> does.</dd></dl>
<p>Finally, this will return false if some integer overflow or underflow occurred during the constraint simplification. </p>
<p>Nothing to do if the literal is false.</p>

<p class="definition">Definition at line <a class="el" href="pb__constraint_8cc_source.html#l00117">117</a> of file <a class="el" href="pb__constraint_8cc_source.html">pb_constraint.cc</a>.</p>

</div>
</div>
<a id="a1133b1086a2b84ebae1661a744df5a50" name="a1133b1086a2b84ebae1661a744df5a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1133b1086a2b84ebae1661a744df5a50">&#9670;&#160;</a></span>ApplyLiteralMappingToBooleanProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ApplyLiteralMappingToBooleanProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; LiteralIndex, LiteralIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearBooleanProblem *</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps all the literals of the problem. Note that this converts the cost of a variable correctly, that is if a variable with cost is mapped to another, the cost of the later is updated.</p>
<p>Preconditions: the mapping must map l and not(l) to the same variable and be of the correct size. It can also map a literal index to kTrueLiteralIndex or kFalseLiteralIndex in order to fix the variable. </p>
<p>First the objective.</p>
<p>Now the clauses.</p>
<p>Add bound_shift to the bounds and remove a bound if it is now trivial.</p>
<p>This is because ApplyLiteralMapping make all coefficient positive.</p>
<p>If the constraint is always true, we just leave it empty.</p>
<p>Remove empty constraints.</p>
<p>Computes the new number of variables and set it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001120">Todo</a></b></dt><dd>(user): The names is currently all scrambled. Do something about it so that non-fixed variables keep their names. </dd></dl>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00755">755</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a4659306bddf893dc09c5cd493f9a1fd4" name="a4659306bddf893dc09c5cd493f9a1fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4659306bddf893dc09c5cd493f9a1fd4">&#9670;&#160;</a></span>ApplyToAllIntervalIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ApplyToAllIntervalIndices </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(int *)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00414">414</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="ac103fdbdb9184cf86d2cfadf95b0dd67" name="ac103fdbdb9184cf86d2cfadf95b0dd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac103fdbdb9184cf86d2cfadf95b0dd67">&#9670;&#160;</a></span>ApplyToAllLiteralIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ApplyToAllLiteralIndices </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(int *)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00230">230</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="af703c0ffe9861cc773696e46ccff0a5f" name="af703c0ffe9861cc773696e46ccff0a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af703c0ffe9861cc773696e46ccff0a5f">&#9670;&#160;</a></span>ApplyToAllVariableIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ApplyToAllVariableIndices </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(int *)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the given function to all variables/literals/intervals indices of the constraint. This function is used in a few places to have a "generic" code dealing with constraints. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00293">293</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a2440a5de857e7ceae843c21bc723167c" name="a2440a5de857e7ceae843c21bc723167c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2440a5de857e7ceae843c21bc723167c">&#9670;&#160;</a></span>ApplyVariableMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ApplyVariableMapping </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>reverse_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces all the instance of a variable i (and the literals referring to it) by mapping[i]. The definition of variables i is also moved to its new index. If mapping[i] &lt; 0 the variable can be ignored if possible. If it is not possible, then we will use a new index for it (at the end) and the mapping will be updated to reflect that.</p>
<p>The image of the mapping should be dense in [0, reverse_mapping-&gt;size()). </p>
<p>Remap all the variable/literal references in the constraints and the enforcement literals in the variables.</p>
<p>We extend the mapping if this variable is still used.</p>
<p>Remap the objective variables.</p>
<p>Remap the assumptions.</p>
<p>Remap the symmetries. Note that we should have properly dealt with fixed orbit and such in <a class="el" href="#a7287180e6e143d0a2c6f6e6c206cc656">FilterOrbitOnUnusedOrFixedVariables()</a>.</p>
<p>We clear the orbitope info (we don't really use it after presolve).</p>
<dl class="section note"><dt>Note</dt><dd>For the rest of the mapping, if mapping[i] is -1, we can just ignore the variable instead of trying to map it.</dd></dl>
<p>Remap the search decision heuristic. </p><dl class="section note"><dt>Note</dt><dd>we delete any heuristic related to a removed variable.</dd></dl>
<p>Remove strategy with empty affine expression.</p>
<p>Remap the solution hint.</p>
<dl class="section note"><dt>Note</dt><dd>after remapping, we may have duplicate variables. For instance, identical constant variables are mapped to a single one. So we make sure we don't output duplicates here and just keep the first occurrence.</dd></dl>
<p>Move the variable definitions.</p>
<p>Check that all variables have a non-empty domain.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l13689">13689</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="ae756efa08d99803bb3fe591d43940a5b" name="ae756efa08d99803bb3fe591d43940a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae756efa08d99803bb3fe591d43940a5b">&#9670;&#160;</a></span>AtMinOrMaxInt64I()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::AtMinOrMaxInt64I </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00108">108</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a6bb183ffafc072d9fd0d52c6cc355993" name="a6bb183ffafc072d9fd0d52c6cc355993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb183ffafc072d9fd0d52c6cc355993">&#9670;&#160;</a></span>AtMinValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::AtMinValue </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *</td>          <td class="paramname"><span class="paramname"><em>integer_trail</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns decision corresponding to var at its lower bound. Returns an invalid literal if the variable is fixed. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00059">59</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="aafb2c90348e89a1658dc828e9449d926" name="aafb2c90348e89a1658dc828e9449d926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb2c90348e89a1658dc828e9449d926">&#9670;&#160;</a></span>AtMostOneConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::AtMostOneConstraint </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00932">932</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="adce32567c40d90f074ff693fa483ba9c" name="adce32567c40d90f074ff693fa483ba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce32567c40d90f074ff693fa483ba9c">&#9670;&#160;</a></span>AtMostOneDecomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; absl::Span&lt; int &gt; &gt; operations_research::sat::AtMostOneDecomposition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assuming n "literal" in [0, n), and a graph such that graph[i] list the literal in [0, n) implied to false when the literal with index i is true, this returns an heuristic decomposition of the literals into disjoint at most ones.</p>
<p>Note(user): Symmetrize the matrix if not already, maybe rephrase in term of undirected graph, and clique decomposition. </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00894">894</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="ae35ceb34b6366add1981140f6a173339" name="ae35ceb34b6366add1981140f6a173339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35ceb34b6366add1981140f6a173339">&#9670;&#160;</a></span>BasicOrbitopeExtraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; operations_research::sat::BasicOrbitopeExtraction </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>generators</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the generator for a permutation group of [0, n-1], tries to identify a grouping of the variables in an p x q matrix such that any permutations of the columns of this matrix is in the given group.</p>
<p>The name comes from: "Packing and Partitioning Orbitopes", Volker Kaibel, Marc E. Pfetsch, <a href="https://arxiv.org/abs/math/0603678">https://arxiv.org/abs/math/0603678</a> . Here we just detect it, independently of the constraints on the variables in this matrix. We can also detect non-Boolean orbitope.</p>
<p>In order to detect orbitope, this basic algorithm requires that the generators of the orbitope must only contain one or more 2-cyle (i.e transpositions). Thus they must be involutions. The list of transpositions in the <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> must also be listed in a canonical order.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002459">Todo</a></b></dt><dd>(user): Detect more than one orbitope? Note that once detected, the structure can be exploited efficiently, but for now, a more "generic" algorithm based on stabilizator should achieve the same preprocessing power, so I don't know how hard we need to invest in orbitope detection.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002460">Todo</a></b></dt><dd>(user): The heuristic is quite limited for now, but this works on graph20-20-1rand.mps.gz. I suspect the generators provided by the detection code follow our preconditions. </dd></dl>
<p>Count the number of permutations that are compositions of 2-cycle and regroup them according to the number of cycles.</p>
<p>Heuristic: we try to grow the orbitope that has the most potential for fixing variables.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002458">Todo</a></b></dt><dd>(user): We could grow each and keep the real maximum. </dd></dl>
<p>We will track the element already added so we never have duplicates.</p>
<p>Greedily grow the orbitope.</p>
<p>Start using the first permutation.</p>
<p>We want to find a column such that g sends it to variables not already in the orbitope matrix.</p>
<p>Note(user): This relies on the cycle in each permutation to be ordered by smaller element first. This way we don't have to account any row permutation of the orbitope matrix. The code that detect the symmetries of the problem should already return permutation in this canonical format.</p>
<p>Extract the two elements of this transposition.</p>
<p>We want one element to appear in matching_column_index and the other to not appear at all.</p>
<p>If grow is of full size, we can extend the orbitope.</p>

<p class="definition">Definition at line <a class="el" href="symmetry__util_8cc_source.html#l00031">31</a> of file <a class="el" href="symmetry__util_8cc_source.html">symmetry_util.cc</a>.</p>

</div>
</div>
<a id="ac341ac6090ff0bed8ad2231c94cd3bfc" name="ac341ac6090ff0bed8ad2231c94cd3bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac341ac6090ff0bed8ad2231c94cd3bfc">&#9670;&#160;</a></span>BooleanLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::BooleanLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> based functions.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002393">Todo</a></b></dt><dd>(user): move them in another file, and unit-test them. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00891">891</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a937ae99fd6f6c445a8aad34f04222a1a" name="a937ae99fd6f6c445a8aad34f04222a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937ae99fd6f6c445a8aad34f04222a1a">&#9670;&#160;</a></span>BooleanLinearExpressionIsCanonical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BooleanLinearExpressionIsCanonical </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cst</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the Boolean linear expression is in canonical form. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002127">Todo</a></b></dt><dd>(user): Also check for no duplicates literals + unit tests. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pb__constraint_8cc_source.html#l00150">150</a> of file <a class="el" href="pb__constraint_8cc_source.html">pb_constraint.cc</a>.</p>

</div>
</div>
<a id="a7a27047f906404c42b0f59a34ec50377" name="a7a27047f906404c42b0f59a34ec50377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a27047f906404c42b0f59a34ec50377">&#9670;&#160;</a></span>BooleanProblemToCpModelproto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpModelProto operations_research::sat::BooleanProblemToCpModelproto </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a LinearBooleanProblem to a CpModelProto which should eventually replace completely the LinearBooleanProblem proto. </p>
<dl class="section note"><dt>Note</dt><dd>the new format is slightly different.</dd></dl>
<p>The term was coeff * (1 - var).</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00164">164</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a417435f5c8fe96aa65045dd286a33503" name="a417435f5c8fe96aa65045dd286a33503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417435f5c8fe96aa65045dd286a33503">&#9670;&#160;</a></span>BoolPseudoCostHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::BoolPseudoCostHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant used for <a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html">LbTreeSearch</a> experimentation. Note that each decision is in O(num_variables), but it is kind of ok with <a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html">LbTreeSearch</a> as we only call this for "new" decision, not when we move around in the tree. </p>
<p>Only look at non-fixed booleans.</p>
<p>Get associated literal.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00207">207</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="aa7b5831e3d961be1c87854578abfa197" name="aa7b5831e3d961be1c87854578abfa197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b5831e3d961be1c87854578abfa197">&#9670;&#160;</a></span>BoxesAreInEnergyConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BoxesAreInEnergyConflict </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>energies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> *</td>          <td class="paramname"><span class="paramname"><em>conflict</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visible for testing. The algo is in O(n^4) so shouldn't be used directly. Returns true if there exist a bounding box with too much energy. </p>
<p>First consider all relevant intervals along the x axis.</p>
<p>Redo the same on the y coordinate for the current x interval which is [starts[j], x_max].</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00171">171</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a6dcc287ff62e3f8a4059720ec600fb79" name="a6dcc287ff62e3f8a4059720ec600fb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dcc287ff62e3f8a4059720ec600fb79">&#9670;&#160;</a></span>BoxesToShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1SingleShape.html">SingleShape</a> &gt; operations_research::sat::BoxesToShapes </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Neighbours.html">Neighbours</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbours</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of rectangles, split it into connected components and transform each individual set into a shape described by its boundary and holes paths. </p>
<p>Get edge most to the bottom left</p>
<p>The left-most vertical edge of the connected component must be of its exterior boundary. So we must always see the exterior boundary before seeing any holes.</p>
<p>Follow the usual convention that holes are in the inverse orientation of the external boundary.</p>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l00804">804</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="a4a25604744319c8a83fee36c10ff29f3" name="a4a25604744319c8a83fee36c10ff29f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a25604744319c8a83fee36c10ff29f3">&#9670;&#160;</a></span>BruteForceOrthogonalPacking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1BruteForceResult.html">BruteForceResult</a> operations_research::sat::BruteForceOrthogonalPacking </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; IntegerValue, IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>bounding_box_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_complexity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It is unlikely that preprocessing will remove half of the items, so don't lose time trying.</p>

<p class="definition">Definition at line <a class="el" href="2d__packing__brute__force_8cc_source.html#l00619">619</a> of file <a class="el" href="2d__packing__brute__force_8cc_source.html">2d_packing_brute_force.cc</a>.</p>

</div>
</div>
<a id="a1490b1b035faf1abe0893610f0bc0d90" name="a1490b1b035faf1abe0893610f0bc0d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1490b1b035faf1abe0893610f0bc0d90">&#9670;&#160;</a></span>BuildMaxAffineUpConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BuildMaxAffineUpConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; IntegerValue, IntegerValue &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>affines</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html">LinearConstraintBuilder</a> *</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper for the affine max constraint.</p>
<p>This function will reset the bounds of the builder. </p>
<p>target &lt;= y_at_min + (delta_y / delta_x) * (var - x_min) delta_x * target &lt;= delta_x * y_at_min + delta_y * (var - x_min) -delta_y * var + delta_x * target &lt;= delta_x * y_at_min - delta_y * x_min</p>
<p>Checks the rhs for overflows.</p>
<p>Checks target * delta_x for overflow.</p>
<p>Prevent to create constraints that can overflow.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02666">2666</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="acee4308da9f3f45757bd8dde329cd0f9" name="acee4308da9f3f45757bd8dde329cd0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee4308da9f3f45757bd8dde329cd0f9">&#9670;&#160;</a></span>BuildNeighboursGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Neighbours.html">Neighbours</a> operations_research::sat::BuildNeighboursGraph </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To build a graph of neighbours, we build a sorted vector for each one of the edges (top, bottom, etc) of the rectangles. Then we merge the bottom and top vectors and iterate on it. Due to the sorting order, segments where the bottom of a rectangle touches the top of another one must consecutive.</p>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l00467">467</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="a83443be9bcc967eec871d47ead6bfb73" name="a83443be9bcc967eec871d47ead6bfb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83443be9bcc967eec871d47ead6bfb73">&#9670;&#160;</a></span>CanonicalizeExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> operations_research::sat::CanonicalizeExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the same expression in the canonical form (all positive coefficients). </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00390">390</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a016498efd7ac3ee90eb0d00b38b0d061" name="a016498efd7ac3ee90eb0d00b38b0d061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016498efd7ac3ee90eb0d00b38b0d061">&#9670;&#160;</a></span>CanonicalizeLinearExpressionInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoWithVarsAndCoeffs, typename PresolveContextT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::CanonicalizeLinearExpressionInternal </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtoWithVarsAndCoeffs *</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int64_t &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>tmp_terms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PresolveContextT *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>First regroup the terms on the same variables and sum the fixed ones.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002219">Todo</a></b></dt><dd>(user): Add a quick pass to skip most of the work below if the constraint is already in canonical form? </dd></dl>
<p>Remove fixed variable and take affine representative.</p>
<dl class="section note"><dt>Note</dt><dd>we need to do that before we test for equality with an enforcement (they should already have been mapped).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002220">Todo</a></b></dt><dd>(user): Avoid the quadratic loop for the corner case of many enforcement literal (this should be pretty rare though). </dd></dl>
<p>If the constraint is enforced, we can assume the variable is at 1.</p>
<p>We can assume the variable is at zero.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02542">2542</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="afaf265c6d5bebf939210d9b8ce6943fd" name="afaf265c6d5bebf939210d9b8ce6943fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf265c6d5bebf939210d9b8ce6943fd">&#9670;&#160;</a></span>CanonicalizeTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CanonicalizeTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Canonicalizes the table constraint by removing all unreachable tuples, and all columns which have the same variable of a previous column.</p>
<p>This also sort all the tuples and remove all fixed columns from the table. </p>
<p>Make the trivial table constraint canonical.</p>
<p>Detect expressions sharing the same variable as a previous expression.</p>
<p>The mapping between the position in the original list of expressions, and the position in the reduced list of expressions.</p>
<p>Remove all scaling on expressions as we have stored the inner values.</p>
<p>The table was not empty from the beginning (we test it), but it became empty after removing all fixed variables. So either we also remove all the tuples, in which case there was no tuple that matched, or some tuple (of size 0!) remained and in this case we did find a match.</p>
<p>Add a trivially unsat (or trivially sat if negated) table constraint so code downstream can handle any eventual enforcement literals.</p>
<p>Write sorted tuples.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__table_8cc_source.html#l00034">34</a> of file <a class="el" href="cp__model__table_8cc_source.html">cp_model_table.cc</a>.</p>

</div>
</div>
<a id="a92716c99d1629cbb8717b4e0dec1dbc7" name="a92716c99d1629cbb8717b4e0dec1dbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92716c99d1629cbb8717b4e0dec1dbc7">&#9670;&#160;</a></span>CapAddI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::CapAddI </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00100">100</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="aeb5808dd3a993daef4c5d5e427097180" name="aeb5808dd3a993daef4c5d5e427097180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5808dd3a993daef4c5d5e427097180">&#9670;&#160;</a></span>CapProdI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::CapProdI </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overflows and saturated arithmetic. </p>

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00092">92</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="ae6cf8fbd59474ff6b4a19b2add7d2f4a" name="ae6cf8fbd59474ff6b4a19b2add7d2f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cf8fbd59474ff6b4a19b2add7d2f4a">&#9670;&#160;</a></span>CapSubI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::CapSubI </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00096">96</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="abf691c03cf07937979c23faa67c29d70" name="abf691c03cf07937979c23faa67c29d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf691c03cf07937979c23faa67c29d70">&#9670;&#160;</a></span>CardinalityConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::CardinalityConstraint </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00901">901</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a29b96869d2a821cf1d2e6099e7a0f51b" name="a29b96869d2a821cf1d2e6099e7a0f51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b96869d2a821cf1d2e6099e7a0f51b">&#9670;&#160;</a></span>CeilRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::CeilRatio </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>dividend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>positive_divisor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00072">72</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a3f5064fe335d0bd2f67a8c9e3e132b4f" name="a3f5064fe335d0bd2f67a8c9e3e132b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5064fe335d0bd2f67a8c9e3e132b4f">&#9670;&#160;</a></span>CeilSquareRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::CeilSquareRoot </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002494">Todo</a></b></dt><dd>(user): Find better implementation? </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00309">309</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="a6c8262482191c38e5e1490922b9d1c5f" name="a6c8262482191c38e5e1490922b9d1c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8262482191c38e5e1490922b9d1c5f">&#9670;&#160;</a></span>CenterToCenterL2Distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::CenterToCenterL2Distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the L2 distance between the centers of the two rectangles. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8h_source.html#l00135">135</a> of file <a class="el" href="diffn__util_8h_source.html">diffn_util.h</a>.</p>

</div>
</div>
<a id="a5038b1e77ef9a49c65fe0571c6b764d6" name="a5038b1e77ef9a49c65fe0571c6b764d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5038b1e77ef9a49c65fe0571c6b764d6">&#9670;&#160;</a></span>CenterToCenterLInfinityDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::CenterToCenterLInfinityDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diffn__util_8h_source.html#l00145">145</a> of file <a class="el" href="diffn__util_8h_source.html">diffn_util.h</a>.</p>

</div>
</div>
<a id="a5e72e8b29637efc57d3d9489078a5748" name="a5e72e8b29637efc57d3d9489078a5748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e72e8b29637efc57d3d9489078a5748">&#9670;&#160;</a></span>ChangeLargeBoundsToInfinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ChangeLargeBoundsToInfinity </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_magnitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPModelProto *</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function changes bounds of variables or constraints that have a magnitude greater than mip_max_valid_magnitude. </p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00237">237</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a67d84927df689473b8cf695784f58140" name="a67d84927df689473b8cf695784f58140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d84927df689473b8cf695784f58140">&#9670;&#160;</a></span>ChangeOptimizationDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ChangeOptimizationDirection </td>
          <td>(</td>
          <td class="paramtype">LinearBooleanProblem *</td>          <td class="paramname"><span class="paramname"><em>problem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keeps the same objective but change the optimization direction from a minimization problem to a maximization problem.</p>
<p>Ex: if the problem was to minimize 2 + x, the new problem will be to maximize 2 + x subject to exactly the same constraints. </p>
<p>We need 'auto' here to keep the open-source compilation happy (it uses the public protobuf release).</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00221">221</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a65bf93441e3921c23e072061b83abb08" name="a65bf93441e3921c23e072061b83abb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bf93441e3921c23e072061b83abb08">&#9670;&#160;</a></span>ChooseBestObjectiveValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::ChooseBestObjectiveValue </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *</td>          <td class="paramname"><span class="paramname"><em>integer_trail</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1ObjectiveDefinition.html">ObjectiveDefinition</a> *</td>          <td class="paramname"><span class="paramname"><em>objective_definition</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a variable appear in the objective, branch on its best objective value. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00066">66</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a6eccc333150afd49596f53fec23d2a4b" name="a6eccc333150afd49596f53fec23d2a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eccc333150afd49596f53fec23d2a4b">&#9670;&#160;</a></span>CircuitCovering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::CircuitCovering </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>distinguished_nodes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="circuit_8cc_source.html#l00709">709</a> of file <a class="el" href="circuit_8cc_source.html">circuit.cc</a>.</p>

</div>
</div>
<a id="a37093a0df3cca500d5f58b1d5482bdc6" name="a37093a0df3cca500d5f58b1d5482bdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37093a0df3cca500d5f58b1d5482bdc6">&#9670;&#160;</a></span>ClauseConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ClauseConstraint </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00947">947</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a445ddafc05cd8e1a75db81c1c4426179" name="a445ddafc05cd8e1a75db81c1c4426179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445ddafc05cd8e1a75db81c1c4426179">&#9670;&#160;</a></span>ClauseIsEnforcementImpliesLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ClauseIsEnforcementImpliesLiteral </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>clause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>literal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specific function. Returns true if the negation of all literals in clause except literal is exactly equal to the literal of enforcement.</p>
<p>We assumes that enforcement and negated(clause) are sorted lexicographically Or negated(enforcement) and clause. Both option works. If not, we will only return false more often. When we return true, the property is enforced.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002234">Todo</a></b></dt><dd>(user): For the same complexity, we do not need to specify literal and can recover it. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__util_8h_source.html#l00383">383</a> of file <a class="el" href="presolve__util_8h_source.html">presolve_util.h</a>.</p>

</div>
</div>
<a id="a9a8b9aa5e8f896a552de39960a007b86" name="a9a8b9aa5e8f896a552de39960a007b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8b9aa5e8f896a552de39960a007b86">&#9670;&#160;</a></span>CleanTermsAndFillConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CleanTermsAndFillConstraint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>terms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sort and add coeff of duplicate variables. Note that a variable and its negation will appear one after another in the natural order.</p>

<p class="definition">Definition at line <a class="el" href="sat_2linear__constraint_8h_source.html#l00378">378</a> of file <a class="el" href="sat_2linear__constraint_8h_source.html">linear_constraint.h</a>.</p>

</div>
</div>
<a id="a71dda16556ea20503fe019addd42f605" name="a71dda16556ea20503fe019addd42f605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71dda16556ea20503fe019addd42f605">&#9670;&#160;</a></span>CleanTermsAndFillConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CleanTermsAndFillConstraint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>terms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts and merges duplicate IntegerVariable in the given "terms". Fills the given <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> or <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> with the result. </p>
<p>Sort and add coeff of duplicate variables. Note that a variable and its negation will appear one after another in the natural order.</p>

<p class="definition">Definition at line <a class="el" href="sat_2linear__constraint_8h_source.html#l00347">347</a> of file <a class="el" href="sat_2linear__constraint_8h_source.html">linear_constraint.h</a>.</p>

</div>
</div>
<a id="ab45b9df04a0d18b7a12d062c2e7982c6" name="ab45b9df04a0d18b7a12d062c2e7982c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45b9df04a0d18b7a12d062c2e7982c6">&#9670;&#160;</a></span>ClosestMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::ClosestMultiple </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the multiple of base closest to value. If there is a tie, we return the one closest to zero. This way we have ClosestMultiple(x) = -ClosestMultiple(-x) which is important for how this is used. </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00317">317</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="a448193df35c1e481b2ad18e0fb097d8a" name="a448193df35c1e481b2ad18e0fb097d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448193df35c1e481b2ad18e0fb097d8a">&#9670;&#160;</a></span>CombineSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::CombineSeed </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base_seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We assume delta &gt;= 0 and we only use the low bit of delta. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l01015">1015</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a37db01bf814ae23bd4a029c9cee80992" name="a37db01bf814ae23bd4a029c9cee80992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37db01bf814ae23bd4a029c9cee80992">&#9670;&#160;</a></span>CompleteHeuristics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &gt; operations_research::sat::CompleteHeuristics </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>incomplete_heuristics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>completion_heuristic</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenates each input_heuristic with a default heuristic that instantiate all the problem's Boolean variables, into a new vector. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l01328">1328</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a1a88950631a19f96084df07209e43d30" name="a1a88950631a19f96084df07209e43d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a88950631a19f96084df07209e43d30">&#9670;&#160;</a></span>CompressTuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CompressTuples </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>domain_sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int64_t &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>tuples</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove duplicates if any.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__table_8cc_source.html#l00182">182</a> of file <a class="el" href="cp__model__table_8cc_source.html">cp_model_table.cc</a>.</p>

</div>
</div>
<a id="a03415c6fcb9dedc9b88bb92ae45b46a8" name="a03415c6fcb9dedc9b88bb92ae45b46a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03415c6fcb9dedc9b88bb92ae45b46a8">&#9670;&#160;</a></span>ComputeActivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::ComputeActivity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the activity of the given constraint. That is the current value of the linear terms. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00174">174</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="afe0ad26c40a4024f160695f2a504ff0a" name="afe0ad26c40a4024f160695f2a504ff0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0ad26c40a4024f160695f2a504ff0a">&#9670;&#160;</a></span>ComputeBooleanLinearExpressionCanonicalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ComputeBooleanLinearExpressionCanonicalForm </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient *</td>          <td class="paramname"><span class="paramname"><em>bound_shift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient *</td>          <td class="paramname"><span class="paramname"><em>max_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts the given Boolean linear expression in canonical form:</p><ul>
<li>Merge all the literal corresponding to the same variable.</li>
<li>Remove zero coefficients.</li>
<li>Make all the coefficients positive.</li>
<li>Sort the terms by increasing coefficient values.</li>
</ul>
<p>This function also computes:</p><ul>
<li>max_value: the maximum possible value of the formula.</li>
<li>bound_shift: which allows to updates initial bounds. That is, if an initial pseudo-Boolean constraint was lhs &lt; initial_pb_formula &lt; rhs then the new one is: lhs + bound_shift &lt; canonical_form &lt; rhs + bound_shift</li>
</ul>
<p>Finally, this will return false, if some integer overflow or underflow occurred during the reduction to the canonical form. </p>
<p>Note(user): For some reason, the IntType checking doesn't work here ?! that is a bit worrying, but the code seems to behave correctly.</p>
<p>First, sort by literal to remove duplicate literals. This also remove term with a zero coefficient.</p>
<p>Here current_literal is equal to (1 - representative).</p>
<p>Then, make all coefficients positive by replacing a term "-c x" into "c(1-x) - c" which is the same as "c(not x) - c".</p>
<p>Finally sort by increasing coefficients.</p>

<p class="definition">Definition at line <a class="el" href="pb__constraint_8cc_source.html#l00055">55</a> of file <a class="el" href="pb__constraint_8cc_source.html">pb_constraint.cc</a>.</p>

</div>
</div>
<a id="aa6c84ab8a0590875d286e1d518b804c9" name="aa6c84ab8a0590875d286e1d518b804c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c84ab8a0590875d286e1d518b804c9">&#9670;&#160;</a></span>ComputeCanonicalRhs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient operations_research::sat::ComputeCanonicalRhs </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>bound_shift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>max_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>From a constraint 'expr &lt;= ub' and the result (bound_shift, max_value) of calling <a class="el" href="#afe0ad26c40a4024f160695f2a504ff0a">ComputeBooleanLinearExpressionCanonicalForm()</a> on 'expr', this returns a new rhs such that 'canonical expression &lt;= rhs' is an equivalent constraint. This function deals with all the possible overflow corner cases.</p>
<p>The result will be in [-1, max_value] where -1 means unsatisfiable and max_value means trivialy satisfiable. </p>
<p>Positive overflow. The constraint is trivially true. This is because the canonical linear expression is in [0, max_value].</p>
<p>Negative overflow. The constraint is infeasible.</p>

<p class="definition">Definition at line <a class="el" href="pb__constraint_8cc_source.html#l00174">174</a> of file <a class="el" href="pb__constraint_8cc_source.html">pb_constraint.cc</a>.</p>

</div>
</div>
<a id="a55cf8284db404ce0040808a1d62f0c10" name="a55cf8284db404ce0040808a1d62f0c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cf8284db404ce0040808a1d62f0c10">&#9670;&#160;</a></span>ComputeCoreMinWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient operations_research::sat::ComputeCoreMinWeight </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>core</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum weight of the nodes in the core. Note that the literal in the core must appear in the same order as the one in nodes. </p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00562">562</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="af6a9258290419e520e0cb578b6bc3cf0" name="af6a9258290419e520e0cb578b6bc3cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a9258290419e520e0cb578b6bc3cf0">&#9670;&#160;</a></span>ComputeEnergyMinInWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::ComputeEnergyMinInWindow </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>start_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>start_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>end_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>end_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>size_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>demand_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>filtered_energy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>window_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>window_end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utilities </p>
<p>Returns zero if the interval do not necessarily overlap.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__helpers_8cc_source.html#l00682">682</a> of file <a class="el" href="scheduling__helpers_8cc_source.html">scheduling_helpers.cc</a>.</p>

</div>
</div>
<a id="a2d74e0ba57b88249516ace1c6d2dc546" name="a2d74e0ba57b88249516ace1c6d2dc546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d74e0ba57b88249516ace1c6d2dc546">&#9670;&#160;</a></span>ComputeGomoryHuTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::ComputeGomoryHuTree </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ArcWithLpValue.html">ArcWithLpValue</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>relevant_arcs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of arcs on a directed graph with n nodes (in [0, num_nodes)), returns a "parent" vector of size n encoding a rooted Gomory-Hu tree.</p>
<dl class="section note"><dt>Note</dt><dd>usually each edge in the tree is attached a max-flow value (its weight), but we don't need it here. It can be added if needed. This tree as the property that for all (s, t) pair of nodes, if you take the minimum weight edge on the path from s to t and split the tree in two, then this is a min-cut for that pair.</dd></dl>
<p>IMPORTANT: This algorithm currently "symmetrize" the graph, so we will actually have all the min-cuts that minimize sum incoming + sum outgoing lp values. The algo do not work as is on an asymmetric graph. Note however that because of flow conservation, our outgoing lp values should be the same as our incoming one on a circuit/route constraint.</p>
<p>We use a simple implementation described in "Very Simple Methods for All
Pairs Network Flow Analysis", Dan Gusfield, 1990, <a href="https://ranger.uta.edu/~weems/NOTES5311/LAB/LAB2SPR21/gusfield.huGomory.pdf">https://ranger.uta.edu/~weems/NOTES5311/LAB/LAB2SPR21/gusfield.huGomory.pdf</a> </p>
<p>Initialize the graph. Note that we use only arcs with a relevant lp value, so this should be small in practice.</p>
<p>Compute an equivalent max-flow tree, according to the paper. This version should actually produce a Gomory-Hu cut tree.</p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01132">1132</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="a9ae754b2aa285603335beca4d62587cc" name="a9ae754b2aa285603335beca4d62587cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae754b2aa285603335beca4d62587cc">&#9670;&#160;</a></span>ComputeHyperplanAboveSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> operations_research::sat::ComputeHyperplanAboveSquare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>square</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>x_lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>x_ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Above hyperplan for square = x * x: square should be below the line (x_lb, x_lb ^ 2) to (x_ub, x_ub ^ 2). The slope of that line is (ub^2 - lb^2) / (ub - lb) = ub + lb. square &lt;= (x_lb + x_ub) * x - x_lb * x_ub This only works for positive x. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l01969">1969</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a32c493e48e51fd4f652fbca14b34d587" name="a32c493e48e51fd4f652fbca14b34d587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c493e48e51fd4f652fbca14b34d587">&#9670;&#160;</a></span>ComputeHyperplanBelowSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> operations_research::sat::ComputeHyperplanBelowSquare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>square</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>x_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Below hyperplan for square = x * x: y should be above the line (x_value, x_value ^ 2) to (x_value + 1, (x_value + 1) ^ 2) The slope of that line is 2 * x_value + 1 square &gt;= below_slope * (x - x_value) + x_value ^ 2 square &gt;= below_slope * x - x_value ^ 2 - x_value </p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l01981">1981</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a3be9ba98c31d692caf42401992a0b4c3" name="a3be9ba98c31d692caf42401992a0b4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be9ba98c31d692caf42401992a0b4c3">&#9670;&#160;</a></span>ComputeInfinityNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::ComputeInfinityNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum absolute value of the coefficients. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00219">219</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a2979162c101d957e47f1ad97155a023e" name="a2979162c101d957e47f1ad97155a023e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2979162c101d957e47f1ad97155a023e">&#9670;&#160;</a></span>ComputeInnerObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::ComputeInnerObjective </td>
          <td>(</td>
          <td class="paramtype">const CpObjectiveProto &amp;</td>          <td class="paramname"><span class="paramname"><em>objective</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the "inner" objective of a response that contains a solution. This is the objective without offset and scaling. Call <a class="el" href="#a6c7910e5ccb41edc8f442a682890cb31" title="Scales back a objective value to a double value from the original model.">ScaleObjectiveValue()</a> to get the user facing objective. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00602">602</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a268155d48da53ccd81c49ee890c8e75f" name="a268155d48da53ccd81c49ee890c8e75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268155d48da53ccd81c49ee890c8e75f">&#9670;&#160;</a></span>ComputeL2Norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::ComputeL2Norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns sqrt(sum square(coeff)). </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00211">211</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a34cc8829256ea003a3f538b06d3a3a74" name="a34cc8829256ea003a3f538b06d3a3a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cc8829256ea003a3f538b06d3a3a74">&#9670;&#160;</a></span>ComputeLinearRelaxation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> operations_research::sat::ComputeLinearRelaxation </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the linear relaxation of a CpModelProto. </p>
<p>Collect AtMostOne to compute better Big-M.</p>
<p>Linearize the constraints.</p>
<p>Linearize the encoding of variable that are fully encoded.</p>
<p>We first try to linearize the values encoding.</p>
<p>Then we try to linearize the inequality encoding. Note that on some problem like pizza27i.mps.gz, adding both equality and inequality encoding is a must.</p>
<p>Even if the variable is fully encoded, sometimes not all its associated literal have a view (if they are not part of the original model for instance).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002060">Todo</a></b></dt><dd>(user): Should we add them to the LP anyway? this isn't clear as we can sometimes create a lot of Booleans like this. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002061">Todo</a></b></dt><dd>(user): This is similar to <a class="el" href="#af8a1aaff5bb36f1dfaf3daea8d5a076e">AppendRelaxationForEqualityEncoding()</a> above. Investigate if we can merge the code. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002062">Todo</a></b></dt><dd>(user): I am not sure this is still needed. Investigate and explain why or remove. </dd></dl>
<p>We display the stats before linearizing the at most ones.</p>
<p>Linearize the at most one constraints. Note that we transform them into maximum "at most one" first and we removes redundant ones.</p>
<dl class="section note"><dt>Note</dt><dd>it is okay to simply ignore the literal if it has no integer view.</dd></dl>
<p>We converted all at_most_one to LP constraints, so we need to clear them so that we don't do extra work in the connected component computation.</p>
<p>Propagate unary constraints.</p>
<p>Remove size one LP constraints from the main algorithms, they are not useful.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01872">1872</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a8dc1657dd321ca86c667f100053768da" name="a8dc1657dd321ca86c667f100053768da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc1657dd321ca86c667f100053768da">&#9670;&#160;</a></span>ComputeMinSumOfWeightedEndMins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ComputeMinSumOfWeightedEndMins </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1PermutableEvent.html">PermutableEvent</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>capacity_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue &amp;</td>          <td class="paramname"><span class="paramname"><em>min_sum_of_end_mins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue &amp;</td>          <td class="paramname"><span class="paramname"><em>min_sum_of_weighted_end_mins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>unweighted_threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>weighted_threshold</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reusable storage for ComputeWeightedSumOfEndMinsForOnePermutation().</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l01107">1107</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a530ca58b0a7104b907a8933f8704dce8" name="a530ca58b0a7104b907a8933f8704dce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530ca58b0a7104b907a8933f8704dce8">&#9670;&#160;</a></span>ComputeNegatedCanonicalRhs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient operations_research::sat::ComputeNegatedCanonicalRhs </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>bound_shift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>max_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#aa6c84ab8a0590875d286e1d518b804c9">ComputeCanonicalRhs()</a>, but uses the initial constraint lower bound instead. From a constraint 'lb &lt;= expression', this returns a rhs such that 'canonical expression with literals negated &lt;= rhs'.</p>
<dl class="section note"><dt>Note</dt><dd>the range is also [-1, max_value] with the same meaning. </dd></dl>
<p>The new bound is "max_value - (lower_bound + bound_shift)", but we must pay attention to possible overflows.</p>
<p>Positive overflow. The constraint is infeasible.</p>
<p>Negative overflow. The constraint is trivialy satisfiable.</p>
<p>If shifted_lb &lt;= 0 then the constraint is trivialy satisfiable. We test this so we are sure that max_value - shifted_lb doesn't overflow below.</p>

<p class="definition">Definition at line <a class="el" href="pb__constraint_8cc_source.html#l00192">192</a> of file <a class="el" href="pb__constraint_8cc_source.html">pb_constraint.cc</a>.</p>

</div>
</div>
<a id="ad8a94daf3536dd065dd3d6660e14ae43" name="ad8a94daf3536dd065dd3d6660e14ae43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a94daf3536dd065dd3d6660e14ae43">&#9670;&#160;</a></span>ComputeObjectiveValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient operations_research::sat::ComputeObjectiveValue </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the objective value under the current assignment. </p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00359">359</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="adb6db4124c1030575ede339b237d9e68" name="adb6db4124c1030575ede339b237d9e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6db4124c1030575ede339b237d9e68">&#9670;&#160;</a></span>ComputeResolvant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ComputeResolvant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visible for testing. Computes the resolvant of 'a' and 'b' obtained by performing the resolution on 'x'. If the resolvant is trivially true this returns false, otherwise it returns true and fill 'out' with the resolvant.</p>
<dl class="section note"><dt>Note</dt><dd>the resolvant is just 'a' union 'b' with the literals 'x' and not(x) removed. The two clauses are assumed to be sorted, and the computed resolvant will also be sorted.</dd></dl>
<p>This is the basic operation when a variable is eliminated by clause distribution. </p>
<p>Copy remaining literals.</p>

<p class="definition">Definition at line <a class="el" href="simplification_8cc_source.html#l01023">1023</a> of file <a class="el" href="simplification_8cc_source.html">simplification.cc</a>.</p>

</div>
</div>
<a id="aa4e10d7ec51fc3637bb6d86f3703ab80" name="aa4e10d7ec51fc3637bb6d86f3703ab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e10d7ec51fc3637bb6d86f3703ab80">&#9670;&#160;</a></span>ComputeResolvantSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::ComputeResolvantSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>this function takes a big chunk of the presolve running time.</dd></dl>
<p>Same as <a class="el" href="#adb6db4124c1030575ede339b237d9e68">ComputeResolvant()</a> but just returns the resolvant size. Returns -1 when <a class="el" href="#adb6db4124c1030575ede339b237d9e68">ComputeResolvant()</a> returns false. </p>

<p class="definition">Definition at line <a class="el" href="simplification_8cc_source.html#l01058">1058</a> of file <a class="el" href="simplification_8cc_source.html">simplification.cc</a>.</p>

</div>
</div>
<a id="a3be15b4e667753185cda0c0d9315b5ad" name="a3be15b4e667753185cda0c0d9315b5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be15b4e667753185cda0c0d9315b5ad">&#9670;&#160;</a></span>ComputeSignatureAndMaxElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, int &gt; operations_research::sat::ComputeSignatureAndMaxElement </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the signature and the maximum element. We want a signature that is order invariant and is compatible with inclusion. </p>

<p class="definition">Definition at line <a class="el" href="inclusion_8h_source.html#l00269">269</a> of file <a class="el" href="inclusion_8h_source.html">inclusion.h</a>.</p>

</div>
</div>
<a id="ac47959359a009b02531ab19f206cdd54" name="ac47959359a009b02531ab19f206cdd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47959359a009b02531ab19f206cdd54">&#9670;&#160;</a></span>ComputeTrueObjectiveLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::ComputeTrueObjectiveLowerBound </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto_with_floating_point_objective</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpObjectiveProto &amp;</td>          <td class="paramname"><span class="paramname"><em>integer_objective</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>inner_integer_objective_lower_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a CpModelProto with a floating point objective, and its scaled integer version with a known lower bound, this uses the variable bounds to derive a correct lower bound on the original objective.</p>
<dl class="section note"><dt>Note</dt><dd>the integer version can be way different, but then the bound is likely to be bad. For now, we solve this with a simple LP with one constraint.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002080">Todo</a></b></dt><dd>(user): Code a custom algo with more precision guarantee? </dd></dl>
<p>Create an LP with the correct variable domain.</p>
<p>Add the original problem floating point objective. This is user given, so we do need to deal with duplicate entries.</p>
<p>Add a single constraint "integer_objective &gt;= lower_bound".</p>
<p>This should be fast. However, in case of numerical difficulties, we bound the number of iterations.</p>
<p>Error. Hoperfully this shouldn't happen.</p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l01703">1703</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="af9deb88b5fd44c96982ebf16eee8ddd2" name="af9deb88b5fd44c96982ebf16eee8ddd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9deb88b5fd44c96982ebf16eee8ddd2">&#9670;&#160;</a></span>ConditionalLowerOrEqualWithOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ConditionalLowerOrEqualWithOffset </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>is_le</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is_le =&gt; (a + offset &lt;= b). </p>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00706">706</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="a965ac7991d6f213cb8398a43575dbf6d" name="a965ac7991d6f213cb8398a43575dbf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965ac7991d6f213cb8398a43575dbf6d">&#9670;&#160;</a></span>ConditionalWeightedSumGreaterOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ConditionalWeightedSumGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00613">613</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a6789b92ff0403313af6cb313636d1317" name="a6789b92ff0403313af6cb313636d1317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6789b92ff0403313af6cb313636d1317">&#9670;&#160;</a></span>ConditionalWeightedSumLowerOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ConditionalWeightedSumLowerOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001854">Todo</a></b></dt><dd>(user): Delete once Telamon use new function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00599">599</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a08ac4c44a4524b21806a1ae9839bc5bd" name="a08ac4c44a4524b21806a1ae9839bc5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ac4c44a4524b21806a1ae9839bc5bd">&#9670;&#160;</a></span>ConfigureSearchHeuristics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ConfigureSearchHeuristics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a base "fixed_search" function that should mainly control in which order integer variables are lazily instantiated (and at what value), this uses the current solver parameters to set the <a class="el" href="structoperations__research_1_1sat_1_1SearchHeuristics.html">SearchHeuristics</a> class in the given model. </p>
<p>Not all Boolean might appear in fixed_search(), so once there is no decision left, we fix all Booleans that are still undecided.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001885">Todo</a></b></dt><dd>(user): We might want to restart if external info is available. Code a custom restart for this? </dd></dl>
<p>Push user search if present.</p>
<p>Do a portfolio with the default sat heuristics.</p>
<p>Use default restart policies.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l01206">1206</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a64664019450638ab96732f0b59ea015b" name="a64664019450638ab96732f0b59ea015b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64664019450638ab96732f0b59ea015b">&#9670;&#160;</a></span>ConstantIntegerVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ConstantIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01483">1483</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ab77c8edd75ecda9e91f2a9a02af6adca" name="ab77c8edd75ecda9e91f2a9a02af6adca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77c8edd75ecda9e91f2a9a02af6adca">&#9670;&#160;</a></span>ConstraintCaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::string_view operations_research::sat::ConstraintCaseName </td>
          <td>(</td>
          <td class="paramtype">ConstraintProto::ConstraintCase</td>          <td class="paramname"><span class="paramname"><em>constraint_case</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the ConstraintProto::ConstraintCase oneof enum. Note(user): There is no such function in the proto API as of 16/01/2017. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00475">475</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a3f808a9d169b2b074a23d52cc86f18aa" name="a3f808a9d169b2b074a23d52cc86f18aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f808a9d169b2b074a23d52cc86f18aa">&#9670;&#160;</a></span>ConstraintIsFeasible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ConstraintIsFeasible </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>variable_values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks a single constraint for feasibility. This has some overhead, and should only be used for debugging. The full model is needed for scheduling constraints that refers to intervals. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__checker_8cc_source.html#l01857">1857</a> of file <a class="el" href="cp__model__checker_8cc_source.html">cp_model_checker.cc</a>.</p>

</div>
</div>
<a id="a50803a36792e1ce5b1dfada9166766a7" name="a50803a36792e1ce5b1dfada9166766a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50803a36792e1ce5b1dfada9166766a7">&#9670;&#160;</a></span>ConstructFixedSearchStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::ConstructFixedSearchStrategy </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>user_search</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>heuristic_search</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>integer_completion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs our "fixed" search strategy which start with <a class="el" href="#ab621abdbab919d365ca747aebdd2ff74" title="Constructs the search strategy specified in the given CpModelProto.">ConstructUserSearchStrategy()</a> but is completed by a couple of automatic heuristics. </p>
<p>We start by the user specified heuristic.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00429">429</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a807f0da8a99a471e809213176132588f" name="a807f0da8a99a471e809213176132588f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807f0da8a99a471e809213176132588f">&#9670;&#160;</a></span>ConstructHeuristicSearchStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::ConstructHeuristicSearchStrategy </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>cp_model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a search strategy tailored for the current model. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001511">Todo</a></b></dt><dd>(user): Implement a routing search. </dd></dl>
<p>Tricky: we need to create this at level zero in case there are no linear constraint in the model at the beginning.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001512">Todo</a></b></dt><dd>(user): Alternatively, support creation of <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints.">SatPropagator</a> at positive level. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00354">354</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a5465fbc93435e155dd99a36283155a5c" name="a5465fbc93435e155dd99a36283155a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5465fbc93435e155dd99a36283155a5c">&#9670;&#160;</a></span>ConstructHintSearchStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::ConstructHintSearchStrategy </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>cp_model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1CpModelMapping.html">CpModelMapping</a> *</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a search strategy that follow the hint from the model. </p>
<p>Constructs a search strategy that follows the hints from the model. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00410">410</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a40aa243acb668c453deb8600ab80b38a" name="a40aa243acb668c453deb8600ab80b38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aa243acb668c453deb8600ab80b38a">&#9670;&#160;</a></span>ConstructIntegerCompletionSearchStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::ConstructIntegerCompletionSearchStrategy </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>variable_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>objective_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an integer completion search strategy. </p>
<p>Make sure we try to fix the objective to its lowest value first. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001513">Todo</a></b></dt><dd>(user): we could also fix terms of the objective in the right direction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00385">385</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a7ca3e1768bf680ee6b3bbec72f4d0955" name="a7ca3e1768bf680ee6b3bbec72f4d0955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca3e1768bf680ee6b3bbec72f4d0955">&#9670;&#160;</a></span>ConstructOverlappingSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ConstructOverlappingSets </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; <a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html">IndexedInterval</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>intervals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1CompactVectorVector.html">CompactVectorVector</a>&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given n fixed intervals that must be sorted by IndexedInterval::ComparatorByStart(), returns the subsets of intervals that overlap during at least one time unit. Note that we only return "maximal" subset and filter subset strictly included in another.</p>
<p>IMPORTANT: The span of intervals will not be usable after this function! this could be changed if needed with an extra copy.</p>
<p>All Intervals must have a positive size.</p>
<p>The algo is in O(n log n) + O(result_size) which is usually O(n^2).</p>
<p>If the last argument is not empty, we will sort the interval in the result according to the given order, i.e. i will be before j if order[i] &lt; order[j]. </p>
<p>We do a line sweep. The "current" subset crossing the "line" at (time, time + 1) will be in (*intervals)[start_index, end_index) at the end of the loop block.</p>
<p>First, if there is some deletion, we will push the "old" set to the result before updating it. Otherwise, we will have a superset later, so we just continue for now.</p>
<p>Push the current set to result first if its size is &gt; 1.</p>
<p>Update the set. Note that we keep the order.</p>
<p>Add all the new intervals starting exactly at "time". </p><dl class="section note"><dt>Note</dt><dd>we always add at least one here.</dd></dl>
<p>If order is not empty, make sure we maintain the order. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001708">Todo</a></b></dt><dd>(user): we could only do that when we push a new set. </dd></dl>
<p>Push final set.</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00428">428</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="ab621abdbab919d365ca747aebdd2ff74" name="ab621abdbab919d365ca747aebdd2ff74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab621abdbab919d365ca747aebdd2ff74">&#9670;&#160;</a></span>ConstructUserSearchStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::ConstructUserSearchStrategy </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>cp_model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the search strategy specified in the given CpModelProto. </p>
<dl class="section note"><dt>Note</dt><dd>we copy strategies to keep the return function validity independently of the life of the passed vector.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001510">Todo</a></b></dt><dd>(user): Improve the complexity if this becomes an issue which may be the case if we do a fixed_search. </dd></dl>
<p>To store equivalent variables in randomized search.</p>
<p>The size of the domain is not multiplied by the coeff.</p>
<p>The size of the domain is not multiplied by the coeff.</p>
<p>We need to use -value as we want the minimum valued variables. We add a random noise to get improve the entropy.</p>
<p>We can stop scanning if the variable selection strategy is to use the first unbound variable and no randomization is needed.</p>
<p>Check if one active variable has been found.</p>
<p>Pick the winner when decisions are randomized.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00209">209</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="ac63affeaff6ccd82933aa13529338857" name="ac63affeaff6ccd82933aa13529338857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63affeaff6ccd82933aa13529338857">&#9670;&#160;</a></span>ContainsLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ContainsLiteral </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>clause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>literal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given clause contains the given literal. This works in O(clause.size()). </p>

<p class="definition">Definition at line <a class="el" href="drat__checker_8cc_source.html#l00474">474</a> of file <a class="el" href="drat__checker_8cc_source.html">drat_checker.cc</a>.</p>

</div>
</div>
<a id="aa97f36cf2700f25a17eb5f3370df6b11" name="aa97f36cf2700f25a17eb5f3370df6b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97f36cf2700f25a17eb5f3370df6b11">&#9670;&#160;</a></span>ConvertBinaryMPModelProtoToBooleanProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ConvertBinaryMPModelProtoToBooleanProblem </td>
          <td>(</td>
          <td class="paramtype">const MPModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearBooleanProblem *</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an integer program with only binary variables to a Boolean optimization problem. Returns false if the problem didn't contains only binary integer variable, or if the coefficients couldn't be converted to integer with a good enough precision. </p>
<p>Test if the variables are binary variables. Add constraints for the fixed variables.</p>
<p>This will be changed to false as soon as we detect the variable to be non-binary. This is done this way so we can display a nice error message before aborting the function and returning false.</p>
<p>4 cases.</p>
<p>Binary variable. Ok.</p>
<p>Fixed variable at 1.</p>
<p>Fixed variable at 0.</p>
<p>No possible integer value!</p>
<p>Abort if the variable is not binary.</p>
<p>Variables needed to scale the double coefficients into int64_t.</p>
<p>Add all constraints.</p>
<p>First scale the coefficients of the constraints.</p>
<p>Add the bounds. Note that we do not pass them to <a class="el" href="namespaceoperations__research.html#a20f1b86022ab6b187d9e205fc308eb39">GetBestScalingOfDoublesToInt64()</a> because we know that the sum of absolute coefficients of the constraint fit on an int64_t. If one of the scaled bound overflows, we don't care by how much because in this case the constraint is just trivial or unsatisfiable.</p>
<p>Otherwise, the constraint is not needed.</p>
<p>Otherwise, the constraint is not needed.</p>
<p>Display the error/scaling without taking into account the objective first.</p>
<p>Add the objective.</p>
<p>Display the objective error/scaling.</p>
<dl class="section note"><dt>Note</dt><dd>here we set the scaling factor for the inverse operation of getting the "true" objective value from the scaled one. Hence the inverse.</dd></dl>
<p>If the problem was a maximization one, we need to modify the objective.</p>
<p>Test the precision of the conversion.</p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l01460">1460</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a3813521303490a81cc8585dc4dc13daa" name="a3813521303490a81cc8585dc4dc13daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3813521303490a81cc8585dc4dc13daa">&#9670;&#160;</a></span>ConvertBooleanProblemToLinearProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ConvertBooleanProblemToLinearProgram </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html">glop::LinearProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>lp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a Boolean optimization problem to its lp formulation. </p>
<p>Variables name are optional.</p>
<p>Objective.</p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l01639">1639</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a6da39a32345d2a2c18a62bb356bfd3b3" name="a6da39a32345d2a2c18a62bb356bfd3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da39a32345d2a2c18a62bb356bfd3b3">&#9670;&#160;</a></span>ConvertCpModelProtoToCnf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ConvertCpModelProtoToCnf </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>cp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We should have no objective, only unassigned Boolean, and only bool_or and bool_and.</p>
<p>We can convert.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00958">958</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="ac9c41d8a7687386839ef94182e3badb9" name="ac9c41d8a7687386839ef94182e3badb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c41d8a7687386839ef94182e3badb9">&#9670;&#160;</a></span>ConvertCpModelProtoToMPModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ConvertCpModelProtoToMPModelProto </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPModelProto *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a CP-SAT model to a MPModelProto one. This only works for pure linear model (otherwise it returns false). This is mainly useful for debugging or using CP-SAT presolve and then trying other MIP solvers.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002079">Todo</a></b></dt><dd>(user): This first version do not even handle basic Boolean constraint. Support more constraints as needed. </dd></dl>
<p>Copy variables.</p>
<p>Copy integer or float objective.</p>
<p>Copy constraint.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002072">Todo</a></b></dt><dd>(user): Support more constraints with enforcement. </dd></dl>
<p>Compute min/max activity.</p>
<p>term &lt;= ub + coeff * (1 - enf);</p>
<p>term &gt;= lb + coeff * (1 - enf)</p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l01150">1150</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a2d32bfb7e130364f3dd94087b686b6f5" name="a2d32bfb7e130364f3dd94087b686b6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d32bfb7e130364f3dd94087b686b6f5">&#9670;&#160;</a></span>ConvertMPModelProtoToCpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ConvertMPModelProtoToCpModelProto </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>cp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a MIP problem to a CpModel. Returns false if the coefficients couldn't be converted to integers with a good enough precision.</p>
<p>There is a bunch of caveats and you can find more details on the SatParameters proto documentation for the mip_* parameters. </p>
<p>To make sure we cannot have integer overflow, we use this bound for any unbounded variable.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002070">Todo</a></b></dt><dd>(user): This could be made larger if needed, so be smarter if we have MIP problem that we cannot "convert" because of this. Note however than we cannot go that much further because we need to make sure we will not run into overflow if we add a big linear combination of such variables. It should always be possible for a user to scale its problem so that all relevant quantities are a couple of millions. A LP/MIP solver have a similar condition in disguise because problem with a difference of more than 6 magnitudes between the variable values will likely run into numeric trouble. </dd></dl>
<p>Add the variables.</p>
<p>Deal with the corner case of a domain far away from zero.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002071">Todo</a></b></dt><dd>(user): We could avoid these cases by shifting the domain of all variables to contain zero. This should also lead to a better scaling, but it has some complications with integer variables and require some post-solve. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>we must process the lower bound first.</dd>
<dd>
the cast is "perfect" because we forbid large values.</dd></dl>
<p>Notify if a continuous variable has a small domain as this is likely to make an all integer solution far from a continuous one.</p>
<p>Add the constraints. We scale each of them individually.</p>
<p>Add the indicator.</p>
<p>Display the error/scaling on the constraints.</p>
<p>Since cp_model support a floating point objective, we use that. This will allow us to scale the objective a bit later so we can potentially do more domain reduction first.</p>
<p>If the objective is fixed to zero, we consider there is none.</p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00933">933</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="ab5349a83e5dcf17ebb4862cd15f9d595" name="ab5349a83e5dcf17ebb4862cd15f9d595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5349a83e5dcf17ebb4862cd15f9d595">&#9670;&#160;</a></span>CopyEverythingExceptVariablesAndConstraintsFieldsIntoContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CopyEverythingExceptVariablesAndConstraintsFieldsIntoContext </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>in_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the non constraint, non variables part of the model. </p>
<p>We make sure we do not use the old variables field.</p>
<p>We make sure the hint is within the variables domain.</p>
<p>This allows to avoid overflow because we know evaluating constraints on the variables domains should be safe thanks to the initial validation.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__copy_8cc_source.html#l00922">922</a> of file <a class="el" href="cp__model__copy_8cc_source.html">cp_model_copy.cc</a>.</p>

</div>
</div>
<a id="a287579e5f181fc7c89feccf1128faffb" name="a287579e5f181fc7c89feccf1128faffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287579e5f181fc7c89feccf1128faffb">&#9670;&#160;</a></span>CpModelStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::CpModelStats </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with some statistics on the given CpModelProto. </p>
<p>Public API. </p>
<dl class="section note"><dt>Note</dt><dd>we only store pointer to "constant" string literals. This is slightly faster and take less space for model with millions of constraints.</dd></dl>
<p>We split the linear constraints into 3 buckets has it gives more insight on the type of problem we are facing.</p>
<p>For pure Boolean constraints, we also display the total number of literal involved as this gives a good idea of the problem size.</p>
<p>We always list Boolean first.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l00272">272</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a864c163d77d4ede1b9111a426493a497" name="a864c163d77d4ede1b9111a426493a497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864c163d77d4ede1b9111a426493a497">&#9670;&#160;</a></span>CpSatSolverVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::CpSatSolverVersion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that describes the version of the solver. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l00137">137</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="af443c47f14a044d69553b02337b5dc52" name="af443c47f14a044d69553b02337b5dc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af443c47f14a044d69553b02337b5dc52">&#9670;&#160;</a></span>CpSolverResponseStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::CpSolverResponseStats </td>
          <td>(</td>
          <td class="paramtype">const CpSolverResponse &amp;</td>          <td class="paramname"><span class="paramname"><em>response</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>has_objective</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string with some statistics on the solver response.</p>
<p>If the second argument is false, we will just display NA for the objective value instead of zero. It is not really needed but it makes things a bit clearer to see that there is no objective. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001525">Todo</a></b></dt><dd>(user): This is probably better named "binary_propagation", but we just output "propagations" to be consistent with sat/analyze.sh. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l00681">681</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a79480946db118d243932e4b85e7e2fe3" name="a79480946db118d243932e4b85e7e2fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79480946db118d243932e4b85e7e2fe3">&#9670;&#160;</a></span>CreateAllDifferentCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateAllDifferentCutGenerator </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A cut generator for all_diff(xi). Let the united domain of all xi be D. Sum of any k-sized subset of xi need to be greater or equal to the sum of smallest k values in D and lesser or equal to the sum of largest k values in D. The cut generator first sorts the variables based on LP values and adds cuts of the form described above if they are violated by lp solution. Note that all the fixed variables are ignored while generating cuts. </p>
<p>These cuts work at all levels but the generator adds too many cuts on some instances and degrade the performance so we only use it at level</p><ol type="1">
<li></li>
</ol>
<p>Other direction.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02465">2465</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="ae3fd4466b012022bab0c5c1839c77890" name="ae3fd4466b012022bab0c5c1839c77890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fd4466b012022bab0c5c1839c77890">&#9670;&#160;</a></span>CreateAlternativeLiteralsWithView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::CreateAlternativeLiteralsWithView </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of new literals in exactly one relationship. In addition, this create an IntegerView for all these literals and also add the exactly one to the <a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a>. </p>
<p>This is not supposed to happen, but it is easy enough to cover, just in case. We might however want to use encoder-&gt;GetTrueLiteral().</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002044">Todo</a></b></dt><dd>(user): We shouldn't need to create this view ideally. Even better, we should be able to handle <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> natively in the linear relaxation, but that is a lot of work. </dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00452">452</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a7f9083888ba1b046703d2402a1a0994c" name="a7f9083888ba1b046703d2402a1a0994c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9083888ba1b046703d2402a1a0994c">&#9670;&#160;</a></span>CreateAndRegisterMandatoryOverlapPropagator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CreateAndRegisterMandatoryOverlapPropagator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">GenericLiteralWatcher</a> *</td>          <td class="paramname"><span class="paramname"><em>watcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagator that checks that no mandatory area of two boxes overlap in O(N * log N) time. </p>

<p class="definition">Definition at line <a class="el" href="2d__mandatory__overlap__propagator_8cc_source.html#l00096">96</a> of file <a class="el" href="2d__mandatory__overlap__propagator_8cc_source.html">2d_mandatory_overlap_propagator.cc</a>.</p>

</div>
</div>
<a id="a3959b472b3acf1de55a0d0c63b829ba7" name="a3959b472b3acf1de55a0d0c63b829ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3959b472b3acf1de55a0d0c63b829ba7">&#9670;&#160;</a></span>CreateAndRegisterTryEdgePropagator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CreateAndRegisterTryEdgePropagator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">GenericLiteralWatcher</a> *</td>          <td class="paramname"><span class="paramname"><em>watcher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagator that for each boxes participating in a no_overlap_2d constraint try to find the leftmost valid position that is compatible with all the other boxes. If none is found, it will propagate a conflict. Otherwise, if it is different from the current x_min, it will propagate the new x_min. </p>

<p class="definition">Definition at line <a class="el" href="2d__try__edge__propagator_8cc_source.html#l00407">407</a> of file <a class="el" href="2d__try__edge__propagator_8cc_source.html">2d_try_edge_propagator.cc</a>.</p>

</div>
</div>
<a id="a7c70694f9f0f67ba168f9b981735c05a" name="a7c70694f9f0f67ba168f9b981735c05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c70694f9f0f67ba168f9b981735c05a">&#9670;&#160;</a></span>CreateCliqueCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateCliqueCutGenerator </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>base_variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the variables that have a <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> view from base variables and create a generator that will returns constraint of the form "at_most_one" between such literals. </p>
<p>Filter base_variables to only keep the one with a literal view, and do the conversion.</p>
<p>We need to express such "at most one" in term of the initial variables, so we do not use the <a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a2e0e40fb0d6e7fe60f792ee77c706d4f">LinearConstraintBuilder::AddLiteralTerm()</a> here.</p>
<p>Add 1 - X to the linear constraint.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02742">2742</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a0dfc8799f2e7ffc634715e6524db3077" name="a0dfc8799f2e7ffc634715e6524db3077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfc8799f2e7ffc634715e6524db3077">&#9670;&#160;</a></span>CreateCumulativeCompletionTimeCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateCumulativeCompletionTimeCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completion time cuts for the cumulative constraint. It is a simple relaxation where we replace a cumulative task with demand k and duration d by a no_overlap task with duration d * k / capacity_max. </p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l01570">1570</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a55cafa81679ac10c971927ca17ec7f2e" name="a55cafa81679ac10c971927ca17ec7f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cafa81679ac10c971927ca17ec7f2e">&#9670;&#160;</a></span>CreateCumulativeEnergyCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateCumulativeEnergyCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>makespan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given set of intervals and demands, we compute the energy of each task and make sure their sum fits in the span of the intervals * its capacity.</p>
<p>If an interval is optional, it contributes min_demand * min_size * presence_literal amount of total energy.</p>
<p>If an interval is performed, we use the linear energy formulation (if defined, that is if different from a constant -1), or the McCormick relaxation of the product size * demand if not defined.</p>
<p>The maximum energy is capacity * span of intervals at level 0. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002408">Todo</a></b></dt><dd>(user): use level 0 bounds ? </dd></dl>
<p>We can always skip events.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00584">584</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a3472d7c626a01bde822df5443fc76d87" name="a3472d7c626a01bde822df5443fc76d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3472d7c626a01bde822df5443fc76d87">&#9670;&#160;</a></span>CreateCumulativePrecedenceCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateCumulativePrecedenceCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given set of intervals in a cumulative constraint, we detect violated mandatory precedences and create a cut for these. </p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00953">953</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a808babe15ef3ed46b6b0fdc42653e1da" name="a808babe15ef3ed46b6b0fdc42653e1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808babe15ef3ed46b6b0fdc42653e1da">&#9670;&#160;</a></span>CreateCumulativeTimeTableCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateCumulativeTimeTableCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>demands_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given set of intervals and demands, we first compute the mandatory part of the interval as [start_max , end_min]. We use this to calculate mandatory demands for each start_max time points for eligible intervals. Since the sum of these mandatory demands must be smaller or equal to the capacity, we create a cut representing that.</p>
<p>If an interval is optional, it contributes min_demand * presence_literal amount of demand to the mandatory demands sum. So the final cut is generated as follows: sum(demands of always present intervals)</p><ul>
<li>sum(presence_literal * min_of_demand) &lt;= capacity. </li>
</ul>
<p>Iterate through the intervals. If start_max &lt; end_min, the demand is mandatory.</p>
<p>Ignore the interval if the linearized demand fails.</p>
<p>Sort events by time. It is also important that all positive event with the same time as negative events appear after for the correctness of the algo below.</p>
<p>Reset positive event added. We do not want to create cuts for each negative event in sequence.</p>
<p>Create cut.</p>
<p>The i-th event, which is a negative event, follows a positive event. We must ignore it in our cut generation.</p>
<p>The demand_lp was added in case of a positive event. We need to remove it for a negative event.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00698">698</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a6247f9f44748b4ed51106c8a13d879b6" name="a6247f9f44748b4ed51106c8a13d879b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6247f9f44748b4ed51106c8a13d879b6">&#9670;&#160;</a></span>CreateCVRPCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateCVRPCutGenerator </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>heads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>demands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Almost the same as <a class="el" href="#a29a3f925228a72fd13718b740037c2a8">CreateStronglyConnectedGraphCutGenerator()</a> but for each components, computes the demand needed to serves it, and depending on whether it contains the depot (node zero) or not, compute the minimum number of vehicle that needs to cross the component border. </p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01336">1336</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="a88677d1180474733727feff2bbca0d31" name="a88677d1180474733727feff2bbca0d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88677d1180474733727feff2bbca0d31">&#9670;&#160;</a></span>CreateFlowCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateFlowCutGenerator </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>heads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arc_capacities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt;</td>          <td class="paramname"><span class="paramname"><em>get_flows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to find a subset where the current LP capacity of the outgoing or incoming arc is not enough to satisfy the demands.</p>
<p>We support the special value -1 for tail or head that means that the arc comes from (or is going to) outside the nodes in [0, num_nodes). Such arc must still have a capacity assigned to it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002274">Todo</a></b></dt><dd><p class="startdd">(user): Support general linear expression for capacities. </p>
<p class="enddd">(user): Some model applies the same capacity to both an arc and its reverse. Also support this case. </p>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01500">1500</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="a6c901078d9cbbd1d172c40c979daa86f" name="a6c901078d9cbbd1d172c40c979daa86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c901078d9cbbd1d172c40c979daa86f">&#9670;&#160;</a></span>CreateLinMaxCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateLinMaxCutGenerator </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>z_vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consider the Lin Max constraint with d expressions and n variables in the form: target = max {exprs[k] = Sum (wki * xi + bk)}. k in {1,..,d}. Li = lower bound of xi Ui = upper bound of xi. Let zk be in {0,1} for all k in {1,..,d}. The target = exprs[k] when zk = 1.</p>
<p>The following is a valid linearization for Lin Max. target &gt;= exprs[k], for all k in {1,..,d} target &lt;= Sum (wli * xi) + Sum((Nlk + bk) * zk), for all l in {1,..,d} Where Nlk is a large number defined as: Nlk = Sum (max((wki - wli)*Li, (wki - wli)*Ui)) = Sum (max corner difference for variable i, target expr l, max expr k)</p>
<p>Consider a partition of variables xi into set {1,..,d} as I. i.e. I(i) = j means xi is mapped to jth index. The following inequality is valid and sharp cut for the lin max constraint described above.</p>
<p>target &lt;= Sum(i=1..n)(wI(i)i * xi + Sum(k=1..d)(MPlusCoefficient_ki * zk))</p><ul>
<li>Sum(k=1..d)(bk * zk) , Where MPlusCoefficient_ki = max((wki - wI(i)i) * Li, (wki - wI(i)i) * Ui) = max corner difference for variable i, target expr I(i), max expr k.</li>
</ul>
<p>For detailed proof of validity, refer Reference: "Strong mixed-integer programming formulations for trained neural
networks" by Ross Anderson et. (<a href="https://arxiv.org/pdf/1811.01988.pdf">https://arxiv.org/pdf/1811.01988.pdf</a>).</p>
<p>In the cut generator, we compute the most violated partition I by computing the rhs value (wI(i)i * lp_value(xi) + Sum(k=1..d)(MPlusCoefficient_ki * zk)) for each variable for each partition index. We choose the partition index that gives lowest rhs value for a given variable.</p>
<dl class="section note"><dt>Note</dt><dd>This cut generator requires all expressions to contain only positive vars. </dd></dl>
<p>All expressions should only contain positive variables.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02577">2577</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a8f489d29b6f16fd7ee68f7435bfffa59" name="a8f489d29b6f16fd7ee68f7435bfffa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f489d29b6f16fd7ee68f7435bfffa59">&#9670;&#160;</a></span>CreateMaxAffineCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateMaxAffineCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a></td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; IntegerValue, IntegerValue &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>affines</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>cut_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By definition, the Max of affine functions is convex. The linear polytope is bounded by all affine functions on the bottom, and by a single hyperplane that join the two points at the extreme of the var domain, and their y-values of the max of the affine functions. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02720">2720</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="afe56022a1da9877153f91ab02f433dba" name="afe56022a1da9877153f91ab02f433dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe56022a1da9877153f91ab02f433dba">&#9670;&#160;</a></span>CreateNewIntegerVariableFromLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::CreateNewIntegerVariableFromLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 0-1 integer variable "view" of the given literal. It will have a value of 1 when the literal is true, and 0 when the literal is false. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01509">1509</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a98231785656155f51bdfef3c63bc0127" name="a98231785656155f51bdfef3c63bc0127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98231785656155f51bdfef3c63bc0127">&#9670;&#160;</a></span>CreateNoOverlap2dCompletionTimeCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateNoOverlap2dCompletionTimeCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completion time cuts for the no_overlap_2d constraint. It actually generates the completion time cumulative cuts in both axis. </p>

</div>
</div>
<a id="a2b7ca84b359f0e49b63ece216db6c944" name="a2b7ca84b359f0e49b63ece216db6c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7ca84b359f0e49b63ece216db6c944">&#9670;&#160;</a></span>CreateNoOverlap2dEnergyCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateNoOverlap2dEnergyCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1NoOverlap2DConstraintHelper.html">NoOverlap2DConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Energetic cuts for the no_overlap_2d constraint.</p>
<p>For a given set of rectangles, we compute the area of each rectangle and make sure their sum is less than the area of the bounding interval.</p>
<p>If an interval is optional, it contributes min_size_x * min_size_y * presence_literal amount of total area.</p>
<p>If an interval is performed, we use the linear area formulation (if possible), or the McCormick relaxation of the size_x * size_y.</p>
<p>The maximum area is the area of the bounding rectangle of each intervals at level 0. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001705">Todo</a></b></dt><dd>(user): We could compute this once and for all in the helper. </dd></dl>
<p>We do not consider rectangles controlled by 2 different unassigned enforcement literals.</p>

<p class="definition">Definition at line <a class="el" href="diffn__cuts_8cc_source.html#l00311">311</a> of file <a class="el" href="diffn__cuts_8cc_source.html">diffn_cuts.cc</a>.</p>

</div>
</div>
<a id="a8bb41d6a99bb282019a1a7efc6250ce5" name="a8bb41d6a99bb282019a1a7efc6250ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb41d6a99bb282019a1a7efc6250ce5">&#9670;&#160;</a></span>CreateNoOverlapCompletionTimeCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateNoOverlapCompletionTimeCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given set of intervals in a no_overlap constraint, we detect violated area based cuts from Queyranne 93 [see note in the code] and create a cut for these. </p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l01523">1523</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="ab20782292f65eff3a95731906141a718" name="ab20782292f65eff3a95731906141a718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20782292f65eff3a95731906141a718">&#9670;&#160;</a></span>CreateNoOverlapEnergyCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateNoOverlapEnergyCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>makespan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given set of intervals, we first compute the min and max of all intervals. Then we create a cut that indicates that all intervals must fit in that span.</p>
<p>If an interval is optional, it contributes min_size * presence_literal amount of demand to the mandatory demands sum. So the final cut is generated as follows: sum(sizes of always present intervals)</p><ul>
<li>sum(presence_literal * min_of_size) &lt;= span of all intervals. </li>
</ul>
<p>We can always skip events.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00647">647</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="abe41a207e47ea846654b9cb973c0b4b5" name="abe41a207e47ea846654b9cb973c0b4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe41a207e47ea846654b9cb973c0b4b5">&#9670;&#160;</a></span>CreateNoOverlapPrecedenceCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateNoOverlapPrecedenceCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given set of intervals in a no_overlap constraint, we detect violated mandatory precedences and create a cut for these. </p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00987">987</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a28abd2fe9199829f0c98ade48cfe459c" name="a28abd2fe9199829f0c98ade48cfe459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28abd2fe9199829f0c98ade48cfe459c">&#9670;&#160;</a></span>CreatePositiveMultiplicationCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreatePositiveMultiplicationCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>linearization_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cut generator for z = x * y (x and y &gt;= 0). </p>
<p>if x or y are fixed, the McCormick equations are exact.</p>
<p>Check for overflow with the product of expression bounds and the product of one expression bound times the constant part of the other expression.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001683">Todo</a></b></dt><dd>(user): As the bounds change monotonically, these cuts dominate any previous one. try to keep a reference to the cut and replace it. Alternatively, add an API for a level-zero bound change callback. </dd></dl>
<p>Cut -z + x_coeff * x + y_coeff* y &lt;= rhs</p>
<p>Cut -z + x_coeff * x + y_coeff* y &gt;= rhs</p>
<p>McCormick relaxation of bilinear constraints. These 4 cuts are the exact facets of the x * y polyhedron for a bounded x and y.</p>
<p>Each cut correspond to plane that contains two of the line (x=x_lb), (x=x_ub), (y=y_lb), (y=y_ub). The easiest to understand them is to draw the x*y curves and see the 4 planes that correspond to the convex hull of the graph.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l01874">1874</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="ad9c9d3bcc4628aa9439abe33d70b372e" name="ad9c9d3bcc4628aa9439abe33d70b372e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c9d3bcc4628aa9439abe33d70b372e">&#9670;&#160;</a></span>CreateSparsePermutationFromProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; operations_research::sat::CreateSparsePermutationFromProto </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsePermutationProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> on [0, n) from its proto representation. </p>

<p class="definition">Definition at line <a class="el" href="symmetry__util_8cc_source.html#l00238">238</a> of file <a class="el" href="symmetry__util_8cc_source.html">symmetry_util.cc</a>.</p>

</div>
</div>
<a id="a79af46d14a4530c0bf34132ff038b181" name="a79af46d14a4530c0bf34132ff038b181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79af46d14a4530c0bf34132ff038b181">&#9670;&#160;</a></span>CreateSquareCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateSquareCutGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>linearization_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A cut generator for y = x ^ 2 (x &gt;= 0). It will dynamically add a linear inequality to push y closer to the parabola. </p>
<p>Check for potential overflows.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l01993">1993</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a29a3f925228a72fd13718b740037c2a8" name="a29a3f925228a72fd13718b740037c2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a3f925228a72fd13718b740037c2a8">&#9670;&#160;</a></span>CreateStronglyConnectedGraphCutGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1CutGenerator.html">CutGenerator</a> operations_research::sat::CreateStronglyConnectedGraphCutGenerator </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>heads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We use a basic algorithm to detect components that are not connected to the rest of the graph in the LP solution, and add cuts to force some arcs to enter and leave this component from outside.</p>
<p>Cut generator for the circuit constraint, where in any feasible solution, the arcs that are present (variable at 1) must form a circuit through all the nodes of the graph. Self arc are forbidden in this case.</p>
<p>In more generality, this currently enforce the resulting graph to be strongly connected. Note that we already assume basic constraint to be in the lp, so we do not add any cuts for components of size 1. </p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01320">1320</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="add50a2f0b709713e4943459a845da887" name="add50a2f0b709713e4943459a845da887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add50a2f0b709713e4943459a845da887">&#9670;&#160;</a></span>CreateValidModelWithSingleConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CreateValidModelWithSingleConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>variable_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>mini_model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Now add end = start + size for the interval. This is not strictly necessary but it makes the presolve more powerful.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02704">2704</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ace9a3f85b1ced1ed86954a6d4d620fbd" name="ace9a3f85b1ced1ed86954a6d4d620fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9a3f85b1ced1ed86954a6d4d620fbd">&#9670;&#160;</a></span>Cumulative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::Cumulative </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IntervalVariable &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>demands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a cumulative constraint on the given intervals, the associated demands and the capacity expressions.</p>
<p>Each interval represents a task to be scheduled in time such that the task consumes the resource during the time range [lb, ub) where lb and ub respectively represent the lower and upper bounds of the corresponding interval variable. The amount of resource consumed by the task is the value of its associated demand variable.</p>
<p>The cumulative constraint forces the set of task to be scheduled such that the sum of the demands of all the tasks that overlap any time point cannot exceed the capacity of the resource.</p>
<p>This constraint assumes that an interval can be optional or have a size of zero. The demands and the capacity can be any non-negative number.</p>
<p>Optimization: If one already have an helper constructed from the interval variable, it can be passed as last argument. </p>
<p>If there is no demand, since we already added a constraint that the capacity is not negative above, we can stop here.</p>
<p>Redundant constraints to ensure that the resource capacity is high enough for each task. Also ensure that no task consumes more resource than what is available. This is useful because the subsequent propagators do not filter the capacity variable very well.</p>
<p>If the interval can be of size zero, it currently do not count towards the capacity. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001624">Todo</a></b></dt><dd>(user): Change that since we have optional interval for this. </dd></dl>
<p>Detect a subset of intervals that needs to be in disjunction and add a Disjunctive() constraint over them.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001625">Todo</a></b></dt><dd>(user): We need to exclude intervals that can be of size zero because the disjunctive do not "ignore" them like the cumulative does. That is, the interval [2,2) will be assumed to be in disjunction with [1, 3) for instance. We need to uniformize the handling of interval with size zero. </dd></dl>
<p>Liftable? We might be able to add one more interval!</p>
<p>Add a disjunctive constraint on the intervals in in_disjunction. Do not create the cumulative at all when all intervals must be in disjunction.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001626">Todo</a></b></dt><dd>(user): Do proper experiments to see how beneficial this is, the disjunctive will propagate more but is also using slower algorithms. That said, this is more a question of optimizing the disjunctive propagation code.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001627">Todo</a></b></dt><dd>(user): Another "known" idea is to detect pair of tasks that must be in disjunction and to create a Boolean to indicate which one is before the other. It shouldn't change the propagation, but may result in a faster one with smaller explanations, and the solver can also take decision on such Boolean.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001628">Todo</a></b></dt><dd>(user): A better place for stuff like this could be in the presolver so that it is easier to disable and play with alternatives. </dd></dl>
<p>For each variables that is after a subset of task ends (i.e. like a makespan objective), we detect it and add a special constraint to propagate it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001629">Todo</a></b></dt><dd>(user): Models that include the makespan as a special interval might be better, but then not everyone does that. In particular this code allows to have decent lower bound on the large cumulative minizinc instances.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001630">Todo</a></b></dt><dd>(user): this require the precedence constraints to be already loaded, and there is no guarantee of that currently. Find a more robust way.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001631">Todo</a></b></dt><dd>(user): There is a bit of code duplication with the disjunctive precedence propagator. Abstract more? </dd></dl>
<p>The CumulativeIsAfterSubsetConstraint() always reset the helper to the forward time direction, so it is important to also precompute the precedence relation using the same direction! This is needed in case the helper has already been used and set in the other direction.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001632">Todo</a></b></dt><dd>(user): Handle generic affine relation? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001633">Todo</a></b></dt><dd>(user): This can lead to many constraints. By analyzing a bit more the precedences, we could restrict that. In particular for cases were the cumulative is always (bunch of tasks B), T, (bunch of tasks A) and task T always in the middle, we never need to explicit list the precedence of a task in B with a task in A.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001634">Todo</a></b></dt><dd>(user): If more than one variable are after the same set of intervals, we should regroup them in a single constraint rather than having two independent constraint doing the same propagation. </dd></dl>
<p>We have var &gt;= end_exp.var + offset, so var &gt;= (end_exp.var + end_exp.cte) + (offset - end_exp.cte) var &gt;= task end + new_offset.</p>
<p>Propagator responsible for applying Timetabling filtering rule. It increases the minimum of the start variables, decrease the maximum of the end variables, and increase the minimum of the capacity variable.</p>
<p>Propagator responsible for applying the Overload Checking filtering rule. It increases the minimum of the capacity variable.</p>
<p>Since we use the potential DFF conflict on demands to apply the heuristic, only do so if any demand is greater than 1.</p>
<p>Propagator responsible for applying the Timetable Edge finding filtering rule. It increases the minimum of the start variables and decreases the maximum of the end variables,</p>

<p class="definition">Definition at line <a class="el" href="cumulative_8cc_source.html#l00044">44</a> of file <a class="el" href="cumulative_8cc_source.html">cumulative.cc</a>.</p>

</div>
</div>
<a id="af421daf12e0e45a0bb3cc7655cd443cc" name="af421daf12e0e45a0bb3cc7655cd443cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af421daf12e0e45a0bb3cc7655cd443cc">&#9670;&#160;</a></span>CumulativePrecedenceSearchHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::CumulativePrecedenceSearchHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The algo goes as follow:</p><ul>
<li>Build a profile of all the tasks packed to the right as long as that is feasible.</li>
<li>If we can't grow the profile, we have identified a set of tasks that all overlap if they are packed on the right, and whose sum of demand exceed the capacity.</li>
<li>Look for two tasks in that set that can be made non-overlapping, and take a "precedence" decision between them. </li>
</ul>
<p>We use a similar algo as in BuildProfile() in <a class="el" href="timetable_8cc.html">timetable.cc</a></p>
<p>Start and height of the currently built profile rectangle.</p>
<p>Remove added task ending there. <a class="el" href="classoperations__research_1_1Set.html">Set</a> their demand to zero.</p>
<p>Corner case if task is of duration zero.</p>
<p>Add new task starting here. If the task cannot be added we have a candidate for precedence. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001874">Todo</a></b></dt><dd>(user): tie-break tasks not fitting in the profile smartly. </dd></dl>
<p>We should have everything needed here to add a new precedence.</p>
<p>If packing everything to the left is feasible, continue.</p>
<p>We will use a bunch of heuristic to add a new precedence. All the task in open_tasks cannot share a time point since they exceed the capacity. Moreover if we pack all to the left, they have an intersecting point. So we should be able to make two of them disjoint</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001875">Todo</a></b></dt><dd>(user): If the two box cannot overlap because of high demand, use repo.CreateDisjunctivePrecedenceLiteral() instead.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001876">Todo</a></b></dt><dd>(user): Add heuristic ordering for creating interesting precedence first. </dd></dl>
<p>Can we add s &lt;= t ? All the considered tasks are intersecting if on the left.</p>
<p>skip if we already have a literal created and assigned to false.</p>
<p>It shouldn't be able to be true here otherwise we will have s and t disjoint.</p>
<p>This should always be true in normal usage after SAT search has fixed all literal, but if it is not, we can just return this decision.</p>
<p>Make sure s could be before t.</p>
<p>It shouldn't be able to fail since s can be before t.</p>
<p>Branch on that precedence.</p>
<p>If no precedence can be created, and all precedence are assigned to false we have a conflict since all these interval must intersect but cannot fit in the capacity!</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001877">Todo</a></b></dt><dd>(user): We need to add the reason for demand_min and capacity_max. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001878">Todo</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001879">Todo</a></b></dt><dd>(user): unfortunately we can't report it from here. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001880">Todo</a></b></dt><dd>(user): add heuristic criteria, right now we stop at first one. See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00776">776</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="adadd474f9fa4e5ea4cb65ec7d38c5018" name="adadd474f9fa4e5ea4cb65ec7d38c5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadd474f9fa4e5ea4cb65ec7d38c5018">&#9670;&#160;</a></span>CumulativeTimeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::CumulativeTimeDecomposition </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntervalVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>demands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a simple cumulative constraint. See the comment of <a class="el" href="#ace9a3f85b1ced1ed86954a6d4d620fbd">Cumulative()</a> above for a definition of the constraint. This is only used for testing.</p>
<p>This constraint assumes that task demands and the resource capacity are fixed to non-negative number. </p>
<p>Compute time range.</p>
<p>Task t consumes the resource at time if consume_condition is true.</p>
<p>Task t consumes the resource at time if it is present.</p>
<p>Task t overlaps time.</p>
<p>this is needed because we currently can't create a boolean variable if the model is unsat.</p>
<p>The profile cannot exceed the capacity at time.</p>
<p>Abort if UNSAT.</p>

<p class="definition">Definition at line <a class="el" href="cumulative_8cc_source.html#l00294">294</a> of file <a class="el" href="cumulative_8cc_source.html">cumulative.cc</a>.</p>

</div>
</div>
<a id="a19cda77b951e195fa78d14b3afd30578" name="a19cda77b951e195fa78d14b3afd30578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cda77b951e195fa78d14b3afd30578">&#9670;&#160;</a></span>CumulativeUsingReservoir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::CumulativeUsingReservoir </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntervalVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>demands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Another testing code, same assumptions as the <a class="el" href="#adadd474f9fa4e5ea4cb65ec7d38c5018">CumulativeTimeDecomposition()</a>. </p>

<p class="definition">Definition at line <a class="el" href="cumulative_8cc_source.html#l00378">378</a> of file <a class="el" href="cumulative_8cc_source.html">cumulative.cc</a>.</p>

</div>
</div>
<a id="ab6def9f0c4da45842811ae480b12cd69" name="ab6def9f0c4da45842811ae480b12cd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6def9f0c4da45842811ae480b12cd69">&#9670;&#160;</a></span>CutShapeIntoRectangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; operations_research::sat::CutShapeIntoRectangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1SingleShape.html">SingleShape</a></td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function applies the method described in page 3 of [1].</p>
<p>[1] Eppstein, David. "Graph-theoretic solutions to computational geometry
problems." International Workshop on Graph-Theoretic Concepts in Computer Science. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009. </p>
<p>To cut our polygon into rectangles, we first put it into a data structure that is easier to manipulate.</p>
<p>Some cuts connect two concave edges and will be duplicated in all_cuts. Those are important: since they "fix" two concavities with a single cut, they are called "good diagonals" in the literature. Note that in computational geometry jargon, a diagonal of a polygon is a line segment that connects two non-adjacent vertices of a polygon, even in cases like ours that we are only talking of diagonals that are not "diagonal" in the usual meaning of the word: ie., horizontal or vertical segments connecting two vertices of the polygon).</p>
<p>The "good diagonals" are only more optimal that any cut if they are not crossed by other cuts. To maximize their usefulness, we build a graph where the good diagonals are the vertices and we add an edge every time a vertical and horizontal diagonal cross. The minimum vertex cover of this graph is the minimal set of good diagonals that are not crossed by other cuts.</p>
<p>Since our data structure only allow to cut the shape according to a list of vertical or horizontal cuts, but not a list mixing both, we cut first on the chosen horizontal good diagonals.</p>
<p>We need to recompute the cuts after we applied the good diagonals, since the geometry has changed.</p>
<p>Now that we did all horizontal good diagonals, we need to cut on all vertical good diagonals and then cut arbitrarily to remove all concave edges. To make things simple, just apply all vertical cuts, since they include all the vertical good diagonals and also fully slice the shape into rectangles.</p>
<p>Remove duplicates coming from good diagonals first.</p>
<p>Now every connected component of the shape is a rectangle. Build the final result.</p>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l01267">1267</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="a5ee6af9b585a14fcbbbedee050b6c934" name="a5ee6af9b585a14fcbbbedee050b6c934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee6af9b585a14fcbbbedee050b6c934">&#9670;&#160;</a></span>DEFINE_STRONG_INDEX_TYPE() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INDEX_TYPE </td>
          <td>(</td>
          <td class="paramtype">BooleanVariable</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of a variable (&gt;= 0). </p>

</div>
</div>
<a id="a0e75372160364c7130866052ddade46b" name="a0e75372160364c7130866052ddade46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e75372160364c7130866052ddade46b">&#9670;&#160;</a></span>DEFINE_STRONG_INDEX_TYPE() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INDEX_TYPE </td>
          <td>(</td>
          <td class="paramtype">ClauseIndex</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of a clause (&gt;= 0). </p>

</div>
</div>
<a id="aa6ed833632a191f0950ce1f9e80a9ccd" name="aa6ed833632a191f0950ce1f9e80a9ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ed833632a191f0950ce1f9e80a9ccd">&#9670;&#160;</a></span>DEFINE_STRONG_INDEX_TYPE() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INDEX_TYPE </td>
          <td>(</td>
          <td class="paramtype">EnforcementId</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adda1319282a2ed2307e06999f1e8e1f8" name="adda1319282a2ed2307e06999f1e8e1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda1319282a2ed2307e06999f1e8e1f8">&#9670;&#160;</a></span>DEFINE_STRONG_INDEX_TYPE() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INDEX_TYPE </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of an IntegerVariable.</p>
<p>Each time we create an IntegerVariable we also create its negation. This is done like that so internally we only stores and deal with lower bound. The upper bound being the lower bound of the negated variable. </p>

</div>
</div>
<a id="ad5b04eae7b76b3c8989b8ac5753cbc16" name="ad5b04eae7b76b3c8989b8ac5753cbc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b04eae7b76b3c8989b8ac5753cbc16">&#9670;&#160;</a></span>DEFINE_STRONG_INDEX_TYPE() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INDEX_TYPE </td>
          <td>(</td>
          <td class="paramtype">IntervalVariable</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eac46edfbe4bab27e13aebe3805a558" name="a2eac46edfbe4bab27e13aebe3805a558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eac46edfbe4bab27e13aebe3805a558">&#9670;&#160;</a></span>DEFINE_STRONG_INDEX_TYPE() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INDEX_TYPE </td>
          <td>(</td>
          <td class="paramtype">LiteralIndex</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of a literal (&gt;= 0), see <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> below. </p>

</div>
</div>
<a id="a57ab2033e6dfb7bc18d684852cccc8fa" name="a57ab2033e6dfb7bc18d684852cccc8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ab2033e6dfb7bc18d684852cccc8fa">&#9670;&#160;</a></span>DEFINE_STRONG_INDEX_TYPE() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INDEX_TYPE </td>
          <td>(</td>
          <td class="paramtype">PositiveOnlyIndex</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special type for storing only one thing for var and NegationOf(var). </p>

</div>
</div>
<a id="aba8aa4554e45ceae93cb84e3be5cf151" name="aba8aa4554e45ceae93cb84e3be5cf151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8aa4554e45ceae93cb84e3be5cf151">&#9670;&#160;</a></span>DEFINE_STRONG_INT64_TYPE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INT64_TYPE </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the integer coefficients in a pseudo-Boolean constraint. This is also used for the current value of a constraint or its bounds. </p>

</div>
</div>
<a id="a2abf8d5e7d838d6348a6b5b7101a0b04" name="a2abf8d5e7d838d6348a6b5b7101a0b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abf8d5e7d838d6348a6b5b7101a0b04">&#9670;&#160;</a></span>DEFINE_STRONG_INT64_TYPE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::DEFINE_STRONG_INT64_TYPE </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value type of an integer variable. An integer variable is always bounded on both sides, and this type is also used to store the bounds [lb, ub] of the range of each integer variable.</p>
<dl class="section note"><dt>Note</dt><dd>both bounds are inclusive, which allows to write many propagation algorithms for just one of the bound and apply it to the negated variables to get the symmetric algorithm for the other bound. </dd></dl>

</div>
</div>
<a id="aa71dfa5c438ceb1f2474eea8ceb3c4ad" name="aa71dfa5c438ceb1f2474eea8ceb3c4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71dfa5c438ceb1f2474eea8ceb3c4ad">&#9670;&#160;</a></span>DetectAndAddSymmetryToProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DetectAndAddSymmetryToProto </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects symmetries and fill the symmetry field. </p>
<p>Log orbit information.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001588">Todo</a></b></dt><dd>(user): It might be nice to just add this to the proto rather than re-reading the generators and recomputing this in a few places. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__symmetries_8cc_source.html#l00769">769</a> of file <a class="el" href="cp__model__symmetries_8cc_source.html">cp_model_symmetries.cc</a>.</p>

</div>
</div>
<a id="a3423c28a2a00161e74d9c6e0174bcbf6" name="a3423c28a2a00161e74d9c6e0174bcbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3423c28a2a00161e74d9c6e0174bcbf6">&#9670;&#160;</a></span>DetectAndExploitSymmetriesInPresolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::DetectAndExploitSymmetriesInPresolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basic implementation of some symmetry breaking during presolve.</p>
<p>Currently this just try to fix variables by detecting symmetries between Booleans in bool_and, at_most_one or exactly_one constraints.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001617">Todo</a></b></dt><dd>(user): A bunch of other presolve transformations break the symmetry even though they probably shouldn't. Like the find big liner overlap for instance. Or when we fix variable but don't propagate to the full orbit. It might not be too much work to: 1/ Compute the symmetry early 2/ Only do transformation that preserve them To investigate. It seems disabling find_big_linear_overlap helps on mas74.pb.gz, or the square??.mps for instance. But it is less good overall. </dd></dl>
<p>We need to make sure the proto is up to date before computing symmetries!</p>
<p>Tricky: the equivalence relation are not part of the proto. We thus add them temporarily to compute the symmetry.</p>
<p>Remove temporary affine relation.</p>
<p>Collect the at most ones.</p>
<p>Note(user): This relies on the fact that the pointers remain stable when we adds new constraints. It should be the case, but it is a bit unsafe. On the other hand it is annoying to deal with both cases below.</p>
<p>We have a few heuristics. The first only look at the global orbits under the symmetry group and try to infer Boolean variable fixing via symmetry breaking. Note that nothing is fixed yet, we will decide later if we fix these Booleans or not.</p>
<p>Get the global orbits and their size.</p>
<p>Log orbit info.</p>
<p>First heuristic based on propagation, see the function comment.</p>
<p>If an at most one intersect with one or more orbit, in each intersection, we can fix all but one variable to zero. For now we only test positive literal, and maximize the number of fixing.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001589">Todo</a></b></dt><dd>(user): Doing that is not always good, on cod105.mps, fixing variables instead of letting the inner solver handle Boolean symmetries make the problem unsolvable instead of easily solved. This is probably because this fixing do not exploit the full structure of these symmetries. Note however that the fixing via propagation above close cod105 even more efficiently. </dd></dl>
<p>Compute how many variables we can fix with this at most one.</p>
<p>We count all but the first one in each orbit.</p>
<p>Redo a pass to copy the intersection.</p>
<p>We push all but the first one in each orbit.</p>
<p>Sparse clean up.</p>
<p>Orbitope approach.</p>
<p>This is basically the same as the generic approach, but because of the extra structure, computing the orbit of any stabilizer subgroup is easy. We look for orbits intersecting at most one constraints, so we can break symmetry by fixing variables.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001590">Todo</a></b></dt><dd>(user): The same effect could be achieved by adding symmetry breaking constraints of the form "a &gt;= b " between Booleans and let the presolve do the reduction. This might be less code, but it is also less efficient. Similarly, when we cannot just fix variables to break symmetries, we could add these constraints, but it is unclear if we should do it all the time or not.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001591">Todo</a></b></dt><dd>(user): code the generic approach with orbits and stabilizer. </dd></dl>
<p>HACK for flatzinc wordpress* problem.</p>
<p>If we have a large orbitope, with one objective term by column, we break the symmetry by ordering the objective terms. This usually increase drastically the objective lower bounds we can discover.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001592">Todo</a></b></dt><dd>(user): generalize somehow. See if we can exploit this in lb_tree_search directly. We also have a lot more structure than just the objective can be ordered. Like if the objective is a max, we can still do that.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001593">Todo</a></b></dt><dd>(user): Actually the constraint we add is really just breaking the orbitope symmetry on one line. But this line being the objective is key. We can also explicitly look for a full permutation group of the objective terms directly instead of finding the largest orbitope first. </dd></dl>
<p>Super simple heuristic to use the orbitope or not.</p>
<p>In an orbitope with an at most one on each row, we can fix the upper right triangle. We could use a formula, but the loop is fast enough.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001594">Todo</a></b></dt><dd>(user): Compute the stabilizer under the only non-fixed element and iterate! </dd></dl>
<p>Fixing just a few variables to break large symmetry can be really bad. See for example cdc7-4-3-2.pb.gz where we don't find solution if we do that. On the other hand, enabling this make it worse on neos-3083784-nive.pb.gz.</p>
<p>In general, enabling this works better in single thread with max_lp_sym, but worse in multi-thread, where less workers are using symmetries, and so it is better to fix more stuff.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001595">Todo</a></b></dt><dd>(user): Tune more, especially as we handle symmetry better. Also the estimate is pretty bad, we should probably compute stabilizer and decide when we actually know how much we can fix compared to how many symmetry we lose. </dd></dl>
<p>Fix "can_be_fixed_to_false" instead of the orbitope if it is larger.</p>
<p>We are breaking the symmetry in a way that makes the hint invalid. We want <code>var</code> to be false, so we would naively pick a symmetry to enforce that. But that will be wrong if we do this twice: after we permute the hint to fix the first one we would look for a symmetry group element that fixes the second one to false. But there are many of those, and picking the wrong one would risk making the first one true again. Since this is a AMO, fixing the one that is true doesn't have this problem.</p>
<p>Moreover, we can add the implication that in the orbit of distinguished_var, either everything is false, or var is at one.</p>
<p>This will always be kept all zero after usage.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001596">Todo</a></b></dt><dd>(user): The code below requires that no variable appears twice in the same at most one. In particular lit and not(lit) cannot appear in the same at most one. </dd></dl>
<p>Using the orbitope orbits and intersecting at most ones, we will be able in some case to derive a property of the literals of one row of the orbitope. Namely that:</p><ul>
<li>All literals of that row take the same value.</li>
<li>At most one literal can be true.</li>
<li>At most one literal can be false.</li>
</ul>
<p>See the comment below for how we can infer this.</p>
<p>Because in the orbitope case, we have a full symmetry group of the columns, we can infer more than just using the orbits under a general permutation group. If an at most one contains two variables from the row, we can infer: 1/ If the two variables appear positively, then there is an at most one on the full row, and we can set n - 1 variables to zero to break the symmetry. 2/ If the two variables appear negatively, then the opposite situation arise and there is at most one zero on the row, we can set n - 1 variables to one. 3/ If two literals of opposite sign appear, then the only possibility for the row are all at one or all at zero, thus we can mark all variables as equivalent.</p>
<p>These property comes from the fact that when we permute a line of the orbitope in any way, then the position than ends up in the at most one must never be both at one.</p>
<dl class="section note"><dt>Note</dt><dd>3/ can be done without breaking any symmetry, but for 1/ and 2/ by choosing which variable is not fixed, we will break some symmetry.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001597">Todo</a></b></dt><dd>(user): for 1/ and 2/ we could add an at most one constraint on the full row if it is not already there!</dd></dl>
<p>Note(user): On the miplib, only 1/ and 2/ happens currently. Not sure with LNS though.</p>
<p>An at most one touching two positions in an orbitope row can be extended to include the full row.</p>
<p>Note(user): I am not sure we care about that here. By symmetry, if we have an at most one touching two positions, then we should have others touching all pair of positions. And the at most one expansion would already have extended it. So this is more FYI.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001598">Todo</a></b></dt><dd>(user): if the same at most one touch more than one row, we can deduce more. It is a bit tricky and maybe not frequent enough to make a big difference. Also, as we start to fix things, at most one might propagate by themselves. </dd></dl>
<p>List the row in "at most one" by score. We will be able to fix a "triangle" of literals in order to break some of the symmetry.</p>
<p>Mark all the equivalence or fixed rows. </p><dl class="section note"><dt>Note</dt><dd>this operation do not change the symmetry group.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001599">Todo</a></b></dt><dd>(user): We could remove these rows from the orbitope. Note that currently this never happen on the miplib (maybe in LNS though). </dd></dl>
<p>If we have both property, it means we have</p><ul>
<li>sum_j orbitope[row][j] &lt;= 1</li>
<li>sum_j not(orbitope[row][j]) &lt;= 1 which is the same as sum_j orbitope[row][j] &gt;= num_cols - 1. This is only possible if we have two elements and we don't have row_is_all_equivalent.</li>
</ul>
<p>We have [1, 0] or [0, 1].</p>
<p>No solution.</p>
<p>Here we proved that the row is either all ones or all zeros. This was because we had: at_most_one = [x, ~y, ...] orbitope = [x, y, ...] and by symmetry we have at_most_one = [~x, y, ...] This for all pairs of positions in that row.</p>
<p>We use as the score the number of constraint in which variables from this row participate.</p>
<p>Break the symmetry by fixing at each step all but one literal to true or false. Note that each time we do that for a row, we need to exclude the non-fixed column from the rest of the row processing. We thus fix a "triangle" of literals.</p>
<p>This is the same as ordering the columns in some lexicographic order and using the at_most_ones to fix known position. Note that we can still add lexicographic symmetry breaking inequality on the columns as long as we do that in the same order as these fixing.</p>
<p>For correctness of the code below, reduce the orbitope.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001600">Todo</a></b></dt><dd>(user): This is probably not needed if we add lexicographic constraint instead of just breaking a single row below. </dd></dl>
<p>Remove the first num_processed_rows.</p>
<p>For each of them remove the first num_processed_rows entries.</p>
<p>The transformations below seems to hurt more than what they help. Especially when we handle symmetry during the search like with max_lp_sym worker. See for instance neos-948346.pb or map06.pb.gz.</p>
<p>If we are left with a set of variable than can all be permuted, lets break the symmetry by ordering them.</p>
<p>Add orbitope[0][i] &gt;= orbitope[0][i+1].</p>

<p class="definition">Definition at line <a class="el" href="cp__model__symmetries_8cc_source.html#l00936">936</a> of file <a class="el" href="cp__model__symmetries_8cc_source.html">cp_model_symmetries.cc</a>.</p>

</div>
</div>
<a id="a7d5b31875c1bdb84fd6ab2c57ba49a46" name="a7d5b31875c1bdb84fd6ab2c57ba49a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5b31875c1bdb84fd6ab2c57ba49a46">&#9670;&#160;</a></span>DetectDisjointRegionIn2dPacking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1Disjoint2dPackingResult.html">Disjoint2dPackingResult</a> operations_research::sat::DetectDisjointRegionIn2dPacking </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>non_fixed_boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>fixed_boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_num_components</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we are here, that means that the space where boxes can be placed is not connected.</p>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l01484">1484</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="a753e3aea07903c667891eb57036d26de" name="a753e3aea07903c667891eb57036d26de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753e3aea07903c667891eb57036d26de">&#9670;&#160;</a></span>DetectImpliedIntegers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; operations_research::sat::DetectImpliedIntegers </td>
          <td>(</td>
          <td class="paramtype">MPModelProto *</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will mark implied integer as such. Note that it can also discover variable of the form coeff * Integer + offset, and will change the model so that these are marked as integer. It is why we return both a scaling and an offset to transform the solution back to its original domain.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002078">Todo</a></b></dt><dd>(user): Actually implement the offset part. This currently only happens on the 3 neos-46470* miplib problems where we have a non-integer rhs. </dd></dl>
<p>We will process all equality constraints with exactly one non-integer.</p>
<p>Scale the variable right away and mark it as implied integer. </p><dl class="section note"><dt>Note</dt><dd>the constraints will be scaled later.</dd></dl>
<p>Update the queue of constraints with a single non-integer.</p>
<p>The non integer variable was already made integer by one other constraint.</p>
<p>Ignore non-equality here.</p>
<p>This will be set to the unique non-integer term of this constraint.</p>
<p>We are looking for a "multiplier" so that the unique non-integer term in this constraint (i.e. var * var_coeff) times this multiplier is an integer.</p>
<p>If this is set to zero or becomes too large, we fail to detect a new implied integer and ignore this constraint.</p>
<p>This actually compute the smallest multiplier to make all other terms in the constraint integer.</p>
<p>These "rhs" fail could be handled by shifting the variable.</p>
<p>We want to multiply the variable so that it is integer. We know that coeff * multiplier is an integer, so we just multiply by that.</p>
<p>But if a variable appear in more than one equality, we want to find the smallest integrality factor! See diameterc-msts-v40a100d5i.mps for an instance of this.</p>
<p>Ignore non-equality here.</p>
<p>Process continuous variables that only appear as the unique non integer in a set of non-equality constraints.</p>
<dl class="section note"><dt>Note</dt><dd>turning to integer such variable cannot in turn trigger new integer detection, so there is no point doing that in a loop.</dd></dl>
<p>This should be presolved and not happen.</p>
<p>The situation is a bit tricky here, we have a bunch of coeffs c_i, and we know that X * c_i can take integer value without changing the constraint i meaning.</p>
<p>For now we take the min, and scale only if all c_i / min are integer.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002067">Todo</a></b></dt><dd>(user): be smarter! we should be able to handle these cases. </dd></dl>
<p>Tricky, we also need the bound of the scaled variable to be integer.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002068">Todo</a></b></dt><dd>(user): If we scale more we migth be able to turn it into an integer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00482">482</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a175a4aa8393ef1f42790017ac2ef3d0e" name="a175a4aa8393ef1f42790017ac2ef3d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175a4aa8393ef1f42790017ac2ef3d0e">&#9670;&#160;</a></span>DetectMakespan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int &gt; operations_research::sat::DetectMakespan </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntervalVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>intervals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>demands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan the intervals of a cumulative/no_overlap constraint, and its capacity (1 for the no_overlap). It returns the index of the makespan interval if found, or std::nullopt otherwise.</p>
<p>Currently, this requires the capacity to be fixed in order to scan for a makespan interval.</p>
<p>The makespan interval has the following property:</p><ul>
<li>its end is fixed at the horizon</li>
<li>it is always present</li>
<li>its demand is the capacity of the cumulative/no_overlap.</li>
<li>its size is &gt; 0.</li>
</ul>
<p>These property ensures that all other intervals ends before the start of the makespan interval. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002045">Todo</a></b></dt><dd>(user): Supports variable capacity. </dd></dl>
<p>Detect the horizon (max of all end max of all intervals).</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l00636">636</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a3216f11aeb59c8cd63d2a1e8cdc6d47b" name="a3216f11aeb59c8cd63d2a1e8cdc6d47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3216f11aeb59c8cd63d2a1e8cdc6d47b">&#9670;&#160;</a></span>DetectOptionalVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DetectOptionalVariables </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically detect optional variables. </p>
<p>The variables from the objective cannot be marked as optional!</p>
<p>Compute for each variables the intersection of the enforcement literals of the constraints in which they appear.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001294">Todo</a></b></dt><dd>(user): This deals with the simplest cases, but we could try to detect literals that implies all the constraints in which a variable appear to false. This can be done with a LCA computation in the tree of Boolean implication (once the presolve remove cycles). Not sure if we can properly exploit that afterwards though. Do some research! </dd></dl>
<p>Take the intersection.</p>
<p>Auto-detect optional variables.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00909">909</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a7bb6813fa96405f91b0c930ce00356f3" name="a7bb6813fa96405f91b0c930ce00356f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb6813fa96405f91b0c930ce00356f3">&#9670;&#160;</a></span>DeterministicLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DeterministicLoop </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subsolvers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>batch_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_num_batches</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="#a8be20b017a46b4e9d7097ee32622eba8">NonDeterministicLoop()</a> except this should result in a deterministic solver provided that all <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> respect the Synchronize() contract.</p>
<p>Executes the following loop: 1/ Synchronize all in given order. 2/ generate and schedule up to batch_size tasks using an heuristic to select which one to run. 3/ wait for all task to finish. 4/ repeat until no task can be generated in step 2.</p>
<p>If max_num_batches is &gt; 0, stop after that many batches. </p>
<p>We abort the loop after the last synchronize to properly reports final status in case max_num_batches is used.</p>
<p>We first generate all task to run in this batch. </p><dl class="section note"><dt>Note</dt><dd>we can't start the task right away since if a task finish before we schedule everything, we will not be deterministic.</dd></dl>
<p>Schedule each task.</p>
<p>Wait for all tasks of this batch to be done before scheduling another batch.</p>
<p>Update times.</p>

<p class="definition">Definition at line <a class="el" href="subsolver_8cc_source.html#l00128">128</a> of file <a class="el" href="subsolver_8cc_source.html">subsolver.cc</a>.</p>

</div>
</div>
<a id="a63a3f2af6ea15181591a33edda577652" name="a63a3f2af6ea15181591a33edda577652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a3f2af6ea15181591a33edda577652">&#9670;&#160;</a></span>DifferAtGivenLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiteralIndex operations_research::sat::DifferAtGivenLiteral </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visible for testing. Returns kNoLiteralIndex except if:</p><ul>
<li>a and b differ in only one literal.</li>
<li>For a it is the given literal l. In which case, returns the LiteralIndex of the literal in b that is not in a. </li>
</ul>
<p>A literal of a is not in b, it must be l. </p><dl class="section note"><dt>Note</dt><dd>this can only happen once.</dd></dl>
<p>A literal of b is not in a, save it. We abort if this happen twice.</p>
<p>Check the corner case of the difference at the end.</p>

<p class="definition">Definition at line <a class="el" href="simplification_8cc_source.html#l00989">989</a> of file <a class="el" href="simplification_8cc_source.html">simplification.cc</a>.</p>

</div>
</div>
<a id="aa5cbc97ff49b1aed57ea5e8f82cf9534" name="aa5cbc97ff49b1aed57ea5e8f82cf9534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cbc97ff49b1aed57ea5e8f82cf9534">&#9670;&#160;</a></span>DiophantineEquationOfSizeTwoHasSolutionInDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::DiophantineEquationOfSizeTwoHasSolutionInDomain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>cte</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the equation a * X + b * Y = cte has some integer solutions in the domain of X and Y. </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00248">248</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="a33798fe85208035f149a5c124b89b7b4" name="a33798fe85208035f149a5c124b89b7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33798fe85208035f149a5c124b89b7b4">&#9670;&#160;</a></span>DisjunctivePrecedenceSearchHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::DisjunctivePrecedenceSearchHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The algo goes as follow:</p><ul>
<li>For each disjunctive, consider the intervals by start time, consider adding the first precedence between overlapping interval.</li>
<li>Take the smallest start time amongst all disjunctive.</li>
</ul>
<p>Compared to <a class="el" href="#a85b41013bb2f7709a99765d5c491f381" title="A simple heuristic for scheduling models.">SchedulingSearchHeuristic()</a> this one take decision on precedences between tasks. Lazily creating a precedence Boolean for the task in disjunction.</p>
<dl class="section note"><dt>Note</dt><dd>this one is meant to be used when all Boolean has been fixed, so more as a "completion" heuristic rather than a fixed search one. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001870">Todo</a></b></dt><dd>(user): tie break by size/start-max </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001871">Todo</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001872">Todo</a></b></dt><dd>(user): Use conditional lower bounds? note that in automatic search all precedence will be fixed before this is called though. In fixed search maybe we should use the other <a class="el" href="#a85b41013bb2f7709a99765d5c491f381" title="A simple heuristic for scheduling models.">SchedulingSearchHeuristic()</a>. </dd></dl>
<p>Swap (a,b) if they have the same start_min.</p>
<p>Corner case in case b can fit before a (size zero)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001873">Todo</a></b></dt><dd>(user): Also compare the second part of the precedence in PrecedenceIsBetter() and not just the interval before? </dd></dl>
<p>If one of the task presence is undecided, start by making it present.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00699">699</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a0f0ece2fd7a5f1c4ff26f8caade0d798" name="a0f0ece2fd7a5f1c4ff26f8caade0d798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0ece2fd7a5f1c4ff26f8caade0d798">&#9670;&#160;</a></span>DivideByGCD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DivideByGCD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the GCD of the constraint coefficient, and divide them by it. This also tighten the constraint bounds assumming all the variables are integer. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00271">271</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="ace619cca537761022dff4ee830354f19" name="ace619cca537761022dff4ee830354f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace619cca537761022dff4ee830354f19">&#9670;&#160;</a></span>DivideLinearExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DivideLinearExpression </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearExpressionProto *</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the expression in place by 'divisor'. It will DCHECK that 'divisor' divides all constants. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00059">59</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a6d8e3999c6efdf2b47d4379b3eb9c85e" name="a6d8e3999c6efdf2b47d4379b3eb9c85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8e3999c6efdf2b47d4379b3eb9c85e">&#9670;&#160;</a></span>DivisionConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::DivisionConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>denom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>div</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the constraint: num / denom = div. (denom &gt; 0). </p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00791">791</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a46540a899ab5e8fe1b55e12da55cbbe0" name="a46540a899ab5e8fe1b55e12da55cbbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46540a899ab5e8fe1b55e12da55cbbe0">&#9670;&#160;</a></span>DomainInProtoContains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoWithDomain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::DomainInProtoContains </td>
          <td>(</td>
          <td class="paramtype">const ProtoWithDomain &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a proto.domain() contain the given value. The domain is expected to be encoded as a sorted disjoint interval list. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00124">124</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a393ff6c6adb9d243cd4b7b7e445a3c23" name="a393ff6c6adb9d243cd4b7b7e445a3c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393ff6c6adb9d243cd4b7b7e445a3c23">&#9670;&#160;</a></span>EnforcedClause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::EnforcedClause </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>clause</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>enforcement_literals =&gt; clause. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00987">987</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="adff14ec933b464328de54c33e81429a9" name="adff14ec933b464328de54c33e81429a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff14ec933b464328de54c33e81429a9">&#9670;&#160;</a></span>EnforcementLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::EnforcementLiteral </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00052">52</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a385d140d4f7ca2544f0ef33e71965793" name="a385d140d4f7ca2544f0ef33e71965793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385d140d4f7ca2544f0ef33e71965793">&#9670;&#160;</a></span>Equality() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::Equality </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a == b. </p>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00687">687</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="a134ba4c37e543cb80c698555b6ae89f8" name="a134ba4c37e543cb80c698555b6ae89f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134ba4c37e543cb80c698555b6ae89f8">&#9670;&#160;</a></span>Equality() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::Equality </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix v to a given value. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01596">1596</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a1fe51896137f1dc2c0e707695a04183a" name="a1fe51896137f1dc2c0e707695a04183a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe51896137f1dc2c0e707695a04183a">&#9670;&#160;</a></span>Equality() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::Equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a == b. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00962">962</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a768255abe58acbda21da0438875ed315" name="a768255abe58acbda21da0438875ed315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768255abe58acbda21da0438875ed315">&#9670;&#160;</a></span>EqualityWithOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::EqualityWithOffset </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a + offset == b. </p>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00696">696</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="a385fff0913c87d0912b88d59d7dcfc7a" name="a385fff0913c87d0912b88d59d7dcfc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385fff0913c87d0912b88d59d7dcfc7a">&#9670;&#160;</a></span>EvaluateImpliedIntProdDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a> operations_research::sat::EvaluateImpliedIntProdDomain </td>
          <td>(</td>
          <td class="paramtype">const LinearArgumentProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l01484">1484</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="abf7ff8fbf0c457648f4944b2d27c0135" name="abf7ff8fbf0c457648f4944b2d27c0135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7ff8fbf0c457648f4944b2d27c0135">&#9670;&#160;</a></span>ExactlyOneConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ExactlyOneConstraint </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00917">917</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ad991297f9637c704d1824dc9513ab8b8" name="ad991297f9637c704d1824dc9513ab8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad991297f9637c704d1824dc9513ab8b8">&#9670;&#160;</a></span>ExactlyOnePerRowAndPerColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ExactlyOnePerRowAndPerColumn </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001131">Todo</a></b></dt><dd>(user): Change to a sparse API like for the function above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="circuit_8cc_source.html#l00630">630</a> of file <a class="el" href="circuit_8cc_source.html">circuit.cc</a>.</p>

</div>
</div>
<a id="ae5713162a0aa0aa8ce18c442afc26254" name="ae5713162a0aa0aa8ce18c442afc26254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5713162a0aa0aa8ce18c442afc26254">&#9670;&#160;</a></span>ExcludeCurrentSolutionAndBacktrack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ExcludeCurrentSolutionAndBacktrack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be used to enumerate all the solutions. After each SAT call to <a class="el" href="#a09d851f944ab4f305c3d9f8df99b7bf8" title="Solves the given CpModelProto and returns an instance of CpSolverResponse.">Solve()</a>, calling this will reset the solver and exclude the current solution so that the next call to <a class="el" href="#a09d851f944ab4f305c3d9f8df99b7bf8" title="Solves the given CpModelProto and returns an instance of CpSolverResponse.">Solve()</a> will give a new solution or UNSAT is there is no more new solutions. </p>
<dl class="section note"><dt>Note</dt><dd>we only exclude the current decisions, which is an efficient way to not get the same SAT assignment.</dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l01053">1053</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a313297bca1475c995d9a4139cb790cc8" name="a313297bca1475c995d9a4139cb790cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313297bca1475c995d9a4139cb790cc8">&#9670;&#160;</a></span>ExpandCpModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ExpandCpModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expands a given CpModelProto by rewriting complex constraints into simpler constraints. This is different from <a class="el" href="#a5ae90163b3b1ba74569501c3a9d3e6d6" title="Convenient wrapper to call the full presolve.">PresolveCpModel()</a> as there are no reduction or simplification of the model. Furthermore, this expansion is mandatory. </p>
<p>None of the function here need to be run twice. This is because we never create constraint that need to be expanded during presolve.</p>
<p>Make sure all domains are initialized.</p>
<p>Clear the precedence cache.</p>
<p>First pass: we look at constraints that may fully encode variables.</p>
<p>If we only do expansion, we do that as part of the main loop. This way we don't need to call <a class="el" href="#a9665c030067d31a2aa2c9376228eab59">FinalExpansionForLinearConstraint()</a>.</p>
<p>Update variable-constraint graph.</p>
<p>Early exit if the model is unsat.</p>
<p>Second pass. We may decide to expand constraints if all their variables are fully encoded.</p>
<p>Cache for variable scanning.</p>
<p>Update variable-constraint graph.</p>
<p>Early exit if the model is unsat.</p>
<p>The precedence cache can become invalid during presolve as it does not handle variable substitution. It is safer just to clear it at the end of the expansion phase.</p>
<p>Make sure the context is consistent.</p>
<p>Update any changed domain from the context.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__expand_8cc_source.html#l02449">2449</a> of file <a class="el" href="cp__model__expand_8cc_source.html">cp_model_expand.cc</a>.</p>

</div>
</div>
<a id="a265b8cf37f58fb2c78b247a6412ce519" name="a265b8cf37f58fb2c78b247a6412ce519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265b8cf37f58fb2c78b247a6412ce519">&#9670;&#160;</a></span>ExploitDominanceRelations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ExploitDominanceRelations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">VarDomination</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var_domination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Once detected, exploit the dominance relations that appear in the same constraint. This does a full scan of the model.</p>
<p>Return false if the problem is infeasible. </p>
<p>Abort early if there is nothing to do.</p>
<p>Strenghtening via domination. When a variable is dominated by a bunch of other, either we can do (var&ndash;, dom++) or if we can't (i.e all dominated variable at their upper bound) then maybe all constraint are satisfied if var is high enough and we can also decrease it.</p>
<p>Temporary data that we fill/clear for each linear constraint.</p>
<p>Temporary data used for boolean constraints.</p>
<p>If (a&ndash;, b&ndash;) is valid, we can always set a to false. If the hint value of <code>a</code> is 1 then the hint value of <code>b</code> should be 1 due to the a =&gt; b constraint. Hence the hint feasibility can always be preserved (if the hint value of <code>a</code> is 0 the hint does not need to be updated).</p>
<p>If (b++, a++) is valid, then we can always set b to true. If the hint value of <code>b</code> is 0 then the hint value of <code>a</code> should be 0 due to the a =&gt; b constraint. Hence the hint feasibility can always be preserved (if the hint value of <code>b</code> is 1 the hint does not need to be updated).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002523">Todo</a></b></dt><dd>(user): More generally, combine with probing? if a dominated variable implies one of its dominant to zero, then it can be set to zero. It seems adding the implication below should have the same effect? but currently it requires a lot of presolve rounds. </dd></dl>
<p>Precompute.</p>
<p>Returns the change magnitude in min-activity (resp. max-activity) if all the given variables are fixed to their upper bound.</p>
<p>Tricky: For now we skip complex domain as we are not sure they can be moved correctly.</p>
<p>Look for dominated var.</p>
<p>For strenghtening using domination, just consider &gt;= constraint.</p>
<p>Always transform to coeff_magnitude * current_ref + ... &gt;=</p>
<p>When all dominated var are at their upper bound, we miss 'slack' to make the constraint trivially satisfiable.</p>
<p>Any increase such that coeff * delta &gt;= slack make the constraint trivial.</p>
<p>Note(user): It look like even if any of the upper bound of the dominating var decrease, this should still be valid. Here we only decrease such a bound due to a dominance relation, so the slack when all dominating variable are at their bound should not really decrease.</p>
<p>Compute the delta in min-activity if all dominating var moves to their other bound.</p>
<p>We need to update the precomputed quantities.</p>
<p>Tricky: If there are holes, we can't just reduce the domain to new_ub if it is not a valid value, so we need to compute the Min() of the intersection.</p>
<p>We need to update the precomputed quantities.</p>
<p>Restore.</p>
<p>For any dominance relation still left (i.e. between non-fixed vars), if the variable are Boolean and X is dominated by Y, we can add (X = 1) =&gt; (Y = 1). But, as soon as we do that, we break some symmetry and cannot add any incompatible relations.</p>
<p>EX: It is possible that X dominate Y and Y dominate X if they are both appearing in exactly the same constraint with the same coefficient.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002524">Todo</a></b></dt><dd>(user): if both variable are in a bool_or, this will allow us to remove the dominated variable. Maybe we should exploit that to decide which implication we add. Or just remove such variable and not add the implications?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002525">Todo</a></b></dt><dd>(user): generalize to non Booleans? </dd></dl>
<p>Increase the count for variable in the objective to account for the kObjectiveConstraint in their VarToConstraints() list.</p>
<p>We need to account for domain with hole, hence the ValueAtOrAfter().</p>
<p>We have a candidate, however, we need to make sure the dominating variable upper bound didn't change.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002526">Todo</a></b></dt><dd>(user): It look like testing this is not really necessary. The reduction done by this class seem to be order independent. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>we assumed that a fixed point was reached before this is called, so modified_domains should have been empty as we entered this function. If not, the code is still correct, but we might miss some reduction, they will still likely be done later though.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002527">Todo</a></b></dt><dd>(user): Is this needed? </dd></dl>
<p>The rest of the loop only care about Booleans. And if this was boolean, we would have fixed it. If it became Boolean, we wait for the next call. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002528">Todo</a></b></dt><dd>(user): maybe the last point can be improved. </dd></dl>
<p>The newly added implication can break the hint only if the hint value of <code>ref</code> is 1 and the hint value of <code>dom_ref</code> is 0. In this case the call below fixes it by negating both values. Otherwise it does nothing and thus preserves its feasibility.</p>
<p>dom&ndash; or var++ are now forbidden.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002529">Todo</a></b></dt><dd>(user): We should probably be able to do something with this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l01515">1515</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<a id="abc34dbcdae318ae9788e4448a65acecc" name="abc34dbcdae318ae9788e4448a65acecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc34dbcdae318ae9788e4448a65acecc">&#9670;&#160;</a></span>ExpressionContainsSingleRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ExpressionContainsSingleRef </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a linear expression can be reduced to a single ref. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00615">615</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a75cf12df936171c3abd17cf962264dcb" name="a75cf12df936171c3abd17cf962264dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf12df936171c3abd17cf962264dcb">&#9670;&#160;</a></span>ExpressionIsAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ExpressionIsAffine </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the expression is affine or constant. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00620">620</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="ab1263f7cb0bf4a69c2981e643af985f5" name="ab1263f7cb0bf4a69c2981e643af985f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1263f7cb0bf4a69c2981e643af985f5">&#9670;&#160;</a></span>ExpressionsContainsOnlyOneVar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ExpressionList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ExpressionsContainsOnlyOneVar </td>
          <td>(</td>
          <td class="paramtype">const ExpressionList &amp;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there exactly one variable appearing in all the expressions. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00270">270</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="ad6957a99e6ed65e43b44bf86a846822c" name="ad6957a99e6ed65e43b44bf86a846822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6957a99e6ed65e43b44bf86a846822c">&#9670;&#160;</a></span>ExtendNegativeFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerValue(IntegerValue)&gt; operations_research::sat::ExtendNegativeFunction </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; IntegerValue(IntegerValue)&gt;</td>          <td class="paramname"><span class="paramname"><em>base_f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>period</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a super-additive non-decreasing function f(), we periodically extend its restriction from [-period, 0] to Z. Such extension is not always super-additive and it is up to the caller to know when this is true or not. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8h_source.html#l00373">373</a> of file <a class="el" href="cuts_8h_source.html">cuts.h</a>.</p>

</div>
</div>
<a id="adeb8d3a8598889ab54b14dd56b56ae1b" name="adeb8d3a8598889ab54b14dd56b56ae1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb8d3a8598889ab54b14dd56b56ae1b">&#9670;&#160;</a></span>ExtractAllSubsetsFromForest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ExtractAllSubsetsFromForest </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>subset_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; absl::Span&lt; const int &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>subsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>node_limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;int&#160;&gt;::max()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of rooted tree on n nodes represented by the parent vector, returns the n sets of nodes corresponding to all the possible subtree. Note that the output memory is just n as all subset will point into the same vector.</p>
<p>This assumes no cycles, otherwise it will not crash but the result will not be correct.</p>
<p>In the TSP context, if the tree is a Gomory-Hu cut tree, this will returns a set of "min-cut" that contains a min-cut for all node pairs.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002273">Todo</a></b></dt><dd>(user): This also allocate O(n) memory internally, we could reuse it from call to call if needed. </dd></dl>
<p>To not reallocate memory since we need the span to point inside this vector, we resize subset_data right away.</p>
<p>Starts by creating the corresponding graph and find the root.</p>
<p>Perform a dfs on the rooted tree. The subset_data will just be the node in post-order.</p>
<p>The node was already explored, output its subtree and pop it.</p>
<p>Explore.</p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01079">1079</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="a2df0c7e4537cd6479226c6262db24f18" name="a2df0c7e4537cd6479226c6262db24f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df0c7e4537cd6479226c6262db24f18">&#9670;&#160;</a></span>ExtractAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ExtractAssignment </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; *</td>          <td class="paramname"><span class="paramname"><em>assignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the assignment from the solver into the given Boolean vector. Note that variables with a greater index that the given num_variables are ignored. </p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00063">63</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a1fe04b2641ce52e27d22fd205da99f06" name="a1fe04b2641ce52e27d22fd205da99f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe04b2641ce52e27d22fd205da99f06">&#9670;&#160;</a></span>ExtractAssumptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::ExtractAssumptions </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>stratified_lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the assumptions from the nodes.</p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00549">549</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a89efb582832622f508e29d0c32f56ca9" name="a89efb582832622f508e29d0c32f56ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89efb582832622f508e29d0c32f56ca9">&#9670;&#160;</a></span>ExtractElementEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ExtractElementEncoding </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract element encodings from exactly_one constraints and lit =&gt; var == value constraints. This function must be called after <a class="el" href="#afa73e23a5cfae0eaf253c2e2518e05e7">ExtractEncoding()</a> has been called. </p>
<p>Scan all exactly_one constraints and look for literal =&gt; var == value to detect element encodings.</p>
<p>Project the implied values onto each integer variable.</p>
<p>Used for logging only.</p>
<p><a class="el" href="classoperations__research_1_1Search.html" title="---------------— Search class --------------—">Search</a> for variable fully covered by the literals of the exactly_one.</p>
<p>We use the order of literals of the exactly_one.</p>
<p>Encode the holes propagation (but we don't create extra literal if they are not already there). If there are non-encoded values we also add the direct min/max propagation.</p>
<p>Lets not create var &gt;= value or var &lt;= value if they do not exist.</p>
<p>We do not create an extra literal if it doesn't exist.</p>
<p>If all literal supporting a value are false, then the value must be false. Note that such a clause is only useful if there are more than one literal supporting the value, otherwise we should already have detected the equivalence.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001291">Todo</a></b></dt><dd>(user): It should be safe otherwise the exactly_one will have duplicate literal, but I am not sure that if presolve is off we can assume that. </dd></dl>
<p>And the &lt;= side.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00682">682</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="afa73e23a5cfae0eaf253c2e2518e05e7" name="afa73e23a5cfae0eaf253c2e2518e05e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa73e23a5cfae0eaf253c2e2518e05e7">&#9670;&#160;</a></span>ExtractEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ExtractEncoding </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The logic assumes that the linear constraints have been presolved, so that equality with a domain bound have been converted to &lt;= or &gt;= and so that we never have any trivial inequalities.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001283">Todo</a></b></dt><dd>(user): Regroup/presolve two encoding like b =&gt; x &gt; 2 and the same Boolean b =&gt; x &gt; 5. These shouldn't happen if we merge linear constraints. </dd></dl>
<p>Extract the encodings (IntegerVariable &lt;-&gt; Booleans) present in the model. This effectively load some linear constraints of size 1 that will be marked as already loaded. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001284">Todo</a></b></dt><dd>(user): Debug what makes it unsat at this point. </dd></dl>
<p>Detection of literal equivalent to (i_var == value). We collect all the half-reified constraint lit =&gt; equality or lit =&gt; inequality for a given variable, and we will later sort them to detect equivalence.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001285">Todo</a></b></dt><dd>(user): We will re-add the same implied bounds during probing, so it might not be necessary to do that here. Also, it might be too early if some of the literal view used in the LP are created later, but that should be fixable via calls to implied_bounds-&gt;NotifyNewIntegerView(). </dd></dl>
<p>Detection of literal equivalent to (i_var &gt;= bound). We also collect all the half-refied part and we will sort the vector for detection of the equivalence.</p>
<p>Loop over all constraints and fill var_to_equalities and inequalities.</p>
<p>ct is a linear constraint with one term and one enforcement literal.</p>
<p>Detect enforcement_literal =&gt; (var &gt;= value or var &lt;= value).</p>
<p>Detect implied bounds. The test is less strict than the above test.</p>
<p>Detect enforcement_literal =&gt; (var == value or var != value).</p>
<dl class="section note"><dt>Note</dt><dd>for domain with 2 values like [0, 1], we will detect both == 0 and != 1. Similarly, for a domain in [min, max], we should both detect (== min) and (&lt;= min), and both detect (== max) and (&gt;= max).</dd></dl>
<p>Detect <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &lt;=&gt; X &gt;= value</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001286">Todo</a></b></dt><dd>(user): In these cases, we could fix the enforcement literal right away or ignore the constraint. Note that it will be done later anyway though. </dd></dl>
<p>Encode the half-inequalities.</p>
<p>Detect <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &lt;=&gt; X == value and associate them in the <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001287">Todo</a></b></dt><dd>(user): Fully encode variable that are almost fully encoded? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001288">Todo</a></b></dt><dd>(user): Try to remove it. Normally we caught UNSAT above, but tests are very flaky (it only happens in parallel). Keeping it there for the time being. </dd></dl>
<p>Encode the half-equalities.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001289">Todo</a></b></dt><dd>(user): delay this after <a class="el" href="#ad1ebf465eb7ccee4f79a5b8cfccfe7d9">PropagateEncodingFromEquivalenceRelations()</a>? Otherwise we might create new Boolean variables for no reason. Note however, that in the presolve, we should only use the "representative" in linear constraints, so we should be fine. </dd></dl>
<p>If we have just an half-equality, lets not create the &lt;=&gt; literal but just add two implications. If we don't create hole, we don't really need the reverse literal. This way it is also possible for the <a class="el" href="#a89efb582832622f508e29d0c32f56ca9">ExtractElementEncoding()</a> to detect later that actually this literal is &lt;=&gt; to var == value, and this way we create one less Boolean for the same result.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001290">Todo</a></b></dt><dd>(user): It is not 100% clear what is the best encoding and if we should create equivalent literal or rely on propagator instead to push bounds. </dd></dl>
<p>Update stats.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00397">397</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a443952c1a8ca3d057c079644f71dc0fd" name="a443952c1a8ca3d057c079644f71dc0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443952c1a8ca3d057c079644f71dc0fd">&#9670;&#160;</a></span>ExtractSubproblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ExtractSubproblem </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearBooleanProblem *</td>          <td class="paramname"><span class="paramname"><em>subproblem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a sub-problem formed by the constraints with given indices. </p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00499">499</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a834cefc490c4046ce63a4c58da9e8ea4" name="a834cefc490c4046ce63a4c58da9e8ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834cefc490c4046ce63a4c58da9e8ea4">&#9670;&#160;</a></span>ExtractSubSolverName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::ExtractSubSolverName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>improvement_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We assume the subsolver name is always first.</p>

<p class="definition">Definition at line <a class="el" href="synchronization_8cc_source.html#l00780">780</a> of file <a class="el" href="synchronization_8cc_source.html">synchronization.cc</a>.</p>

</div>
</div>
<a id="ac9d08e5135a1ae71b571b14fbff3381b" name="ac9d08e5135a1ae71b571b14fbff3381b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d08e5135a1ae71b571b14fbff3381b">&#9670;&#160;</a></span>FailedLiteralProbingRound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::FailedLiteralProbingRound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html">ProbingOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to ProbeBooleanVariables() but different :-)</p>
<p>First, this do not consider integer variable. It doesn't do any disjunctive reasoning (i.e. changing the domain of an integer variable by intersecting it with the union of what happen when x is fixed and not(x) is fixed).</p>
<p>However this should be more efficient and just work better for pure Boolean problems. On integer problems, we might also want to run this one first, and then do just one quick pass of ProbeBooleanVariables().</p>
<dl class="section note"><dt>Note</dt><dd>this by itself just do one "round", look at the code in the <a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html">Inprocessing</a> class that call this interleaved with other reductions until a fix point is reached.</dd></dl>
<p>This can fix a lot of literals via failed literal detection, that is when we detect that x =&gt; not(x) via propagation after taking x as a decision. It also use the strongly connected component algorithm to detect equivalent literals.</p>
<p>It will add any detected binary clause (via hyper binary resolution) to the implication graph. See the option comments for more details. </p>
<p>Reset the solver in case it was already used.</p>
<p>When called from <a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html">Inprocessing</a>, the implication graph should already be a DAG, so these two calls should return right away. But we do need them to get the topological order if this is used in isolation.</p>
<p>This is only needed when options.use_queue is true.</p>
<p>This is only needed when options use_queue is false;</p>
<p>We delay fixing of already assigned literal once we go back to level zero.</p>
<p>Depending on the options. we do not use the same order. With tree look, it is better to start with "leaf" first since we try to reuse propagation as much as possible. This is also interesting to do when extracting binary clauses since we will need to propagate everyone anyway, and this should result in less clauses that can be removed later by transitive reduction.</p>
<p>However, without tree-look and without the need to extract all binary clauses, it is better to just probe the root of the binary implication graph. This is exactly what happen when we probe using the topological order.</p>
<p>We only use this for the queue version.</p>
<p>We only enqueue literal at level zero if we don't use "tree look".</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002242">Todo</a></b></dt><dd>(user): Instead of minimizing index in topo order (which might be nice for binary extraction), we could try to maximize reusability in some way. </dd></dl>
<p>Probe a literal that implies previous decision.</p>
<p>This is a backtrack marker, go back one level.</p>
<p>Fix any delayed fixed literal.</p>
<p>Probe an unexplored node.</p>
<p>The pass is finished.</p>
<p>Probe a literal that implies previous decision.</p>
<dl class="section note"><dt>Note</dt><dd>contrary to the queue based implementation, this do not process them in a particular order.</dd></dl>
<p>candidate =&gt; previous =&gt; not(candidate), so we can fix it.</p>
<p>This shouldn't happen if extract_binary_clauses is false. We have an equivalence.</p>
<p>Sync the queue with the new level.</p>
<p>Fix <code>next_decision</code> to <code>false</code> if not already done.</p>
<p>Even if we fixed something at level zero, next_decision might not be fixed! But we can fix it. It can happen because when we propagate with clauses, we might have <code>a =&gt; b</code> but not <code>not(b) =&gt; not(a)</code>. Like <code>a =&gt; b</code> and clause <code>(not(a), not(b), c)</code>, propagating <code>a</code> will set <code>c</code>, but propagating <code>not(c)</code> will not do anything.</p>
<p>We "delay" the fixing if we are not at level zero so that we can still reuse the current propagation work via tree look.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002243">Todo</a></b></dt><dd>(user): Can we be smarter here? Maybe we can still fix the literal without going back to level zero by simply enqueuing it with no reason? it will be backtracked over, but we will still lazily fix it later. </dd></dl>
<p>Inspect the newly propagated literals. Depending on the options, try to extract binary clauses via hyper binary resolution and/or mark the literals on the trail so that they do not need to be probed later.</p>
<p>If we can extract a binary clause that subsume the reason clause, we do add the binary and remove the subsumed clause.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002244">Todo</a></b></dt><dd>(user): We could be slightly more generic and subsume some clauses that do not contains last_decision.Negated(). </dd></dl>
<p>We need to change the reason now that the clause is cleared.</p>
<p>Anything not propagated by the <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">BinaryImplicationGraph</a> is a "new" binary clause. This is because the <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">BinaryImplicationGraph</a> has the highest priority of all propagators.</p>
<p>Note(user): This is not 100% true, since when we launch the clause propagation for one literal we do finish it before calling again the binary propagation.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002245">Todo</a></b></dt><dd>(user): Think about trying to extract clause that will not get removed by transitive reduction later. If we can both extract a =&gt; c and b =&gt; c , ideally we don't want to extract a =&gt; c first if we already know that a =&gt; b.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002246">Todo</a></b></dt><dd>(user): Similar to previous point, we could find the LCA of all literals in the reason for this propagation. And use this as a reason for later hyber binary resolution. Like we do when this clause subsume the reason. </dd></dl>
<p>If we don't extract binary, we don't need to explore any of these literal until more variables are fixed.</p>
<p>Inspect the watcher list for last_decision, If we have a blocking literal at true (implied by last decision), then we have subsumptions.</p>
<p>The intuition behind this is that if a binary clause (a,b) subsume a clause, and we watch a.Negated() for this clause with a blocking literal b, then this watch entry will never change because we always propagate binary clauses first and the blocking literal will always be true. So after many propagations, we hope to have such configuration which is quite cheap to test here.</p>
<p>Tricky: If we have many "decision" and we do not extract the binary clause, then the fact that last_decision =&gt; literal might not be currently encoded in the problem clause, so if we use that relation to subsume, we should make sure it is added.</p>
<dl class="section note"><dt>Note</dt><dd>it is okay to add duplicate binary clause, we will clean that later.</dd></dl>
<p>Add the binary clause if needed. Note that we change the reason to a binary one so that we never add the same clause twice.</p>
<p>Tricky: while last_decision would be a valid reason, we need a reason that was assigned before this literal, so we use the decision at the level where this literal was assigned which is an even better reason. Maybe it is just better to change all the reason above to a binary one so we don't have an issue here.</p>
<p>If the variable was true at level zero, there is no point adding the clause.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002247">Todo</a></b></dt><dd>(user): We might just want to do that even more lazily by checking for detached clause while propagating here? and do a big cleanup at the end. </dd></dl>
<p>Display stats.</p>

<p class="definition">Definition at line <a class="el" href="probing_8cc_source.html#l00500">500</a> of file <a class="el" href="probing_8cc_source.html">probing.cc</a>.</p>

</div>
</div>
<a id="a901c19b12842f8af153e588a689a90b5" name="a901c19b12842f8af153e588a689a90b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901c19b12842f8af153e588a689a90b5">&#9670;&#160;</a></span>FillDomainInProto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoWithDomain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::FillDomainInProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtoWithDomain *</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> into the domain field of a proto. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00133">133</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="aee030f8f392170e436c92454e2a7fbc5" name="aee030f8f392170e436c92454e2a7fbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee030f8f392170e436c92454e2a7fbc5">&#9670;&#160;</a></span>FillTightenedDomainInResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::FillTightenedDomainInResponse </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>original_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>postsolve_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>search_domains</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpSolverResponse *</td>          <td class="paramname"><span class="paramname"><em>response</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to postsolve with a "best-effort" the reduced domain from the presolved model to the user given model. See the documentation of the CpSolverResponse tightened_variables field for more information on the caveats. </p>
<p>The [0, num_vars) part will contain the tightened domains.</p>
<p>Start with the domain from the mapping proto. Note that by construction this should be tighter than the original variable domains.</p>
<p>The first test is for the corner case of presolve closing the problem, in which case there is no more info to process.</p>
<p>Currently no mapping should mean all variables are in common. This happen when presolve is disabled, but we might still have more variables due to expansion for instance.</p>
<p>There is also the corner case of presolve closing the problem,</p>
<p>This is the normal presolve case. Intersect the domain of the variables in common.</p>
<p>Look for affine relation, and do more intersection.</p>
<p>We can reduce the domain of v1 by using the affine relation and the domain of v2. We have c1 * v2 + c2 * v2 = offset;</p>
<p>Copy the names and replace domains.</p>
<p>Some stats.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00466">466</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a546e46146833c0fe056cccbbdc65fb11" name="a546e46146833c0fe056cccbbdc65fb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546e46146833c0fe056cccbbdc65fb11">&#9670;&#160;</a></span>FilterAssignedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::FilterAssignedLiteral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>assignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>core</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A core cannot be all true. </p>
<p>Remove fixed literals from the core. </p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00196">196</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="a3f0be3244a48d1875afbbb1fa690d743" name="a3f0be3244a48d1875afbbb1fa690d743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0be3244a48d1875afbbb1fa690d743">&#9670;&#160;</a></span>FilterBoxesAndRandomize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Span&lt; int &gt; operations_research::sat::FilterBoxesAndRandomize </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cached_rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>threshold_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>threshold_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes boxes with a size above the thresholds. Also randomize the order. Because we rely on various heuristic, this allow to change the order from one call to the next. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00390">390</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a56f440f63eee04ede634a116041adf7b" name="a56f440f63eee04ede634a116041adf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f440f63eee04ede634a116041adf7b">&#9670;&#160;</a></span>FilterBoxesThatAreTooLarge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Span&lt; int &gt; operations_research::sat::FilterBoxesThatAreTooLarge </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>cached_rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>energies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>boxes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the total energy of all rectangles (sum of energies[box]) we know that any box with an area greater than that cannot participate in any "bounding
box" conflict. As we remove this box, the total energy decrease, so we might remove more. This works in O(n log n). </p>
<p>Sort the boxes by increasing area.</p>
<p>Remove all the large boxes until we have one with area smaller than the energy of the boxes below.</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00406">406</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a7287180e6e143d0a2c6f6e6c206cc656" name="a7287180e6e143d0a2c6f6e6c206cc656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7287180e6e143d0a2c6f6e6c206cc656">&#9670;&#160;</a></span>FilterOrbitOnUnusedOrFixedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::FilterOrbitOnUnusedOrFixedVariables </td>
          <td>(</td>
          <td class="paramtype">SymmetryProto *</td>          <td class="paramname"><span class="paramname"><em>symmetry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This make sure all variables from the same orbit have the same domain. We also remove from the generator cycles on fixed or removed variables.</p>
<p>Returns false on UNSAT. </p>
<p>We process each cycle at once. If all variables from a cycle are fixed to the same value, this is fine and we can just remove the cycle.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001601">Todo</a></b></dt><dd>(user): These are just basic checks and do not guarantee that we properly kept this symmetry in the presolve.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001602">Todo</a></b></dt><dd>(user): Deal with case where all variable in an orbit has been found to be equivalent to each other. Or all variables have affine representative, like if all domains where [0][2], we should have remapped all such variable to Booleans. </dd></dl>
<p>If we have affine relation, we only support the case where they are all the same.</p>
<dl class="section note"><dt>Note</dt><dd>the order matter. If all have the same representative, we don't care about this one.</dd></dl>
<p>Lets keep this cycle.</p>
<p>Lets remove empty generators.</p>
<p>Lets output the new statistics. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001603">Todo</a></b></dt><dd>(user): Avoid the reconvertion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__symmetries_8cc_source.html#l01583">1583</a> of file <a class="el" href="cp__model__symmetries_8cc_source.html">cp_model_symmetries.cc</a>.</p>

</div>
</div>
<a id="a9665c030067d31a2aa2c9376228eab59" name="a9665c030067d31a2aa2c9376228eab59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9665c030067d31a2aa2c9376228eab59">&#9670;&#160;</a></span>FinalExpansionForLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::FinalExpansionForLinearConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Linear constraint with a complex rhs need to be expanded at the end of the presolve. We do that at the end, because the presolve is allowed to simplify such constraints by updating the rhs. Also the extra variable we create are only linked by a few constraints to the rest of the model and should not be pre-solvable. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__expand_8cc_source.html#l02600">2600</a> of file <a class="el" href="cp__model__expand_8cc_source.html">cp_model_expand.cc</a>.</p>

</div>
</div>
<a id="a0f79d28fdcdb115fb186792a0c215540" name="a0f79d28fdcdb115fb186792a0c215540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f79d28fdcdb115fb186792a0c215540">&#9670;&#160;</a></span>FindBestScalingAndComputeErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::FindBestScalingAndComputeErrors </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>lower_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_absolute_activity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>wanted_absolute_activity_precision</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>relative_coeff_error</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>scaled_sum_error</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a linear expression Sum_i c_i * X_i with each X_i in [lb_i, ub_i], this returns a scaling factor f such that 1/ the rounded expression cannot overflow given the domains of the X_i: Sum |std::round(f * c_i) * X_i| &lt;= max_absolute_activity 2/ the error is bounded: | Sum_i (std::round(f * c_i) - f * c_i) | &lt; f * wanted_absolute_activity_precision</p>
<p>This also fills the exact errors made by using the returned scaling factor. The heuristics try to minimize the magnitude of the scaled expression while satisfying the requested precision.</p>
<p>Returns 0.0 if no scaling factor can be found under the condition 1/. Note that we try really hard to satisfy 2/ but we still return our best shot even when 2/ is not satisfied. One can check this by comparing the returned scaled_sum_error / f with wanted_absolute_activity_precision.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002076">Todo</a></b></dt><dd><p class="startdd">(user): unit test this and move to fp_utils. </p>
<p class="enddd">(user): Ideally the lower/upper should be int64_t so that we can have an exact definition for the max_absolute_activity allowed. </p>
</dd></dl>
<p>Starts by computing the highest possible factor.</p>
<p>Returns the smallest factor of the form 2^i that gives us a relative sum error of wanted_absolute_activity_precision and still make sure we will have no integer overflow.</p>
<p>Important: the loop is written in such a way that <a class="el" href="namespaceoperations__research.html#aaf20e043696e44c2ba09e4d6ee85e74e">ComputeScalingErrors()</a> is called on the last factor.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002069">Todo</a></b></dt><dd>(user): Make this faster. </dd></dl>
<p>This could happen if we always have enough precision.</p>
<p>Because we deal with an approximate input, scaling with a power of 2 might not be the best choice. It is also possible user used rational coeff and then converted them to double (1/2, 1/3, 4/5, etc...). This scaling will recover such rational input and might result in a smaller overall coefficient which is good.</p>
<dl class="section note"><dt>Note</dt><dd>if our current precisions is already above the requested one, we choose integer scaling if we get a better precision.</dd></dl>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00872">872</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a84f3aff918cf9fa95f5922cbb93d125e" name="a84f3aff918cf9fa95f5922cbb93d125e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f3aff918cf9fa95f5922cbb93d125e">&#9670;&#160;</a></span>FindCombinedSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::vector&lt; int64_t &gt; &gt; operations_research::sat::FindCombinedSolution </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>base_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *</td>          <td class="paramname"><span class="paramname"><em>response_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>solution_info</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a <code>new_solution</code> that was created by changing a bit a <code>base_solution</code>, try to apply the same changes to the other solutions stored in the <code>response_manager</code> and return any such generated solution that is valid. </p>

<p class="definition">Definition at line <a class="el" href="combine__solutions_8cc_source.html#l00049">49</a> of file <a class="el" href="combine__solutions_8cc_source.html">combine_solutions.cc</a>.</p>

</div>
</div>
<a id="ae16bafcf3c5377ed905021a96f93bdcf" name="ae16bafcf3c5377ed905021a96f93bdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16bafcf3c5377ed905021a96f93bdcf">&#9670;&#160;</a></span>FindCpModelSymmetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::FindCpModelSymmetries </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>generators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>deterministic_limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of generators of the symmetry group of the given problem. Each generator is a permutation of the integer range [0, n) where n is the number of variables of the problem. They are permutations of the (index representation of the) problem variables.</p>
<dl class="section note"><dt>Note</dt><dd>we ignore the variables that appear in no constraint, instead of outputing the full symmetry group involving them.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001615">Todo</a></b></dt><dd>(user): On SAT problems it is more powerful to detect permutations also involving the negation of the problem variables. So that we could find a symmetry x &lt;-&gt; not(y) for instance.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001616">Todo</a></b></dt><dd>(user): As long as we only exploit symmetry involving only Boolean variables we can make this code more efficient by not detecting symmetries involing integer variable. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001587">Todo</a></b></dt><dd>(user): Change the API to not return an error when the time limit is reached. </dd></dl>
<p>Remove from the permutations the part not concerning the variables. </p><dl class="section note"><dt>Note</dt><dd>some permutations may become empty, which means that we had duplicate constraints.</dd></dl>
<p>Because variable nodes are in a separate equivalence class than any other node, a cycle can either contain only variable nodes or none, so we just need to check one element of the cycle.</p>
<p>Verify that the cycle's entire support does not touch any variable.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__symmetries_8cc_source.html#l00646">646</a> of file <a class="el" href="cp__model__symmetries_8cc_source.html">cp_model_symmetries.cc</a>.</p>

</div>
</div>
<a id="a2e4999dc16f55afa8c5d30a733a26e3d" name="a2e4999dc16f55afa8c5d30a733a26e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4999dc16f55afa8c5d30a733a26e3d">&#9670;&#160;</a></span>FindDuplicateConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; operations_research::sat::FindDuplicateConstraints </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_enforcement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of duplicate constraints in the given proto in the first element of each pair. The second element of each pair is the "representative" that is the first constraint in the proto in a set of duplicate constraints.</p>
<p>Empty constraints are ignored. We also do a bit more:</p><ul>
<li>We ignore names when comparing constraint.</li>
<li>For linear constraints, we ignore the domain. This is because we can just merge them if the constraints are the same.</li>
<li>We return the special kObjectiveConstraint (&lt; 0) representative if a linear constraint is parallel to the objective and has no enforcement literals. The domain of such constraint can just be merged with the objective domain.</li>
</ul>
<p>If ignore_enforcement is true, we ignore enforcement literal, but do not do the linear domain or objective special cases. This allow to cover some other cases like:</p><ul>
<li>enforced constraint duplicate of non-enforced one.</li>
<li>Two enforced constraints with singleton enforcement (vpphard).</li>
</ul>
<p>Visible here for testing. This is meant to be called at the end of the presolve where constraints have been canonicalized. </p>
<p>We use a map hash that uses the underlying constraint to compute the hash and the equality for the indices.</p>
<p>Create a special representative for the linear objective.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001499">Todo</a></b></dt><dd>(user): we could delete duplicate identical interval, but we need to make sure reference to them are updated. </dd></dl>
<p>Nothing we will presolve in this case.</p>
<p>Already present!</p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l14026">14026</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="a557dbf01937df17542da0144682913cd" name="a557dbf01937df17542da0144682913cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557dbf01937df17542da0144682913cd">&#9670;&#160;</a></span>FindEmptySpaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; operations_research::sat::FindEmptySpaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bounding_box</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ocupied_rectangles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a bounding box and a list of rectangles inside that bounding box, returns a list of rectangles partitioning the empty area inside the bounding box. </p>
<p>Sorting is not necessary for correctness but makes it faster.</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l01600">1600</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a75271e8da6c6cb4c5c87226e150d47d7" name="a75271e8da6c6cb4c5c87226e150d47d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75271e8da6c6cb4c5c87226e150d47d7">&#9670;&#160;</a></span>FindLinearBooleanProblemSymmetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::FindLinearBooleanProblemSymmetries </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>generators</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of generators of the symmetry group of the given problem. Each generator is a permutation of the integer range [0, 2n) where n is the number of variables of the problem. They are permutations of the (index representation of the) problem literals. </p>
<p>Remap the graph nodes to sort them by equivalence classes.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001118">Todo</a></b></dt><dd>(user): inject the appropriate time limit here. </dd></dl>
<p>Remove from the permutations the part not concerning the literals. </p><dl class="section note"><dt>Note</dt><dd>some permutation may becomes empty, which means that we had duplicates constraints. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001119">Todo</a></b></dt><dd>(user): Remove them beforehand? </dd></dl>
<p>Verify that the cycle's entire support does not touch any variable.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00683">683</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a4dfb3b053c2a90810e5d46bcd80f450f" name="a4dfb3b053c2a90810e5d46bcd80f450f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfb3b053c2a90810e5d46bcd80f450f">&#9670;&#160;</a></span>FindOneIntersectionIfPresent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; int, int &gt; &gt; operations_research::sat::FindOneIntersectionIfPresent </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is faster that the <a class="el" href="#acd64e55540ba0780860b048ebe2810bc">FindPartialRectangleIntersections()</a> if one only want to know if there is at least one intersection. It is in O(N log N).</p>
<p>IMPORTANT: this assumes rectangles are already sorted by their x_min and does not support degenerate rectangles with zero area.</p>
<p>If a pair {i, j} is returned, we will have i &lt; j, and no intersection in the subset of rectanges in [0, j). </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l02109">2109</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="ac9cf3e62055df8605ab8f160c4557591" name="ac9cf3e62055df8605ab8f160c4557591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cf3e62055df8605ab8f160c4557591">&#9670;&#160;</a></span>FindOneIntersectionIfPresentWithZeroArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; int, int &gt; &gt; operations_research::sat::FindOneIntersectionIfPresentWithZeroArea </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a4dfb3b053c2a90810e5d46bcd80f450f">FindOneIntersectionIfPresent()</a> but supports degenerate rectangles with zero area. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l02114">2114</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="acd64e55540ba0780860b048ebe2810bc" name="acd64e55540ba0780860b048ebe2810bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd64e55540ba0780860b048ebe2810bc">&#9670;&#160;</a></span>FindPartialRectangleIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; operations_research::sat::FindPartialRectangleIntersections </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given a set of N rectangles in <code>rectangles</code>, there might be up to N*(N-1)/2 pairs of rectangles that intersect one another. If each of these pairs describe an arc and each rectangle describe a node, the rectangles and their intersections describe a graph. This function returns the full spanning forest for this graph (ie., a spanning tree for each connected component). This function allows to know if a set of rectangles has any intersection, find an example intersection for each rectangle that has one, or split the rectangles into connected components according to their intersections.</p>
<p>The returned tuples are the arcs of the spanning forest represented by their indices in the input vector.</p>
<p>This function works with degenerate rectangles (ie., points or lines) and have the same semantics for overlap as <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html#abfdcdc50770cdb036245da007fe6e0a8">Rectangle::IsDisjoint()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(N (log N)^2) time on the input size, which would be impossible to do if we were to return all the intersections, which can be quadratic in number. </dd></dl>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l02101">2101</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a90a029475f2aeb7c0836c71197e45029" name="a90a029475f2aeb7c0836c71197e45029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a029475f2aeb7c0836c71197e45029">&#9670;&#160;</a></span>FindPartialRectangleIntersectionsImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; operations_research::sat::FindPartialRectangleIntersectionsImpl </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle32.html">Rectangle32</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires that rectangles are sorted by x_min and that sizes on both dimensions are &gt; 0. </p>
<p>We are going to use a sweep line algorithm to find the intersections. First, we sort the rectangles by their x coordinates, then consider a sweep line that goes from the left to the right. See the comment on the <a class="el" href="structoperations__research_1_1sat_1_1SweepLineIntervalTree.html">SweepLineIntervalTree</a> class for more details about what we store for each line.</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l01814">1814</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a2fa3c7d5ae90dfbcdf080ee3cefbedda" name="a2fa3c7d5ae90dfbcdf080ee3cefbedda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa3c7d5ae90dfbcdf080ee3cefbedda">&#9670;&#160;</a></span>FindRationalFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::FindRationalFactor </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This uses the best rational approximation of x via continuous fractions. It is probably not the best implementation, but according to the unit test, it seems to do the job.</p>
<p>Returns the smallest factor f such that f * abs(x) is integer modulo the given tolerance relative to f (we use f * tolerance). It is only looking for f smaller than the given limit. Returns zero if no such factor exist below the limit.</p>
<p>The complexity is a lot less than O(limit), but it is possible that we might miss the smallest such factor if the tolerance used is too low. This is because we only rely on the best rational approximations of x with increasing denominator. </p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00133">133</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a9c95d68b46f17e3aa215ce63ea446514" name="a9c95d68b46f17e3aa215ce63ea446514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c95d68b46f17e3aa215ce63ea446514">&#9670;&#160;</a></span>FindRectanglesWithEnergyConflictMC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1FindRectanglesResult.html">FindRectanglesResult</a> operations_research::sat::FindRectanglesWithEnergyConflictMC </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>intervals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>temperature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>candidate_energy_usage_factor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pick a change with a probability proportional to exp(- delta_E / Temp)</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l01513">1513</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a0e5aedd2ff7497d3def1e999afd71f6f" name="a0e5aedd2ff7497d3def1e999afd71f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5aedd2ff7497d3def1e999afd71f6f">&#9670;&#160;</a></span>FindSingleLinearDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::FindSingleLinearDifference </td>
          <td>(</td>
          <td class="paramtype">const LinearConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>lin1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>lin2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>var1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>coeff1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>var2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>coeff2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#ab84b1a369118c0ee55fd26133eb9bcc4">LinearsDifferAtOneTerm()</a> below but also fills the differing terms. </p>
<dl class="section note"><dt>Note</dt><dd>we can't have both undefined or the loop would have exited.</dd></dl>
<p>Same term, continue.</p>
<p>We have a diff. term i not in lin2.</p>
<p>term j not in lin1.</p>
<p>Coeff differ. Returns if we had a diff previously.</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00689">689</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="a70f1774c343aaebb5a3d9686e12e7f7e" name="a70f1774c343aaebb5a3d9686e12e7f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f1774c343aaebb5a3d9686e12e7f7e">&#9670;&#160;</a></span>FingerprintExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t operations_research::sat::FingerprintExpression </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>lin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a stable fingerprint of a linear expression. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00696">696</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a7492392221bdfcc832cce2d93c9b681c" name="a7492392221bdfcc832cce2d93c9b681c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7492392221bdfcc832cce2d93c9b681c">&#9670;&#160;</a></span>FingerprintModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t operations_research::sat::FingerprintModel </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a stable fingerprint of a model. </p>
<p>Fingerprint the objective.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001622">Todo</a></b></dt><dd>(user): Should we fingerprint decision strategies? </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00707">707</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a1352f3fb2b6e1a4186a12473bb2b6d8e" name="a1352f3fb2b6e1a4186a12473bb2b6d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1352f3fb2b6e1a4186a12473bb2b6d8e">&#9670;&#160;</a></span>FingerprintRepeatedField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t operations_research::sat::FingerprintRepeatedField </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::RepeatedField&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sequence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00289">289</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a6494711186bdd07baa40f2f99718de24" name="a6494711186bdd07baa40f2f99718de24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6494711186bdd07baa40f2f99718de24">&#9670;&#160;</a></span>FingerprintSingleField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t operations_research::sat::FingerprintSingleField </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00297">297</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a28a1d7fdb9ee5a88b771b2965bf18596" name="a28a1d7fdb9ee5a88b771b2965bf18596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a1d7fdb9ee5a88b771b2965bf18596">&#9670;&#160;</a></span>FirstUnassignedVarAtItsMinHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::FirstUnassignedVarAtItsMinHeuristic </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001860">Todo</a></b></dt><dd>(user): the complexity caused by the linear scan in this heuristic and the one below is ok when search_branching is set to SAT_SEARCH because it is not executed often, but otherwise it is done for each search decision, which seems expensive. Improve. </dd></dl>
<p><a class="el" href="classoperations__research_1_1Decision.html">Decision</a> heuristic for <a class="el" href="#a78d12c07dbcc1ac097e51359ac299aea">SolveIntegerProblemWithLazyEncoding()</a>. Returns a function that will return the literal corresponding to the fact that the first currently non-fixed variable value is &lt;= its min. The function will return kNoLiteralIndex if all the given variables are fixed.</p>
<dl class="section note"><dt>Note</dt><dd>this function will create the associated literal if needed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00171">171</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a41ea57d3df7b63f7be86a96eca1d0cf8" name="a41ea57d3df7b63f7be86a96eca1d0cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ea57d3df7b63f7be86a96eca1d0cf8">&#9670;&#160;</a></span>FixedDivisionConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::FixedDivisionConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the constraint: a / b = c where b is a constant. </p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00810">810</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="ad9f0785106a02e030ddee919ff33bd0d" name="ad9f0785106a02e030ddee919ff33bd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f0785106a02e030ddee919ff33bd0d">&#9670;&#160;</a></span>FixedModuloConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::FixedModuloConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the constraint: a % b = c where b is a constant. </p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00824">824</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a4a0524e31331a03f6d21a75bc4421aeb" name="a4a0524e31331a03f6d21a75bc4421aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0524e31331a03f6d21a75bc4421aeb">&#9670;&#160;</a></span>FixedWeightedSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::FixedWeightedSum </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorInt &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weighted sum == constant. </p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00460">460</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="add5fc3553106ac67afaf0b8525d7f110" name="add5fc3553106ac67afaf0b8525d7f110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5fc3553106ac67afaf0b8525d7f110">&#9670;&#160;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::floor </td>
          <td>(</td>
          <td class="paramtype">|P|/</td>          <td class="paramname"><span class="paramname"><em>2</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduces v modulo the elements_to_consider first elements of the (normal form) basis. The leading coeff of a basis element is the last one. In other terms, basis has the form:</p><ul>
<li>A 0 0 0 0 0</li>
<li>* B 0 0 0 0</li>
<li>* * C 0 0 0 ............. with non-zero pivots elements A, B, C, ... and the reduction is performed in such a way that for a pivot P of the basis and the correspond entry x of v at the end of the reduction, we have </li>
</ul>

</div>
</div>
<a id="a07823d046b027c81155f8a2f322cf813" name="a07823d046b027c81155f8a2f322cf813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07823d046b027c81155f8a2f322cf813">&#9670;&#160;</a></span>FloorRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::FloorRatio </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>dividend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>positive_divisor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00081">81</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a392d70cc768a13de271f87123513acf2" name="a392d70cc768a13de271f87123513acf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392d70cc768a13de271f87123513acf2">&#9670;&#160;</a></span>FloorSquareRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::FloorSquareRoot </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The argument must be non-negative. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002493">Todo</a></b></dt><dd>(user): Find better implementation? In practice passing via double is almost always correct, but the <a class="el" href="namespaceoperations__research.html#aa64bf49d041052c7cb3f40f7496d7534">CapProd()</a> might be a bit slow. However this is only called when we do propagate something. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00300">300</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="ac679551eb33dd7fd5168a8d0ab74c82c" name="ac679551eb33dd7fd5168a8d0ab74c82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac679551eb33dd7fd5168a8d0ab74c82c">&#9670;&#160;</a></span>FollowHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::FollowHint </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerVariable.html">BooleanOrIntegerVariable</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is not ideal as we reserve an int for the full duration of the model even if we use this <a class="el" href="#ac679551eb33dd7fd5168a8d0ab74c82c">FollowHint()</a> function just for a while. But it is an easy solution to not have reference to deleted memory in the RevIntRepository(). Note that once we backtrack, these reference will disappear.</p>
<p>If we retake a decision at this level, we will restart from i.</p>
<p>If we retake a decision at this level, we will restart from i.</p>
<p>If the value is outside the current possible domain, we skip it.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l01128">1128</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a88a7a53b2e474d3d5c602030c5c449e9" name="a88a7a53b2e474d3d5c602030c5c449e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a7a53b2e474d3d5c602030c5c449e9">&#9670;&#160;</a></span>FormatCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::FormatCounter </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a positive number with separators for easier reading (ex: 1'348'065). </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00044">44</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="af41bef85b701ac3dd74b685f5232b96b" name="af41bef85b701ac3dd74b685f5232b96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41bef85b701ac3dd74b685f5232b96b">&#9670;&#160;</a></span>FormatName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::FormatName </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used to format our table first row entry. </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8h_source.html#l00204">204</a> of file <a class="el" href="sat_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="af7414c91f17a6ff5a2621fa05fedf7da" name="af7414c91f17a6ff5a2621fa05fedf7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7414c91f17a6ff5a2621fa05fedf7da">&#9670;&#160;</a></span>FormatTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::FormatTable </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spacing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display tabular data by auto-computing cell width. Note that we right align everything but the first row/col that is assumed to be the table name and is left aligned. </p>
<p>We order by name.</p>
<p>We currently only left align the table name.</p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00072">72</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="a7c2c3a42e94b355db103786dd526e2ea" name="a7c2c3a42e94b355db103786dd526e2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2c3a42e94b355db103786dd526e2ea">&#9670;&#160;</a></span>FullMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> operations_research::sat::FullMerge </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges the two given <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> by creating a new node that corresponds to the sum of the two given ones. The given upper_bound is interpreted as a bound on this sum, and allows creating fewer binary variables. </p>
<p>Fix the variable to false because of the given upper_bound.</p>
<p>Fix the variable to false because of the given upper_bound.</p>
<p>if x &lt;= ia and y &lt;= ib, then x + y &lt;= ia + ib.</p>
<p>if x &gt; ia and y &gt; ib, then x + y &gt; ia + ib + 1.</p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00390">390</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a36bf1351ffa74960b3040a96ddc37468" name="a36bf1351ffa74960b3040a96ddc37468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bf1351ffa74960b3040a96ddc37468">&#9670;&#160;</a></span>FullyCompressTuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; absl::InlinedVector&lt; int64_t, 2 &gt; &gt; &gt; operations_research::sat::FullyCompressTuples </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>domain_sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int64_t &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>tuples</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001618">Todo</a></b></dt><dd>(user): We can probably reuse the tuples memory always and never create new one. We should also be able to code an iterative version of this. Note however that the recursion level is bounded by the number of columns which should be small. </dd></dl>
<p>Similar to <a class="el" href="#a1a88950631a19f96084df07209e43d30">CompressTuples()</a> but produces a final table where each cell is a set of value. This should result in a table that can still be encoded efficiently in SAT but with less tuples and thus less extra Booleans. Note that if a set of value is empty, it is interpreted at "any" so we can gain some space.</p>
<p>The passed tuples vector is used as temporary memory and is detroyed. We interpret kTableAnyValue as an "any" tuple.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001620">Todo</a></b></dt><dd>(user): To reduce memory, we could return some absl::Span in the last layer instead of vector.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001621">Todo</a></b></dt><dd>(user): The final compression is depend on the order of the variables. For instance the table (1,1)(1,2)(1,3),(1,4),(2,3) can either be compressed as (1,*)(2,3) or (1,{1,2,4})({1,3},3). More experiment are needed to devise a better heuristic. It might for example be good to call <a class="el" href="#a1a88950631a19f96084df07209e43d30">CompressTuples()</a> first. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__table_8cc_source.html#l00321">321</a> of file <a class="el" href="cp__model__table_8cc_source.html">cp_model_table.cc</a>.</p>

</div>
</div>
<a id="a0185d084af6ad784edced90f45174133" name="a0185d084af6ad784edced90f45174133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0185d084af6ad784edced90f45174133">&#9670;&#160;</a></span>FullyEncodeVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt;(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::FullyEncodeVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calling model.Add(FullyEncodeVariable(var)) will create one literal per value in the domain of var (if not already done), and wire everything correctly. This also returns the full encoding, see the FullDomainEncoding() method of the <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> class. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01659">1659</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a0f8cabd3d98b36018d409338a6875acc" name="a0f8cabd3d98b36018d409338a6875acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8cabd3d98b36018d409338a6875acc">&#9670;&#160;</a></span>GenerateCompletionTimeCutsWithEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GenerateCompletionTimeCutsWithEnergy </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>cut_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CtEvent.html">CtEvent</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>capacity_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_low_sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We generate the cut from the Smith's rule from: M. Queyranne, Structure of a simple scheduling polyhedron, Mathematical Programming 58 (1993), 263–285</p>
<p>The original cut is: sum(end_min_i * size_min_i) &gt;= (sum(size_min_i^2) + sum(size_min_i)^2) / 2 We strengthen this cuts by noticing that if all tasks starts after S, then replacing end_min_i by (end_min_i - S) is still valid.</p>
<p>A second difference is that we lift intervals that starts before a given value, but are forced to cross it. This lifting procedure implies trimming interval to its part that is after the given value.</p>
<p>In the case of a cumulative constraint with a capacity of C, we compute a valid equation by splitting the task (size_min si, demand_min di) into di tasks of size si and demand 1, that we spread across C no_overlap constraint. When doing so, the lhs of the equation is the same, the first term of the rhs is also unchanged. A lower bound of the second term of the rhs is reached when the split is exact (each no_overlap sees a long demand of sum(si * di / C). Thus the second term is greater or equal to (sum (si * di) ^ 2) / (2 * C)</p>
<p>Sometimes, the min energy of the task i is greater than si * di. Let's introduce ai the minimum energy of the task and rewrite the previous equation. In that new setting, we can rewrite the cumulative transformation by splitting each tasks into at least di tasks of size at least si and demand 1.</p>
<p>In that setting, the lhs is rewritten as sum(ai * ei) and the second term of the rhs is rewritten as sum(ai) ^ 2 / (2 * C).</p>
<p>The question is how to rewrite the term `sum(di * si * si). The minimum contribution is when the task has size si and demand ai / si. (note that si is the minimum size of the task, and di its minimum demand). We can replace the small rectangle area term by ai * si. </p><div class="fragment"><div class="line">sum (ai * ei) - sum (ai) * current_start_min &gt;=</div>
<div class="line">    sum(si * ai) / 2 + (sum (ai) ^ 2) / (2 * C)</div>
</div><!-- fragment --><p> The separation procedure is implemented using two loops:</p><ul>
<li>first, we loop on potential start times in increasing order.</li>
<li>second loop, we add tasks that must contribute after this start time ordered by increasing end time in the LP relaxation. </li>
</ul>
<p>Sort by start min to bucketize by start_min.</p>
<p>First loop: we loop on potential start times.</p>
<p>Skip to the next start_min value.</p>
<p>We look at events that start before sequence_start_min, but are forced to cross this time point. In that case, we replace this event by a truncated event starting at sequence_start_min. To do this, we reduce the size_min, align the start_min with the sequence_start_min, and scale the energy down accordingly.</p>
<p>Best cut so far for this loop.</p>
<p>Used in the first term of the rhs of the equation.</p>
<p>Used in the second term of the rhs of the equation.</p>
<p>For normalization.</p>
<p>We will add tasks one by one, sorted by end time, and evaluate the potential cut at each step.</p>
<p>Second loop: we add tasks one by one.</p>
<p>Make sure we do not overflow.</p>
<p>In the no_overlap case, we have: area = event.x_size_min ^ 2 In the simple cumulative case, we split split the task (demand_min, size_min) into demand_min tasks in the no_overlap case. area = event.y_size_min * event.x_size_min * event.x_size_min In the cumulative case, we can have energy_min &gt; side_min * demand_min. In that case, we use energy_min * size_min.</p>
<p>Maintain the reachable capacity with a bounded complexity subset sum.</p>
<p>This is competing with the brute force approach. Skip cases covered by the other code.</p>
<p>Do we have a violated cut ?</p>
<p>shift contribution by current_start_min.</p>
<p>The efficacy of the cut is the normalized violation of the above equation. We will normalize by the sqrt of the sum of squared energies.</p>
<p>For a given start time, we only keep the best cut. The reason is that is the cut is strongly violated, we can get a sequence of violated cuts as we add more tasks. These new cuts will be less violated, but will not bring anything useful to the LP relaxation. At the same time, this sequence of cuts can push out other cuts from a disjoint set of tasks.</p>
<p>We have inserted all tasks. Have we found a violated cut ? If so, add the most violated one to the top_n cut container.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l01365">1365</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a3cfa6389f471e5868e779c07148e4ee4" name="a3cfa6389f471e5868e779c07148e4ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfa6389f471e5868e779c07148e4ee4">&#9670;&#160;</a></span>GenerateCumulativeEnergeticCuts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GenerateCumulativeEnergeticCuts </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>cut_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lp_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1EnergyEvent.html">EnergyEvent</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>time_limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Currently, we look at all the possible time windows, and will push all cuts in the <a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">TopNCuts</a> object. From our observations, this generator creates only a few cuts for a given run.</p>
<p>The complexity of this loop is n^3. if we follow the latest research, we could implement this in n log^2(n). Still, this is not visible in the profile as we only this method at the root node,</p>
<p>Compute relevant time points. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002407">Todo</a></b></dt><dd>(user): We could reduce this set. </dd></dl>
<p>Checks the time limit if the problem is too big.</p>
<p>After max_end_min, all tasks can fit before window_start.</p>
<p>Compute the max energy available for the tasks.</p>
<p>Add all contributions.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00483">483</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a79c07c2911bf5d9a1225cd3789ff0499" name="a79c07c2911bf5d9a1225cd3789ff0499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c07c2911bf5d9a1225cd3789ff0499">&#9670;&#160;</a></span>GenerateCumulativeEnergeticCutsWithMakespanAndFixedCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GenerateCumulativeEnergeticCutsWithMakespanAndFixedCapacity </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>cut_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lp_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1EnergyEvent.html">EnergyEvent</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>makespan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>time_limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This cumulative energetic cut generator will split the cumulative span in 2 regions.</p>
<p>In the region before the min of the makespan, we will compute a more precise reachable profile and have a better estimation of the energy available between two time point. the improvement can come from two sources:</p><ul>
<li>subset sum indicates that the max capacity cannot be reached.</li>
<li>sum of demands &lt; max capacity.</li>
</ul>
<p>In the region after the min of the makespan, we will use fixed_capacity * (makespan - makespan_min) as the available energy. </p>
<p>Checks the precondition of the code.</p>
<p>Currently, we look at all the possible time windows, and will push all cuts in the <a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">TopNCuts</a> object. From our observations, this generator creates only a few cuts for a given run.</p>
<p>The complexity of this loop is n^3. if we follow the latest research, we could implement this in n log^2(n). Still, this is not visible in the profile as we only this method at the root node,</p>
<p>Compute relevant time points. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002404">Todo</a></b></dt><dd>(user): We could reduce this set. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002405">Todo</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002406">Todo</a></b></dt><dd>(user): we can compute the max usage between makespan_min and makespan_max. </dd></dl>
<p>In practice, it stops the DP as the upper bound is reached.</p>
<p>Checks the time limit if the problem is too big.</p>
<p>After max_end_min, all tasks can fit before window_start.</p>
<p>Update states for the name of the generated cut.</p>
<p>We prefer using the makespan as the cut will tighten itself when the objective value is improved.</p>
<p>We reuse the min cut violation to allow some slack in the comparison between the two computed energy values.</p>
<p>Add contributions from all events.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00276">276</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="a24e2846c953a0da80fa787daddb78be7" name="a24e2846c953a0da80fa787daddb78be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e2846c953a0da80fa787daddb78be7">&#9670;&#160;</a></span>GenerateCutsBetweenPairOfNonOverlappingTasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GenerateCutsBetweenPairOfNonOverlappingTasks </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>cut_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lp_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CachedIntervalData.html">CachedIntervalData</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>capacity_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Balas disjunctive cuts on 2 tasks a and b: start_1 * (duration_1 + start_min_1 - start_min_2) + start_2 * (duration_2 + start_min_2 - start_min_1) &gt;= duration_1 * duration_2 + start_min_1 * duration_2 + start_min_2 * duration_1 From: David L. Applegate, William J. Cook: A Computational Study of the Job-Shop Scheduling Problem. 149-156 INFORMS Journal on Computing, Volume 3, Number 1, Winter 1991</p>
<p>Checks hypothesis from the cut.</p>
<p>Encode only the interesting pairs.</p>
<p>interval_1.end &lt;= interval_2.start</p>
<p>interval_2.end &lt;= interval_1.start</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l00857">857</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="af2a840612629fd37d42870c23e183609" name="af2a840612629fd37d42870c23e183609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a840612629fd37d42870c23e183609">&#9670;&#160;</a></span>GenerateGraphForSymmetryDetection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a> * operations_research::sat::GenerateGraphForSymmetryDetection </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>initial_equivalence_classes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a graph whose automorphisms can be mapped back to the symmetries of the given LinearBooleanProblem.</p>
<p>Any permutation of the graph that respects the initial_equivalence_classes output can be mapped to a symmetry of the given problem simply by taking its restriction on the first 2 * num_variables nodes and interpreting its index as a literal index. In a sense, a node with a low enough index <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a> is in one-to-one correspondence with a literals <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a> (using the index representation of literal).</p>
<p>The format of the initial_equivalence_classes is the same as the one described in <a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#a42c71ed3bac0344dfe9964839806566b">GraphSymmetryFinder::FindSymmetries()</a>. The classes must be dense in [0, num_classes) and any symmetry will only map nodes with the same class between each other. </p>
<p>First, we convert the problem to its canonical representation.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001117">Todo</a></b></dt><dd>(user): reserve the memory for the graph? not sure it is worthwhile since it would require some linear scan of the problem though. </dd></dl>
<p>We will construct a graph with 3 different types of node that must be in different equivalent classes.</p>
<p>First, we need one node per literal with an edge between each literal and its negation.</p>
<p>We have two nodes for each variable. </p><dl class="section note"><dt>Note</dt><dd>the indices are in [0, 2 * num_variables) and in one to one correspondence with the index representation of a literal.</dd></dl>
<p>We use 0 for their initial equivalence class, but that may be modified with the objective coefficient (see below).</p>
<p>Literals with different objective coeffs shouldn't be in the same class.</p>
<p>We need to canonicalize the objective to regroup literals corresponding to the same variables. Note that we don't care about the offset or optimization direction here, we just care about literals with the same canonical coefficient.</p>
<p>Then, for each constraint, we will have one or more nodes.</p>
<p>First we have a node for the constraint with an equivalence class depending on the rhs.</p>
<dl class="section note"><dt>Note</dt><dd>Since we add nodes one by one, initial_equivalence_classes-&gt;size() gives the number of nodes at any point, which we use as next node index.</dd></dl>
<p>This node will also be connected to all literals of the constraint with a coefficient of 1. Literals with new coefficients will be grouped under a new node connected to the constraint_node_index.</p>
<dl class="section note"><dt>Note</dt><dd>this works because a canonical constraint is sorted by increasing coefficient value (all positive).</dd></dl>
<p>Connect this node to the constraint node. Note that we don't technically need the arcs in both directions, but that may help a bit the algorithm to find symmetries.</p>
<p>Connect this node to the associated term.literal node. Note that we don't technically need the arcs in both directions, but that may help a bit the algorithm to find symmetries.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00545">545</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="ae8d88eb1ae1d8e5ab4507b8f809f2672" name="ae8d88eb1ae1d8e5ab4507b8f809f2672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d88eb1ae1d8e5ab4507b8f809f2672">&#9670;&#160;</a></span>GenerateInterestingSubsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GenerateInterestingSubsets </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; int, int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stop_at_num_components</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>subset_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; absl::Span&lt; const int &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>subsets</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a graph with nodes in [0, num_nodes) and a set of arcs (the order is important), this will:</p><ul>
<li>Start with each nodes in separate "subsets".</li>
<li>Consider the arc in order, and each time one connects two separate subsets, merge the two subsets into a new one.</li>
<li>Stops when there is only 2 subset left.</li>
<li>Output all subsets generated this way (at most 2 * num_nodes). The subsets spans will point in the subset_data vector (which will be of size exactly num_nodes).</li>
</ul>
<p>This is an heuristic to generate interesting cuts for TSP or other graph based constraints. We roughly follow the algorithm described in section 6 of "The Traveling Salesman Problem, A computational Study", David L. Applegate, Robert E. Bixby, Vasek Chvatal, William J. Cook.</p>
<dl class="section note"><dt>Note</dt><dd>this is mainly a "symmetric" case algo, but it does still work for the asymmetric case. </dd></dl>
<p>We will do a union-find by adding one by one the arc of the lp solution in the order above. Every intermediate set during this construction will be a candidate for a cut.</p>
<p>In parallel to the union-find, to efficiently reconstruct these sets (at most num_nodes), we construct a "decomposition forest" of the different connected components. Note that we don't exploit any asymmetric nature of the graph here. This is exactly the algo 6.3 in the book above.</p>
<p>Update the decomposition forest, note that the number of nodes is growing.</p>
<p>It is important that the union-find representative is the same node.</p>
<p>For each node in the decomposition forest, try to add a cut for the set formed by the nodes and its children. To do that efficiently, we first order the nodes so that for each node in a tree, the set of children forms a consecutive span in the subset_data vector. This vector just lists the nodes in the "pre-order" graph traversal order. The Spans will point inside the subset_data vector, it is why we initialize it once and for all.</p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01019">1019</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="ac47a8fc574385d4cfed0a85234e8d0fd" name="ac47a8fc574385d4cfed0a85234e8d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47a8fc574385d4cfed0a85234e8d0fd">&#9670;&#160;</a></span>GenerateItemsRectanglesWithNoPairwiseConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt; operations_research::sat::GenerateItemsRectanglesWithNoPairwiseConflict </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>slack_factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html#l00181">181</a> of file <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html">2d_orthogonal_packing_testing.cc</a>.</p>

</div>
</div>
<a id="ab98d2da0f736d2f7782c371adc0ff004" name="ab98d2da0f736d2f7782c371adc0ff004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98d2da0f736d2f7782c371adc0ff004">&#9670;&#160;</a></span>GenerateItemsRectanglesWithNoPairwisePropagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ItemWithVariableSize.html">ItemWithVariableSize</a> &gt; operations_research::sat::GenerateItemsRectanglesWithNoPairwisePropagation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>slack_factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Now run the propagator until there is no more pairwise conditions.</p>
<p>Remove the slack we added</p>

<p class="definition">Definition at line <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html#l00204">204</a> of file <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html">2d_orthogonal_packing_testing.cc</a>.</p>

</div>
</div>
<a id="a1ea8930e8c4adb6e5ffbf8a747049423" name="a1ea8930e8c4adb6e5ffbf8a747049423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea8930e8c4adb6e5ffbf8a747049423">&#9670;&#160;</a></span>GenerateNonConflictingRectangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; operations_research::sat::GenerateNonConflictingRectangles </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html#l00033">33</a> of file <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html">2d_orthogonal_packing_testing.cc</a>.</p>

</div>
</div>
<a id="a40d194228f8d909459b83d199ba60493" name="a40d194228f8d909459b83d199ba60493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d194228f8d909459b83d199ba60493">&#9670;&#160;</a></span>GenerateNonConflictingRectanglesWithPacking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; operations_research::sat::GenerateNonConflictingRectanglesWithPacking </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; IntegerValue, IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>bb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>average_num_boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alternative way of generating random rectangles. This one generate random rectangles and try to pack them using the left-bottom-first order. </p>

<p class="definition">Definition at line <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html#l00083">83</a> of file <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html">2d_orthogonal_packing_testing.cc</a>.</p>

</div>
</div>
<a id="a645a56c08ee13df54ea959184ffea321" name="a645a56c08ee13df54ea959184ffea321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645a56c08ee13df54ea959184ffea321">&#9670;&#160;</a></span>GenerateNoOverlap2dEnergyCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GenerateNoOverlap2dEnergyCut </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>energies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>cut_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>x_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>y_helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">SchedulingDemandHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>y_demands_helper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We can always skip events.</p>
<p>Compute y_spread.</p>
<p>The sum of all energies can be used to stop iterating early.</p>
<p>For each start time, we will keep the most violated cut generated while scanning the residual intervals.</p>
<p>Accumulate intervals, areas, energies and check for potential cuts.</p>
<p>We sort all tasks (x_start_min(task) &gt;= x_start_min(start_index) by increasing end max.</p>
<p>Let's process residual tasks and evaluate the violation of the cut at each step. We follow the same structure as the cut creation code below.</p>
<p>Dominance rule. If the next interval also fits in [window_min, window_max]*[y_min, y_max], the cut will be stronger with the next interval/rectangle.</p>
<p>Checks the current area vs the sum of all energies. The area is capacity_profile.GetBoundingArea(). We can compare it to the bounding box area: (window_max - window_min) * (y_max - y_min).</p>
<p>Compute the violation of the potential cut.</p>
<p>A maximal violated cut has been found. Build it and add it to the pool.</p>

<p class="definition">Definition at line <a class="el" href="diffn__cuts_8cc_source.html#l00140">140</a> of file <a class="el" href="diffn__cuts_8cc_source.html">diffn_cuts.cc</a>.</p>

</div>
</div>
<a id="a4f6fa507fbbee0406152f493e0dfb95b" name="a4f6fa507fbbee0406152f493e0dfb95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6fa507fbbee0406152f493e0dfb95b">&#9670;&#160;</a></span>GenerateSchedulingNeighborhoodFromIntervalPrecedences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html">Neighborhood</a> operations_research::sat::GenerateSchedulingNeighborhoodFromIntervalPrecedences </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; int, int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>precedences</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpSolverResponse &amp;</td>          <td class="paramname"><span class="paramname"><em>initial_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html">NeighborhoodGeneratorHelper</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper method for the scheduling neighborhood generators. Returns a full neighborhood enriched with the set or precedences passed to the generate method. </p>
<p>Collect seen intervals.</p>
<p>Fix the presence/absence of unseen intervals.</p>
<p>If the interval is not enforced, we just relax it. If it belongs to an exactly one constraint, and the enforced interval is not relaxed, then propagation will force this interval to stay not enforced. Otherwise, LNS will be able to change which interval will be enforced among all alternatives.</p>
<p>Fix the value.</p>
<p><a class="el" href="classoperations__research_1_1Set.html">Set</a> the current solution as a hint.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__lns_8cc_source.html#l02071">2071</a> of file <a class="el" href="cp__model__lns_8cc_source.html">cp_model_lns.cc</a>.</p>

</div>
</div>
<a id="a6078c1c54d29bceb642ec436017a3093" name="a6078c1c54d29bceb642ec436017a3093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6078c1c54d29bceb642ec436017a3093">&#9670;&#160;</a></span>GenerateSchedulingNeighborhoodFromRelaxedIntervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html">Neighborhood</a> operations_research::sat::GenerateSchedulingNeighborhoodFromRelaxedIntervals </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>intervals_to_relax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>variables_to_fix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpSolverResponse &amp;</td>          <td class="paramname"><span class="paramname"><em>initial_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html">NeighborhoodGeneratorHelper</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper method for the scheduling neighborhood generators. Returns a neighborhood defined from the given set of intervals to relax. For each scheduling constraint, it adds strict relation order between the non-relaxed intervals. </p>
<p>We will extend the set with some interval that we cannot fix.</p>
<p>Fix the presence/absence of non-relaxed intervals.</p>
<p>If the interval is not enforced, we just relax it. If it belongs to an exactly one constraint, and the enforced interval is not relaxed, then propagation will force this interval to stay not enforced. Otherwise, LNS will be able to change which interval will be enforced among all alternatives.</p>
<p>Fix the value.</p>
<p>We differ from the ICAPS05 paper as we do not consider ignored intervals when generating the precedence graph, instead of building the full graph, then removing intervals, and reconstructing the precedence graph heuristically after that.</p>
<p>fix the extra variables passed as parameters.</p>
<p><a class="el" href="classoperations__research_1_1Set.html">Set</a> the current solution as a hint.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__lns_8cc_source.html#l02135">2135</a> of file <a class="el" href="cp__model__lns_8cc_source.html">cp_model_lns.cc</a>.</p>

</div>
</div>
<a id="a53c4d8406e1afd37e5a99ed333207f32" name="a53c4d8406e1afd37e5a99ed333207f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c4d8406e1afd37e5a99ed333207f32">&#9670;&#160;</a></span>GenerateShortCompletionTimeCutsWithExactBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GenerateShortCompletionTimeCutsWithExactBound </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>cut_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CtEvent.html">CtEvent</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>capacity_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002409">Todo</a></b></dt><dd>(user): Improve performance<ul>
<li>detect disjoint tasks (no need to crossover to the second part)</li>
<li>better caching of explored states </li>
</ul>
</dd></dl>
<p>Sort by start min to bucketize by start_min.</p>
<p>Skip to the next start_min value.</p>
<p>We look at events that start before sequence_start_min, but are forced to cross this time point. In that case, we replace this event by a truncated event starting at sequence_start_min. To do this, we reduce the size_min, and align the start_min with the sequence_start_min.</p>
<p>Both cases with 1 or 2 tasks are trivial and independent of the order. Also, if capacity is not exceeded, pushing all ends left is a valid LP assignment.</p>
<p>We re-index the elements, so we will start enumerating the permutation from there. Note that if the previous i caused an abort because of the threshold, we might abort right away again!</p>
<p>Unweighted cuts.</p>
<p>Weighted cuts.</p>

<p class="definition">Definition at line <a class="el" href="scheduling__cuts_8cc_source.html#l01150">1150</a> of file <a class="el" href="scheduling__cuts_8cc_source.html">scheduling_cuts.cc</a>.</p>

</div>
</div>
<a id="acc41fb817d6b7c21672487bb6d451170" name="acc41fb817d6b7c21672487bb6d451170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc41fb817d6b7c21672487bb6d451170">&#9670;&#160;</a></span>GetCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::GetCoefficient </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the coefficient of the variable in the expression. Works in linear time. </p><dl class="section note"><dt>Note</dt><dd>GetCoefficient(NegationOf(var, expr)) == -GetCoefficient(var, expr). </dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00456">456</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="ad4cb284d48d84c21b02978fca95825c0" name="ad4cb284d48d84c21b02978fca95825c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cb284d48d84c21b02978fca95825c0">&#9670;&#160;</a></span>GetCoefficientOfPositiveVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::GetCoefficientOfPositiveVar </td>
          <td>(</td>
          <td class="paramtype">const IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00468">468</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a1ab085f4bfc568341a61b1a178fb718d" name="a1ab085f4bfc568341a61b1a178fb718d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab085f4bfc568341a61b1a178fb718d">&#9670;&#160;</a></span>GetFactorT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::GetFactorT </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>rhs_remainder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>max_magnitude</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the larger t &lt;= max_t such that t * rhs_remainder &gt;= divisor / 2.</p>
<p>This is just a separate function as it is slightly faster to compute the result only once.</p>
<p>Visible for testing. Returns a function f on integers such that:</p><ul>
<li>f is non-decreasing.</li>
<li>f is super-additive: f(a) + f(b) &lt;= f(a + b)</li>
<li>1 &lt;= f(divisor) &lt;= max_scaling</li>
<li>For all x, f(x * divisor) = x * f(divisor)</li>
<li>For all x, f(x * divisor + remainder) = x * f(divisor)</li>
</ul>
<p>Preconditions:</p><ul>
<li>0 &lt;= remainder &lt; divisor.</li>
<li>1 &lt;= max_scaling.</li>
</ul>
<p>This is used in IntegerRoundingCut() and is responsible for "strengthening" the cut. Just taking f(x) = x / divisor result in the non-strengthened cut and using any function that stricly dominate this one is better.</p>
<p>Algorithm:</p><ul>
<li>We first scale by a factor t so that rhs_remainder &gt;= divisor / 2.</li>
<li>Then, if max_scaling == 2, we use the function described in "Strenghtening Chvatal-Gomory cuts and Gomory fractional cuts", Adam N. Letchfrod, Andrea Lodi.</li>
<li>Otherwise, we use a generalization of this which is a discretized version of the classical MIR rounding function that only take the value of the form "an_integer / max_scaling". As max_scaling goes to infinity, this converge to the real-valued MIR function.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>for each value of max_scaling we will get a different function. And that there is no dominance relation between any of these functions. So it could be nice to try to generate a cut using different values of max_scaling. </dd></dl>
<p>Make sure that when we multiply the rhs or the coefficient by a factor t, we do not have an integer overflow. Note that the rhs should be counted in max_magnitude since we will apply f() on it.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l00469">469</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a8ab3041ce22f8dfd13a0bab64f7fd6bb" name="a8ab3041ce22f8dfd13a0bab64f7fd6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab3041ce22f8dfd13a0bab64f7fd6bb">&#9670;&#160;</a></span>GetFirstSolutionBaseParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; SatParameters &gt; operations_research::sat::GetFirstSolutionBaseParams </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>base_params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of base parameters to specify solvers specialized to find a initial solution. This is meant to be used with <a class="el" href="#ab3a1dd9bf60ce8490922e3f1148524e8">RepeatParameters()</a> and FilterParameters(). </p>
<p>Add one feasibility jump.</p>
<p>Random search.</p>
<p>Add a second feasibility jump.</p>
<p>Random quick restart.</p>
<p>Add a linear feasibility jump. This one seems to perform worse, so we add only 1 for 2 normal LS, and we add this late.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00996">996</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a2d3beb2acf8977c52500de3ebe170d24" name="a2d3beb2acf8977c52500de3ebe170d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3beb2acf8977c52500de3ebe170d24">&#9670;&#160;</a></span>GetFullWorkerParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; SatParameters &gt; operations_research::sat::GetFullWorkerParameters </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>base_params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>cp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_already_present</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SubsolverNameFilter.html">SubsolverNameFilter</a> *</td>          <td class="paramname"><span class="paramname"><em>filter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>in flatzinc setting, we know we always have a fixed search defined.</dd></dl>
<p>Things to try:</p><ul>
<li>Specialize for purely boolean problems</li>
<li>Disable linearization_level options for non linear problems</li>
<li>Fast restart in randomized search</li>
<li>Different propatation levels for scheduling constraints </li>
</ul>
<p>Defines a set of named strategies so it is easier to read in one place the one that are used. See below.</p>
<p>We only use a "fixed search" worker if some strategy is specified or if we have a scheduling model.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001517">Todo</a></b></dt><dd>(user): For scheduling, this is important to find good first solution but afterwards it is not really great and should probably be replaced by a LNS worker. </dd></dl>
<p>Our current set of strategies</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001518">Todo</a></b></dt><dd>(user): Avoid launching two strategies if they are the same, like if there is no lp, or everything is already linearized at level 1. </dd></dl>
<p>Starts by adding user specified ones.</p>
<p>We use the default if empty.</p>
<dl class="section note"><dt>Note</dt><dd>the order is important as the list can be truncated.</dd></dl>
<p>If there is no symmetry, max_lp_sym and max_lp are the same, but we prefer the less confusing name.</p>
<p>Hack for flatzinc. At the time of parameter setting, the objective is not expanded. So we do not know if core is applicable or not.</p>
<p>Remove the names that should be ignored.</p>
<p>Creates the diverse set of parameters with names and seed.</p>
<p>Do some filtering.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001519">Todo</a></b></dt><dd>(user): Enable probing_search in deterministic mode. Currently it timeouts on small problems as the deterministic time limit never hits the sharding limit. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001520">Todo</a></b></dt><dd>(user): Enable shaving search in interleave mode. Currently it do not respect ^C, and has no per chunk time limit. </dd></dl>
<p>In the corner case of empty variable, lets not schedule the probing as it currently just loop forever instead of returning right away.</p>
<p>Disable core search if there is only 1 term in the objective.</p>
<p>Disable subsolvers that do not implement the deterministic mode.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001521">Todo</a></b></dt><dd>(user): Enable lb_tree_search in deterministic mode. </dd></dl>
<p>Remove subsolvers that require an objective.</p>
<p>Add this strategy.</p>
<p>In interleaved mode, we run all of them.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001522">Todo</a></b></dt><dd>(user): Actually make sure the gap num_workers &lt;-&gt; num_heuristics is contained. </dd></dl>
<p>Apply the logic for how many we keep.</p>
<p>Derive some automatic number to leave room for LS/LNS and other strategies not taken into account here.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00817">817</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a53df1021ad3dff678c212d37692b8677" name="a53df1021ad3dff678c212d37692b8677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53df1021ad3dff678c212d37692b8677">&#9670;&#160;</a></span>GetInnerVarValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::GetInnerVarValue </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the inner variable of an affine expression from the value of the expression. It will DCHECK that the result is valid. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00228">228</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a632e976a0e61c8dc649c0fcb4d3cc324" name="a632e976a0e61c8dc649c0fcb4d3cc324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632e976a0e61c8dc649c0fcb4d3cc324">&#9670;&#160;</a></span>GetIntervalArticulationPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::GetIntervalArticulationPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html">IndexedInterval</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>intervals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="#ada6c4aa7b48dc203f11f4be4581dbdd6">GetOverlappingIntervalComponents()</a>, but returns the indices of all intervals whose removal would create one more connected component in the interval graph. Those are sorted by start. See: <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#articulation_point">https://en.wikipedia.org/wiki/Glossary_of_graph_theory#articulation_point</a>. </p>
<p>New connected component.</p>
<p>Still the same connected component. Was the previous "max" an articulation point ?</p>
<p>We might be re-inserting the same articulation point: guard against it.</p>
<p>Update the max end.</p>
<p>Convert articulation point indices to <a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html#ac7791848687cf5068ec00b7bac302dc6">IndexedInterval.index</a>.</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00534">534</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="ae2f0522b87e92a3a69cd92fe98af4be7" name="ae2f0522b87e92a3a69cd92fe98af4be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f0522b87e92a3a69cd92fe98af4be7">&#9670;&#160;</a></span>GetNamedParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::flat_hash_map&lt; std::string, SatParameters &gt; operations_research::sat::GetNamedParameters </td>
          <td>(</td>
          <td class="paramtype">SatParameters</td>          <td class="paramname"><span class="paramname"><em>base_params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all the named set of parameters known to the solver. This include our default strategies like "max_lp", "core", etc... It is visible here so that this can be reused by parameter validation.</p>
<p>Usually, named strategies just override a few field from the base_params. </p>
<p>By default we disable the logging when we generate a set of parameter. It is possible to force it by setting it in the corresponding named parameter via the subsolver_params field.</p>
<p>The "default" name can be used for the base_params unchanged.</p>
<p>Lp variations only.</p>
<p>Core. Note that we disable the lp here because it is faster on the minizinc benchmark.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001514">Todo</a></b></dt><dd>(user): Do more experiments, the LP with core could be useful, but we probably need to incorporate the newly created integer variables from the core algorithm into the LP. </dd></dl>
<p>It can be interesting to try core and lp.</p>
<p>We do not want to change the objective_var lb from outside as it gives better result to only use locally derived reason in that algo.</p>
<p>We want to spend more time on the LP here.</p>
<p>We want to spend more time on the LP here.</p>
<p><a class="el" href="classoperations__research_1_1Search.html" title="---------------— Search class --------------—">Search</a> variation.</p>
<p>Quick restart.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001515">Todo</a></b></dt><dd>(user): Experiment with search_random_variable_pool_size. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>no dual scheduling heuristics.</dd></dl>
<p>Less encoding.</p>
<p>Base parameters for shared tree worker.</p>
<p>These settings don't make sense with shared tree search, turn them off as they can break things.</p>
<p>Given that each workers work on a different part of the subtree, it might not be a good idea to try to work on a global shared solution.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001516">Todo</a></b></dt><dd>(user): Experiments more here, in particular we could follow it if it falls into the current subtree. </dd></dl>
<p>Base parameters for LNS worker.</p>
<p>We disable costly presolve/inprocessing.</p>
<dl class="section note"><dt>Note</dt><dd>we only do this for the derived parameters. The strategy "lns" will be handled along with the other ones.</dd></dl>
<p>For routing, the LP relaxation seems pretty important, so we prefer an high linearization level to solve LNS subproblems.</p>
<p>Add user defined ones. </p><dl class="section note"><dt>Note</dt><dd>this might be merged to our default ones.</dd></dl>
<p>Merge the named parameters with the base parameters to create the new parameters.</p>
<p>Fix names (we don't set them above).</p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00505">505</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a0c8a370fc5dabda472b2004e14fd6a0a" name="a0c8a370fc5dabda472b2004e14fd6a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8a370fc5dabda472b2004e14fd6a0a">&#9670;&#160;</a></span>GetOrbitopeOrbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::GetOrbitopeOrbits </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::vector&lt; int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>orbitope</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the orbits under the given orbitope action. Same results format as in <a class="el" href="#aa8cc7ff53b39b6a28e821bc428dcb331">GetOrbits()</a>. Note that here, the orbit index is simply the row index of an element in the orbitope matrix. </p>

<p class="definition">Definition at line <a class="el" href="symmetry__util_8cc_source.html#l00189">189</a> of file <a class="el" href="symmetry__util_8cc_source.html">symmetry_util.cc</a>.</p>

</div>
</div>
<a id="aa8cc7ff53b39b6a28e821bc428dcb331" name="aa8cc7ff53b39b6a28e821bc428dcb331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cc7ff53b39b6a28e821bc428dcb331">&#9670;&#160;</a></span>GetOrbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::GetOrbits </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>generators</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of size n such that</p><ul>
<li>orbits[i] == -1 iff i is never touched by the generators (singleton orbit).</li>
<li><p class="startli">orbits[i] = orbit_index, where orbits are numbered from 0 to num_orbits - 1</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002461">Todo</a></b></dt><dd>(user): We could reuse the internal memory if needed. </dd></dl>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>there is currently no random access api like cycle[j].</dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetry__util_8cc_source.html#l00154">154</a> of file <a class="el" href="symmetry__util_8cc_source.html">symmetry_util.cc</a>.</p>

</div>
</div>
<a id="ada6c4aa7b48dc203f11f4be4581dbdd6" name="ada6c4aa7b48dc203f11f4be4581dbdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6c4aa7b48dc203f11f4be4581dbdd6">&#9670;&#160;</a></span>GetOverlappingIntervalComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GetOverlappingIntervalComponents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IndexedInterval.html">IndexedInterval</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>intervals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>components</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given n intervals, returns the set of connected components (using the overlap relation between 2 intervals). Components are sorted by their start, and inside a component, the intervals are also sorted by start. <code>intervals</code> is only sorted (by start), and not modified otherwise. </p>
<p>For correctness, ComparatorByStart is enough, but in unit tests we want to verify this function against another implementation, and fully defined sorting with tie-breaking makes that much easier. If that becomes a performance bottleneck:</p><ul>
<li>One may want to sort the list outside of this function, and simply have this function DCHECK that it's sorted by start.</li>
<li>One may use stable_sort() with ComparatorByStart().</li>
</ul>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00501">501</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="a37ebac5ff9b5521ef368606a16ca84ce" name="a37ebac5ff9b5521ef368606a16ca84ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ebac5ff9b5521ef368606a16ca84ce">&#9670;&#160;</a></span>GetOverlappingRectangleComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1CompactVectorVector.html">CompactVectorVector</a>&lt; int &gt; operations_research::sat::GetOverlappingRectangleComponents </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a graph when two nodes are connected iff their rectangles overlap. Then partition into connected components. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00111">111</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="acf09b937c4d7439804c0fc61afcb7008" name="acf09b937c4d7439804c0fc61afcb7008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf09b937c4d7439804c0fc61afcb7008">&#9670;&#160;</a></span>GetPositiveOnlyIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PositiveOnlyIndex operations_research::sat::GetPositiveOnlyIndex </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00169">169</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="aeafd68a229d8e8b0893f2f0720e08332" name="aeafd68a229d8e8b0893f2f0720e08332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafd68a229d8e8b0893f2f0720e08332">&#9670;&#160;</a></span>GetReferencesUsedByConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IndexReferences.html">IndexReferences</a> operations_research::sat::GetReferencesUsedByConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00081">81</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a5582ef17b5b0f85e9a1b382b6acfa1bc" name="a5582ef17b5b0f85e9a1b382b6acfa1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5582ef17b5b0f85e9a1b382b6acfa1bc">&#9670;&#160;</a></span>GetReferencesUsedByConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GetReferencesUsedByConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00087">87</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a2d6dfa125801eb330bfe3c8ece4751a4" name="a2d6dfa125801eb330bfe3c8ece4751a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6dfa125801eb330bfe3c8ece4751a4">&#9670;&#160;</a></span>GetRinsRensNeighborhood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1ReducedDomainNeighborhood.html">ReducedDomainNeighborhood</a> operations_research::sat::GetRinsRensNeighborhood </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *</td>          <td class="paramname"><span class="paramname"><em>response_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SharedLPSolutionRepository.html">SharedLPSolutionRepository</a> *</td>          <td class="paramname"><span class="paramname"><em>lp_solutions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedIncompleteSolutionManager.html">SharedIncompleteSolutionManager</a> *</td>          <td class="paramname"><span class="paramname"><em>incomplete_solutions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>difficulty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper method to create a RINS neighborhood by fixing variables with same values in relaxation solution and the current best solution in the response_manager. Prioritizes repositories in following order to get a neighborhood.</p><ol type="1">
<li>incomplete_solutions</li>
<li>lp_solutions</li>
</ol>
<p>If response_manager has no solution, this generates a RENS neighborhood by ignoring the solutions and using the relaxation values. The domain of the variables are reduced to integer values around relaxation values. If the relaxation value is integer, then we fix the domain of the variable to that value. </p>
<p>Using a partial LP relaxation computed by feasibility_pump, and a full lp relaxation periodically dumped by linearization=2 workers is equiprobable.</p>

<p class="definition">Definition at line <a class="el" href="rins_8cc_source.html#l00176">176</a> of file <a class="el" href="rins_8cc_source.html">rins.cc</a>.</p>

</div>
</div>
<a id="a1bd9e4dc35b02efb37cf01da2bac1743" name="a1bd9e4dc35b02efb37cf01da2bac1743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd9e4dc35b02efb37cf01da2bac1743">&#9670;&#160;</a></span>GetSchreierVectorAndOrbit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::GetSchreierVectorAndOrbit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>generators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>schrier_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>orbit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See Chapter 7 of Butler, Gregory, ed. Fundamental algorithms for permutation groups. Berlin, Heidelberg: Springer Berlin Heidelberg, 1991. </p>

<p class="definition">Definition at line <a class="el" href="symmetry__util_8cc_source.html#l00201">201</a> of file <a class="el" href="symmetry__util_8cc_source.html">symmetry_util.cc</a>.</p>

</div>
</div>
<a id="ad06c22b7b182ddb7070f175bb325162c" name="ad06c22b7b182ddb7070f175bb325162c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c22b7b182ddb7070f175bb325162c">&#9670;&#160;</a></span>GetSingleRefFromExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::GetSingleRefFromExpression </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the reference the expression can be reduced to. It will DCHECK that ExpressionContainsSingleRef(expr) is true. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00626">626</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a0c9697a77db1ba2b0a9055c7a71fe666" name="a0c9697a77db1ba2b0a9055c7a71fe666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9697a77db1ba2b0a9055c7a71fe666">&#9670;&#160;</a></span>GetSolutionValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int64_t &gt; operations_research::sat::GetSolutionValues </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For ignored or not fully instantiated variable, we just use the lower bound.</p>
<p>Just use the lower bound if the variable is not fully instantiated.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00286">286</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="afa1020b89b12f653b1ea0dd0d595557e" name="afa1020b89b12f653b1ea0dd0d595557e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1020b89b12f653b1ea0dd0d595557e">&#9670;&#160;</a></span>GetSuperAdditiveRoundingFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerValue(IntegerValue)&gt; operations_research::sat::GetSuperAdditiveRoundingFunction </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>rhs_remainder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>max_scaling</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjust after the multiplication by t.</p>
<p>Make sure we don't have an integer overflow below. Note that we assume that divisor and the maximum coeff magnitude are not too different (maybe a factor 1000 at most) so that the final result will never overflow.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001647">Todo</a></b></dt><dd>(user): Use everywhere a two step computation to avoid overflow? First divide by divisor, then multiply by t. For now, we limit t so that we never have an overflow instead. </dd></dl>
<p>Because of our max_t limitation, the rhs_remainder might stay small.</p>
<p>If it is "too small" we cannot use the code below because it will not be valid. So we just divide divisor into max_scaling bucket. The rhs_remainder will be in the bucket 0.</p>
<p>Note(user): This seems the same as just increasing t, modulo integer overflows. Maybe we should just always do the computation like this so that we can use larger t even if coeff is close to kint64max.</p>
<p>We divide (size = divisor - rhs_remainder) into (max_scaling - 1) buckets and increase the function by 1 / max_scaling for each of them.</p>
<dl class="section note"><dt>Note</dt><dd>for different values of max_scaling, we get a family of functions that do not dominate each others. So potentially, a max scaling as low as 2 could lead to the better cut (this is exactly the Letchford &amp; Lodi function).</dd></dl>
<p>Another interesting fact, is that if we want to compute the maximum alpha for a constraint with 2 terms like: divisor * Y + (ratio * divisor + remainder) * X &lt;= rhs_ratio * divisor + rhs_remainder so that we have the cut: Y + (ratio + alpha) * X &lt;= rhs_ratio This is the same as computing the maximum alpha such that for all integer X &gt; 0 we have CeilRatio(alpha * divisor * X, divisor) &lt;= CeilRatio(remainder * X - rhs_remainder, divisor). We can prove that this alpha is of the form (n - 1) / n, and it will be reached by such function for a max_scaling of n.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001648">Todo</a></b></dt><dd>(user): This function is not always maximal when size % (max_scaling - 1) == 0. Improve? </dd></dl>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l00483">483</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a7876cef7b031a084f24b5c5898c9710c" name="a7876cef7b031a084f24b5c5898c9710c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7876cef7b031a084f24b5c5898c9710c">&#9670;&#160;</a></span>GetSuperAdditiveStrengtheningFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerValue(IntegerValue)&gt; operations_research::sat::GetSuperAdditiveStrengtheningFunction </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>positive_rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>min_magnitude</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we have an equation sum ci.Xi &gt;= rhs with everything positive, and all ci are &gt;= min_magnitude then any ci &gt;= rhs can be set to rhs. Also if some ci are in [rhs - min, rhs) then they can be strenghtened to rhs - min.</p>
<p>If we apply this to the negated equation (sum -ci.Xi + sum cj.Xj &lt;= -rhs) with potentially positive terms, this reduce to apply a super-additive function:</p>
<p>Plot look like: x=-rhs x=0 | | y=0 : | ------------------------------&mdash; | &mdash; | / |&mdash; y=-rhs ----&mdash;</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001692">Todo</a></b></dt><dd>(user): Extend it for ci &gt;= max_magnitude, we can probaly "lift" such coefficient. </dd></dl>
<p>The transformation only work if 2 * second_threshold &gt;= positive_rhs.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001649">Todo</a></b></dt><dd>(user): Limit the number of value used with scaling like above. </dd></dl>
<p>This should actually never happen by the definition of min_magnitude. But with it, the function is supper-additive even if min_magnitude is not correct.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001650">Todo</a></b></dt><dd>(user): we might want to intoduce some step to reduce the final magnitude of the cut. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l00568">568</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="adadc8829018c149d88271978270bf822" name="adadc8829018c149d88271978270bf822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadc8829018c149d88271978270bf822">&#9670;&#160;</a></span>GetSuperAdditiveStrengtheningMirFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerValue(IntegerValue)&gt; operations_research::sat::GetSuperAdditiveStrengtheningMirFunction </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>positive_rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>scaling</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to above but with scaling of the linear part to just have at most scaling values. </p>
<p>Simple case, no scaling required.</p>
<p>We need to scale.</p>
<p>We divide [-positive_rhs + 1, 0] into (scaling - 1) bucket.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l00603">603</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a46ee72b20ff7dd9d0285e8fb535b8229" name="a46ee72b20ff7dd9d0285e8fb535b8229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ee72b20ff7dd9d0285e8fb535b8229">&#9670;&#160;</a></span>GreaterOrEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::GreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a &gt;= b. </p>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00679">679</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="ab3ba1ab2a4a6cdc0ea4324d409ddbe7e" name="ab3ba1ab2a4a6cdc0ea4324d409ddbe7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ba1ab2a4a6cdc0ea4324d409ddbe7e">&#9670;&#160;</a></span>GreaterOrEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::GreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01567">1567</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aeaa27df9712553f45eb84d209a92ca8b" name="aeaa27df9712553f45eb84d209a92ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa27df9712553f45eb84d209a92ca8b">&#9670;&#160;</a></span>GreaterOrEqualToMiddleValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::GreaterOrEqualToMiddleValue </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *</td>          <td class="paramname"><span class="paramname"><em>integer_trail</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns decision corresponding to var &gt;= lb + max(1, (ub - lb) / 2). It also CHECKs that the variable is not fixed. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00078">78</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a0ecdc69e06c5414f4e20a755b94f70f7" name="a0ecdc69e06c5414f4e20a755b94f70f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecdc69e06c5414f4e20a755b94f70f7">&#9670;&#160;</a></span>GreaterThanAtLeastOneOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::GreaterThanAtLeastOneOf </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>target_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>selectors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcements</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__constraints_8h_source.html#l00135">135</a> of file <a class="el" href="cp__constraints_8h_source.html">cp_constraints.h</a>.</p>

</div>
</div>
<a id="af6433b3a01c71cd754d3d710f345b4c0" name="af6433b3a01c71cd754d3d710f345b4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6433b3a01c71cd754d3d710f345b4c0">&#9670;&#160;</a></span>GreedyFastDecreasingGcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::GreedyFastDecreasingGcd </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ordering of the indices of coefficients such that the GCD of its initial segments decreases fast. As the product of the 15 smallest prime numbers is the biggest fitting in an int64_t, it is guaranteed that the GCD becomes stationary after at most 15 steps. Returns an empty vector if the GCD is equal to the absolute value of one of the coefficients. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001711">Todo</a></b></dt><dd>(user): The following is a heuristic to make drop the GCD as fast as possible. It might be suboptimal in general (as we could miss two coprime coefficients for instance). </dd></dl>
<p>initial_count is very small (proven &lt;= 15, usually much smaller).</p>

<p class="definition">Definition at line <a class="el" href="diophantine_8cc_source.html#l00069">69</a> of file <a class="el" href="diophantine_8cc_source.html">diophantine.cc</a>.</p>

</div>
</div>
<a id="a42a3b266d8c6dfab1c14baa6c04e2333" name="a42a3b266d8c6dfab1c14baa6c04e2333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a3b266d8c6dfab1c14baa6c04e2333">&#9670;&#160;</a></span>HasEnforcementLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::HasEnforcementLiteral </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Small utility functions to deal with half-reified constraints. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00049">49</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a5ca12ac764578209e7eaa692a9029635" name="a5ca12ac764578209e7eaa692a9029635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca12ac764578209e7eaa692a9029635">&#9670;&#160;</a></span>Implication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::Implication </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001814">Todo</a></b></dt><dd>(user): This is one of the rare case where it is better to use <a class="el" href="#a134ba4c37e543cb80c698555b6ae89f8" title="Fix v to a given value.">Equality()</a> rather than two Implications(). Maybe we should modify our internal implementation to use half-reified encoding? that is do not propagate the direction integer-bound =&gt; literal, but just literal =&gt; integer-bound? This is the same as using different underlying variable for an integer literal and its negation. </dd></dl>
<p>Always true! nothing to do.</p>
<p>Always false.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001815">Todo</a></b></dt><dd>(user): Double check what happen when we associate a trivially true or false literal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01609">1609</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a641e39cef45870bebda662477a8d6771" name="a641e39cef45870bebda662477a8d6771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e39cef45870bebda662477a8d6771">&#9670;&#160;</a></span>Implication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::Implication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a =&gt; b. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00955">955</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ad39ed3f215af8b2d35da4d2a52254c42" name="ad39ed3f215af8b2d35da4d2a52254c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39ed3f215af8b2d35da4d2a52254c42">&#9670;&#160;</a></span>ImpliesInInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ImpliesInInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>in_interval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>in_interval =&gt; v in [lb, ub]. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01637">1637</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a456dcb4946579eafb5e3ce4059b5a6be" name="a456dcb4946579eafb5e3ce4059b5a6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456dcb4946579eafb5e3ce4059b5a6be">&#9670;&#160;</a></span>ImportModelAndDomainsWithBasicPresolveIntoContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ImportModelAndDomainsWithBasicPresolveIntoContext </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>in_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(int)&gt;</td>          <td class="paramname"><span class="paramname"><em>active_constraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a4cc46bf1380ba6450d83513096326146">ImportModelWithBasicPresolveIntoContext()</a> except that variable domains are read from domains. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__copy_8cc_source.html#l00907">907</a> of file <a class="el" href="cp__model__copy_8cc_source.html">cp_model_copy.cc</a>.</p>

</div>
</div>
<a id="a4cc46bf1380ba6450d83513096326146" name="a4cc46bf1380ba6450d83513096326146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc46bf1380ba6450d83513096326146">&#9670;&#160;</a></span>ImportModelWithBasicPresolveIntoContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ImportModelWithBasicPresolveIntoContext </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>in_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy in_model to the model in the presolve context. It performs on the fly simplification, and returns false if the model is proved infeasible. If reads the parameters 'ignore_names' and keeps or deletes variables and constraints names accordingly.</p>
<p>This should only be called on the first copy of the user given model. </p><dl class="section note"><dt>Note</dt><dd>this reorder all constraints that use intervals last. We loose the user-defined order, but hopefully that should not matter too much. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__copy_8cc_source.html#l00895">895</a> of file <a class="el" href="cp__model__copy_8cc_source.html">cp_model_copy.cc</a>.</p>

</div>
</div>
<a id="ac5c32a6d4b37adef70ebfc92eabf05b4" name="ac5c32a6d4b37adef70ebfc92eabf05b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c32a6d4b37adef70ebfc92eabf05b4">&#9670;&#160;</a></span>InclusionDetector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::InclusionDetector </td>
          <td>(</td>
          <td class="paramtype">const Storage &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span></td><td>)</td>
          <td> -&gt;  InclusionDetector&lt; Storage &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>

</div>
</div>
<a id="ad715c4b2444c3b6fb162bc2382a2248e" name="ad715c4b2444c3b6fb162bc2382a2248e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad715c4b2444c3b6fb162bc2382a2248e">&#9670;&#160;</a></span>IncreaseNodeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IncreaseNodeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the size of the given node by one. To keep all the needed relations with its children, we also need to increase their size by one, and so on recursively. Also adds all the necessary clauses linking the newly added literals. </p>
<p>Only one side of the constraint is mandatory (the one propagating the ones to the top of the encoding tree), and it seems more efficient not to encode the other side.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001741">Todo</a></b></dt><dd>(user): Experiment more. </dd></dl>
<p>Integer leaf node.</p>
<dl class="section note"><dt>Note</dt><dd>since we were able to increase its size, n must have children. n-&gt;GreaterThan(target) is the new literal of n.</dd></dl>
<p>Add a literal to a if needed. That is, now that the node n can go up to it new current_ub, if we need to increase the current_ub of a.</p>
<p>Add a literal to b if needed.</p>
<p>Wire the new literal of n correctly with its two children.</p>
<p>if x &lt;= ia and y &lt;= ib then x + y &lt;= ia + ib.</p>
<p>if x &gt; ia and y &gt; ib - 1 then x + y &gt; ia + ib.</p>
<p>Case ia = a-&gt;lb() - 1; a-&gt;GreaterThan(ia) always true.</p>
<p>case ia == a-&gt;ub; a-&gt;GreaterThan(ia) always false.</p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00291">291</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a5631139e1ab47ec3f8f2273fa476d62e" name="a5631139e1ab47ec3f8f2273fa476d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5631139e1ab47ec3f8f2273fa476d62e">&#9670;&#160;</a></span>InitializeDebugSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::InitializeDebugSolution </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This both copy the "main" <a class="el" href="structoperations__research_1_1sat_1_1DebugSolution.html">DebugSolution</a> to a local_model and also cache the value of the integer variables in that solution. </p>
<p>Copy the proto values.</p>
<p>Fill the values by integer variable.</p>
<p>If the solution is fully boolean (there is no integer variable), and we have a decision problem (so no new boolean should be created), we load it in the sat solver for debugging too.</p>
<p>The objective variable is usually not part of the proto, but it is still nice to have it, so we recompute it here.</p>
<p>We also register a DEBUG callback to check our reasons.</p>
<p>First case, this Boolean is mapped.</p>
<p>Second case, it is associated to <a class="el" href="classoperations__research_1_1sat_1_1IntVar.html">IntVar</a> &gt;= value. We can use any of them, so if one is false, we use this one.</p>
<p>Note the sign is inversed, we cannot have all literal false and all integer literal true.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00142">142</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="ae242b79514feb483756fd8dedd385742" name="ae242b79514feb483756fd8dedd385742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae242b79514feb483756fd8dedd385742">&#9670;&#160;</a></span>InsertVariablesFromInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::InsertVariablesFromInterval </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Bitset64.html">Bitset64</a>&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert/Remove variables from an interval constraint into a bitset. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00104">104</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="af0255a3e8ee357c78aba5982ed7045d0" name="af0255a3e8ee357c78aba5982ed7045d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0255a3e8ee357c78aba5982ed7045d0">&#9670;&#160;</a></span>InstrumentSearchStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::InstrumentSearchStrategy </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>cp_model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>variable_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>instrumented_strategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For debugging fixed-search: display information about the named variables domain before taking each decision. Note that we copy the instrumented strategy so it doesn't have to outlive the returned functions like the other arguments. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l00448">448</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a429d1fd54b5becc39e4cfbc608d7d70a" name="a429d1fd54b5becc39e4cfbc608d7d70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429d1fd54b5becc39e4cfbc608d7d70a">&#9670;&#160;</a></span>IntegerTermDebugString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::IntegerTermDebugString </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00173">173</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a8b7beb472425b294af9b102a4a98f42c" name="a8b7beb472425b294af9b102a4a98f42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7beb472425b294af9b102a4a98f42c">&#9670;&#160;</a></span>IntegerTypeMinimumValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerType operations_research::sat::IntegerTypeMinimumValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimal value of an envelope, for instance the envelope of the empty set. </p>
<p>The Theta-Lambda tree can be used to implement several scheduling algorithms.</p>
<p>This template class is instantiated only for IntegerValue and int64_t.</p>
<p>The tree structure itself is a binary tree coded in a vector, where node 0 is unused, node 1 is the root, node 2 is the left child of the root, node 3 its right child, etc.</p>
<p>The API gives access to rightmost events that realize a given envelope.</p>
<p>See: _ (0) Petr Vilim's PhD thesis "Global Constraints in Scheduling". _ (1) Petr Vilim "Edge Finding Filtering Algorithm for Discrete Cumulative
  Resources in O(kn log n)" _ (2) Petr Vilim "Max energy filtering algorithm for discrete cumulative
  resources". _ (3) Wolf &amp; Schrader "O(n log n) Overload Checking for the Cumulative
  Constraint and Its Application". _ (4) Kameugne &amp; Fotso "A cumulative not-first/not-last filtering algorithm
  in O(n^2 log n)". _ (5) Ouellet &amp; Quimper "Time-table extended-edge-finding for the cumulative
  constraint".</p>
<p>Instead of providing one declination of the theta-tree per possible filtering algorithm, this generalization intends to provide a data structure that can fit several algorithms. This tree is based around the notion of events. It has events at its leaves that can be present or absent, and present events come with an initial_envelope, a minimal and a maximal energy. All nodes maintain values on the set of present events under them: _ sum_energy_min(node) = sum_{leaf \in leaves(node)} energy_min(leaf) _ envelope(node) = max_{leaf \in leaves(node)} initial_envelope(leaf) + sum_{leaf' \in leaves(node), leaf' &gt;= leaf} energy_min(leaf').</p>
<p>Thus, the envelope of a leaf representing an event, when present, is initial_envelope(event) + sum_energy_min(event).</p>
<p>We also maintain envelope_opt with is the maximum envelope a node could take if at most one of the events were at its maximum energy. _ energy_delta(leaf) = energy_max(leaf) - energy_min(leaf) _ max_energy_delta(node) = max_{leaf \in leaves(node)} energy_delta(leaf) _ envelope_opt(node) = max_{leaf \in leaves(node)} initial_envelope(leaf) + sum_{leaf' \in leaves(node), leaf' &gt;= leaf} energy_min(leaf') + max_{leaf' \in leaves(node), leaf' &gt;= leaf} energy_delta(leaf');</p>
<p>Most articles using theta-tree variants hack Vilim's original theta tree for the disjunctive resource constraint by manipulating envelope and energy: _ in (0), initial_envelope = start_min, energy = duration _ in (3), initial_envelope = C * start_min, energy = demand * duration _ in (5), there are several trees in parallel: initial_envelope = C * start_min or (C - h) * start_min energy = demand * duration, h * (Horizon - start_min), or h * (end_min). _ in (2), same as (3), but putting the max energy instead of min in lambda. _ in OscaR's TimeTableOverloadChecker, initial_envelope = C * start_min - energy of mandatory profile before start_min, energy = demand * duration</p>
<p>There is hope to unify the variants of these algorithms by abstracting the tasks away to reason only on events. </p>

<p class="definition">Definition at line <a class="el" href="theta__tree_8h_source.html#l00095">95</a> of file <a class="el" href="theta__tree_8h_source.html">theta_tree.h</a>.</p>

</div>
</div>
<a id="a9fb08d14503090b0fcd0cff9e37013c7" name="a9fb08d14503090b0fcd0cff9e37013c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb08d14503090b0fcd0cff9e37013c7">&#9670;&#160;</a></span>IntegerTypeMinimumValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTypeMinimumValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="theta__tree_8h_source.html#l00099">99</a> of file <a class="el" href="theta__tree_8h_source.html">theta_tree.h</a>.</p>

</div>
</div>
<a id="a4f8e9410f7631560e2efea8f401e5aa1" name="a4f8e9410f7631560e2efea8f401e5aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8e9410f7631560e2efea8f401e5aa1">&#9670;&#160;</a></span>IntegerValueSelectionHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::IntegerValueSelectionHeuristic </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>var_selection_heuristic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>all these heuristic do not depend on the variable being positive or negative.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001866">Todo</a></b></dt><dd>(user): Experiment more with value selection heuristics. </dd></dl>
<p>Changes the value of the given decision by 'var_selection_heuristic' according to various value selection heuristics. Looks at the code to know exactly what heuristic we use. </p>
<p>LP based value.</p>
<dl class="section note"><dt>Note</dt><dd>we only do this if a big enough percentage of the problem variables appear in the LP relaxation.</dd></dl>
<p>Solution based value.</p>
<p>Objective based value.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00369">369</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="abc92e600d7a70f5525d8c2998008a136" name="abc92e600d7a70f5525d8c2998008a136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc92e600d7a70f5525d8c2998008a136">&#9670;&#160;</a></span>IntervalIsVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntervalIsVariable </td>
          <td>(</td>
          <td class="paramtype">const IntervalVariable</td>          <td class="paramname"><span class="paramname"><em>interval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html">IntervalsRepository</a> *</td>          <td class="paramname"><span class="paramname"><em>intervals_repository</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ignore absent rectangles.</p>
<p>Checks non-present intervals.</p>
<p>Checks variable sized intervals.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01652">1652</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="a1e30e51173c7e43a8c0b4668d5e3f050" name="a1e30e51173c7e43a8c0b4668d5e3f050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e30e51173c7e43a8c0b4668d5e3f050">&#9670;&#160;</a></span>IntTypeAbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType operations_research::sat::IntTypeAbs </td>
          <td>(</td>
          <td class="paramtype">IntType</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00068">68</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="abe5488433478bfcf730825b9221e2d5e" name="abe5488433478bfcf730825b9221e2d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5488433478bfcf730825b9221e2d5e">&#9670;&#160;</a></span>IsAssignmentValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IsAssignmentValid </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that an assignment is valid for the given BooleanProblem. </p>
<p>Check that all constraints are satisfied.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00373">373</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a4d7b280638f4df989a78aa0774e48160" name="a4d7b280638f4df989a78aa0774e48160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7b280638f4df989a78aa0774e48160">&#9670;&#160;</a></span>IsEqualToMinOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::IsEqualToMinOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min_expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00756">756</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a4d3c6ea5e2b95e4d7e45d6146c61c2ce" name="a4d3c6ea5e2b95e4d7e45d6146c61c2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3c6ea5e2b95e4d7e45d6146c61c2ce">&#9670;&#160;</a></span>IsFixed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; bool(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::IsFixed </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01551">1551</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a4e355cfd816df871c404e097c4b02696" name="a4e355cfd816df871c404e097c4b02696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e355cfd816df871c404e097c4b02696">&#9670;&#160;</a></span>IsNegatableInt64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IsNegatableInt64 </td>
          <td>(</td>
          <td class="paramtype">absl::int128</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether a int128 can be casted to a int64_t that can be negated. </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8h_source.html#l00740">740</a> of file <a class="el" href="sat_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ad66328f1be79a54762cba9067ad806cc" name="ad66328f1be79a54762cba9067ad806cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66328f1be79a54762cba9067ad806cc">&#9670;&#160;</a></span>IsOptional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; bool(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::IsOptional </td>
          <td>(</td>
          <td class="paramtype">IntervalVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00250">250</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a1f9cdbedf84c94259e56684fd18eab1b" name="a1f9cdbedf84c94259e56684fd18eab1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9cdbedf84c94259e56684fd18eab1b">&#9670;&#160;</a></span>IsPresentLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::IsPresentLiteral </td>
          <td>(</td>
          <td class="paramtype">IntervalVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00256">256</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="afd482f2c4b9533b4d1f7379a578e9b18" name="afd482f2c4b9533b4d1f7379a578e9b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd482f2c4b9533b4d1f7379a578e9b18">&#9670;&#160;</a></span>kCoefficientMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Coefficient operations_research::sat::kCoefficientMax </td>
          <td>(</td>
          <td class="paramtype">std::numeric_limits&lt; Coefficient::ValueType &gt;</td>          <td class="paramname"><span class="paramname"><em>::max</em></span>()</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IMPORTANT: We can't use numeric_limits&lt;Coefficient&gt;::max() which will compile but just returns zero!! </p>

</div>
</div>
<a id="a969b5056550d96847f8c35f19fd17f50" name="a969b5056550d96847f8c35f19fd17f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969b5056550d96847f8c35f19fd17f50">&#9670;&#160;</a></span>kFalseLiteralIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LiteralIndex operations_research::sat::kFalseLiteralIndex </td>
          <td>(</td>
          <td class="paramtype">-</td>          <td class="paramname"><span class="paramname"><em>3</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1227e67513602591fb959e35c9de66e8" name="a1227e67513602591fb959e35c9de66e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1227e67513602591fb959e35c9de66e8">&#9670;&#160;</a></span>kMaxIntegerValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::kMaxIntegerValue </td>
          <td>(</td>
          <td class="paramtype">std::numeric_limits&lt; IntegerValue::ValueType &gt;::max() -</td>          <td class="paramname"><span class="paramname"><em>1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The max range of an integer variable is [kMinIntegerValue, kMaxIntegerValue].</p>
<p>It is symmetric so the set of possible ranges stays the same when we take the negation of a variable. Moreover, we need some IntegerValue that fall outside this range on both side so that we can usually take care of integer overflow by simply doing "saturated arithmetic" and if one of the bound overflow, the two bounds will "cross" each others and we will get an empty range. </p>

</div>
</div>
<a id="a1227e67513602591fb959e35c9de66e8" name="a1227e67513602591fb959e35c9de66e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1227e67513602591fb959e35c9de66e8">&#9670;&#160;</a></span>kMaxIntegerValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::kMaxIntegerValue </td>
          <td>(</td>
          <td class="paramtype">std::numeric_limits&lt; IntegerValue::ValueType &gt;::max() -</td>          <td class="paramname"><span class="paramname"><em>1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The max range of an integer variable is [kMinIntegerValue, kMaxIntegerValue].</p>
<p>It is symmetric so the set of possible ranges stays the same when we take the negation of a variable. Moreover, we need some IntegerValue that fall outside this range on both side so that we can usually take care of integer overflow by simply doing "saturated arithmetic" and if one of the bound overflow, the two bounds will "cross" each others and we will get an empty range. </p>

</div>
</div>
<a id="a5316808a2d5007c3b489e844801385e5" name="a5316808a2d5007c3b489e844801385e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5316808a2d5007c3b489e844801385e5">&#9670;&#160;</a></span>kMinIntegerValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::kMinIntegerValue </td>
          <td>(</td>
          <td class="paramtype">-kMaxIntegerValue.</td>          <td class="paramname"><span class="paramname"><em>value</em></span>()</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5316808a2d5007c3b489e844801385e5" name="a5316808a2d5007c3b489e844801385e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5316808a2d5007c3b489e844801385e5">&#9670;&#160;</a></span>kMinIntegerValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::kMinIntegerValue </td>
          <td>(</td>
          <td class="paramtype">-kMaxIntegerValue.</td>          <td class="paramname"><span class="paramname"><em>value</em></span>()</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add67896a84f6372a648154c5770a0ae0" name="add67896a84f6372a648154c5770a0ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add67896a84f6372a648154c5770a0ae0">&#9670;&#160;</a></span>kNoBooleanVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const BooleanVariable operations_research::sat::kNoBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">-</td>          <td class="paramname"><span class="paramname"><em>1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affcb42181de5b23ba7b5df37fe1676a3" name="affcb42181de5b23ba7b5df37fe1676a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcb42181de5b23ba7b5df37fe1676a3">&#9670;&#160;</a></span>kNoClauseIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ClauseIndex operations_research::sat::kNoClauseIndex </td>
          <td>(</td>
          <td class="paramtype">-</td>          <td class="paramname"><span class="paramname"><em>1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bd8c44473618b7eafd33ba978db2f06" name="a5bd8c44473618b7eafd33ba978db2f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd8c44473618b7eafd33ba978db2f06">&#9670;&#160;</a></span>kNoIntegerVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IntegerVariable operations_research::sat::kNoIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">-</td>          <td class="paramname"><span class="paramname"><em>1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dcbeecb5d63f15f9f4c79c2ffa08777" name="a5dcbeecb5d63f15f9f4c79c2ffa08777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcbeecb5d63f15f9f4c79c2ffa08777">&#9670;&#160;</a></span>kNoIntervalVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IntervalVariable operations_research::sat::kNoIntervalVariable </td>
          <td>(</td>
          <td class="paramtype">-</td>          <td class="paramname"><span class="paramname"><em>1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dbcb7017d468a17bdb30252af5c6c31" name="a2dbcb7017d468a17bdb30252af5c6c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbcb7017d468a17bdb30252af5c6c31">&#9670;&#160;</a></span>kNoLiteralIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LiteralIndex operations_research::sat::kNoLiteralIndex </td>
          <td>(</td>
          <td class="paramtype">-</td>          <td class="paramname"><span class="paramname"><em>1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ab45c5256e605ee3da3bf3abd1df2e1" name="a7ab45c5256e605ee3da3bf3abd1df2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab45c5256e605ee3da3bf3abd1df2e1">&#9670;&#160;</a></span>kTrueLiteralIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LiteralIndex operations_research::sat::kTrueLiteralIndex </td>
          <td>(</td>
          <td class="paramtype">-</td>          <td class="paramname"><span class="paramname"><em>2</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special values used in some API to indicate a literal that is always true or always false. </p>

</div>
</div>
<a id="a7b60373d086b4bfab3d7eef132513733" name="a7b60373d086b4bfab3d7eef132513733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b60373d086b4bfab3d7eef132513733">&#9670;&#160;</a></span>LazyMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> operations_research::sat::LazyMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges the two given EncodingNodes by creating a new node that corresponds to the sum of the two given ones. Only the left-most binary variable is created for the parent node, the other ones will be created later when needed. </p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00281">281</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a953eef5429c8eee49950f3f28f22ca09" name="a953eef5429c8eee49950f3f28f22ca09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953eef5429c8eee49950f3f28f22ca09">&#9670;&#160;</a></span>LazyMergeAllNodeWithPQAndIncreaseLb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * operations_research::sat::LazyMergeAllNodeWithPQAndIncreaseLb </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>repository</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a0b03a3ba7d84e291889f64f0897c5518">MergeAllNodesWithDeque()</a> but use a priority queue to merge in priority nodes with smaller sizes. This also enforce that the sum of nodes is greater than its lower bound. </p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00463">463</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a18679d8902d037df4ad5371ab25ad435" name="a18679d8902d037df4ad5371ab25ad435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18679d8902d037df4ad5371ab25ad435">&#9670;&#160;</a></span>LinearBooleanProblemToCnfString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::LinearBooleanProblemToCnfString </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note(user): This function makes a few assumptions about the format of the given LinearBooleanProblem. All constraint coefficients must be 1 (and of the form &gt;= 1) and all objective weights must be strictly positive.</p>
<p>Converts a LinearBooleanProblem to the cnf file format. </p><dl class="section note"><dt>Note</dt><dd>this only works for pure SAT problems (only clauses), max-sat or weighted max-sat problems. Returns an empty string on error. </dd></dl>
<p>Hack: We know that all the variables with index greater than this have been created "artificially" in order to encode a max-sat problem into our format. Each extra variable appear only once, and was used as a slack to reify a soft clause.</p>
<p>This will contains the objective.</p>
<p>This will be the weight of the "hard" clauses in the wcnf format. It must be greater than the sum of the weight of all the soft clauses, so we will just set it to this sum + 1.</p>
<p>There is no direct support for an objective offset in the wcnf format. So this is not a perfect translation of the objective. It is however possible to achieve the same effect by adding a new variable x, and two soft clauses: x with weight offset, and -x with weight offset.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001116">Todo</a></b></dt><dd>(user): implement this trick. </dd></dl>
<p>Output the rest of the objective as singleton constraints.</p>
<p>Since it is falsifying this clause that cost "weigtht", we need to take its negation.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00403">403</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="abe7d45e5b1ef013bac04bd33de575589" name="abe7d45e5b1ef013bac04bd33de575589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7d45e5b1ef013bac04bd33de575589">&#9670;&#160;</a></span>LinearExpressionGcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::LinearExpressionGcd </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>gcd</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gcd of the given LinearExpressionProto. Specifying the second argument will take the gcd with it. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00051">51</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="ae704c82581dd897d1fe09e8a3435077a" name="ae704c82581dd897d1fe09e8a3435077a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae704c82581dd897d1fe09e8a3435077a">&#9670;&#160;</a></span>LinearExpressionProtosAreEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LinearExpressionProtosAreEqual </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>b_scaling</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff a == b * b_scaling. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00679">679</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="acfcd7f361a263decf1acd1f3aa585706" name="acfcd7f361a263decf1acd1f3aa585706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcd7f361a263decf1acd1f3aa585706">&#9670;&#160;</a></span>LinearInequalityCanBeReducedWithClosestMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LinearInequalityCanBeReducedWithClosestMultiple </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>new_rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a linear equation "sum coeff_i * X_i &lt;= rhs. We can rewrite it using
ClosestMultiple() as "base * new_terms + error &lt;= rhs" where error can be bounded using the provided bounds on each variables. This will return true if the error can be ignored and this equation is completely equivalent to new_terms &lt;= new_rhs.</p>
<p>This is useful for cases like 9'999 X + 10'0001 Y &lt;= 155'000 where we have weird coefficient (maybe due to scaling). With a base of 10K, this is equivalent to X + Y &lt;= 15.</p>
<p>Preconditions: All coeffs are assumed to be positive. You can easily negate all the negative coeffs and corresponding bounds before calling this. </p>
<p>Precompute some bounds for the equation base * X + error &lt;= rhs.</p>
<p>The constraint is trivially true.</p>
<p>This is the max error assuming that activity &gt; rhs.</p>
<p>We have old solution valid =&gt; base * X + error &lt;= rhs base * X &lt;= rhs - error base * X &lt;= rhs - min_error X &lt;= new_rhs</p>
<p>And we have old solution invalid =&gt; base * X + error &gt;= rhs + 1 base * X &gt;= rhs + 1 - max_error_if_invalid X &gt;= infeasibility_bound</p>
<p>If the two bounds can be separated, we have an equivalence !</p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00324">324</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="ac8088e9f55c5b4430a04da7e3367f32d" name="ac8088e9f55c5b4430a04da7e3367f32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8088e9f55c5b4430a04da7e3367f32d">&#9670;&#160;</a></span>LinearizedPartIsLarge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LinearizedPartIsLarge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the number of variables in the linearized part represent a large enough proportion of all the problem variables. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00353">353</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="ab84b1a369118c0ee55fd26133eb9bcc4" name="ab84b1a369118c0ee55fd26133eb9bcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84b1a369118c0ee55fd26133eb9bcc4">&#9670;&#160;</a></span>LinearsDifferAtOneTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LinearsDifferAtOneTerm </td>
          <td>(</td>
          <td class="paramtype">const LinearConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>lin1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>lin2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true iff the two linear constraint only differ at a single term.</p>
<p>Preconditions: <a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a> should be sorted by variable and of same size. </p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8h_source.html#l00404">404</a> of file <a class="el" href="presolve__util_8h_source.html">presolve_util.h</a>.</p>

</div>
</div>
<a id="a9af49d12cb0a07cd82e3498380f43a2e" name="a9af49d12cb0a07cd82e3498380f43a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af49d12cb0a07cd82e3498380f43a2e">&#9670;&#160;</a></span>Literals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::Literals </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only used for testing to use the classical SAT notation for a literal. This allows to write Literals({+1, -4, +3}) for the clause with BooleanVariable 0 and 2 appearing positively and 3 negatively. </p>

<p class="definition">Definition at line <a class="el" href="sat__base_8h_source.html#l00146">146</a> of file <a class="el" href="sat__base_8h_source.html">sat_base.h</a>.</p>

</div>
</div>
<a id="a3d113c6e0193be7420f842f6f392189f" name="a3d113c6e0193be7420f842f6f392189f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d113c6e0193be7420f842f6f392189f">&#9670;&#160;</a></span>LiteralTableConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::LiteralTableConstraint </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>literal_tuples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>line_literals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enforces that exactly one literal in line_literals is true, and that all literals in the corresponding line of the literal_tuples matrix are true. This constraint assumes that exactly one literal per column of the literal_tuples matrix is true. </p>
<p>line_literals[i] == true =&gt; literal_tuples[i][j] == true. literal_tuples[i][j] == false =&gt; line_literals[i] == false.</p>
<p>Exactly one selected literal is true.</p>
<p>If all selected literals of the lines containing a literal are false, then the literal is false.</p>

<p class="definition">Definition at line <a class="el" href="sat_2table_8cc_source.html#l00030">30</a> of file <a class="el" href="sat_2table_8cc_source.html">table.cc</a>.</p>

</div>
</div>
<a id="a1281483ec40c05251f937bf10b25603d" name="a1281483ec40c05251f937bf10b25603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1281483ec40c05251f937bf10b25603d">&#9670;&#160;</a></span>LiteralXorIs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::LiteralXorIs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforces the XOR of a set of literals to be equal to the given value. </p>

<p class="definition">Definition at line <a class="el" href="cp__constraints_8h_source.html#l00123">123</a> of file <a class="el" href="cp__constraints_8h_source.html">cp_constraints.h</a>.</p>

</div>
</div>
<a id="a968bcd1e78c91d4c861a784deb8a9f80" name="a968bcd1e78c91d4c861a784deb8a9f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968bcd1e78c91d4c861a784deb8a9f80">&#9670;&#160;</a></span>LoadAllDiffConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadAllDiffConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01533">1533</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a274467bd0b939aa8e494e2ed82404ffd" name="a274467bd0b939aa8e494e2ed82404ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274467bd0b939aa8e494e2ed82404ffd">&#9670;&#160;</a></span>LoadAndConsumeBooleanProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LoadAndConsumeBooleanProblem </td>
          <td>(</td>
          <td class="paramtype">LinearBooleanProblem *</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a0df7b56e0026b783deeeff20487de7cf" title="Loads a BooleanProblem into a given SatSolver instance.">LoadBooleanProblem()</a> but also free the memory used by the problem during the loading. This allows to use less peak memory. Note that this function clear all the constraints of the given problem (not the objective though). </p>
<p>We will process the constraints backward so we can free the memory used by each constraint just after processing it. Because of that, we initially reverse all the constraints to add them in the same order.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00272">272</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a277ebf478f1fa693dd01867071080203" name="a277ebf478f1fa693dd01867071080203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277ebf478f1fa693dd01867071080203">&#9670;&#160;</a></span>LoadAndSolveCpModelForTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadAndSolveCpModelForTest </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001556">Todo</a></b></dt><dd>(user): Clean this up. Solves a CpModelProto without any processing. Only used for unit tests. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02941">2941</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a74ba965c06434561f068b227d5b1f8a3" name="a74ba965c06434561f068b227d5b1f8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ba965c06434561f068b227d5b1f8a3">&#9670;&#160;</a></span>LoadAtMostOneConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadAtMostOneConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01038">1038</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a1efa4af8efff3dc82feb1add05075c63" name="a1efa4af8efff3dc82feb1add05075c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efa4af8efff3dc82feb1add05075c63">&#9670;&#160;</a></span>LoadBaseModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadBaseModel </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple function for the few places where we do "return unsat()".</p>
<p>We will add them all at once after model_proto is loaded.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001560">Todo</a></b></dt><dd>(user): The core algo and symmetries seems to be problematic in some cases. See for instance: neos-691058.mps.gz. This is probably because as we modify the model, our symmetry might be wrong? investigate.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001561">Todo</a></b></dt><dd>(user): More generally, we cannot load the symmetry if we create new Booleans and constraints that link them to some Booleans of the model. Creating Booleans related to integer variable is fine since we only deal with Boolean only symmetry here. It is why we disable this when we have linear relaxation as some of them create new constraints. </dd></dl>
<p>Check the model is still feasible before continuing.</p>
<p>Fully encode variables as needed by the search strategy.</p>
<p>Reserve space for the precedence relations.</p>
<p>Load the constraints.</p>
<p>We propagate after each new Boolean constraint but not the integer ones. So we call FinishPropagation() manually here.</p>
<dl class="section note"><dt>Note</dt><dd>we only do that in debug mode as this can be really slow on certain types of problems with millions of constraints.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001562">Todo</a></b></dt><dd>(user): This is wrong. We should support a MODEL_INVALID end of solve in the <a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01079">1079</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="ab29def40923c6b49578f7f0b8658bbf1" name="ab29def40923c6b49578f7f0b8658bbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29def40923c6b49578f7f0b8658bbf1">&#9670;&#160;</a></span>LoadBoolAndConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadBoolAndConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01024">1024</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a0df7b56e0026b783deeeff20487de7cf" name="a0df7b56e0026b783deeeff20487de7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df7b56e0026b783deeeff20487de7cf">&#9670;&#160;</a></span>LoadBooleanProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LoadBooleanProblem </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a BooleanProblem into a given <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> instance. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001115">Todo</a></b></dt><dd>(user): Currently, the sat solver can load without any issue constraints with duplicate variables, so we just output a warning if the problem is not "valid". Make this a strong check once we have some preprocessing step to remove duplicates variable in the constraints. </dd></dl>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00232">232</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a64c230730625662a2a2032da620b6c6e" name="a64c230730625662a2a2032da620b6c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c230730625662a2a2032da620b6c6e">&#9670;&#160;</a></span>LoadBooleanSymmetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadBooleanSymmetries </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Experimental. Loads the symmetry form the proto symmetry field, as long as they only involve Booleans.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001300">Todo</a></b></dt><dd>(user): We currently only have the code for Booleans, it is why we currently ignore symmetries involving integer variables. </dd></dl>
<p>We currently can only use symmetry that touch a subset of variables.</p>
<p>First, we currently only support loading symmetry between Booleans.</p>
<p>Tricky: Moreover, some constraint will causes extra Boolean to be created and linked with the Boolean in the constraints. We can't use any of the symmetry that touch these since we potentially miss the component that will map these extra Booleans between each other.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001282">Todo</a></b></dt><dd>(user): We could add these extra Boolean during expansion/presolve so that we have the symmetry involing them. Or maybe comes up with a different solution. </dd></dl>
<p>A linear with a complex domain might need extra Booleans to be loaded. </p><dl class="section note"><dt>Note</dt><dd>it should be fine for the Boolean(s) in enforcement_literal though.</dd></dl>
<p>Convert the variable symmetry to a "literal" one.</p>
<dl class="section note"><dt>Note</dt><dd>we also need to add the corresponding cycle for the negated literals.</dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00307">307</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a32358b01352ff3e6ccb494789264ae00" name="a32358b01352ff3e6ccb494789264ae00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32358b01352ff3e6ccb494789264ae00">&#9670;&#160;</a></span>LoadBoolOrConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadBoolOrConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a> loading functions. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01011">1011</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a0677696952c26c0cfdd5b8336ad991f8" name="a0677696952c26c0cfdd5b8336ad991f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0677696952c26c0cfdd5b8336ad991f8">&#9670;&#160;</a></span>LoadBoolXorConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadBoolXorConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01058">1058</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a89da239e75747c3187c2c4bfa2bacf85" name="a89da239e75747c3187c2c4bfa2bacf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89da239e75747c3187c2c4bfa2bacf85">&#9670;&#160;</a></span>LoadCircuitConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadCircuitConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01677">1677</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a0a1b3ad033e2499a4d815f4e98eba795" name="a0a1b3ad033e2499a4d815f4e98eba795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1b3ad033e2499a4d815f4e98eba795">&#9670;&#160;</a></span>LoadCircuitCoveringConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadCircuitCoveringConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b4da650bfcb86c00bee1df0ab0cc953" name="a4b4da650bfcb86c00bee1df0ab0cc953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4da650bfcb86c00bee1df0ab0cc953">&#9670;&#160;</a></span>LoadConditionalLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadConditionalLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcement_literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> version. </p>
<p>The enforcement literals cannot be all at true.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001855">Todo</a></b></dt><dd>(user): Remove the conversion! </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00630">630</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="ace5df13048ddce1b84667d805c764dd8" name="ace5df13048ddce1b84667d805c764dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5df13048ddce1b84667d805c764dd8">&#9670;&#160;</a></span>LoadConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LoadConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls one of the functions below. Returns false if we do not know how to load the given constraints. </p>
<p>Already dealt with.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01702">1702</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="ad81c56ee655b074e6d565cd223a70024" name="ad81c56ee655b074e6d565cd223a70024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81c56ee655b074e6d565cd223a70024">&#9670;&#160;</a></span>LoadCpModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadCpModel </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a CpModelProto inside the given model. This should only be called once on a given '<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a>' class. </p>
<p>We want to load the debug solution before the initial propag. But at this point the objective is not loaded yet, so we will not have a value for the objective integer variable, so we do it again later.</p>
<p>Simple function for the few places where we do "return unsat()".</p>
<p>Auto detect "at least one of" constraints in the <a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html">PrecedencesPropagator</a>. </p><dl class="section note"><dt>Note</dt><dd>we do that before we finish loading the problem (objective and LP relaxation), because propagation will be faster at this point and it should be enough for the purpose of this auto-detection.</dd>
<dd>
this is already done in the presolve, but it is important to redo it here to collect literal =&gt; integer &gt;= bound constraints that are used in many places. Without it, we don't detect them if they depends on long chain of implications.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001563">Todo</a></b></dt><dd>(user): We don't have a good deterministic time on all constraints, so this might take more time than wanted. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>it is important to do that after the probing.</dd></dl>
<p>Compute decomposed energies on demands helper.</p>
<p>We need to know beforehand if the objective var can just be &gt;= terms or needs to be == terms.</p>
<p>Create an objective variable and its associated linear constraint if needed.</p>
<p>Linearize some part of the problem and register LP constraint(s).</p>
<p>We do not care about the &lt;= obj for core, we only need the other side to enforce a restriction of the objective lower bound.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001564">Todo</a></b></dt><dd>(user): This might still create intermediate variables to decompose the objective for no reason. Just deal directly with the objective domain in the core algo by forbidding bad assumptions? Alternatively, just ignore the core solution if it is "too" good and rely on other solvers? </dd></dl>
<p>Create the objective definition inside the <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> so that it can be accessed by the heuristics than needs it.</p>
<dl class="section note"><dt>Note</dt><dd>if there is no mapping, then the variable will be kNoIntegerVariable.</dd></dl>
<p>Fill the objective heuristics data.</p>
<p>Register an objective special propagator.</p>
<p>Intersect the objective domain with the given one if any.</p>
<dl class="section note"><dt>Note</dt><dd>we do one last propagation at level zero once all the constraints were added.</dd></dl>
<p>Report the initial objective variable bounds.</p>
<p>Watch improved objective best bounds.</p>
<p>Import objective bounds. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001565">Todo</a></b></dt><dd>(user): Support objective bounds import in LNS and Core based search. </dd></dl>
<p>Initialize the search strategies.</p>
<p>Create the <a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html">CoreBasedOptimizer</a> class if needed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001566">Todo</a></b></dt><dd>(user): Remove code duplication with the solution_observer in <a class="el" href="#a11198d99e855837fa730eb6a5097a801">SolveLoadedCpModel()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01234">1234</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="a10f6cec7e46c76f4cd934fe0207a53eb" name="a10f6cec7e46c76f4cd934fe0207a53eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f6cec7e46c76f4cd934fe0207a53eb">&#9670;&#160;</a></span>LoadCumulativeConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadCumulativeConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01646">1646</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="aba7deb7ec52ad9f39b76e7c44200af8c" name="aba7deb7ec52ad9f39b76e7c44200af8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7deb7ec52ad9f39b76e7c44200af8c">&#9670;&#160;</a></span>LoadDebugSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadDebugSolution </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This should be called on the presolved model. It will read the file specified by &ndash;cp_model_load_debug_solution and properly fill the model-&gt;Get&lt;DebugSolution&gt;() proto vector. </p>
<p>Make sure we load a solution with the same number of variable has in the presolved model.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00121">121</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="ab83d747b5d6d82dc4e1c55d9f69d8626" name="ab83d747b5d6d82dc4e1c55d9f69d8626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83d747b5d6d82dc4e1c55d9f69d8626">&#9670;&#160;</a></span>LoadExactlyOneConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadExactlyOneConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01048">1048</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a8470e9ca1358898a2c52fc76bcd9c45d" name="a8470e9ca1358898a2c52fc76bcd9c45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8470e9ca1358898a2c52fc76bcd9c45d">&#9670;&#160;</a></span>LoadFeasibilityPump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadFeasibilityPump </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add linear constraints to Feasibility Pump.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01202">1202</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="aff17ce80f88bebcf893741c5e86b7275" name="aff17ce80f88bebcf893741c5e86b7275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff17ce80f88bebcf893741c5e86b7275">&#9670;&#160;</a></span>LoadIntDivConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadIntDivConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01581">1581</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="aca7fee6509920049d61a48cbd0edf30a" name="aca7fee6509920049d61a48cbd0edf30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7fee6509920049d61a48cbd0edf30a">&#9670;&#160;</a></span>LoadIntMaxConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadIntMaxConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c1f1cd3466f640c86fd2df798db0198" name="a8c1f1cd3466f640c86fd2df798db0198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1f1cd3466f640c86fd2df798db0198">&#9670;&#160;</a></span>LoadIntMinConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadIntMinConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a6444401c2185cb6968a3a526951d23" name="a5a6444401c2185cb6968a3a526951d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6444401c2185cb6968a3a526951d23">&#9670;&#160;</a></span>LoadIntModConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadIntModConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01601">1601</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a2a700cf4c7395801227fff94daf5cd64" name="a2a700cf4c7395801227fff94daf5cd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a700cf4c7395801227fff94daf5cd64">&#9670;&#160;</a></span>LoadIntProdConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadIntProdConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01540">1540</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="ade08c3522dfce173ee1fd50fab3bd3c0" name="ade08c3522dfce173ee1fd50fab3bd3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade08c3522dfce173ee1fd50fab3bd3c0">&#9670;&#160;</a></span>LoadLinearConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001296">Todo</a></b></dt><dd>(user): Actually this should never be called since we process linear1 in <a class="el" href="#afa73e23a5cfae0eaf253c2e2518e05e7">ExtractEncoding()</a>. </dd></dl>
<p>Compute the min/max to relax the bounds if needed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001297">Todo</a></b></dt><dd>(user): Reuse ComputeLinearBounds()? but then we need another loop to detect if we only have Booleans. </dd></dl>
<p>Load conditional precedences.</p>
<p>To avoid overflow in the code below, we tighten the bounds.</p>
<p>Load precedences.</p>
<p>To avoid overflow in the code below, we tighten the bounds. </p><dl class="section note"><dt>Note</dt><dd>we detect and do not add trivial relation.</dd></dl>
<p>magnitude * v1 &lt;= magnitude * v2 + rhs_max.</p>
<p>magnitude * v1 &gt;= magnitude * v2 + rhs_min.</p>
<p>Make the terms magnitude * v1 - magnitude * v2 ...</p>
<p>magnitude * v1 + other_lb &lt;= magnitude * v2 + rhs_max</p>
<p>magnitude * v1 + other_ub &gt;= magnitude * v2 + rhs_min</p>
<dl class="section note"><dt>Note</dt><dd>the domain/enforcement of the main constraint do not change. Same for the min/sum and max_sum. The intermediate variables are always equal to the intermediate sum, independently of the enforcement.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001298">Todo</a></b></dt><dd>(user): we should probably also implement an half-reified version of this constraint. </dd></dl>
<p>We have a linear with a complex <a class="el" href="classoperations__research_1_1Domain.html">Domain</a>, we need to create extra Booleans.</p>
<p>For enforcement =&gt; var \in domain, we can potentially reuse the encoding literal directly rather than creating new ones.</p>
<p>Skip non-reachable intervals.</p>
<p>Skip trivial constraint. Note that when this happens, all the intervals before where non-reachable.</p>
<p>If there is just two terms and no enforcement, we don't need to create an extra boolean as the second case can be controlled by the negation of the first.</p>
<p>Make sure all booleans are tights when enumerating all solutions.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01220">1220</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a899896953b6215b01cb0b85caa96bebe" name="a899896953b6215b01cb0b85caa96bebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899896953b6215b01cb0b85caa96bebe">&#9670;&#160;</a></span>LoadLinearConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00662">662</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a23861bab6341cfcfeeff90c2b3e3ab7e" name="a23861bab6341cfcfeeff90c2b3e3ab7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23861bab6341cfcfeeff90c2b3e3ab7e">&#9670;&#160;</a></span>LoadLinMaxConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadLinMaxConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001299">Todo</a></b></dt><dd>(user): Consider replacing the min propagator by max. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01613">1613</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="af8c33159d33daea6d86cc399b37e8b20" name="af8c33159d33daea6d86cc399b37e8b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c33159d33daea6d86cc399b37e8b20">&#9670;&#160;</a></span>LoadModelForPresolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LoadModelForPresolve </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SatParameters</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>local_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>name_for_logging</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Important: Because the model_proto do not contains affine relation or the objective, we cannot call <a class="el" href="#a3216f11aeb59c8cd63d2a1e8cdc6d47b" title="Automatically detect optional variables.">DetectOptionalVariables()</a> ! This might wrongly detect optionality and derive bad conclusion.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02500">2500</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a0f015dd7f088e0a586993ec925a94ced" name="a0f015dd7f088e0a586993ec925a94ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f015dd7f088e0a586993ec925a94ced">&#9670;&#160;</a></span>LoadModelForProbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LoadModelForProbing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>local_model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the constraints in a local model.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002216">Todo</a></b></dt><dd>(user): The model we load does not contain affine relations! But ideally we should be able to remove all of them once we allow more complex constraints to contains linear expression.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002217">Todo</a></b></dt><dd>(user): remove code duplication with cp_model_solver. Here we also do not run the heuristic to decide which variable to fully encode.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002218">Todo</a></b></dt><dd>(user): Maybe do not load slow to propagate constraints? for instance we do not use any linear relaxation here. </dd></dl>
<p>Utility function to load the current problem into a in-memory representation that will be used for probing. Returns false if UNSAT. </p>
<p>Update the domain in the current CpModelProto.</p>
<p>Adapt some of the parameters during this probing phase.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02487">2487</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aa3625f2ac6b65996775a6f9f41035711" name="aa3625f2ac6b65996775a6f9f41035711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3625f2ac6b65996775a6f9f41035711">&#9670;&#160;</a></span>LoadNoOverlap2dConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadNoOverlap2dConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01636">1636</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a932e7e363476a4eacd4422cd2d7f055f" name="a932e7e363476a4eacd4422cd2d7f055f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932e7e363476a4eacd4422cd2d7f055f">&#9670;&#160;</a></span>LoadNoOverlapConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadNoOverlapConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01631">1631</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a903ac568c6e118231b7e22a7d1ee7974" name="a903ac568c6e118231b7e22a7d1ee7974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903ac568c6e118231b7e22a7d1ee7974">&#9670;&#160;</a></span>LoadReservoirConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadReservoirConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01656">1656</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a71a2aae922f1cb8ec020517dfd5a103c" name="a71a2aae922f1cb8ec020517dfd5a103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a2aae922f1cb8ec020517dfd5a103c">&#9670;&#160;</a></span>LoadRoutesConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadRoutesConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01689">1689</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a3609d4b9a2bd583c9daaa19a2f27e711" name="a3609d4b9a2bd583c9daaa19a2f27e711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3609d4b9a2bd583c9daaa19a2f27e711">&#9670;&#160;</a></span>LoadSubcircuitConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadSubcircuitConstraint </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>heads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>multiple_subcircuit_through_zero</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> based functions. This just wraps <a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html">CircuitPropagator</a>. See the comment there to see what this does. Note that any nodes with no outgoing or no incoming arc will cause the problem to be UNSAT. One can call <a class="el" href="#a91d56da965ecd3194b8aa8683f8e5e09">ReindexArcs()</a> first to ignore such nodes. </p>
<p>If a node has no outgoing or no incoming arc, the model will be unsat as soon as we add the corresponding <a class="el" href="#abf7ff8fbf0c457648f4944b2d27c0135">ExactlyOneConstraint()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001129">Todo</a></b></dt><dd>(user): Just ignore node zero if multiple_subcircuit_through_zero is true. </dd></dl>

<p class="definition">Definition at line <a class="el" href="circuit_8cc_source.html#l00650">650</a> of file <a class="el" href="circuit_8cc_source.html">circuit.cc</a>.</p>

</div>
</div>
<a id="a47e5d5cb3e7eb43191d094fc4752b5c6" name="a47e5d5cb3e7eb43191d094fc4752b5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e5d5cb3e7eb43191d094fc4752b5c6">&#9670;&#160;</a></span>LoadVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::LoadVariables </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>view_all_booleans_as_integers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts all the used variables in the CpModelProto and creates a <a class="el" href="classoperations__research_1_1sat_1_1Model.html">sat::Model</a> representation for them. More precisely</p><ul>
<li>All Boolean variables will be mapped.</li>
<li>All Interval variables will be mapped.</li>
<li>All non-Boolean variable will have a corresponding IntegerVariable, and depending on the view_all_booleans_as_integers, some or all of the BooleanVariable will also have an IntegerVariable corresponding to its "integer view".</li>
</ul>
<p>Note(user): We could create IntegerVariable on the fly as they are needed, but that loose the original variable order which might be useful in heuristics later. </p>
<p>All [0, 1] variables always have a corresponding Boolean, even if it is fixed to 0 (domain == [0,0]) or fixed to 1 (domain == [1,1]).</p>
<p>Compute the list of positive variable reference for which we need to create an IntegerVariable.</p>
<p>Compute the integer variable references used by the model.</p>
<p>We always add a linear relaxation for circuit/route except for linearization level zero.</p>
<p>Add the objectives variables that needs to be referenceable as integer even if they are only used as Booleans.</p>
<p>Make sure any unused variable, that is not already a Boolean is considered "used".</p>
<p>We want the variable in the problem order.</p>
<p>It is important for memory usage to reserve tight vector has we have many indexed by IntegerVariable. Unfortunately, we create intermediate IntegerVariable while loading large linear constraint, or when we have disjoint LP component. So this is a best effort at a tight upper bound.</p>
<p>Link any variable that has both views.</p>
<p>Associate with corresponding integer variable.</p>
<p>Create the interval variables.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001281">Todo</a></b></dt><dd>(user): Fix the constant variable situation. An optional interval with constant start/end or size cannot share the same constant variable if it is used in non-optional situation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00127">127</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a7b169dd6f3e2bd0b684265da6a28d6ed" name="a7b169dd6f3e2bd0b684265da6a28d6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b169dd6f3e2bd0b684265da6a28d6ed">&#9670;&#160;</a></span>LookForTrivialSatSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::LookForTrivialSatSolution </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>deterministic_time_limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to randomly tweak the search and stop at the first conflict each time. This can sometimes find feasible solution, but more importantly, it is a form of probing that can sometimes find small and interesting conflicts or fix variables. This seems to work well on the SAT14/app/rook-* problems and do fix more variables if run before probing.</p>
<p>If a feasible SAT solution is found (i.e. all Boolean assigned), then this abort and leave the solver with the full solution assigned.</p>
<p>Returns false iff the problem is UNSAT. </p>
<p>Hack to not have empty logger.</p>
<p>Reset the solver in case it was already used.</p>
<dl class="section note"><dt>Note</dt><dd>this code do not care about the non-Boolean part and just try to assign the existing Booleans.</dd></dl>
<p>SetParameters() reset the deterministic time to zero inside time_limit.</p>
<p>We randomize at the end so that the default params is executed at least once.</p>
<p>Restore the initial parameters.</p>

<p class="definition">Definition at line <a class="el" href="probing_8cc_source.html#l00420">420</a> of file <a class="el" href="probing_8cc_source.html">probing.cc</a>.</p>

</div>
</div>
<a id="a3ad49ae9019c528851f6fd084479a567" name="a3ad49ae9019c528851f6fd084479a567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad49ae9019c528851f6fd084479a567">&#9670;&#160;</a></span>LowerBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::LowerBound </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01539">1539</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a4e17af099eed64300c03a7bc945171f4" name="a4e17af099eed64300c03a7bc945171f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e17af099eed64300c03a7bc945171f4">&#9670;&#160;</a></span>LowerOrEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::LowerOrEqual </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a &lt;= b. </p>
<p><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> based functions. </p>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00619">619</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="a3f35d207f7fbd9abc30ced851352b069" name="a3f35d207f7fbd9abc30ced851352b069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f35d207f7fbd9abc30ced851352b069">&#9670;&#160;</a></span>LowerOrEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::LowerOrEqual </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01582">1582</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a2656f8b95d75b4ba12494e5fc3bc573d" name="a2656f8b95d75b4ba12494e5fc3bc573d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2656f8b95d75b4ba12494e5fc3bc573d">&#9670;&#160;</a></span>LowerOrEqualWithOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::LowerOrEqualWithOffset </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a + offset &lt;= b. </p>

<p class="definition">Definition at line <a class="el" href="precedences_8h_source.html#l00627">627</a> of file <a class="el" href="precedences_8h_source.html">precedences.h</a>.</p>

</div>
</div>
<a id="ae9ec04c047ef7bfe5cfa06c17ff0c76d" name="ae9ec04c047ef7bfe5cfa06c17ff0c76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ec04c047ef7bfe5cfa06c17ff0c76d">&#9670;&#160;</a></span>LpPseudoCostHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::LpPseudoCostHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When not reliable, we skip integer.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001861">Todo</a></b></dt><dd>(user): Use strong branching when not reliable. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001862">Todo</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001863">Todo</a></b></dt><dd>(user): do not branch on integer lp? however it seems better to do that !? Maybe this is because if it has a high pseudo cost average, it is good anyway? </dd></dl>
<p>We delay to subsequent heuristic if the score is 0.0.</p>
<p>This direction works better than the inverse in the benchs. But always branching up seems even better. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001864">Todo</a></b></dt><dd>(user): investigate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00238">238</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a7265fc0e5f5f1ad098805c5029a82fc0" name="a7265fc0e5f5f1ad098805c5029a82fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7265fc0e5f5f1ad098805c5029a82fc0">&#9670;&#160;</a></span>MakeAllCoefficientsPositive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::MakeAllCoefficientsPositive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes all coefficients positive by transforming a variable to its negation. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00300">300</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a398107d209dc3d829796a9060faa8501" name="a398107d209dc3d829796a9060faa8501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398107d209dc3d829796a9060faa8501">&#9670;&#160;</a></span>MakeAllLiteralsPositive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::MakeAllLiteralsPositive </td>
          <td>(</td>
          <td class="paramtype">LinearBooleanProblem *</td>          <td class="paramname"><span class="paramname"><em>problem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modifies the given LinearBooleanProblem so that all the literals appearing inside are positive. </p>
<p>Objective.</p>
<p>Constraints.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00648">648</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="ad094633975889f2d6cc0f93a91355528" name="ad094633975889f2d6cc0f93a91355528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad094633975889f2d6cc0f93a91355528">&#9670;&#160;</a></span>MakeAllVariablesPositive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::MakeAllVariablesPositive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes all variables "positive" by transforming a variable to its negation. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00311">311</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a416207a1e2a7eb94bd6c36442802ed96" name="a416207a1e2a7eb94bd6c36442802ed96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416207a1e2a7eb94bd6c36442802ed96">&#9670;&#160;</a></span>MakeBoundsOfIntegerVariablesInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::MakeBoundsOfIntegerVariablesInteger </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPModelProto *</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This simple step helps and should be done first. Returns false if the model is trivially infeasible because of crossing bounds. </p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00204">204</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="af0e031be8d985befef7e59fe56356746" name="af0e031be8d985befef7e59fe56356746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e031be8d985befef7e59fe56356746">&#9670;&#160;</a></span>MakeItemsFromRectangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt; operations_research::sat::MakeItemsFromRectangles </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>slack_factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html#l00148">148</a> of file <a class="el" href="2d__orthogonal__packing__testing_8cc_source.html">2d_orthogonal_packing_testing.cc</a>.</p>

</div>
</div>
<a id="af483d3fee5a1d84f115a3797cddbd98c" name="af483d3fee5a1d84f115a3797cddbd98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af483d3fee5a1d84f115a3797cddbd98c">&#9670;&#160;</a></span>MaxNodeWeightSmallerThan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Coefficient operations_research::sat::MaxNodeWeightSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum node weight under the given upper_bound. Returns zero if no such weight exist (note that a node weight is strictly positive, so this make sense). </p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00576">576</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a0c78f247ab4f6f3851944098fd5b1b8c" name="a0c78f247ab4f6f3851944098fd5b1b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c78f247ab4f6f3851944098fd5b1b8c">&#9670;&#160;</a></span>MaxSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::MaxSize </td>
          <td>(</td>
          <td class="paramtype">IntervalVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00244">244</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a0b03a3ba7d84e291889f64f0897c5518" name="a0b03a3ba7d84e291889f64f0897c5518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b03a3ba7d84e291889f64f0897c5518">&#9670;&#160;</a></span>MergeAllNodesWithDeque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * operations_research::sat::MergeAllNodesWithDeque </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>repository</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges all the given nodes two by two until there is only one left. Returns the final node which encodes the sum of all the given nodes. </p>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00441">441</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a887f6ed27a01ab3f1e1e9a7e93bd6624" name="a887f6ed27a01ab3f1e1e9a7e93bd6624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887f6ed27a01ab3f1e1e9a7e93bd6624">&#9670;&#160;</a></span>MergePositiveVariableTermsAndCheckForOverflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::MergePositiveVariableTermsAndCheckForOverflow </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>terms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sort and add coeff of duplicate variables. Note that a variable and its negation will appear one after another in the natural order.</p>

<p class="definition">Definition at line <a class="el" href="sat_2linear__constraint_8h_source.html#l00411">411</a> of file <a class="el" href="sat_2linear__constraint_8h_source.html">linear_constraint.h</a>.</p>

</div>
</div>
<a id="af004193a12bf9ed78b295e7f7cb51e6f" name="af004193a12bf9ed78b295e7f7cb51e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af004193a12bf9ed78b295e7f7cb51e6f">&#9670;&#160;</a></span>MinimizeCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::MinimizeCore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>core</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to minimize the given UNSAT core with a really simple heuristic. The idea is to remove literals that are consequences of others in the core. We already know that in the initial order, no literal is propagated by the one before it, so we just look for propagation in the reverse order.</p>
<p>Important: The given <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> must be the one that just produced the given core.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002392">Todo</a></b></dt><dd>(user): One should use <a class="el" href="#a4d6ba15542ec5d59958de53c92279b2a">MinimizeCoreWithPropagation()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l02830">2830</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a4d6ba15542ec5d59958de53c92279b2a" name="a4d6ba15542ec5d59958de53c92279b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6ba15542ec5d59958de53c92279b2a">&#9670;&#160;</a></span>MinimizeCoreWithPropagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::MinimizeCoreWithPropagation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>core</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="#af004193a12bf9ed78b295e7f7cb51e6f">MinimizeCore()</a> with a slower but strictly better heuristic. This algorithm should produce a minimal core with respect to propagation. We put each literal of the initial core "last" at least once, so if such literal can be inferred by propagation by any subset of the other literal, it will be removed.</p>
<dl class="section note"><dt>Note</dt><dd>the literal of the minimized core will stay in the same order.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002120">Todo</a></b></dt><dd>(user): Avoid spending too much time trying to minimize a core. </dd></dl>
<p>We want each literal in candidate to appear last once in our propagation order. We want to do that while maximizing the reutilization of the current assignment prefix, that is minimizing the number of decision/progagation we need to perform.</p>
<p>This is a "weird" API to get the subset of decisions that caused this literal to be false with reason analysis.</p>
<p>We want to preserve the order of literal in the response.</p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00057">57</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="a56ad40efdac4d337987b0ca306aa7bd6" name="a56ad40efdac4d337987b0ca306aa7bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ad40efdac4d337987b0ca306aa7bd6">&#9670;&#160;</a></span>MinimizeCoreWithSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::MinimizeCoreWithSearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>core</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002095">Todo</a></b></dt><dd>(user): tune. </dd></dl>
<p>Find a not yet removed literal to remove. We prefer to remove high indices since these are more likely to be of high depth.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002096">Todo</a></b></dt><dd>(user): Properly use the node depth instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00114">114</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="ab231dff94744f73429364e7180b1397f" name="ab231dff94744f73429364e7180b1397f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab231dff94744f73429364e7180b1397f">&#9670;&#160;</a></span>MinimizeIntegerVariableWithLinearScanAndLazyEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::MinimizeIntegerVariableWithLinearScanAndLazyEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>objective_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>feasible_solution_observer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Model-based API to minimize a given IntegerVariable by solving a sequence of decision problem. Each problem is solved using SolveIntegerProblem(). Returns the status of the last solved decision problem.</p>
<p>The feasible_solution_observer function will be called each time a new feasible solution is found.</p>
<dl class="section note"><dt>Note</dt><dd>this function will resume the search from the current state of the solver, and it is up to the client to backtrack to the root node if needed. </dd></dl>
<p>Simple linear scan algorithm to find the optimal.</p>
<p>The objective is the current lower bound of the objective_var.</p>
<p>We have a solution!</p>
<p>Restrict the objective.</p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00211">211</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="a633a2eb5447b0e49f8958cb4bb4b7a44" name="a633a2eb5447b0e49f8958cb4bb4b7a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633a2eb5447b0e49f8958cb4bb4b7a44">&#9670;&#160;</a></span>MinimizeL1DistanceWithHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::MinimizeL1DistanceWithHint </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve a model with a different objective consisting of minimizing the L1 distance with the provided hint. Note that this method creates an in-memory copy of the model and loads a local <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> object from the copied model. </p>
<p>Forward some shared class.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001572">Todo</a></b></dt><dd>(user): As of now the repair hint doesn't support when enumerate_all_solutions is set since the solution is created on a different model. </dd></dl>
<p>Change the parameters.</p>
<p>Update the model to introduce penalties to go away from hinted values.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001573">Todo</a></b></dt><dd>(user): For boolean variables we can avoid creating new variables. </dd></dl>
<p>Add a new var to represent the difference between var and value.</p>
<p>new_var = var - value.</p>
<p>abs_var = abs(new_var).</p>
<p>Solve optimization problem.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01712">1712</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="aba58497e1b2f2b732475d5796dbbbce6" name="aba58497e1b2f2b732475d5796dbbbce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba58497e1b2f2b732475d5796dbbbce6">&#9670;&#160;</a></span>MinSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::MinSize </td>
          <td>(</td>
          <td class="paramtype">IntervalVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> based functions. </p>

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00238">238</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a4a998a24858a532c80b11c1d015e76db" name="a4a998a24858a532c80b11c1d015e76db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a998a24858a532c80b11c1d015e76db">&#9670;&#160;</a></span>ModularInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::ModularInverse </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using the extended Euclidean algo, we find a and b such that a x + b m = gcd(x, m) <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm</a></p>
<p>Returns a in [0, m) such that a * x = 1 modulo m. If gcd(x, m) != 1, there is no inverse, and it returns 0.</p>
<p>This DCHECK that x is in [0, m). This is integer overflow safe.</p>
<p>Note(user): I didn't find this in a easily usable standard library. </p>
<p>We only keep the last two terms of the sequences with the "^1" trick:</p>
<p>q = r[i-2] / r[i-1] r[i] = r[i-2] % r[i-1] t[i] = t[i-2] - t[i-1] * q</p>
<p>We always have:</p><ul>
<li>gcd(r[i], r[i - 1]) = gcd(r[i - 1], r[i - 2])</li>
<li>x * t[i] + m * t[i - 1] = r[i]</li>
</ul>
<p>If the gcd is not one, there is no inverse, we returns 0.</p>
<p>Correct the result so that it is in [0, m). Note that abs(t[i]) is known to be less than or equal to x / 2, and we have thorough unit-tests.</p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00144">144</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="af302dfe77be22de2fdecf4d3fa3e42be" name="af302dfe77be22de2fdecf4d3fa3e42be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af302dfe77be22de2fdecf4d3fa3e42be">&#9670;&#160;</a></span>MostFractionalHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::MostFractionalHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the variable with most fractional LP value. </p>
<p>This choose &lt;= value if possible.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00185">185</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="ad40dd9970adbe462e75e6074f8896e76" name="ad40dd9970adbe462e75e6074f8896e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40dd9970adbe462e75e6074f8896e76">&#9670;&#160;</a></span>MoveOneUnprocessedLiteralLast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::MoveOneUnprocessedLiteralLast </td>
          <td>(</td>
          <td class="paramtype">const absl::btree_set&lt; LiteralIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>processed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>relevant_prefix_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Context: this function is not really generic, but required to be unit-tested. It is used in a clause minimization algorithm when we try to detect if any of the clause literals can be propagated by a subset of the other literal being false. For that, we want to enqueue in the solver all the subset of size n-1.</p>
<p>This moves one of the unprocessed literal from literals to the last position. The function tries to do that while preserving the longest possible prefix of literals "amortized" through the calls assuming that we want to move each literal to the last position once.</p>
<p>For a vector of size n, if we want to call this n times so that each literal is last at least once, the sum of the size of the changed suffixes will be O(n log n). If we were to use a simpler algorithm (like moving the last unprocessed literal to the last position), this sum would be O(n^2).</p>
<p>Returns the size of the common prefix of literals before and after the move, or -1 if all the literals are already processed. The argument relevant_prefix_size is used as a hint when keeping more that this prefix size do not matter. The returned value will always be lower or equal to relevant_prefix_size. </p>
<p>To get O(n log n) size of suffixes, we will first process the last n/2 literals, we then move all of them first and process the n/2 literals left. We use the same algorithm recursively. The sum of the suffixes' size S(n) is thus S(n/2) + n + S(n/2). That gives us the correct complexity. The code below simulates one step of this algorithm and is made to be "robust" when from one call to the next, some literals have been removed (but the order of literals is preserved).</p>
<p>Once a prefix size has been decided, it is always better to enqueue the literal already processed first.</p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00388">388</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="af63eebc797e29eb26229f5787cdf5212" name="af63eebc797e29eb26229f5787cdf5212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63eebc797e29eb26229f5787cdf5212">&#9670;&#160;</a></span>MPModelProtoValidationBeforeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::MPModelProtoValidationBeforeConversion </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs some extra tests on the given MPModelProto and returns false if one is not satisfied. These are needed before trying to convert it to the native CP-SAT format. </p>
<p>Abort if there is constraint type we don't currently support.</p>
<p>Abort if finite variable bounds or objective is too large.</p>
<p>Abort if finite constraint bounds or coefficients are too large.</p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00418">418</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="ae0803b8198728cd4f6e58498d9c60091" name="ae0803b8198728cd4f6e58498d9c60091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0803b8198728cd4f6e58498d9c60091">&#9670;&#160;</a></span>NegatedRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::NegatedRef </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Small utility functions to deal with negative variable/literal references. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00044">44</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a437aa190248b2ee0c2971fa058512f71" name="a437aa190248b2ee0c2971fa058512f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437aa190248b2ee0c2971fa058512f71">&#9670;&#160;</a></span>NegationOf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IntegerVariable &gt; operations_research::sat::NegationOf </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector of the negated variables. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00052">52</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ac64e33318b5b09f0c9008950d29a0a7e" name="ac64e33318b5b09f0c9008950d29a0a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64e33318b5b09f0c9008950d29a0a7e">&#9670;&#160;</a></span>NegationOf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> operations_research::sat::NegationOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preserves canonicality. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00433">433</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a829dfffce41f532b7ca32665750a1ec2" name="a829dfffce41f532b7ca32665750a1ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829dfffce41f532b7ca32665750a1ec2">&#9670;&#160;</a></span>NegationOf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::NegationOf </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00155">155</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a9e8bc70ae581d62f20820eebbb17407e" name="a9e8bc70ae581d62f20820eebbb17407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8bc70ae581d62f20820eebbb17407e">&#9670;&#160;</a></span>NewBestBoundCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewBestBoundCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(double)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a callbacks that will be called on each new best objective bound found.</p>
<p>Note that this function is called before the update takes place. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02227">2227</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a3cb95842130bc03177260ad20464bdbf" name="a3cb95842130bc03177260ad20464bdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb95842130bc03177260ad20464bdbf">&#9670;&#160;</a></span>NewBooleanVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; BooleanVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewBooleanVariable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> based functions.</p>
<dl class="section note"><dt>Note</dt><dd>in the model API, we simply use int64_t for the integer values, so that it is nicer for the client. Internally these are converted to IntegerValue which is typechecked. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01477">1477</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aa7e12611a48297771228ed1bb6971fe1" name="aa7e12611a48297771228ed1bb6971fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e12611a48297771228ed1bb6971fe1">&#9670;&#160;</a></span>NewFeasibleSolutionLogCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewFeasibleSolutionLogCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::string(const CpSolverResponse &amp;response)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a callbacks that will append a string to the search log when reporting a new solution.</p>
<p>The given function will be called on each improving feasible solution found during the search. For a non-optimization problem, if the option to find all solution was set, then this will be called on each new solution. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02219">2219</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="ad13630b39d297fb31cc3c151ff02dcc0" name="ad13630b39d297fb31cc3c151ff02dcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13630b39d297fb31cc3c151ff02dcc0">&#9670;&#160;</a></span>NewFeasibleSolutionObserver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewFeasibleSolutionObserver </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const CpSolverResponse &amp;response)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a solution observer with the model with model.Add(NewFeasibleSolutionObserver([](response){...}));</p>
<p>The given function will be called on each improving feasible solution found during the search. For a non-optimization problem, if the option to find all solution was set, then this will be called on each new solution.</p>
<p>WARNING: Except when enumerate_all_solution() is true, one shouldn't rely on this to get a set of "diverse" solutions since any future change to the solver might completely kill any diversity in the set of solutions observed.</p>
<p>Valid usage of this includes implementing features like:</p><ul>
<li>Enumerating all solution via enumerate_all_solution(). If only n solutions are needed, this can also be used to abort when this number is reached.</li>
<li>Aborting early if a good enough solution is found.</li>
<li>Displaying log progress.</li>
<li>etc... </li>
</ul>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02212">2212</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a7052daba281884bb077df08cb581cb31" name="a7052daba281884bb077df08cb581cb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7052daba281884bb077df08cb581cb31">&#9670;&#160;</a></span>NewIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01500">1500</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ab186c7ad5f0930615f096f56e1499d30" name="ab186c7ad5f0930615f096f56e1499d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab186c7ad5f0930615f096f56e1499d30">&#9670;&#160;</a></span>NewIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01491">1491</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a050c9f843d5f82c4cf6e958a4062e5a7" name="a050c9f843d5f82c4cf6e958a4062e5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050c9f843d5f82c4cf6e958a4062e5a7">&#9670;&#160;</a></span>NewIntegerVariableFromLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewIntegerVariableFromLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated</a></b></dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01532">1532</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a507bc1fac620b6d08f573ae738141bd9" name="a507bc1fac620b6d08f573ae738141bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507bc1fac620b6d08f573ae738141bd9">&#9670;&#160;</a></span>NewInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewInterval </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00263">263</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a10d4ffaa0c34c37b593d23503c35eaa5" name="a10d4ffaa0c34c37b593d23503c35eaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d4ffaa0c34c37b593d23503c35eaa5">&#9670;&#160;</a></span>NewInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewInterval </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00278">278</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a414c2de7ad2f1703693fab810bc4f197" name="a414c2de7ad2f1703693fab810bc4f197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414c2de7ad2f1703693fab810bc4f197">&#9670;&#160;</a></span>NewIntervalWithVariableSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewIntervalWithVariableSize </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00286">286</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a7ca9c8d3f9284a57a274895d29add611" name="a7ca9c8d3f9284a57a274895d29add611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca9c8d3f9284a57a274895d29add611">&#9670;&#160;</a></span>NewOptionalInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewOptionalInterval </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>is_present</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>this should only be used in tests. </dd></dl>
<p>To not have too many solutions during enumeration, we force the start at its min value for absent interval.</p>

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00298">298</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a62d43a4a505cac54beae16c1a91ee3ca" name="a62d43a4a505cac54beae16c1a91ee3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d43a4a505cac54beae16c1a91ee3ca">&#9670;&#160;</a></span>NewOptionalInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewOptionalInterval </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>is_present</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00319">319</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a13e864568827fc45afc655a9967d5f6c" name="a13e864568827fc45afc655a9967d5f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e864568827fc45afc655a9967d5f6c">&#9670;&#160;</a></span>NewOptionalIntervalWithVariableSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntervalVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewOptionalIntervalWithVariableSize </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>is_present</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intervals_8h_source.html#l00329">329</a> of file <a class="el" href="intervals_8h_source.html">intervals.h</a>.</p>

</div>
</div>
<a id="a4bd54ab16ebc1bd6fa80d1e23ab79adc" name="a4bd54ab16ebc1bd6fa80d1e23ab79adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd54ab16ebc1bd6fa80d1e23ab79adc">&#9670;&#160;</a></span>NewSatParameters() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewSatParameters </td>
          <td>(</td>
          <td class="paramtype">const sat::SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tricky: It is important to initialize the model parameters before any of the solver object are created, so that by default they use the given parameters.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001527">Todo</a></b></dt><dd>(user): A notable exception to this is the <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> which is currently not initializing itself from the SatParameters in the model. It will also starts counting from the time of its creation. It will be good to find a solution that is less error prone. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02247">2247</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="adbf4fa68898b3aaa2e6de2b5d3064580" name="adbf4fa68898b3aaa2e6de2b5d3064580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf4fa68898b3aaa2e6de2b5d3064580">&#9670;&#160;</a></span>NewSatParameters() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewSatParameters </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10700832ca6bc420f2931eb707957b0b" name="a10700832ca6bc420f2931eb707957b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10700832ca6bc420f2931eb707957b0b">&#9670;&#160;</a></span>NewSatParameters() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewSatParameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001526">Todo</a></b></dt><dd>(user): Support it on android. </dd></dl>
<p>Creates parameters for the solver, which you can add to the model with </p><div class="fragment"><div class="line">model-&gt;Add(<a class="code hl_function" href="#a10700832ca6bc420f2931eb707957b0b">NewSatParameters</a>(parameters_as_string_or_proto))</div>
<div class="ttc" id="anamespaceoperations__research_1_1sat_html_a10700832ca6bc420f2931eb707957b0b"><div class="ttname"><a href="#a10700832ca6bc420f2931eb707957b0b">operations_research::sat::NewSatParameters</a></div><div class="ttdeci">std::function&lt; SatParameters(Model *)&gt; NewSatParameters(const std::string &amp;params)</div><div class="ttdef"><b>Definition</b> <a href="cp__model__solver_8cc_source.html#l02236">cp_model_solver.cc:2236</a></div></div>
</div><!-- fragment --><p> before calling <code><a class="el" href="#a9d67b9c66f1cb9c1dcc3415cd5af11bf">SolveCpModel()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02236">2236</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a10700832ca6bc420f2931eb707957b0b" name="a10700832ca6bc420f2931eb707957b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10700832ca6bc420f2931eb707957b0b">&#9670;&#160;</a></span>NewSatParameters() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; SatParameters(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewSatParameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001526">Todo</a></b></dt><dd>(user): Support it on android. </dd></dl>
<p>Creates parameters for the solver, which you can add to the model with </p><div class="fragment"><div class="line">model-&gt;Add(<a class="code hl_function" href="#a10700832ca6bc420f2931eb707957b0b">NewSatParameters</a>(parameters_as_string_or_proto))</div>
</div><!-- fragment --><p> before calling <code><a class="el" href="#a9d67b9c66f1cb9c1dcc3415cd5af11bf">SolveCpModel()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02236">2236</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="ad8af8f787d40f2ccb96beb5306c913c5" name="ad8af8f787d40f2ccb96beb5306c913c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8af8f787d40f2ccb96beb5306c913c5">&#9670;&#160;</a></span>NewWeightedSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; IntegerVariable(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::NewWeightedSum </td>
          <td>(</td>
          <td class="paramtype">const VectorInt &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IntegerVariable &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Model-based function to create an IntegerVariable that corresponds to the given weighted sum of other IntegerVariables.</p>
<dl class="section note"><dt>Note</dt><dd>this is templated so that it can seamlessly accept vector&lt;int&gt; or vector&lt;int64_t&gt;.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001856">Todo</a></b></dt><dd>(user): invert the coefficients/vars arguments. </dd></dl>
<p>To avoid overflow in the <a class="el" href="#a4a0524e31331a03f6d21a75bc4421aeb" title="Weighted sum == constant.">FixedWeightedSum()</a> constraint, we need to compute the basic bounds on the sum.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001857">Todo</a></b></dt><dd>(user): deal with overflow here too! </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00683">683</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="adbad520b0fd87f997fd2de7eeff9e848" name="adbad520b0fd87f997fd2de7eeff9e848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbad520b0fd87f997fd2de7eeff9e848">&#9670;&#160;</a></span>NoDuplicateVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::NoDuplicateVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns false if duplicate variables are found in ct. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00377">377</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a8be20b017a46b4e9d7097ee32622eba8" name="a8be20b017a46b4e9d7097ee32622eba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be20b017a46b4e9d7097ee32622eba8">&#9670;&#160;</a></span>NonDeterministicLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::NonDeterministicLoop </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subsolvers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1ModelSharedTimeLimit.html">ModelSharedTimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>time_limit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes the following loop: 1/ Synchronize all in given order. 2/ generate and schedule one task from the current "best" subsolver. 3/ repeat until no extra task can be generated and all tasks are done.</p>
<p>The complexity of each selection is in O(num_subsolvers), but that should be okay given that we don't expect more than 100 such subsolvers.</p>
<dl class="section note"><dt>Note</dt><dd>it is okay to incorporate "special" subsolver that never produce any tasks. This can be used to synchronize classes used by many subsolvers just once for instance. </dd></dl>
<p>The mutex guards num_in_flight and num_in_flight_per_subsolvers. This is used to detect when the search is done.</p>
<p>Predicate to be used with absl::Condition to detect that num_in_flight &lt; num_threads. Must only be called while locking <code>mutex</code>.</p>
<p>The lambda below are using little space, but there is no reason to create millions of them, so we use the blocking nature of pool.Schedule() when the queue capacity is set.</p>
<p><a class="el" href="classoperations__research_1_1Set.html">Set</a> to true if no task is pending right now.</p>
<p>Wait if num_in_flight == num_threads.</p>
<p>To support some "advanced" cancelation of subsolve, we still call synchronize every 0.1 seconds even if there is no worker available.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002451">Todo</a></b></dt><dd>(user): We could also directly register callback to set stopping Boolean to false in a few places. </dd></dl>
<p>The stopping condition is that we do not have anything else to generate once all the task are done and synchronized.</p>
<p>We need to do that while holding the lock since substask below might be currently updating the time via AddTaskDuration().</p>
<p>It is hard to know when new info will allows for more task to be scheduled, so for now we just sleep for a bit. Note that in practice We will never reach here except at the end of the search because we can always schedule LNS threads.</p>
<p>Schedule next task.</p>

<p class="definition">Definition at line <a class="el" href="subsolver_8cc_source.html#l00194">194</a> of file <a class="el" href="subsolver_8cc_source.html">subsolver.cc</a>.</p>

</div>
</div>
<a id="a9543ecb1cf6d394e2919cedde21cf6ed" name="a9543ecb1cf6d394e2919cedde21cf6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9543ecb1cf6d394e2919cedde21cf6ed">&#9670;&#160;</a></span>NoOverlapMinRepairDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::NoOverlapMinRepairDistance </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>interval1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>interval2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="constraint__violation_8cc_source.html#l01213">1213</a> of file <a class="el" href="constraint__violation_8cc_source.html">constraint_violation.cc</a>.</p>

</div>
</div>
<a id="a5e3de118c1f8dd5a7ec21704e05684b9" name="a5e3de118c1f8dd5a7ec21704e05684b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3de118c1f8dd5a7ec21704e05684b9">&#9670;&#160;</a></span>Not()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a> operations_research::sat::Not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient wrapper so we can write Not(x) instead of x.Not() which is sometimes clearer. </p>

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l00087">87</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="ac5f88f13d009bea305340ad747262317" name="ac5f88f13d009bea305340ad747262317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f88f13d009bea305340ad747262317">&#9670;&#160;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01366">1366</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a8ad89939d32828716e2f01940e81ce4a" name="a8ad89939d32828716e2f01940e81ce4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad89939d32828716e2f01940e81ce4a">&#9670;&#160;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01361">1361</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a1b127fca095a77a5c789d443f522fbbb" name="a1b127fca095a77a5c789d443f522fbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b127fca095a77a5c789d443f522fbbb">&#9670;&#160;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator* </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01280">1280</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="ae5e220860af1fa89265bd640ab575c94" name="ae5e220860af1fa89265bd640ab575c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e220860af1fa89265bd640ab575c94">&#9670;&#160;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01276">1276</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="adedef397b25c1cc6909adcae18a820e9" name="adedef397b25c1cc6909adcae18a820e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedef397b25c1cc6909adcae18a820e9">&#9670;&#160;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01292">1292</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a0bdaf49a2294d9fd664ce3ad0360d501" name="a0bdaf49a2294d9fd664ce3ad0360d501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdaf49a2294d9fd664ce3ad0360d501">&#9670;&#160;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01303">1303</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a14d680e53b769b0bf60b6613d27994df" name="a14d680e53b769b0bf60b6613d27994df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d680e53b769b0bf60b6613d27994df">&#9670;&#160;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01234">1234</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="af5d9b25ef5642c457636001e9393034e" name="af5d9b25ef5642c457636001e9393034e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d9b25ef5642c457636001e9393034e">&#9670;&#160;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01243">1243</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a8958bf1527cb994a0d7553282dd731f2" name="a8958bf1527cb994a0d7553282dd731f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8958bf1527cb994a0d7553282dd731f2">&#9670;&#160;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01323">1323</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a23499bc93d6b2ab81e91ea946e2780c8" name="a23499bc93d6b2ab81e91ea946e2780c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23499bc93d6b2ab81e91ea946e2780c8">&#9670;&#160;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01298">1298</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a5317d7f37f16096d85dfc5a7f05bed77" name="a5317d7f37f16096d85dfc5a7f05bed77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5317d7f37f16096d85dfc5a7f05bed77">&#9670;&#160;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01308">1308</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a60111592f54952fd8d14692750ac5617" name="a60111592f54952fd8d14692750ac5617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60111592f54952fd8d14692750ac5617">&#9670;&#160;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01319">1319</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a70c3650a2627f7072b46545ba712da1c" name="a70c3650a2627f7072b46545ba712da1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c3650a2627f7072b46545ba712da1c">&#9670;&#160;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01239">1239</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a12a296a3b389239ce1ffef3527bfa1e3" name="a12a296a3b389239ce1ffef3527bfa1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a296a3b389239ce1ffef3527bfa1e3">&#9670;&#160;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01247">1247</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a1ed1cd9aca1c45ff97111ebfe1d8c555" name="a1ed1cd9aca1c45ff97111ebfe1d8c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed1cd9aca1c45ff97111ebfe1d8c555">&#9670;&#160;</a></span>operator-() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01328">1328</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a37a77b7fe5f2ae90130d7f9cf20a995a" name="a37a77b7fe5f2ae90130d7f9cf20a995a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a77b7fe5f2ae90130d7f9cf20a995a">&#9670;&#160;</a></span>operator-() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01339">1339</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="aedd485d7f6b2ccacff90294455d30ae5" name="aedd485d7f6b2ccacff90294455d30ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd485d7f6b2ccacff90294455d30ae5">&#9670;&#160;</a></span>operator-() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01257">1257</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a1083f8028e54d27eec081e45d92da3da" name="a1083f8028e54d27eec081e45d92da3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1083f8028e54d27eec081e45d92da3da">&#9670;&#160;</a></span>operator-() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01266">1266</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a962810e4d6e648b9bdd8a6147e6ecd8c" name="a962810e4d6e648b9bdd8a6147e6ecd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962810e4d6e648b9bdd8a6147e6ecd8c">&#9670;&#160;</a></span>operator-() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01355">1355</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="ade32b256f6277fd7a7e52c3a17128b96" name="ade32b256f6277fd7a7e52c3a17128b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade32b256f6277fd7a7e52c3a17128b96">&#9670;&#160;</a></span>operator-() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01334">1334</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a90add9340d2579eed96c65f248306982" name="a90add9340d2579eed96c65f248306982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90add9340d2579eed96c65f248306982">&#9670;&#160;</a></span>operator-() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01345">1345</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a49cbabfb6c894b12ffb48181248c2c87" name="a49cbabfb6c894b12ffb48181248c2c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cbabfb6c894b12ffb48181248c2c87">&#9670;&#160;</a></span>operator-() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>epxr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01351">1351</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a3ef55954ce104b703b05f5a926a55c52" name="a3ef55954ce104b703b05f5a926a55c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef55954ce104b703b05f5a926a55c52">&#9670;&#160;</a></span>operator-() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a>. </p>

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01287">1287</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a62d4cee395c01f64847f322fd74f3613" name="a62d4cee395c01f64847f322fd74f3613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d4cee395c01f64847f322fd74f3613">&#9670;&#160;</a></span>operator-() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01262">1262</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="ab29f5117f4220225e73e5984196315a7" name="ab29f5117f4220225e73e5984196315a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29f5117f4220225e73e5984196315a7">&#9670;&#160;</a></span>operator-() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01271">1271</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a49f6d80163fd6aa41fec7ebf8e27949a" name="a49f6d80163fd6aa41fec7ebf8e27949a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f6d80163fd6aa41fec7ebf8e27949a">&#9670;&#160;</a></span>operator-() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> operations_research::sat::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimal support for "natural" API to create <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a>.</p>
<p>Note(user): This might be optimized further by optimizing <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> for holding one term, or introducing an <a class="el" href="structoperations__research_1_1sat_1_1LinearTerm.html">LinearTerm</a> class, but these should mainly be used to construct small expressions. Revisit if we run into performance issues. Note that if perf become a bottleneck for a client, then probably directly writing the proto will be even faster. </p>

<p class="definition">Definition at line <a class="el" href="cp__model_8h_source.html#l01232">1232</a> of file <a class="el" href="cp__model_8h_source.html">cp_model.h</a>.</p>

</div>
</div>
<a id="a646ee3cd14af2a14066c6cd56f7f242b" name="a646ee3cd14af2a14066c6cd56f7f242b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646ee3cd14af2a14066c6cd56f7f242b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00239">239</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a38ddf9ebf6ced32e8fef8475caa357c2" name="a38ddf9ebf6ced32e8fef8475caa357c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ddf9ebf6ced32e8fef8475caa357c2">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__base_8h_source.html#l00127">127</a> of file <a class="el" href="sat__base_8h_source.html">sat_base.h</a>.</p>

</div>
</div>
<a id="a807d4ae4dc98ad0c05fa05c3f1dfabc9" name="a807d4ae4dc98ad0c05fa05c3f1dfabc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807d4ae4dc98ad0c05fa05c3f1dfabc9">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l00089">89</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="a4c1168782300a1c64e854ec6f1ead1ea" name="a4c1168782300a1c64e854ec6f1ead1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1168782300a1c64e854ec6f1ead1ea">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1DoubleLinearExpr.html">DoubleLinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l00488">488</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="a2cf9d9d5996eef7d0e67d446d906bad5" name="a2cf9d9d5996eef7d0e67d446d906bad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf9d9d5996eef7d0e67d446d906bad5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa4a62b204187763884e737d2f51aad8a">EnforcementStatus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__propagation_8cc_source.html#l00053">53</a> of file <a class="el" href="linear__propagation_8cc_source.html">linear_propagation.cc</a>.</p>

</div>
</div>
<a id="afeefd0a183a2d1c9f09fec0aa52b200a" name="afeefd0a183a2d1c9f09fec0aa52b200a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeefd0a183a2d1c9f09fec0aa52b200a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntervalVar.html">IntervalVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l00641">641</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="a0c1b0a196a70f7edd0ff1bc0250e76ac" name="a0c1b0a196a70f7edd0ff1bc0250e76ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1b0a196a70f7edd0ff1bc0250e76ac">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntVar.html">IntVar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l00171">171</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="a9ff9b7f7a0e15c369487e0c089dba1a2" name="a9ff9b7f7a0e15c369487e0c089dba1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff9b7f7a0e15c369487e0c089dba1a2">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat_2linear__constraint_8h_source.html#l00129">129</a> of file <a class="el" href="sat_2linear__constraint_8h_source.html">linear_constraint.h</a>.</p>

</div>
</div>
<a id="a616a1843aa394d2d018e052050588bb2" name="a616a1843aa394d2d018e052050588bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616a1843aa394d2d018e052050588bb2">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l00318">318</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="ad4f0092047d7e82e9fdb7f6b1235947c" name="ad4f0092047d7e82e9fdb7f6b1235947c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f0092047d7e82e9fdb7f6b1235947c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00066">66</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a0af861617ac8f6ef74fe77c789248b86" name="a0af861617ac8f6ef74fe77c789248b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af861617ac8f6ef74fe77c789248b86">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00234">234</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="aac642826c64ada206ceeec3c813a803a" name="aac642826c64ada206ceeec3c813a803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac642826c64ada206ceeec3c813a803a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>literal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__base_8h_source.html#l00117">117</a> of file <a class="el" href="sat__base_8h_source.html">sat_base.h</a>.</p>

</div>
</div>
<a id="ae9035e7022f44a62d30b9ae6050d57a4" name="ae9035e7022f44a62d30b9ae6050d57a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9035e7022f44a62d30b9ae6050d57a4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a></td>          <td class="paramname"><span class="paramname"><em>term</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pb__constraint_8h_source.html#l00069">69</a> of file <a class="el" href="pb__constraint_8h_source.html">pb_constraint.h</a>.</p>

</div>
</div>
<a id="a9ba4fb23e5a8ee32e9a2c807ee82b4c4" name="a9ba4fb23e5a8ee32e9a2c807ee82b4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba4fb23e5a8ee32e9a2c807ee82b4c4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operations_research::sat::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l01073">1073</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a2b20ba2e68f06f165c023e5833e1d3b3" name="a2b20ba2e68f06f165c023e5833e1d3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b20ba2e68f06f165c023e5833e1d3b3">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::operator== </td>
          <td>(</td>
          <td class="paramtype">const BoolArgumentProto &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoolArgumentProto &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>hashing support.</p>
<p>Currently limited to a few inner types of ConstraintProto. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00351">351</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a0db1bfd158b39da039bdfc275e767ee9" name="a0db1bfd158b39da039bdfc275e767ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db1bfd158b39da039bdfc275e767ee9">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::operator== </td>
          <td>(</td>
          <td class="paramtype">const LinearConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00372">372</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a2248f26fb2b8d0a4b25994f904c80150" name="a2248f26fb2b8d0a4b25994f904c80150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2248f26fb2b8d0a4b25994f904c80150">&#9670;&#160;</a></span>OverlapOfTwoIntervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::OverlapOfTwoIntervals </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>interval1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>interval2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>--&mdash; <a class="el" href="classoperations__research_1_1sat_1_1CompiledNoOverlap2dConstraint.html">CompiledNoOverlap2dConstraint</a> --&mdash; </p>
<p>We force a min cost of 1 to cover the case where a interval of size 0 is in the middle of another interval.</p>

<p class="definition">Definition at line <a class="el" href="constraint__violation_8cc_source.html#l01188">1188</a> of file <a class="el" href="constraint__violation_8cc_source.html">constraint_violation.cc</a>.</p>

</div>
</div>
<a id="a1920a590c197db1c4cb7beac6cf4a4f6" name="a1920a590c197db1c4cb7beac6cf4a4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1920a590c197db1c4cb7beac6cf4a4f6">&#9670;&#160;</a></span>PartialIsOneOfVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::PartialIsOneOfVar </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>target_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>selectors</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The target variable is equal to exactly one of the candidate variable. The equality is controlled by the given "selector" literals.</p>
<p>Note(user): This only propagate from the min/max of still possible candidates to the min/max of the target variable. The full constraint also requires to deal with the case when one of the literal is true.</p>
<p>Note(user): If there is just one or two candidates, this doesn't add anything. </p>
<p>Propagate the min.</p>
<p>Propagate the max.</p>

<p class="definition">Definition at line <a class="el" href="cp__constraints_8h_source.html#l00162">162</a> of file <a class="el" href="cp__constraints_8h_source.html">cp_constraints.h</a>.</p>

</div>
</div>
<a id="a9de14d43c9cfa1c3df4c349eae8bae9c" name="a9de14d43c9cfa1c3df4c349eae8bae9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de14d43c9cfa1c3df4c349eae8bae9c">&#9670;&#160;</a></span>PavedRegionDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; operations_research::sat::PavedRegionDifference </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>original_region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>area_to_remove</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two regions, each one of them defined by a vector of non-overlapping rectangles paving them, returns a vector of non-overlapping rectangles that paves the points that were part of the first region but not of the second. This can also be seen as the set difference of the points of the regions. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l01611">1611</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="ac435c5e5536231b2542ba53f100c3936" name="ac435c5e5536231b2542ba53f100c3936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac435c5e5536231b2542ba53f100c3936">&#9670;&#160;</a></span>PositiveMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PositiveMod </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just returns x % m but with a result always in [0, m). </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00177">177</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="acdbc8ad33149d45a6e6fcd8b72fd68ed" name="acdbc8ad33149d45a6e6fcd8b72fd68ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbc8ad33149d45a6e6fcd8b72fd68ed">&#9670;&#160;</a></span>PositiveRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PositiveRef </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00045">45</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a83f714c395df7a814ed067125f567a0d" name="a83f714c395df7a814ed067125f567a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f714c395df7a814ed067125f567a0d">&#9670;&#160;</a></span>PositiveRemainder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::PositiveRemainder </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>dividend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>positive_divisor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns dividend - FloorRatio(dividend, divisor) * divisor;</p>
<p>This function is around the same speed than the computation above, but it never causes integer overflow. Note also that when calling <a class="el" href="#a07823d046b027c81155f8a2f322cf813">FloorRatio()</a> then <a class="el" href="#a83f714c395df7a814ed067125f567a0d">PositiveRemainder()</a>, the compiler should optimize the modulo away and just reuse the one from the first integer division. </p>

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00118">118</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="ac1f5fc24892786308e339b0865309580" name="ac1f5fc24892786308e339b0865309580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f5fc24892786308e339b0865309580">&#9670;&#160;</a></span>PositiveVarExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> operations_research::sat::PositiveVarExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the same expression with positive variables. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00441">441</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a7f1ac774d4646a83631f8117f4ea03f5" name="a7f1ac774d4646a83631f8117f4ea03f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ac774d4646a83631f8117f4ea03f5">&#9670;&#160;</a></span>PositiveVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::PositiveVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00163">163</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a94b1038b63ced09f0c7239a726dbe790" name="a94b1038b63ced09f0c7239a726dbe790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b1038b63ced09f0c7239a726dbe790">&#9670;&#160;</a></span>PossibleIntegerOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PossibleIntegerOverflow </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given linear expression can create overflow. It is exposed to test new constraints created during the presolve. </p>
<dl class="section note"><dt>Note</dt><dd>we use min/max with zero to disallow "alternative" terms and be sure that we cannot have an overflow if we do the computation in a different order.</dd></dl>
<p>In addition to computing the min/max possible sum, we also often compare it with the constraint bounds, so we do not want max - min to overflow. We might also create an intermediate variable to represent the sum.</p>
<dl class="section note"><dt>Note</dt><dd>it is important to be symmetric here, as we do not want expr to pass but not -expr!</dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__checker_8cc_source.html#l01011">1011</a> of file <a class="el" href="cp__model__checker_8cc_source.html">cp_model_checker.cc</a>.</p>

</div>
</div>
<a id="a62555e26e4185c3c441e9222914b4186" name="a62555e26e4185c3c441e9222914b4186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62555e26e4185c3c441e9222914b4186">&#9670;&#160;</a></span>PossibleOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PossibleOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>integer_trail</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests for possible overflow in the given linear constraint used for the linear relaxation. This is a bit relaxed compared to what we require for generic linear constraint that are used in our CP propagators.</p>
<p>If this check pass, our constraint should be safe to use in our simplication code, our cut computation, etc... </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00479">479</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="ab67697c2e8ba7d65eff35db17d7b94a9" name="ab67697c2e8ba7d65eff35db17d7b94a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67697c2e8ba7d65eff35db17d7b94a9">&#9670;&#160;</a></span>PostsolveClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveClause </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This postsolve is "special". If the clause is not satisfied, we fix the first literal in the clause to true (even if it was fixed to false). This allows to handle more complex presolve operations used by the SAT presolver.</p>
<p>Also, any "free" Boolean should be fixed to some value for the subsequent postsolve steps. </p>
<p>We still need to assign free variable. Any value should work.</p>
<p>Change the value of the first variable (which was chosen at presolve).</p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00040">40</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a1743e4469ce5d2535719981c49544a5d" name="a1743e4469ce5d2535719981c49544a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1743e4469ce5d2535719981c49544a5d">&#9670;&#160;</a></span>PostsolveElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveElement </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We only support 2 cases: either the index was removed, of the target, not both. </p>
<p>Deal with fixed index.</p>
<p>Deal with fixed target (and constant vars).</p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00283">283</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a62feb42f880fdeb019acf6a06cff70c1" name="a62feb42f880fdeb019acf6a06cff70c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62feb42f880fdeb019acf6a06cff70c1">&#9670;&#160;</a></span>PostsolveExactlyOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveExactlyOne </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fix one at true.</p>
<p>Fix any free variable left at false.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00063">63</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="aaf05e16c4d9a267526d3edaec410dd32" name="aaf05e16c4d9a267526d3edaec410dd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf05e16c4d9a267526d3edaec410dd32">&#9670;&#160;</a></span>PostsolveIntMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveIntMod </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We only support assigning to an affine target. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00326">326</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a74933f0fe5e619ae684cba634094a7a8" name="a74933f0fe5e619ae684cba634094a7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74933f0fe5e619ae684cba634094a7a8">&#9670;&#160;</a></span>PostsolveIntProd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveIntProd </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We only support assigning to an affine target. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00342">342</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a1951d3606d9c0c92204c310b911bf0e7" name="a1951d3606d9c0c92204c310b911bf0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951d3606d9c0c92204c310b911bf0e7">&#9670;&#160;</a></span>PostsolveLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveLinear </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Here we simply assign all non-fixed variable to a feasible value. Which should always exists by construction. </p>
<p>The constraint is satisfied, if there is any enforcement that are not fixed yet, we need to fix them.</p>
<p>Tricky: We sometime push two constraints for postsolve: 1/ l =&gt; A 2/ not(l) =&gt; B if B is true, it is better to fix <code>l</code> so that the constraint 2/ is enforced. This way we should have no problem when processing 1/</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001304">Todo</a></b></dt><dd>(user): This is a bit hacky, if we need to postsolve both constraints at once, it might be cleaner to do that in a single postsolve operation. However this allows us to reuse normal constraints for the postsolve specification, which is nice. </dd></dl>
<p>Fast track for the most common case.</p>
<p>The postsolve code is a bit involved if there is more than one free variable, we have to postsolve them one by one.</p>
<p>Here we recompute the same domains as during the presolve. Everything is like if we where substiting the variable one by one: terms[i] + fixed_activity \in rhs_domains[i] In the reverse order.</p>
<dl class="section note"><dt>Note</dt><dd>these should be exactly the same computation as the one done during presolve and should be exact. However, we have some tests that do not comply, so we don't check exactness here. Also, as long as we don't get empty domain below, and the complexity of the domain do not explode here, we should be fine.</dd></dl>
<p>Choose a value for free_vars[i] that fall into rhs_domains[i] - fixed_activity. This will crash if the intersection is empty, but it shouldn't be.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001305">Todo</a></b></dt><dd>(user): I am not 100% that the algo here might cover all the presolve case, so if this fail, it might indicate an issue here and not in the presolve/solver code. </dd></dl>
<p>We assign that afterwards for better debugging if we run into the domains empty above.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00117">117</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a86b855c27a037ed3eec043f0f0f25e2e" name="a86b855c27a037ed3eec043f0f0f25e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b855c27a037ed3eec043f0f0f25e2e">&#9670;&#160;</a></span>PostsolveLinMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveLinMax </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the max of each expression, and assign it to the target expr. We only support post-solving the case where whatever the value of all expression, there will be a valid target. </p>
<p>In most case all expression are fixed, except in the corner case where one of the expression refer to the target itself !</p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00263">263</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="aba206d3b30a8812e9fae0e74c7277ad9" name="aba206d3b30a8812e9fae0e74c7277ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba206d3b30a8812e9fae0e74c7277ad9">&#9670;&#160;</a></span>PostsolveResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveResponse </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>num_variables_in_original_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>postsolve_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Postsolves the given response using information filled by our presolver.</p>
<p>This works as follow:</p><ul>
<li>First we fix fixed variables of the mapping_model according to the solution of the presolved problem and the index mapping.</li>
<li>Then, we process the mapping constraints in "reverse" order, and unit propagate each of them when necessary. By construction this should never give rise to any conflicts. And after each constraints, we should have a feasible solution to the presolved problem + all already postsolved constraints. This is the invariant we maintain.</li>
<li>Finally, we arbitrarily fix any free variables left and update the given response with the new solution.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Most of the postsolve operations require the constraints to have been written in the correct way by the presolve.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001306">Todo</a></b></dt><dd>(user): We could use the search strategy to fix free variables to some chosen values? The feature might never be needed though. </dd></dl>
<p>Read the initial variable domains, either from the fixed solution of the presolved problems or from the mapping model.</p>
<p>Process the constraints in reverse order.</p>
<p>We ignore constraint with an enforcement literal set to false. If the enforcement is still unclear, we still process this constraint.</p>
<p>This should never happen as we control what kind of constraint we add to the mapping_proto;</p>
<p>Fill the response. Maybe fix some still unfixed variable.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00382">382</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a5c02c475828b411a8dbd4b3c399eb251" name="a5c02c475828b411a8dbd4b3c399eb251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c02c475828b411a8dbd4b3c399eb251">&#9670;&#160;</a></span>PostsolveResponseWithFullSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveResponseWithFullSolver </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_variables_in_original_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto</td>          <td class="paramname"><span class="paramname"><em>mapping_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>postsolve_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001574">Todo</a></b></dt><dd>(user): If this ever shows up in the profile, we could avoid copying the mapping_proto if we are careful about how we modify the variable domain before postsolving it. Note that 'num_variables_in_original_model' refers to the model before presolve. </dd></dl>
<p>Fix the correct variable in the mapping_proto.</p>
<p>Postosolve parameters. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001575">Todo</a></b></dt><dd>(user): this problem is usually trivial, but we may still want to impose a time limit or copy some of the parameters passed by the user. </dd></dl>
<p>We only copy the solution from the postsolve_response to the response.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01822">1822</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="ad2bd81a63601be208cff5d7d34f6a5db" name="ad2bd81a63601be208cff5d7d34f6a5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bd81a63601be208cff5d7d34f6a5db">&#9670;&#160;</a></span>PostsolveResponseWrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PostsolveResponseWrapper </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_variable_in_original_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>postsolve_mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01866">1866</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="a80355280b6a679a0e89bbeb71708f5cf" name="a80355280b6a679a0e89bbeb71708f5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80355280b6a679a0e89bbeb71708f5cf">&#9670;&#160;</a></span>Preprocess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::Preprocess </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; <a class="el" href="structoperations__research_1_1sat_1_1PermutableItem.html">PermutableItem</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; IntegerValue, IntegerValue &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bounding_box_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_complexity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exposed for testing. </p>
<p>Try to find an equivalent smaller OPP problem by fixing large items. The API is a bit unusual: it takes a reference to a mutable Span of sizes and rectangles. When this function finds an item that can be fixed, it sets the position of the <a class="el" href="structoperations__research_1_1sat_1_1PermutableItem.html">PermutableItem</a>, reorders <code>items</code> to put that item in the end of the span and then resizes the span so it contain only non-fixed items.</p>
<dl class="section note"><dt>Note</dt><dd>the position of input items is not used and the position of non-fixed items will not be modified by this function. </dd></dl>
<p>No point in optimizing obviously infeasible instance.</p>
<p>No item (not even the narrowest one) fit alongside the widest item. So we care only about fitting the remaining items in the remaining space.</p>

<p class="definition">Definition at line <a class="el" href="2d__packing__brute__force_8cc_source.html#l00546">546</a> of file <a class="el" href="2d__packing__brute__force_8cc_source.html">2d_packing_brute_force.cc</a>.</p>

</div>
</div>
<a id="a7a3e424a9963561cbd837b7a293b416e" name="a7a3e424a9963561cbd837b7a293b416e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3e424a9963561cbd837b7a293b416e">&#9670;&#160;</a></span>PresolveBooleanLinearExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveBooleanLinearExpression </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Coefficient &gt; *</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient *</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the given linear expression so that:</p><ul>
<li>duplicate terms are merged.</li>
<li>terms with a literal and its negation are merged.</li>
<li>all weight are positive.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002121">Todo</a></b></dt><dd>(user): Merge this with similar code like <a class="el" href="#afe0ad26c40a4024f160695f2a504ff0a">ComputeBooleanLinearExpressionCanonicalForm()</a>. </dd></dl>
<p>Sorting by literal index regroup duplicate or negated literal together.</p>
<p>Merge terms if needed.</p>
<p>The term is coeff *( 1 - X).</p>
<p>Rebuild with positive coeff.</p>
<p>coeff * X = coeff - coeff * (1 - X).</p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00851">851</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="a5ae90163b3b1ba74569501c3a9d3e6d6" name="a5ae90163b3b1ba74569501c3a9d3e6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae90163b3b1ba74569501c3a9d3e6d6">&#9670;&#160;</a></span>PresolveCpModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpSolverStatus operations_research::sat::PresolveCpModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>postsolve_mapping</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient wrapper to call the full presolve. </p>
<p>Public API. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l13057">13057</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="aef7dd0a73fe3618ca37a526969940761" name="aef7dd0a73fe3618ca37a526969940761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7dd0a73fe3618ca37a526969940761">&#9670;&#160;</a></span>PresolveFixed2dRectangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveFixed2dRectangles </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html">RectangleInRange</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>non_fixed_boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>fixed_boxes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of fixed boxes and a set of boxes that are not yet fixed (but attributed a range), look for a more optimal set of fixed boxes that are equivalent to the initial set of fixed boxes. This uses "equivalent" in the sense that a placement of the non-fixed boxes will be non-overlapping with all other boxes if and only if it was with the original set of fixed boxes too. </p>
<p>This implementation compiles a set of areas that cannot be occupied by any item, then calls ReduceNumberofBoxes() to use these areas to minimize <code>fixed_boxes</code>.</p>
<p>The greedy algorithm is really fast. Run it first since it might greatly reduce the size of large trivial instances.</p>
<p>Fixed items are only useful to constraint where the non-fixed items can be placed. This means in particular that any part of a fixed item outside the bounding box of the non-fixed items is useless. Clip them.</p>
<p>The whole rectangle was outside of the domain, remove it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001105">Todo</a></b></dt><dd>(user): instead of doing the greedy algorithm first with optional boxes, and then the one that is exact for mandatory boxes but weak for optional ones, refactor the second algorithm. One possible way of doing that would be to follow the shape boundary of optional+mandatory boxes and look whether we can shave off some turns. For example, if we have a shape like below, with the "+" representing area covered by optional boxes, we can replace the turns by a straight line. </dd></dl>
<p>^ ++++ . ++++ . . ++++ . =&gt; ++++ \/</p>
<hr  />
 <hr  />
<p>Since less turns means less edges, this should be a good way to reduce the number of boxes.</p>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l00165">165</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="a89916cb29dee74465f5d966707a34845" name="a89916cb29dee74465f5d966707a34845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89916cb29dee74465f5d966707a34845">&#9670;&#160;</a></span>PrintClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PrintClauses </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6cd6f4cf7fb7b9e5d8788c7bb25b51ce">SatFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>clauses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_variables</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the given clauses in the file at the given path, using the given file format. Returns true iff the file was successfully written. </p>

<p class="definition">Definition at line <a class="el" href="drat__checker_8cc_source.html#l00606">606</a> of file <a class="el" href="drat__checker_8cc_source.html">drat_checker.cc</a>.</p>

</div>
</div>
<a id="a76af37fab5c93f2f256ff65457866fb4" name="a76af37fab5c93f2f256ff65457866fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af37fab5c93f2f256ff65457866fb4">&#9670;&#160;</a></span>ProbeAndFindEquivalentLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ProbeAndFindEquivalentLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html">SatPostsolver</a> *</td>          <td class="paramname"><span class="paramname"><em>postsolver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>drat_proof_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; LiteralIndex, LiteralIndex &gt; *</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Presolver that does literals probing and finds equivalent literals by computing the strongly connected components of the graph: literal l -&gt; literals propagated by l.</p>
<p>Clears the mapping if there are no equivalent literals. Otherwise, mapping[l] is the representative of the equivalent class of l. Note that mapping[l] may be equal to l.</p>
<p>The postsolver will be updated so it can recover a solution of the mapped problem. Note that this works on any problem the <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> can handle, not only pure SAT problem, but the returned mapping do need to be applied to all constraints. </p>
<p>We have no guarantee that the cycle of x and not(x) touch the same variables. This is because we may have more info for the literal probed later or the propagation may go only in one direction. For instance if we have two clauses (not(x1) v x2) and (not(x1) v not(x2) v x3) then x1 implies x2 and x3 but not(x3) doesn't imply anything by unit propagation.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002440">Todo</a></b></dt><dd>(user): Add some constraint so that it does?</dd></dl>
<p>Because of this, we "merge" the cycles.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002441">Todo</a></b></dt><dd>(user): check compatibility? if x ~ not(x) =&gt; unsat. but probably, the solver would have found this too? not sure... </dd></dl>
<p>We rely on the fact that the representative of a literal x and the one of its negation are the same variable.</p>
<p>If a variable in a cycle is fixed. We want to fix all of them.</p>
<p>We first fix all representative if one variable of the cycle is fixed. In a second pass we fix all the variable of a cycle whose representative is fixed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002442">Todo</a></b></dt><dd>(user): Fixing a variable might fix more of them by propagation, so we might not fix everything possible with these loops. </dd></dl>

<p class="definition">Definition at line <a class="el" href="simplification_8cc_source.html#l01141">1141</a> of file <a class="el" href="simplification_8cc_source.html">simplification.cc</a>.</p>

</div>
</div>
<a id="a60a37142e38a0a290d70b030405db801" name="a60a37142e38a0a290d70b030405db801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a37142e38a0a290d70b030405db801">&#9670;&#160;</a></span>ProbeAndSimplifyProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ProbeAndSimplifyProblem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html">SatPostsolver</a> *</td>          <td class="paramname"><span class="paramname"><em>postsolver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearBooleanProblem *</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple preprocessing step that does basic probing and removes the equivalent literals.</p>
<p>A simple preprocessing step that does basic probing and removes the fixed and equivalent variables. Note that the variable indices will also be remapped in order to be dense. The given postsolver will be updated with the information needed during postsolve. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001121">Todo</a></b></dt><dd>(user): expose the number of iterations as a parameter. </dd></dl>
<p>We can abort if no information is learned.</p>
<p>Fix fixed variables in the equivalence map and in the postsolver.</p>
<p>Remap the variables into a dense set. All the variables for which the equiv_map is not the identity are no longer needed.</p>
<p>Apply the variable mapping.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00837">837</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a98f7eb19b1030f3da667a3914c7ba666" name="a98f7eb19b1030f3da667a3914c7ba666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f7eb19b1030f3da667a3914c7ba666">&#9670;&#160;</a></span>ProbeLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ProbeLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>assumption</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>since we only care about Booleans here, even if we have a feasible solution, it might not be feasible for the full cp_model.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002097">Todo</a></b></dt><dd>(user): Still use it if the problem is Boolean only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00168">168</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="af4bda4a1e891ce16104b476b327af01e" name="af4bda4a1e891ce16104b476b327af01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bda4a1e891ce16104b476b327af01e">&#9670;&#160;</a></span>ProcessFloatingPointOVariablesAndObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ProcessFloatingPointOVariablesAndObjective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1fz_1_1Model.html">fz::Model</a> *</td>          <td class="paramname"><span class="paramname"><em>fz_model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan the model to replace all int2float to int_eq, and all floating point variables used in these int2float constraint to be integral.</p>
<p>Scan the model to find a floating point objective (defined by a single floating point variable and a single float_lin_eq constraint defining it), and replace them by a single objective with integer variables and floating point weights. </p>
<p>Scan the model, rename int2float to int_eq, change type of the floating point variables to integer.</p>
<p>Scan the model to find the float objective variable and the float objective constraint if defined.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__fz__solver_8cc_source.html#l01355">1355</a> of file <a class="el" href="cp__model__fz__solver_8cc_source.html">cp_model_fz_solver.cc</a>.</p>

</div>
</div>
<a id="a2aa12deefa498c86a88f95cd7d221381" name="a2aa12deefa498c86a88f95cd7d221381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa12deefa498c86a88f95cd7d221381">&#9670;&#160;</a></span>ProdOverflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ProdOverflow </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00104">104</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a2ee7c83ad06fb9a710a64f3ff79b4289" name="a2ee7c83ad06fb9a710a64f3ff79b4289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee7c83ad06fb9a710a64f3ff79b4289">&#9670;&#160;</a></span>ProductConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ProductConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the constraint: a * b = p. </p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00768">768</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a345bada8924ba2bf94e22f85916b23ad" name="a345bada8924ba2bf94e22f85916b23ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345bada8924ba2bf94e22f85916b23ad">&#9670;&#160;</a></span>ProductWithModularInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::ProductWithModularInverse </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we know that X * coeff % mod = rhs % mod, this returns c such that PositiveMod(X, mod) = c.</p>
<p>This requires coeff != 0, mod !=0 and gcd(coeff, mod) == 1. The result will be in [0, mod) but there is no other condition on the sign or magnitude of a and b.</p>
<p>This is overflow safe, and when rhs == 0 or abs(mod) == 1, it returns 0. </p>
<p>Make both in [0, mod).</p>
<p>From X * coeff % mod = rhs We deduce that X % mod = rhs * inverse % mod</p>
<p>We make the operation in 128 bits to be sure not to have any overflow here.</p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00182">182</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="ad8873d5bb4db4affe6faa2da6553882a" name="ad8873d5bb4db4affe6faa2da6553882a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8873d5bb4db4affe6faa2da6553882a">&#9670;&#160;</a></span>PropagateAutomaton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PropagateAutomaton </td>
          <td>(</td>
          <td class="paramtype">const AutomatonConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>states</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills and propagates the set of reachable states/labels. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001619">Todo</a></b></dt><dd>(user): Note that if we have duplicate variables controlling different time point, this might not reach the fixed point. Fix? it is not that important as the expansion take care of this case anyway. </dd></dl>
<p>Forward pass.</p>
<p>Backward pass.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__table_8cc_source.html#l00334">334</a> of file <a class="el" href="cp__model__table_8cc_source.html">cp_model_table.cc</a>.</p>

</div>
</div>
<a id="ad1ebf465eb7ccee4f79a5b8cfccfe7d9" name="ad1ebf465eb7ccee4f79a5b8cfccfe7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ebf465eb7ccee4f79a5b8cfccfe7d9">&#9670;&#160;</a></span>PropagateEncodingFromEquivalenceRelations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PropagateEncodingFromEquivalenceRelations </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process all affine relations of the form a*X + b*Y == cte. For each literals associated to (X &gt;= bound) or (X == value) associate it to its corresponding relation on Y. Also do the other side.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001301">Todo</a></b></dt><dd>(user): In an ideal world, all affine relations like this should be removed in the presolve. </dd></dl>
<p>Loop over all constraints and find affine ones.</p>
<p>Make sure the coefficient are positive.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001292">Todo</a></b></dt><dd>(user): This is not supposed to happen, but apparently it did on once on routing_GCM_0001_sat.fzn. Investigate and fix. </dd></dl>
<p>We first map the &gt;= literals. It is important to do that first, since otherwise mapping a == literal might creates the underlying &gt;= and &lt;= literals.</p>
<p>Same for the == literals.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001293">Todo</a></b></dt><dd>(user): This is similar to LoadEquivalenceAC() for unreified constraints, but when the later is called, more encoding might have taken place. </dd></dl>
<p>Using this function deals properly with UNSAT.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00823">823</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a7bb3adbf30215f4aafac3f24caf00f84" name="a7bb3adbf30215f4aafac3f24caf00f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb3adbf30215f4aafac3f24caf00f84">&#9670;&#160;</a></span>PseudoCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::PseudoCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the branching variable using pseudo costs and combines it with a value for branching. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001868">Todo</a></b></dt><dd>(user): This will be overridden by the value decision heuristic in almost all cases. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00454">454</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="ad4192af14f7971beec13bcd9dc390487" name="ad4192af14f7971beec13bcd9dc390487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4192af14f7971beec13bcd9dc390487">&#9670;&#160;</a></span>PushAndMaybeCombineSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1PushedSolutionPointers.html">PushedSolutionPointers</a> operations_research::sat::PushAndMaybeCombineSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *</td>          <td class="paramname"><span class="paramname"><em>response_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>solution_info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>base_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="combine__solutions_8cc_source.html#l00079">79</a> of file <a class="el" href="combine__solutions_8cc_source.html">combine_solutions.cc</a>.</p>

</div>
</div>
<a id="ab37f2f037c1a414988b378b00ae80dcf" name="ab37f2f037c1a414988b378b00ae80dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37f2f037c1a414988b378b00ae80dcf">&#9670;&#160;</a></span>QuickSolveWithHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::QuickSolveWithHint </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to find a solution by following the hint and using a low conflict limit. The CpModelProto must already be loaded in the <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a>. </p>
<p>Temporarily change the parameters.</p>
<p>If the model was loaded with "optimize_with_core" then the objective variable is not linked to its linear expression. Because of that, we can return a solution that does not satisfy the objective domain.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001571">Todo</a></b></dt><dd>(user): This is fixable, but then do we need the hint when optimizing with core? </dd></dl>
<p>Solve decision problem.</p>
<p>Restrict the objective.</p>
<p>This code is here to debug bad presolve during LNS that corrupt the hint. </p><dl class="section note"><dt>Note</dt><dd>sometime the deterministic limit is hit before the hint can be completed, so we don't report that has an error.</dd></dl>
<p>Tricky: We can only test that if we don't already have a feasible solution like we do if the hint is complete.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01627">1627</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="a568e140395471f0f24820941dd72edaf" name="a568e140395471f0f24820941dd72edaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568e140395471f0f24820941dd72edaf">&#9670;&#160;</a></span>Random3SatProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpModelProto operations_research::sat::Random3SatProblem </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>proportion_of_constraints</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4.26</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a random 3-SAT problem with a number of constraints given by: num_variables * proportions_of_constraints. With the default proportion value, we are around the transition SAT/UNSAT. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__test__utils_8cc_source.html#l00028">28</a> of file <a class="el" href="cp__model__test__utils_8cc_source.html">cp_model_test_utils.cc</a>.</p>

</div>
</div>
<a id="a2421e921ab494e0c666f6d7ed2a7e432" name="a2421e921ab494e0c666f6d7ed2a7e432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2421e921ab494e0c666f6d7ed2a7e432">&#9670;&#160;</a></span>RandomizeDecisionHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RandomizeDecisionHeuristic </td>
          <td>(</td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SatParameters *</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomizes the decision heuristic of the given SatParameters. </p>
<p>Random preferred variable order.</p>
<p>Random polarity initial value.</p>
<p>Other random parameters.</p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00101">101</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="ac2b9ed2c9fd55af7cfd4effe1ad5a5d6" name="ac2b9ed2c9fd55af7cfd4effe1ad5a5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b9ed2c9fd55af7cfd4effe1ad5a5d6">&#9670;&#160;</a></span>RandomizeOnRestartHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::RandomizeOnRestartHeuristic </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lns_mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001881">Todo</a></b></dt><dd>(user): Add other policies and perform more experiments. </dd></dl>
<p>Add sat search + fixed_search (to complete the search).</p>
<p>Adds user defined search if present.</p>
<p>Always add heuristic search.</p>
<p>The higher weight for the sat policy is because this policy actually contains a lot of variation as we randomize the sat parameters. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001882">Todo</a></b></dt><dd>(user): Do more experiments to find better distribution. </dd></dl>
<p>Value selection.</p>
<p>LP Based value.</p>
<p>Solution based value.</p>
<p>Min value.</p>
<p>Special case: Don't change the decision value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001883">Todo</a></b></dt><dd>(user): These distribution values are just guessed values. They need to be tuned. </dd></dl>
<p><a class="el" href="classoperations__research_1_1Set.html">Set</a> some assignment preference. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001884">Todo</a></b></dt><dd>(user): Also use LP value as assignment like in Bop. </dd></dl>
<p>Use Boolean objective as assignment preference.</p>
<p>Because this is a minimization problem, we prefer to assign a Boolean variable to its "low" objective value. So if a literal has a positive weight when true, we want to set it to false.</p>
<p>Select the variable selection heuristic.</p>
<p>Select the value selection heuristic.</p>
<p>Get the current decision.</p>
<p>Special case: Don't override the decision value.</p>
<p>Decode the decision and get the variable.</p>
<p>Try the selected policy.</p>
<p>Selected policy failed. Revert back to original decision.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00973">973</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a93cdb025832191e49e0643dc6ed4a6ed" name="a93cdb025832191e49e0643dc6ed4a6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cdb025832191e49e0643dc6ed4a6ed">&#9670;&#160;</a></span>RandomLinearProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpModelProto operations_research::sat::RandomLinearProblem </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_constraints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a random 0-1 "covering" optimization linear problem:</p><ul>
<li>Each constraint has density ~0.5 and ask for a sum &gt;= num_variables / 10.</li>
<li>The objective is to minimize the number of variables at 1. </li>
</ul>
<p>Sum &gt;= num_variables / 10.</p>
<p>To ensure that the constraint is feasible, we enforce that it has at least the 'minimum' number of terms. This clause should only rarely be used, when num_variables is high.</p>
<p>Objective: minimize variables at one.</p>
<p>Sum of all other variables == 0</p>

<p class="definition">Definition at line <a class="el" href="cp__model__test__utils_8cc_source.html#l00057">57</a> of file <a class="el" href="cp__model__test__utils_8cc_source.html">cp_model_test_utils.cc</a>.</p>

</div>
</div>
<a id="ab1240060466ba48a36a4b36379bce26a" name="ab1240060466ba48a36a4b36379bce26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1240060466ba48a36a4b36379bce26a">&#9670;&#160;</a></span>ReadDomainFromProto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoWithDomain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a> operations_research::sat::ReadDomainFromProto </td>
          <td>(</td>
          <td class="paramtype">const ProtoWithDomain &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> from the domain field of a proto. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00144">144</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a774bb7b95d0309e6e4448b044b88c456" name="a774bb7b95d0309e6e4448b044b88c456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774bb7b95d0309e6e4448b044b88c456">&#9670;&#160;</a></span>RecordLPRelaxationValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RecordLPRelaxationValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the current LP solution to the pool. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002261">Todo</a></b></dt><dd>(user): The default of ::infinity() for variable for which we do not have any LP solution is weird and inconsistent with <a class="el" href="structoperations__research_1_1sat_1_1ModelLpValues.html">ModelLpValues</a> default which is zero. Fix. Note that in practice, at linearization level 2, all variable will eventually have an lp relaxation value, so it shoulnd't matter much to just use zero in RINS/RENS. </dd></dl>
<p>We only loop over the positive variables.</p>

<p class="definition">Definition at line <a class="el" href="rins_8cc_source.html#l00040">40</a> of file <a class="el" href="rins_8cc_source.html">rins.cc</a>.</p>

</div>
</div>
<a id="a611f7231b53b78245f5464fdbc2375a4" name="a611f7231b53b78245f5464fdbc2375a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611f7231b53b78245f5464fdbc2375a4">&#9670;&#160;</a></span>ReduceModuloBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ReduceModuloBasis </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::vector&lt; absl::int128 &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>elements_to_consider</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; absl::int128 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diophantine_8cc_source.html#l00046">46</a> of file <a class="el" href="diophantine_8cc_source.html">diophantine.cc</a>.</p>

</div>
</div>
<a id="a4c7c0126948e1cf811fc9fe8519915e5" name="a4c7c0126948e1cf811fc9fe8519915e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7c0126948e1cf811fc9fe8519915e5">&#9670;&#160;</a></span>ReduceNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ReduceNodes </td>
          <td>(</td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient *</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduces the nodes using the now fixed literals, update the lower-bound, and returns the set of assumptions for the next round of the core-based algorithm. Returns an empty set of assumptions if everything is fixed. </p>
<p>Remove the left-most variables fixed to one from each node. Also update the lower_bound. Note that Reduce() needs the solver to be at the root node in order to work.</p>
<p>Fix the nodes right-most variables that are above the gap. If we closed the problem, we abort and return and empty vector.</p>
<p>Remove the empty nodes.</p>
<p>Sort the nodes.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001742">Todo</a></b></dt><dd>(user): with DEFAULT_ASSUMPTION_ORDER, this will lead to a somewhat weird behavior, since we will reverse the nodes at each iteration... </dd></dl>

<p class="definition">Definition at line <a class="el" href="encoding_8cc_source.html#l00503">503</a> of file <a class="el" href="encoding_8cc_source.html">encoding.cc</a>.</p>

</div>
</div>
<a id="a0d7b47f29a76a183bf462cff8ec583e8" name="a0d7b47f29a76a183bf462cff8ec583e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7b47f29a76a183bf462cff8ec583e8">&#9670;&#160;</a></span>ReduceNumberOfBoxesExactMandatory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ReduceNumberOfBoxesExactMandatory </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>mandatory_rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>optional_rectangles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but this implementation returns the optimal solution in minimizing the number of boxes if <code>optional_rectangles</code> is empty. On the other hand, its handling of optional boxes is rather limited. It simply fills the holes in the mandatory boxes with optional boxes, if possible. </p>
<p>This heuristic can be slow for very large problems, so gate it with a reasonable limit.</p>
<p>Now for every connected component of the holes in the mandatory area, see if we can fill them with optional boxes.</p>
<p>Fill the hole.</p>
<p>We can modify <code>optional_rectangles</code> here since we know that if we remove a hole this function will return true.</p>
<p>This is the function that applies the algorithm described in [1].</p>
<p>It is possible that the algorithm actually increases the number of boxes. See the "Problematic2" test.</p>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l01420">1420</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="aaf29f7195014635a66a11fb41c254022" name="aaf29f7195014635a66a11fb41c254022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf29f7195014635a66a11fb41c254022">&#9670;&#160;</a></span>ReduceNumberofBoxesGreedy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ReduceNumberofBoxesGreedy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>mandatory_rectangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>optional_rectangles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The current implementation just greedly merge rectangles that shares an edge.</p>
<p>bool for is_optional</p>
<p>Merge two rectangles!</p>

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l00343">343</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="a217338425de4389014563f1f24331713" name="a217338425de4389014563f1f24331713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217338425de4389014563f1f24331713">&#9670;&#160;</a></span>RefIsPositive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::RefIsPositive </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00046">46</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a1b3c2a027271b5ffacc61124c8fc0f24" name="a1b3c2a027271b5ffacc61124c8fc0f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3c2a027271b5ffacc61124c8fc0f24">&#9670;&#160;</a></span>RegionIncludesOther()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::RegionIncludesOther </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The two regions must be defined by non-overlapping rectangles. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8h_source.html#l00694">694</a> of file <a class="el" href="diffn__util_8h_source.html">diffn_util.h</a>.</p>

</div>
</div>
<a id="a838ae1c98a62762620ef82e362c4ad8c" name="a838ae1c98a62762620ef82e362c4ad8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838ae1c98a62762620ef82e362c4ad8c">&#9670;&#160;</a></span>RegisterAndTransferOwnership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RegisterAndTransferOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00763">763</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a63074e2e2521d97be10a61595f59d165" name="a63074e2e2521d97be10a61595f59d165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63074e2e2521d97be10a61595f59d165">&#9670;&#160;</a></span>RegisterClausesExport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RegisterClausesExport </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html">SharedClausesManager</a> *</td>          <td class="paramname"><span class="paramname"><em>shared_clauses_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback that will export good clauses discovered during search. </p>
<dl class="section note"><dt>Note</dt><dd>this callback takes no global locks, everything operates on this worker's own clause stream, whose lock is only used by this worker, and briefly when generating a batch in <a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html#a3ebbcf2be803ef7f2cbad87a044dc4ec">SharedClausesManager::Synchronize()</a>.</dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00954">954</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="ae9354f9bc95baa7e65765e065b38fefc" name="ae9354f9bc95baa7e65765e065b38fefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9354f9bc95baa7e65765e065b38fefc">&#9670;&#160;</a></span>RegisterClausesLevelZeroImport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::RegisterClausesLevelZeroImport </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html">SharedClausesManager</a> *</td>          <td class="paramname"><span class="paramname"><em>shared_clauses_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback to import new clauses stored in the shared_clausess_manager. These clauses are imported at level 0 of the search in the linear scan minimize function. it returns the id of the worker in the shared clause manager.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001559">Todo</a></b></dt><dd>(user): Can we import them in the core worker ? </dd></dl>
<p>Registers a callback to import new clauses stored in the shared_clausess_manager. These clauses are imported at level 0 of the search in the linear scan minimize function. it returns the id of the worker in the shared clause manager.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001586">Todo</a></b></dt><dd>(user): Can we import them in the core worker ? </dd></dl>
<p>Temporarily disable clause sharing so we don't immediately re-export the clauses we just imported.</p>
<p>Check this clause was not already learned by this worker. We can delete the fingerprint because we should not learn an identical clause, and the global stream will not emit the same clause while any worker hasn't consumed this clause (and thus also shouldn't relearn the clause).</p>
<p>The new clauses may be subsumed, so try to minimize them to reduce overhead of sharing. We only share up to 1024 literals worth of new clauses per second, so at most 1024 decisions to vivify all new clauses, so this should be relatively cheap.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01006">1006</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="ae41d718cabb8c89ffce625c35e884080" name="ae41d718cabb8c89ffce625c35e884080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41d718cabb8c89ffce625c35e884080">&#9670;&#160;</a></span>RegisterObjectiveBestBoundExport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RegisterObjectiveBestBoundExport </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>objective_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *</td>          <td class="paramname"><span class="paramname"><em>shared_response_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback that will report improving objective best bound. It will be called each time new objective bound are propagated at level zero. </p>
<p>If we are not in interleave_search we synchronize right away.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00870">870</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="a4f656cdcbe318b6a953aff7907fe3d32" name="a4f656cdcbe318b6a953aff7907fe3d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f656cdcbe318b6a953aff7907fe3d32">&#9670;&#160;</a></span>RegisterObjectiveBoundsImport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RegisterObjectiveBoundsImport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html">SharedResponseManager</a> *</td>          <td class="paramname"><span class="paramname"><em>shared_response_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback to import new objective bounds. It will be called each time the search main loop is back to level zero. Note that it the presence of assumptions, this will not happen until the set of assumptions is changed. </p>
<dl class="section note"><dt>Note</dt><dd>we will propagate if they are new bounds separately. See BeforeTakingDecision().</dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00899">899</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="aceadbdc1d18fb949cc787a53e656d65a" name="aceadbdc1d18fb949cc787a53e656d65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceadbdc1d18fb949cc787a53e656d65a">&#9670;&#160;</a></span>RegisterVariableBoundsLevelZeroExport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RegisterVariableBoundsLevelZeroExport </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html">SharedBoundsManager</a> *</td>          <td class="paramname"><span class="paramname"><em>shared_bounds_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback that will export variables bounds fixed at level 0 of the search. This should not be registered to a LNS search. </p>
<p>Inspect the modified IntegerVariables.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001557">Todo</a></b></dt><dd>(user): We could imagine an API based on atomic&lt;int64_t&gt; that could preemptively check if this new bounds are improving. </dd></dl>
<p>Inspect the newly modified Booleans.</p>
<p>Clear for next call.</p>
<p>If we are not in interleave_search we synchronize right away.</p>
<p>The callback will just be called on NEWLY modified var. So initially, we do want to read all variables.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001558">Todo</a></b></dt><dd>(user): Find a better way? It seems nicer to register this before any variable is modified. But then we don't want to call it each time we reach level zero during probing. It should be better to only call it when a new variable has been fixed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00687">687</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="ad591ae16ce115e2dbd3b2501845377c2" name="ad591ae16ce115e2dbd3b2501845377c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad591ae16ce115e2dbd3b2501845377c2">&#9670;&#160;</a></span>RegisterVariableBoundsLevelZeroImport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RegisterVariableBoundsLevelZeroImport </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html">SharedBoundsManager</a> *</td>          <td class="paramname"><span class="paramname"><em>shared_bounds_manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback to import new variables bounds stored in the shared_bounds_manager. These bounds are imported at level 0 of the search in the linear scan minimize function. </p>
<p>If this is a Boolean, fix it if not already done. </p><dl class="section note"><dt>Note</dt><dd>it is important not to use AddUnitClause() as we do not want to propagate after each addition.</dd></dl>
<p>Deal with integer.</p>
<dl class="section note"><dt>Note</dt><dd>we will propagate if they are new bounds separately. See BeforeTakingDecision().</dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l00788">788</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="a536dbee8dfbb862d59d1d213a0c53772" name="a536dbee8dfbb862d59d1d213a0c53772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536dbee8dfbb862d59d1d213a0c53772">&#9670;&#160;</a></span>ReifiedBoolAnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ReifiedBoolAnd </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>r &lt;=&gt; (all literals are true).</p>
<p>Note(user): we could have called <a class="el" href="#ae43cf9354e7156908e6587958694c5b4" title="r &lt;=&gt; (at least one literal is true). This is a reified clause.">ReifiedBoolOr()</a> with everything negated. </p>
<p>All true =&gt; r true.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l01005">1005</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a52e7ea663f64c733766811e8f20a6a13" name="a52e7ea663f64c733766811e8f20a6a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e7ea663f64c733766811e8f20a6a13">&#9670;&#160;</a></span>ReifiedBoolLe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ReifiedBoolLe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>r &lt;=&gt; (a &lt;= b). </p>
<p>r &lt;=&gt; (a &lt;= b) is the same as r &lt;=&gt; not(a=1 and b=0). So r &lt;=&gt; a=0 OR b=1.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l01022">1022</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ae43cf9354e7156908e6587958694c5b4" name="ae43cf9354e7156908e6587958694c5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43cf9354e7156908e6587958694c5b4">&#9670;&#160;</a></span>ReifiedBoolOr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::ReifiedBoolOr </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>r &lt;=&gt; (at least one literal is true). This is a reified clause. </p>
<p>All false =&gt; r false.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00970">970</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a91d56da965ecd3194b8aa8683f8e5e09" name="a91d56da965ecd3194b8aa8683f8e5e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d56da965ecd3194b8aa8683f8e5e09">&#9670;&#160;</a></span>ReindexArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntContainer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::ReindexArcs </td>
          <td>(</td>
          <td class="paramtype">IntContainer *</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntContainer *</td>          <td class="paramname"><span class="paramname"><em>heads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_map&lt; int, int &gt; *</td>          <td class="paramname"><span class="paramname"><em>mapping_output</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the node indices so that we get a graph in [0, num_nodes) where every node has at least one incoming or outgoing arc. Returns the number of nodes. </p>
<p>Put all nodes in a set.</p>
<p>Compute the new indices while keeping a stable order.</p>
<p>Remap the arcs.</p>

<p class="definition">Definition at line <a class="el" href="circuit_8h_source.html#l00208">208</a> of file <a class="el" href="circuit_8h_source.html">circuit.h</a>.</p>

</div>
</div>
<a id="a88c65bcf51a7c679ad0159e09ecfb3fc" name="a88c65bcf51a7c679ad0159e09ecfb3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c65bcf51a7c679ad0159e09ecfb3fc">&#9670;&#160;</a></span>RemapGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a> &gt; util::RemapGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceoperations__research.html#acf9cb12e488ad2ace33c313f2f2cc220">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>new_node_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a remapped copy of graph "graph", where node i becomes node new_node_index[i]. "new_node_index" must be a valid permutation of [0..num_nodes-1] or the behavior is undefined (it may die). </p><dl class="section note"><dt>Note</dt><dd>you can call IsValidPermutation() to check it yourself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00279">279</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a7d8d6bd2036aaa59c3719954e5262c5a" name="a7d8d6bd2036aaa59c3719954e5262c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8d6bd2036aaa59c3719954e5262c5a">&#9670;&#160;</a></span>RemoveNearZeroTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RemoveNearZeroTerms </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPModelProto *</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To satisfy our scaling requirements, any terms that is almost zero can just be set to zero. We need to do that before operations like <a class="el" href="#a753e3aea07903c667891eb57036d26de">DetectImpliedIntegers()</a>, because really low coefficients can cause issues and might lead to less detection. </p>
<p>Having really low bounds or rhs can be problematic. We set them to zero.</p>
<p>Compute for each variable its current maximum magnitude. Note that we will only scale variable with a coefficient &gt;= 1, so it is safe to use this bound.</p>
<dl class="section note"><dt>Note</dt><dd>when a variable is fixed to zero, the code here remove all its coefficients. But we do not count them here.</dd></dl>
<p>We want the maximum absolute error while setting coefficients to zero to not exceed our mip wanted precision. So for a binary variable we might set to zero coefficient around 1e-7. But for large domain, we need lower coeff than that, around 1e-12 with the default params.mip_max_bound(). This also depends on the size of the constraint.</p>
<p>We also do the same for the objective coefficient.</p>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00308">308</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a1926dfe1e50b0db22cd629022d4be102" name="a1926dfe1e50b0db22cd629022d4be102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1926dfe1e50b0db22cd629022d4be102">&#9670;&#160;</a></span>RemoveVariablesFromInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RemoveVariablesFromInterval </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Bitset64.html">Bitset64</a>&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00112">112</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a3a88781ba518fe1373e2bbe36aeb8132" name="a3a88781ba518fe1373e2bbe36aeb8132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a88781ba518fe1373e2bbe36aeb8132">&#9670;&#160;</a></span>RemoveZeroTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RemoveZeroTerms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> *</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the entries with a coefficient of zero. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00288">288</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="afcd788eac051abcdab1ccdf96fb223e5" name="afcd788eac051abcdab1ccdf96fb223e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd788eac051abcdab1ccdf96fb223e5">&#9670;&#160;</a></span>RenderDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::RenderDot </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>extra_dot_payload</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Render a packing solution as a Graphviz dot file. Only works in the "neato" or "fdp" Graphviz backends. </p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l01573">1573</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="ab3a1dd9bf60ce8490922e3f1148524e8" name="ab3a1dd9bf60ce8490922e3f1148524e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a1dd9bf60ce8490922e3f1148524e8">&#9670;&#160;</a></span>RepeatParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; SatParameters &gt; operations_research::sat::RepeatParameters </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const SatParameters &gt;</td>          <td class="paramname"><span class="paramname"><em>base_params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_params_to_generate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a base set of parameter, if non-empty, this repeat them (round-robbin) until we get num_params_to_generate. Note that if we don't have a multiple, the first base parameters will be repeated more than the others.</p>
<dl class="section note"><dt>Note</dt><dd>this will also change the random_seed of each of these parameters. </dd></dl>
<p>Return if we are done.</p>
<p>Repeat parameters until we have enough.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__search_8cc_source.html#l01068">1068</a> of file <a class="el" href="cp__model__search_8cc_source.html">cp_model_search.cc</a>.</p>

</div>
</div>
<a id="a89dc2fa5d4896cd17270cf7d40099e08" name="a89dc2fa5d4896cd17270cf7d40099e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dc2fa5d4896cd17270cf7d40099e08">&#9670;&#160;</a></span>ReportEnergyConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ReportEnergyConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1Rectangle.html">Rectangle</a></td>          <td class="paramname"><span class="paramname"><em>bounding_box</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>boxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html">SchedulingConstraintHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that there is indeed a conflict for the given bounding_box and report it. This returns false for convenience as we usually want to return false on a conflict.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001710">Todo</a></b></dt><dd>(user): relax the bounding box dimension to have a relaxed explanation. We can also minimize the number of required intervals. </dd></dl>
<p>We abort early if a subset of boxes is enough. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001706">Todo</a></b></dt><dd>(user): Also relax the box if possible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00139">139</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="ade6ce3f7172b49fd16513489bdb4ca32" name="ade6ce3f7172b49fd16513489bdb4ca32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6ce3f7172b49fd16513489bdb4ca32">&#9670;&#160;</a></span>ResetAndSolveIntegerProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::ResetAndSolveIntegerProblem </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assumptions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the solver to the given assumptions before calling SolveIntegerProblem(). </p>
<p>Backtrack to level zero.</p>
<p>Sync bounds and maybe do some inprocessing. We reuse the BeforeTakingDecision() code</p>
<p>Add the assumptions if any and solve.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l01599">1599</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a3518eef034832dda8fbc0df67737c35b" name="a3518eef034832dda8fbc0df67737c35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3518eef034832dda8fbc0df67737c35b">&#9670;&#160;</a></span>Resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::Resolve </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>clause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>other_clause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>complementary_literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> *</td>          <td class="paramname"><span class="paramname"><em>assignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>resolvent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if 'complementary_literal' is the unique complementary literal in the two given clauses. If so the resolvent of these clauses (i.e. their union with 'complementary_literal' and its negation removed) is set in 'resolvent'. 'clause' must contain 'complementary_literal', while 'other_clause' must contain its negation. 'assignment' must have at least as many variables as each clause, and they must all be unassigned. They are still unassigned upon return. </p>
<p>Temporary assignment used to do the checks below in linear time.</p>
<p>Revert the temporary assignment done above.</p>

<p class="definition">Definition at line <a class="el" href="drat__checker_8cc_source.html#l00478">478</a> of file <a class="el" href="drat__checker_8cc_source.html">drat_checker.cc</a>.</p>

</div>
</div>
<a id="ab2ed30948924c0d2d512eec06d24353f" name="ab2ed30948924c0d2d512eec06d24353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ed30948924c0d2d512eec06d24353f">&#9670;&#160;</a></span>RestartEveryKFailures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; bool()&gt; operations_research::sat::RestartEveryKFailures </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A restart policy that restarts every k failures. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l01178">1178</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="aed01516ad5ceb238e62df4fdebfb054e" name="aed01516ad5ceb238e62df4fdebfb054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed01516ad5ceb238e62df4fdebfb054e">&#9670;&#160;</a></span>RestrictObjectiveDomainWithBinarySearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::RestrictObjectiveDomainWithBinarySearch </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>objective_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>feasible_solution_observer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use a low conflict limit and performs a binary search to try to restrict the domain of objective_var. </p>
<p><a class="el" href="classoperations__research_1_1Set.html">Set</a> the requested conflict limit.</p>
<p>The assumption (objective &lt;= value) for values in [unknown_min, unknown_max] reached the conflict limit.</p>
<p>We first refine the lower bound and then the upper bound.</p>
<p>Update the objective lower bound.</p>
<p>The objective is the current lower bound of the objective_var.</p>
<p>We have a solution, restrict the objective upper bound to only look for better ones now.</p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00246">246</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="a491a3e74f9172260076d4dfae8a4f4af" name="a491a3e74f9172260076d4dfae8a4f4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491a3e74f9172260076d4dfae8a4f4af">&#9670;&#160;</a></span>SafeAddLinearExpressionToLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SafeAddLinearExpressionToLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coefficient</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>linear</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same method, but returns if the addition was possible without overflowing. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00660">660</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a8687ebf06d20e5b9fb4e461fc6f949a6" name="a8687ebf06d20e5b9fb4e461fc6f949a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8687ebf06d20e5b9fb4e461fc6f949a6">&#9670;&#160;</a></span>SafeDoubleToInt64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SafeDoubleToInt64 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a double to int64_t and cap large magnitudes at kint64min/max. We also arbitrarily returns 0 for NaNs.</p>
<p>Note(user): This is similar to SaturatingFloatToInt(), but we use our own since we need to open source it and the code is simple enough.</p>
<p>Implementation. </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8h_source.html#l00728">728</a> of file <a class="el" href="sat_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="aaddc23780eb0fa31082a04cc6e345d31" name="aaddc23780eb0fa31082a04cc6e345d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddc23780eb0fa31082a04cc6e345d31">&#9670;&#160;</a></span>SatSolverHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::SatSolverHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a> advised by the underlying SAT solver. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00415">415</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="ae838746224cfa12487aab4a0d10aa3ce" name="ae838746224cfa12487aab4a0d10aa3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae838746224cfa12487aab4a0d10aa3ce">&#9670;&#160;</a></span>SatSolverRestartPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; bool()&gt; operations_research::sat::SatSolverRestartPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A restart policy that uses the underlying sat solver's policy. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l01192">1192</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a215d34ee33b3afef47b10eef03beb7e1" name="a215d34ee33b3afef47b10eef03beb7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215d34ee33b3afef47b10eef03beb7e1">&#9670;&#160;</a></span>SatStatusString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::SatStatusString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>. </p>
<p>Fallback. We don't use "default:" so the compiler will return an error if we forgot one enum case above.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l02813">2813</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="afb476403c2ecaebf0c38e03a0e770c40" name="afb476403c2ecaebf0c38e03a0e770c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb476403c2ecaebf0c38e03a0e770c40">&#9670;&#160;</a></span>ScalarProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::ScalarProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the scalar product of given constraint coefficients. This method assumes that the constraint variables are in sorted order. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00227">227</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a628fdf755d7e7ca380fce027615b10dc" name="a628fdf755d7e7ca380fce027615b10dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628fdf755d7e7ca380fce027615b10dc">&#9670;&#160;</a></span>ScaleAndSetObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ScaleAndSetObjective </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; int, double &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>objective</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>objective_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>maximize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>cp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scales a double objective to its integer version and fills it in the proto. The variable listed in the objective must be already defined in the cp_model proto as this uses the variables bounds to compute a proper scaling.</p>
<p>This uses params.mip_wanted_tolerance() and params.mip_max_activity_exponent() to compute the scaling. Note however that if the wanted tolerance is not satisfied this still scale with best effort. You can see in the log the tolerance guaranteed by this automatic scaling.</p>
<p>This will almost always returns true except for really bad cases like having infinity in the objective. </p>
<p>Make sure the objective is currently empty.</p>
<p>We filter constant terms and compute some needed quantities.</p>
<p>These are the parameters used for scaling the objective.</p>
<p>Display the objective error/scaling.</p>
<dl class="section note"><dt>Note</dt><dd>here we set the scaling factor for the inverse operation of getting the "true" objective value from the scaled one. Hence the inverse.</dd></dl>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l01354">1354</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="ad6d384c7c56f3027894875278e4b9526" name="ad6d384c7c56f3027894875278e4b9526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d384c7c56f3027894875278e4b9526">&#9670;&#160;</a></span>ScaleContinuousVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; operations_research::sat::ScaleContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scaling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPModelProto *</td>          <td class="paramname"><span class="paramname"><em>mp_model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies all continuous variable by the given scaling parameters and change the rest of the model accordingly. The returned vector contains the scaling of each variable (will always be 1.0 for integers) and can be used to recover a solution of the unscaled problem from one of the new scaled problems by dividing the variable values.</p>
<p>We usually scale a continuous variable by scaling, but if its domain is going to have larger values than max_bound, then we scale to have the max domain magnitude equal to max_bound.</p>
<dl class="section note"><dt>Note</dt><dd>it is recommended to call <a class="el" href="#a753e3aea07903c667891eb57036d26de">DetectImpliedIntegers()</a> before this function so that we do not scale variables that do not need to be scaled.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002077">Todo</a></b></dt><dd>(user): Also scale the solution hint if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat_2lp__utils_8cc_source.html#l00110">110</a> of file <a class="el" href="sat_2lp__utils_8cc_source.html">lp_utils.cc</a>.</p>

</div>
</div>
<a id="a5efa47c328d4e70fd3337a8e70c947b0" name="a5efa47c328d4e70fd3337a8e70c947b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efa47c328d4e70fd3337a8e70c947b0">&#9670;&#160;</a></span>ScaleFloatingPointObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::ScaleFloatingPointObjective </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a floating point objective is present, scale it using the current domains and transform it to an integer_objective. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01002">1002</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ad0d99a59590707fcc7bbd11e1ca5804f" name="ad0d99a59590707fcc7bbd11e1ca5804f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d99a59590707fcc7bbd11e1ca5804f">&#9670;&#160;</a></span>ScaleInnerObjectiveValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::ScaleInnerObjectiveValue </td>
          <td>(</td>
          <td class="paramtype">const CpObjectiveProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="#a6c7910e5ccb41edc8f442a682890cb31" title="Scales back a objective value to a double value from the original model.">ScaleObjectiveValue()</a> but uses the integer version. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00183">183</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a6c7910e5ccb41edc8f442a682890cb31" name="a6c7910e5ccb41edc8f442a682890cb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7910e5ccb41edc8f442a682890cb31">&#9670;&#160;</a></span>ScaleObjectiveValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::ScaleObjectiveValue </td>
          <td>(</td>
          <td class="paramtype">const CpObjectiveProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales back a objective value to a double value from the original model. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00170">170</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="ab5275984bb2d64275b69e881316b7f34" name="ab5275984bb2d64275b69e881316b7f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5275984bb2d64275b69e881316b7f34">&#9670;&#160;</a></span>ScanModelForDominanceDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ScanModelForDominanceDetection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">VarDomination</a> *</td>          <td class="paramname"><span class="paramname"><em>var_domination</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects the variable dominance relations within the given model. Note that to avoid doing too much work, we might miss some relations. </p>
<p>Ignore variables that have been substituted already or are unused.</p>
<p>Deal with the affine relations that are not part of the proto. Those only need to be processed in the first pass.</p>
<p>First scan: update the partition.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002517">Todo</a></b></dt><dd>(user): Maybe we should avoid recomputing that here. </dd></dl>
<p>We cannot infer anything if we don't know the constraint. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002518">Todo</a></b></dt><dd>(user): Handle enforcement better here. </dd></dl>
<p>The objective is handled like a &lt;= constraints, or an == constraint if there is a non-trivial domain.</p>
<p>Important: We need to write the objective first to make sure it is up to date.</p>
<p>do nothing for now.</p>
<p>Now do two more scan.</p><ul>
<li>the phase_ = 0 initialize candidate list, then EndFirstPhase()</li>
<li>the phase_ = 1 filter them, then EndSecondPhase();</li>
</ul>
<p>We process it like n clauses.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002519">Todo</a></b></dt><dd>(user): the way we process that is a bit restrictive. By working on the implication graph we could detect more dominance relations. Since if a =&gt; b we say that a++ can only be paired with b&ndash;, but it could actually be paired with any variables that when dereased implies b = 0. This is a bit mitigated by the fact that we regroup when we can such implications into big at most ones. </dd></dl>
<p>The objective is handled like a &lt;= constraints, or an == constraint if there is a non-trivial domain.</p>
<p>Early abort if no possible relations can be found.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002520">Todo</a></b></dt><dd>(user): We might be able to detect that nothing can be done earlier during the constraint scanning. </dd></dl>
<p>Some statistics.</p>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l01176">1176</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<a id="a7b440ecab00a601d5643f21df87c7cc6" name="a7b440ecab00a601d5643f21df87c7cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b440ecab00a601d5643f21df87c7cc6">&#9670;&#160;</a></span>ScanModelForDualBoundStrengthening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ScanModelForDualBoundStrengthening </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html">DualBoundStrengthening</a> *</td>          <td class="paramname"><span class="paramname"><em>dual_bound_strengthening</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan the model so that dual_bound_strengthening.Strenghten() works. </p>
<p>Ignore variables that have been substituted already or are unused.</p>
<p>Deal with the affine relations that are not part of the proto. Those only need to be processed in the first pass.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002521">Todo</a></b></dt><dd>(user): Maybe we should avoid recomputing that here. </dd></dl>
<p>We cannot infer anything if we don't know the constraint. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002522">Todo</a></b></dt><dd>(user): Handle enforcement better here. </dd></dl>
<p>The objective is handled like a &lt;= constraints, or an == constraint if there is a non-trivial domain.</p>
<dl class="section warning"><dt>Warning</dt><dd>The proto objective might not be up to date, so we need to write it first.</dd></dl>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l01382">1382</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<a id="a85b41013bb2f7709a99765d5c491f381" name="a85b41013bb2f7709a99765d5c491f381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b41013bb2f7709a99765d5c491f381">&#9670;&#160;</a></span>SchedulingSearchHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::SchedulingSearchHeuristic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple heuristic for scheduling models. </p>
<p>Simple scheduling heuristic that looks at all the no-overlap constraints and try to assign and perform the intervals that can be scheduled first. </p>
<p>To avoid to scan already fixed intervals, we use a simple reversible int.</p>
<p>Note(user): only the model is captured for no reason.</p>
<p><a class="el" href="structVariable.html">Variable</a> to fix.</p>
<p>Information to select best.</p>
<p>We want to pack interval to the left. If two have the same start_min, we want to choose the one that will likely leave an easier problem for the other tasks.</p>
<p>Generating random noise can take time, so we use this function to delay it.</p>
<p>Save rev_fixed before we modify it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001869">Todo</a></b></dt><dd>(user): we should also precompute fixed precedences and only fix interval that have all their predecessors fixed. </dd></dl>
<p>For task whose presence is still unknown, our propagators should have propagated the minimum time as if it was present. So this should reflect the earliest time at which this interval can be scheduled.</p>
<p>Finish filling candidate.</p>
<p>For variable size, we compute the min size once the start is fixed to time. This is needed to never pick the "artificial" makespan interval at the end in priority compared to intervals that still need to be scheduled.</p>
<p>Do not replace if we have a strict inequality now.</p>
<p>Setup rev_is_in_dive to be true on the next call only if there was no backtrack since the previous call.</p>
<p>Use the next_decision_override to fix in turn all the variables from the selected interval.</p>
<p>We have been trying to fix this interval for a while. Do we miss some propagation? In any case, try to see if the heuristic above would select something else.</p>
<p>First make sure the interval is present.</p>
<p>We assume that start_min is propagated by now.</p>
<p>We assume that end_min is propagated by now.</p>
<p>Everything is fixed, detach the override.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00476">476</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="ab771e6d4ef64d782505e2abdc6c0dbe3" name="ab771e6d4ef64d782505e2abdc6c0dbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab771e6d4ef64d782505e2abdc6c0dbe3">&#9670;&#160;</a></span>SeparateFlowInequalities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SeparateFlowInequalities </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>tails</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>heads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_capacities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt;</td>          <td class="paramname"><span class="paramname"><em>get_flows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lp_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is really similar to SeparateSubtourInequalities, see the reference there. </p>
<p>We will collect only the arcs with a positive lp capacity value to speed up some computation below.</p>
<p>Often capacities have a coeff &gt; 1. We currently exploit this if all coeff have a gcd &gt; 1.</p>
<p>Sort the arcs by non-increasing lp_values.</p>
<p>Process each subsets and add any violated cut.</p>
<p>Initialize "in_subset" and the subset demands.</p>
<p>We will sum the offset of all incoming/outgoing arc capacities. </p><dl class="section note"><dt>Note</dt><dd>all arcs with a non-zero offset are part of relevant_arcs.</dd></dl>
<p>Compute the current flow in and out of the subset.</p>
<p>This can take a significant portion of the running time, it is why it is faster to do it only on arcs with non-zero lp values which should be in linear number rather than the total number of arc which can be quadratic.</p>
<p>If the gcd is greater than one, because all variables are integer we can round the flow lower bound to the next multiple of the gcd.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002266">Todo</a></b></dt><dd>(user): Alternatively, try MIR heuristics if the coefficients in the capacities are not all the same. </dd></dl>
<p>Sparse clean up.</p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01356">1356</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="af306b332a6cfbebe5858dcdedfdfb132" name="af306b332a6cfbebe5858dcdedfdfb132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af306b332a6cfbebe5858dcdedfdfb132">&#9670;&#160;</a></span>SeparateSubtourInequalities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SeparateSubtourInequalities </td>
          <td>(</td>
          <td class="paramtype">OutgoingCutHelper &amp;</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html">LinearConstraintManager</a> *</td>          <td class="paramname"><span class="paramname"><em>manager</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We roughly follow the algorithm described in section 6 of "The Traveling
Salesman Problem, A computational Study", David L. Applegate, Robert E. Bixby, Vasek Chvatal, William J. Cook.</p>
<dl class="section note"><dt>Note</dt><dd>this is mainly a "symmetric" case algo, but it does still work for the asymmetric case. </dd></dl>
<p>Add the depot so that we have a trivial bound on the number of vehicle.</p>
<p>Hack/optim: we exploit the tree structure of the subsets to not add a cut for a larger subset if we added a cut from one included in it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002264">Todo</a></b></dt><dd>(user): Currently if we add too many not so relevant cuts, our generic MIP cut heuritic are way too slow on TSP/VRP problems. </dd></dl>
<p>Process each subsets and add any violated cut.</p>
<p>If there were no cut added by the heuristic above, we try exact separation.</p>
<p>With n-1 max_flow from a source to all destination, we can get the global min-cut. Here, we use a slightly more advanced algorithm that will find a min-cut for all possible pair of nodes. This is achieved by computing a Gomory-Hu tree, still with n-1 max flow call.</p>
<p>Note(user): Compared to any min-cut, these cut have some nice properties since they are "included" in each other. This might help with combining them within our generic IP cuts framework.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002265">Todo</a></b></dt><dd>(user): I had an older version that tried the n-cuts generated during the course of the algorithm. This could also be interesting. But it is hard to tell with our current benchmark setup. </dd></dl>
<p>Try all interesting subset from the Gomory-Hu tree.</p>
<p>Exact separation of symmetric Blossom cut. We use the algorithm in the paper: "A Faster Exact Separation Algorithm for Blossom Inequalities", Adam N. Letchford, Gerhard Reinelt, Dirk Oliver Theis, 2004.</p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01195">1195</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="ae4f7fad019ed1def27f3b582c050b3a6" name="ae4f7fad019ed1def27f3b582c050b3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f7fad019ed1def27f3b582c050b3a6">&#9670;&#160;</a></span>SequentialLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SequentialLoop </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subsolvers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but specialized implementation for the case num_threads=1. This avoids using a Threadpool altogether. It should have the same behavior than the functions above with num_threads=1 and batch_size=1. Note that an higher batch size will not behave in the same way, even if num_threads=1. </p>

<p class="definition">Definition at line <a class="el" href="subsolver_8cc_source.html#l00095">95</a> of file <a class="el" href="subsolver_8cc_source.html">subsolver.cc</a>.</p>

</div>
</div>
<a id="af804e16573254d0396f897b201736f6a" name="af804e16573254d0396f897b201736f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af804e16573254d0396f897b201736f6a">&#9670;&#160;</a></span>SequentialSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::SequentialSearch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>heuristics</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combines search heuristics in order: if the i-th one returns kNoLiteralIndex, ask the (i+1)-th. If every heuristic returned kNoLiteralIndex, returns kNoLiteralIndex. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00296">296</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a4accab74442b986ddcc870636b232756" name="a4accab74442b986ddcc870636b232756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4accab74442b986ddcc870636b232756">&#9670;&#160;</a></span>SequentialValueSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::SequentialValueSelection </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>(IntegerVariable)&gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>value_selection_heuristics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>var_selection_heuristic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the value of the given decision by 'var_selection_heuristic'. We try to see if the decision is "associated" with an IntegerVariable, and if it is the case, we choose the new value by the first 'value_selection_heuristics' that is applicable. If none of the heuristics are applicable then the given decision by 'var_selection_heuristic' is returned. </p>
<p>Get the current decision.</p>
<p>When we are in the "stable" phase, we prefer to follow the SAT polarity heuristic.</p>
<p><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> case.</p>
<p>Boolean case. We try to decode the Boolean decision to see if it is associated with an integer variable.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001865">Todo</a></b></dt><dd>(user): we will likely stop at the first non-fixed variable. </dd></dl>
<p>Sequentially try the value selection heuristics.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00307">307</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a73e2ec8896aa53a5c58f86dfd68e6f19" name="a73e2ec8896aa53a5c58f86dfd68e6f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e2ec8896aa53a5c58f86dfd68e6f19">&#9670;&#160;</a></span>SetEnforcementLiteralToFalse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SetEnforcementLiteralToFalse </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>domains</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For now we set the first unset enforcement literal to false. There must be one. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__postsolve_8cc_source.html#l00094">94</a> of file <a class="el" href="cp__model__postsolve_8cc_source.html">cp_model_postsolve.cc</a>.</p>

</div>
</div>
<a id="a02df75a9e906f53495a7f7f56c782361" name="a02df75a9e906f53495a7f7f56c782361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02df75a9e906f53495a7f7f56c782361">&#9670;&#160;</a></span>SetToNegatedLinearExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SetToNegatedLinearExpression </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>input_expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearExpressionProto *</td>          <td class="paramname"><span class="paramname"><em>output_negated_expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the target as negated ref. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00071">71</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="ab4fb16cf2994009c7ab17facafbb2760" name="ab4fb16cf2994009c7ab17facafbb2760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fb16cf2994009c7ab17facafbb2760">&#9670;&#160;</a></span>SetupTextFormatPrinter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SetupTextFormatPrinter </td>
          <td>(</td>
          <td class="paramtype">google::protobuf::TextFormat::Printer *</td>          <td class="paramname"><span class="paramname"><em>printer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We register a few custom printers to display variables and linear expression on one line. This is especially nice for variables where it is easy to recover their indices from the line number now.</p>
<p>ex:</p>
<p>variables { domain: [0, 1] } variables { domain: [0, 1] } variables { domain: [0, 1] }</p>
<p>constraints { linear { vars: [0, 1, 2] coeffs: [2, 4, 5 ] domain: [11, 11] } } </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00947">947</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a4bfc95b7fb811709c6763963bee970a4" name="a4bfc95b7fb811709c6763963bee970a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfc95b7fb811709c6763963bee970a4">&#9670;&#160;</a></span>ShaveObjectiveLb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::ShaveObjectiveLb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001867">Todo</a></b></dt><dd>(user): Do we need a mechanism to reduce the range of possible gaps when nothing gets proven? This could be a parameter or some adaptative code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00430">430</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a0479a7ca6dd22cbabccdf623aea07315" name="a0479a7ca6dd22cbabccdf623aea07315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0479a7ca6dd22cbabccdf623aea07315">&#9670;&#160;</a></span>SimplifyCanonicalBooleanLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SimplifyCanonicalBooleanLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002128">Todo</a></b></dt><dd>(user): Use more complex simplification like dividing by the gcd of everyone and using less different coefficients if possible. </dd></dl>
<p>Given a Boolean linear constraint in canonical form, simplify its coefficients using simple heuristics. </p>
<p>Replace all coefficient &gt;= rhs by rhs + 1 (these literal must actually be false). Note that the linear sum of literals remains canonical.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002129">Todo</a></b></dt><dd>(user): It is probably better to remove these literals and have other constraint setting them to false from the symmetry finder perspective. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pb__constraint_8cc_source.html#l00162">162</a> of file <a class="el" href="pb__constraint_8cc_source.html">pb_constraint.cc</a>.</p>

</div>
</div>
<a id="ab649ca11fd81e049dc7a8c0dd1104b5b" name="ab649ca11fd81e049dc7a8c0dd1104b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab649ca11fd81e049dc7a8c0dd1104b5b">&#9670;&#160;</a></span>SimplifyClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SimplifyClause </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LiteralIndex *</td>          <td class="paramname"><span class="paramname"><em>opposite_literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>num_inspected_literals</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visible for testing. Returns true iff:</p><ul>
<li>a subsume b (subsumption): the clause a is a subset of b, in which case opposite_literal is set to -1.</li>
<li>b is strengthened by self-subsumption using a (self-subsuming resolution): the clause a with one of its literal negated is a subset of b, in which case opposite_literal is set to this negated literal index. Moreover, this opposite_literal is then removed from b.</li>
</ul>
<p>If num_inspected_literals_ is not nullptr, the "complexity" of this function will be added to it in order to track the amount of work done.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002445">Todo</a></b></dt><dd>(user): when a.size() &lt;&lt; b.size(), we should use binary search instead of scanning b linearly. </dd></dl>
<p>Because we abort early when size_diff becomes negative, the second test in the while loop is not needed.</p>
<p>A literal of b is not in a, we can abort early by comparing the sizes left.</p>

<p class="definition">Definition at line <a class="el" href="simplification_8cc_source.html#l00941">941</a> of file <a class="el" href="simplification_8cc_source.html">simplification.cc</a>.</p>

</div>
</div>
<a id="ad6111749765bdc417d6faab8b21bebe1" name="ad6111749765bdc417d6faab8b21bebe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6111749765bdc417d6faab8b21bebe1">&#9670;&#160;</a></span>Smallest1DIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::Smallest1DIntersection </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>range_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>range_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>interval_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>interval_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1D counterpart of <a class="el" href="structoperations__research_1_1sat_1_1RectangleInRange.html#a78205f42a0969603f47ea8a34ebcb464">RectangleInRange::GetMinimumIntersectionArea</a>. Finds the minimum possible overlap of a interval of size <code>size</code> that fits in [range_min, range_max] and a second interval [interval_min, interval_max]. </p>
<p>If the item is on the left of the range, we get the intersection between [range_min, range_min + size] and [interval_min, interval_max].</p>
<p>If the item is on the right of the range, we get the intersection between [range_max - size, range_max] and [interval_min, interval_max].</p>

<p class="definition">Definition at line <a class="el" href="diffn__util_8cc_source.html#l00789">789</a> of file <a class="el" href="diffn__util_8cc_source.html">diffn_util.cc</a>.</p>

</div>
</div>
<a id="afa415e372a9d64eede869ed98666c29c" name="afa415e372a9d64eede869ed98666c29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa415e372a9d64eede869ed98666c29c">&#9670;&#160;</a></span>SolutionBooleanValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SolutionBooleanValue </td>
          <td>(</td>
          <td class="paramtype">const CpSolverResponse &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1BoolVar.html">BoolVar</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the value of a Boolean literal in a solver response. </p>

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l01490">1490</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="ab6fe86bc876c281163a053a9581346c3" name="ab6fe86bc876c281163a053a9581346c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fe86bc876c281163a053a9581346c3">&#9670;&#160;</a></span>SolutionIntegerValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SolutionIntegerValue </td>
          <td>(</td>
          <td class="paramtype">const CpSolverResponse &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1LinearExpr.html">LinearExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the value of an linear expression in a solver response. </p>

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l01479">1479</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="a336d2faa10d80d646232f5e6d91891d4" name="a336d2faa10d80d646232f5e6d91891d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336d2faa10d80d646232f5e6d91891d4">&#9670;&#160;</a></span>SolutionIsFeasible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SolutionIsFeasible </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>variable_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>mapping_proto</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>postsolve_mapping</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies that the given variable assignment is a feasible solution of the given model. The values vector should be in one to one correspondence with the model.variables() list of variables.</p>
<p>The last two arguments are optional and help debugging a failing constraint due to presolve. </p>
<p>Check that all values fall in the variable domains.</p>
<p>Display a message to help debugging.</p>
<p>Check that the objective is within its domain.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001201">Todo</a></b></dt><dd>(user): This is not really a "feasibility" question, but we should probably check that the response objective matches with the one we can compute here. This might better be done in another function though. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__checker_8cc_source.html#l01864">1864</a> of file <a class="el" href="cp__model__checker_8cc_source.html">cp_model_checker.cc</a>.</p>

</div>
</div>
<a id="a09d851f944ab4f305c3d9f8df99b7bf8" name="a09d851f944ab4f305c3d9f8df99b7bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d851f944ab4f305c3d9f8df99b7bf8">&#9670;&#160;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpSolverResponse operations_research::sat::Solve </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the given CpModelProto and returns an instance of CpSolverResponse. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02920">2920</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="acf0df7f3393a26a60e4a6816a21ea5c3" name="acf0df7f3393a26a60e4a6816a21ea5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0df7f3393a26a60e4a6816a21ea5c3">&#9670;&#160;</a></span>SolveCpDestroyAtomicBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SolveCpDestroyAtomicBool </td>
          <td>(</td>
          <td class="paramtype">void *const</td>          <td class="paramname"><span class="paramname"><em>atomic_bool</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__solver__c_8cc_source.html#l00053">53</a> of file <a class="el" href="cp__solver__c_8cc_source.html">cp_solver_c.cc</a>.</p>

</div>
</div>
<a id="a1a4a6a05ee3d12f1391ed11f529907ff" name="a1a4a6a05ee3d12f1391ed11f529907ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4a6a05ee3d12f1391ed11f529907ff">&#9670;&#160;</a></span>SolveCpInterruptible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SolveCpInterruptible </td>
          <td>(</td>
          <td class="paramtype">void *const</td>          <td class="paramname"><span class="paramname"><em>limit_reached</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>creq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>creq_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>cparams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cparams_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>cres</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>cres_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__solver__c_8cc_source.html#l00061">61</a> of file <a class="el" href="cp__solver__c_8cc_source.html">cp_solver_c.cc</a>.</p>

</div>
</div>
<a id="a9d67b9c66f1cb9c1dcc3415cd5af11bf" name="a9d67b9c66f1cb9c1dcc3415cd5af11bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d67b9c66f1cb9c1dcc3415cd5af11bf">&#9670;&#160;</a></span>SolveCpModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpSolverResponse operations_research::sat::SolveCpModel </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the given CpModelProto.</p>
<p>This advanced API accept a Model* which allows to access more advanced features by configuring some classes in the <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> before solve.</p>
<p>For instance:</p><ul>
<li>model-&gt;Add(NewSatParameters(parameters_as_string_or_proto));</li>
<li>model-&gt;GetOrCreate&lt;TimeLimit&gt;()-&gt;RegisterExternalBooleanAsLimit(&amp;stop);</li>
<li>model-&gt;Add(NewFeasibleSolutionObserver(observer)); </li>
</ul>
<p>Dump initial model?</p>
<p>Override parameters?</p>
<p>Enable the logging component.</p>
<dl class="section note"><dt>Note</dt><dd>the postprocessors are executed in reverse order, so this will always dump the response just before it is returned since it is the first one we register.</dd></dl>
<p>Always display the final response stats if requested. This also copy the logs to the response if requested.</p>
<p>Always add the timing information to a response. Note that it is important to add this after the log/dump postprocessor since we execute them in reverse order.</p>
<p>Validate parameters.</p>
<dl class="section note"><dt>Note</dt><dd>the few parameters we use before that are Booleans and thus "safe". We need to delay the validation to return a proper response.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001528">Todo</a></b></dt><dd>(user): We currently reuse the MODEL_INVALID status even though it is not the best name for this. Maybe we can add a PARAMETERS_INVALID when it become needed. Or rename to INVALID_INPUT ? </dd></dl>
<p>Initialize the time limit from the parameters.</p>
<p>Register SIGINT handler if requested by the parameters.</p>
<p>Internally we adapt the parameters so that things are disabled if they do not make sense.</p>
<p>Validate model_proto. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001529">Todo</a></b></dt><dd>(user): provide an option to skip this step for speed? </dd></dl>
<p>Presolve and expansions.</p>
<dl class="section note"><dt>Note</dt><dd>Allocating in an arena significantly speed up destruction (free) for large messages.</dd></dl>
<p>Checks for hints early in case they are forced to be hard constraints.</p>
<p>If the hint is complete, we can use the solution checker to do more validation. Note that after the model has been validated, we are sure there are do duplicate variables in the solution hint, so we can just check the size.</p>
<p>If the objective was a floating point one, do some postprocessing on the final response.</p>
<p>Compute the true objective of the best returned solution.</p>
<p>Also copy the scaled objective which must be in the mapping model. This can be useful for some client, like if they want to do multi-objective optimization in stages.</p>
<p>If requested, compute a correct lb from the one on the integer objective. We only do that if some error were introduced by the scaling algorithm.</p>
<p>To avoid small errors that can be confusing, we take the min/max with the objective value.</p>
<p>Check the absolute gap, and display warning if needed. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001530">Todo</a></b></dt><dd>(user): Change status to IMPRECISE? </dd></dl>
<p>For the case where the assumptions are currently not supported, we just assume they are fixed, and will always report all of them in the UNSAT core if the problem turn out to be UNSAT.</p>
<p>If the mode is not degraded, we will hopefully report a small subset in case there is no feasible solution under these assumptions.</p>
<p>For now, just pass in all assumptions.</p>
<p>Clear them from the new proto.</p>
<p>Do the actual presolve.</p>
<p>Delete the context as soon as the presolve is done. Note that only postsolve_mapping and mapping_proto are needed for postsolve.</p>
<p>Detect the symmetry of the presolved model. </p><dl class="section note"><dt>Note</dt><dd>this needs to be done before <a class="el" href="structoperations__research_1_1sat_1_1SharedClasses.html">SharedClasses</a> are created.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001531">Todo</a></b></dt><dd>(user): We could actually report a complete feasible hint before this point. But the proper fix is to report it even before the presolve. </dd></dl>
<p>Symmetry should be already computed and correct, so we don't redo it. Moreover it is possible we will not find them again as the constraints might have changed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001532">Todo</a></b></dt><dd>(user): reduce this function size and find a better place for this? </dd></dl>
<p>Collect the info we know about new_cp_model_proto bounds. </p><dl class="section note"><dt>Note</dt><dd>this is not really needed as we should have the same information in the mapping_proto.</dd></dl>
<p>Intersect with the <a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html">SharedBoundsManager</a> if it exist.</p>
<p>Postsolve and fill the field.</p>
<p>Solution checking. We either check all solutions, or only the last one. Checking all solution might be expensive if we creates many.</p>
<p>We pass presolve data for more informative message in case the solution is not feasible.</p>
<p>We dump the response when infeasible, this might help debugging.</p>
<p>Crash.</p>
<p>Solution postsolving.</p>
<p>Map back the sufficient assumptions for infeasibility.</p>
<p>Truncate the solution in case model expansion added more variables.</p>
<p>Make sure everything stops when we have a first solution if requested.</p>
<p>If the model is convertible to a MIP, we dump it too.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001533">Todo</a></b></dt><dd>(user): We could try to dump our linear relaxation too. </dd></dl>
<p>If the model is convertible to a pure SAT one, we dump it too.</p>
<p>If specified, we load the initial objective domain right away in the response manager. Note that the presolve will always fill it with the trivial min/max value if the user left it empty. This avoids to display [-infinity, infinity] for the initial objective search space.</p>
<p>Start counting the primal integral from the current deterministic time and initial objective domain gap that we just filled.</p>
<p>Re-test a complete solution hint to see if it survived the presolve. If it is feasible, we load it right away.</p>
<p>Tricky: when we enumerate all solutions, we cannot properly exclude the current solution if we didn't find it via full propagation, so we don't load it in this case.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001534">Todo</a></b></dt><dd>(user): Even for an optimization, if we load the solution right away, we might not have the same behavior as the initial search that follow the hint will be infeasible, so the activities of the variables will be different. </dd></dl>
<p>To avoid duplicating code, the single-thread version reuse most of the multi-thread architecture.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02304">2304</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a2d1465f989d9ff7138b62c25eea5ab1a" name="a2d1465f989d9ff7138b62c25eea5ab1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1465f989d9ff7138b62c25eea5ab1a">&#9670;&#160;</a></span>SolveCpModelWithParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SolveCpModelWithParameters </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>creq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>creq_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>cparams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cparams_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>cres</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>cres_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__solver__c_8cc_source.html#l00044">44</a> of file <a class="el" href="cp__solver__c_8cc_source.html">cp_solver_c.cc</a>.</p>

</div>
</div>
<a id="ac9dc756eed847e0f0f77824695b24943" name="ac9dc756eed847e0f0f77824695b24943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dc756eed847e0f0f77824695b24943">&#9670;&#160;</a></span>SolveCpNewAtomicBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * operations_research::sat::SolveCpNewAtomicBool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__solver__c_8cc_source.html#l00051">51</a> of file <a class="el" href="cp__solver__c_8cc_source.html">cp_solver_c.cc</a>.</p>

</div>
</div>
<a id="a4101b7d436bf6e0a4414490bf987c18a" name="a4101b7d436bf6e0a4414490bf987c18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4101b7d436bf6e0a4414490bf987c18a">&#9670;&#160;</a></span>SolveCpStopSolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SolveCpStopSolve </td>
          <td>(</td>
          <td class="paramtype">void *const</td>          <td class="paramname"><span class="paramname"><em>atomic_bool</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__solver__c_8cc_source.html#l00057">57</a> of file <a class="el" href="cp__solver__c_8cc_source.html">cp_solver_c.cc</a>.</p>

</div>
</div>
<a id="a43a3828d1897a92ece5fd4f6018fe3da" name="a43a3828d1897a92ece5fd4f6018fe3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a3828d1897a92ece5fd4f6018fe3da">&#9670;&#160;</a></span>SolveDiophantine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1DiophantineSolution.html">DiophantineSolution</a> operations_research::sat::SolveDiophantine </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>var_lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>var_ubs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>x_i's Satisfying sum(x_i * coeffs[pivots[i]]) = current_gcd.</p>
<p>Z-basis of sum(x_i * arg.coeffs(pivots[i])) = 0.</p>
<p>Solves current_gcd * u + coeff * v = new_gcd. Copy the coefficients as the function below modifies them.</p>
<p>To compute the domains, we use the triangular shape of the basis. The first one is special as it is controlled by two columns of the basis. Note that we don't try to compute exact domains as we would need to multiply then making the number of interval explode. For i = 0, ..., replaced_variable_count - 1, uses identities x[i] = special_solution[i]</p><ul>
<li>sum(linear_basis[k][i]*y[k], max(1, i) &lt;= k &lt; vars.size) where: y[k] is a newly created variable if 1 &lt;= k &lt; replaced_variable_count y[k] = x[pivots[k]] else. <dl class="todo"><dt><b><a class="el" href="todo.html#_todo001712">Todo</a></b></dt><dd>(user): look if there is a natural improvement. </dd></dl>
</li>
</ul>
<p>Identities 0 and 1 both bound the first element of the basis.</p>

<p class="definition">Definition at line <a class="el" href="diophantine_8cc_source.html#l00122">122</a> of file <a class="el" href="diophantine_8cc_source.html">diophantine.cc</a>.</p>

</div>
</div>
<a id="a34eb7909877704c304f50d65dd5c0052" name="a34eb7909877704c304f50d65dd5c0052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34eb7909877704c304f50d65dd5c0052">&#9670;&#160;</a></span>SolveDiophantineEquationOfSizeTwo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SolveDiophantineEquationOfSizeTwo </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>cte</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>y0</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the equation a * X + b * Y = cte has some integer solutions. For now, we check that a and b are different from 0 and from int64_t min.</p>
<p>There is actually always a solution if cte % gcd(<code>a</code>, <code>b</code>) == 0. And because a, b and cte fit on an int64_t, if there is a solution, there is one with X and Y fitting on an int64_t.</p>
<p>We will divide everything by gcd(a, b) first, so it is why we take reference and the equation can change.</p>
<p>If there are solutions, we return one of them (x0, y0). From any such solution, the set of all solutions is given for Z integer by: X = x0 + b * Z; Y = y0 - a * Z;</p>
<p>Given a domain for X and Y, it is possible to compute the "exact" domain of Z with our <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> functions. Note however that this will only compute solution where both x-x0 and y-y0 do fit on an int64_t: DomainOf(x).SubtractionWith(x0).InverseMultiplicationBy(b).IntersectionWith( DomainOf(y).SubtractionWith(y0).InverseMultiplicationBy(-a)) </p>
<p>The simple case where (0, 0) is a solution.</p>
<p>We solve a * X + b * Y = cte We take a valid x0 in [0, b) by considering the equation mod b.</p>
<p>We choose x0 of the same sign as cte.</p>
<p>By plugging X = x0 + b * Z We have a * (x0 + b * Z) + b * Y = cte so a * b * Z + b * Y = cte - a * x0; and y0 = (cte - a * x0) / b (with an exact division by construction).</p>
<p>Overflow-wise, there is two cases for cte &gt; 0:</p><ul>
<li>a * x0 &lt;= cte, in this case y0 will not overflow (&lt;= cte).</li>
<li>a * x0 &gt; cte, in this case y0 will be in (-a, 0].</li>
</ul>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00204">204</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="a635874624086317f36f097b23b84d3eb" name="a635874624086317f36f097b23b84d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635874624086317f36f097b23b84d3eb">&#9670;&#160;</a></span>SolveFzWithCpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SolveFzWithCpModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1fz_1_1Model.html">fz::Model</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fz_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1fz_1_1FlatzincSatParameters.html">fz::FlatzincSatParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sat_params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *</td>          <td class="paramname"><span class="paramname"><em>solution_logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the given flatzinc model using the CP-SAT solver. </p>
<p>The translation is easy, we create one variable per flatzinc variable, plus eventually a bunch of constant variables that will be created lazily.</p>
<p>The CP-SAT solver checks that constraints cannot overflow during their propagation. Because of that, we trim undefined variable domains (i.e. int in minizinc) to something hopefully large enough.</p>
<p>Translate the constraints.</p>
<p>Fill the objective.</p>
<p>Fill the search order.</p>
<p>Enumerate all sat solutions.</p>
<p>Helps with challenge unit tests.</p>
<p>Computes the number of workers.</p>
<p>We don't support enumerating all solution in parallel for a SAT problem. But note that we do support it for an optimization problem since the meaning of p.all_solutions is not the same in this case.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000457">Todo</a></b></dt><dd>(user): Supports setting the number of workers to 0, which will then query the number of cores available. This is complex now as we need to still support the expected behabior (no flags -&gt; 1 thread fixed search, -f -&gt; 1 thread free search). </dd></dl>
<p>Specifies single thread specific search modes.</p>
<p>Time limit.</p>
<p>The order is important, we want the flag parameters to overwrite anything set in m.parameters.</p>
<p>We only need an observer if 'p.display_all_solutions' or 'p.search_all_solutions' are true.</p>
<p>Setup logging. </p><dl class="section note"><dt>Note</dt><dd>we need to do that before we start calling the sat functions below that might create a SolverLogger() themselves.</dd></dl>
<p>Check the returned solution with the fz model checker.</p>
<p>Output the solution in the flatzinc official format.</p>
<p>Already printed otherwise.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__fz__solver_8cc_source.html#l01414">1414</a> of file <a class="el" href="cp__model__fz__solver_8cc_source.html">cp_model_fz_solver.cc</a>.</p>

</div>
</div>
<a id="a78d12c07dbcc1ac097e51359ac299aea" name="a78d12c07dbcc1ac097e51359ac299aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d12c07dbcc1ac097e51359ac299aea">&#9670;&#160;</a></span>SolveIntegerProblemWithLazyEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SolveIntegerProblemWithLazyEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only used in tests. Move to a test utility file.</p>
<p>This configures the model <a class="el" href="structoperations__research_1_1sat_1_1SearchHeuristics.html">SearchHeuristics</a> with a simple default heuristic and then call <a class="el" href="#ade6ce3f7172b49fd16513489bdb4ca32">ResetAndSolveIntegerProblem()</a> without any assumptions. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l01617">1617</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a11198d99e855837fa730eb6a5097a801" name="a11198d99e855837fa730eb6a5097a801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11198d99e855837fa730eb6a5097a801">&#9670;&#160;</a></span>SolveLoadedCpModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SolveLoadedCpModel </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves an already loaded cp_model_proto. The final CpSolverResponse must be read from the shared_response_manager.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001567">Todo</a></b></dt><dd>(user): This should be transformed so that it can be called many times and resume from the last search state as if it wasn't interrupted. That would allow use to easily interleave different heuristics in the same thread. </dd></dl>
<p>Solves an already loaded cp_model_proto. The final CpSolverResponse must be read from the shared_response_manager.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001585">Todo</a></b></dt><dd>(user): This should be transformed so that it can be called many times and resume from the last search state as if it wasn't interrupted. That would allow use to easily interleave different heuristics in the same thread. </dd></dl>
<p>Make sure we are not at a positive level.</p>
<p>Reconfigure search heuristic if it was changed.</p>
<p>Extract a good subset of assumptions and add it to the response.</p>
<p>Optimization problem.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001568">Todo</a></b></dt><dd>(user): This doesn't work with splitting in chunk for now. It shouldn't be too hard to fix. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001569">Todo</a></b></dt><dd>(user): This parameter breaks the splitting in chunk of a <a class="el" href="#a09d851f944ab4f305c3d9f8df99b7bf8" title="Solves the given CpModelProto and returns an instance of CpSolverResponse.">Solve()</a>. It should probably be moved into another <a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html">SubSolver</a> altogether. </dd></dl>
<p>The search is done in both case.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001570">Todo</a></b></dt><dd>(user): Remove the weird translation INFEASIBLE-&gt;FEASIBLE in the function above? </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__solver__helpers_8cc_source.html#l01495">1495</a> of file <a class="el" href="cp__model__solver__helpers_8cc_source.html">cp_model_solver_helpers.cc</a>.</p>

</div>
</div>
<a id="aa3062797aa0396abf37dbcc99a746f12" name="aa3062797aa0396abf37dbcc99a746f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3062797aa0396abf37dbcc99a746f12">&#9670;&#160;</a></span>SolveWithParameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpSolverResponse operations_research::sat::SolveWithParameters </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the given CpModelProto with the given parameters. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02925">2925</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="af52c27ecb43d6486c1a70e022b4aad39" name="af52c27ecb43d6486c1a70e022b4aad39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52c27ecb43d6486c1a70e022b4aad39">&#9670;&#160;</a></span>SolveWithParameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpSolverResponse operations_research::sat::SolveWithParameters </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the given CpModelProto with the given sat parameters as string in JSon format, and returns an instance of CpSolverResponse. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__solver_8cc_source.html#l02933">2933</a> of file <a class="el" href="cp__model__solver_8cc_source.html">cp_model_solver.cc</a>.</p>

</div>
</div>
<a id="a2af162f5376a8d8234b9287b5c8163c1" name="a2af162f5376a8d8234b9287b5c8163c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af162f5376a8d8234b9287b5c8163c1">&#9670;&#160;</a></span>SplitAndLoadIntermediateConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SplitAndLoadIntermediateConstraints </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lb_required</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ub_required</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IntegerVariable &gt; *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001295">Todo</a></b></dt><dd>(user): We could use a smarter way to determine buckets, like putting everyone with the same coeff together if possible and the split is ok. </dd></dl>
<p>Part of <a class="el" href="#ade08c3522dfce173ee1fd50fab3bd3c0">LoadLinearConstraint()</a> that we reuse to load the objective.</p>
<p>We split large constraints into a square root number of parts. This is to avoid a bad complexity while propagating them since our algorithm is not in O(num_changes).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001302">Todo</a></b></dt><dd>(user): Alternatively, we could use a O(num_changes) propagation (a bit tricky to implement), or a decomposition into a tree with more than one level. Both requires experimentations. </dd></dl>
<p>If we enumerate all solutions, then we want intermediate variables to be tight independently of what side is required.</p>
<p>Everything should be exactly divisible!</p>
<p>We have sum bucket_var &gt;= lb, so we need local_vars &gt;= bucket_var.</p>
<p>Similarly, bucket_var &lt;= ub, so we need local_vars &lt;= bucket_var</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l01154">1154</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="ad725b9adf7aec4dc6bc11e925973dc87" name="ad725b9adf7aec4dc6bc11e925973dc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad725b9adf7aec4dc6bc11e925973dc87">&#9670;&#160;</a></span>SplitAroundGivenValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::SplitAroundGivenValue </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method first tries var &lt;= value. If this does not reduce the domain it tries var &gt;= value. If that also does not reduce the domain then returns an invalid literal. </p>
<p>Heuristic: Prefer the objective direction first. Reference: Conflict-Driven Heuristics for Mixed Integer Programming (2019) by Jakob Witzig and Ambros Gleixner. </p><dl class="section note"><dt>Note</dt><dd>The value might be out of bounds. In that case we return kNoLiteralIndex.</dd></dl>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00089">89</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a5154a61154ff9b3522e0c0eba7ed0319" name="a5154a61154ff9b3522e0c0eba7ed0319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5154a61154ff9b3522e0c0eba7ed0319">&#9670;&#160;</a></span>SplitAroundLpValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::SplitAroundLpValue </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns decision corresponding to var &lt;= round(lp_value). If the variable does not appear in the LP, this method returns an invalid literal. </p>
<p>We only use this if the sub-lp has a solution, and depending on the value of exploit_all_lp_solution() if it is a pure-integer solution.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001858">Todo</a></b></dt><dd>(user): Depending if we branch up or down, this might not exclude the LP value, which is potentially a bad thing.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001859">Todo</a></b></dt><dd>(user): Why is the reduced cost doing things differently? </dd></dl>
<p>Because our lp solution might be from higher up in the tree, it is possible that value is now outside the domain of positive_var. In this case, this function will return an invalid literal.</p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00117">117</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a872297a32bd1f4a91bbcebd1c47b3751" name="a872297a32bd1f4a91bbcebd1c47b3751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872297a32bd1f4a91bbcebd1c47b3751">&#9670;&#160;</a></span>SplitDomainUsingBestSolutionValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::SplitDomainUsingBestSolutionValue </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns decision corresponding to var &lt;= best_solution[var]. If no solution has been found, this method returns a literal with kNoIntegerVariable. This was suggested in paper: "Solution-Based Phase Saving for CP" (2018) by Emir Demirovic, Geoffrey Chu, and Peter J. Stuckey. </p>

</div>
</div>
<a id="a10b69b90d6f71d58555815dec71d7126" name="a10b69b90d6f71d58555815dec71d7126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b69b90d6f71d58555815dec71d7126">&#9670;&#160;</a></span>SplitInConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; operations_research::sat::SplitInConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Neighbours.html">Neighbours</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbours</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="2d__rectangle__presolve_8cc_source.html#l00559">559</a> of file <a class="el" href="2d__rectangle__presolve_8cc_source.html">2d_rectangle_presolve.cc</a>.</p>

</div>
</div>
<a id="ac4a25d47a029efe205efbc015f7c7e7c" name="ac4a25d47a029efe205efbc015f7c7e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a25d47a029efe205efbc015f7c7e7c">&#9670;&#160;</a></span>SplitUsingBestSolutionValueInRepository()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::SplitUsingBestSolutionValueInRepository </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html">SharedSolutionRepository</a>&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>solution_repo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00146">146</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a208ca223ea68cdf0a4c3a3d69403be4d" name="a208ca223ea68cdf0a4c3a3d69403be4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208ca223ea68cdf0a4c3a3d69403be4d">&#9670;&#160;</a></span>StoreAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::StoreAssignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>assignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BooleanAssignment *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store a variable assignment into the given BooleanAssignment proto. </p><dl class="section note"><dt>Note</dt><dd>only the assigned variables are stored, so the assignment may be incomplete. </dd></dl>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00488">488</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="acdca64632fe6eb1a4fed67843084620f" name="acdca64632fe6eb1a4fed67843084620f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdca64632fe6eb1a4fed67843084620f">&#9670;&#160;</a></span>SubsetsDetector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SubsetsDetector </td>
          <td>(</td>
          <td class="paramtype">const Storage &amp;</td>          <td class="paramname"><span class="paramname"><em>storage</em></span></td><td>)</td>
          <td> -&gt;  SubsetsDetector&lt; Storage &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e6ebcd354f4957a3e7bf72b45b9408d" name="a6e6ebcd354f4957a3e7bf72b45b9408d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6ebcd354f4957a3e7bf72b45b9408d">&#9670;&#160;</a></span>SubstituteVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SubstituteVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>var_coeff_in_definition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>definition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the variable var in ct using the definition constraint. Currently the coefficient in the definition must be 1 or -1.</p>
<p>This might return false and NOT modify ConstraintProto in case of overflow or other issue with the substitution. </p>
<p>Get the coefficient of var in the constraint. We assume positive reference here (it should always be the case now). If we don't find var, we abort.</p>
<p>If var appear multiple time, we add all its coefficients.</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00232">232</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="ab89c95fd9e5fe8176a7807d92872972e" name="ab89c95fd9e5fe8176a7807d92872972e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89c95fd9e5fe8176a7807d92872972e">&#9670;&#160;</a></span>SUniv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SUniv </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the ith element of the strategy S^univ proposed by M. Luby et al. in Optimal Speedup of Las Vegas Algorithms, Information Processing Letters 1993. This is used to decide the number of conflicts allowed before the next restart. This method, used by most SAT solvers, is usually referenced as Luby. Returns 2^{k-1} when i == 2^k - 1 and SUniv(i - 2^{k-1} + 1) when 2^{k-1} &lt;= i &lt; 2^k - 1. The sequence is defined for i &gt; 0 and starts with: {1, 1, 2, 1, 1, 2, 4, 1, 1, 2, 1, 1, 2, 4, 8, ...} </p>

<p class="definition">Definition at line <a class="el" href="restart_8h_source.html#l00092">92</a> of file <a class="el" href="restart_8h_source.html">restart.h</a>.</p>

</div>
</div>
<a id="ac0cd12533c5931b78650aebe211dd51e" name="ac0cd12533c5931b78650aebe211dd51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cd12533c5931b78650aebe211dd51e">&#9670;&#160;</a></span>SymmetrizeArcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SymmetrizeArcs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ArcWithLpValue.html">ArcWithLpValue</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Regroups and sum the lp values on duplicate arcs or reversed arcs (tail-&gt;head) and (head-&gt;tail). As a side effect, we will always have tail &lt;= head. </p>

<p class="definition">Definition at line <a class="el" href="routing__cuts_8cc_source.html#l01164">1164</a> of file <a class="el" href="routing__cuts_8cc_source.html">routing_cuts.cc</a>.</p>

</div>
</div>
<a id="aed77a1a7675c2f8568529a5a16247ec1" name="aed77a1a7675c2f8568529a5a16247ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed77a1a7675c2f8568529a5a16247ec1">&#9670;&#160;</a></span>ToDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::ToDouble </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00060">60</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="ac4d28f8e2aa38a7c39feee848168a26c" name="ac4d28f8e2aa38a7c39feee848168a26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d28f8e2aa38a7c39feee848168a26c">&#9670;&#160;</a></span>ToIntegerValueVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IntegerValue &gt; operations_research::sat::ToIntegerValueVector </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> based functions. </p>

<p class="definition">Definition at line <a class="el" href="cp__constraints_8h_source.html#l00113">113</a> of file <a class="el" href="cp__constraints_8h_source.html">cp_constraints.h</a>.</p>

</div>
</div>
<a id="a582f0961633776a7a3e0933052435137" name="a582f0961633776a7a3e0933052435137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582f0961633776a7a3e0933052435137">&#9670;&#160;</a></span>TracePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::TracePoint </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>schrier_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>generators</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a schreier vector for a given base point and a point in the same orbit of the base point, returns a list of index of the <code>generators</code> to apply to get a permutation mapping the base point to get the given point. </p>

<p class="definition">Definition at line <a class="el" href="symmetry__util_8cc_source.html#l00224">224</a> of file <a class="el" href="symmetry__util_8cc_source.html">symmetry_util.cc</a>.</p>

</div>
</div>
<a id="a8fc9e60de9ebec04b0d8e62c0bcd7aa1" name="a8fc9e60de9ebec04b0d8e62c0bcd7aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc9e60de9ebec04b0d8e62c0bcd7aa1">&#9670;&#160;</a></span>TransformToGeneratorOfStabilizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::TransformToGeneratorOfStabilizer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>to_stabilize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>generators</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the generators for a permutation group of [0, n-1], update it to a set of generators of the group stabilizing the given element.</p>
<dl class="section note"><dt>Note</dt><dd>one can add symmetry breaking constraints by repeatedly doing: 1/ Call <a class="el" href="#aa8cc7ff53b39b6a28e821bc428dcb331">GetOrbits()</a> using the current set of generators. 2/ Choose an element x0 in a large orbit (x0, .. xi ..) , and add x0 &gt;= xi for all i. 3/ Update the set of generators to the one stabilizing x0.</dd></dl>
<p>This is more or less what is described in "Symmetry Breaking Inequalities
from the Schreier-Sims Table", Domenico Salvagnin, <a href="https://link.springer.com/chapter/10.1007/978-3-319-93031-2_37">https://link.springer.com/chapter/10.1007/978-3-319-93031-2_37</a></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002462">Todo</a></b></dt><dd>(user): Implement! </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetry__util_8h_source.html#l00097">97</a> of file <a class="el" href="symmetry__util_8h_source.html">symmetry_util.h</a>.</p>

</div>
</div>
<a id="a0699275a4e8ee3496cef3657c360ad2b" name="a0699275a4e8ee3496cef3657c360ad2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0699275a4e8ee3496cef3657c360ad2b">&#9670;&#160;</a></span>TrySolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::TrySolution </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>new_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>base_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>new_combined_solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A value that changed that we patch.</p>

<p class="definition">Definition at line <a class="el" href="combine__solutions_8cc_source.html#l00033">33</a> of file <a class="el" href="combine__solutions_8cc_source.html">combine_solutions.cc</a>.</p>

</div>
</div>
<a id="a7e710c5266505c51982912036c840755" name="a7e710c5266505c51982912036c840755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e710c5266505c51982912036c840755">&#9670;&#160;</a></span>TryToLinearizeConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::TryToLinearizeConstraint </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>linearization_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1LinearRelaxation.html">LinearRelaxation</a> *</td>          <td class="paramname"><span class="paramname"><em>relaxation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a> *</td>          <td class="paramname"><span class="paramname"><em>activity_helper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linearization of different types of constraints. </p>
<p>Add a static and a dynamic linear relaxation of the CP constraint to the set of linear constraints. The highest linearization_level is, the more types of constraint we encode. This method should be called only for linearization_level &gt; 0. The static part is just called a relaxation and is called at the root node of the search. The dynamic part is implemented through a set of linear cut generators that will be called throughout the search.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002054">Todo</a></b></dt><dd><p class="startdd">(user): In full generality, we could encode all the constraint as an LP. </p>
<p class="interdd">(user): Add unit tests for this method. </p>
<p class="enddd">(user): Remove and merge with model loading. </p>
</dd></dl>
<p>No relaxation, just a cut generator .</p>
<p>Add cut generators.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002055">Todo</a></b></dt><dd>(user): Use the same pattern as the other 2 scheduling methods:<ul>
<li>single function</li>
<li>generate helpers once</li>
</ul>
</dd></dl>
<p>Adds an energetic relaxation (sum of areas fits in bounding box).</p>
<p>Adds a completion time cut generator and an energetic cut generator.</p>

<p class="definition">Definition at line <a class="el" href="linear__relaxation_8cc_source.html#l01379">1379</a> of file <a class="el" href="linear__relaxation_8cc_source.html">linear_relaxation.cc</a>.</p>

</div>
</div>
<a id="aa5783ecb0b6b7f12fc2ea70339ec7acd" name="aa5783ecb0b6b7f12fc2ea70339ec7acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5783ecb0b6b7f12fc2ea70339ec7acd">&#9670;&#160;</a></span>TryToReconcileEncodings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt; operations_research::sat::TryToReconcileEncodings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>size2_affine</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>affine</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>affine_var_encoding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>put_affine_left_in_result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> *</td>          <td class="paramname"><span class="paramname"><em>integer_encoder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a variable has a size of 2, it is most likely reduced to an affine expression pointing to a variable with domain [0,1] or [-1,0]. If the original variable has been removed from the model, then there are no implied values from any exactly_one constraint to its domain. If we are lucky, one of the literal of the exactly_one constraints, and its negation are used to encode the Boolean variable of the affine.</p>
<p>This may fail if exactly_one(l0, l1, l2, l3); l0 and l1 imply x = 0, l2 and l3 imply x = 1. In that case, one must look at the binary implications to find the missing link.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001767">Todo</a></b></dt><dd>(user): Consider removing this once we are more complete in our implied bounds repository. Because if we can reconcile an encoding, then any of the literal in the at most one should imply a value on the boolean view use in the size2 affine. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001768">Todo</a></b></dt><dd>(user): I am not sure how this can happen since size2_affine is supposed to be non-fixed. Maybe we miss some propag. Investigate. </dd></dl>
<p>Build the decomposition.</p>

<p class="definition">Definition at line <a class="el" href="implied__bounds_8cc_source.html#l00257">257</a> of file <a class="el" href="implied__bounds_8cc_source.html">implied_bounds.cc</a>.</p>

</div>
</div>
<a id="a20bb893f521052633be884ab5a14a566" name="a20bb893f521052633be884ab5a14a566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bb893f521052633be884ab5a14a566">&#9670;&#160;</a></span>TryToReconcileSize2Encodings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralValueValue.html">LiteralValueValue</a> &gt; operations_research::sat::TryToReconcileSize2Encodings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> *</td>          <td class="paramname"><span class="paramname"><em>integer_encoder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialized case of encoding reconciliation when both variables have a domain of size of 2. </p>

<p class="definition">Definition at line <a class="el" href="implied__bounds_8cc_source.html#l00301">301</a> of file <a class="el" href="implied__bounds_8cc_source.html">implied_bounds.cc</a>.</p>

</div>
</div>
<a id="a5c23af10324a7d8e255e789fa0e2eb15" name="a5c23af10324a7d8e255e789fa0e2eb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c23af10324a7d8e255e789fa0e2eb15">&#9670;&#160;</a></span>UnassignedVarWithLowestMinAtItsMinHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerLiteral.html">BooleanOrIntegerLiteral</a>()&gt; operations_research::sat::UnassignedVarWithLowestMinAtItsMinHeuristic </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1Decision.html">Decision</a> heuristic for <a class="el" href="#a78d12c07dbcc1ac097e51359ac299aea">SolveIntegerProblemWithLazyEncoding()</a>. Like <a class="el" href="#a28a1d7fdb9ee5a88b771b2965bf18596">FirstUnassignedVarAtItsMinHeuristic()</a> but the function will return the literal corresponding to the fact that the currently non-assigned variable with the lowest min has a value &lt;= this min. </p>

<p class="definition">Definition at line <a class="el" href="integer__search_8cc_source.html#l00275">275</a> of file <a class="el" href="integer__search_8cc_source.html">integer_search.cc</a>.</p>

</div>
</div>
<a id="a1ff712b32e44ffd2e7f40042330bf2ad" name="a1ff712b32e44ffd2e7f40042330bf2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff712b32e44ffd2e7f40042330bf2ad">&#9670;&#160;</a></span>UnscaleObjectiveValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::UnscaleObjectiveValue </td>
          <td>(</td>
          <td class="paramtype">const CpObjectiveProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the objective scaling and offset from the given value. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00194">194</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a9e815eb2193f1bb6903274c7f0859cd7" name="a9e815eb2193f1bb6903274c7f0859cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e815eb2193f1bb6903274c7f0859cd7">&#9670;&#160;</a></span>UpperBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::UpperBound </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01545">1545</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a869d0ba93c0a19641fc4d0cdaf5b7233" name="a869d0ba93c0a19641fc4d0cdaf5b7233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869d0ba93c0a19641fc4d0cdaf5b7233">&#9670;&#160;</a></span>UsedIntervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::UsedIntervals </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sorted list of interval used by a constraint. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00542">542</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="a82863d7b3a08b5b2267b69b737034076" name="a82863d7b3a08b5b2267b69b737034076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82863d7b3a08b5b2267b69b737034076">&#9670;&#160;</a></span>UsedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; operations_research::sat::UsedVariables </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sorted list of variables used by a constraint. </p><dl class="section note"><dt>Note</dt><dd>this include variable used as a literal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8cc_source.html#l00529">529</a> of file <a class="el" href="cp__model__utils_8cc_source.html">cp_model_utils.cc</a>.</p>

</div>
</div>
<a id="ae3f15cad54562c8611ebe62208a22b44" name="ae3f15cad54562c8611ebe62208a22b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f15cad54562c8611ebe62208a22b44">&#9670;&#160;</a></span>UseObjectiveForSatAssignmentPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::UseObjectiveForSatAssignmentPreference </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> *</td>          <td class="paramname"><span class="paramname"><em>solver</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the objective coefficient to drive the SAT search towards an heuristically better solution. </p>
<p>Because this is a minimization problem, we prefer to assign a Boolean variable to its "low" objective value. So if a literal has a positive weight when true, we want to set it to false.</p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00320">320</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="abe077e9fb0115e89e7e4cb9623b2d61a" name="abe077e9fb0115e89e7e4cb9623b2d61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe077e9fb0115e89e7e4cb9623b2d61a">&#9670;&#160;</a></span>ValidateBooleanProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::sat::ValidateBooleanProblem </td>
          <td>(</td>
          <td class="paramtype">const LinearBooleanProblem &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests the preconditions of the given problem (as described in the proto) and returns an error if they are not all satisfied. </p>

<p class="definition">Definition at line <a class="el" href="boolean__problem_8cc_source.html#l00144">144</a> of file <a class="el" href="boolean__problem_8cc_source.html">boolean_problem.cc</a>.</p>

</div>
</div>
<a id="a2eec7d4958da587ee893e334ab7756cc" name="a2eec7d4958da587ee893e334ab7756cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eec7d4958da587ee893e334ab7756cc">&#9670;&#160;</a></span>ValidateCpModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::ValidateCpModel </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>after_presolve</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies that the given model satisfies all the properties described in the proto comments. Returns an empty string if it is the case, otherwise fails at the first error and returns a human-readable description of the issue.</p>
<p>The extra parameter is internal and mainly for debugging. After the problem has been presolved, we have a stricter set of properties we want to enforce.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001202">Todo</a></b></dt><dd>(user): Add any needed overflow validation because we are far from exhaustive. We could also run a small presolve that tighten variable bounds before the overflow check to facilitate the lives of our users, but it is a some work to put in place. </dd></dl>
<p>We require this precondition so that we can take any linear combination of variable with coefficient in int64_t and compute the activity on an int128 with no overflow. This is useful during cut computation.</p>
<p>We need to validate the intervals used first, so we add these constraints here so that we can validate them in a second pass.</p>
<p>By default, a constraint does not support enforcement literals except if explicitly stated by setting this to true below.</p>
<p>Other non-generic validations.</p>
<p>Because some client set fixed enforcement literal which are supported in the presolve for all constraints, we just check that there is no non-fixed enforcement.</p>
<p>Extra validation for constraint using intervals.</p>
<p>If any of these fields are set, the domain must be set.</p>
<p>Check that we can transform any value in the objective domain without overflow. We only check the bounds which is enough.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__checker_8cc_source.html#l01048">1048</a> of file <a class="el" href="cp__model__checker_8cc_source.html">cp_model_checker.cc</a>.</p>

</div>
</div>
<a id="a2073b9c892ac56b197b31cb583e25f3d" name="a2073b9c892ac56b197b31cb583e25f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2073b9c892ac56b197b31cb583e25f3d">&#9670;&#160;</a></span>ValidateInputCpModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::ValidateInputCpModel </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some validation (in particular the floating point objective) requires to read parameters.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001203">Todo</a></b></dt><dd>(user): Ideally we would have just one <a class="el" href="#a2eec7d4958da587ee893e334ab7756cc">ValidateCpModel()</a> function but this was introduced after many users already use <a class="el" href="#a2eec7d4958da587ee893e334ab7756cc">ValidateCpModel()</a> without parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__checker_8cc_source.html#l01251">1251</a> of file <a class="el" href="cp__model__checker_8cc_source.html">cp_model_checker.cc</a>.</p>

</div>
</div>
<a id="ad582c9543b77917ac1084bbfda601f5e" name="ad582c9543b77917ac1084bbfda601f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad582c9543b77917ac1084bbfda601f5e">&#9670;&#160;</a></span>ValidateLinearConstraintForOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ValidateLinearConstraintForOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1LinearConstraint.html">LinearConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>integer_trail</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001928">Todo</a></b></dt><dd>(user): Avoid duplication with <a class="el" href="#a94b1038b63ced09f0c7239a726dbe790">PossibleIntegerOverflow()</a> in the checker? At least make sure the code is the same. </dd></dl>
<p>Makes sure that any of our future computation on this constraint will not cause overflow. We use the level zero bounds and use the same definition as in <a class="el" href="#a94b1038b63ced09f0c7239a726dbe790">PossibleIntegerOverflow()</a> in the <a class="el" href="cp__model_8proto.html">cp_model.proto</a> checker.</p>
<p>Namely, the sum of positive terms, the sum of negative terms and their difference shouldn't overflow. Note that we don't validate the rhs, but if the bounds are properly relaxed, then this shouldn't cause any issues.</p>
<p>Note(user): We should avoid doing this test too often as it can be slow. At least do not do it more than once on each constraint. </p>

<p class="definition">Definition at line <a class="el" href="linear__constraint_8cc_source.html#l00407">407</a> of file <a class="el" href="linear__constraint_8cc_source.html">linear_constraint.cc</a>.</p>

</div>
</div>
<a id="a80f1b6bbf960239725bec385f09a5b14" name="a80f1b6bbf960239725bec385f09a5b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f1b6bbf960239725bec385f09a5b14">&#9670;&#160;</a></span>ValidateParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::ValidateParameters </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies that the given parameters are correct. Returns an empty string if it is the case, or an human-readable error message otherwise. </p>
<p>Test that all floating point parameters are not NaN or +/- infinity.</p>
<p>Parallelism.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002126">Todo</a></b></dt><dd>(user): Consider using annotations directly in the proto for these validation. It is however not open sourced. </dd></dl>
<p>Feasibility jump.</p>
<p>Violation ls.</p>
<p>Test LP tolerances.</p>

<p class="definition">Definition at line <a class="el" href="sat_2parameters__validation_8cc_source.html#l00055">55</a> of file <a class="el" href="sat_2parameters__validation_8cc_source.html">parameters_validation.cc</a>.</p>

</div>
</div>
<a id="a1a3318619f57025ab3d6474542d64994" name="a1a3318619f57025ab3d6474542d64994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3318619f57025ab3d6474542d64994">&#9670;&#160;</a></span>Value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::Value </td>
          <td>(</td>
          <td class="paramtype">BooleanVariable</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This checks that the variable is fixed. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l01041">1041</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a96eab70b5ead3894afac4d4fff0fd984" name="a96eab70b5ead3894afac4d4fff0fd984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96eab70b5ead3894afac4d4fff0fd984">&#9670;&#160;</a></span>Value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::Value </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This checks that the variable is fixed. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01559">1559</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aaa275108375324277e2d6399f6119513" name="aaa275108375324277e2d6399f6119513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa275108375324277e2d6399f6119513">&#9670;&#160;</a></span>Value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; int64_t(const <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> &amp;)&gt; operations_research::sat::Value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This checks that the variable is fixed. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l01032">1032</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a007d129b4917935f84c9ae0823c2cb11" name="a007d129b4917935f84c9ae0823c2cb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007d129b4917935f84c9ae0823c2cb11">&#9670;&#160;</a></span>VarDebugString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::VarDebugString </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001199">Todo</a></b></dt><dd>(user): unfortunately, we need this indirection to get a DebugString() in a const way from an index. Because building an <a class="el" href="classoperations__research_1_1sat_1_1IntVar.html">IntVar</a> is non-const. </dd></dl>
<p>Returns a more readable and compact DebugString() than proto.variables(index).DebugString(). This is used by <a class="el" href="classoperations__research_1_1sat_1_1IntVar.html#aac78f1c00b73fbad7bd6577181f537fb">IntVar::DebugString()</a> but also allow to get the same string from a const proto. </p>
<p>Special case for constant variables without names.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001200">Todo</a></b></dt><dd>(user): Use domain pretty print function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model_8cc_source.html#l00143">143</a> of file <a class="el" href="cp__model_8cc_source.html">cp_model.cc</a>.</p>

</div>
</div>
<a id="ae2544d2a3a5ef4c78f8e5891f104ab41" name="ae2544d2a3a5ef4c78f8e5891f104ab41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2544d2a3a5ef4c78f8e5891f104ab41">&#9670;&#160;</a></span>VariableIsPositive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::VariableIsPositive </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer__base_8h_source.html#l00159">159</a> of file <a class="el" href="integer__base_8h_source.html">integer_base.h</a>.</p>

</div>
</div>
<a id="a7fc73d43252c02a3d538fd5bbf1f2aec" name="a7fc73d43252c02a3d538fd5bbf1f2aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc73d43252c02a3d538fd5bbf1f2aec">&#9670;&#160;</a></span>WeightedPick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::WeightedPick </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>random</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is equivalent of absl::discrete_distribution&lt;std::size_t&gt;(input.begin(), input.end())(random) but does no allocations. It is a lot faster when you need to pick just one elements from a distribution for instance. </p>

<p class="definition">Definition at line <a class="el" href="sat_2util_8cc_source.html#l00426">426</a> of file <a class="el" href="sat_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="a2c2f7e39e8f0fd691b6efe8f2ff4c86a" name="a2c2f7e39e8f0fd691b6efe8f2ff4c86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2f7e39e8f0fd691b6efe8f2ff4c86a">&#9670;&#160;</a></span>WeightedSumGreaterOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::WeightedSumGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorInt &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weighted sum &gt;= constant. </p>
<p>We just negate everything and use an &lt;= constraints.</p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00449">449</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="aff1ffcc62b140fdca347aa4e5c381b3b" name="aff1ffcc62b140fdca347aa4e5c381b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1ffcc62b140fdca347aa4e5c381b3b">&#9670;&#160;</a></span>WeightedSumLowerOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *)&gt; operations_research::sat::WeightedSumLowerOrEqual </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorInt &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weighted sum &lt;= constant. </p>
<p><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> based functions. </p>

<p class="definition">Definition at line <a class="el" href="integer__expr_8h_source.html#l00437">437</a> of file <a class="el" href="integer__expr_8h_source.html">integer_expr.h</a>.</p>

</div>
</div>
<a id="a46450179bd4a1af484e23da5557aef2a" name="a46450179bd4a1af484e23da5557aef2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46450179bd4a1af484e23da5557aef2a">&#9670;&#160;</a></span>WriteModelProtoToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::WriteModelProtoToFile </td>
          <td>(</td>
          <td class="paramtype">const M &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00331">331</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aea68c208c5e7f0abb9afc90d9188d3d4" name="aea68c208c5e7f0abb9afc90d9188d3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea68c208c5e7f0abb9afc90d9188d3d4">&#9670;&#160;</a></span>b</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">for operations_research::sat::b = 0 <a class="el" href="parser_8yy_8cc.html#a33e91cd0cef6786e9e3a27ac67707207">if</a> j &gt; <a class="el" href="#ab0c36038a18f65060a8232934b26cb7e">i</a>+1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diophantine_8h_source.html#l00100">100</a> of file <a class="el" href="diophantine_8h_source.html">diophantine.h</a>.</p>

</div>
</div>
<a id="ab0c36038a18f65060a8232934b26cb7e" name="ab0c36038a18f65060a8232934b26cb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c36038a18f65060a8232934b26cb7e">&#9670;&#160;</a></span>i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">for operations_research::sat::i = 0 ... k-2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives a parametric description of the solutions of the Diophantine equation with n variables: sum(coeffs[i] * x[i]) = rhs. var_lbs and var_ubs are bounds on desired values for variables x_i's.</p>
<p>It is known that, ignoring variable bounds, the set of solutions of such an equation is</p><ol type="1">
<li>either empty if the gcd(coeffs[i]) does not divide rhs;</li>
<li>or the sum of a special solution and an element of the kernel of the equation. In case 1, the function return .has_solution = false; In case 2, if one coefficient is equal to the GCD of all (in absolute value), returns .no_reformulation_needed = true. Otherwise, it behaves as follows:</li>
</ol>
<p>The kernel of the equation as dimension n-1.</p>
<p>We assume we permute the variable by index_permutation, such that the first k k terms have a gcd equal to the gcd of all coefficient (it is possible to do this with k &lt;= 15). Under this assumption, we can find:</p><ul>
<li>a special solution that is entirely supported by the k first variables;</li>
<li>a basis {b[0], b[1], ..., b[n-2]} of the kernel such that: </li>
</ul>

<p class="definition">Definition at line <a class="el" href="diophantine_8h_source.html#l00100">100</a> of file <a class="el" href="diophantine_8h_source.html">diophantine.h</a>.</p>

</div>
</div>
<a id="a7e3872788ea20ace515221011452ce03" name="a7e3872788ea20ace515221011452ce03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3872788ea20ace515221011452ce03">&#9670;&#160;</a></span>kAffineRelationConstraint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::kAffineRelationConstraint = -2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00054">54</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a808ec1fa0c9026293a5f6f0fc5e1236e" name="a808ec1fa0c9026293a5f6f0fc5e1236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808ec1fa0c9026293a5f6f0fc5e1236e">&#9670;&#160;</a></span>kAssumptionsConstraint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::kAssumptionsConstraint = -3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00055">55</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a12e7f8bfb4546fdd870155aea927cbd2" name="a12e7f8bfb4546fdd870155aea927cbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7f8bfb4546fdd870155aea927cbd2">&#9670;&#160;</a></span>kDefaultFingerprintSeed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t operations_research::sat::kDefaultFingerprintSeed = 0xa5b85c5e198ed849</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default seed for fingerprints. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__utils_8h_source.html#l00286">286</a> of file <a class="el" href="cp__model__utils_8h_source.html">cp_model_utils.h</a>.</p>

</div>
</div>
<a id="a073868a91ec87d04bc963609af7806b6" name="a073868a91ec87d04bc963609af7806b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073868a91ec87d04bc963609af7806b6">&#9670;&#160;</a></span>kInfinity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::glop::kInfinity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infinity for type <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>. </p>

<p class="definition">Definition at line <a class="el" href="lp__types_8h_source.html#l00087">87</a> of file <a class="el" href="lp__types_8h_source.html">lp_types.h</a>.</p>

</div>
</div>
<a id="ad0e83800af0856c335c499d4bf32c900" name="ad0e83800af0856c335c499d4bf32c900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e83800af0856c335c499d4bf32c900">&#9670;&#160;</a></span>kMaxProblemSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::kMaxProblemSize = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="2d__packing__brute__force_8cc_source.html#l00034">34</a> of file <a class="el" href="2d__packing__brute__force_8cc_source.html">2d_packing_brute_force.cc</a>.</p>

</div>
</div>
<a id="a9b7e34d84dd16d6b24f271692624c394" name="a9b7e34d84dd16d6b24f271692624c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7e34d84dd16d6b24f271692624c394">&#9670;&#160;</a></span>kObjectiveConstraint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::kObjectiveConstraint = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We use some special constraint index in our variable &lt;-&gt; constraint graph. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00053">53</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a0703b6fa9bb29801da1f26884386e05f" name="a0703b6fa9bb29801da1f26884386e05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0703b6fa9bb29801da1f26884386e05f">&#9670;&#160;</a></span>kTableAnyValue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::kTableAnyValue = std::numeric_limits&lt;int64_t&gt;::min()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method tries to compress a list of tuples by merging complementary tuples, that is a set of tuples that only differ on one variable, and that cover the domain of the variable. In that case, it will keep only one tuple, and replace the value for variable by any_value, the equivalent of '*' in regexps.</p>
<p>This method is exposed for testing purposes. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__table_8h_source.html#l00043">43</a> of file <a class="el" href="cp__model__table_8h_source.html">cp_model_table.h</a>.</p>

</div>
</div>
<a id="acc68c12bf322c82aee0e2ccb202945d9" name="acc68c12bf322c82aee0e2ccb202945d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc68c12bf322c82aee0e2ccb202945d9">&#9670;&#160;</a></span>kUnsatTrailIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int operations_research::sat::kUnsatTrailIndex = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant used by the EnqueueDecision*() API. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00054">54</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
