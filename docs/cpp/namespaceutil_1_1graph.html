<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: util::graph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.10</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceutil_1_1graph.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">util::graph Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a64d412571923330f6b2b1036377b6c43" id="r_a64d412571923330f6b2b1036377b6c43"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> , class NodeIndex  = int&gt; </td></tr>
<tr class="memitem:a64d412571923330f6b2b1036377b6c43"><td class="memTemplItemLeft" align="right" valign="top">absl::StatusOr&lt; std::vector&lt; NodeIndex &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a64d412571923330f6b2b1036377b6c43">GetBFSRootedTree</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, NodeIndex num_nodes, NodeIndex source)</td></tr>
<tr class="separator:a64d412571923330f6b2b1036377b6c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae983373ed3b415fdda5b223bb0a40431" id="r_ae983373ed3b415fdda5b223bb0a40431"><td class="memTemplParams" colspan="2">template&lt;class NodeIndex &gt; </td></tr>
<tr class="memitem:ae983373ed3b415fdda5b223bb0a40431"><td class="memTemplItemLeft" align="right" valign="top">absl::StatusOr&lt; std::vector&lt; NodeIndex &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae983373ed3b415fdda5b223bb0a40431">GetBFSDistances</a> (const std::vector&lt; NodeIndex &gt; &amp;bfs_tree)</td></tr>
<tr class="separator:ae983373ed3b415fdda5b223bb0a40431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d4e06c981eff78332549151ac55f2f" id="r_a37d4e06c981eff78332549151ac55f2f"><td class="memTemplParams" colspan="2">template&lt;class NodeIndex &gt; </td></tr>
<tr class="memitem:a37d4e06c981eff78332549151ac55f2f"><td class="memTemplItemLeft" align="right" valign="top">absl::StatusOr&lt; std::vector&lt; NodeIndex &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a37d4e06c981eff78332549151ac55f2f">GetBFSShortestPath</a> (const std::vector&lt; NodeIndex &gt; &amp;bfs_tree, NodeIndex target)</td></tr>
<tr class="separator:a37d4e06c981eff78332549151ac55f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7ab592842225bf80afd735048a0e0e" id="r_a0d7ab592842225bf80afd735048a0e0e"><td class="memTemplParams" colspan="2">template&lt;class AdjacencyLists &gt; </td></tr>
<tr class="memitem:a0d7ab592842225bf80afd735048a0e0e"><td class="memTemplItemLeft" align="right" valign="top">absl::StatusOr&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d7ab592842225bf80afd735048a0e0e">FastTopologicalSort</a> (const AdjacencyLists &amp;adj)</td></tr>
<tr class="separator:a0d7ab592842225bf80afd735048a0e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440afdf238e5a752bbe4e1bcc8878fe7" id="r_a440afdf238e5a752bbe4e1bcc8878fe7"><td class="memTemplParams" colspan="2">template&lt;class AdjacencyLists &gt; </td></tr>
<tr class="memitem:a440afdf238e5a752bbe4e1bcc8878fe7"><td class="memTemplItemLeft" align="right" valign="top">absl::StatusOr&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a440afdf238e5a752bbe4e1bcc8878fe7">FindCycleInGraph</a> (const AdjacencyLists &amp;adj)</td></tr>
<tr class="separator:a440afdf238e5a752bbe4e1bcc8878fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c544f7c7c323eb16a64389b95b79458" id="r_a5c544f7c7c323eb16a64389b95b79458"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c544f7c7c323eb16a64389b95b79458">DenseIntTopologicalSortOrDie</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="separator:a5c544f7c7c323eb16a64389b95b79458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b429182836eddf34189e5af39f1e886" id="r_a1b429182836eddf34189e5af39f1e886"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b429182836eddf34189e5af39f1e886">DenseIntStableTopologicalSortOrDie</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="separator:a1b429182836eddf34189e5af39f1e886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcd58ffa60a8a68fb960ff41deba777" id="r_a4bcd58ffa60a8a68fb960ff41deba777"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bcd58ffa60a8a68fb960ff41deba777"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4bcd58ffa60a8a68fb960ff41deba777">StableTopologicalSortOrDie</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs)</td></tr>
<tr class="separator:a4bcd58ffa60a8a68fb960ff41deba777"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1b429182836eddf34189e5af39f1e886" name="a1b429182836eddf34189e5af39f1e886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b429182836eddf34189e5af39f1e886">&#9670;&#160;</a></span>DenseIntStableTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::graph::DenseIntStableTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00607">607</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a5c544f7c7c323eb16a64389b95b79458" name="a5c544f7c7c323eb16a64389b95b79458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c544f7c7c323eb16a64389b95b79458">&#9670;&#160;</a></span>DenseIntTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::graph::DenseIntTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00603">603</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a0d7ab592842225bf80afd735048a0e0e" name="a0d7ab592842225bf80afd735048a0e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7ab592842225bf80afd735048a0e0e">&#9670;&#160;</a></span>FastTopologicalSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AdjacencyLists &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; std::vector&lt; int &gt; &gt; util::graph::FastTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const AdjacencyLists &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the recommended API when performance matters. It's also very simple. AdjacencyList is any type that lets you iterate over the neighbors of node with the [] operator, for example vector&lt;vector&lt;int&gt;&gt; or <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">util::Graph</a>.</p>
<p>If you don't already have an adjacency list representation, build one using StaticGraph&lt;&gt; in ./graph.h: <a class="el" href="#a0d7ab592842225bf80afd735048a0e0e">FastTopologicalSort()</a> can take any such graph as input.</p>
<p>ERRORS: returns InvalidArgumentError if the input is broken (negative or out-of-bounds integers) or if the graph is cyclic. In the latter case, the error message will contain "cycle". Note that if cycles may occur in your input, you can probably assume that your input isn't broken, and thus rely on failures to detect that the graph is cyclic.</p>
<p>TIE BREAKING: the returned topological order is deterministic and fixed, and corresponds to iterating on nodes in a LIFO (Breadth-first) order.</p>
<p>Benchmark: gpaste/6147236302946304, 4-10x faster than util_graph::TopoSort().</p>
<p>EXAMPLES: std::vector&lt;std::vector&lt;int&gt;&gt; adj = {{..}, {..}, ..}; <a class="el" href="base_2status__macros_8h.html#a600de4b8f65fe0a4b1898041634f9011">ASSIGN_OR_RETURN(std::vector&lt;int&gt; topo_order, FastTopologicalSort(adj))</a>;</p>
<p>or std::vector&lt;pair&lt;int, int&gt;&gt; arcs = {{.., ..}, ..., }; ASSIGN_OR_RETURN( std::vector&lt;int&gt; topo_order, FastTopologicalSort(util::StaticGraph&lt;&gt;::FromArcs(num_nodes, arcs))); </p>
<p>We cast to unsigned int to test "head &lt; 0 || head ≥ num_nodes" with a single test. Microbenchmarks showed a ~1% overall performance gain.</p>
<p>NOTE(user): We could detect self-arcs here (head == from) and exit early, but microbenchmarks show a 2 to 4% slow-down if we do it, so we simply rely on self-arcs being detected as cycles in the topo sort.</p>
<p>We cast to unsigned int to test "head &lt; 0 || head ≥ num_nodes" with a single test. Microbenchmarks showed a ~1% overall performance gain.</p>
<p>NOTE(user): We could detect self-arcs here (head == from) and exit early, but microbenchmarks show a 2 to 4% slow-down if we do it, so we simply rely on self-arcs being detected as cycles in the topo sort.</p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00618">618</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a440afdf238e5a752bbe4e1bcc8878fe7" name="a440afdf238e5a752bbe4e1bcc8878fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440afdf238e5a752bbe4e1bcc8878fe7">&#9670;&#160;</a></span>FindCycleInGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AdjacencyLists &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; std::vector&lt; int &gt; &gt; util::graph::FindCycleInGraph </td>
          <td>(</td>
          <td class="paramtype">const AdjacencyLists &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a cycle in the directed graph given as argument: nodes are dense integers in 0..num_nodes-1, and (directed) arcs are pairs of nodes {from, to}. The returned cycle is a list of nodes that form a cycle, eg. {1, 4, 3} if the cycle 1-&gt;4-&gt;3-&gt;1 exists. If the graph is acyclic, returns an empty vector. </p>
<p>To find a cycle, we start a DFS from each yet-unvisited node and try to find a cycle, if we don't find it then we know for sure that no cycle is reachable from any of the explored nodes (so, we don't explore them in later DFSs).</p>
<p>The DFS stack will contain a chain of nodes, from the root of the DFS to the current leaf.</p>
<p>Points at the first child node that we did <em>not</em> yet look at.</p>
<p>Start the DFS.</p>
<p>Look at the current child, and increase the current state's adj_list_index. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000718">Todo</a></b></dt><dd>(user): Caching adj[cur_state-&gt;node] in a local stack to improve locality and so that the [] operator is called exactly once per node. </dd></dl>
<p>We detected a cycle! It corresponds to the tail end of dfs_stack, in reverse order, until we find "child".</p>
<p>Push the child onto the stack.</p>
<p>Verify that its adjacency list seems valid.</p>
<p>If we're here, then all the DFS stopped, and there is no cycle.</p>
<p>To find a cycle, we start a DFS from each yet-unvisited node and try to find a cycle, if we don't find it then we know for sure that no cycle is reachable from any of the explored nodes (so, we don't explore them in later DFSs).</p>
<p>The DFS stack will contain a chain of nodes, from the root of the DFS to the current leaf.</p>
<p>Points at the first child node that we did <em>not</em> yet look at.</p>
<p>Start the DFS.</p>
<p>Look at the current child, and increase the current state's adj_list_index. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000718">Todo</a></b></dt><dd>(user): Caching adj[cur_state-&gt;node] in a local stack to improve locality and so that the [] operator is called exactly once per node. </dd></dl>
<p>We detected a cycle! It corresponds to the tail end of dfs_stack, in reverse order, until we find "child".</p>
<p>Push the child onto the stack.</p>
<p>Verify that its adjacency list seems valid.</p>
<p>If we're here, then all the DFS stopped, and there is no cycle.</p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00659">659</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ae983373ed3b415fdda5b223bb0a40431" name="ae983373ed3b415fdda5b223bb0a40431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae983373ed3b415fdda5b223bb0a40431">&#9670;&#160;</a></span>GetBFSDistances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; std::vector&lt; NodeIndex &gt; &gt; util::graph::GetBFSDistances </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; NodeIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bfs_tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distances of all nodes from the source, in O(num_nodes). <code>bfs_tree</code> must be exactly as returned by <a class="el" href="#a64d412571923330f6b2b1036377b6c43">GetBFSRootedTree()</a>. </p><dl class="section note"><dt>Note</dt><dd>Supports BFS forests, i.e. the result of a BFS from multiple sources. </dd></dl>
<p>Run a few checks on the input first.</p>
<p>The algorithm starts.</p>
<p>Ascend the parent tree until we reach either the root (the BFS source), or an already-marked node (whose distance we already know).</p>
<p>We've reached the root or an already-marked node. Update our distance.</p>
<p>Now ascend the path a second time, to mark the distances of all nodes on the path.</p>
<p>Run a few checks on the input first.</p>
<p>The algorithm starts.</p>
<p>Ascend the parent tree until we reach either the root (the BFS source), or an already-marked node (whose distance we already know).</p>
<p>We've reached the root or an already-marked node. Update our distance.</p>
<p>Now ascend the path a second time, to mark the distances of all nodes on the path.</p>

<p class="definition">Definition at line <a class="el" href="bfs_8h_source.html#l00135">135</a> of file <a class="el" href="bfs_8h_source.html">bfs.h</a>.</p>

</div>
</div>
<a id="a64d412571923330f6b2b1036377b6c43" name="a64d412571923330f6b2b1036377b6c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d412571923330f6b2b1036377b6c43">&#9670;&#160;</a></span>GetBFSRootedTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> , class NodeIndex  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; std::vector&lt; NodeIndex &gt; &gt; util::graph::GetBFSRootedTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeIndex</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeIndex</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs a BFS (Breadth First Search) in O(num_nodes + num_arcs), and returns the BFS tree rooted at the source: returned element #i is either:</p><ul>
<li>the parent of node #i, i.e. the node that precedes it in the shortest path from the source to i;</li>
<li>or -1, if the node wasn't reached;</li>
<li>or itself, i.e. i, if #i is the source.</li>
</ul>
<p>TIE BREAKING: This implementation always breaks tie the same way, by order in the adjacency lists. E.g. if all the adjacency lists are sorted, then the parent of a node in the BFS tree is always the smalled possible parent.</p>
<hr  />
<p> Implementation of the templates. </p>
<p>NOTE(user): -1 works fine for unsigned integers because 'num_nodes' is already an exclusive upper bound for node indices (and -1 unsigned can only be ≥ num_nodes).</p>
<p>NOTE(user): -1 works fine for unsigned integers because 'num_nodes' is already an exclusive upper bound for node indices (and -1 unsigned can only be ≥ num_nodes).</p>

<p class="definition">Definition at line <a class="el" href="bfs_8h_source.html#l00101">101</a> of file <a class="el" href="bfs_8h_source.html">bfs.h</a>.</p>

</div>
</div>
<a id="a37d4e06c981eff78332549151ac55f2f" name="a37d4e06c981eff78332549151ac55f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d4e06c981eff78332549151ac55f2f">&#9670;&#160;</a></span>GetBFSShortestPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; std::vector&lt; NodeIndex &gt; &gt; util::graph::GetBFSShortestPath </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; NodeIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bfs_tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeIndex</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the shortest path from the source to <code>target</code>, in O(path length). <code>bfs_tree</code> must be exactly as returned by <a class="el" href="#a64d412571923330f6b2b1036377b6c43">GetBFSRootedTree()</a>. If <code>target</code> wasn't reached in the BFS, returns the empty vector. Else the returned path always starts with the source and ends with the target (if source=target, returns [source]). </p>

<p class="definition">Definition at line <a class="el" href="bfs_8h_source.html#l00196">196</a> of file <a class="el" href="bfs_8h_source.html">bfs.h</a>.</p>

</div>
</div>
<a id="a4bcd58ffa60a8a68fb960ff41deba777" name="a4bcd58ffa60a8a68fb960ff41deba777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcd58ffa60a8a68fb960ff41deba777">&#9670;&#160;</a></span>StableTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; util::graph::StableTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00612">612</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutil.html">util</a></li><li class="navelem"><a class="el" href="namespaceutil_1_1graph.html">graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
