<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::pdlp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.5</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceoperations__research_1_1pdlp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">operations_research::pdlp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Validation utilities for <a class="el" href="solvers_8proto.html">solvers.proto</a>.  
<a href="namespaceoperations__research_1_1pdlp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceoperations__research_1_1pdlp_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespaceoperations__research_1_1pdlp_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for internal use only. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1RelativeConvergenceInformation.html">RelativeConvergenceInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1RescalingOptions.html">RescalingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1ScalingVectors.html">ScalingVectors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedWeightedAverage.html">ShardedWeightedAverage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8b49502c323652c8d4e9a3fd3dd5cda7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a> { <a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7a974f1270f89b99d15b58a4d35c26aedc">kMaxNorm</a>
, <a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7aaafbdb17e2f1da89be62331fa0cf5503">kEuclideanNorm</a>
 }</td></tr>
<tr class="separator:a8b49502c323652c8d4e9a3fd3dd5cda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad3a4f857c920478cbdc673571b69f660"><td class="memItemLeft" align="right" valign="top">ConvergenceInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ad3a4f857c920478cbdc673571b69f660">ComputeConvergenceInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;scaled_sharded_qp, const Eigen::VectorXd &amp;col_scaling_vec, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;scaled_primal_solution, const Eigen::VectorXd &amp;scaled_dual_solution, const double componentwise_primal_residual_offset, const double componentwise_dual_residual_offset, PointType candidate_type)</td></tr>
<tr class="separator:ad3a4f857c920478cbdc673571b69f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4a3d5eb9d440e6417eb339fad6568d"><td class="memItemLeft" align="right" valign="top">InfeasibilityInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aeb4a3d5eb9d440e6417eb339fad6568d">ComputeInfeasibilityInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;scaled_sharded_qp, const Eigen::VectorXd &amp;col_scaling_vec, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;scaled_primal_ray, const Eigen::VectorXd &amp;scaled_dual_ray, PointType candidate_type)</td></tr>
<tr class="separator:aeb4a3d5eb9d440e6417eb339fad6568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e1750531d2a33362a8b9b9158f5192"><td class="memItemLeft" align="right" valign="top">ConvergenceInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a91e1750531d2a33362a8b9b9158f5192">ComputeScaledConvergenceInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;primal_solution, const VectorXd &amp;dual_solution, const double componentwise_primal_residual_offset, const double componentwise_dual_residual_offset, PointType candidate_type)</td></tr>
<tr class="separator:a91e1750531d2a33362a8b9b9158f5192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fad6392722c357cd629f5dc9cbb94a2"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a3fad6392722c357cd629f5dc9cbb94a2">ReducedCosts</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;primal_solution, const VectorXd &amp;dual_solution, bool use_zero_primal_objective)</td></tr>
<tr class="separator:a3fad6392722c357cd629f5dc9cbb94a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22565ae8507a53fdd98f539757c11c2d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; ConvergenceInformation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a22565ae8507a53fdd98f539757c11c2d">GetConvergenceInformation</a> (const IterationStats &amp;stats, PointType candidate_type)</td></tr>
<tr class="separator:a22565ae8507a53fdd98f539757c11c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d133b011f79db6b38b39d967ba1106"><td class="memItemLeft" align="right" valign="top">std::optional&lt; InfeasibilityInformation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a46d133b011f79db6b38b39d967ba1106">GetInfeasibilityInformation</a> (const IterationStats &amp;stats, PointType candidate_type)</td></tr>
<tr class="separator:a46d133b011f79db6b38b39d967ba1106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaf9a260a4e9bd5ed462840b5ee9cb8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; PointMetadata &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a8aaf9a260a4e9bd5ed462840b5ee9cb8">GetPointMetadata</a> (const IterationStats &amp;stats, const PointType point_type)</td></tr>
<tr class="separator:a8aaf9a260a4e9bd5ed462840b5ee9cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3082edb885e96d187a000584cf2c3046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a3082edb885e96d187a000584cf2c3046">SetRandomProjections</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;primal_solution, const Eigen::VectorXd &amp;dual_solution, const std::vector&lt; int &gt; &amp;random_projection_seeds, PointMetadata &amp;metadata)</td></tr>
<tr class="separator:a3082edb885e96d187a000584cf2c3046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cba1e0f05d2dd4e3efb2587802f022"><td class="memItemLeft" align="right" valign="top">ConvergenceInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a67cba1e0f05d2dd4e3efb2587802f022">ComputeScaledConvergenceInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;primal_solution, const Eigen::VectorXd &amp;dual_solution, double componentwise_primal_residual_offset, double componentwise_dual_residual_offset, PointType candidate_type)</td></tr>
<tr class="separator:a67cba1e0f05d2dd4e3efb2587802f022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e56bcb1dbb063aac138bfaaeaca695a"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a6e56bcb1dbb063aac138bfaaeaca695a">ReducedCosts</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;scaled_sharded_qp, const Eigen::VectorXd &amp;primal_solution, const Eigen::VectorXd &amp;dual_solution, bool use_zero_primal_objective=false)</td></tr>
<tr class="separator:a6e56bcb1dbb063aac138bfaaeaca695a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43b4c39d3be5e0bced44530d50f8208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ac43b4c39d3be5e0bced44530d50f8208">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, const std::atomic&lt; bool &gt; *interrupt_solve, IterationStatsCallback iteration_stats_callback)</td></tr>
<tr class="separator:ac43b4c39d3be5e0bced44530d50f8208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5be3defc8ff241ecc00008c63569df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a5e5be3defc8ff241ecc00008c63569df">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt; initial_solution, const std::atomic&lt; bool &gt; *interrupt_solve, IterationStatsCallback iteration_stats_callback)</td></tr>
<tr class="separator:a5e5be3defc8ff241ecc00008c63569df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f489ba459dad7b5491ec327d8340f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a333f489ba459dad7b5491ec327d8340f">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, const std::atomic&lt; bool &gt; *interrupt_solve=nullptr, std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt; iteration_stats_callback=nullptr)</td></tr>
<tr class="separator:a333f489ba459dad7b5491ec327d8340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96f89f313a2d89099e740349e02214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a7b96f89f313a2d89099e740349e02214">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt; initial_solution, const std::atomic&lt; bool &gt; *interrupt_solve=nullptr, std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt; iteration_stats_callback=nullptr)</td></tr>
<tr class="separator:a7b96f89f313a2d89099e740349e02214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d607529c02f2842bdc5cb9c918bd1b"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a29d607529c02f2842bdc5cb9c918bd1b">ValidateQuadraticProgramDimensions</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:a29d607529c02f2842bdc5cb9c918bd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aeab0f9534091e49e800a82445edc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aa4aeab0f9534091e49e800a82445edc2">HasValidBounds</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:aa4aeab0f9534091e49e800a82445edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f90c55cdcb499205898fd7f90da6f3"><td class="memItemLeft" align="right" valign="top">absl::StatusOr&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a70f90c55cdcb499205898fd7f90da6f3">QpFromMpModelProto</a> (const MPModelProto &amp;<a class="el" href="cp__model__fz__solver_8cc.html#aed003f5eb5197bc586b7ef2c36a63da2">proto</a>, bool relax_integer_variables, bool include_names)</td></tr>
<tr class="separator:a70f90c55cdcb499205898fd7f90da6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98a981710e58e6eead1ca6c76f7b2b7"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ad98a981710e58e6eead1ca6c76f7b2b7">CanFitInMpModelProto</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:ad98a981710e58e6eead1ca6c76f7b2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fc89d57cdfcdd70d122ffc32fb015d"><td class="memItemLeft" align="right" valign="top">absl::StatusOr&lt; MPModelProto &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a03fc89d57cdfcdd70d122ffc32fb015d">QpToMpModelProto</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:a03fc89d57cdfcdd70d122ffc32fb015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bf48ca920aa5abf755b21a3a938e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ab5bf48ca920aa5abf755b21a3a938e72">SetEigenMatrixFromTriplets</a> (std::vector&lt; Eigen::Triplet&lt; double, int64_t &gt; &gt; triplets, Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix)</td></tr>
<tr class="separator:ab5bf48ca920aa5abf755b21a3a938e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850865b3deabb2a623e130691df99f15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a850865b3deabb2a623e130691df99f15">IsLinearProgram</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:a850865b3deabb2a623e130691df99f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b7dc41ed788020cbaf942674f623d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a80b7dc41ed788020cbaf942674f623d9">ReadQuadraticProgramOrDie</a> (const std::string &amp;filename, bool include_names)</td></tr>
<tr class="separator:a80b7dc41ed788020cbaf942674f623d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae83b2a0a223071e9c8a20cc2d8c0664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aae83b2a0a223071e9c8a20cc2d8c0664">ReadMpsLinearProgramOrDie</a> (const std::string &amp;lp_file, bool include_names)</td></tr>
<tr class="separator:aae83b2a0a223071e9c8a20cc2d8c0664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bff54df141c92a98fb14a56a06417c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a40bff54df141c92a98fb14a56a06417c">ReadMPModelProtoFileOrDie</a> (const std::string &amp;mpmodel_proto_file, bool include_names)</td></tr>
<tr class="separator:a40bff54df141c92a98fb14a56a06417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efbc8bad87c896ca3c29f6ab4f969e5"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a9efbc8bad87c896ca3c29f6ab4f969e5">WriteLinearProgramToMps</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;linear_program, const std::string &amp;mps_file)</td></tr>
<tr class="separator:a9efbc8bad87c896ca3c29f6ab4f969e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69097fbe470f9bdb4110f2c54455926"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ac69097fbe470f9bdb4110f2c54455926">WriteQuadraticProgramToMPModelProto</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;quadratic_program, const std::string &amp;mpmodel_proto_file)</td></tr>
<tr class="separator:ac69097fbe470f9bdb4110f2c54455926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c351ac6432daa4ea00cef61ced76c8"><td class="memItemLeft" align="right" valign="top">QuadraticProgramStats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aa9c351ac6432daa4ea00cef61ced76c8">ComputeStats</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;qp, double infinite_constraint_bound_threshold=std::numeric_limits&lt; double &gt;::infinity())</td></tr>
<tr class="memdesc:aa9c351ac6432daa4ea00cef61ced76c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a QuadraticProgramStats object for a <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a>.  <br /></td></tr>
<tr class="separator:aa9c351ac6432daa4ea00cef61ced76c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ded6625965f8ddd342161a55263cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a54ded6625965f8ddd342161a55263cce">LInfRuizRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const int num_iterations, VectorXd &amp;row_scaling_vec, VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:a54ded6625965f8ddd342161a55263cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dee2894b8028a57b7f7d2306b402e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a9dee2894b8028a57b7f7d2306b402e44">L2NormRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, VectorXd &amp;row_scaling_vec, VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:a9dee2894b8028a57b7f7d2306b402e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6db4184272e326213cd4a7ddc1cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1ScalingVectors.html">ScalingVectors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#acea6db4184272e326213cd4a7ddc1cd4">ApplyRescaling</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1RescalingOptions.html">RescalingOptions</a> &amp;rescaling_options, <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp)</td></tr>
<tr class="separator:acea6db4184272e326213cd4a7ddc1cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259d3f73717a2ababa9df2dd43914656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a259d3f73717a2ababa9df2dd43914656">ComputePrimalGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;primal_solution, const VectorXd &amp;dual_product)</td></tr>
<tr class="separator:a259d3f73717a2ababa9df2dd43914656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d94aed55433c303286276bc57a8d77e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a8d94aed55433c303286276bc57a8d77e">DualSubgradientCoefficient</a> (const double constraint_lower_bound, const double constraint_upper_bound, const double dual, const double primal_product)</td></tr>
<tr class="separator:a8d94aed55433c303286276bc57a8d77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0a68c36dafae816b5d18fdf7f4f2d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a0b0a68c36dafae816b5d18fdf7f4f2d1">ComputeDualGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;dual_solution, const VectorXd &amp;primal_product)</td></tr>
<tr class="separator:a0b0a68c36dafae816b5d18fdf7f4f2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6985b8c7ce87b3858b50efa4a923a0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a6985b8c7ce87b3858b50efa4a923a0eb">EstimateMaximumSingularValueOfConstraintMatrix</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const std::optional&lt; VectorXd &gt; &amp;primal_solution, const std::optional&lt; VectorXd &gt; &amp;dual_solution, const double desired_relative_error, const double failure_probability, std::mt19937 &amp;mt_generator)</td></tr>
<tr class="separator:a6985b8c7ce87b3858b50efa4a923a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc88d1ca95af991600037eaf027f081b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#acc88d1ca95af991600037eaf027f081b">HasValidBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp)</td></tr>
<tr class="separator:acc88d1ca95af991600037eaf027f081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7f29f435d6c9fc53148ee403c7049e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#acb7f29f435d6c9fc53148ee403c7049e">ProjectToPrimalVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, VectorXd &amp;primal)</td></tr>
<tr class="separator:acb7f29f435d6c9fc53148ee403c7049e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898c0c776a5736cf1931036d0d370724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a898c0c776a5736cf1931036d0d370724">ProjectToDualVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, VectorXd &amp;dual)</td></tr>
<tr class="separator:a898c0c776a5736cf1931036d0d370724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b6d816e6a31a4c4964f5592ed8c056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a39b6d816e6a31a4c4964f5592ed8c056">LInfRuizRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const int num_iterations, Eigen::VectorXd &amp;row_scaling_vec, Eigen::VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:a39b6d816e6a31a4c4964f5592ed8c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41379e6fa8d7e6e6e8151c256906970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#af41379e6fa8d7e6e6e8151c256906970">L2NormRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, Eigen::VectorXd &amp;row_scaling_vec, Eigen::VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:af41379e6fa8d7e6e6e8151c256906970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe180ee4e003e6a819c90205bf38b60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#abe180ee4e003e6a819c90205bf38b60f">ComputePrimalGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;primal_solution, const Eigen::VectorXd &amp;dual_product)</td></tr>
<tr class="separator:abe180ee4e003e6a819c90205bf38b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fca5ce03ac69c5ca4e0db9d39d62e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a96fca5ce03ac69c5ca4e0db9d39d62e0">ComputeDualGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;dual_solution, const Eigen::VectorXd &amp;primal_product)</td></tr>
<tr class="separator:a96fca5ce03ac69c5ca4e0db9d39d62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a017d5b14d16ecb6edb0216c5955280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a6a017d5b14d16ecb6edb0216c5955280">EstimateMaximumSingularValueOfConstraintMatrix</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const std::optional&lt; Eigen::VectorXd &gt; &amp;primal_solution, const std::optional&lt; Eigen::VectorXd &gt; &amp;dual_solution, const double desired_relative_error, const double failure_probability, std::mt19937 &amp;mt_generator)</td></tr>
<tr class="separator:a6a017d5b14d16ecb6edb0216c5955280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f1c93e7c9a345a90874f314196d1aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a03f1c93e7c9a345a90874f314196d1aa">ProjectToPrimalVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, Eigen::VectorXd &amp;primal)</td></tr>
<tr class="memdesc:a03f1c93e7c9a345a90874f314196d1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a primal vector onto the variable bounds constraints.  <br /></td></tr>
<tr class="separator:a03f1c93e7c9a345a90874f314196d1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b46c4812be8af75325d63ed3ced80f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a4b46c4812be8af75325d63ed3ced80f0">ProjectToDualVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, Eigen::VectorXd &amp;dual)</td></tr>
<tr class="separator:a4b46c4812be8af75325d63ed3ced80f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463586ded0a114d3ca4b97a048d37d8a"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a463586ded0a114d3ca4b97a048d37d8a">TransposedMatrixVectorProduct</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a463586ded0a114d3ca4b97a048d37d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d987d5d30e76fbbe2c32174eb3a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a070d987d5d30e76fbbe2c32174eb3a4e">SetZero</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a070d987d5d30e76fbbe2c32174eb3a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9385d74b2577097ab755dbf9c4f7c2ff"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a9385d74b2577097ab755dbf9c4f7c2ff">ZeroVector</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a9385d74b2577097ab755dbf9c4f7c2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like VectorXd::Zero(sharder.NumElements())  <br /></td></tr>
<tr class="separator:a9385d74b2577097ab755dbf9c4f7c2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd7d091bd562c2141e811478aaaa991"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#acbd7d091bd562c2141e811478aaaa991">OnesVector</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:acbd7d091bd562c2141e811478aaaa991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like VectorXd::Ones(sharder.NumElements())  <br /></td></tr>
<tr class="separator:acbd7d091bd562c2141e811478aaaa991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904cea6c14ac90eea354da5d70ec1719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a904cea6c14ac90eea354da5d70ec1719">AddScaledVector</a> (const double scale, const VectorXd &amp;increment, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a904cea6c14ac90eea354da5d70ec1719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca8f74da7e8301c8aee45f33c93896c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#afca8f74da7e8301c8aee45f33c93896c">AssignVector</a> (const VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:afca8f74da7e8301c8aee45f33c93896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a3bad4a7c95a6d68387ba8ae8c104"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aaa4a3bad4a7c95a6d68387ba8ae8c104">CloneVector</a> (const VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aaa4a3bad4a7c95a6d68387ba8ae8c104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920005e41b36a7a0c7f4ad148ad7069d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a920005e41b36a7a0c7f4ad148ad7069d">CoefficientWiseProductInPlace</a> (const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a920005e41b36a7a0c7f4ad148ad7069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c8ca6bf2bb288c322e1d8fbd6ea2bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a92c8ca6bf2bb288c322e1d8fbd6ea2bc">CoefficientWiseQuotientInPlace</a> (const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a92c8ca6bf2bb288c322e1d8fbd6ea2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11831586b99d28a708bc103bce1a945e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a11831586b99d28a708bc103bce1a945e">Dot</a> (const VectorXd &amp;v1, const VectorXd &amp;v2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a11831586b99d28a708bc103bce1a945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a42241df5501b0165ee77c3de54d7f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a33a42241df5501b0165ee77c3de54d7f">LInfNorm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a33a42241df5501b0165ee77c3de54d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa577696ad9121b3f002cd37de6f86989"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aa577696ad9121b3f002cd37de6f86989">L1Norm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aa577696ad9121b3f002cd37de6f86989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051e8994e91729e038b6cab678ef5f89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a051e8994e91729e038b6cab678ef5f89">SquaredNorm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a051e8994e91729e038b6cab678ef5f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade56a0bd875b06000c45e1730398e5a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ade56a0bd875b06000c45e1730398e5a8">Norm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:ade56a0bd875b06000c45e1730398e5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32389515e696df20cec86493cf9852e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a32389515e696df20cec86493cf9852e6">SquaredDistance</a> (const VectorXd &amp;vector1, const VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a32389515e696df20cec86493cf9852e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e28f45b9c1ccdec8d926b4034d3679b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a3e28f45b9c1ccdec8d926b4034d3679b">Distance</a> (const VectorXd &amp;vector1, const VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a3e28f45b9c1ccdec8d926b4034d3679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b8c43a5adfafddb030074c75aeef70"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a55b8c43a5adfafddb030074c75aeef70">ScaledLInfNorm</a> (const VectorXd &amp;vector, const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a55b8c43a5adfafddb030074c75aeef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f71a53d7766ac4c753d2218887cf98"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a65f71a53d7766ac4c753d2218887cf98">ScaledSquaredNorm</a> (const VectorXd &amp;vector, const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a65f71a53d7766ac4c753d2218887cf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b812156619599417e29521a41b7a734"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a0b812156619599417e29521a41b7a734">ScaledNorm</a> (const VectorXd &amp;vector, const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a0b812156619599417e29521a41b7a734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a3cf251337531692721a574033a9df"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a69a3cf251337531692721a574033a9df">ScaledColLInfNorm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const VectorXd &amp;row_scaling_vec, const VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a69a3cf251337531692721a574033a9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c5dd95681fe94691be1407d6bb62aa"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aa3c5dd95681fe94691be1407d6bb62aa">ScaledColL2Norm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const VectorXd &amp;row_scaling_vec, const VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aa3c5dd95681fe94691be1407d6bb62aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2cdcdbe1010ad09a8d2c6fe8bc8645"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aef2cdcdbe1010ad09a8d2c6fe8bc8645">TransposedMatrixVectorProduct</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aef2cdcdbe1010ad09a8d2c6fe8bc8645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b78b2d2b8f14df64e2d6def3ab5545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ad8b78b2d2b8f14df64e2d6def3ab5545">SetZero</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="separator:ad8b78b2d2b8f14df64e2d6def3ab5545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b08cd6ba4e025f1df1ec41261e14db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a62b08cd6ba4e025f1df1ec41261e14db">AddScaledVector</a> (double scale, const Eigen::VectorXd &amp;increment, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:a62b08cd6ba4e025f1df1ec41261e14db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like dest += scale * increment.  <br /></td></tr>
<tr class="separator:a62b08cd6ba4e025f1df1ec41261e14db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa393d2c90adfa983d1625e6e409d4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#afa393d2c90adfa983d1625e6e409d4f7">AssignVector</a> (const Eigen::VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:afa393d2c90adfa983d1625e6e409d4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like dest = vec. dest is resized if needed.  <br /></td></tr>
<tr class="separator:afa393d2c90adfa983d1625e6e409d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed237f4d1a54c4da63c16cc38baf030"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a3ed237f4d1a54c4da63c16cc38baf030">CloneVector</a> (const Eigen::VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a3ed237f4d1a54c4da63c16cc38baf030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of vec.  <br /></td></tr>
<tr class="separator:a3ed237f4d1a54c4da63c16cc38baf030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e7e8dab386b40f5984525566c9709f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#af2e7e8dab386b40f5984525566c9709f">CoefficientWiseProductInPlace</a> (const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:af2e7e8dab386b40f5984525566c9709f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like dest = dest.cwiseProduct(scale).  <br /></td></tr>
<tr class="separator:af2e7e8dab386b40f5984525566c9709f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ba879295782a2f85c4903e0de21cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ae3ba879295782a2f85c4903e0de21cbe">CoefficientWiseQuotientInPlace</a> (const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:ae3ba879295782a2f85c4903e0de21cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like dest = dest.cwiseQuotient(scale).  <br /></td></tr>
<tr class="separator:ae3ba879295782a2f85c4903e0de21cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa51fc5a2896d98a940cc367c5bbfe5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#adfa51fc5a2896d98a940cc367c5bbfe5">Dot</a> (const Eigen::VectorXd &amp;v1, const Eigen::VectorXd &amp;v2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:adfa51fc5a2896d98a940cc367c5bbfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like v1.dot(v2)  <br /></td></tr>
<tr class="separator:adfa51fc5a2896d98a940cc367c5bbfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cbc527d8c2c204dbd36be85cc4569d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ab2cbc527d8c2c204dbd36be85cc4569d">LInfNorm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ab2cbc527d8c2c204dbd36be85cc4569d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like vector.lpNorm&lt;Eigen::Infinity&gt;(), a.k.a. LInf norm.  <br /></td></tr>
<tr class="separator:ab2cbc527d8c2c204dbd36be85cc4569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e75bc358dc64d1dc080cb311acd449"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a45e75bc358dc64d1dc080cb311acd449">L1Norm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a45e75bc358dc64d1dc080cb311acd449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like vector.lpNorm&lt;1&gt;(), a.k.a. L_1 norm.  <br /></td></tr>
<tr class="separator:a45e75bc358dc64d1dc080cb311acd449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11d2b633fbd4e06d2d51d95767105db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ab11d2b633fbd4e06d2d51d95767105db">SquaredNorm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ab11d2b633fbd4e06d2d51d95767105db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like vector.squaredNorm()  <br /></td></tr>
<tr class="separator:ab11d2b633fbd4e06d2d51d95767105db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3cc73755c80cd79c2fb1c697e1310a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a4f3cc73755c80cd79c2fb1c697e1310a">Norm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a4f3cc73755c80cd79c2fb1c697e1310a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like vector.norm()  <br /></td></tr>
<tr class="separator:a4f3cc73755c80cd79c2fb1c697e1310a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdde18597f56c6108928669aa7e1fff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#acfdde18597f56c6108928669aa7e1fff">SquaredDistance</a> (const Eigen::VectorXd &amp;vector1, const Eigen::VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:acfdde18597f56c6108928669aa7e1fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like (vector1 - vector2).squaredNorm()  <br /></td></tr>
<tr class="separator:acfdde18597f56c6108928669aa7e1fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09826daec0fbcdf6594b1ada846dbb3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a09826daec0fbcdf6594b1ada846dbb3a">Distance</a> (const Eigen::VectorXd &amp;vector1, const Eigen::VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a09826daec0fbcdf6594b1ada846dbb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like (vector1 - vector2).norm()  <br /></td></tr>
<tr class="separator:a09826daec0fbcdf6594b1ada846dbb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e24a12cfaed2024d52b70297b5a96b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a42e24a12cfaed2024d52b70297b5a96b">ScaledLInfNorm</a> (const Eigen::VectorXd &amp;vector, const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a42e24a12cfaed2024d52b70297b5a96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ScaledL1Norm is omitted because it's not needed (yet).  <br /></td></tr>
<tr class="separator:a42e24a12cfaed2024d52b70297b5a96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff65f956f203f1538f4bbf0cd44fa2b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#acff65f956f203f1538f4bbf0cd44fa2b">ScaledSquaredNorm</a> (const Eigen::VectorXd &amp;vector, const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:acff65f956f203f1538f4bbf0cd44fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250eacb9ce6df8be7e5837a2279e7cca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a250eacb9ce6df8be7e5837a2279e7cca">ScaledNorm</a> (const Eigen::VectorXd &amp;vector, const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a250eacb9ce6df8be7e5837a2279e7cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2 norm of a rescaled vector, i.e., vector.cwiseProduct(scale).norm().  <br /></td></tr>
<tr class="separator:a250eacb9ce6df8be7e5837a2279e7cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac825edcd2a72e7284c0b1c1ffce6dea0"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ac825edcd2a72e7284c0b1c1ffce6dea0">ScaledColLInfNorm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ac825edcd2a72e7284c0b1c1ffce6dea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LInf norm of each column of a scaled matrix.  <br /></td></tr>
<tr class="separator:ac825edcd2a72e7284c0b1c1ffce6dea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371aa1f67b4d895ed970bf479e6ec5f"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ac371aa1f67b4d895ed970bf479e6ec5f">ScaledColL2Norm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ac371aa1f67b4d895ed970bf479e6ec5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2 norm of each column of a scaled matrix.  <br /></td></tr>
<tr class="separator:ac371aa1f67b4d895ed970bf479e6ec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7fb0fc4d208899d240d64bfa7b29c"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a6ef7fb0fc4d208899d240d64bfa7b29c">CheckNonNegative</a> (const double <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>, const absl::string_view <a class="el" href="default__search_8cc.html#ac673bc430bdc3fdaa09f7becf98ef267">name</a>)</td></tr>
<tr class="separator:a6ef7fb0fc4d208899d240d64bfa7b29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1ddf99c0904d4ec8d3975975ffb4ff"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aea1ddf99c0904d4ec8d3975975ffb4ff">ValidateTerminationCriteria</a> (const TerminationCriteria &amp;criteria)</td></tr>
<tr class="separator:aea1ddf99c0904d4ec8d3975975ffb4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d3d32d0a8e4e2c01b081f331797e1f"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a46d3d32d0a8e4e2c01b081f331797e1f">ValidateAdaptiveLinesearchParams</a> (const AdaptiveLinesearchParams &amp;params)</td></tr>
<tr class="separator:a46d3d32d0a8e4e2c01b081f331797e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ed703509ec38f4d680039f6d62791a"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aa1ed703509ec38f4d680039f6d62791a">ValidateMalitskyPockParams</a> (const MalitskyPockParams &amp;params)</td></tr>
<tr class="separator:aa1ed703509ec38f4d680039f6d62791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2bda13dd823757fe941eecc9dc328b"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a2d2bda13dd823757fe941eecc9dc328b">ValidatePrimalDualHybridGradientParams</a> (const PrimalDualHybridGradientParams &amp;params)</td></tr>
<tr class="separator:a2d2bda13dd823757fe941eecc9dc328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05b31a796e1009f7087884df50815fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ad05b31a796e1009f7087884df50815fc">ObjectiveGapMet</a> (const TerminationCriteria::DetailedOptimalityCriteria &amp;optimality_criteria, const ConvergenceInformation &amp;stats)</td></tr>
<tr class="separator:ad05b31a796e1009f7087884df50815fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba79804abf8f9932eba7e98356c05ad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aba79804abf8f9932eba7e98356c05ad5">OptimalityCriteriaMet</a> (const TerminationCriteria::DetailedOptimalityCriteria &amp;optimality_criteria, const ConvergenceInformation &amp;stats, const OptimalityNorm optimality_norm, const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;bound_norms)</td></tr>
<tr class="memdesc:aba79804abf8f9932eba7e98356c05ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the optimality criteria are met.  <br /></td></tr>
<tr class="separator:aba79804abf8f9932eba7e98356c05ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5acb887ad53db5411c34545980f993"><td class="memItemLeft" align="right" valign="top">TerminationCriteria::DetailedOptimalityCriteria&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a3a5acb887ad53db5411c34545980f993">EffectiveOptimalityCriteria</a> (const TerminationCriteria &amp;termination_criteria)</td></tr>
<tr class="memdesc:a3a5acb887ad53db5411c34545980f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the effective optimality criteria for a TerminationCriteria.  <br /></td></tr>
<tr class="separator:a3a5acb887ad53db5411c34545980f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254f8c83c3395526dcc958f19e3c14a"><td class="memItemLeft" align="right" valign="top">TerminationCriteria::DetailedOptimalityCriteria&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a7254f8c83c3395526dcc958f19e3c14a">EffectiveOptimalityCriteria</a> (const TerminationCriteria::SimpleOptimalityCriteria &amp;simple_criteria)</td></tr>
<tr class="separator:a7254f8c83c3395526dcc958f19e3c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd964babbc05f32fd088b1005215dc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a02fd964babbc05f32fd088b1005215dc">CheckSimpleTerminationCriteria</a> (const TerminationCriteria &amp;criteria, const IterationStats &amp;stats, const std::atomic&lt; bool &gt; *interrupt_solve)</td></tr>
<tr class="separator:a02fd964babbc05f32fd088b1005215dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915b4c9c60210eb50bbb836643aba393"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a915b4c9c60210eb50bbb836643aba393">CheckIterateTerminationCriteria</a> (const TerminationCriteria &amp;criteria, const IterationStats &amp;stats, const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;bound_norms, const bool force_numerical_termination)</td></tr>
<tr class="separator:a915b4c9c60210eb50bbb836643aba393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c3bece6c277a26a34c825c2b4e4509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a58c3bece6c277a26a34c825c2b4e4509">BoundNormsFromProblemStats</a> (const QuadraticProgramStats &amp;stats)</td></tr>
<tr class="separator:a58c3bece6c277a26a34c825c2b4e4509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7474762d0771b51e98686306ec7b4f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a5c7474762d0771b51e98686306ec7b4f">EpsilonRatio</a> (const double epsilon_absolute, const double epsilon_relative)</td></tr>
<tr class="separator:a5c7474762d0771b51e98686306ec7b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabaaef8b32ae92f1331599732ac99d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1RelativeConvergenceInformation.html">RelativeConvergenceInformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#afabaaef8b32ae92f1331599732ac99d1">ComputeRelativeResiduals</a> (const TerminationCriteria::DetailedOptimalityCriteria &amp;optimality_criteria, const ConvergenceInformation &amp;stats, const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;bound_norms)</td></tr>
<tr class="separator:afabaaef8b32ae92f1331599732ac99d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71efdc063650b57ca9c2dce8ba280aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a71efdc063650b57ca9c2dce8ba280aa2">TestLp</a> ()</td></tr>
<tr class="separator:a71efdc063650b57ca9c2dce8ba280aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5567aad57ec9c50762717560246a25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a4d5567aad57ec9c50762717560246a25">VerifyTestLp</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp, bool maximize=false)</td></tr>
<tr class="memdesc:a4d5567aad57ec9c50762717560246a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> equals <a class="el" href="namespaceoperations__research_1_1pdlp.html#a71efdc063650b57ca9c2dce8ba280aa2">TestLp()</a>.  <br /></td></tr>
<tr class="separator:a4d5567aad57ec9c50762717560246a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa435d5162dd0e66c54d0b99600816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a3ffa435d5162dd0e66c54d0b99600816">TinyLp</a> ()</td></tr>
<tr class="separator:a3ffa435d5162dd0e66c54d0b99600816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacc8fc59edce54401bcdee2cf277c4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#adacc8fc59edce54401bcdee2cf277c4e">CorrelationClusteringLp</a> ()</td></tr>
<tr class="memdesc:adacc8fc59edce54401bcdee2cf277c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">| /  <br /></td></tr>
<tr class="separator:adacc8fc59edce54401bcdee2cf277c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23678bb7c561c0ebbc4c3e2a941fbd9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a23678bb7c561c0ebbc4c3e2a941fbd9d">CorrelationClusteringStarLp</a> ()</td></tr>
<tr class="separator:a23678bb7c561c0ebbc4c3e2a941fbd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d16c98703c18ea1d861e274758f0e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a1d16c98703c18ea1d861e274758f0e4b">TestDiagonalQp1</a> ()</td></tr>
<tr class="separator:a1d16c98703c18ea1d861e274758f0e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e82a5f4fad9211f4235a37919e36c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a9e82a5f4fad9211f4235a37919e36c64">TestDiagonalQp2</a> ()</td></tr>
<tr class="separator:a9e82a5f4fad9211f4235a37919e36c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be6c6d75aa743c9a64c87b093da0257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a2be6c6d75aa743c9a64c87b093da0257">TestDiagonalQp3</a> ()</td></tr>
<tr class="separator:a2be6c6d75aa743c9a64c87b093da0257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340ee35401be0c80f722003a6ac987d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aa340ee35401be0c80f722003a6ac987d">SmallInvalidProblemLp</a> ()</td></tr>
<tr class="separator:aa340ee35401be0c80f722003a6ac987d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86984b72235fd509deb9975088eafb82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a86984b72235fd509deb9975088eafb82">SmallInconsistentVariableBoundsLp</a> ()</td></tr>
<tr class="separator:a86984b72235fd509deb9975088eafb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af846811056ccf9ca9b69bef6ff8dc528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#af846811056ccf9ca9b69bef6ff8dc528">SmallPrimalInfeasibleLp</a> ()</td></tr>
<tr class="separator:af846811056ccf9ca9b69bef6ff8dc528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24be2a07d0f1a8994196b4c7f74870c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a24be2a07d0f1a8994196b4c7f74870c2">SmallDualInfeasibleLp</a> ()</td></tr>
<tr class="separator:a24be2a07d0f1a8994196b4c7f74870c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da8f33b9749e1da2c36dddc189d77fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a0da8f33b9749e1da2c36dddc189d77fb">SmallPrimalDualInfeasibleLp</a> ()</td></tr>
<tr class="separator:a0da8f33b9749e1da2c36dddc189d77fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287eefed02ca53e0fa0af77382920688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a287eefed02ca53e0fa0af77382920688">SmallInitializationLp</a> ()</td></tr>
<tr class="separator:a287eefed02ca53e0fa0af77382920688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9961ddc0f992257e088066b1d9f59b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a9961ddc0f992257e088066b1d9f59b92">LpWithoutConstraints</a> ()</td></tr>
<tr class="separator:a9961ddc0f992257e088066b1d9f59b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa645221539fcb7491fa586e9e568922a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aa645221539fcb7491fa586e9e568922a">VerifyTestDiagonalQp1</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp, bool maximize)</td></tr>
<tr class="separator:aa645221539fcb7491fa586e9e568922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c473c17b12a0b8d751a14939b0843ac"><td class="memItemLeft" align="right" valign="top">::Eigen::ArrayXXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a5c473c17b12a0b8d751a14939b0843ac">ToDense</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;sparse_mat)</td></tr>
<tr class="separator:a5c473c17b12a0b8d751a14939b0843ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da80544adc685ee442522ede0e095a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a8da80544adc685ee442522ede0e095a9">SolveTrustRegion</a> (const VectorXd &amp;objective_vector, const VectorXd &amp;variable_lower_bounds, const VectorXd &amp;variable_upper_bounds, const VectorXd &amp;center_point, const VectorXd &amp;norm_weights, const double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a8da80544adc685ee442522ede0e095a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b58430ce7de405a6a70e8857e8caf6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ac5b58430ce7de405a6a70e8857e8caf6">dual_gradient</a> (y - dual_solution) class DiagonalTrustRegionProblemFromQp</td></tr>
<tr class="memdesc:ac5b58430ce7de405a6a70e8857e8caf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">s.t. l &lt;= x - primal_solution &lt;= u l_implicit &lt;= y - dual_solution &lt;= u_implicit ||(x, y) - (primal_solution, dual_solution)||_W &lt;= r, where ||(x, y)||_W = sqrt(0.5 * primal_weight |<code>x</code>|^2 + (0.5 / primal_weight) |<code>y</code>|^2). This class implements the same methods as <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>, but without the need to explicitly copy vectors.  <br /></td></tr>
<tr class="separator:ac5b58430ce7de405a6a70e8857e8caf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb6df46237b5d870b93c6566cadd722"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </td></tr>
<tr class="memitem:accb6df46237b5d870b93c6566cadd722"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#accb6df46237b5d870b93c6566cadd722">ProjectedValueOfScaledDifference</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const int64_t <a class="el" href="local__search_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, const double scaling_factor)</td></tr>
<tr class="memdesc:accb6df46237b5d870b93c6566cadd722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a single coordinate projection of the scaled difference, sqrt(NormWeight(i)) * (x[i] - CenterPoint(i)), to the corresponding box constraints. As a function of scaling_factor, the difference is equal to (Q[i, i] / NormWeight(i)) + scaling_factor)^{-1} * (-c[i] / sqrt(NormWeight(i))), where Q, c are the objective matrix and vector, respectively.  <br /></td></tr>
<tr class="separator:accb6df46237b5d870b93c6566cadd722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c71f00da2c898c481414c3e92f12f0d"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </td></tr>
<tr class="memitem:a3c71f00da2c898c481414c3e92f12f0d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a3c71f00da2c898c481414c3e92f12f0d">NormOfDeltaProjection</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double scaling_factor)</td></tr>
<tr class="memdesc:a3c71f00da2c898c481414c3e92f12f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the norm of the projection of the difference vector, x - center_point, to the corresponding box constraints. We are using the standard Euclidean norm (instead of the weighted norm) because the solver implicitly reformulates the problem to one with a Euclidean ball constraint first.  <br /></td></tr>
<tr class="separator:a3c71f00da2c898c481414c3e92f12f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd16384c5572b001a57e9987bf5b0e9"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </td></tr>
<tr class="memitem:a7bd16384c5572b001a57e9987bf5b0e9"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a7bd16384c5572b001a57e9987bf5b0e9">FindScalingFactor</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double target_radius, const double solve_tol)</td></tr>
<tr class="memdesc:a7bd16384c5572b001a57e9987bf5b0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an approximately optimal scaling factor for the solution of the trust region subproblem, which can be passed on to ProjectedCoordinate() to find an approximately optimal solution to the trust region subproblem. The value returned is guaranteed to be within <code>solve_tol * <a class="el" href="alldiff__cst_8cc.html#a26e6db9bcc64b584051ecc28171ed11f">max(1, s*)</a></code> of the optimal scaling <code>s*</code>.  <br /></td></tr>
<tr class="separator:a7bd16384c5572b001a57e9987bf5b0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39db3ccea12adec49816af128a288223"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </td></tr>
<tr class="memitem:a39db3ccea12adec49816af128a288223"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a39db3ccea12adec49816af128a288223">SolveDiagonalTrustRegionProblem</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double target_radius, const double solve_tol)</td></tr>
<tr class="memdesc:a39db3ccea12adec49816af128a288223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the diagonal trust region problem using a binary search algorithm. See comment above <a class="el" href="namespaceoperations__research_1_1pdlp.html#a5f128477eac14f0eda4b73fdfb3e24d4">SolveDiagonalTrustRegion()</a> in <a class="el" href="trust__region_8h.html">trust_region.h</a> for the meaning of solve_tol.  <br /></td></tr>
<tr class="separator:a39db3ccea12adec49816af128a288223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f128477eac14f0eda4b73fdfb3e24d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a5f128477eac14f0eda4b73fdfb3e24d4">SolveDiagonalTrustRegion</a> (const VectorXd &amp;objective_vector, const VectorXd &amp;objective_matrix_diagonal, const VectorXd &amp;variable_lower_bounds, const VectorXd &amp;variable_upper_bounds, const VectorXd &amp;center_point, const VectorXd &amp;norm_weights, const double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double solve_tolerance)</td></tr>
<tr class="separator:a5f128477eac14f0eda4b73fdfb3e24d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c21ba4bf7d15e5dd1f8396074a9dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a64c21ba4bf7d15e5dd1f8396074a9dfa">SolveDiagonalQpTrustRegion</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;primal_solution, const VectorXd &amp;dual_solution, const VectorXd &amp;primal_gradient, const VectorXd &amp;<a class="el" href="namespaceoperations__research_1_1pdlp.html#ac5b58430ce7de405a6a70e8857e8caf6">dual_gradient</a>, const double primal_weight, double target_radius, const double solve_tolerance)</td></tr>
<tr class="separator:a64c21ba4bf7d15e5dd1f8396074a9dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb77e7cede2fecf6bccfa93226b49c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#adb77e7cede2fecf6bccfa93226b49c0b">ComputeLocalizedLagrangianBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;primal_solution, const VectorXd &amp;dual_solution, const <a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a> primal_dual_norm, const double primal_weight, const double radius, const VectorXd *primal_product, const VectorXd *dual_product, const bool use_diagonal_qp_trust_region_solver, const double diagonal_qp_trust_region_solver_tolerance)</td></tr>
<tr class="separator:adb77e7cede2fecf6bccfa93226b49c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dd3b503fb3d2bb8bd51729584d6bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a90dd3b503fb3d2bb8bd51729584d6bad">SolveTrustRegion</a> (const Eigen::VectorXd &amp;objective_vector, const Eigen::VectorXd &amp;variable_lower_bounds, const Eigen::VectorXd &amp;variable_upper_bounds, const Eigen::VectorXd &amp;center_point, const Eigen::VectorXd &amp;norm_weights, double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a90dd3b503fb3d2bb8bd51729584d6bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87e72f6888d8bd27a4d74f35c3a118d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#ad87e72f6888d8bd27a4d74f35c3a118d">SolveDiagonalTrustRegion</a> (const Eigen::VectorXd &amp;objective_vector, const Eigen::VectorXd &amp;objective_matrix_diagonal, const Eigen::VectorXd &amp;variable_lower_bounds, const Eigen::VectorXd &amp;variable_upper_bounds, const Eigen::VectorXd &amp;center_point, const Eigen::VectorXd &amp;norm_weights, double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, double solve_tolerance)</td></tr>
<tr class="separator:ad87e72f6888d8bd27a4d74f35c3a118d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4054cb0abdfaacfebe5bf1b67eb9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a2f4054cb0abdfaacfebe5bf1b67eb9c9">SolveDiagonalQpTrustRegion</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;primal_solution, const Eigen::VectorXd &amp;dual_solution, const Eigen::VectorXd &amp;primal_gradient, const Eigen::VectorXd &amp;<a class="el" href="namespaceoperations__research_1_1pdlp.html#ac5b58430ce7de405a6a70e8857e8caf6">dual_gradient</a>, const double primal_weight, double target_radius, double solve_tolerance)</td></tr>
<tr class="separator:a2f4054cb0abdfaacfebe5bf1b67eb9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd1506c32f697aeb13c4b9a9f05ba03"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#afdd1506c32f697aeb13c4b9a9f05ba03">BoundGap</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> &amp;<a class="el" href="cp__model__solver_8cc.html#a06dad0852d85b0686e01c084207c03a7">bounds</a>)</td></tr>
<tr class="separator:afdd1506c32f697aeb13c4b9a9f05ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca670cd122efdc372993d4b49568ec4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#aca670cd122efdc372993d4b49568ec4f">ComputeLocalizedLagrangianBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;primal_solution, const Eigen::VectorXd &amp;dual_solution, <a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a> primal_dual_norm, double primal_weight, double radius, const Eigen::VectorXd *primal_product, const Eigen::VectorXd *dual_product, bool use_diagonal_qp_trust_region_solver, double diagonal_qp_trust_region_solver_tolerance)</td></tr>
<tr class="separator:aca670cd122efdc372993d4b49568ec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7b49a0361e8201ffd1515e0067b9fd30"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a7b49a0361e8201ffd1515e0067b9fd30">kInfinity</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="separator:a7b49a0361e8201ffd1515e0067b9fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f1afcc777ad3dbf7090595ce6fe803"><td class="memItemLeft" align="right" valign="top">x_0 x_1 x_2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a19f1afcc777ad3dbf7090595ce6fe803">x_3</a></td></tr>
<tr class="separator:a19f1afcc777ad3dbf7090595ce6fe803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Validation utilities for <a class="el" href="solvers_8proto.html">solvers.proto</a>. </p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. These are internal helper functions and classes that implicitly or explicitly operate on a <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a>. Utilities that are purely linear algebra operations (e.g., norms) should be defined in <a class="el" href="sharder_8h.html">sharder.h</a> instead. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8b49502c323652c8d4e9a3fd3dd5cda7" name="a8b49502c323652c8d4e9a3fd3dd5cda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b49502c323652c8d4e9a3fd3dd5cda7">&#9670;&#160;</a></span>PrimalDualNorm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7">operations_research::pdlp::PrimalDualNorm</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a norm on a vector partitioned as (x, y) where x is the primal and y is the dual. The enum values define a joint norm as a function of |<code>x</code>|_P and |<code>y</code>|_D, whose definition depends on the context. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b49502c323652c8d4e9a3fd3dd5cda7a974f1270f89b99d15b58a4d35c26aedc" name="a8b49502c323652c8d4e9a3fd3dd5cda7a974f1270f89b99d15b58a4d35c26aedc"></a>kMaxNorm&#160;</td><td class="fielddoc"><p>The joint norm ||(x,y)||_PD = max{|<code>x</code>|_P, |<code>y</code>|_D}. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8b49502c323652c8d4e9a3fd3dd5cda7aaafbdb17e2f1da89be62331fa0cf5503" name="a8b49502c323652c8d4e9a3fd3dd5cda7aaafbdb17e2f1da89be62331fa0cf5503"></a>kEuclideanNorm&#160;</td><td class="fielddoc"><p>The joint norm (||(x,y)||_PD)^2 = (|<code>x</code>|_P)^2 + (|<code>y</code>|_D)^2. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="trust__region_8h_source.html#l00120">120</a> of file <a class="el" href="trust__region_8h_source.html">trust_region.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a904cea6c14ac90eea354da5d70ec1719" name="a904cea6c14ac90eea354da5d70ec1719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904cea6c14ac90eea354da5d70ec1719">&#9670;&#160;</a></span>AddScaledVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AddScaledVector </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00192">192</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a62b08cd6ba4e025f1df1ec41261e14db" name="a62b08cd6ba4e025f1df1ec41261e14db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b08cd6ba4e025f1df1ec41261e14db">&#9670;&#160;</a></span>AddScaledVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AddScaledVector </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like dest += scale * increment. </p>

</div>
</div>
<a id="acea6db4184272e326213cd4a7ddc1cd4" name="acea6db4184272e326213cd4a7ddc1cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea6db4184272e326213cd4a7ddc1cd4">&#9670;&#160;</a></span>ApplyRescaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1ScalingVectors.html">ScalingVectors</a> operations_research::pdlp::ApplyRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1RescalingOptions.html">RescalingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>rescaling_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the rescaling specified by rescaling_options to sharded_qp (in place). Returns the scaling vectors that were applied. </p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00418">418</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="afa393d2c90adfa983d1625e6e409d4f7" name="afa393d2c90adfa983d1625e6e409d4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa393d2c90adfa983d1625e6e409d4f7">&#9670;&#160;</a></span>AssignVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AssignVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like dest = vec. dest is resized if needed. </p>

</div>
</div>
<a id="afca8f74da7e8301c8aee45f33c93896c" name="afca8f74da7e8301c8aee45f33c93896c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca8f74da7e8301c8aee45f33c93896c">&#9670;&#160;</a></span>AssignVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AssignVector </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00199">199</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="afdd1506c32f697aeb13c4b9a9f05ba03" name="afdd1506c32f697aeb13c4b9a9f05ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd1506c32f697aeb13c4b9a9f05ba03">&#9670;&#160;</a></span>BoundGap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::BoundGap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8h_source.html#l00113">113</a> of file <a class="el" href="trust__region_8h_source.html">trust_region.h</a>.</p>

</div>
</div>
<a id="a58c3bece6c277a26a34c825c2b4e4509" name="a58c3bece6c277a26a34c825c2b4e4509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c3bece6c277a26a34c825c2b4e4509">&#9670;&#160;</a></span>BoundNormsFromProblemStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> operations_research::pdlp::BoundNormsFromProblemStats </td>
          <td>(</td>
          <td class="paramtype">const QuadraticProgramStats &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the norms needed for the termination criteria from the full problem statistics. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00222">222</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="ad98a981710e58e6eead1ca6c76f7b2b7" name="ad98a981710e58e6eead1ca6c76f7b2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98a981710e58e6eead1ca6c76f7b2b7">&#9670;&#160;</a></span>CanFitInMpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::CanFitInMpModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns InvalidArgument if the given quadratic program is too large to convert to MPModelProto and OkStatus otherwise. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00211">211</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a915b4c9c60210eb50bbb836643aba393" name="a915b4c9c60210eb50bbb836643aba393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915b4c9c60210eb50bbb836643aba393">&#9670;&#160;</a></span>CheckIterateTerminationCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt; operations_research::pdlp::CheckIterateTerminationCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterationStats &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;&#160;</td>
          <td class="paramname"><em>bound_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_numerical_termination</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if any iterate-based termination criteria (i.e., the criteria not checked by CheckSimpleTerimationCriteria()) are satisfied by the solution state described by the IterationStats instance stats (see definitions of termination criteria in <a class="el" href="solvers_8proto.html">solvers.proto</a>). bound_norms provides the instance- dependent data required for the relative convergence criteria. Returns a termination reason and a point type if so (if multiple are satisfied, the optimality and infeasibility conditions are checked first). If force_numerical_termination is true, returns NUMERICAL_ERROR if no other criteria are satisfied. The return value is empty in any other case. If the output is not empty, the PointType indicates which entry prompted termination. If no entry prompted termination, e.g. NUMERICAL_ERROR is returned, then the PointType is set to POINT_TYPE_NONE. NOTE: This function assumes that the solution used to compute the stats satisfies the primal and dual variable bounds; see <a href="https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds">https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds</a>. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00187">187</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a6ef7fb0fc4d208899d240d64bfa7b29c" name="a6ef7fb0fc4d208899d240d64bfa7b29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef7fb0fc4d208899d240d64bfa7b29c">&#9670;&#160;</a></span>CheckNonNegative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::CheckNonNegative </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00029">29</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a02fd964babbc05f32fd088b1005215dc" name="a02fd964babbc05f32fd088b1005215dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd964babbc05f32fd088b1005215dc">&#9670;&#160;</a></span>CheckSimpleTerminationCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt; operations_research::pdlp::CheckSimpleTerminationCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterationStats &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>interrupt_solve</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if any of the simple termination criteria are satisfied by <code>stats</code>, and returns a termination reason if so, and nullopt otherwise. The "simple" termination criteria are <code>time_sec_limit</code>, <code>iteration_limit</code>, <code>kkt_matrix_pass_limit</code>, and <code>interrupt_solve</code>. The corresponding fields of <code>stats</code> (<code>cumulative_time_sec</code>, <code>iteration_number</code>, <code>cumulative_kkt_matrix_passes</code>) are the only ones accessed. If returning a termination reason, the PointType will be set to POINT_TYPE_NONE. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00162">162</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a3ed237f4d1a54c4da63c16cc38baf030" name="a3ed237f4d1a54c4da63c16cc38baf030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed237f4d1a54c4da63c16cc38baf030">&#9670;&#160;</a></span>CloneVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::CloneVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of vec. </p>

</div>
</div>
<a id="aaa4a3bad4a7c95a6d68387ba8ae8c104" name="aaa4a3bad4a7c95a6d68387ba8ae8c104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4a3bad4a7c95a6d68387ba8ae8c104">&#9670;&#160;</a></span>CloneVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::CloneVector </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00205">205</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="af2e7e8dab386b40f5984525566c9709f" name="af2e7e8dab386b40f5984525566c9709f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e7e8dab386b40f5984525566c9709f">&#9670;&#160;</a></span>CoefficientWiseProductInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseProductInPlace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like dest = dest.cwiseProduct(scale). </p>

</div>
</div>
<a id="a920005e41b36a7a0c7f4ad148ad7069d" name="a920005e41b36a7a0c7f4ad148ad7069d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920005e41b36a7a0c7f4ad148ad7069d">&#9670;&#160;</a></span>CoefficientWiseProductInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseProductInPlace </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00211">211</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ae3ba879295782a2f85c4903e0de21cbe" name="ae3ba879295782a2f85c4903e0de21cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ba879295782a2f85c4903e0de21cbe">&#9670;&#160;</a></span>CoefficientWiseQuotientInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseQuotientInPlace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like dest = dest.cwiseQuotient(scale). </p>

</div>
</div>
<a id="a92c8ca6bf2bb288c322e1d8fbd6ea2bc" name="a92c8ca6bf2bb288c322e1d8fbd6ea2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c8ca6bf2bb288c322e1d8fbd6ea2bc">&#9670;&#160;</a></span>CoefficientWiseQuotientInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseQuotientInPlace </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00218">218</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ad3a4f857c920478cbdc673571b69f660" name="ad3a4f857c920478cbdc673571b69f660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a4f857c920478cbdc673571b69f660">&#9670;&#160;</a></span>ComputeConvergenceInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConvergenceInformation operations_research::pdlp::ComputeConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scaled_primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scaled_dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>componentwise_primal_residual_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>componentwise_dual_residual_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>candidate_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns convergence statistics about a primal/dual solution pair. It is assumed that scaled_sharded_qp has been transformed from the original qp by ShardedQuadraticProgram::RescaleQuadraticProgram(col_scaling_vec,
row_scaling_vec). scaled_primal_solution and scaled_dual_solution are solutions for the scaled problem. The stats are computed with respect to the implicit original problem. 'componentwise_primal_residual_offset' and 'componentwise_dual_residual_offset' are the offsets (i.e., eps_ratio) used for computing the l_inf_componentwise residual norms. </p><dl class="section note"><dt>Note</dt><dd>This function assumes that scaled_primal_solution satisfies the variable bounds and scaled_dual_solution satisfies the dual variable bounds; see <a href="https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds">https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds</a>. </dd></dl>
<p>See <a href="https://developers.google.com/optimization/lp/pdlp_math#rescaling">https://developers.google.com/optimization/lp/pdlp_math#rescaling</a> for notes describing the connection between the scaled and unscaled problem.</p>
<p>This is the dual objective from <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a> minus the last term (involving r). All scaling terms cancel out.</p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00348">348</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="a96fca5ce03ac69c5ca4e0db9d39d62e0" name="a96fca5ce03ac69c5ca4e0db9d39d62e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fca5ce03ac69c5ca4e0db9d39d62e0">&#9670;&#160;</a></span>ComputeDualGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputeDualGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the value of the dual part of the Lagrangian function defined at <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a>, i.e., -h^*(y) and the gradient of the Lagrangian with respect to the dual variables y, i.e., -Ax - \grad_y h^*(y). Note the asymmetry with ComputePrimalGradient: the term -y'Ax is not part of the value. Because h^*(y) is piece-wise linear, a subgradient is returned at a point of non- smoothness. The primal_product argument is Ax. The result is undefined and invalid if any duals violate their bounds. </p>

</div>
</div>
<a id="a0b0a68c36dafae816b5d18fdf7f4f2d1" name="a0b0a68c36dafae816b5d18fdf7f4f2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0a68c36dafae816b5d18fdf7f4f2d1">&#9670;&#160;</a></span>ComputeDualGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputeDualGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00497">497</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="aeb4a3d5eb9d440e6417eb339fad6568d" name="aeb4a3d5eb9d440e6417eb339fad6568d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4a3d5eb9d440e6417eb339fad6568d">&#9670;&#160;</a></span>ComputeInfeasibilityInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InfeasibilityInformation operations_research::pdlp::ComputeInfeasibilityInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>scaled_sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scaled_primal_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scaled_dual_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>candidate_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns infeasibility statistics about a primal/dual infeasibility certificate estimate. It is assumed that scaled_sharded_qp has been transformed from the original qp by ShardedQuadraticProgram::RescaleQuadraticProgram(col_scaling_vec,
row_scaling_vec). primal_ray and dual_ray are certificates for the scaled problem. The stats are computed with respect to the implicit original problem. </p>
<p>Compute primal infeasibility information.</p>
<p>We don't use dual_residuals.l_inf_componentwise_residual, so don't need to set componentwise_residual_offset to a meaningful value.</p>
<p>Compute dual infeasibility information. We don't use primal_residuals.l_inf_componentwise_residual, so don't need to set componentwise_residual_offset to a meaningful value.</p>
<p>primal_residuals contains the violations of the linear constraints. The signs of the components are also constrained by the presence or absence of variable bounds.</p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00420">420</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="aca670cd122efdc372993d4b49568ec4f" name="aca670cd122efdc372993d4b49568ec4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca670cd122efdc372993d4b49568ec4f">&#9670;&#160;</a></span>ComputeLocalizedLagrangianBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> operations_research::pdlp::ComputeLocalizedLagrangianBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a>&#160;</td>
          <td class="paramname"><em>primal_dual_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>primal_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>primal_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>dual_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_diagonal_qp_trust_region_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>diagonal_qp_trust_region_solver_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recall the saddle-point formulation OPT = min_x max_y L(x, y) defined at <a href="https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation">https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation</a>. This function computes lower and upper bounds on OPT with an additional ball or "trust- region" constraint on the domains of x and y.</p>
<p>The bounds are derived from the solution of the following problem: min_{x,y} ∇_x L(primal_solution, dual_solution)^T (x - primal_solution) - ∇_y L(primal_solution, dual_solution)^T (y - dual_solution) subject to ||(x - primal_solution, y - dual_solution)||_PD &lt;= radius, where x and y are constrained to their respective bounds and ||(x,y)||_PD is defined by primal_dual_norm. When use_diagonal_qp_trust_region_solver is true, the solver instead solves the following problem: min_{x,y} ∇_x L(primal_solution, dual_solution)^T (x - primal_solution) - ∇_y L(primal_solution, dual_solution)^T (y - dual_solution) + (1 / 2) * (x - primal_solution)^T * objective_matrix * (x - primal_solution), subject to ||(x - primal_solution, y - dual_solution)||_PD &lt;= radius. use_diagonal_qp_trust_region_solver == true assumes that primal_dual_norm is the Euclidean norm and the objective matrix is diagonal. See <a class="el" href="namespaceoperations__research_1_1pdlp.html#a5f128477eac14f0eda4b73fdfb3e24d4">SolveDiagonalTrustRegion()</a> above for the meaning of diagonal_qp_trust_region_solver_tolerance.</p>
<p>In the context of primal_dual_norm, the primal norm ||.||_P is defined as (|<code>x</code>|_P)^2 = (1 / 2) * primal_weight * |<code>x</code>|_2^2, and the dual norm ||.||_D is defined as (|<code>y</code>|_D)^2 = (1 / 2) * (1 / primal_weight) * |<code>y</code>|_2^2.</p>
<p>Given an optimal solution (x, y) to the above problem, the lower bound is computed as L(primal_solution, dual_solution) + ∇_x L(primal_solution, dual_solution)^T (x - primal_solution) and the upper bound is computed as L(primal_solution, dual_solution) + ∇_y L(primal_solution, dual_solution)^T (y - dual_solution).</p>
<p>The bounds are "localized" because they are guaranteed to bound OPT only if the ||.||_PD ball contains an optimal solution. The primal_product and dual_product arguments optionally specify the values of constraint_matrix * primal_solution and constraint_matrix.transpose() * dual_solution, respectively. If set to nullptr, they will be computed. </p>

</div>
</div>
<a id="adb77e7cede2fecf6bccfa93226b49c0b" name="adb77e7cede2fecf6bccfa93226b49c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb77e7cede2fecf6bccfa93226b49c0b">&#9670;&#160;</a></span>ComputeLocalizedLagrangianBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> operations_research::pdlp::ComputeLocalizedLagrangianBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceoperations__research_1_1pdlp.html#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a>&#160;</td>
          <td class="paramname"><em>primal_dual_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>primal_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd *&#160;</td>
          <td class="paramname"><em>primal_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd *&#160;</td>
          <td class="paramname"><em>dual_product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_diagonal_qp_trust_region_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>diagonal_qp_trust_region_solver_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00964">964</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="abe180ee4e003e6a819c90205bf38b60f" name="abe180ee4e003e6a819c90205bf38b60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe180ee4e003e6a819c90205bf38b60f">&#9670;&#160;</a></span>ComputePrimalGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputePrimalGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the value of the primal part of the Lagrangian function defined at <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a>, i.e., c'x + (1/2) x'Qx - y'Ax and its gradient with respect to the primal variables x, i.e., c + Qx - A'y. The dual_product argument is A'y. Note: The objective constant is omitted. The result is undefined and invalid if any primal bounds are violated. </p>

</div>
</div>
<a id="a259d3f73717a2ababa9df2dd43914656" name="a259d3f73717a2ababa9df2dd43914656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259d3f73717a2ababa9df2dd43914656">&#9670;&#160;</a></span>ComputePrimalGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputePrimalGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>using auto instead of VectorXd for the type of objective_product causes eigen to defer the matrix product until it is used (twice).</dd></dl>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00441">441</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="afabaaef8b32ae92f1331599732ac99d1" name="afabaaef8b32ae92f1331599732ac99d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabaaef8b32ae92f1331599732ac99d1">&#9670;&#160;</a></span>ComputeRelativeResiduals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1RelativeConvergenceInformation.html">RelativeConvergenceInformation</a> operations_research::pdlp::ComputeRelativeResiduals </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::DetailedOptimalityCriteria &amp;&#160;</td>
          <td class="paramname"><em>optimality_criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConvergenceInformation &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;&#160;</td>
          <td class="paramname"><em>bound_norms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00240">240</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a67cba1e0f05d2dd4e3efb2587802f022" name="a67cba1e0f05d2dd4e3efb2587802f022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cba1e0f05d2dd4e3efb2587802f022">&#9670;&#160;</a></span>ComputeScaledConvergenceInformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConvergenceInformation operations_research::pdlp::ComputeScaledConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>componentwise_primal_residual_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>componentwise_dual_residual_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>candidate_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns convergence statistics about a primal/dual solution pair. The stats are with respect to sharded_qp (which is typically scaled). This function is equivalent to ComputeConvergenceInformation given scaling vectors uniformly equal to one. </p>

</div>
</div>
<a id="a91e1750531d2a33362a8b9b9158f5192" name="a91e1750531d2a33362a8b9b9158f5192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e1750531d2a33362a8b9b9158f5192">&#9670;&#160;</a></span>ComputeScaledConvergenceInformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConvergenceInformation operations_research::pdlp::ComputeScaledConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>componentwise_primal_residual_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>componentwise_dual_residual_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>candidate_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00519">519</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="aa9c351ac6432daa4ea00cef61ced76c8" name="aa9c351ac6432daa4ea00cef61ced76c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c351ac6432daa4ea00cef61ced76c8">&#9670;&#160;</a></span>ComputeStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuadraticProgramStats operations_research::pdlp::ComputeStats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>infinite_constraint_bound_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a QuadraticProgramStats object for a <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a>. </p>
<p>Caution: if the constraint matrix is empty, elementwise operations (like .coeffs().maxCoeff() or .minCoeff()) will fail.</p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00274">274</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="adacc8fc59edce54401bcdee2cf277c4e" name="adacc8fc59edce54401bcdee2cf277c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacc8fc59edce54401bcdee2cf277c4e">&#9670;&#160;</a></span>CorrelationClusteringLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::CorrelationClusteringLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>| / </p>
<p>Returns a correlation clustering LP. This is the LP for minimizing disagreements for correlation clustering for the 4-vertex graph In integer solutions x_ij is 1 if i and j are in the same cluster and 0 otherwise. The 6 variables are in the order x_12, x_13, x_14, x_23, x_24, x_34. For any distinct i,j,k there's a triangle inequality (1-x_ik) &lt;= (1-x_ij) + (1-x_jk) i.e. -x_ij - x_jk + x_ik &gt;= -1. For brevity we only include 3 out of the 12 possible triangle inequalities: two needed in the optimal solution and 1 other.</p>
<p>Optimal solutions: Primal: [1, 1, 0, 1, 0, 0] Dual: Multiple. Value: 1. </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00087">87</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a23678bb7c561c0ebbc4c3e2a941fbd9d" name="a23678bb7c561c0ebbc4c3e2a941fbd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23678bb7c561c0ebbc4c3e2a941fbd9d">&#9670;&#160;</a></span>CorrelationClusteringStarLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::CorrelationClusteringStarLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns another 4-vertex correlation clustering LP.</p>
<p>The variables are x_12, x_13, x_14, x_23, x_24, and x_34. This time the graph is a star centered at vertex 1. Only the three triangle inequalities that are needed are included.""" Optimal solutions: Primal: [0.5, 0.5, 0.5, 0.0, 0.0, 0.0] Dual: [0.5, 0.5, 0.5] Value: 1.5 </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00108">108</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a09826daec0fbcdf6594b1ada846dbb3a" name="a09826daec0fbcdf6594b1ada846dbb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09826daec0fbcdf6594b1ada846dbb3a">&#9670;&#160;</a></span>Distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like (vector1 - vector2).norm() </p>

</div>
</div>
<a id="a3e28f45b9c1ccdec8d926b4034d3679b" name="a3e28f45b9c1ccdec8d926b4034d3679b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e28f45b9c1ccdec8d926b4034d3679b">&#9670;&#160;</a></span>Distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Distance </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00259">259</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="adfa51fc5a2896d98a940cc367c5bbfe5" name="adfa51fc5a2896d98a940cc367c5bbfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa51fc5a2896d98a940cc367c5bbfe5">&#9670;&#160;</a></span>Dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Dot </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like v1.dot(v2) </p>

</div>
</div>
<a id="a11831586b99d28a708bc103bce1a945e" name="a11831586b99d28a708bc103bce1a945e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11831586b99d28a708bc103bce1a945e">&#9670;&#160;</a></span>Dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Dot </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00225">225</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ac5b58430ce7de405a6a70e8857e8caf6" name="ac5b58430ce7de405a6a70e8857e8caf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b58430ce7de405a6a70e8857e8caf6">&#9670;&#160;</a></span>dual_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::pdlp::dual_gradient </td>
          <td>(</td>
          <td class="paramtype">y -&#160;</td>
          <td class="paramname"><em>dual_solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>s.t. l &lt;= x - primal_solution &lt;= u l_implicit &lt;= y - dual_solution &lt;= u_implicit ||(x, y) - (primal_solution, dual_solution)||_W &lt;= r, where ||(x, y)||_W = sqrt(0.5 * primal_weight |<code>x</code>|^2 + (0.5 / primal_weight) |<code>y</code>|^2). This class implements the same methods as <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>, but without the need to explicitly copy vectors. </p>
<p>DiagonalTrustRegionProblemFromQp accepts a diagonal quadratic program and information about the current solution and gradient and sets up the following trust-region subproblem: min_{x, y} (x - primal_solution)'Q(x - primal_solution)</p><ul>
<li>primal_gradient'(x - primal_solution) </li>
</ul>
<p>A reference to the objects passed in the constructor is kept, so they must outlive the DiagonalTrustRegionProblemFromQp instance.</p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00529">529</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a8d94aed55433c303286276bc57a8d77e" name="a8d94aed55433c303286276bc57a8d77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d94aed55433c303286276bc57a8d77e">&#9670;&#160;</a></span>DualSubgradientCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::DualSubgradientCoefficient </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>constraint_lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>constraint_upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>primal_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a subderivative of the concave dual penalty function that appears in the Lagrangian: -p(dual; -constraint_upper_bound, -constraint_lower_bound) = { constraint_upper_bound * dual when dual &lt; 0, 0 when dual == 0, and constraint_lower_bound * dual when dual &gt; 0} (as defined at <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a>). The subderivative is not necessarily unique when dual == 0. In this case, if only one of the bounds is finite, we return that one. If both are finite, we return the primal product projected onto the bounds, which causes the dual Lagrangian gradient to be zero when the constraint is not violated. If both are infinite, we return zero. The value returned is valid only when the function is finite-valued. </p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00471">471</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a3a5acb887ad53db5411c34545980f993" name="a3a5acb887ad53db5411c34545980f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5acb887ad53db5411c34545980f993">&#9670;&#160;</a></span>EffectiveOptimalityCriteria() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TerminationCriteria::DetailedOptimalityCriteria operations_research::pdlp::EffectiveOptimalityCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;&#160;</td>
          <td class="paramname"><em>termination_criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the effective optimality criteria for a TerminationCriteria. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00127">127</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a7254f8c83c3395526dcc958f19e3c14a" name="a7254f8c83c3395526dcc958f19e3c14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7254f8c83c3395526dcc958f19e3c14a">&#9670;&#160;</a></span>EffectiveOptimalityCriteria() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TerminationCriteria::DetailedOptimalityCriteria operations_research::pdlp::EffectiveOptimalityCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::SimpleOptimalityCriteria &amp;&#160;</td>
          <td class="paramname"><em>simple_criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like previous overload but takes a SimpleOptimalityCriteria. Useful in unit tests where no TerminationCriteria is naturally available. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00144">144</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a5c7474762d0771b51e98686306ec7b4f" name="a5c7474762d0771b51e98686306ec7b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7474762d0771b51e98686306ec7b4f">&#9670;&#160;</a></span>EpsilonRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::EpsilonRatio </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon_absolute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon_relative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns epsilon_absolute / epsilon_relative, returning 1.0 if epsilon_absolute and epsilon_relative are equal (even if they are both 0.0 or infinity, which would normally yield NAN). </p>
<p>Handling epsilon_absolute == epsilon_relative avoids NANs when both values are zero or infinite.</p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00231">231</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a6a017d5b14d16ecb6edb0216c5955280" name="a6a017d5b14d16ecb6edb0216c5955280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a017d5b14d16ecb6edb0216c5955280">&#9670;&#160;</a></span>EstimateMaximumSingularValueOfConstraintMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a> operations_research::pdlp::EstimateMaximumSingularValueOfConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>desired_relative_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>failure_probability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>mt_generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the maximum singular value of A by applying the method of power iteration to A^T A. If a primal and/or dual solution is provided, restricts to the "active" part of A, that is, the columns (rows) for variables that are not at their bounds in the solution. The estimate will have desired_relative_error with probability at least 1 - failure_probability. The number of iterations will be approximately log(primal_size / failure_probability^2)/(2 * desired_relative_error). Uses a mersenne-twister portable random number generator to generate the starting point for the power method, in order to have deterministic results. </p>

</div>
</div>
<a id="a6985b8c7ce87b3858b50efa4a923a0eb" name="a6985b8c7ce87b3858b50efa4a923a0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6985b8c7ce87b3858b50efa4a923a0eb">&#9670;&#160;</a></span>EstimateMaximumSingularValueOfConstraintMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a> operations_research::pdlp::EstimateMaximumSingularValueOfConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>desired_relative_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>failure_probability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;&#160;</td>
          <td class="paramname"><em>mt_generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00671">671</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a7bd16384c5572b001a57e9987bf5b0e9" name="a7bd16384c5572b001a57e9987bf5b0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd16384c5572b001a57e9987bf5b0e9">&#9670;&#160;</a></span>FindScalingFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::FindScalingFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>solve_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an approximately optimal scaling factor for the solution of the trust region subproblem, which can be passed on to ProjectedCoordinate() to find an approximately optimal solution to the trust region subproblem. The value returned is guaranteed to be within <code>solve_tol * <a class="el" href="alldiff__cst_8cc.html#a26e6db9bcc64b584051ecc28171ed11f">max(1, s*)</a></code> of the optimal scaling <code>s*</code>. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000905">Todo:</a></b></dt><dd>(user): figure out what accuracy is useful to callers and redo the stopping criterion accordingly. </dd></dl>
<p>Determine a search interval using monotonicity of the squared norm of the candidate solution with respect to the scaling factor.</p>
<p>Invariant: bounds.upper_bound &gt;= bounds.lower_bound.</p>
<p>Norm is monotonically non-increasing as a function of scaling_factor.</p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00663">663</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a22565ae8507a53fdd98f539757c11c2d" name="a22565ae8507a53fdd98f539757c11c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22565ae8507a53fdd98f539757c11c2d">&#9670;&#160;</a></span>GetConvergenceInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; ConvergenceInformation &gt; operations_research::pdlp::GetConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const IterationStats &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>candidate_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns the ConvergenceInformation with the specified candidate_type, or std::nullopt if no such candidate exists. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00566">566</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="a46d133b011f79db6b38b39d967ba1106" name="a46d133b011f79db6b38b39d967ba1106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d133b011f79db6b38b39d967ba1106">&#9670;&#160;</a></span>GetInfeasibilityInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; InfeasibilityInformation &gt; operations_research::pdlp::GetInfeasibilityInformation </td>
          <td>(</td>
          <td class="paramtype">const IterationStats &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>candidate_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns the InfeasibilityInformation with the specified candidate_type, or std::nullopt if no such candidate exists. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00576">576</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="a8aaf9a260a4e9bd5ed462840b5ee9cb8" name="a8aaf9a260a4e9bd5ed462840b5ee9cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaf9a260a4e9bd5ed462840b5ee9cb8">&#9670;&#160;</a></span>GetPointMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; PointMetadata &gt; operations_research::pdlp::GetPointMetadata </td>
          <td>(</td>
          <td class="paramtype">const IterationStats &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType&#160;</td>
          <td class="paramname"><em>point_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns the PointMetadata with the specified point_type, or std::nullopt if no such point exists. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00587">587</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="aa4aeab0f9534091e49e800a82445edc2" name="aa4aeab0f9534091e49e800a82445edc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4aeab0f9534091e49e800a82445edc2">&#9670;&#160;</a></span>HasValidBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::HasValidBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the lower and upper bounds of the problem are consistent, i.e. for each variable and constraint bound we have lower_bound &lt;= upper_bound. If the input is consistent the method returns true, otherwise it returns false. See also <a class="el" href="namespaceoperations__research_1_1pdlp.html#acc88d1ca95af991600037eaf027f081b">HasValidBounds(const ShardedQuadraticProgram&amp;)</a>. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00082">82</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="acc88d1ca95af991600037eaf027f081b" name="acc88d1ca95af991600037eaf027f081b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc88d1ca95af991600037eaf027f081b">&#9670;&#160;</a></span>HasValidBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::HasValidBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the lower and upper bounds of the problem are consistent, i.e. for each variable and constraint bound we have lower_bound &lt;= upper_bound. If the input is consistent the method returns true, otherwise it returns false. See also <a class="el" href="namespaceoperations__research_1_1pdlp.html#aa4aeab0f9534091e49e800a82445edc2">HasValidBounds(const QuadraticProgram&amp;)</a>. </p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00696">696</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a850865b3deabb2a623e130691df99f15" name="a850865b3deabb2a623e130691df99f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850865b3deabb2a623e130691df99f15">&#9670;&#160;</a></span>IsLinearProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::IsLinearProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="quadratic__program_8h_source.html#l00148">148</a> of file <a class="el" href="quadratic__program_8h_source.html">quadratic_program.h</a>.</p>

</div>
</div>
<a id="a45e75bc358dc64d1dc080cb311acd449" name="a45e75bc358dc64d1dc080cb311acd449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e75bc358dc64d1dc080cb311acd449">&#9670;&#160;</a></span>L1Norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::L1Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like vector.lpNorm&lt;1&gt;(), a.k.a. L_1 norm. </p>

</div>
</div>
<a id="aa577696ad9121b3f002cd37de6f86989" name="aa577696ad9121b3f002cd37de6f86989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa577696ad9121b3f002cd37de6f86989">&#9670;&#160;</a></span>L1Norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::L1Norm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00238">238</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="af41379e6fa8d7e6e6e8151c256906970" name="af41379e6fa8d7e6e6e8151c256906970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41379e6fa8d7e6e6e8151c256906970">&#9670;&#160;</a></span>L2NormRescaling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::L2NormRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>L2NormRescaling divides row_scaling_vec (col_scaling_vec) by the sqrt of the row (col) L2 norm of the current (scaled) constraint matrix. Unlike LInfRescaling, this function does only one iteration because the scaling procedure does not converge in general. This is not Ruiz rescaling for the L2 norm. </p>

</div>
</div>
<a id="a9dee2894b8028a57b7f7d2306b402e44" name="a9dee2894b8028a57b7f7d2306b402e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dee2894b8028a57b7f7d2306b402e44">&#9670;&#160;</a></span>L2NormRescaling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::L2NormRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00411">411</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="ab2cbc527d8c2c204dbd36be85cc4569d" name="ab2cbc527d8c2c204dbd36be85cc4569d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cbc527d8c2c204dbd36be85cc4569d">&#9670;&#160;</a></span>LInfNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::LInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like vector.lpNorm&lt;Eigen::Infinity&gt;(), a.k.a. LInf norm. </p>

</div>
</div>
<a id="a33a42241df5501b0165ee77c3de54d7f" name="a33a42241df5501b0165ee77c3de54d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a42241df5501b0165ee77c3de54d7f">&#9670;&#160;</a></span>LInfNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::LInfNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00230">230</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a39b6d816e6a31a4c4964f5592ed8c056" name="a39b6d816e6a31a4c4964f5592ed8c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b6d816e6a31a4c4964f5592ed8c056">&#9670;&#160;</a></span>LInfRuizRescaling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::LInfRuizRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LInfRuizRescaling and L2NormRescaling rescale the (scaled) constraint matrix of the LP by updating the scaling vectors in-place. More specifically, the (scaled) constraint matrix always has the format: diag(row_scaling_vec) * sharded_qp.Qp().constraint_matrix * diag(col_scaling_vec), and row_scaling_vec and col_scaling_vec are updated in-place. On input, row_scaling_vec and col_scaling_vec provide the initial scaling. With each iteration of LInfRuizRescaling scaling, row_scaling_vec (col_scaling_vec) is divided by the sqrt of the row (col) LInf norm of the current (scaled) constraint matrix. The (scaled) constraint matrix approaches having all row and column LInf norms equal to 1 as the number of iterations goes to infinity. This convergence is fast (linear). More details of Ruiz rescaling algorithm can be found at: <a href="http://www.numerical.rl.ac.uk/reports/drRAL2001034.pdf">http://www.numerical.rl.ac.uk/reports/drRAL2001034.pdf</a>. </p>

</div>
</div>
<a id="a54ded6625965f8ddd342161a55263cce" name="a54ded6625965f8ddd342161a55263cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ded6625965f8ddd342161a55263cce">&#9670;&#160;</a></span>LInfRuizRescaling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::LInfRuizRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00404">404</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a9961ddc0f992257e088066b1d9f59b92" name="a9961ddc0f992257e088066b1d9f59b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9961ddc0f992257e088066b1d9f59b92">&#9670;&#160;</a></span>LpWithoutConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::LpWithoutConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00262">262</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a4f3cc73755c80cd79c2fb1c697e1310a" name="a4f3cc73755c80cd79c2fb1c697e1310a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3cc73755c80cd79c2fb1c697e1310a">&#9670;&#160;</a></span>Norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like vector.norm() </p>

</div>
</div>
<a id="ade56a0bd875b06000c45e1730398e5a8" name="ade56a0bd875b06000c45e1730398e5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade56a0bd875b06000c45e1730398e5a8">&#9670;&#160;</a></span>Norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Norm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00248">248</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a3c71f00da2c898c481414c3e92f12f0d" name="a3c71f00da2c898c481414c3e92f12f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c71f00da2c898c481414c3e92f12f0d">&#9670;&#160;</a></span>NormOfDeltaProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::NormOfDeltaProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaling_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the norm of the projection of the difference vector, x - center_point, to the corresponding box constraints. We are using the standard Euclidean norm (instead of the weighted norm) because the solver implicitly reformulates the problem to one with a Euclidean ball constraint first. </p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00636">636</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="ad05b31a796e1009f7087884df50815fc" name="ad05b31a796e1009f7087884df50815fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05b31a796e1009f7087884df50815fc">&#9670;&#160;</a></span>ObjectiveGapMet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::ObjectiveGapMet </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::DetailedOptimalityCriteria &amp;&#160;</td>
          <td class="paramname"><em>optimality_criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConvergenceInformation &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00027">27</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="acbd7d091bd562c2141e811478aaaa991" name="acbd7d091bd562c2141e811478aaaa991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd7d091bd562c2141e811478aaaa991">&#9670;&#160;</a></span>OnesVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::OnesVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like VectorXd::Ones(sharder.NumElements()) </p>

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00185">185</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="aba79804abf8f9932eba7e98356c05ad5" name="aba79804abf8f9932eba7e98356c05ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba79804abf8f9932eba7e98356c05ad5">&#9670;&#160;</a></span>OptimalityCriteriaMet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::OptimalityCriteriaMet </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::DetailedOptimalityCriteria &amp;&#160;</td>
          <td class="paramname"><em>optimality_criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConvergenceInformation &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OptimalityNorm&#160;</td>
          <td class="paramname"><em>optimality_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;&#160;</td>
          <td class="paramname"><em>bound_norms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the optimality criteria are met. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00044">44</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="ac43b4c39d3be5e0bced44530d50f8208" name="ac43b4c39d3be5e0bced44530d50f8208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43b4c39d3be5e0bced44530d50f8208">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>interrupt_solve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterationStatsCallback&#160;</td>
          <td class="paramname"><em>iteration_stats_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html#l02296">2296</a> of file <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html">primal_dual_hybrid_gradient.cc</a>.</p>

</div>
</div>
<a id="a333f489ba459dad7b5491ec327d8340f" name="a333f489ba459dad7b5491ec327d8340f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333f489ba459dad7b5491ec327d8340f">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>interrupt_solve</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>iteration_stats_callback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the given QP using PDLP (Primal-Dual hybrid gradient enhanced for LP).</p>
<p>All operations that are repeated each iteration are executed in parallel using params.num_threads() threads.</p>
<p>The algorithm generally follows the description in <a href="https://arxiv.org/pdf/2106.04756.pdf">https://arxiv.org/pdf/2106.04756.pdf</a>, with further enhancements for QP. Notation here and in the implementation follows Chambolle and Pock, "On the
ergodic convergence rates of a first-order primal-dual algorithm" (<a href="http://www.optimization-online.org/DB_FILE/2014/09/4532.pdf">http://www.optimization-online.org/DB_FILE/2014/09/4532.pdf</a>). That paper doesn't explicitly use the terminology "primal-dual hybrid
gradient" but their Theorem 1 is analyzing PDHG. See <a href="https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation">https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation</a> for the saddle-point formulation of the QP we use that is compatible with Chambolle and Pock.</p>
<p>We use 0.5 ||.||^2 for both the primal and dual distance functions.</p>
<p>We parameterize the primal and dual step sizes (tau and sigma in Chambolle and Pock) as: primal_stepsize = step_size / primal_weight dual_stepsize = step_size * primal_weight where step_size and primal_weight are parameters. params.linesearch_rule determines the update rule for step_size. params.initial_primal_weight specifies how primal_weight is initialized and params.primal_weight_update_smoothing controls how primal_weight is updated.</p>
<p>If interrupt_solve is not nullptr, then the solver will periodically check if interrupt_solve-&gt;load() is true, in which case the solve will terminate with TERMINATION_REASON_INTERRUPTED_BY_USER.</p>
<p>If iteration_stats_callback is not nullptr, then at each termination step (when iteration stats are logged), iteration_stats_callback will also be called with those iteration stats.</p>
<p>Callers MUST check solve_log.termination_reason before using the vectors in the <a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>. See the comment on <a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> for interpreting the termination reason.</p>
<p>All objective values reported by the algorithm are transformed by using <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html#a03c3931b50f720a92130b299d282ed2b">QuadraticProgram::ApplyObjectiveScalingAndOffset</a>.</p>
<dl class="section note"><dt>Note</dt><dd>qp is intentionally passed by value, because PrimalDualHybridGradient modifies its copy. </dd></dl>

</div>
</div>
<a id="a5e5be3defc8ff241ecc00008c63569df" name="a5e5be3defc8ff241ecc00008c63569df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5be3defc8ff241ecc00008c63569df">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>interrupt_solve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterationStatsCallback&#160;</td>
          <td class="paramname"><em>iteration_stats_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html#l02305">2305</a> of file <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html">primal_dual_hybrid_gradient.cc</a>.</p>

</div>
</div>
<a id="a7b96f89f313a2d89099e740349e02214" name="a7b96f89f313a2d89099e740349e02214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b96f89f313a2d89099e740349e02214">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>interrupt_solve</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>iteration_stats_callback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like above but optionally starts with the given initial solution. If no initial solution is given the zero vector is used. In either case the initial solution is projected onto the primal and dual variable bounds before use. Convergence should be faster if the initial solution is close to an optimal solution. NOTE: initial_solution is intentionally passed by value. </p>

</div>
</div>
<a id="accb6df46237b5d870b93c6566cadd722" name="accb6df46237b5d870b93c6566cadd722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb6df46237b5d870b93c6566cadd722">&#9670;&#160;</a></span>ProjectedValueOfScaledDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ProjectedValueOfScaledDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaling_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a single coordinate projection of the scaled difference, sqrt(NormWeight(i)) * (x[i] - CenterPoint(i)), to the corresponding box constraints. As a function of scaling_factor, the difference is equal to (Q[i, i] / NormWeight(i)) + scaling_factor)^{-1} * (-c[i] / sqrt(NormWeight(i))), where Q, c are the objective matrix and vector, respectively. </p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00616">616</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a4b46c4812be8af75325d63ed3ced80f0" name="a4b46c4812be8af75325d63ed3ced80f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b46c4812be8af75325d63ed3ced80f0">&#9670;&#160;</a></span>ProjectToDualVariableBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToDualVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects the dual vector to the dual variable bounds; see <a href="https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds">https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds</a>. </p>

</div>
</div>
<a id="a898c0c776a5736cf1931036d0d370724" name="a898c0c776a5736cf1931036d0d370724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898c0c776a5736cf1931036d0d370724">&#9670;&#160;</a></span>ProjectToDualVariableBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToDualVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00727">727</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a03f1c93e7c9a345a90874f314196d1aa" name="a03f1c93e7c9a345a90874f314196d1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f1c93e7c9a345a90874f314196d1aa">&#9670;&#160;</a></span>ProjectToPrimalVariableBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToPrimalVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects a primal vector onto the variable bounds constraints. </p>

</div>
</div>
<a id="acb7f29f435d6c9fc53148ee403c7049e" name="acb7f29f435d6c9fc53148ee403c7049e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7f29f435d6c9fc53148ee403c7049e">&#9670;&#160;</a></span>ProjectToPrimalVariableBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToPrimalVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00716">716</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a70f90c55cdcb499205898fd7f90da6f3" name="a70f90c55cdcb499205898fd7f90da6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f90c55cdcb499205898fd7f90da6f3">&#9670;&#160;</a></span>QpFromMpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &gt; operations_research::pdlp::QpFromMpModelProto </td>
          <td>(</td>
          <td class="paramtype">const MPModelProto &amp;&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relax_integer_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_names</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an MPModelProto into a <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>. Returns an error if general constraints are present. If relax_integer_variables is true integer variables are relaxed to continuous; otherwise integer variables are an error. If include_names is true (the default is false), the problem, constraint, and variable names are included in the <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>; otherwise they are left empty. Maximization problems are converted to minimization by negating the objective and setting objective_scaling_factor to -1, which preserves the reported objective values. </p>
<p>To reduce peak RAM usage we construct the constraint matrix in-place. According to the documentation of SparseMatrix::insert() it's effecient to construct a matrix with insert()s as long as reserve() is called first and the non-zeros are inserted in increasing order of inner index. The non-zeros in each input constraint may not be sorted so this is only efficient with Column major format.</p>
<p>We use triplets-based initialization for the objective matrix because the objective non-zeros may be in arbitrary order in the input.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> has an implicit "1/2" in front of the quadratic term.</dd></dl>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00092">92</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a03fc89d57cdfcdd70d122ffc32fb015d" name="a03fc89d57cdfcdd70d122ffc32fb015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fc89d57cdfcdd70d122ffc32fb015d">&#9670;&#160;</a></span>QpToMpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; MPModelProto &gt; operations_research::pdlp::QpToMpModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> into an MPModelProto. To preserve objective values in the conversion, the objective vector, objective matrix, and objective offset are scaled by objective_scaling_factor, and if objective_scaling_factor is negative, then the proto is a maximization problem (otherwise it's a minimization problem). Returns InvalidArgumentError if objective_scaling_factor is zero or if <a class="el" href="namespaceoperations__research_1_1pdlp.html#ad98a981710e58e6eead1ca6c76f7b2b7">CanFitInMpModelProto()</a> fails. </p>
<p>To avoid reallocs during the inserts, we could count the nonzeros and reserve() before filling.</p>
<p>Some OR tools decide the objective is quadratic based on has_quadratic_objective() rather than on quadratic_objective_size() == 0, so don't create the quadratic objective for linear programs.</p>
<p>Undo the implicit (1/2) term in <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>'s objective.</p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00235">235</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a40bff54df141c92a98fb14a56a06417c" name="a40bff54df141c92a98fb14a56a06417c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bff54df141c92a98fb14a56a06417c">&#9670;&#160;</a></span>ReadMPModelProtoFileOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::ReadMPModelProtoFileOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mpmodel_proto_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_names</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The input may be MPModelProto in text format, binary format, or JSON, possibly gzipped. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00082">82</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="aae83b2a0a223071e9c8a20cc2d8c0664" name="aae83b2a0a223071e9c8a20cc2d8c0664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae83b2a0a223071e9c8a20cc2d8c0664">&#9670;&#160;</a></span>ReadMpsLinearProgramOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::ReadMpsLinearProgramOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lp_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MpsFileToMPModelProto sometimes fails silently if the file isn't read properly.</p>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00067">67</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="a80b7dc41ed788020cbaf942674f623d9" name="a80b7dc41ed788020cbaf942674f623d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b7dc41ed788020cbaf942674f623d9">&#9670;&#160;</a></span>ReadQuadraticProgramOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::ReadQuadraticProgramOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000901">Todo:</a></b></dt><dd>(user): Update internal helper functions to use references instead of pointers. </dd></dl>
<p>Reads a quadratic program, determining the type based on the filename's suffix: *.mps, *.mps.gz, *.mps.bz2 -&gt; ReadMpsLinearProgramOrDie *.pb, *.textproto, *.json, *.json.gz -&gt; ReadMPModelProtoFileOrDie otherwise CHECK-fails. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00050">50</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="a6e56bcb1dbb063aac138bfaaeaca695a" name="a6e56bcb1dbb063aac138bfaaeaca695a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e56bcb1dbb063aac138bfaaeaca695a">&#9670;&#160;</a></span>ReducedCosts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ReducedCosts </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>scaled_sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_zero_primal_objective</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the reduced costs vector, objective_matrix * primal_solution + objective_vector - constraint_matrix * dual_solution - dual_residuals, when use_zero_primal_objective is false, and -constraint_matrix * dual_solution - dual_residuals when use_zero_primal_objective is true. The elements of the vector are corrected component-wise to zero to ensure that the dual objective takes a finite value. See <a href="https://developers.google.com/optimization/lp/pdlp_math#reduced_costs_dual_residuals_and_the_corrected_dual_objective">https://developers.google.com/optimization/lp/pdlp_math#reduced_costs_dual_residuals_and_the_corrected_dual_objective</a>. </p>

</div>
</div>
<a id="a3fad6392722c357cd629f5dc9cbb94a2" name="a3fad6392722c357cd629f5dc9cbb94a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fad6392722c357cd629f5dc9cbb94a2">&#9670;&#160;</a></span>ReducedCosts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::ReducedCosts </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_zero_primal_objective</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00532">532</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="ac371aa1f67b4d895ed970bf479e6ec5f" name="ac371aa1f67b4d895ed970bf479e6ec5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac371aa1f67b4d895ed970bf479e6ec5f">&#9670;&#160;</a></span>ScaledColL2Norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ScaledColL2Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the L2 norm of each column of a scaled matrix. </p>

</div>
</div>
<a id="aa3c5dd95681fe94691be1407d6bb62aa" name="aa3c5dd95681fe94691be1407d6bb62aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c5dd95681fe94691be1407d6bb62aa">&#9670;&#160;</a></span>ScaledColL2Norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::ScaledColL2Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00308">308</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ac825edcd2a72e7284c0b1c1ffce6dea0" name="ac825edcd2a72e7284c0b1c1ffce6dea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac825edcd2a72e7284c0b1c1ffce6dea0">&#9670;&#160;</a></span>ScaledColLInfNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ScaledColLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LInf norm of each column of a scaled matrix. </p>
<p>The functions below compute norms of the columns of a scaled matrix. The (i,j) entry of the scaled matrix equals matrix[i,j] * row_scaling_vec[i] * col_scaling_vec[j]. To ensure good parallelization the matrix passed here should have (roughly) the same location of non-zeros as the matrix passed to the <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a>'s constructor. The <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a>'s size must match the matrix's number of columns. </p>

</div>
</div>
<a id="a69a3cf251337531692721a574033a9df" name="a69a3cf251337531692721a574033a9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a3cf251337531692721a574033a9df">&#9670;&#160;</a></span>ScaledColLInfNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::ScaledColLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>row_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>col_scaling_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00286">286</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a42e24a12cfaed2024d52b70297b5a96b" name="a42e24a12cfaed2024d52b70297b5a96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e24a12cfaed2024d52b70297b5a96b">&#9670;&#160;</a></span>ScaledLInfNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ScaledL1Norm is omitted because it's not needed (yet). </p>
<p>LInf norm of a rescaled vector, i.e., vector.cwiseProduct(scale).lpNorm&lt;Eigen::Infinity&gt;(). </p>

</div>
</div>
<a id="a55b8c43a5adfafddb030074c75aeef70" name="a55b8c43a5adfafddb030074c75aeef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b8c43a5adfafddb030074c75aeef70">&#9670;&#160;</a></span>ScaledLInfNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00264">264</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a250eacb9ce6df8be7e5837a2279e7cca" name="a250eacb9ce6df8be7e5837a2279e7cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250eacb9ce6df8be7e5837a2279e7cca">&#9670;&#160;</a></span>ScaledNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L2 norm of a rescaled vector, i.e., vector.cwiseProduct(scale).norm(). </p>

</div>
</div>
<a id="a0b812156619599417e29521a41b7a734" name="a0b812156619599417e29521a41b7a734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b812156619599417e29521a41b7a734">&#9670;&#160;</a></span>ScaledNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00281">281</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="acff65f956f203f1538f4bbf0cd44fa2b" name="acff65f956f203f1538f4bbf0cd44fa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff65f956f203f1538f4bbf0cd44fa2b">&#9670;&#160;</a></span>ScaledSquaredNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledSquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Squared L2 norm of a rescaled vector, i.e., vector.cwiseProduct(scale).squaredNorm(). </p>

</div>
</div>
<a id="a65f71a53d7766ac4c753d2218887cf98" name="a65f71a53d7766ac4c753d2218887cf98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f71a53d7766ac4c753d2218887cf98">&#9670;&#160;</a></span>ScaledSquaredNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledSquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00274">274</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ab5bf48ca920aa5abf755b21a3a938e72" name="ab5bf48ca920aa5abf755b21a3a938e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bf48ca920aa5abf755b21a3a938e72">&#9670;&#160;</a></span>SetEigenMatrixFromTriplets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetEigenMatrixFromTriplets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::Triplet&lt; double, int64_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>triplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like matrix.setFromTriplets(triplets), except that setFromTriplets results in having three copies of the nonzeros in memory at the same time, because it first fills one matrix from triplets, and then transposes it into another. This avoids having the third copy in memory by sorting the triplets, reserving space in the matrix, and then inserting in sorted order. Compresses the matrix (SparseMatrix.makeCompressed()) after loading it. </p><dl class="section note"><dt>Note</dt><dd>This intentionally passes triplets by value, because it modifies them. To avoid the copy, pass a move reference. </dd></dl>
<p>The triplets are allowed to contain duplicate entries (and intentionally do for the diagonals of the objective matrix). For efficiency of insert and reserve, merge the duplicates first.</p>
<dl class="section note"><dt>Note</dt><dd>reserve() takes column counts because matrix is in column major order.</dd></dl>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00314">314</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a3082edb885e96d187a000584cf2c3046" name="a3082edb885e96d187a000584cf2c3046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3082edb885e96d187a000584cf2c3046">&#9670;&#160;</a></span>SetRandomProjections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetRandomProjections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>random_projection_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointMetadata &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each entry in random_projection_seeds, computes a random projection of the primal/dual solution pair onto pseudo-random vectors generated from that seed and adds the results to random_primal_projections/random_dual_projections in metadata. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00597">597</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="ad8b78b2d2b8f14df64e2d6def3ab5545" name="ad8b78b2d2b8f14df64e2d6def3ab5545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b78b2d2b8f14df64e2d6def3ab5545">&#9670;&#160;</a></span>SetZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following functions use a <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> to compute a vector operation in parallel. The <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> should have the same size as the vector(s). For best performance the <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> should have been created with the Sharder(int64_t,
int, ThreadPool*) constructor. Like dest.setZero(sharder.NumElements()). Note that if dest.size() != sharder.NumElements(), dest will be resized. </p>

</div>
</div>
<a id="a070d987d5d30e76fbbe2c32174eb3a4e" name="a070d987d5d30e76fbbe2c32174eb3a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d987d5d30e76fbbe2c32174eb3a4e">&#9670;&#160;</a></span>SetZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00173">173</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a24be2a07d0f1a8994196b4c7f74870c2" name="a24be2a07d0f1a8994196b4c7f74870c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24be2a07d0f1a8994196b4c7f74870c2">&#9670;&#160;</a></span>SmallDualInfeasibleLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallDualInfeasibleLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00233">233</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a86984b72235fd509deb9975088eafb82" name="a86984b72235fd509deb9975088eafb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86984b72235fd509deb9975088eafb82">&#9670;&#160;</a></span>SmallInconsistentVariableBoundsLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallInconsistentVariableBoundsLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00204">204</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a287eefed02ca53e0fa0af77382920688" name="a287eefed02ca53e0fa0af77382920688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287eefed02ca53e0fa0af77382920688">&#9670;&#160;</a></span>SmallInitializationLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallInitializationLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00246">246</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="aa340ee35401be0c80f722003a6ac987d" name="aa340ee35401be0c80f722003a6ac987d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340ee35401be0c80f722003a6ac987d">&#9670;&#160;</a></span>SmallInvalidProblemLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallInvalidProblemLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00191">191</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a0da8f33b9749e1da2c36dddc189d77fb" name="a0da8f33b9749e1da2c36dddc189d77fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da8f33b9749e1da2c36dddc189d77fb">&#9670;&#160;</a></span>SmallPrimalDualInfeasibleLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallPrimalDualInfeasibleLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00240">240</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="af846811056ccf9ca9b69bef6ff8dc528" name="af846811056ccf9ca9b69bef6ff8dc528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af846811056ccf9ca9b69bef6ff8dc528">&#9670;&#160;</a></span>SmallPrimalInfeasibleLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallPrimalInfeasibleLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00217">217</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a2f4054cb0abdfaacfebe5bf1b67eb9c9" name="a2f4054cb0abdfaacfebe5bf1b67eb9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4054cb0abdfaacfebe5bf1b67eb9c9">&#9670;&#160;</a></span>SolveDiagonalQpTrustRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalQpTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>primal_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>solve_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like SolveDiagonalTrustRegion, but extracts the problem data from a <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> and implicitly concatenates the primal and dual parts before solving the trust-region subproblem. </p>

</div>
</div>
<a id="a64c21ba4bf7d15e5dd1f8396074a9dfa" name="a64c21ba4bf7d15e5dd1f8396074a9dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c21ba4bf7d15e5dd1f8396074a9dfa">&#9670;&#160;</a></span>SolveDiagonalQpTrustRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalQpTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>sharded_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>primal_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>dual_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>primal_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>solve_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00755">755</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="ad87e72f6888d8bd27a4d74f35c3a118d" name="ad87e72f6888d8bd27a4d74f35c3a118d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87e72f6888d8bd27a4d74f35c3a118d">&#9670;&#160;</a></span>SolveDiagonalTrustRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>objective_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>objective_matrix_diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_lower_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_upper_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>norm_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>solve_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the following trust-region problem with bound constraints: min_x (1/2) * (x - center_point)' * Q * (x - center_point)</p><ul>
<li>objective_vector' * (x - center_point) s.t. variable_lower_bounds &lt;= x &lt;= variable_upper_bounds || x - center_point ||_W &lt;= target_radius where |<code>y</code>|_W = sqrt(sum_i norm_weights[i] * y[i]^2). It replaces the ball constraint || x - center_point ||_W &lt;= target_radius with the equivalent constraint 0.5 * || x - center_point ||_W^2 &lt;= 0.5 * target_radius^2 and does a binary search for a Lagrange multiplier for the latter constraint that is at most <code>solve_tolerance * <a class="el" href="alldiff__cst_8cc.html#a26e6db9bcc64b584051ecc28171ed11f">max(1, lambda*)</a></code> away from the optimum Lagrange multiplier lambda*. The sharder should have the same size as the number of variables in the problem. Assumes that there is always a feasible solution, that is, that variable_lower_bounds &lt;= center_point &lt;= variable_upper_bounds, and that norm_weights &gt; 0, for 0 &lt;= i &lt; sharder.NumElements(). </li>
</ul>

</div>
</div>
<a id="a5f128477eac14f0eda4b73fdfb3e24d4" name="a5f128477eac14f0eda4b73fdfb3e24d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f128477eac14f0eda4b73fdfb3e24d4">&#9670;&#160;</a></span>SolveDiagonalTrustRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>objective_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>objective_matrix_diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_lower_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_upper_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>norm_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>solve_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00742">742</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a39db3ccea12adec49816af128a288223" name="a39db3ccea12adec49816af128a288223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39db3ccea12adec49816af128a288223">&#9670;&#160;</a></span>SolveDiagonalTrustRegionProblem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalTrustRegionProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>solve_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the diagonal trust region problem using a binary search algorithm. See comment above <a class="el" href="namespaceoperations__research_1_1pdlp.html#a5f128477eac14f0eda4b73fdfb3e24d4">SolveDiagonalTrustRegion()</a> in <a class="el" href="trust__region_8h.html">trust_region.h</a> for the meaning of solve_tol. </p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00694">694</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a90dd3b503fb3d2bb8bd51729584d6bad" name="a90dd3b503fb3d2bb8bd51729584d6bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dd3b503fb3d2bb8bd51729584d6bad">&#9670;&#160;</a></span>SolveTrustRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>objective_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_lower_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_upper_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>norm_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the following trust-region problem with bound constraints: min_x objective_vector' * (x - center_point) s.t. variable_lower_bounds &lt;= x &lt;= variable_upper_bounds || x - center_point ||_W &lt;= target_radius where |<code>y</code>|_W = sqrt(sum_i norm_weights[i] * y[i]^2) using an exact linear-time method. The sharder should have the same size as the number of variables in the problem. Assumes that there is always a feasible solution, that is, that variable_lower_bounds &lt;= center_point &lt;= variable_upper_bounds, and that norm_weights &gt; 0, for 0 &lt;= i &lt; sharder.NumElements(). </p>

</div>
</div>
<a id="a8da80544adc685ee442522ede0e095a9" name="a8da80544adc685ee442522ede0e095a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da80544adc685ee442522ede0e095a9">&#9670;&#160;</a></span>SolveTrustRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>objective_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_lower_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>variable_upper_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>norm_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>target_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00453">453</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="acfdde18597f56c6108928669aa7e1fff" name="acfdde18597f56c6108928669aa7e1fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdde18597f56c6108928669aa7e1fff">&#9670;&#160;</a></span>SquaredDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredDistance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like (vector1 - vector2).squaredNorm() </p>

</div>
</div>
<a id="a32389515e696df20cec86493cf9852e6" name="a32389515e696df20cec86493cf9852e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32389515e696df20cec86493cf9852e6">&#9670;&#160;</a></span>SquaredDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredDistance </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00252">252</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ab11d2b633fbd4e06d2d51d95767105db" name="ab11d2b633fbd4e06d2d51d95767105db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11d2b633fbd4e06d2d51d95767105db">&#9670;&#160;</a></span>SquaredNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like vector.squaredNorm() </p>

</div>
</div>
<a id="a051e8994e91729e038b6cab678ef5f89" name="a051e8994e91729e038b6cab678ef5f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051e8994e91729e038b6cab678ef5f89">&#9670;&#160;</a></span>SquaredNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00243">243</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a1d16c98703c18ea1d861e274758f0e4b" name="a1d16c98703c18ea1d861e274758f0e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d16c98703c18ea1d861e274758f0e4b">&#9670;&#160;</a></span>TestDiagonalQp1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestDiagonalQp1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00143">143</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a9e82a5f4fad9211f4235a37919e36c64" name="a9e82a5f4fad9211f4235a37919e36c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e82a5f4fad9211f4235a37919e36c64">&#9670;&#160;</a></span>TestDiagonalQp2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestDiagonalQp2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00159">159</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a2be6c6d75aa743c9a64c87b093da0257" name="a2be6c6d75aa743c9a64c87b093da0257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be6c6d75aa743c9a64c87b093da0257">&#9670;&#160;</a></span>TestDiagonalQp3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestDiagonalQp3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00175">175</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a71efdc063650b57ca9c2dce8ba280aa2" name="a71efdc063650b57ca9c2dce8ba280aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71efdc063650b57ca9c2dce8ba280aa2">&#9670;&#160;</a></span>TestLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00033">33</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a3ffa435d5162dd0e66c54d0b99600816" name="a3ffa435d5162dd0e66c54d0b99600816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa435d5162dd0e66c54d0b99600816">&#9670;&#160;</a></span>TinyLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TinyLp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a small test LP. The LP: min 5 x_1 + 2 x_2 + x_3 + x_4 - 14 s.t. 2 x_1 + x_2 + x_3 + 2 x_4 = 12 x_1 + x_3 &gt;= 7 x_3 - x_4 &gt;= 1 0 &lt;= x_1 &lt;= 2 0 &lt;= x_2 &lt;= 4 0 &lt;= x_3 &lt;= 6 0 &lt;= x_4 &lt;= 3</p>
<p>Optimum solutions: Primal: x_1 = 1, x_2 = 0, x_3 = 6, x_4 = 2. Value: 5 + 0 + 6 + 2 - 14 = -1. Dual: [0.5, 4.0, 0.0] Value: 6 + 28 - 3.5*6 - 14 = -1 Reduced costs: [0.0, 1.5, -3.5, 0.0] </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00067">67</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a5c473c17b12a0b8d751a14939b0843ac" name="a5c473c17b12a0b8d751a14939b0843ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c473c17b12a0b8d751a14939b0843ac">&#9670;&#160;</a></span>ToDense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::Eigen::ArrayXXd operations_research::pdlp::ToDense </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sparse_mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00285">285</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="aef2cdcdbe1010ad09a8d2c6fe8bc8645" name="aef2cdcdbe1010ad09a8d2c6fe8bc8645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2cdcdbe1010ad09a8d2c6fe8bc8645">&#9670;&#160;</a></span>TransposedMatrixVectorProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::TransposedMatrixVectorProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like matrix.transpose() * vector but executed in parallel using the given <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a>. The <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a>'s size must match the matrix's number of columns. To ensure good parallelization the matrix passed here should have (roughly) the same location of non-zeros as the matrix passed to the <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a>'s constructor. </p>

</div>
</div>
<a id="a463586ded0a114d3ca4b97a048d37d8a" name="a463586ded0a114d3ca4b97a048d37d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463586ded0a114d3ca4b97a048d37d8a">&#9670;&#160;</a></span>TransposedMatrixVectorProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::TransposedMatrixVectorProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>For very sparse columns, assignment to shard(answer) incurs a measurable overhead compared to using a constructor (i.e. VectorXd temp = ...). It is not clear why this is the case, nor how to avoid it.</dd></dl>

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00158">158</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a46d3d32d0a8e4e2c01b081f331797e1f" name="a46d3d32d0a8e4e2c01b081f331797e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d3d32d0a8e4e2c01b081f331797e1f">&#9670;&#160;</a></span>ValidateAdaptiveLinesearchParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateAdaptiveLinesearchParams </td>
          <td>(</td>
          <td class="paramtype">const AdaptiveLinesearchParams &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns InvalidArgument if the proto contains invalid values. Returns OkStatus otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00115">115</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="aa1ed703509ec38f4d680039f6d62791a" name="aa1ed703509ec38f4d680039f6d62791a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ed703509ec38f4d680039f6d62791a">&#9670;&#160;</a></span>ValidateMalitskyPockParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateMalitskyPockParams </td>
          <td>(</td>
          <td class="paramtype">const MalitskyPockParams &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns InvalidArgument if the proto contains invalid values. Returns OkStatus otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00133">133</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a2d2bda13dd823757fe941eecc9dc328b" name="a2d2bda13dd823757fe941eecc9dc328b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2bda13dd823757fe941eecc9dc328b">&#9670;&#160;</a></span>ValidatePrimalDualHybridGradientParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidatePrimalDualHybridGradientParams </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns InvalidArgument if the proto contains invalid values. Returns OkStatus otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00159">159</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a29d607529c02f2842bdc5cb9c918bd1b" name="a29d607529c02f2842bdc5cb9c918bd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d607529c02f2842bdc5cb9c918bd1b">&#9670;&#160;</a></span>ValidateQuadraticProgramDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateQuadraticProgramDimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns InvalidArgument if vector or matrix dimensions are inconsistent. Returns OkStatus otherwise. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00037">37</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="aea1ddf99c0904d4ec8d3975975ffb4ff" name="aea1ddf99c0904d4ec8d3975975ffb4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1ddf99c0904d4ec8d3975975ffb4ff">&#9670;&#160;</a></span>ValidateTerminationCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateTerminationCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;&#160;</td>
          <td class="paramname"><em>criteria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns InvalidArgument if the proto contains invalid values. Returns OkStatus otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00040">40</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="aa645221539fcb7491fa586e9e568922a" name="aa645221539fcb7491fa586e9e568922a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa645221539fcb7491fa586e9e568922a">&#9670;&#160;</a></span>VerifyTestDiagonalQp1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::VerifyTestDiagonalQp1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maximize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00270">270</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a4d5567aad57ec9c50762717560246a25" name="a4d5567aad57ec9c50762717560246a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5567aad57ec9c50762717560246a25">&#9670;&#160;</a></span>VerifyTestLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::VerifyTestLp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maximize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the given <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> equals <a class="el" href="namespaceoperations__research_1_1pdlp.html#a71efdc063650b57ca9c2dce8ba280aa2">TestLp()</a>. </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00049">49</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a9efbc8bad87c896ca3c29f6ab4f969e5" name="a9efbc8bad87c896ca3c29f6ab4f969e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efbc8bad87c896ca3c29f6ab4f969e5">&#9670;&#160;</a></span>WriteLinearProgramToMps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::WriteLinearProgramToMps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mps_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This will fail if 'linear_program' is actually a quadratic program (that is, has a non-empty quadratic objective term). </dd></dl>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00092">92</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="ac69097fbe470f9bdb4110f2c54455926" name="ac69097fbe470f9bdb4110f2c54455926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69097fbe470f9bdb4110f2c54455926">&#9670;&#160;</a></span>WriteQuadraticProgramToMPModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::WriteQuadraticProgramToMPModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>quadratic_program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mpmodel_proto_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00107">107</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="a9385d74b2577097ab755dbf9c4f7c2ff" name="a9385d74b2577097ab755dbf9c4f7c2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9385d74b2577097ab755dbf9c4f7c2ff">&#9670;&#160;</a></span>ZeroVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;&#160;</td>
          <td class="paramname"><em>sharder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like VectorXd::Zero(sharder.NumElements()) </p>

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00179">179</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7b49a0361e8201ffd1515e0067b9fd30" name="a7b49a0361e8201ffd1515e0067b9fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b49a0361e8201ffd1515e0067b9fd30">&#9670;&#160;</a></span>kInfinity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double operations_research::pdlp::kInfinity = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00037">37</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a19f1afcc777ad3dbf7090595ce6fe803" name="a19f1afcc777ad3dbf7090595ce6fe803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f1afcc777ad3dbf7090595ce6fe803">&#9670;&#160;</a></span>x_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">x_0 x_1 x_2 operations_research::pdlp::x_3</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= 12</div>
<div class="line"> </div>
<div class="line"> 4 x_0                            &gt;=  -4</div>
<div class="line"> -1 &lt;=            1.5 x_2 -   <a class="code hl_variable" href="namespaceoperations__research_1_1pdlp.html#a19f1afcc777ad3dbf7090595ce6fe803">x_3</a>  &lt;= 1</div>
<div class="line"> </div>
<div class="line"> -2 &lt;= x_1 &lt;= infinity</div>
<div class="line"> </div>
<div class="line"> 2.5 &lt;= <a class="code hl_variable" href="namespaceoperations__research_1_1pdlp.html#a19f1afcc777ad3dbf7090595ce6fe803">x_3</a> &lt;= 3.5</div>
<div class="line"> </div>
<div class="line">QuadraticProgram <a class="code hl_function" href="namespaceoperations__research_1_1pdlp.html#a71efdc063650b57ca9c2dce8ba280aa2">TestLp</a>()</div>
<div class="ttc" id="anamespaceoperations__research_1_1pdlp_html_a19f1afcc777ad3dbf7090595ce6fe803"><div class="ttname"><a href="namespaceoperations__research_1_1pdlp.html#a19f1afcc777ad3dbf7090595ce6fe803">operations_research::pdlp::x_3</a></div><div class="ttdeci">x_0 x_1 x_2 x_3</div><div class="ttdef"><b>Definition:</b> <a href="test__util_8h_source.html#l00035">test_util.h:35</a></div></div>
<div class="ttc" id="anamespaceoperations__research_1_1pdlp_html_a71efdc063650b57ca9c2dce8ba280aa2"><div class="ttname"><a href="namespaceoperations__research_1_1pdlp.html#a71efdc063650b57ca9c2dce8ba280aa2">operations_research::pdlp::TestLp</a></div><div class="ttdeci">QuadraticProgram TestLp()</div><div class="ttdef"><b>Definition:</b> <a href="test__util_8cc_source.html#l00033">test_util.cc:33</a></div></div>
</div><!-- fragment --><p>A small LP with all 4 patterns of which lower and upper bounds on the constraints are finite and similarly for the variables. min 5.5 x_0 - 2 x_1 - x_2 + x_3 - 14 s.t. </p>

<p class="definition">Definition at line <a class="el" href="test__util_8h_source.html#l00035">35</a> of file <a class="el" href="test__util_8h_source.html">test_util.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1pdlp.html">pdlp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
