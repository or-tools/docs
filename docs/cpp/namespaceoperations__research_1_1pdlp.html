<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::pdlp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceoperations__research_1_1pdlp.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">operations_research::pdlp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Validation utilities for <a class="el" href="solvers_8proto.html">solvers.proto</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1pdlp_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespaceoperations__research_1_1pdlp_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for internal use only. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1EigenThreadPoolScheduler.html">EigenThreadPoolScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceEigen.html">Eigen</a> <a class="el" href="classoperations__research_1_1ThreadPool.html">ThreadPool</a> scheduler with barrier synchronization.  <a href="classoperations__research_1_1pdlp_1_1EigenThreadPoolScheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1GoogleThreadPoolScheduler.html">GoogleThreadPoolScheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Google3 <a class="el" href="classoperations__research_1_1ThreadPool.html">ThreadPool</a> scheduler with barrier synchronization.  <a href="classoperations__research_1_1pdlp_1_1GoogleThreadPoolScheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1RelativeConvergenceInformation.html">RelativeConvergenceInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1RescalingOptions.html">RescalingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1ScalingVectors.html">ScalingVectors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1Scheduler.html">Scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread scheduling interface.  <a href="classoperations__research_1_1pdlp_1_1Scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedWeightedAverage.html">ShardedWeightedAverage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1pdlp_1_1SolverLogger.html">SolverLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afe5252c7e11352b2fd773332db49caea" id="r_afe5252c7e11352b2fd773332db49caea"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe5252c7e11352b2fd773332db49caea">IterationType</a> { <br />
&#160;&#160;<a class="el" href="#afe5252c7e11352b2fd773332db49caeaa07fa7a19aa722c635a15e94cb7f50416">kNormal</a>
, <a class="el" href="#afe5252c7e11352b2fd773332db49caeaa3107a306d88a13c04181ef2ea88b75a6">kPrimalFeasibility</a>
, <a class="el" href="#afe5252c7e11352b2fd773332db49caeaae80733093bd583d1de0c376ade72293d">kDualFeasibility</a>
, <a class="el" href="#afe5252c7e11352b2fd773332db49caeaadff2ce8d72bb215fd32902d63bfae0bb">kPresolveTermination</a>
, <br />
&#160;&#160;<a class="el" href="#afe5252c7e11352b2fd773332db49caeaaff958e043681d83083ed771112b11d1b">kNormalTermination</a>
, <a class="el" href="#afe5252c7e11352b2fd773332db49caeaa5daa2a77074cdd5071382b576c7ff07b">kFeasibilityPolishingTermination</a>
<br />
 }</td></tr>
<tr class="separator:afe5252c7e11352b2fd773332db49caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b49502c323652c8d4e9a3fd3dd5cda7" id="r_a8b49502c323652c8d4e9a3fd3dd5cda7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a> { <a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7a974f1270f89b99d15b58a4d35c26aedc">kMaxNorm</a>
, <a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7aaafbdb17e2f1da89be62331fa0cf5503">kEuclideanNorm</a>
 }</td></tr>
<tr class="separator:a8b49502c323652c8d4e9a3fd3dd5cda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad3a4f857c920478cbdc673571b69f660" id="r_ad3a4f857c920478cbdc673571b69f660"><td class="memItemLeft" align="right" valign="top">ConvergenceInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a4f857c920478cbdc673571b69f660">ComputeConvergenceInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;scaled_sharded_qp, const Eigen::VectorXd &amp;col_scaling_vec, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;scaled_primal_solution, const Eigen::VectorXd &amp;scaled_dual_solution, const double componentwise_primal_residual_offset, const double componentwise_dual_residual_offset, PointType candidate_type)</td></tr>
<tr class="separator:ad3a4f857c920478cbdc673571b69f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09acbcbe1760b35dd5d927037c7089a7" id="r_a09acbcbe1760b35dd5d927037c7089a7"><td class="memItemLeft" align="right" valign="top">InfeasibilityInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09acbcbe1760b35dd5d927037c7089a7">ComputeInfeasibilityInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;scaled_sharded_qp, const Eigen::VectorXd &amp;col_scaling_vec, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;scaled_primal_ray, const Eigen::VectorXd &amp;scaled_dual_ray, const Eigen::VectorXd &amp;primal_solution_for_residual_tests, PointType candidate_type)</td></tr>
<tr class="separator:a09acbcbe1760b35dd5d927037c7089a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e1750531d2a33362a8b9b9158f5192" id="r_a91e1750531d2a33362a8b9b9158f5192"><td class="memItemLeft" align="right" valign="top">ConvergenceInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e1750531d2a33362a8b9b9158f5192">ComputeScaledConvergenceInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const VectorXd &amp;dual_solution, const double componentwise_primal_residual_offset, const double componentwise_dual_residual_offset, PointType candidate_type)</td></tr>
<tr class="separator:a91e1750531d2a33362a8b9b9158f5192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fad6392722c357cd629f5dc9cbb94a2" id="r_a3fad6392722c357cd629f5dc9cbb94a2"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fad6392722c357cd629f5dc9cbb94a2">ReducedCosts</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const VectorXd &amp;dual_solution, bool use_zero_primal_objective)</td></tr>
<tr class="separator:a3fad6392722c357cd629f5dc9cbb94a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22565ae8507a53fdd98f539757c11c2d" id="r_a22565ae8507a53fdd98f539757c11c2d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; ConvergenceInformation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22565ae8507a53fdd98f539757c11c2d">GetConvergenceInformation</a> (const IterationStats &amp;stats, PointType candidate_type)</td></tr>
<tr class="separator:a22565ae8507a53fdd98f539757c11c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d133b011f79db6b38b39d967ba1106" id="r_a46d133b011f79db6b38b39d967ba1106"><td class="memItemLeft" align="right" valign="top">std::optional&lt; InfeasibilityInformation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46d133b011f79db6b38b39d967ba1106">GetInfeasibilityInformation</a> (const IterationStats &amp;stats, PointType candidate_type)</td></tr>
<tr class="separator:a46d133b011f79db6b38b39d967ba1106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaf9a260a4e9bd5ed462840b5ee9cb8" id="r_a8aaf9a260a4e9bd5ed462840b5ee9cb8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; PointMetadata &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aaf9a260a4e9bd5ed462840b5ee9cb8">GetPointMetadata</a> (const IterationStats &amp;stats, const PointType point_type)</td></tr>
<tr class="separator:a8aaf9a260a4e9bd5ed462840b5ee9cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3082edb885e96d187a000584cf2c3046" id="r_a3082edb885e96d187a000584cf2c3046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3082edb885e96d187a000584cf2c3046">SetRandomProjections</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const Eigen::VectorXd &amp;dual_solution, const std::vector&lt; int &gt; &amp;random_projection_seeds, PointMetadata &amp;metadata)</td></tr>
<tr class="separator:a3082edb885e96d187a000584cf2c3046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cba1e0f05d2dd4e3efb2587802f022" id="r_a67cba1e0f05d2dd4e3efb2587802f022"><td class="memItemLeft" align="right" valign="top">ConvergenceInformation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67cba1e0f05d2dd4e3efb2587802f022">ComputeScaledConvergenceInformation</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const Eigen::VectorXd &amp;dual_solution, double componentwise_primal_residual_offset, double componentwise_dual_residual_offset, PointType candidate_type)</td></tr>
<tr class="separator:a67cba1e0f05d2dd4e3efb2587802f022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e56bcb1dbb063aac138bfaaeaca695a" id="r_a6e56bcb1dbb063aac138bfaaeaca695a"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e56bcb1dbb063aac138bfaaeaca695a">ReducedCosts</a> (const PrimalDualHybridGradientParams &amp;params, const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;scaled_sharded_qp, const Eigen::VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const Eigen::VectorXd &amp;dual_solution, bool use_zero_primal_objective=false)</td></tr>
<tr class="separator:a6e56bcb1dbb063aac138bfaaeaca695a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf423134517a37a89f497afc72942735" id="r_abf423134517a37a89f497afc72942735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf423134517a37a89f497afc72942735">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, const std::atomic&lt; bool &gt; *interrupt_solve, std::function&lt; void(const std::string &amp;)&gt; message_callback, IterationStatsCallback iteration_stats_callback)</td></tr>
<tr class="separator:abf423134517a37a89f497afc72942735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c304e3179e094cb89d838e86684c1e" id="r_a71c304e3179e094cb89d838e86684c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71c304e3179e094cb89d838e86684c1e">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt; initial_solution, const std::atomic&lt; bool &gt; *interrupt_solve, std::function&lt; void(const std::string &amp;)&gt; message_callback, IterationStatsCallback iteration_stats_callback)</td></tr>
<tr class="separator:a71c304e3179e094cb89d838e86684c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4976f41a18336d1f56e40e10927df23d" id="r_a4976f41a18336d1f56e40e10927df23d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4976f41a18336d1f56e40e10927df23d">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, const std::atomic&lt; bool &gt; *interrupt_solve=nullptr, std::function&lt; void(const std::string &amp;)&gt; message_callback=nullptr, std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt; iteration_stats_callback=nullptr)</td></tr>
<tr class="separator:a4976f41a18336d1f56e40e10927df23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8af91fb08550bb1fee05251d70b702d" id="r_af8af91fb08550bb1fee05251d70b702d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8af91fb08550bb1fee05251d70b702d">PrimalDualHybridGradient</a> (<a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> qp, const PrimalDualHybridGradientParams &amp;params, std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt; initial_solution, const std::atomic&lt; bool &gt; *interrupt_solve=nullptr, std::function&lt; void(const std::string &amp;)&gt; message_callback=nullptr, std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt; iteration_stats_callback=nullptr)</td></tr>
<tr class="separator:af8af91fb08550bb1fee05251d70b702d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d607529c02f2842bdc5cb9c918bd1b" id="r_a29d607529c02f2842bdc5cb9c918bd1b"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29d607529c02f2842bdc5cb9c918bd1b">ValidateQuadraticProgramDimensions</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:a29d607529c02f2842bdc5cb9c918bd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f90c55cdcb499205898fd7f90da6f3" id="r_a70f90c55cdcb499205898fd7f90da6f3"><td class="memItemLeft" align="right" valign="top">absl::StatusOr&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70f90c55cdcb499205898fd7f90da6f3">QpFromMpModelProto</a> (const MPModelProto &amp;proto, bool relax_integer_variables, bool include_names)</td></tr>
<tr class="separator:a70f90c55cdcb499205898fd7f90da6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98a981710e58e6eead1ca6c76f7b2b7" id="r_ad98a981710e58e6eead1ca6c76f7b2b7"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98a981710e58e6eead1ca6c76f7b2b7">CanFitInMpModelProto</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:ad98a981710e58e6eead1ca6c76f7b2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fc89d57cdfcdd70d122ffc32fb015d" id="r_a03fc89d57cdfcdd70d122ffc32fb015d"><td class="memItemLeft" align="right" valign="top">absl::StatusOr&lt; MPModelProto &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03fc89d57cdfcdd70d122ffc32fb015d">QpToMpModelProto</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:a03fc89d57cdfcdd70d122ffc32fb015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8124ffb313ef7566aec4a6cd14dfdf" id="r_a9c8124ffb313ef7566aec4a6cd14dfdf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c8124ffb313ef7566aec4a6cd14dfdf">ToString</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp, int64_t max_size)</td></tr>
<tr class="separator:a9c8124ffb313ef7566aec4a6cd14dfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bf48ca920aa5abf755b21a3a938e72" id="r_ab5bf48ca920aa5abf755b21a3a938e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5bf48ca920aa5abf755b21a3a938e72">SetEigenMatrixFromTriplets</a> (std::vector&lt; Eigen::Triplet&lt; double, int64_t &gt; &gt; triplets, Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix)</td></tr>
<tr class="separator:ab5bf48ca920aa5abf755b21a3a938e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850865b3deabb2a623e130691df99f15" id="r_a850865b3deabb2a623e130691df99f15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a850865b3deabb2a623e130691df99f15">IsLinearProgram</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp)</td></tr>
<tr class="separator:a850865b3deabb2a623e130691df99f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b7dc41ed788020cbaf942674f623d9" id="r_a80b7dc41ed788020cbaf942674f623d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80b7dc41ed788020cbaf942674f623d9">ReadQuadraticProgramOrDie</a> (const std::string &amp;filename, bool include_names)</td></tr>
<tr class="separator:a80b7dc41ed788020cbaf942674f623d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bff54df141c92a98fb14a56a06417c" id="r_a40bff54df141c92a98fb14a56a06417c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40bff54df141c92a98fb14a56a06417c">ReadMPModelProtoFileOrDie</a> (const std::string &amp;mpmodel_proto_file, bool include_names)</td></tr>
<tr class="separator:a40bff54df141c92a98fb14a56a06417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efbc8bad87c896ca3c29f6ab4f969e5" id="r_a9efbc8bad87c896ca3c29f6ab4f969e5"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9efbc8bad87c896ca3c29f6ab4f969e5">WriteLinearProgramToMps</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;linear_program, const std::string &amp;mps_file)</td></tr>
<tr class="separator:a9efbc8bad87c896ca3c29f6ab4f969e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69097fbe470f9bdb4110f2c54455926" id="r_ac69097fbe470f9bdb4110f2c54455926"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac69097fbe470f9bdb4110f2c54455926">WriteQuadraticProgramToMPModelProto</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;quadratic_program, const std::string &amp;mpmodel_proto_file)</td></tr>
<tr class="separator:ac69097fbe470f9bdb4110f2c54455926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49e60cdec3f8a1e616da88dc4761c9a" id="r_af49e60cdec3f8a1e616da88dc4761c9a"><td class="memItemLeft" align="right" valign="top">absl::StatusOr&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af49e60cdec3f8a1e616da88dc4761c9a">ReadMpsLinearProgram</a> (const std::string &amp;lp_file, bool include_names)</td></tr>
<tr class="separator:af49e60cdec3f8a1e616da88dc4761c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae83b2a0a223071e9c8a20cc2d8c0664" id="r_aae83b2a0a223071e9c8a20cc2d8c0664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae83b2a0a223071e9c8a20cc2d8c0664">ReadMpsLinearProgramOrDie</a> (const std::string &amp;lp_file, bool include_names)</td></tr>
<tr class="separator:aae83b2a0a223071e9c8a20cc2d8c0664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7cd58c59cd30e221879d2c9731ec7e" id="r_a0f7cd58c59cd30e221879d2c9731ec7e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1pdlp_1_1Scheduler.html">Scheduler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7cd58c59cd30e221879d2c9731ec7e">MakeScheduler</a> (SchedulerType type, int num_threads)</td></tr>
<tr class="memdesc:a0f7cd58c59cd30e221879d2c9731ec7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience factory function.  <br /></td></tr>
<tr class="separator:a0f7cd58c59cd30e221879d2c9731ec7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f96ba4fae041845072b4e960bb42d13" id="r_a0f96ba4fae041845072b4e960bb42d13"><td class="memItemLeft" align="right" valign="top">QuadraticProgramStats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f96ba4fae041845072b4e960bb42d13">ComputeStats</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;qp)</td></tr>
<tr class="memdesc:a0f96ba4fae041845072b4e960bb42d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>QuadraticProgramStats</code> for a <code><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a></code>.  <br /></td></tr>
<tr class="separator:a0f96ba4fae041845072b4e960bb42d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ded6625965f8ddd342161a55263cce" id="r_a54ded6625965f8ddd342161a55263cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54ded6625965f8ddd342161a55263cce">LInfRuizRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const int num_iterations, VectorXd &amp;row_scaling_vec, VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:a54ded6625965f8ddd342161a55263cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dee2894b8028a57b7f7d2306b402e44" id="r_a9dee2894b8028a57b7f7d2306b402e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dee2894b8028a57b7f7d2306b402e44">L2NormRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, VectorXd &amp;row_scaling_vec, VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:a9dee2894b8028a57b7f7d2306b402e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6db4184272e326213cd4a7ddc1cd4" id="r_acea6db4184272e326213cd4a7ddc1cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1ScalingVectors.html">ScalingVectors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea6db4184272e326213cd4a7ddc1cd4">ApplyRescaling</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1RescalingOptions.html">RescalingOptions</a> &amp;rescaling_options, <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp)</td></tr>
<tr class="separator:acea6db4184272e326213cd4a7ddc1cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259d3f73717a2ababa9df2dd43914656" id="r_a259d3f73717a2ababa9df2dd43914656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a259d3f73717a2ababa9df2dd43914656">ComputePrimalGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const VectorXd &amp;dual_product)</td></tr>
<tr class="separator:a259d3f73717a2ababa9df2dd43914656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d94aed55433c303286276bc57a8d77e" id="r_a8d94aed55433c303286276bc57a8d77e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d94aed55433c303286276bc57a8d77e">DualSubgradientCoefficient</a> (const double constraint_lower_bound, const double constraint_upper_bound, const double dual, const double primal_product)</td></tr>
<tr class="separator:a8d94aed55433c303286276bc57a8d77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0a68c36dafae816b5d18fdf7f4f2d1" id="r_a0b0a68c36dafae816b5d18fdf7f4f2d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b0a68c36dafae816b5d18fdf7f4f2d1">ComputeDualGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;dual_solution, const VectorXd &amp;primal_product)</td></tr>
<tr class="separator:a0b0a68c36dafae816b5d18fdf7f4f2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6985b8c7ce87b3858b50efa4a923a0eb" id="r_a6985b8c7ce87b3858b50efa4a923a0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6985b8c7ce87b3858b50efa4a923a0eb">EstimateMaximumSingularValueOfConstraintMatrix</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const std::optional&lt; VectorXd &gt; &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const std::optional&lt; VectorXd &gt; &amp;dual_solution, const double desired_relative_error, const double failure_probability, std::mt19937 &amp;mt_generator)</td></tr>
<tr class="separator:a6985b8c7ce87b3858b50efa4a923a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc88d1ca95af991600037eaf027f081b" id="r_acc88d1ca95af991600037eaf027f081b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc88d1ca95af991600037eaf027f081b">HasValidBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp)</td></tr>
<tr class="separator:acc88d1ca95af991600037eaf027f081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ae66853ff4985ca2911ba4d453fdc" id="r_a6b5ae66853ff4985ca2911ba4d453fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b5ae66853ff4985ca2911ba4d453fdc">ProjectToPrimalVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, VectorXd &amp;primal, const bool use_feasibility_bounds)</td></tr>
<tr class="separator:a6b5ae66853ff4985ca2911ba4d453fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898c0c776a5736cf1931036d0d370724" id="r_a898c0c776a5736cf1931036d0d370724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a898c0c776a5736cf1931036d0d370724">ProjectToDualVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, VectorXd &amp;dual)</td></tr>
<tr class="separator:a898c0c776a5736cf1931036d0d370724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897df53498faee509db98ef2681556ce" id="r_a897df53498faee509db98ef2681556ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a897df53498faee509db98ef2681556ce">LInfRuizRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, int num_iterations, Eigen::VectorXd &amp;row_scaling_vec, Eigen::VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:a897df53498faee509db98ef2681556ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41379e6fa8d7e6e6e8151c256906970" id="r_af41379e6fa8d7e6e6e8151c256906970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41379e6fa8d7e6e6e8151c256906970">L2NormRescaling</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, Eigen::VectorXd &amp;row_scaling_vec, Eigen::VectorXd &amp;col_scaling_vec)</td></tr>
<tr class="separator:af41379e6fa8d7e6e6e8151c256906970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe180ee4e003e6a819c90205bf38b60f" id="r_abe180ee4e003e6a819c90205bf38b60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe180ee4e003e6a819c90205bf38b60f">ComputePrimalGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const Eigen::VectorXd &amp;dual_product)</td></tr>
<tr class="separator:abe180ee4e003e6a819c90205bf38b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fca5ce03ac69c5ca4e0db9d39d62e0" id="r_a96fca5ce03ac69c5ca4e0db9d39d62e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96fca5ce03ac69c5ca4e0db9d39d62e0">ComputeDualGradient</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;dual_solution, const Eigen::VectorXd &amp;primal_product)</td></tr>
<tr class="separator:a96fca5ce03ac69c5ca4e0db9d39d62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4395f27dfe822c4efc56d16900841c22" id="r_a4395f27dfe822c4efc56d16900841c22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4395f27dfe822c4efc56d16900841c22">EstimateMaximumSingularValueOfConstraintMatrix</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const std::optional&lt; Eigen::VectorXd &gt; &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const std::optional&lt; Eigen::VectorXd &gt; &amp;dual_solution, double desired_relative_error, double failure_probability, std::mt19937 &amp;mt_generator)</td></tr>
<tr class="separator:a4395f27dfe822c4efc56d16900841c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7865a873a402347ac2065a887bacb299" id="r_a7865a873a402347ac2065a887bacb299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7865a873a402347ac2065a887bacb299">ProjectToPrimalVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, Eigen::VectorXd &amp;primal, bool use_feasibility_bounds=false)</td></tr>
<tr class="separator:a7865a873a402347ac2065a887bacb299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b46c4812be8af75325d63ed3ced80f0" id="r_a4b46c4812be8af75325d63ed3ced80f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b46c4812be8af75325d63ed3ced80f0">ProjectToDualVariableBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, Eigen::VectorXd &amp;dual)</td></tr>
<tr class="separator:a4b46c4812be8af75325d63ed3ced80f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463586ded0a114d3ca4b97a048d37d8a" id="r_a463586ded0a114d3ca4b97a048d37d8a"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a463586ded0a114d3ca4b97a048d37d8a">TransposedMatrixVectorProduct</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a463586ded0a114d3ca4b97a048d37d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d987d5d30e76fbbe2c32174eb3a4e" id="r_a070d987d5d30e76fbbe2c32174eb3a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070d987d5d30e76fbbe2c32174eb3a4e">SetZero</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a070d987d5d30e76fbbe2c32174eb3a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9385d74b2577097ab755dbf9c4f7c2ff" id="r_a9385d74b2577097ab755dbf9c4f7c2ff"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9385d74b2577097ab755dbf9c4f7c2ff">ZeroVector</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a9385d74b2577097ab755dbf9c4f7c2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>VectorXd::Zero(sharder.NumElements())</code>.  <br /></td></tr>
<tr class="separator:a9385d74b2577097ab755dbf9c4f7c2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd7d091bd562c2141e811478aaaa991" id="r_acbd7d091bd562c2141e811478aaaa991"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd7d091bd562c2141e811478aaaa991">OnesVector</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:acbd7d091bd562c2141e811478aaaa991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>VectorXd::Ones(sharder.NumElements())</code>.  <br /></td></tr>
<tr class="separator:acbd7d091bd562c2141e811478aaaa991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904cea6c14ac90eea354da5d70ec1719" id="r_a904cea6c14ac90eea354da5d70ec1719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a904cea6c14ac90eea354da5d70ec1719">AddScaledVector</a> (const double scale, const VectorXd &amp;increment, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a904cea6c14ac90eea354da5d70ec1719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca8f74da7e8301c8aee45f33c93896c" id="r_afca8f74da7e8301c8aee45f33c93896c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afca8f74da7e8301c8aee45f33c93896c">AssignVector</a> (const VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:afca8f74da7e8301c8aee45f33c93896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a3bad4a7c95a6d68387ba8ae8c104" id="r_aaa4a3bad4a7c95a6d68387ba8ae8c104"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4a3bad4a7c95a6d68387ba8ae8c104">CloneVector</a> (const VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aaa4a3bad4a7c95a6d68387ba8ae8c104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920005e41b36a7a0c7f4ad148ad7069d" id="r_a920005e41b36a7a0c7f4ad148ad7069d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a920005e41b36a7a0c7f4ad148ad7069d">CoefficientWiseProductInPlace</a> (const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a920005e41b36a7a0c7f4ad148ad7069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c8ca6bf2bb288c322e1d8fbd6ea2bc" id="r_a92c8ca6bf2bb288c322e1d8fbd6ea2bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c8ca6bf2bb288c322e1d8fbd6ea2bc">CoefficientWiseQuotientInPlace</a> (const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, VectorXd &amp;dest)</td></tr>
<tr class="separator:a92c8ca6bf2bb288c322e1d8fbd6ea2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11831586b99d28a708bc103bce1a945e" id="r_a11831586b99d28a708bc103bce1a945e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11831586b99d28a708bc103bce1a945e">Dot</a> (const VectorXd &amp;v1, const VectorXd &amp;v2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a11831586b99d28a708bc103bce1a945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a42241df5501b0165ee77c3de54d7f" id="r_a33a42241df5501b0165ee77c3de54d7f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33a42241df5501b0165ee77c3de54d7f">LInfNorm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a33a42241df5501b0165ee77c3de54d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa577696ad9121b3f002cd37de6f86989" id="r_aa577696ad9121b3f002cd37de6f86989"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa577696ad9121b3f002cd37de6f86989">L1Norm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aa577696ad9121b3f002cd37de6f86989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051e8994e91729e038b6cab678ef5f89" id="r_a051e8994e91729e038b6cab678ef5f89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a051e8994e91729e038b6cab678ef5f89">SquaredNorm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a051e8994e91729e038b6cab678ef5f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade56a0bd875b06000c45e1730398e5a8" id="r_ade56a0bd875b06000c45e1730398e5a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade56a0bd875b06000c45e1730398e5a8">Norm</a> (const VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:ade56a0bd875b06000c45e1730398e5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32389515e696df20cec86493cf9852e6" id="r_a32389515e696df20cec86493cf9852e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32389515e696df20cec86493cf9852e6">SquaredDistance</a> (const VectorXd &amp;vector1, const VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a32389515e696df20cec86493cf9852e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e28f45b9c1ccdec8d926b4034d3679b" id="r_a3e28f45b9c1ccdec8d926b4034d3679b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e28f45b9c1ccdec8d926b4034d3679b">Distance</a> (const VectorXd &amp;vector1, const VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a3e28f45b9c1ccdec8d926b4034d3679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b8c43a5adfafddb030074c75aeef70" id="r_a55b8c43a5adfafddb030074c75aeef70"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b8c43a5adfafddb030074c75aeef70">ScaledLInfNorm</a> (const VectorXd &amp;vector, const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a55b8c43a5adfafddb030074c75aeef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f71a53d7766ac4c753d2218887cf98" id="r_a65f71a53d7766ac4c753d2218887cf98"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65f71a53d7766ac4c753d2218887cf98">ScaledSquaredNorm</a> (const VectorXd &amp;vector, const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a65f71a53d7766ac4c753d2218887cf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b812156619599417e29521a41b7a734" id="r_a0b812156619599417e29521a41b7a734"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b812156619599417e29521a41b7a734">ScaledNorm</a> (const VectorXd &amp;vector, const VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a0b812156619599417e29521a41b7a734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a3cf251337531692721a574033a9df" id="r_a69a3cf251337531692721a574033a9df"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69a3cf251337531692721a574033a9df">ScaledColLInfNorm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const VectorXd &amp;row_scaling_vec, const VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a69a3cf251337531692721a574033a9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c5dd95681fe94691be1407d6bb62aa" id="r_aa3c5dd95681fe94691be1407d6bb62aa"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3c5dd95681fe94691be1407d6bb62aa">ScaledColL2Norm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const VectorXd &amp;row_scaling_vec, const VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aa3c5dd95681fe94691be1407d6bb62aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2cdcdbe1010ad09a8d2c6fe8bc8645" id="r_aef2cdcdbe1010ad09a8d2c6fe8bc8645"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef2cdcdbe1010ad09a8d2c6fe8bc8645">TransposedMatrixVectorProduct</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:aef2cdcdbe1010ad09a8d2c6fe8bc8645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b78b2d2b8f14df64e2d6def3ab5545" id="r_ad8b78b2d2b8f14df64e2d6def3ab5545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b78b2d2b8f14df64e2d6def3ab5545">SetZero</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="separator:ad8b78b2d2b8f14df64e2d6def3ab5545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b08cd6ba4e025f1df1ec41261e14db" id="r_a62b08cd6ba4e025f1df1ec41261e14db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b08cd6ba4e025f1df1ec41261e14db">AddScaledVector</a> (double scale, const Eigen::VectorXd &amp;increment, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:a62b08cd6ba4e025f1df1ec41261e14db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>dest += scale * increment</code>.  <br /></td></tr>
<tr class="separator:a62b08cd6ba4e025f1df1ec41261e14db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa393d2c90adfa983d1625e6e409d4f7" id="r_afa393d2c90adfa983d1625e6e409d4f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa393d2c90adfa983d1625e6e409d4f7">AssignVector</a> (const Eigen::VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:afa393d2c90adfa983d1625e6e409d4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>dest = vec</code>. <code>dest</code> is resized if needed.  <br /></td></tr>
<tr class="separator:afa393d2c90adfa983d1625e6e409d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed237f4d1a54c4da63c16cc38baf030" id="r_a3ed237f4d1a54c4da63c16cc38baf030"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ed237f4d1a54c4da63c16cc38baf030">CloneVector</a> (const Eigen::VectorXd &amp;vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a3ed237f4d1a54c4da63c16cc38baf030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of <code>vec</code>.  <br /></td></tr>
<tr class="separator:a3ed237f4d1a54c4da63c16cc38baf030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e7e8dab386b40f5984525566c9709f" id="r_af2e7e8dab386b40f5984525566c9709f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2e7e8dab386b40f5984525566c9709f">CoefficientWiseProductInPlace</a> (const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:af2e7e8dab386b40f5984525566c9709f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>dest = dest.cwiseProduct(scale)</code>.  <br /></td></tr>
<tr class="separator:af2e7e8dab386b40f5984525566c9709f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ba879295782a2f85c4903e0de21cbe" id="r_ae3ba879295782a2f85c4903e0de21cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ba879295782a2f85c4903e0de21cbe">CoefficientWiseQuotientInPlace</a> (const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, Eigen::VectorXd &amp;dest)</td></tr>
<tr class="memdesc:ae3ba879295782a2f85c4903e0de21cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>dest = dest.cwiseQuotient(scale)</code>.  <br /></td></tr>
<tr class="separator:ae3ba879295782a2f85c4903e0de21cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa51fc5a2896d98a940cc367c5bbfe5" id="r_adfa51fc5a2896d98a940cc367c5bbfe5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfa51fc5a2896d98a940cc367c5bbfe5">Dot</a> (const Eigen::VectorXd &amp;v1, const Eigen::VectorXd &amp;v2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:adfa51fc5a2896d98a940cc367c5bbfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>v1.dot(v2)</code>.  <br /></td></tr>
<tr class="separator:adfa51fc5a2896d98a940cc367c5bbfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cbc527d8c2c204dbd36be85cc4569d" id="r_ab2cbc527d8c2c204dbd36be85cc4569d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2cbc527d8c2c204dbd36be85cc4569d">LInfNorm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ab2cbc527d8c2c204dbd36be85cc4569d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>vector.lpNorm&lt;Eigen::Infinity&gt;()</code>, a.k.a. LInf norm.  <br /></td></tr>
<tr class="separator:ab2cbc527d8c2c204dbd36be85cc4569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e75bc358dc64d1dc080cb311acd449" id="r_a45e75bc358dc64d1dc080cb311acd449"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e75bc358dc64d1dc080cb311acd449">L1Norm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a45e75bc358dc64d1dc080cb311acd449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>vector.lpNorm&lt;1&gt;()</code>, a.k.a. L_1 norm.  <br /></td></tr>
<tr class="separator:a45e75bc358dc64d1dc080cb311acd449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11d2b633fbd4e06d2d51d95767105db" id="r_ab11d2b633fbd4e06d2d51d95767105db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab11d2b633fbd4e06d2d51d95767105db">SquaredNorm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ab11d2b633fbd4e06d2d51d95767105db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>vector.squaredNorm()</code>.  <br /></td></tr>
<tr class="separator:ab11d2b633fbd4e06d2d51d95767105db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3cc73755c80cd79c2fb1c697e1310a" id="r_a4f3cc73755c80cd79c2fb1c697e1310a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f3cc73755c80cd79c2fb1c697e1310a">Norm</a> (const Eigen::VectorXd &amp;vector, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a4f3cc73755c80cd79c2fb1c697e1310a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>vector.norm()</code>.  <br /></td></tr>
<tr class="separator:a4f3cc73755c80cd79c2fb1c697e1310a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdde18597f56c6108928669aa7e1fff" id="r_acfdde18597f56c6108928669aa7e1fff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfdde18597f56c6108928669aa7e1fff">SquaredDistance</a> (const Eigen::VectorXd &amp;vector1, const Eigen::VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:acfdde18597f56c6108928669aa7e1fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>(vector1 - vector2).squaredNorm()</code>.  <br /></td></tr>
<tr class="separator:acfdde18597f56c6108928669aa7e1fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09826daec0fbcdf6594b1ada846dbb3a" id="r_a09826daec0fbcdf6594b1ada846dbb3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09826daec0fbcdf6594b1ada846dbb3a">Distance</a> (const Eigen::VectorXd &amp;vector1, const Eigen::VectorXd &amp;vector2, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a09826daec0fbcdf6594b1ada846dbb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>(vector1 - vector2).norm()</code>.  <br /></td></tr>
<tr class="separator:a09826daec0fbcdf6594b1ada846dbb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e24a12cfaed2024d52b70297b5a96b" id="r_a42e24a12cfaed2024d52b70297b5a96b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42e24a12cfaed2024d52b70297b5a96b">ScaledLInfNorm</a> (const Eigen::VectorXd &amp;vector, const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a42e24a12cfaed2024d52b70297b5a96b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>ScaledL1Norm</code> is omitted because it's not needed (yet).  <br /></td></tr>
<tr class="separator:a42e24a12cfaed2024d52b70297b5a96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff65f956f203f1538f4bbf0cd44fa2b" id="r_acff65f956f203f1538f4bbf0cd44fa2b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff65f956f203f1538f4bbf0cd44fa2b">ScaledSquaredNorm</a> (const Eigen::VectorXd &amp;vector, const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:acff65f956f203f1538f4bbf0cd44fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250eacb9ce6df8be7e5837a2279e7cca" id="r_a250eacb9ce6df8be7e5837a2279e7cca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250eacb9ce6df8be7e5837a2279e7cca">ScaledNorm</a> (const Eigen::VectorXd &amp;vector, const Eigen::VectorXd &amp;scale, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:a250eacb9ce6df8be7e5837a2279e7cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2 norm of a rescaled vector, i.e., <code>vector.cwiseProduct(scale).norm()</code>.  <br /></td></tr>
<tr class="separator:a250eacb9ce6df8be7e5837a2279e7cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac825edcd2a72e7284c0b1c1ffce6dea0" id="r_ac825edcd2a72e7284c0b1c1ffce6dea0"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac825edcd2a72e7284c0b1c1ffce6dea0">ScaledColLInfNorm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ac825edcd2a72e7284c0b1c1ffce6dea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the LInf norm of each column of a scaled <code>matrix</code>.  <br /></td></tr>
<tr class="separator:ac825edcd2a72e7284c0b1c1ffce6dea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371aa1f67b4d895ed970bf479e6ec5f" id="r_ac371aa1f67b4d895ed970bf479e6ec5f"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac371aa1f67b4d895ed970bf479e6ec5f">ScaledColL2Norm</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;matrix, const Eigen::VectorXd &amp;row_scaling_vec, const Eigen::VectorXd &amp;col_scaling_vec, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="memdesc:ac371aa1f67b4d895ed970bf479e6ec5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the L2 norm of each column of a scaled <code>matrix</code>.  <br /></td></tr>
<tr class="separator:ac371aa1f67b4d895ed970bf479e6ec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7fb0fc4d208899d240d64bfa7b29c" id="r_a6ef7fb0fc4d208899d240d64bfa7b29c"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ef7fb0fc4d208899d240d64bfa7b29c">CheckNonNegative</a> (const double value, const absl::string_view name)</td></tr>
<tr class="separator:a6ef7fb0fc4d208899d240d64bfa7b29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1ddf99c0904d4ec8d3975975ffb4ff" id="r_aea1ddf99c0904d4ec8d3975975ffb4ff"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea1ddf99c0904d4ec8d3975975ffb4ff">ValidateTerminationCriteria</a> (const TerminationCriteria &amp;criteria)</td></tr>
<tr class="separator:aea1ddf99c0904d4ec8d3975975ffb4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d3d32d0a8e4e2c01b081f331797e1f" id="r_a46d3d32d0a8e4e2c01b081f331797e1f"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46d3d32d0a8e4e2c01b081f331797e1f">ValidateAdaptiveLinesearchParams</a> (const AdaptiveLinesearchParams &amp;params)</td></tr>
<tr class="separator:a46d3d32d0a8e4e2c01b081f331797e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ed703509ec38f4d680039f6d62791a" id="r_aa1ed703509ec38f4d680039f6d62791a"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1ed703509ec38f4d680039f6d62791a">ValidateMalitskyPockParams</a> (const MalitskyPockParams &amp;params)</td></tr>
<tr class="separator:aa1ed703509ec38f4d680039f6d62791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2bda13dd823757fe941eecc9dc328b" id="r_a2d2bda13dd823757fe941eecc9dc328b"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d2bda13dd823757fe941eecc9dc328b">ValidatePrimalDualHybridGradientParams</a> (const PrimalDualHybridGradientParams &amp;params)</td></tr>
<tr class="separator:a2d2bda13dd823757fe941eecc9dc328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05b31a796e1009f7087884df50815fc" id="r_ad05b31a796e1009f7087884df50815fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad05b31a796e1009f7087884df50815fc">ObjectiveGapMet</a> (const TerminationCriteria::DetailedOptimalityCriteria &amp;optimality_criteria, const ConvergenceInformation &amp;stats)</td></tr>
<tr class="separator:ad05b31a796e1009f7087884df50815fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa473ed1679cf7844c7a65548cabe8599" id="r_aa473ed1679cf7844c7a65548cabe8599"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa473ed1679cf7844c7a65548cabe8599">OptimalityCriteriaMet</a> (const TerminationCriteria::DetailedOptimalityCriteria &amp;optimality_criteria, const ConvergenceInformation &amp;stats, OptimalityNorm optimality_norm, const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;bound_norms)</td></tr>
<tr class="memdesc:aa473ed1679cf7844c7a65548cabe8599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the optimality criteria are met.  <br /></td></tr>
<tr class="separator:aa473ed1679cf7844c7a65548cabe8599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5acb887ad53db5411c34545980f993" id="r_a3a5acb887ad53db5411c34545980f993"><td class="memItemLeft" align="right" valign="top">TerminationCriteria::DetailedOptimalityCriteria&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a5acb887ad53db5411c34545980f993">EffectiveOptimalityCriteria</a> (const TerminationCriteria &amp;termination_criteria)</td></tr>
<tr class="memdesc:a3a5acb887ad53db5411c34545980f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the effective optimality criteria for a <code>TerminationCriteria</code>.  <br /></td></tr>
<tr class="separator:a3a5acb887ad53db5411c34545980f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254f8c83c3395526dcc958f19e3c14a" id="r_a7254f8c83c3395526dcc958f19e3c14a"><td class="memItemLeft" align="right" valign="top">TerminationCriteria::DetailedOptimalityCriteria&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7254f8c83c3395526dcc958f19e3c14a">EffectiveOptimalityCriteria</a> (const TerminationCriteria::SimpleOptimalityCriteria &amp;simple_criteria)</td></tr>
<tr class="separator:a7254f8c83c3395526dcc958f19e3c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd964babbc05f32fd088b1005215dc" id="r_a02fd964babbc05f32fd088b1005215dc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02fd964babbc05f32fd088b1005215dc">CheckSimpleTerminationCriteria</a> (const TerminationCriteria &amp;criteria, const IterationStats &amp;stats, const std::atomic&lt; bool &gt; *interrupt_solve)</td></tr>
<tr class="separator:a02fd964babbc05f32fd088b1005215dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915b4c9c60210eb50bbb836643aba393" id="r_a915b4c9c60210eb50bbb836643aba393"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a915b4c9c60210eb50bbb836643aba393">CheckIterateTerminationCriteria</a> (const TerminationCriteria &amp;criteria, const IterationStats &amp;stats, const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;bound_norms, const bool force_numerical_termination)</td></tr>
<tr class="separator:a915b4c9c60210eb50bbb836643aba393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c3bece6c277a26a34c825c2b4e4509" id="r_a58c3bece6c277a26a34c825c2b4e4509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58c3bece6c277a26a34c825c2b4e4509">BoundNormsFromProblemStats</a> (const QuadraticProgramStats &amp;stats)</td></tr>
<tr class="separator:a58c3bece6c277a26a34c825c2b4e4509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7474762d0771b51e98686306ec7b4f" id="r_a5c7474762d0771b51e98686306ec7b4f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c7474762d0771b51e98686306ec7b4f">EpsilonRatio</a> (const double epsilon_absolute, const double epsilon_relative)</td></tr>
<tr class="separator:a5c7474762d0771b51e98686306ec7b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabaaef8b32ae92f1331599732ac99d1" id="r_afabaaef8b32ae92f1331599732ac99d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1RelativeConvergenceInformation.html">RelativeConvergenceInformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afabaaef8b32ae92f1331599732ac99d1">ComputeRelativeResiduals</a> (const TerminationCriteria::DetailedOptimalityCriteria &amp;optimality_criteria, const ConvergenceInformation &amp;stats, const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;bound_norms)</td></tr>
<tr class="separator:afabaaef8b32ae92f1331599732ac99d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71efdc063650b57ca9c2dce8ba280aa2" id="r_a71efdc063650b57ca9c2dce8ba280aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71efdc063650b57ca9c2dce8ba280aa2">TestLp</a> ()</td></tr>
<tr class="separator:a71efdc063650b57ca9c2dce8ba280aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5567aad57ec9c50762717560246a25" id="r_a4d5567aad57ec9c50762717560246a25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d5567aad57ec9c50762717560246a25">VerifyTestLp</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp, bool maximize=false)</td></tr>
<tr class="memdesc:a4d5567aad57ec9c50762717560246a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> equals <a class="el" href="#a71efdc063650b57ca9c2dce8ba280aa2">TestLp()</a>.  <br /></td></tr>
<tr class="separator:a4d5567aad57ec9c50762717560246a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa435d5162dd0e66c54d0b99600816" id="r_a3ffa435d5162dd0e66c54d0b99600816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ffa435d5162dd0e66c54d0b99600816">TinyLp</a> ()</td></tr>
<tr class="separator:a3ffa435d5162dd0e66c54d0b99600816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacc8fc59edce54401bcdee2cf277c4e" id="r_adacc8fc59edce54401bcdee2cf277c4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adacc8fc59edce54401bcdee2cf277c4e">CorrelationClusteringLp</a> ()</td></tr>
<tr class="memdesc:adacc8fc59edce54401bcdee2cf277c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">| /  <br /></td></tr>
<tr class="separator:adacc8fc59edce54401bcdee2cf277c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23678bb7c561c0ebbc4c3e2a941fbd9d" id="r_a23678bb7c561c0ebbc4c3e2a941fbd9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23678bb7c561c0ebbc4c3e2a941fbd9d">CorrelationClusteringStarLp</a> ()</td></tr>
<tr class="separator:a23678bb7c561c0ebbc4c3e2a941fbd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d16c98703c18ea1d861e274758f0e4b" id="r_a1d16c98703c18ea1d861e274758f0e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d16c98703c18ea1d861e274758f0e4b">TestDiagonalQp1</a> ()</td></tr>
<tr class="separator:a1d16c98703c18ea1d861e274758f0e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e82a5f4fad9211f4235a37919e36c64" id="r_a9e82a5f4fad9211f4235a37919e36c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e82a5f4fad9211f4235a37919e36c64">TestDiagonalQp2</a> ()</td></tr>
<tr class="separator:a9e82a5f4fad9211f4235a37919e36c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be6c6d75aa743c9a64c87b093da0257" id="r_a2be6c6d75aa743c9a64c87b093da0257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2be6c6d75aa743c9a64c87b093da0257">TestDiagonalQp3</a> ()</td></tr>
<tr class="separator:a2be6c6d75aa743c9a64c87b093da0257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340ee35401be0c80f722003a6ac987d" id="r_aa340ee35401be0c80f722003a6ac987d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa340ee35401be0c80f722003a6ac987d">SmallInvalidProblemLp</a> ()</td></tr>
<tr class="separator:aa340ee35401be0c80f722003a6ac987d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86984b72235fd509deb9975088eafb82" id="r_a86984b72235fd509deb9975088eafb82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86984b72235fd509deb9975088eafb82">SmallInconsistentVariableBoundsLp</a> ()</td></tr>
<tr class="separator:a86984b72235fd509deb9975088eafb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af846811056ccf9ca9b69bef6ff8dc528" id="r_af846811056ccf9ca9b69bef6ff8dc528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af846811056ccf9ca9b69bef6ff8dc528">SmallPrimalInfeasibleLp</a> ()</td></tr>
<tr class="separator:af846811056ccf9ca9b69bef6ff8dc528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24be2a07d0f1a8994196b4c7f74870c2" id="r_a24be2a07d0f1a8994196b4c7f74870c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24be2a07d0f1a8994196b4c7f74870c2">SmallDualInfeasibleLp</a> ()</td></tr>
<tr class="separator:a24be2a07d0f1a8994196b4c7f74870c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da8f33b9749e1da2c36dddc189d77fb" id="r_a0da8f33b9749e1da2c36dddc189d77fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0da8f33b9749e1da2c36dddc189d77fb">SmallPrimalDualInfeasibleLp</a> ()</td></tr>
<tr class="separator:a0da8f33b9749e1da2c36dddc189d77fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287eefed02ca53e0fa0af77382920688" id="r_a287eefed02ca53e0fa0af77382920688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a287eefed02ca53e0fa0af77382920688">SmallInitializationLp</a> ()</td></tr>
<tr class="separator:a287eefed02ca53e0fa0af77382920688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9961ddc0f992257e088066b1d9f59b92" id="r_a9961ddc0f992257e088066b1d9f59b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9961ddc0f992257e088066b1d9f59b92">LpWithoutConstraints</a> ()</td></tr>
<tr class="separator:a9961ddc0f992257e088066b1d9f59b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa645221539fcb7491fa586e9e568922a" id="r_aa645221539fcb7491fa586e9e568922a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa645221539fcb7491fa586e9e568922a">VerifyTestDiagonalQp1</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;qp, bool maximize)</td></tr>
<tr class="separator:aa645221539fcb7491fa586e9e568922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c473c17b12a0b8d751a14939b0843ac" id="r_a5c473c17b12a0b8d751a14939b0843ac"><td class="memItemLeft" align="right" valign="top">::Eigen::ArrayXXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c473c17b12a0b8d751a14939b0843ac">ToDense</a> (const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;sparse_mat)</td></tr>
<tr class="separator:a5c473c17b12a0b8d751a14939b0843ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da80544adc685ee442522ede0e095a9" id="r_a8da80544adc685ee442522ede0e095a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8da80544adc685ee442522ede0e095a9">SolveTrustRegion</a> (const VectorXd &amp;objective_vector, const VectorXd &amp;variable_lower_bounds, const VectorXd &amp;variable_upper_bounds, const VectorXd &amp;center_point, const VectorXd &amp;norm_weights, const double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a8da80544adc685ee442522ede0e095a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac468743f4a9b4acb96d783b3b353a8a" id="r_aac468743f4a9b4acb96d783b3b353a8a"><td class="memItemLeft" align="right" valign="top">dual_gradient&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac468743f4a9b4acb96d783b3b353a8a">T</a> (y - `dual_solution`) class DiagonalTrustRegionProblemFromQp</td></tr>
<tr class="separator:aac468743f4a9b4acb96d783b3b353a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb6df46237b5d870b93c6566cadd722" id="r_accb6df46237b5d870b93c6566cadd722"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </td></tr>
<tr class="memitem:accb6df46237b5d870b93c6566cadd722"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#accb6df46237b5d870b93c6566cadd722">ProjectedValueOfScaledDifference</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const int64_t index, const double scaling_factor)</td></tr>
<tr class="separator:accb6df46237b5d870b93c6566cadd722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c71f00da2c898c481414c3e92f12f0d" id="r_a3c71f00da2c898c481414c3e92f12f0d"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </td></tr>
<tr class="memitem:a3c71f00da2c898c481414c3e92f12f0d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c71f00da2c898c481414c3e92f12f0d">NormOfDeltaProjection</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double scaling_factor)</td></tr>
<tr class="separator:a3c71f00da2c898c481414c3e92f12f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd16384c5572b001a57e9987bf5b0e9" id="r_a7bd16384c5572b001a57e9987bf5b0e9"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </td></tr>
<tr class="memitem:a7bd16384c5572b001a57e9987bf5b0e9"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7bd16384c5572b001a57e9987bf5b0e9">FindScalingFactor</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double target_radius, const double solve_tol)</td></tr>
<tr class="separator:a7bd16384c5572b001a57e9987bf5b0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39db3ccea12adec49816af128a288223" id="r_a39db3ccea12adec49816af128a288223"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </td></tr>
<tr class="memitem:a39db3ccea12adec49816af128a288223"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39db3ccea12adec49816af128a288223">SolveDiagonalTrustRegionProblem</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;problem, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double target_radius, const double solve_tol)</td></tr>
<tr class="separator:a39db3ccea12adec49816af128a288223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f128477eac14f0eda4b73fdfb3e24d4" id="r_a5f128477eac14f0eda4b73fdfb3e24d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f128477eac14f0eda4b73fdfb3e24d4">SolveDiagonalTrustRegion</a> (const VectorXd &amp;objective_vector, const VectorXd &amp;objective_matrix_diagonal, const VectorXd &amp;variable_lower_bounds, const VectorXd &amp;variable_upper_bounds, const VectorXd &amp;center_point, const VectorXd &amp;norm_weights, const double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, const double solve_tolerance)</td></tr>
<tr class="separator:a5f128477eac14f0eda4b73fdfb3e24d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c21ba4bf7d15e5dd1f8396074a9dfa" id="r_a64c21ba4bf7d15e5dd1f8396074a9dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64c21ba4bf7d15e5dd1f8396074a9dfa">SolveDiagonalQpTrustRegion</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const VectorXd &amp;dual_solution, const VectorXd &amp;primal_gradient, const VectorXd &amp;dual_gradient, const double primal_weight, double target_radius, const double solve_tolerance)</td></tr>
<tr class="separator:a64c21ba4bf7d15e5dd1f8396074a9dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb77e7cede2fecf6bccfa93226b49c0b" id="r_adb77e7cede2fecf6bccfa93226b49c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb77e7cede2fecf6bccfa93226b49c0b">ComputeLocalizedLagrangianBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const VectorXd &amp;dual_solution, const <a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a> primal_dual_norm, const double primal_weight, const double radius, const VectorXd *primal_product, const VectorXd *dual_product, const bool use_diagonal_qp_trust_region_solver, const double diagonal_qp_trust_region_solver_tolerance)</td></tr>
<tr class="separator:adb77e7cede2fecf6bccfa93226b49c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dd3b503fb3d2bb8bd51729584d6bad" id="r_a90dd3b503fb3d2bb8bd51729584d6bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90dd3b503fb3d2bb8bd51729584d6bad">SolveTrustRegion</a> (const Eigen::VectorXd &amp;objective_vector, const Eigen::VectorXd &amp;variable_lower_bounds, const Eigen::VectorXd &amp;variable_upper_bounds, const Eigen::VectorXd &amp;center_point, const Eigen::VectorXd &amp;norm_weights, double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder)</td></tr>
<tr class="separator:a90dd3b503fb3d2bb8bd51729584d6bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87e72f6888d8bd27a4d74f35c3a118d" id="r_ad87e72f6888d8bd27a4d74f35c3a118d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad87e72f6888d8bd27a4d74f35c3a118d">SolveDiagonalTrustRegion</a> (const Eigen::VectorXd &amp;objective_vector, const Eigen::VectorXd &amp;objective_matrix_diagonal, const Eigen::VectorXd &amp;variable_lower_bounds, const Eigen::VectorXd &amp;variable_upper_bounds, const Eigen::VectorXd &amp;center_point, const Eigen::VectorXd &amp;norm_weights, double target_radius, const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;sharder, double solve_tolerance)</td></tr>
<tr class="separator:ad87e72f6888d8bd27a4d74f35c3a118d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4054cb0abdfaacfebe5bf1b67eb9c9" id="r_a2f4054cb0abdfaacfebe5bf1b67eb9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f4054cb0abdfaacfebe5bf1b67eb9c9">SolveDiagonalQpTrustRegion</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const Eigen::VectorXd &amp;dual_solution, const Eigen::VectorXd &amp;primal_gradient, const Eigen::VectorXd &amp;dual_gradient, const double primal_weight, double target_radius, double solve_tolerance)</td></tr>
<tr class="separator:a2f4054cb0abdfaacfebe5bf1b67eb9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd1506c32f697aeb13c4b9a9f05ba03" id="r_afdd1506c32f697aeb13c4b9a9f05ba03"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdd1506c32f697aeb13c4b9a9f05ba03">BoundGap</a> (const <a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> &amp;bounds)</td></tr>
<tr class="separator:afdd1506c32f697aeb13c4b9a9f05ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46fc3f284d5b39c05bbbf7f36bbc1c4" id="r_ac46fc3f284d5b39c05bbbf7f36bbc1c4"><td class="memItemLeft" align="right" valign="top">*x <a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac46fc3f284d5b39c05bbbf7f36bbc1c4">ComputeLocalizedLagrangianBounds</a> (const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;sharded_qp, const Eigen::VectorXd &amp;<a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a>, const Eigen::VectorXd &amp;dual_solution, <a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a> primal_dual_norm, double primal_weight, double radius, const Eigen::VectorXd *primal_product, const Eigen::VectorXd *dual_product, bool use_diagonal_qp_trust_region_solver, double diagonal_qp_trust_region_solver_tolerance)</td></tr>
<tr class="separator:ac46fc3f284d5b39c05bbbf7f36bbc1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7b49a0361e8201ffd1515e0067b9fd30" id="r_a7b49a0361e8201ffd1515e0067b9fd30"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b49a0361e8201ffd1515e0067b9fd30">kInfinity</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="separator:a7b49a0361e8201ffd1515e0067b9fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a438627fa7471011a97cf5bd367aa0" id="r_a46a438627fa7471011a97cf5bd367aa0"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46a438627fa7471011a97cf5bd367aa0">kTinyDouble</a> = 1.0e-50</td></tr>
<tr class="separator:a46a438627fa7471011a97cf5bd367aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bde348ab02e750d7423c8e551daedf" id="r_a29bde348ab02e750d7423c8e551daedf"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29bde348ab02e750d7423c8e551daedf">kHugeDouble</a> = 1.0e50</td></tr>
<tr class="separator:a29bde348ab02e750d7423c8e551daedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f1afcc777ad3dbf7090595ce6fe803" id="r_a19f1afcc777ad3dbf7090595ce6fe803"><td class="memItemLeft" align="right" valign="top">x_0 x_1 x_2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19f1afcc777ad3dbf7090595ce6fe803">x_3</a></td></tr>
<tr class="separator:a19f1afcc777ad3dbf7090595ce6fe803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eacdd74b066b885e267adad79344020" id="r_a5eacdd74b066b885e267adad79344020"><td class="memItemLeft" align="right" valign="top">*x&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5eacdd74b066b885e267adad79344020">primal_solution</a></td></tr>
<tr class="separator:a5eacdd74b066b885e267adad79344020"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Validation utilities for <a class="el" href="solvers_8proto.html">solvers.proto</a>. </p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. These are internal helper functions and classes that implicitly or explicitly operate on a <code><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a></code>. Utilities that are purely linear algebra operations (e.g., norms) should be defined in <a class="el" href="sharder_8h.html">sharder.h</a> instead. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afe5252c7e11352b2fd773332db49caea" name="afe5252c7e11352b2fd773332db49caea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5252c7e11352b2fd773332db49caea">&#9670;&#160;</a></span>IterationType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#afe5252c7e11352b2fd773332db49caea">operations_research::pdlp::IterationType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Identifies the iteration type in a callback. The callback is called both for intermediate iterations and upon termination. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe5252c7e11352b2fd773332db49caeaa07fa7a19aa722c635a15e94cb7f50416" name="afe5252c7e11352b2fd773332db49caeaa07fa7a19aa722c635a15e94cb7f50416"></a>kNormal&#160;</td><td class="fielddoc"><p>An intermediate iteration in the "main" phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe5252c7e11352b2fd773332db49caeaa3107a306d88a13c04181ef2ea88b75a6" name="afe5252c7e11352b2fd773332db49caeaa3107a306d88a13c04181ef2ea88b75a6"></a>kPrimalFeasibility&#160;</td><td class="fielddoc"><p>An intermediate iteration during a primal feasibility polishing phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe5252c7e11352b2fd773332db49caeaae80733093bd583d1de0c376ade72293d" name="afe5252c7e11352b2fd773332db49caeaae80733093bd583d1de0c376ade72293d"></a>kDualFeasibility&#160;</td><td class="fielddoc"><p>An intermediate iteration during a dual feasibility polishing phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe5252c7e11352b2fd773332db49caeaadff2ce8d72bb215fd32902d63bfae0bb" name="afe5252c7e11352b2fd773332db49caeaadff2ce8d72bb215fd32902d63bfae0bb"></a>kPresolveTermination&#160;</td><td class="fielddoc"><p>Terminating with a solution found by presolve. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe5252c7e11352b2fd773332db49caeaaff958e043681d83083ed771112b11d1b" name="afe5252c7e11352b2fd773332db49caeaaff958e043681d83083ed771112b11d1b"></a>kNormalTermination&#160;</td><td class="fielddoc"><p>Terminating with a solution found by the "main" phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="afe5252c7e11352b2fd773332db49caeaa5daa2a77074cdd5071382b576c7ff07b" name="afe5252c7e11352b2fd773332db49caeaa5daa2a77074cdd5071382b576c7ff07b"></a>kFeasibilityPolishingTermination&#160;</td><td class="fielddoc"><p>Terminating with a solution found by feasibility polishing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="primal__dual__hybrid__gradient_8h_source.html#l00075">75</a> of file <a class="el" href="primal__dual__hybrid__gradient_8h_source.html">primal_dual_hybrid_gradient.h</a>.</p>

</div>
</div>
<a id="a8b49502c323652c8d4e9a3fd3dd5cda7" name="a8b49502c323652c8d4e9a3fd3dd5cda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b49502c323652c8d4e9a3fd3dd5cda7">&#9670;&#160;</a></span>PrimalDualNorm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7">operations_research::pdlp::PrimalDualNorm</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a norm on a vector partitioned as (x, y) where x is the primal and y is the dual. The enum values define a joint norm as a function of |<code>x</code>|_P and |<code>y</code>|_D, whose definition depends on the context. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b49502c323652c8d4e9a3fd3dd5cda7a974f1270f89b99d15b58a4d35c26aedc" name="a8b49502c323652c8d4e9a3fd3dd5cda7a974f1270f89b99d15b58a4d35c26aedc"></a>kMaxNorm&#160;</td><td class="fielddoc"><p>The joint norm ||(x,y)||_PD = max{|<code>x</code>|_P, |<code>y</code>|_D}. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8b49502c323652c8d4e9a3fd3dd5cda7aaafbdb17e2f1da89be62331fa0cf5503" name="a8b49502c323652c8d4e9a3fd3dd5cda7aaafbdb17e2f1da89be62331fa0cf5503"></a>kEuclideanNorm&#160;</td><td class="fielddoc"><p>The joint norm (||(x,y)||_PD)^2 = (|<code>x</code>|_P)^2 + (|<code>y</code>|_D)^2. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="trust__region_8h_source.html#l00120">120</a> of file <a class="el" href="trust__region_8h_source.html">trust_region.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a904cea6c14ac90eea354da5d70ec1719" name="a904cea6c14ac90eea354da5d70ec1719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904cea6c14ac90eea354da5d70ec1719">&#9670;&#160;</a></span>AddScaledVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AddScaledVector </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>increment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00193">193</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a62b08cd6ba4e025f1df1ec41261e14db" name="a62b08cd6ba4e025f1df1ec41261e14db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b08cd6ba4e025f1df1ec41261e14db">&#9670;&#160;</a></span>AddScaledVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AddScaledVector </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>increment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>dest += scale * increment</code>. </p>

</div>
</div>
<a id="acea6db4184272e326213cd4a7ddc1cd4" name="acea6db4184272e326213cd4a7ddc1cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea6db4184272e326213cd4a7ddc1cd4">&#9670;&#160;</a></span>ApplyRescaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1ScalingVectors.html">ScalingVectors</a> operations_research::pdlp::ApplyRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1RescalingOptions.html">RescalingOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rescaling_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the rescaling specified by <code>rescaling_options</code> to <code>sharded_qp</code> (in place). Returns the scaling vectors that were applied. </p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00423">423</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="afa393d2c90adfa983d1625e6e409d4f7" name="afa393d2c90adfa983d1625e6e409d4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa393d2c90adfa983d1625e6e409d4f7">&#9670;&#160;</a></span>AssignVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AssignVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>dest = vec</code>. <code>dest</code> is resized if needed. </p>

</div>
</div>
<a id="afca8f74da7e8301c8aee45f33c93896c" name="afca8f74da7e8301c8aee45f33c93896c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca8f74da7e8301c8aee45f33c93896c">&#9670;&#160;</a></span>AssignVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::AssignVector </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00200">200</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="afdd1506c32f697aeb13c4b9a9f05ba03" name="afdd1506c32f697aeb13c4b9a9f05ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd1506c32f697aeb13c4b9a9f05ba03">&#9670;&#160;</a></span>BoundGap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::BoundGap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8h_source.html#l00113">113</a> of file <a class="el" href="trust__region_8h_source.html">trust_region.h</a>.</p>

</div>
</div>
<a id="a58c3bece6c277a26a34c825c2b4e4509" name="a58c3bece6c277a26a34c825c2b4e4509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c3bece6c277a26a34c825c2b4e4509">&#9670;&#160;</a></span>BoundNormsFromProblemStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> operations_research::pdlp::BoundNormsFromProblemStats </td>
          <td>(</td>
          <td class="paramtype">const QuadraticProgramStats &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the norms needed for the termination criteria from the full problem <code>stats</code>. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00221">221</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="ad98a981710e58e6eead1ca6c76f7b2b7" name="ad98a981710e58e6eead1ca6c76f7b2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98a981710e58e6eead1ca6c76f7b2b7">&#9670;&#160;</a></span>CanFitInMpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::CanFitInMpModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>InvalidArgumentError</code> if <code>qp</code> is too large to convert to <code>MPModelProto</code> and <code>OkStatus</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00218">218</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a915b4c9c60210eb50bbb836643aba393" name="a915b4c9c60210eb50bbb836643aba393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915b4c9c60210eb50bbb836643aba393">&#9670;&#160;</a></span>CheckIterateTerminationCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt; operations_research::pdlp::CheckIterateTerminationCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterationStats &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bound_norms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>force_numerical_termination</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if any iterate-based termination criteria (i.e., the criteria not checked by <code>CheckSimpleTerimationCriteria()</code>) are satisfied by the solution state described by <code>stats</code> (see definitions of termination criteria in <a class="el" href="solvers_8proto.html">solvers.proto</a>). <code>bound_norms</code> provides the instance-dependent data required for the relative convergence criteria. Returns a termination reason and a point type if so (if multiple criteria are satisfied, the optimality and infeasibility conditions are checked first). If <code>force_numerical_termination</code> is true, returns <code>TERMINATION_REASON_NUMERICAL_ERROR</code> if no other criteria are satisfied. The return value is empty in any other case. If the output is not empty, the <code>PointType</code> indicates which entry prompted termination. If no entry prompted termination, e.g. <code>TERMINATION_REASON_NUMERICAL_ERROR</code> is returned, then the <code>PointType</code> is set to <code>POINT_TYPE_NONE</code>. NOTE: This function assumes that the solution used to compute the stats satisfies the primal and dual variable bounds; see <a href="https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds">https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds</a>. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00186">186</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a6ef7fb0fc4d208899d240d64bfa7b29c" name="a6ef7fb0fc4d208899d240d64bfa7b29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef7fb0fc4d208899d240d64bfa7b29c">&#9670;&#160;</a></span>CheckNonNegative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::CheckNonNegative </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00034">34</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a02fd964babbc05f32fd088b1005215dc" name="a02fd964babbc05f32fd088b1005215dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd964babbc05f32fd088b1005215dc">&#9670;&#160;</a></span>CheckSimpleTerminationCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1TerminationReasonAndPointType.html">TerminationReasonAndPointType</a> &gt; operations_research::pdlp::CheckSimpleTerminationCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterationStats &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *</td>          <td class="paramname"><span class="paramname"><em>interrupt_solve</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if any of the simple termination criteria are satisfied by <code>stats</code>, and returns a termination reason if so, and nullopt otherwise. The "simple" termination criteria are <code>time_sec_limit</code>, <code>iteration_limit</code>, <code>kkt_matrix_pass_limit</code>, and <code>interrupt_solve</code>. The corresponding fields of <code>stats</code> (<code>cumulative_time_sec</code>, <code>iteration_number</code>, <code>cumulative_kkt_matrix_passes</code>) are the only ones accessed. If returning a termination reason, the <code>PointType</code> will be set to <code>POINT_TYPE_NONE</code>. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00161">161</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a3ed237f4d1a54c4da63c16cc38baf030" name="a3ed237f4d1a54c4da63c16cc38baf030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed237f4d1a54c4da63c16cc38baf030">&#9670;&#160;</a></span>CloneVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::CloneVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of <code>vec</code>. </p>

</div>
</div>
<a id="aaa4a3bad4a7c95a6d68387ba8ae8c104" name="aaa4a3bad4a7c95a6d68387ba8ae8c104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4a3bad4a7c95a6d68387ba8ae8c104">&#9670;&#160;</a></span>CloneVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::CloneVector </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00206">206</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="af2e7e8dab386b40f5984525566c9709f" name="af2e7e8dab386b40f5984525566c9709f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e7e8dab386b40f5984525566c9709f">&#9670;&#160;</a></span>CoefficientWiseProductInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseProductInPlace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>dest = dest.cwiseProduct(scale)</code>. </p>

</div>
</div>
<a id="a920005e41b36a7a0c7f4ad148ad7069d" name="a920005e41b36a7a0c7f4ad148ad7069d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920005e41b36a7a0c7f4ad148ad7069d">&#9670;&#160;</a></span>CoefficientWiseProductInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseProductInPlace </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00212">212</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ae3ba879295782a2f85c4903e0de21cbe" name="ae3ba879295782a2f85c4903e0de21cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ba879295782a2f85c4903e0de21cbe">&#9670;&#160;</a></span>CoefficientWiseQuotientInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseQuotientInPlace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>dest = dest.cwiseQuotient(scale)</code>. </p>

</div>
</div>
<a id="a92c8ca6bf2bb288c322e1d8fbd6ea2bc" name="a92c8ca6bf2bb288c322e1d8fbd6ea2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c8ca6bf2bb288c322e1d8fbd6ea2bc">&#9670;&#160;</a></span>CoefficientWiseQuotientInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::CoefficientWiseQuotientInPlace </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00219">219</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ad3a4f857c920478cbdc673571b69f660" name="ad3a4f857c920478cbdc673571b69f660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a4f857c920478cbdc673571b69f660">&#9670;&#160;</a></span>ComputeConvergenceInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConvergenceInformation operations_research::pdlp::ComputeConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scaled_primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scaled_dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>componentwise_primal_residual_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>componentwise_dual_residual_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType</td>          <td class="paramname"><span class="paramname"><em>candidate_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns convergence statistics about a primal/dual solution pair. It is assumed that <code>scaled_sharded_qp</code> has been transformed from the original qp by <code><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html#afdc10bb749b1e680b718b128f91e26cf">ShardedQuadraticProgram::RescaleQuadraticProgram</a>(col_scaling_vec, / row_scaling_vec)</code>. <code>scaled_primal_solution</code> and <code>scaled_dual_solution</code> are solutions for the scaled problem. The stats are computed with respect to the implicit original problem. <code>componentwise_primal_residual_offset</code> and <code>componentwise_dual_residual_offset</code> are the offsets (i.e., eps_ratio) used for computing the l_inf_componentwise residual norms. </p><dl class="section note"><dt>Note</dt><dd>This function assumes that <code>scaled_primal_solution</code> satisfies the variable bounds and <code>scaled_dual_solution</code> satisfies the dual variable bounds; see <a href="https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds">https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds</a>. </dd></dl>
<p>See <a href="https://developers.google.com/optimization/lp/pdlp_math#rescaling">https://developers.google.com/optimization/lp/pdlp_math#rescaling</a> for notes describing the connection between the scaled and unscaled problem.</p>
<p>This is the dual objective from <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a> minus the last term (involving r). All scaling terms cancel out.</p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00383">383</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="a96fca5ce03ac69c5ca4e0db9d39d62e0" name="a96fca5ce03ac69c5ca4e0db9d39d62e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fca5ce03ac69c5ca4e0db9d39d62e0">&#9670;&#160;</a></span>ComputeDualGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputeDualGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_product</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the value of the dual part of the Lagrangian function defined at <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a>, i.e., -h^*(y) and the gradient of the Lagrangian with respect to the dual variables y, i.e., -Ax - \grad_y h^*(y). Note the asymmetry with <code>ComputePrimalGradient</code>: the term -y^T Ax is not part of the value. Because h^*(y) is piece-wise linear, a subgradient is returned at a point of non-smoothness. <code>primal_product</code> is Ax. The result is undefined and invalid if any duals violate their bounds. </p>

</div>
</div>
<a id="a0b0a68c36dafae816b5d18fdf7f4f2d1" name="a0b0a68c36dafae816b5d18fdf7f4f2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0a68c36dafae816b5d18fdf7f4f2d1">&#9670;&#160;</a></span>ComputeDualGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputeDualGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_product</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00502">502</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a09acbcbe1760b35dd5d927037c7089a7" name="a09acbcbe1760b35dd5d927037c7089a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09acbcbe1760b35dd5d927037c7089a7">&#9670;&#160;</a></span>ComputeInfeasibilityInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InfeasibilityInformation operations_research::pdlp::ComputeInfeasibilityInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scaled_sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scaled_primal_ray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scaled_dual_ray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution_for_residual_tests</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType</td>          <td class="paramname"><span class="paramname"><em>candidate_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns infeasibility statistics about a primal/dual infeasibility certificate estimate. It is assumed that <code>scaled_sharded_qp</code> has been transformed from the original qp by <code><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html#afdc10bb749b1e680b718b128f91e26cf">ShardedQuadraticProgram::RescaleQuadraticProgram</a>(col_scaling_vec, / row_scaling_vec)</code>. <code>scaled_primal_ray</code> and <code>scaled_dual_ray</code> are potential certificates for the scaled problem. The stats are computed with respect to the implicit original problem. <code>primal_solution_for_residual_tests</code> is used instead of <code>scaled_primal_ray</code> when deciding whether or not to treat a primal gradient as a dual residual or not. </p>
<p>Compute primal infeasibility information.</p>
<p>We don't use <code>dual_residuals.l_inf_componentwise_residual</code>, so don't need to set <code>componentwise_residual_offset</code> to a meaningful value.</p>
<p>Compute dual infeasibility information. We don't use <code>primal_residuals.l_inf_componentwise_residual</code>, so don't need to set <code>componentwise_residual_offset</code> to a meaningful value.</p>
<p>The primal ray should have been projected onto the feasibility bounds, so that it has the correct signs.</p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00486">486</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="ac46fc3f284d5b39c05bbbf7f36bbc1c4" name="ac46fc3f284d5b39c05bbbf7f36bbc1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46fc3f284d5b39c05bbbf7f36bbc1c4">&#9670;&#160;</a></span>ComputeLocalizedLagrangianBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">*x <a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> operations_research::pdlp::ComputeLocalizedLagrangianBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a></td>          <td class="paramname"><span class="paramname"><em>primal_dual_norm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>primal_weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>primal_product</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>dual_product</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_diagonal_qp_trust_region_solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>diagonal_qp_trust_region_solver_tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>subject to ||(x - <code>primal_solution</code>, y - <code>dual_solution</code>)||_PD &lt;= <code>radius</code>. <code>use_diagonal_qp_trust_region_solver</code> == true assumes that <code>primal_dual_norm</code> is the Euclidean norm and the objective matrix is diagonal. See <code><a class="el" href="#a5f128477eac14f0eda4b73fdfb3e24d4">SolveDiagonalTrustRegion()</a></code> above for the meaning of <code>diagonal_qp_trust_region_solver_tolerance</code>.</p>
<p>In the context of primal_dual_norm, the primal norm ||.||_P is defined as (|<code>x</code>|_P)^2 = (1 / 2) * <code>primal_weight</code> * |<code>x</code>|_2^2, and the dual norm ||.||_D is defined as (|<code>y</code>|_D)^2 = (1 / 2) * (1 / <code>primal_weight</code>) * |<code>y</code>|_2^2.</p>
<p>Given an optimal solution (x, y) to the above problem, the lower bound is computed as L(<code>primal_solution</code>, <code>dual_solution</code>) + _x L(<code>primal_solution</code>, <code>dual_solution</code>)^T (x - <code>primal_solution</code>) and the upper bound is computed as L(<code>primal_solution</code>, <code>dual_solution</code>) + _y L(<code>primal_solution</code>, <code>dual_solution</code>)^T (y - <code>dual_solution</code>).</p>
<p>The bounds are "localized" because they are guaranteed to bound OPT only if the ||.||_PD ball contains an optimal solution. <code>primal_product</code> and <code>dual_product</code> optionally specify the values of <code>constraint_matrix</code> * <code>primal_solution</code> and <code>constraint_matrix.transpose()</code> * <code>dual_solution</code>, respectively. If set to nullptr, they will be computed. </p>

</div>
</div>
<a id="adb77e7cede2fecf6bccfa93226b49c0b" name="adb77e7cede2fecf6bccfa93226b49c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb77e7cede2fecf6bccfa93226b49c0b">&#9670;&#160;</a></span>ComputeLocalizedLagrangianBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LocalizedLagrangianBounds.html">LocalizedLagrangianBounds</a> operations_research::pdlp::ComputeLocalizedLagrangianBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8b49502c323652c8d4e9a3fd3dd5cda7">PrimalDualNorm</a></td>          <td class="paramname"><span class="paramname"><em>primal_dual_norm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>primal_weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd *</td>          <td class="paramname"><span class="paramname"><em>primal_product</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd *</td>          <td class="paramname"><span class="paramname"><em>dual_product</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>use_diagonal_qp_trust_region_solver</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>diagonal_qp_trust_region_solver_tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00978">978</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="abe180ee4e003e6a819c90205bf38b60f" name="abe180ee4e003e6a819c90205bf38b60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe180ee4e003e6a819c90205bf38b60f">&#9670;&#160;</a></span>ComputePrimalGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputePrimalGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_product</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the value of the primal part of the Lagrangian function defined at <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a>, i.e., c^T x + (1/2) x^T Qx - y^T Ax and its gradient with respect to the primal variables x, i.e., c + Qx - A^T y. <code>dual_product</code> is A^T y. Note: The objective constant is omitted. The result is undefined and invalid if any primal bounds are violated. </p>

</div>
</div>
<a id="a259d3f73717a2ababa9df2dd43914656" name="a259d3f73717a2ababa9df2dd43914656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259d3f73717a2ababa9df2dd43914656">&#9670;&#160;</a></span>ComputePrimalGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1LagrangianPart.html">LagrangianPart</a> operations_research::pdlp::ComputePrimalGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_product</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>using <code>auto</code> instead of <code>VectorXd</code> for the type of <code>objective_product</code> causes eigen to defer the matrix product until it is used (twice).</dd></dl>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00446">446</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="afabaaef8b32ae92f1331599732ac99d1" name="afabaaef8b32ae92f1331599732ac99d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabaaef8b32ae92f1331599732ac99d1">&#9670;&#160;</a></span>ComputeRelativeResiduals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1RelativeConvergenceInformation.html">RelativeConvergenceInformation</a> operations_research::pdlp::ComputeRelativeResiduals </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::DetailedOptimalityCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>optimality_criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConvergenceInformation &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bound_norms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00239">239</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a67cba1e0f05d2dd4e3efb2587802f022" name="a67cba1e0f05d2dd4e3efb2587802f022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cba1e0f05d2dd4e3efb2587802f022">&#9670;&#160;</a></span>ComputeScaledConvergenceInformation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConvergenceInformation operations_research::pdlp::ComputeScaledConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>componentwise_primal_residual_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>componentwise_dual_residual_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType</td>          <td class="paramname"><span class="paramname"><em>candidate_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns convergence statistics about a primal/dual solution pair. The stats are with respect to <code>sharded_qp</code> (which is typically scaled). This function is equivalent to <code>ComputeConvergenceInformation</code> given scaling vectors uniformly equal to one. </p>

</div>
</div>
<a id="a91e1750531d2a33362a8b9b9158f5192" name="a91e1750531d2a33362a8b9b9158f5192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e1750531d2a33362a8b9b9158f5192">&#9670;&#160;</a></span>ComputeScaledConvergenceInformation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConvergenceInformation operations_research::pdlp::ComputeScaledConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>componentwise_primal_residual_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>componentwise_dual_residual_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType</td>          <td class="paramname"><span class="paramname"><em>candidate_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00566">566</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="a0f96ba4fae041845072b4e960bb42d13" name="a0f96ba4fae041845072b4e960bb42d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f96ba4fae041845072b4e960bb42d13">&#9670;&#160;</a></span>ComputeStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuadraticProgramStats operations_research::pdlp::ComputeStats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>QuadraticProgramStats</code> for a <code><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a></code>. </p>
<p>Caution: if the constraint matrix is empty, elementwise operations (like <code>.coeffs().maxCoeff()</code> or <code>.minCoeff()</code>) will fail.</p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00270">270</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="adacc8fc59edce54401bcdee2cf277c4e" name="adacc8fc59edce54401bcdee2cf277c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacc8fc59edce54401bcdee2cf277c4e">&#9670;&#160;</a></span>CorrelationClusteringLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::CorrelationClusteringLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>| / </p>
<p>Returns a correlation clustering LP. This is the LP for minimizing disagreements for correlation clustering for the 4-vertex graph In integer solutions x_ij is 1 if i and j are in the same cluster and 0 otherwise. The 6 variables are in the order x_12, x_13, x_14, x_23, x_24, x_34. For any distinct i,j,k there's a triangle inequality (1-x_ik) &lt;= (1-x_ij) + (1-x_jk) i.e. -x_ij - x_jk + x_ik &gt;= -1. For brevity we only include 3 out of the 12 possible triangle inequalities: two needed in the optimal solution and 1 other.</p>
<p>Optimal solutions: Primal: [1, 1, 0, 1, 0, 0] Dual: Multiple. Value: 1. </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00089">89</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a23678bb7c561c0ebbc4c3e2a941fbd9d" name="a23678bb7c561c0ebbc4c3e2a941fbd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23678bb7c561c0ebbc4c3e2a941fbd9d">&#9670;&#160;</a></span>CorrelationClusteringStarLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::CorrelationClusteringStarLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns another 4-vertex correlation clustering LP.</p>
<p>The variables are x_12, x_13, x_14, x_23, x_24, and x_34. This time the graph is a star centered at vertex 1. Only the three triangle inequalities that are needed are included. Optimal solutions: Primal: [0.5, 0.5, 0.5, 0.0, 0.0, 0.0] Dual: [0.5, 0.5, 0.5] Value: 1.5 </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00110">110</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a09826daec0fbcdf6594b1ada846dbb3a" name="a09826daec0fbcdf6594b1ada846dbb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09826daec0fbcdf6594b1ada846dbb3a">&#9670;&#160;</a></span>Distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>(vector1 - vector2).norm()</code>. </p>

</div>
</div>
<a id="a3e28f45b9c1ccdec8d926b4034d3679b" name="a3e28f45b9c1ccdec8d926b4034d3679b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e28f45b9c1ccdec8d926b4034d3679b">&#9670;&#160;</a></span>Distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Distance </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00260">260</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="adfa51fc5a2896d98a940cc367c5bbfe5" name="adfa51fc5a2896d98a940cc367c5bbfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa51fc5a2896d98a940cc367c5bbfe5">&#9670;&#160;</a></span>Dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Dot </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>v1.dot(v2)</code>. </p>

</div>
</div>
<a id="a11831586b99d28a708bc103bce1a945e" name="a11831586b99d28a708bc103bce1a945e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11831586b99d28a708bc103bce1a945e">&#9670;&#160;</a></span>Dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Dot </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00226">226</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a8d94aed55433c303286276bc57a8d77e" name="a8d94aed55433c303286276bc57a8d77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d94aed55433c303286276bc57a8d77e">&#9670;&#160;</a></span>DualSubgradientCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::DualSubgradientCoefficient </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>constraint_lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>constraint_upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>primal_product</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a subderivative of the concave dual penalty function that appears in the Lagrangian: -p(<code>dual</code>; -<code>constraint_upper_bound</code>, -<code>constraint_lower_bound</code>) = { <code>constraint_upper_bound * dual</code> when <code>dual &lt; 0</code>, 0 when <code>dual == 0</code>, and <code>constraint_lower_bound * dual</code> when <code>dual &gt; 0</code>} (as defined at <a href="https://developers.google.com/optimization/lp/pdlp_math">https://developers.google.com/optimization/lp/pdlp_math</a>). The subderivative is not necessarily unique when dual == 0. In this case, if only one of the bounds is finite, we return that one. If both are finite, we return <code>primal_product</code> projected onto the bounds, which causes the dual Lagrangian gradient to be zero when the constraint is not violated. If both are infinite, we return zero. The value returned is valid only when the function is finite-valued. </p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00476">476</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a3a5acb887ad53db5411c34545980f993" name="a3a5acb887ad53db5411c34545980f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5acb887ad53db5411c34545980f993">&#9670;&#160;</a></span>EffectiveOptimalityCriteria() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TerminationCriteria::DetailedOptimalityCriteria operations_research::pdlp::EffectiveOptimalityCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>termination_criteria</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the effective optimality criteria for a <code>TerminationCriteria</code>. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00126">126</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a7254f8c83c3395526dcc958f19e3c14a" name="a7254f8c83c3395526dcc958f19e3c14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7254f8c83c3395526dcc958f19e3c14a">&#9670;&#160;</a></span>EffectiveOptimalityCriteria() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TerminationCriteria::DetailedOptimalityCriteria operations_research::pdlp::EffectiveOptimalityCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::SimpleOptimalityCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>simple_criteria</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous overload but takes a <code>SimpleOptimalityCriteria</code>. Useful in unit tests where no <code>TerminationCriteria</code> is naturally available. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00143">143</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a5c7474762d0771b51e98686306ec7b4f" name="a5c7474762d0771b51e98686306ec7b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7474762d0771b51e98686306ec7b4f">&#9670;&#160;</a></span>EpsilonRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::EpsilonRatio </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>epsilon_absolute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>epsilon_relative</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>epsilon_absolute / epsilon_relative</code>, returning 1.0 if <code>epsilon_absolute</code> and <code>epsilon_relative</code> are equal (even if they are both 0.0 or infinity, which would normally yield NAN). </p>
<p>Handling <code>epsilon_absolute == epsilon_relative</code> explicitly avoids NANs when both values are zero or infinite.</p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00230">230</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="a4395f27dfe822c4efc56d16900841c22" name="a4395f27dfe822c4efc56d16900841c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4395f27dfe822c4efc56d16900841c22">&#9670;&#160;</a></span>EstimateMaximumSingularValueOfConstraintMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a> operations_research::pdlp::EstimateMaximumSingularValueOfConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>desired_relative_error</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>failure_probability</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;</td>          <td class="paramname"><span class="paramname"><em>mt_generator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the maximum singular value of A by applying the method of power iteration to A^T A. If <code>primal_solution</code> or <code>dual_solution</code> is provided, restricts to the "active" part of A, that is, the columns (rows) for variables that are not at their bounds in the solution. The estimate will have <code>desired_relative_error</code> with probability at least 1 - <code>failure_probability</code>. The number of iterations will be approximately log(<code>primal_size</code> / <code>failure_probability</code>^2)/(2 * <code>desired_relative_error</code>). Uses a mersenne-twister portable random number generator to generate the starting point for the power method, in order to have deterministic results. </p>

</div>
</div>
<a id="a6985b8c7ce87b3858b50efa4a923a0eb" name="a6985b8c7ce87b3858b50efa4a923a0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6985b8c7ce87b3858b50efa4a923a0eb">&#9670;&#160;</a></span>EstimateMaximumSingularValueOfConstraintMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SingularValueAndIterations.html">SingularValueAndIterations</a> operations_research::pdlp::EstimateMaximumSingularValueOfConstraintMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>desired_relative_error</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>failure_probability</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;</td>          <td class="paramname"><span class="paramname"><em>mt_generator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00676">676</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a7bd16384c5572b001a57e9987bf5b0e9" name="a7bd16384c5572b001a57e9987bf5b0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd16384c5572b001a57e9987bf5b0e9">&#9670;&#160;</a></span>FindScalingFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::FindScalingFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>solve_tol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds an approximately optimal scaling factor for the solution of the trust region subproblem, which can be passed on to <code>ProjectedCoordinate()</code> to find an approximately optimal solution to the trust region subproblem. The value returned is guaranteed to be within <code>solve_tol</code> * max(1, s*) of the optimal scaling s*. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001095">Todo</a></b></dt><dd>(user): figure out what accuracy is useful to callers and redo the stopping criterion accordingly. </dd></dl>
<p>Determine a search interval using monotonicity of the squared norm of the candidate solution with respect to the scaling factor.</p>
<p>Invariant: <code>scaling_factor_upper_bound &gt;= scaling_factor_lower_bound</code>.</p>
<p>Norm is monotonically non-increasing as a function of scaling_factor.</p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00663">663</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a22565ae8507a53fdd98f539757c11c2d" name="a22565ae8507a53fdd98f539757c11c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22565ae8507a53fdd98f539757c11c2d">&#9670;&#160;</a></span>GetConvergenceInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; ConvergenceInformation &gt; operations_research::pdlp::GetConvergenceInformation </td>
          <td>(</td>
          <td class="paramtype">const IterationStats &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType</td>          <td class="paramname"><span class="paramname"><em>candidate_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns the <code>ConvergenceInformation</code> with the specified <code>candidate_type</code>, or std::nullopt if no such candidate exists. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00595">595</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="a46d133b011f79db6b38b39d967ba1106" name="a46d133b011f79db6b38b39d967ba1106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d133b011f79db6b38b39d967ba1106">&#9670;&#160;</a></span>GetInfeasibilityInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; InfeasibilityInformation &gt; operations_research::pdlp::GetInfeasibilityInformation </td>
          <td>(</td>
          <td class="paramtype">const IterationStats &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType</td>          <td class="paramname"><span class="paramname"><em>candidate_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns the <code>InfeasibilityInformation</code> with the specified <code>candidate_type</code>, or std::nullopt if no such candidate exists. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00605">605</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="a8aaf9a260a4e9bd5ed462840b5ee9cb8" name="a8aaf9a260a4e9bd5ed462840b5ee9cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaf9a260a4e9bd5ed462840b5ee9cb8">&#9670;&#160;</a></span>GetPointMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; PointMetadata &gt; operations_research::pdlp::GetPointMetadata </td>
          <td>(</td>
          <td class="paramtype">const IterationStats &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointType</td>          <td class="paramname"><span class="paramname"><em>point_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns the <code>PointMetadata</code> with the specified <code>point_type</code>, or std::nullopt if no such point exists. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00616">616</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="acc88d1ca95af991600037eaf027f081b" name="acc88d1ca95af991600037eaf027f081b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc88d1ca95af991600037eaf027f081b">&#9670;&#160;</a></span>HasValidBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::HasValidBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the lower and upper bounds of the problem are consistent, i.e. for each variable and constraint bound we have lower_bound &lt;= upper_bound, lower_bound &lt; inf, and upper_bound &gt; -inf. If the input is consistent the method returns true, otherwise it returns false. </p>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00701">701</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a850865b3deabb2a623e130691df99f15" name="a850865b3deabb2a623e130691df99f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850865b3deabb2a623e130691df99f15">&#9670;&#160;</a></span>IsLinearProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::IsLinearProgram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="quadratic__program_8h_source.html#l00157">157</a> of file <a class="el" href="quadratic__program_8h_source.html">quadratic_program.h</a>.</p>

</div>
</div>
<a id="a45e75bc358dc64d1dc080cb311acd449" name="a45e75bc358dc64d1dc080cb311acd449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e75bc358dc64d1dc080cb311acd449">&#9670;&#160;</a></span>L1Norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::L1Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>vector.lpNorm&lt;1&gt;()</code>, a.k.a. L_1 norm. </p>

</div>
</div>
<a id="aa577696ad9121b3f002cd37de6f86989" name="aa577696ad9121b3f002cd37de6f86989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa577696ad9121b3f002cd37de6f86989">&#9670;&#160;</a></span>L1Norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::L1Norm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00239">239</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="af41379e6fa8d7e6e6e8151c256906970" name="af41379e6fa8d7e6e6e8151c256906970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41379e6fa8d7e6e6e8151c256906970">&#9670;&#160;</a></span>L2NormRescaling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::L2NormRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>L2NormRescaling</code> divides <code>row_scaling_vec</code> (<code>col_scaling_vec</code>) by the sqrt of the row (col) L2 norm of the current (scaled) constraint matrix. Unlike <code>LInfRescaling</code>, this function does only one iteration because the scaling procedure does not converge in general. This is not Ruiz rescaling for the L2 norm. </p>

</div>
</div>
<a id="a9dee2894b8028a57b7f7d2306b402e44" name="a9dee2894b8028a57b7f7d2306b402e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dee2894b8028a57b7f7d2306b402e44">&#9670;&#160;</a></span>L2NormRescaling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::L2NormRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00416">416</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="ab2cbc527d8c2c204dbd36be85cc4569d" name="ab2cbc527d8c2c204dbd36be85cc4569d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cbc527d8c2c204dbd36be85cc4569d">&#9670;&#160;</a></span>LInfNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::LInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>vector.lpNorm&lt;Eigen::Infinity&gt;()</code>, a.k.a. LInf norm. </p>

</div>
</div>
<a id="a33a42241df5501b0165ee77c3de54d7f" name="a33a42241df5501b0165ee77c3de54d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a42241df5501b0165ee77c3de54d7f">&#9670;&#160;</a></span>LInfNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::LInfNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00231">231</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a54ded6625965f8ddd342161a55263cce" name="a54ded6625965f8ddd342161a55263cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ded6625965f8ddd342161a55263cce">&#9670;&#160;</a></span>LInfRuizRescaling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::LInfRuizRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>num_iterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00409">409</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a897df53498faee509db98ef2681556ce" name="a897df53498faee509db98ef2681556ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897df53498faee509db98ef2681556ce">&#9670;&#160;</a></span>LInfRuizRescaling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::LInfRuizRescaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_iterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>LInfRuizRescaling</code> and <code>L2NormRescaling</code> rescale the (scaled) constraint matrix of the LP by updating the scaling vectors in-place. More specifically, the (scaled) constraint matrix always has the format: <code>diag(row_scaling_vec) / * sharded_qp.Qp().constraint_matrix * diag(col_scaling_vec)</code>, and <code>row_scaling_vec</code> and <code>col_scaling_vec</code> are updated in-place. On input, <code>row_scaling_vec</code> and <code>col_scaling_vec</code> provide the initial scaling. With each iteration of <code>LInfRuizRescaling</code> scaling, <code>row_scaling_vec</code> (<code>col_scaling_vec</code>) is divided by the sqrt of the row (col) LInf norm of the current (scaled) constraint matrix. The (scaled) constraint matrix approaches having all row and column LInf norms equal to 1 as the number of iterations goes to infinity. This convergence is fast (linear). More details of Ruiz rescaling algorithm can be found at: <a href="http://www.numerical.rl.ac.uk/reports/drRAL2001034.pdf">http://www.numerical.rl.ac.uk/reports/drRAL2001034.pdf</a>. </p>

</div>
</div>
<a id="a9961ddc0f992257e088066b1d9f59b92" name="a9961ddc0f992257e088066b1d9f59b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9961ddc0f992257e088066b1d9f59b92">&#9670;&#160;</a></span>LpWithoutConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::LpWithoutConstraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00253">253</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a0f7cd58c59cd30e221879d2c9731ec7e" name="a0f7cd58c59cd30e221879d2c9731ec7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7cd58c59cd30e221879d2c9731ec7e">&#9670;&#160;</a></span>MakeScheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1pdlp_1_1Scheduler.html">Scheduler</a> &gt; operations_research::pdlp::MakeScheduler </td>
          <td>(</td>
          <td class="paramtype">SchedulerType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience factory function. </p>
<p>Makes a scheduler of a given type. </p>

<p class="definition">Definition at line <a class="el" href="scheduler_8cc_source.html#l00023">23</a> of file <a class="el" href="scheduler_8cc_source.html">scheduler.cc</a>.</p>

</div>
</div>
<a id="a4f3cc73755c80cd79c2fb1c697e1310a" name="a4f3cc73755c80cd79c2fb1c697e1310a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3cc73755c80cd79c2fb1c697e1310a">&#9670;&#160;</a></span>Norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>vector.norm()</code>. </p>

</div>
</div>
<a id="ade56a0bd875b06000c45e1730398e5a8" name="ade56a0bd875b06000c45e1730398e5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade56a0bd875b06000c45e1730398e5a8">&#9670;&#160;</a></span>Norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::Norm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00249">249</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a3c71f00da2c898c481414c3e92f12f0d" name="a3c71f00da2c898c481414c3e92f12f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c71f00da2c898c481414c3e92f12f0d">&#9670;&#160;</a></span>NormOfDeltaProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::NormOfDeltaProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>scaling_factor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the norm of the projection of the difference vector, x - center_point, to the corresponding box constraints. We are using the standard Euclidean norm (instead of the weighted norm) because the solver implicitly reformulates the problem to one with a Euclidean ball constraint first. </p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00636">636</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="ad05b31a796e1009f7087884df50815fc" name="ad05b31a796e1009f7087884df50815fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05b31a796e1009f7087884df50815fc">&#9670;&#160;</a></span>ObjectiveGapMet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::ObjectiveGapMet </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::DetailedOptimalityCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>optimality_criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConvergenceInformation &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00026">26</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="acbd7d091bd562c2141e811478aaaa991" name="acbd7d091bd562c2141e811478aaaa991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd7d091bd562c2141e811478aaaa991">&#9670;&#160;</a></span>OnesVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::OnesVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>VectorXd::Ones(sharder.NumElements())</code>. </p>

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00186">186</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="aa473ed1679cf7844c7a65548cabe8599" name="aa473ed1679cf7844c7a65548cabe8599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa473ed1679cf7844c7a65548cabe8599">&#9670;&#160;</a></span>OptimalityCriteriaMet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::pdlp::OptimalityCriteriaMet </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria::DetailedOptimalityCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>optimality_criteria</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConvergenceInformation &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OptimalityNorm</td>          <td class="paramname"><span class="paramname"><em>optimality_norm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgramBoundNorms.html">QuadraticProgramBoundNorms</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bound_norms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the optimality criteria are met. </p>

<p class="definition">Definition at line <a class="el" href="termination_8cc_source.html#l00043">43</a> of file <a class="el" href="termination_8cc_source.html">termination.cc</a>.</p>

</div>
</div>
<a id="abf423134517a37a89f497afc72942735" name="abf423134517a37a89f497afc72942735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf423134517a37a89f497afc72942735">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></td>          <td class="paramname"><span class="paramname"><em>qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *</td>          <td class="paramname"><span class="paramname"><em>interrupt_solve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>message_callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterationStatsCallback</td>          <td class="paramname"><span class="paramname"><em>iteration_stats_callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html#l02933">2933</a> of file <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html">primal_dual_hybrid_gradient.cc</a>.</p>

</div>
</div>
<a id="a4976f41a18336d1f56e40e10927df23d" name="a4976f41a18336d1f56e40e10927df23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4976f41a18336d1f56e40e10927df23d">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></td>          <td class="paramname"><span class="paramname"><em>qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *</td>          <td class="paramname"><span class="paramname"><em>interrupt_solve</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>message_callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>iteration_stats_callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the given QP using PDLP (Primal-Dual hybrid gradient enhanced for LP).</p>
<p>All operations that are repeated each iteration are executed in parallel using <code>params.num_threads()</code> threads.</p>
<p>The algorithm generally follows the description in <a href="https://arxiv.org/pdf/2106.04756.pdf">https://arxiv.org/pdf/2106.04756.pdf</a>, with further enhancements for QP. Notation here and in the implementation follows Chambolle and Pock, "On the
ergodic convergence rates of a first-order primal-dual algorithm" (<a href="http://www.optimization-online.org/DB_FILE/2014/09/4532.pdf">http://www.optimization-online.org/DB_FILE/2014/09/4532.pdf</a>). That paper doesn't explicitly use the terminology "primal-dual hybrid
gradient" but their Theorem 1 is analyzing PDHG. See <a href="https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation">https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation</a> for the saddle-point formulation of the QP we use that is compatible with Chambolle and Pock.</p>
<p>We use 0.5 ||.||^2 for both the primal and dual distance functions.</p>
<p>We parameterize the primal and dual step sizes (tau and sigma in Chambolle and Pock) as: primal_stepsize = step_size / primal_weight dual_stepsize = step_size * primal_weight where step_size and primal_weight are parameters. <code>params.linesearch_rule</code> determines the update rule for step_size. <code>params.initial_primal_weight</code> specifies how primal_weight is initialized and <code>params.primal_weight_update_smoothing</code> controls how primal_weight is updated.</p>
<p>If <code>interrupt_solve</code> is not nullptr, then the solver will periodically check if <code>interrupt_solve-&gt;load()</code> is true, in which case the solve will terminate with <code>TERMINATION_REASON_INTERRUPTED_BY_USER</code>.</p>
<p>If <code>message_callback</code> is not nullptr, solver logging will be passed to <code>message_callback</code>. Otherwise solver logging will be written to stdout. In either case, the amount of logging is controlled by <code>verbosity_level</code>. In particular, if <code>verbosity_level == 0</code>, there will be no logging in either case.</p>
<p>If <code>iteration_stats_callback</code> is not nullptr, then at each termination step (when iteration stats are logged), <code>iteration_stats_callback</code> will also be called with those iteration stats.</p>
<p>Callers MUST check <code>solve_log.termination_reason</code> before using the vectors in the <code><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a></code>. See the comment on <code><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a></code> for interpreting the termination reason.</p>
<p>All objective values reported by the algorithm are transformed by using <code><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html#a03c3931b50f720a92130b299d282ed2b">QuadraticProgram::ApplyObjectiveScalingAndOffset</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd><code>qp</code> is intentionally passed by value, because <code>PrimalDualHybridGradient</code> modifies its copy. </dd></dl>

</div>
</div>
<a id="a71c304e3179e094cb89d838e86684c1e" name="a71c304e3179e094cb89d838e86684c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c304e3179e094cb89d838e86684c1e">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></td>          <td class="paramname"><span class="paramname"><em>qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>initial_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *</td>          <td class="paramname"><span class="paramname"><em>interrupt_solve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>message_callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterationStatsCallback</td>          <td class="paramname"><span class="paramname"><em>iteration_stats_callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html#l02943">2943</a> of file <a class="el" href="primal__dual__hybrid__gradient_8cc_source.html">primal_dual_hybrid_gradient.cc</a>.</p>

</div>
</div>
<a id="af8af91fb08550bb1fee05251d70b702d" name="af8af91fb08550bb1fee05251d70b702d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8af91fb08550bb1fee05251d70b702d">&#9670;&#160;</a></span>PrimalDualHybridGradient() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1SolverResult.html">SolverResult</a> operations_research::pdlp::PrimalDualHybridGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></td>          <td class="paramname"><span class="paramname"><em>qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1PrimalAndDualSolution.html">PrimalAndDualSolution</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>initial_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; bool &gt; *</td>          <td class="paramname"><span class="paramname"><em>interrupt_solve</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::string &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>message_callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structoperations__research_1_1pdlp_1_1IterationCallbackInfo.html">IterationCallbackInfo</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>iteration_stats_callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like above but optionally starts with the given <code>initial_solution</code>. If no <code>initial_solution</code> is given the zero vector is used. In either case <code>initial_solution</code> is projected onto the primal and dual variable bounds before use. Convergence should be faster if <code>initial_solution</code> is close to an optimal solution. NOTE: <code>initial_solution</code> is intentionally passed by value. </p>

</div>
</div>
<a id="accb6df46237b5d870b93c6566cadd722" name="accb6df46237b5d870b93c6566cadd722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb6df46237b5d870b93c6566cadd722">&#9670;&#160;</a></span>ProjectedValueOfScaledDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ProjectedValueOfScaledDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>scaling_factor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes a single coordinate projection of the scaled difference, sqrt(NormWeight(i)) * (x[i] - CenterPoint(i)), to the corresponding box constraints. As a function of scaling_factor, the difference is equal to (Q[i, i] / NormWeight(i)) + <code>scaling_factor</code>)^{-1} * (-c[i] / sqrt(NormWeight(i))), where Q, c are the objective matrix and vector, respectively. </p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00616">616</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a4b46c4812be8af75325d63ed3ced80f0" name="a4b46c4812be8af75325d63ed3ced80f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b46c4812be8af75325d63ed3ced80f0">&#9670;&#160;</a></span>ProjectToDualVariableBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToDualVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects <code>dual</code> onto the dual variable bounds; see <a href="https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds">https://developers.google.com/optimization/lp/pdlp_math#dual_variable_bounds</a>. </p>

</div>
</div>
<a id="a898c0c776a5736cf1931036d0d370724" name="a898c0c776a5736cf1931036d0d370724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898c0c776a5736cf1931036d0d370724">&#9670;&#160;</a></span>ProjectToDualVariableBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToDualVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001092">Todo</a></b></dt><dd>(user): Investigate whether it is more efficient to use .cwiseMax() + .cwiseMin() with unaryExpr(s) that map upper_bound_shard and lower_bound_shard to appropriate values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00749">749</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a7865a873a402347ac2065a887bacb299" name="a7865a873a402347ac2065a887bacb299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7865a873a402347ac2065a887bacb299">&#9670;&#160;</a></span>ProjectToPrimalVariableBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToPrimalVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_feasibility_bounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects <code>primal</code> onto the variable bounds constraints. If <code>use_feasibility_bounds == true</code>, all finite variable bounds are replaced by zero. </p>

</div>
</div>
<a id="a6b5ae66853ff4985ca2911ba4d453fdc" name="a6b5ae66853ff4985ca2911ba4d453fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5ae66853ff4985ca2911ba4d453fdc">&#9670;&#160;</a></span>ProjectToPrimalVariableBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::ProjectToPrimalVariableBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>use_feasibility_bounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00725">725</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a70f90c55cdcb499205898fd7f90da6f3" name="a70f90c55cdcb499205898fd7f90da6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f90c55cdcb499205898fd7f90da6f3">&#9670;&#160;</a></span>QpFromMpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &gt; operations_research::pdlp::QpFromMpModelProto </td>
          <td>(</td>
          <td class="paramtype">const MPModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>relax_integer_variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>include_names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an <code>MPModelProto</code> into a <code><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></code>. Returns an error if general constraints are present. If <code>relax_integer_variables</code> is true integer variables are relaxed to continuous; otherwise integer variables are an error. If <code>include_names</code> is true (the default is false), the problem, constraint, and variable names are included in the <code><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></code>; otherwise they are left empty. Maximization problems are converted to minimization by negating the objective and setting <code>objective_scaling_factor</code> to -1, which preserves the reported objective values. </p>
<p>To reduce peak RAM usage we construct the constraint matrix in-place. According to the documentation of <code>SparseMatrix::insert()</code> it's efficient to construct a matrix with insert()s as long as reserve() is called first and the non-zeros are inserted in increasing order of inner index. The non-zeros in each input constraint may not be sorted so this is only efficient with column major format.</p>
<p>We use triplets-based initialization for the objective matrix because the objective non-zeros may be in arbitrary order in the input.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></code> has an implicit "1/2" in front of the quadratic term.</dd></dl>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00099">99</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a03fc89d57cdfcdd70d122ffc32fb015d" name="a03fc89d57cdfcdd70d122ffc32fb015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fc89d57cdfcdd70d122ffc32fb015d">&#9670;&#160;</a></span>QpToMpModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; MPModelProto &gt; operations_research::pdlp::QpToMpModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <code><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></code> into an <code>MPModelProto</code>. To preserve objective values in the conversion, <code>objective_vector</code>, <code>objective_matrix</code>, and <code>objective_offset</code> are scaled by <code>objective_scaling_factor</code>, and if <code>objective_scaling_factor</code> is negative, then the proto is a maximization problem (otherwise it's a minimization problem). Returns <code>InvalidArgumentError</code> if <code>objective_scaling_factor</code> is zero or if <code><a class="el" href="#ad98a981710e58e6eead1ca6c76f7b2b7">CanFitInMpModelProto()</a></code> fails. </p>
<p>To avoid reallocs during the inserts, we could count the nonzeros and <code>reserve()</code> before filling.</p>
<p>Some OR tools decide the objective is quadratic based on <code>has_quadratic_objective()</code> rather than on <code>quadratic_objective_size() == 0</code>, so don't create the quadratic objective for linear programs.</p>
<p>Undo the implicit (1/2) term in <code><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a></code>'s objective.</p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00242">242</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a40bff54df141c92a98fb14a56a06417c" name="a40bff54df141c92a98fb14a56a06417c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bff54df141c92a98fb14a56a06417c">&#9670;&#160;</a></span>ReadMPModelProtoFileOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::ReadMPModelProtoFileOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mpmodel_proto_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>include_names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The input may be <code>MPModelProto</code> in text format, binary format, or JSON, possibly gzipped. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00069">69</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="af49e60cdec3f8a1e616da88dc4761c9a" name="af49e60cdec3f8a1e616da88dc4761c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49e60cdec3f8a1e616da88dc4761c9a">&#9670;&#160;</a></span>ReadMpsLinearProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &gt; operations_research::pdlp::ReadMpsLinearProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>lp_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>include_names</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect MPS format, sizes and names.</p>
<p>Populate the QP with pre-allocated sizes.</p>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00364">364</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="aae83b2a0a223071e9c8a20cc2d8c0664" name="aae83b2a0a223071e9c8a20cc2d8c0664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae83b2a0a223071e9c8a20cc2d8c0664">&#9670;&#160;</a></span>ReadMpsLinearProgramOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::ReadMpsLinearProgramOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>lp_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>include_names</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00399">399</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="a80b7dc41ed788020cbaf942674f623d9" name="a80b7dc41ed788020cbaf942674f623d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b7dc41ed788020cbaf942674f623d9">&#9670;&#160;</a></span>ReadQuadraticProgramOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::ReadQuadraticProgramOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>include_names</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001090">Todo</a></b></dt><dd>(user): Update internal helper functions to use references instead of pointers. </dd></dl>
<p>Reads a quadratic program, determining the type based on the filename's suffix: *.mps, *.mps.gz, *.mps.bz2 -&gt; <code>ReadMpsLinearProgramOrDie</code> *.pb, *.textproto, *.json, *.json.gz -&gt; <code>ReadMPModelProtoFileOrDie</code> otherwise CHECK-fails. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00052">52</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="a6e56bcb1dbb063aac138bfaaeaca695a" name="a6e56bcb1dbb063aac138bfaaeaca695a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e56bcb1dbb063aac138bfaaeaca695a">&#9670;&#160;</a></span>ReducedCosts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ReducedCosts </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scaled_sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_zero_primal_objective</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the reduced costs vector, objective_matrix * <code>primal_solution</code> + objective_vector - constraint_matrix * <code>dual_solution</code>, when <code>use_zero_primal_objective</code> is false, and -constraint_matrix * <code>dual_solution</code> when <code>use_zero_primal_objective</code> is true. See <a href="https://developers.google.com/optimization/lp/pdlp_math#reduced_costs_dual_residuals_and_the_corrected_dual_objective">https://developers.google.com/optimization/lp/pdlp_math#reduced_costs_dual_residuals_and_the_corrected_dual_objective</a>. </p>

</div>
</div>
<a id="a3fad6392722c357cd629f5dc9cbb94a2" name="a3fad6392722c357cd629f5dc9cbb94a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fad6392722c357cd629f5dc9cbb94a2">&#9670;&#160;</a></span>ReducedCosts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::ReducedCosts </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_zero_primal_objective</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00579">579</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="ac371aa1f67b4d895ed970bf479e6ec5f" name="ac371aa1f67b4d895ed970bf479e6ec5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac371aa1f67b4d895ed970bf479e6ec5f">&#9670;&#160;</a></span>ScaledColL2Norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ScaledColL2Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the L2 norm of each column of a scaled <code>matrix</code>. </p>

</div>
</div>
<a id="aa3c5dd95681fe94691be1407d6bb62aa" name="aa3c5dd95681fe94691be1407d6bb62aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c5dd95681fe94691be1407d6bb62aa">&#9670;&#160;</a></span>ScaledColL2Norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::ScaledColL2Norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00309">309</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ac825edcd2a72e7284c0b1c1ffce6dea0" name="ac825edcd2a72e7284c0b1c1ffce6dea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac825edcd2a72e7284c0b1c1ffce6dea0">&#9670;&#160;</a></span>ScaledColLInfNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ScaledColLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the LInf norm of each column of a scaled <code>matrix</code>. </p>
<p>The functions below compute norms of the columns of a scaled matrix. The (i,j) entry of the scaled matrix equals <code>matrix[i,j] * row_scaling_vec[i] / * col_scaling_vec[j]</code>. To ensure good parallelization <code>matrix</code> should have (roughly) the same location of non-zeros as the <code>matrix</code> used to construct <code>sharder</code>. The size of <code>sharder</code> must match the number of columns in <code>matrix</code>. </p>

</div>
</div>
<a id="a69a3cf251337531692721a574033a9df" name="a69a3cf251337531692721a574033a9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a3cf251337531692721a574033a9df">&#9670;&#160;</a></span>ScaledColLInfNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::ScaledColLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>row_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>col_scaling_vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00287">287</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a42e24a12cfaed2024d52b70297b5a96b" name="a42e24a12cfaed2024d52b70297b5a96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e24a12cfaed2024d52b70297b5a96b">&#9670;&#160;</a></span>ScaledLInfNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>ScaledL1Norm</code> is omitted because it's not needed (yet). </p>
<p>LInf norm of a rescaled vector, i.e., <code>vector.cwiseProduct(scale).lpNorm&lt;Eigen::Infinity&gt;()</code>. </p>

</div>
</div>
<a id="a55b8c43a5adfafddb030074c75aeef70" name="a55b8c43a5adfafddb030074c75aeef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b8c43a5adfafddb030074c75aeef70">&#9670;&#160;</a></span>ScaledLInfNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledLInfNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00265">265</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a250eacb9ce6df8be7e5837a2279e7cca" name="a250eacb9ce6df8be7e5837a2279e7cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250eacb9ce6df8be7e5837a2279e7cca">&#9670;&#160;</a></span>ScaledNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L2 norm of a rescaled vector, i.e., <code>vector.cwiseProduct(scale).norm()</code>. </p>

</div>
</div>
<a id="a0b812156619599417e29521a41b7a734" name="a0b812156619599417e29521a41b7a734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b812156619599417e29521a41b7a734">&#9670;&#160;</a></span>ScaledNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00282">282</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="acff65f956f203f1538f4bbf0cd44fa2b" name="acff65f956f203f1538f4bbf0cd44fa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff65f956f203f1538f4bbf0cd44fa2b">&#9670;&#160;</a></span>ScaledSquaredNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledSquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Squared L2 norm of a rescaled vector, i.e., <code>vector.cwiseProduct(scale).squaredNorm()</code>. </p>

</div>
</div>
<a id="a65f71a53d7766ac4c753d2218887cf98" name="a65f71a53d7766ac4c753d2218887cf98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f71a53d7766ac4c753d2218887cf98">&#9670;&#160;</a></span>ScaledSquaredNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::ScaledSquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00275">275</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ab5bf48ca920aa5abf755b21a3a938e72" name="ab5bf48ca920aa5abf755b21a3a938e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bf48ca920aa5abf755b21a3a938e72">&#9670;&#160;</a></span>SetEigenMatrixFromTriplets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetEigenMatrixFromTriplets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::Triplet&lt; double, int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>triplets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>matrix.setFromTriplets(triplets)</code>, except that <code>setFromTriplets</code> results in having three copies of the nonzeros in memory at the same time, because it first fills one matrix from triplets, and then transposes it into another. This avoids having the third copy in memory by sorting the triplets, reserving space in the matrix, and then inserting in sorted order. Compresses the matrix (<code>SparseMatrix.makeCompressed()</code>) after loading it. </p><dl class="section note"><dt>Note</dt><dd>This intentionally passes <code>triplets</code> by value, because it modifies them. To avoid the copy, pass a move reference. </dd></dl>
<p>The triplets are allowed to contain duplicate entries (and intentionally do for the diagonals of the objective matrix). For efficiency of insert and reserve, merge the duplicates first.</p>
<dl class="section note"><dt>Note</dt><dd><code>reserve()</code> takes column counts because matrix is in column major order.</dd></dl>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00431">431</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="a3082edb885e96d187a000584cf2c3046" name="a3082edb885e96d187a000584cf2c3046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3082edb885e96d187a000584cf2c3046">&#9670;&#160;</a></span>SetRandomProjections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetRandomProjections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>random_projection_seeds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointMetadata &amp;</td>          <td class="paramname"><span class="paramname"><em>metadata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each entry in <code>random_projection_seeds</code>, computes a random projection of the primal/dual solution pair onto pseudo-random vectors generated from that seed and adds the results to <code>random_primal_projections</code>/<code>random_dual_projections</code> in <code>metadata</code>. </p>

<p class="definition">Definition at line <a class="el" href="iteration__stats_8cc_source.html#l00626">626</a> of file <a class="el" href="iteration__stats_8cc_source.html">iteration_stats.cc</a>.</p>

</div>
</div>
<a id="ad8b78b2d2b8f14df64e2d6def3ab5545" name="ad8b78b2d2b8f14df64e2d6def3ab5545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b78b2d2b8f14df64e2d6def3ab5545">&#9670;&#160;</a></span>SetZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following functions use <code>sharder</code> to compute a vector operation in parallel. <code>sharder</code> should have the same size as the vector(s). For best performance <code>sharder</code> should have been created with the <code><a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a>(int64_t, / int, Scheduler*)</code> constructor. Like <code>dest.setZero(sharder.NumElements())</code>. Note that if <code>dest.size() != / sharder.NumElements()</code>, <code>dest</code> will be resized. </p>

</div>
</div>
<a id="a070d987d5d30e76fbbe2c32174eb3a4e" name="a070d987d5d30e76fbbe2c32174eb3a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d987d5d30e76fbbe2c32174eb3a4e">&#9670;&#160;</a></span>SetZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::SetZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00174">174</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a24be2a07d0f1a8994196b4c7f74870c2" name="a24be2a07d0f1a8994196b4c7f74870c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24be2a07d0f1a8994196b4c7f74870c2">&#9670;&#160;</a></span>SmallDualInfeasibleLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallDualInfeasibleLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00224">224</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a86984b72235fd509deb9975088eafb82" name="a86984b72235fd509deb9975088eafb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86984b72235fd509deb9975088eafb82">&#9670;&#160;</a></span>SmallInconsistentVariableBoundsLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallInconsistentVariableBoundsLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00195">195</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a287eefed02ca53e0fa0af77382920688" name="a287eefed02ca53e0fa0af77382920688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287eefed02ca53e0fa0af77382920688">&#9670;&#160;</a></span>SmallInitializationLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallInitializationLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00237">237</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="aa340ee35401be0c80f722003a6ac987d" name="aa340ee35401be0c80f722003a6ac987d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340ee35401be0c80f722003a6ac987d">&#9670;&#160;</a></span>SmallInvalidProblemLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallInvalidProblemLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00182">182</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a0da8f33b9749e1da2c36dddc189d77fb" name="a0da8f33b9749e1da2c36dddc189d77fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da8f33b9749e1da2c36dddc189d77fb">&#9670;&#160;</a></span>SmallPrimalDualInfeasibleLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallPrimalDualInfeasibleLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00231">231</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="af846811056ccf9ca9b69bef6ff8dc528" name="af846811056ccf9ca9b69bef6ff8dc528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af846811056ccf9ca9b69bef6ff8dc528">&#9670;&#160;</a></span>SmallPrimalInfeasibleLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::SmallPrimalInfeasibleLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00208">208</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a2f4054cb0abdfaacfebe5bf1b67eb9c9" name="a2f4054cb0abdfaacfebe5bf1b67eb9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4054cb0abdfaacfebe5bf1b67eb9c9">&#9670;&#160;</a></span>SolveDiagonalQpTrustRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalQpTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_gradient</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_gradient</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>primal_weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>solve_tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>SolveDiagonalTrustRegion</code>, but extracts the problem data from a <code><a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a></code> and implicitly concatenates the primal and dual parts before solving the trust-region subproblem. </p>

</div>
</div>
<a id="a64c21ba4bf7d15e5dd1f8396074a9dfa" name="a64c21ba4bf7d15e5dd1f8396074a9dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c21ba4bf7d15e5dd1f8396074a9dfa">&#9670;&#160;</a></span>SolveDiagonalQpTrustRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalQpTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1ShardedQuadraticProgram.html">ShardedQuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharded_qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>primal_gradient</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_gradient</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>primal_weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>solve_tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00768">768</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="ad87e72f6888d8bd27a4d74f35c3a118d" name="ad87e72f6888d8bd27a4d74f35c3a118d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87e72f6888d8bd27a4d74f35c3a118d">&#9670;&#160;</a></span>SolveDiagonalTrustRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>objective_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>objective_matrix_diagonal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_lower_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>center_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>norm_weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>solve_tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the following trust-region problem with bound constraints: min_x (1/2) * (x - <code>center_point</code>)^T * Q * (x - <code>center_point</code>)</p><ul>
<li><code>objective_vector</code>^T * (x - <code>center_point</code>) s.t. <code>variable_lower_bounds</code> &lt;= x &lt;= <code>variable_upper_bounds</code> || x - <code>center_point</code> ||_W &lt;= <code>target_radius</code> where |<code>y</code>|_W = sqrt(sum_i <code>norm_weights</code>[i] * y[i]^2). It replaces the ball constraint || x - <code>center_point</code> ||_W &lt;= <code>target_radius</code> with the equivalent constraint 0.5 * || x - <code>center_point</code> ||_W^2 &lt;= 0.5 * <code>target_radius</code>^2 and does a binary search for a Lagrange multiplier for the latter constraint that is at most (<code>solve_tolerance</code> * max(1, lambda*)) away from the optimum Lagrange multiplier lambda*. <code>sharder</code> should have the same size as the number of variables in the problem. Assumes that there is always a feasible solution, that is, that <code>variable_lower_bounds</code> &lt;= <code>center_point</code> &lt;= <code>variable_upper_bounds</code>, and that <code>norm_weights</code> &gt; 0, for 0 &lt;= i &lt; <code>sharder.NumElements()</code>. </li>
</ul>

</div>
</div>
<a id="a5f128477eac14f0eda4b73fdfb3e24d4" name="a5f128477eac14f0eda4b73fdfb3e24d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f128477eac14f0eda4b73fdfb3e24d4">&#9670;&#160;</a></span>SolveDiagonalTrustRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>objective_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>objective_matrix_diagonal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_lower_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>center_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>norm_weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>solve_tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00755">755</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a39db3ccea12adec49816af128a288223" name="a39db3ccea12adec49816af128a288223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39db3ccea12adec49816af128a288223">&#9670;&#160;</a></span>SolveDiagonalTrustRegionProblem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveDiagonalTrustRegionProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>problem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>solve_tol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the diagonal trust region problem using a binary search algorithm. See comment above <code><a class="el" href="#a5f128477eac14f0eda4b73fdfb3e24d4">SolveDiagonalTrustRegion()</a></code> in <a class="el" href="trust__region_8h.html">trust_region.h</a> for the meaning of <code>solve_tol</code>. </p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00694">694</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a90dd3b503fb3d2bb8bd51729584d6bad" name="a90dd3b503fb3d2bb8bd51729584d6bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dd3b503fb3d2bb8bd51729584d6bad">&#9670;&#160;</a></span>SolveTrustRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>objective_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_lower_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>center_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>norm_weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the following trust-region problem with bound constraints: min_x <code>objective_vector</code>^T * (x - <code>center_point</code>) s.t. <code>variable_lower_bounds</code> &lt;= x &lt;= <code>variable_upper_bounds</code> || x - <code>center_point</code> ||_W &lt;= <code>target_radius</code> where |<code>y</code>|_W = sqrt(sum_i <code>norm_weights</code>[i] * y[i]^2) using an exact linear-time method. <code>sharder</code> should have the same size as the number of variables in the problem. Assumes that there is always a feasible solution, that is, that <code>variable_lower_bounds</code> &lt;= <code>center_point</code> &lt;= <code>variable_upper_bounds</code>, and that <code>norm_weights</code> &gt; 0, for 0 &lt;= i &lt; <code>sharder.NumElements()</code>. </p>

</div>
</div>
<a id="a8da80544adc685ee442522ede0e095a9" name="a8da80544adc685ee442522ede0e095a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da80544adc685ee442522ede0e095a9">&#9670;&#160;</a></span>SolveTrustRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1TrustRegionResult.html">TrustRegionResult</a> operations_research::pdlp::SolveTrustRegion </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>objective_vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_lower_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>center_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>norm_weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>target_radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00453">453</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="acfdde18597f56c6108928669aa7e1fff" name="acfdde18597f56c6108928669aa7e1fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdde18597f56c6108928669aa7e1fff">&#9670;&#160;</a></span>SquaredDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredDistance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>(vector1 - vector2).squaredNorm()</code>. </p>

</div>
</div>
<a id="a32389515e696df20cec86493cf9852e6" name="a32389515e696df20cec86493cf9852e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32389515e696df20cec86493cf9852e6">&#9670;&#160;</a></span>SquaredDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredDistance </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00253">253</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="ab11d2b633fbd4e06d2d51d95767105db" name="ab11d2b633fbd4e06d2d51d95767105db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11d2b633fbd4e06d2d51d95767105db">&#9670;&#160;</a></span>SquaredNorm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>vector.squaredNorm()</code>. </p>

</div>
</div>
<a id="a051e8994e91729e038b6cab678ef5f89" name="a051e8994e91729e038b6cab678ef5f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051e8994e91729e038b6cab678ef5f89">&#9670;&#160;</a></span>SquaredNorm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::SquaredNorm </td>
          <td>(</td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00244">244</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="aac468743f4a9b4acb96d783b3b353a8a" name="aac468743f4a9b4acb96d783b3b353a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac468743f4a9b4acb96d783b3b353a8a">&#9670;&#160;</a></span>T()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dual_gradient operations_research::pdlp::T </td>
          <td>(</td>
          <td class="paramtype">y - `dual_solution`</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>DiagonalTrustRegionProblemFromQp</code> accepts a diagonal quadratic program and information about the current solution and gradient and sets up the following trust-region subproblem: min_{x, y} (x - <code>primal_solution</code>)^T Q (x - <code>primal_solution</code>)</p><ul>
<li><code>primal_gradient</code>^T (x - <code>primal_solution</code>) s.t. l &lt;= x - <code>primal_solution</code> &lt;= u l_implicit &lt;= y - <code>dual_solution</code> &lt;= u_implicit ||(x, y) - (<code>primal_solution</code>, <code>dual_solution</code>)||_W &lt;= r, where ||(x, y)||_W = sqrt(0.5 * <code>primal_weight</code> |<code>x</code>|^2 + (0.5 / <code>primal_weight</code>) |<code>y</code>|^2). This class implements the same methods as <code><a class="el" href="classoperations__research_1_1pdlp_1_1DiagonalTrustRegionProblem.html">DiagonalTrustRegionProblem</a></code>, but without the need to explicitly copy vectors. </li>
</ul>
<p>A reference to the objects passed in the constructor is kept, so they must outlive the <code>DiagonalTrustRegionProblemFromQp</code> instance.</p>

<p class="definition">Definition at line <a class="el" href="trust__region_8cc_source.html#l00529">529</a> of file <a class="el" href="trust__region_8cc_source.html">trust_region.cc</a>.</p>

</div>
</div>
<a id="a1d16c98703c18ea1d861e274758f0e4b" name="a1d16c98703c18ea1d861e274758f0e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d16c98703c18ea1d861e274758f0e4b">&#9670;&#160;</a></span>TestDiagonalQp1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestDiagonalQp1 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00131">131</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a9e82a5f4fad9211f4235a37919e36c64" name="a9e82a5f4fad9211f4235a37919e36c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e82a5f4fad9211f4235a37919e36c64">&#9670;&#160;</a></span>TestDiagonalQp2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestDiagonalQp2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00148">148</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a2be6c6d75aa743c9a64c87b093da0257" name="a2be6c6d75aa743c9a64c87b093da0257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be6c6d75aa743c9a64c87b093da0257">&#9670;&#160;</a></span>TestDiagonalQp3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestDiagonalQp3 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00165">165</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a71efdc063650b57ca9c2dce8ba280aa2" name="a71efdc063650b57ca9c2dce8ba280aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71efdc063650b57ca9c2dce8ba280aa2">&#9670;&#160;</a></span>TestLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TestLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00035">35</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a3ffa435d5162dd0e66c54d0b99600816" name="a3ffa435d5162dd0e66c54d0b99600816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa435d5162dd0e66c54d0b99600816">&#9670;&#160;</a></span>TinyLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> operations_research::pdlp::TinyLp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a "tiny" test LP. min 5 x_1 + 2 x_2 + x_3 + x_4 - 14 s.t. 2 x_1 + x_2 + x_3 + 2 x_4 = 12 x_1 + x_3 &gt;= 7 x_3 - x_4 &gt;= 1 0 &lt;= x_1 &lt;= 2 0 &lt;= x_2 &lt;= 4 0 &lt;= x_3 &lt;= 6 0 &lt;= x_4 &lt;= 3</p>
<p>Optimum solutions: Primal: x_1 = 1, x_2 = 0, x_3 = 6, x_4 = 2. Value: 5 + 0 + 6 + 2 - 14 = -1. Dual: [0.5, 4.0, 0.0] Value: 6 + 28 - 3.5*6 - 14 = -1 Reduced costs: [0.0, 1.5, -3.5, 0.0] </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00069">69</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a5c473c17b12a0b8d751a14939b0843ac" name="a5c473c17b12a0b8d751a14939b0843ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c473c17b12a0b8d751a14939b0843ac">&#9670;&#160;</a></span>ToDense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::Eigen::ArrayXXd operations_research::pdlp::ToDense </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sparse_mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00276">276</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a9c8124ffb313ef7566aec4a6cd14dfdf" name="a9c8124ffb313ef7566aec4a6cd14dfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8124ffb313ef7566aec4a6cd14dfdf">&#9670;&#160;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::pdlp::ToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1&#160;'000&#160;'000</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a "pretty" version of <code>qp</code>, truncating to at most <code>max_size</code> characters. This is for debugging purposes only - the format may change without notice. Although this output is vaguely similar to "LP format", it is not actually compatible with "LP format". </p>
<p>Closes the objective matrix expression.</p>
<p>Closes the objective scaling factor expression.</p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00322">322</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="aef2cdcdbe1010ad09a8d2c6fe8bc8645" name="aef2cdcdbe1010ad09a8d2c6fe8bc8645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2cdcdbe1010ad09a8d2c6fe8bc8645">&#9670;&#160;</a></span>TransposedMatrixVectorProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::TransposedMatrixVectorProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>matrix.transpose() * vector</code> but executed in parallel using <code>sharder</code>. The size of <code>sharder</code> must match the number of columns in <code>matrix</code>. To ensure good parallelization <code>matrix</code> should have (roughly) the same location of non-zeros as the <code>matrix</code> used when constructing <code>sharder</code>. </p>

</div>
</div>
<a id="a463586ded0a114d3ca4b97a048d37d8a" name="a463586ded0a114d3ca4b97a048d37d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463586ded0a114d3ca4b97a048d37d8a">&#9670;&#160;</a></span>TransposedMatrixVectorProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd operations_research::pdlp::TransposedMatrixVectorProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double, Eigen::ColMajor, int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>For very sparse columns, assignment to <code>shard(answer)</code> incurs a measurable overhead compared to using a constructor (i.e. <code>VectorXd temp = ...</code>). It is not clear why this is the case, nor how to avoid it.</dd></dl>

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00159">159</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<a id="a46d3d32d0a8e4e2c01b081f331797e1f" name="a46d3d32d0a8e4e2c01b081f331797e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d3d32d0a8e4e2c01b081f331797e1f">&#9670;&#160;</a></span>ValidateAdaptiveLinesearchParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateAdaptiveLinesearchParams </td>
          <td>(</td>
          <td class="paramtype">const AdaptiveLinesearchParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>InvalidArgumentError</code> if the proto contains invalid values. Returns <code>OkStatus</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00120">120</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="aa1ed703509ec38f4d680039f6d62791a" name="aa1ed703509ec38f4d680039f6d62791a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ed703509ec38f4d680039f6d62791a">&#9670;&#160;</a></span>ValidateMalitskyPockParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateMalitskyPockParams </td>
          <td>(</td>
          <td class="paramtype">const MalitskyPockParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>InvalidArgumentError</code> if the proto contains invalid values. Returns <code>OkStatus</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00141">141</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a2d2bda13dd823757fe941eecc9dc328b" name="a2d2bda13dd823757fe941eecc9dc328b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2bda13dd823757fe941eecc9dc328b">&#9670;&#160;</a></span>ValidatePrimalDualHybridGradientParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidatePrimalDualHybridGradientParams </td>
          <td>(</td>
          <td class="paramtype">const PrimalDualHybridGradientParams &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>InvalidArgumentError</code> if the proto contains invalid values. Returns <code>OkStatus</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00171">171</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a29d607529c02f2842bdc5cb9c918bd1b" name="a29d607529c02f2842bdc5cb9c918bd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d607529c02f2842bdc5cb9c918bd1b">&#9670;&#160;</a></span>ValidateQuadraticProgramDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateQuadraticProgramDimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>InvalidArgumentError</code> if vector or matrix dimensions are inconsistent. Returns <code>OkStatus</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="quadratic__program_8cc_source.html#l00038">38</a> of file <a class="el" href="quadratic__program_8cc_source.html">quadratic_program.cc</a>.</p>

</div>
</div>
<a id="aea1ddf99c0904d4ec8d3975975ffb4ff" name="aea1ddf99c0904d4ec8d3975975ffb4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1ddf99c0904d4ec8d3975975ffb4ff">&#9670;&#160;</a></span>ValidateTerminationCriteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::ValidateTerminationCriteria </td>
          <td>(</td>
          <td class="paramtype">const TerminationCriteria &amp;</td>          <td class="paramname"><span class="paramname"><em>criteria</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>InvalidArgumentError</code> if the proto contains invalid values. Returns <code>OkStatus</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00045">45</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="aa645221539fcb7491fa586e9e568922a" name="aa645221539fcb7491fa586e9e568922a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa645221539fcb7491fa586e9e568922a">&#9670;&#160;</a></span>VerifyTestDiagonalQp1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::VerifyTestDiagonalQp1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>maximize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00261">261</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a4d5567aad57ec9c50762717560246a25" name="a4d5567aad57ec9c50762717560246a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5567aad57ec9c50762717560246a25">&#9670;&#160;</a></span>VerifyTestLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::pdlp::VerifyTestLp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>maximize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the given <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> equals <a class="el" href="#a71efdc063650b57ca9c2dce8ba280aa2">TestLp()</a>. </p>

<p class="definition">Definition at line <a class="el" href="test__util_8cc_source.html#l00051">51</a> of file <a class="el" href="test__util_8cc_source.html">test_util.cc</a>.</p>

</div>
</div>
<a id="a9efbc8bad87c896ca3c29f6ab4f969e5" name="a9efbc8bad87c896ca3c29f6ab4f969e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efbc8bad87c896ca3c29f6ab4f969e5">&#9670;&#160;</a></span>WriteLinearProgramToMps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::WriteLinearProgramToMps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mps_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This will fail if <code>linear_program</code> is actually a quadratic program (that is, has a non-empty quadratic objective term). </dd></dl>

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00080">80</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="ac69097fbe470f9bdb4110f2c54455926" name="ac69097fbe470f9bdb4110f2c54455926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69097fbe470f9bdb4110f2c54455926">&#9670;&#160;</a></span>WriteQuadraticProgramToMPModelProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::pdlp::WriteQuadraticProgramToMPModelProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>quadratic_program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mpmodel_proto_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="quadratic__program__io_8cc_source.html#l00095">95</a> of file <a class="el" href="quadratic__program__io_8cc_source.html">quadratic_program_io.cc</a>.</p>

</div>
</div>
<a id="a9385d74b2577097ab755dbf9c4f7c2ff" name="a9385d74b2577097ab755dbf9c4f7c2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9385d74b2577097ab755dbf9c4f7c2ff">&#9670;&#160;</a></span>ZeroVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd operations_research::pdlp::ZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1pdlp_1_1Sharder.html">Sharder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sharder</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>VectorXd::Zero(sharder.NumElements())</code>. </p>

<p class="definition">Definition at line <a class="el" href="sharder_8cc_source.html#l00180">180</a> of file <a class="el" href="sharder_8cc_source.html">sharder.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a29bde348ab02e750d7423c8e551daedf" name="a29bde348ab02e750d7423c8e551daedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bde348ab02e750d7423c8e551daedf">&#9670;&#160;</a></span>kHugeDouble</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double operations_research::pdlp::kHugeDouble = 1.0e50</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00032">32</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a7b49a0361e8201ffd1515e0067b9fd30" name="a7b49a0361e8201ffd1515e0067b9fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b49a0361e8201ffd1515e0067b9fd30">&#9670;&#160;</a></span>kInfinity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::pdlp::kInfinity = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sharded__optimization__utils_8cc_source.html#l00037">37</a> of file <a class="el" href="sharded__optimization__utils_8cc_source.html">sharded_optimization_utils.cc</a>.</p>

</div>
</div>
<a id="a46a438627fa7471011a97cf5bd367aa0" name="a46a438627fa7471011a97cf5bd367aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a438627fa7471011a97cf5bd367aa0">&#9670;&#160;</a></span>kTinyDouble</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double operations_research::pdlp::kTinyDouble = 1.0e-50</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="solvers__proto__validation_8cc_source.html#l00031">31</a> of file <a class="el" href="solvers__proto__validation_8cc_source.html">solvers_proto_validation.cc</a>.</p>

</div>
</div>
<a id="a5eacdd74b066b885e267adad79344020" name="a5eacdd74b066b885e267adad79344020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eacdd74b066b885e267adad79344020">&#9670;&#160;</a></span>primal_solution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* x operations_research::pdlp::primal_solution</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recall the saddle-point formulation OPT = min_x max_y L(x, y) defined at <a href="https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation">https://developers.google.com/optimization/lp/pdlp_math#saddle-point_formulation</a>. This function computes lower and upper bounds on OPT with an additional ball or "trust-region" constraint on the domains of x and y.</p>
<p>The bounds are derived from the solution of the following problem: min_{x,y} _x L(<code>primal_solution</code>, <code>dual_solution</code>)^T (x - <code>primal_solution</code>)</p><ul>
<li>_y L(<code>primal_solution</code>, <code>dual_solution</code>)^T (y - <code>dual_solution</code>) subject to ||(x - <code>primal_solution</code>, y - <code>dual_solution</code>)||_PD &lt;= <code>radius</code>, where x and y are constrained to their respective bounds and ||(x,y)||_PD is defined by <code>primal_dual_norm</code>. When <code>use_diagonal_qp_trust_region_solver</code> is true, the solver instead solves the following problem: min_{x,y} _x L(<code>primal_solution</code>, <code>dual_solution</code>)^T (x - <code>primal_solution</code>)</li>
<li>_y L(<code>primal_solution</code>, <code>dual_solution</code>)^T (y - <code>dual_solution</code>)</li>
<li>(1 / 2) * (x - <code>primal_solution</code>)^T * <code>objective_matrix</code> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="trust__region_8h_source.html#l00146">146</a> of file <a class="el" href="trust__region_8h_source.html">trust_region.h</a>.</p>

</div>
</div>
<a id="a19f1afcc777ad3dbf7090595ce6fe803" name="a19f1afcc777ad3dbf7090595ce6fe803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f1afcc777ad3dbf7090595ce6fe803">&#9670;&#160;</a></span>x_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">x_0 x_1 x_2 operations_research::pdlp::x_3</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= 12</div>
<div class="line"> </div>
<div class="line"> 4 x_0                            &gt;=  -4</div>
<div class="line"> -1 &lt;=            1.5 x_2 -   <a class="code hl_variable" href="#a19f1afcc777ad3dbf7090595ce6fe803">x_3</a>  &lt;= 1</div>
<div class="line"> </div>
<div class="line"> -2 &lt;= x_1 &lt;= infinity</div>
<div class="line"> </div>
<div class="line"> 2.5 &lt;= <a class="code hl_variable" href="#a19f1afcc777ad3dbf7090595ce6fe803">x_3</a> &lt;= 3.5</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">QuadraticProgram</a> <a class="code hl_function" href="#a71efdc063650b57ca9c2dce8ba280aa2">TestLp</a>()</div>
<div class="ttc" id="anamespaceoperations__research_1_1pdlp_html_a19f1afcc777ad3dbf7090595ce6fe803"><div class="ttname"><a href="#a19f1afcc777ad3dbf7090595ce6fe803">operations_research::pdlp::x_3</a></div><div class="ttdeci">x_0 x_1 x_2 x_3</div><div class="ttdef"><b>Definition</b> <a href="pdlp_2test__util_8h_source.html#l00036">test_util.h:36</a></div></div>
<div class="ttc" id="anamespaceoperations__research_1_1pdlp_html_a71efdc063650b57ca9c2dce8ba280aa2"><div class="ttname"><a href="#a71efdc063650b57ca9c2dce8ba280aa2">operations_research::pdlp::TestLp</a></div><div class="ttdeci">QuadraticProgram TestLp()</div><div class="ttdef"><b>Definition</b> <a href="test__util_8cc_source.html#l00035">test_util.cc:35</a></div></div>
<div class="ttc" id="astructoperations__research_1_1pdlp_1_1QuadraticProgram_html"><div class="ttname"><a href="structoperations__research_1_1pdlp_1_1QuadraticProgram.html">operations_research::pdlp::QuadraticProgram</a></div><div class="ttdef"><b>Definition</b> <a href="quadratic__program_8h_source.html#l00061">quadratic_program.h:61</a></div></div>
</div><!-- fragment --><p>Returns a small LP with all 4 patterns of which lower and upper bounds on the constraints are finite and similarly for the variables. min 5.5 x_0 - 2 x_1 - x_2 + x_3 - 14 s.t. </p>

<p class="definition">Definition at line <a class="el" href="pdlp_2test__util_8h_source.html#l00036">36</a> of file <a class="el" href="pdlp_2test__util_8h_source.html">test_util.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1pdlp.html">pdlp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
