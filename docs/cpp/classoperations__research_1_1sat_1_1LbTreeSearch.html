<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::LbTreeSearch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.8</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classoperations__research_1_1sat_1_1LbTreeSearch.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1LbTreeSearch-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::LbTreeSearch Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="lb__tree__search_8h_source.html">lb_tree_search.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab578e3dd57e9e2c0daff912371d19dc2" id="r_ab578e3dd57e9e2c0daff912371d19dc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab578e3dd57e9e2c0daff912371d19dc2">LbTreeSearch</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *<a class="el" href="gurobi__interface_8cc.html#a0728f23c9a47655d38e0bf1a2f200bcf">model</a>)</td></tr>
<tr class="separator:ab578e3dd57e9e2c0daff912371d19dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eed5bfd114852c086831f49823d8ba" id="r_ab5eed5bfd114852c086831f49823d8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab5eed5bfd114852c086831f49823d8ba">Search</a> (const std::function&lt; void()&gt; &amp;feasible_solution_observer)</td></tr>
<tr class="memdesc:ab5eed5bfd114852c086831f49823d8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explores the search space.  <br /></td></tr>
<tr class="separator:ab5eed5bfd114852c086831f49823d8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implement a "classic" MIP tree search by having an exhaustive list of open nodes.</p>
<p>The goal of this subsolver is to improve the objective lower bound. It is meant to be used in a multi-thread portfolio, and as such it really do not care about finding solution. It is all about improving the lower bound.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001738">Todo:</a></b></dt><dd>(user): What this is doing is really similar to asking a SAT solver if the current objective lower bound is reachable by solving a SAT problem. However, this code handle on the side all the "conflict" of the form objective &gt; current_lb. As a result, when it is UNSAT, we can bump the lower bound by a bigger amount than one. We also do not completely loose everything learned so far for the next iteration. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lb__tree__search_8h_source.html#l00057">57</a> of file <a class="el" href="lb__tree__search_8h_source.html">lb_tree_search.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab578e3dd57e9e2c0daff912371d19dc2" name="ab578e3dd57e9e2c0daff912371d19dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab578e3dd57e9e2c0daff912371d19dc2">&#9670;&#160;</a></span>LbTreeSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::LbTreeSearch::LbTreeSearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We should create this class only in the presence of an objective.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001721">Todo:</a></b></dt><dd>(user): Starts with an initial variable score for all variable in the objective at their minimum value? this should emulate the first step of the core approach and gives a similar bound. </dd></dl>
<p>Identify an LP with the same objective variable.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001722">Todo:</a></b></dt><dd>(user): if we have many independent LP, this will find nothing. </dd></dl>
<p>We use the normal SAT search but we will bump the variable activity slightly differently. In addition to the conflicts, we also bump it each time the objective lower bound increase in a sub-node.</p>

<p class="definition">Definition at line <a class="el" href="lb__tree__search_8cc_source.html#l00048">48</a> of file <a class="el" href="lb__tree__search_8cc_source.html">lb_tree_search.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab5eed5bfd114852c086831f49823d8ba" name="ab5eed5bfd114852c086831f49823d8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eed5bfd114852c086831f49823d8ba">&#9670;&#160;</a></span>Search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::LbTreeSearch::Search </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>feasible_solution_observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explores the search space. </p>
<p>We currently restart the search tree from scratch from time to times:</p><ul>
<li>Initially, every kNumDecisionsBeforeInitialRestarts, for at most kMaxNumInitialRestarts times.</li>
<li>Every time we backtrack to level zero, we count how many nodes are worse than the best known objective lower bound. If this is true for more than half of the existing nodes, we restart and clear all nodes. If if this happens during the initial restarts phase, it reset the above counter and uses 1 of the available initial restarts.</li>
</ul>
<p>This has 2 advantages:</p><ul>
<li>It allows our "pseudo-cost" to kick in and experimentally result in smaller trees down the road.</li>
<li>It removes large inefficient search trees.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001723">Todo:</a></b></dt><dd>(user): a strong branching initial start, or allowing a few decision per nodes might be a better approach.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001724">Todo:</a></b></dt><dd>(user): It would also be cool to exploit the reason for the LB increase even more. </dd></dl>
<p>This is the current bound we try to improve. We cache it here to avoid getting the lock many times and it is also easier to follow the code if this is assumed constant for one iteration.</p>
<p>If some branches already have a good lower bound, no need to call the LP on those.</p>
<p>Propagate upward in the tree the new objective lb.</p>
<p>Our branch is always greater or equal to the level. We increase the objective_lb of the current node if needed.</p>
<p>Minor optim: sometimes, because of the LP and cuts, the reason for objective_var_ only contains lower level literals, so we can exploit that.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001725">Todo:</a></b></dt><dd>(user): No point checking that if the objective lb wasn't assigned at this level.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001726">Todo:</a></b></dt><dd>(user): Exploit the reasons further. </dd></dl>
<p>Propagate upward and then forward any new bounds.</p>
<p>If the root lb increased, update global shared objective lb.</p>
<p>Each time we are back here, we bump the activities of the variable that are part of the objective lower bound reason.</p>
<dl class="section note"><dt>Note</dt><dd>this is why we prefer not to increase the lower zero lower bound of objective_var_ with the tree root lower bound, so we can exploit more reasons.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001727">Todo:</a></b></dt><dd>(user): This is slightly different than bumping each time we push a decision that result in an LB increase. This is also called on backjump for instance. </dd></dl>
<p>Forget the whole tree and restart. We will do it periodically at the beginning of the search each time we cross the kNumDecisionsBeforeInitialRestarts decision since the last restart. This will happen at most kMaxNumInitialRestarts times.</p>
<p>Backtrack if needed.</p>
<p>Our algorithm stop exploring a branch as soon as its objective lower bound is greater than the root lower bound. We then backtrack to the first node in the branch that is not yet closed under this bound.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001728">Todo:</a></b></dt><dd>(user): If we remember how far we can backjump for both true/false branch, we could be more efficient. </dd></dl>
<p>Backtrack the solver.</p>
<p>Periodic backtrack to level zero so we can import bounds.</p>
<p>This will import other workers bound if we are back to level zero.</p>
<p>If the search has not just been restarted (in which case nodes_ would be empty), and if we are at level zero (either naturally, or if the backtrack level was set to zero in the above code), let's run a different heuristic to decide whether to restart the search from scratch or not.</p>
<p>We ignore small search trees.</p>
<p>Let's count how many nodes have worse objective bounds than the best known external objective lower bound.</p>
<p>Dive: Follow the branch with lowest objective. </p><dl class="section note"><dt>Note</dt><dd>we do not creates new nodes here.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001729">Todo:</a></b></dt><dd>(user): If we have new information and our current objective bound is higher than any bound in a whole subtree, we might want to just restart this subtree exploration? </dd></dl>
<p>This will be set to the next node index.</p>
<p>If the variable is already fixed, we bypass the node and connect its parent directly to the relevant child.</p>
<p>We jump directly to the subnode. Else we will change the root.</p>
<p>See if we have better bounds using the current LP state.</p>
<p>If both lower bound are the same, we pick the literal branch. We do that because this is the polarity that was chosen by the SAT heuristic in the first place. We tried random, it doesn't seems to work as well.</p>
<p>Conflict?</p>
<p>Update the proper field and abort the dive if we crossed the threshold.</p>
<p>If a conflict occurred, we will backtrack.</p>
<p>This test allow to not take a decision when the branch is already closed (i.e. the true branch or false branch lb is high enough). Adding it basically changes if we take the decision later when we explore the branch or right now.</p>
<p>I feel taking it later is better. It also avoid creating uneeded nodes. It does change the behavior on a few problem though. For instance on irp.mps.gz, the search works better without this, whatever the random seed. Not sure why, maybe it creates more diversity?</p>
<p>Another difference is that if the search is done and we have a feasible solution, we will not report it because of this test (except if we are at the optimal).</p>
<p>We are about to take a new decision, what we will do is dive until the objective lower bound increase. we will then create a bunch of new nodes in the tree.</p>
<p>By analyzing the reason for the increase, we can create less nodes than if we just followed the initial heuristic.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001730">Todo:</a></b></dt><dd>(user): In multithread, this change the behavior a lot since we dive until we beat the best shared bound. Maybe we shouldn't do that. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001731">Todo:</a></b></dt><dd>(user): We sometimes branch on the objective variable, this should probably be avoided. </dd></dl>
<p>No new decision: search done.</p>
<p>Analyse the reason for objective increase. Deduce a set of new nodes to append to the tree.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001732">Todo:</a></b></dt><dd>(user): Try to minimize the number of decisions? </dd></dl>
<p>Bump activities.</p>
<p>Create one node per new decisions.</p>
<p>Update the objective of the last node in the branch since we just improved that.</p>
<p>Reset the solver to a correct state since we have a subset of the current propagation. We backtrack as little as possible.</p>
<p>The decision level is the number of decision taken. Decision()[level] is the decision at that level.</p>
<p>Update bounds with reduced costs info.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001733">Todo:</a></b></dt><dd>(user): Uses old optimal constraint that we just potentially backtracked over?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001734">Todo:</a></b></dt><dd>(user): We could do all at once rather than in O(#decision * #size). </dd></dl>

<p class="definition">Definition at line <a class="el" href="lb__tree__search_8cc_source.html#l00204">204</a> of file <a class="el" href="lb__tree__search_8cc_source.html">lb_tree_search.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="lb__tree__search_8h_source.html">lb_tree_search.h</a></li>
<li>ortools/sat/<a class="el" href="lb__tree__search_8cc_source.html">lb_tree_search.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html">LbTreeSearch</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
