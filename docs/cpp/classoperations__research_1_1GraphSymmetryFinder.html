<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::GraphSymmetryFinder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.9</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1GraphSymmetryFinder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1GraphSymmetryFinder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::GraphSymmetryFinder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="find__graph__symmetries_8h_source.html">find_graph_symmetries.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeabd870fd44ae7ee75a3341b86e140a6" id="r_aeabd870fd44ae7ee75a3341b86e140a6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1StaticGraph.html">::util::StaticGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeabd870fd44ae7ee75a3341b86e140a6">Graph</a></td></tr>
<tr class="separator:aeabd870fd44ae7ee75a3341b86e140a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af670a8f7f325e3a7431f2723c52ec25d" id="r_af670a8f7f325e3a7431f2723c52ec25d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af670a8f7f325e3a7431f2723c52ec25d">GraphSymmetryFinder</a> (const <a class="el" href="#aeabd870fd44ae7ee75a3341b86e140a6">Graph</a> &amp;graph, bool is_undirected)</td></tr>
<tr class="separator:af670a8f7f325e3a7431f2723c52ec25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb920046454e1c278a6189cf6634a48c" id="r_afb920046454e1c278a6189cf6634a48c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb920046454e1c278a6189cf6634a48c">IsGraphAutomorphism</a> (const <a class="el" href="classoperations__research_1_1DynamicPermutation.html">DynamicPermutation</a> &amp;permutation) const</td></tr>
<tr class="separator:afb920046454e1c278a6189cf6634a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c71ed3bac0344dfe9964839806566b" id="r_a42c71ed3bac0344dfe9964839806566b"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c71ed3bac0344dfe9964839806566b">FindSymmetries</a> (std::vector&lt; int &gt; *node_equivalence_classes_io, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *generators, std::vector&lt; int &gt; *factorized_automorphism_group_size, <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *<a class="el" href="linear__solver_2solve_8cc.html#a5924b2104bcf836d8c82d6d5b6bf4b36">time_limit</a>=nullptr)</td></tr>
<tr class="separator:a42c71ed3bac0344dfe9964839806566b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70544105d8f21edcbed63fdd7f6d34ab" id="r_a70544105d8f21edcbed63fdd7f6d34ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70544105d8f21edcbed63fdd7f6d34ab">RecursivelyRefinePartitionByAdjacency</a> (int first_unrefined_part_index, <a class="el" href="classoperations__research_1_1DynamicPartition.html">DynamicPartition</a> *partition)</td></tr>
<tr class="separator:a70544105d8f21edcbed63fdd7f6d34ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15616e8b6f42c682ff091b989190ff8" id="r_af15616e8b6f42c682ff091b989190ff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af15616e8b6f42c682ff091b989190ff8">DistinguishNodeInPartition</a> (int node, <a class="el" href="classoperations__research_1_1DynamicPartition.html">DynamicPartition</a> *partition, std::vector&lt; int &gt; *new_singletons_or_null)</td></tr>
<tr class="memdesc:af15616e8b6f42c682ff091b989190ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">**** Methods below are public FOR TESTING ONLY. ****  <br /></td></tr>
<tr class="separator:af15616e8b6f42c682ff091b989190ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="find__graph__symmetries_8h_source.html#l00046">46</a> of file <a class="el" href="find__graph__symmetries_8h_source.html">find_graph_symmetries.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeabd870fd44ae7ee75a3341b86e140a6" name="aeabd870fd44ae7ee75a3341b86e140a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabd870fd44ae7ee75a3341b86e140a6">&#9670;&#160;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1StaticGraph.html">::util::StaticGraph</a> <a class="el" href="#aeabd870fd44ae7ee75a3341b86e140a6">operations_research::GraphSymmetryFinder::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="find__graph__symmetries_8h_source.html#l00048">48</a> of file <a class="el" href="find__graph__symmetries_8h_source.html">find_graph_symmetries.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af670a8f7f325e3a7431f2723c52ec25d" name="af670a8f7f325e3a7431f2723c52ec25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af670a8f7f325e3a7431f2723c52ec25d">&#9670;&#160;</a></span>GraphSymmetryFinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::GraphSymmetryFinder::GraphSymmetryFinder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeabd870fd44ae7ee75a3341b86e140a6">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_undirected</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the Graph passed to the <a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html">GraphSymmetryFinder</a> is undirected, i.e. for every arc a-&gt;b, b-&gt;a is also present, then you should set "is_undirected" to true. This will, in effect, DCHECK() that the graph is indeed undirected, and bypass the need for reverse adjacency lists.</p>
<p>If you don't know this in advance, you may use GraphIsSymmetric() from <a class="el" href="graph_2util_8h.html">ortools/graph/util.h</a>.</p>
<p>"graph" must not have multi-arcs. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo</a></b></dt><dd>(user): support multi-arcs. </dd></dl>
<p><a class="el" href="classoperations__research_1_1Set.html">Set</a> up an "unlimited" time limit by default.</p>
<p>Compute the reverse adjacency lists. First pass: compute the total in-degree of all nodes and put it in reverse_adj_list_index (shifted by two; see below why).</p>
<p>Second pass: apply a cumulative sum over reverse_adj_list_index. After that, reverse_adj_list contains: [0, 0, in_degree(node0), in_degree(node0) + in_degree(node1), ...]</p>
<p>Third pass: populate "flattened_reverse_adj_lists", using reverse_adj_list_index[i] as a dynamic pointer to the yet-unpopulated area of the reverse adjacency list of node #i.</p>
<p>The last pass shifted reverse_adj_list_index, so it's now as we want it: [0, in_degree(node0), in_degree(node0) + in_degree(node1), ...]</p>

<p class="definition">Definition at line <a class="el" href="find__graph__symmetries_8cc_source.html#l00173">173</a> of file <a class="el" href="find__graph__symmetries_8cc_source.html">find_graph_symmetries.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af15616e8b6f42c682ff091b989190ff8" name="af15616e8b6f42c682ff091b989190ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15616e8b6f42c682ff091b989190ff8">&#9670;&#160;</a></span>DistinguishNodeInPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::GraphSymmetryFinder::DistinguishNodeInPartition </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1DynamicPartition.html">DynamicPartition</a> *</td>          <td class="paramname"><span class="paramname"><em>partition</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>new_singletons_or_null</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>**** Methods below are public FOR TESTING ONLY. **** </p>
<p>Special wrapper of the above method: assuming that partition is already fully refined, further refine it by {node}, and propagate by adjacency. Also, optionally collect all the new singletons of the partition in "new_singletons", sorted by their part number in the partition. </p>
<p>Explore the newly refined parts to gather all the new singletons.</p>
<p>We may see the same singleton parent several times, so we guard them with the tmp_node_mask_ boolean vector.</p>
<p>Reset tmp_node_mask_.</p>

<p class="definition">Definition at line <a class="el" href="find__graph__symmetries_8cc_source.html#l00341">341</a> of file <a class="el" href="find__graph__symmetries_8cc_source.html">find_graph_symmetries.cc</a>.</p>

</div>
</div>
<a id="a42c71ed3bac0344dfe9964839806566b" name="a42c71ed3bac0344dfe9964839806566b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c71ed3bac0344dfe9964839806566b">&#9670;&#160;</a></span>FindSymmetries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status operations_research::GraphSymmetryFinder::FindSymmetries </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>node_equivalence_classes_io</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1SparsePermutation.html">SparsePermutation</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>generators</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>factorized_automorphism_group_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>time_limit</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a set of generators of the automorphism subgroup of the graph that respects the given node equivalence classes. The generators are themselves permutations of the nodes: see <a href="http://en.wikipedia.org/wiki/Automorphism">http://en.wikipedia.org/wiki/Automorphism</a>. These permutations may only map a node onto a node of its equivalence class: two nodes i and j are in the same equivalence class iff node_equivalence_classes_io[i] == node_equivalence_classes_io[j];</p>
<p>This set of generators is not necessarily the smallest possible (neither in the number of generators, nor in the size of these generators), but it is minimal in that no generator can be removed while keeping the generated group intact. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo</a></b></dt><dd>(user): verify the minimality in unit tests.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if "generators" is empty, then the graph has no symmetry: the only automorphism is the identity.</dd></dl>
<p>The equivalence classes are actually an input/output: they are refined according to all asymmetries found. In the end, n1 and n2 will be considered equivalent (i.e. node_equivalence_classes_io[n1] == node_equivalence_classes_io[n2]) if and only if there exists a permutation of nodes that:</p><ul>
<li>keeps the graph invariant</li>
<li>maps n1 onto n2</li>
<li>maps each node to a node of its original equivalence class.</li>
</ul>
<p>This method also outputs the size of the automorphism group, expressed as a factorized product of integers (note that the size itself may be as large as N!).</p>
<p>DEADLINE AND PARTIAL COMPLETION: If the deadline passed as argument (via <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a>) is reached, this method will return quickly (within a few milliseconds of the limit). The outputs may be partially filled:</p><ul>
<li>Each element of "generators", if non-empty, will be a valid permutation.</li>
<li>"node_equivalence_classes_io" will contain the equivalence classes corresponding to the orbits under all the generators in "generators".</li>
<li>"factorized_automorphism_group_size" will also be incomplete, and partially valid: its last element may be undervalued. But all prior elements are valid factors of the automorphism group size. </li>
</ul>
<p>Initialization.</p>
<p>Break all inherent asymmetries in the graph.</p>
<p>To find all permutations of the Graph that satisfy the current partition, we pick an element v that is not in a singleton part, and we split the search in two phases: 1) Find (the generators of) all permutations that keep v invariant. 2) For each w in PartOf(v) such that w != v: find <em>one</em> permutation that maps v to w, if it exists. if it does exists, add this to the generators.</p>
<p>The part 1) is recursive.</p>
<p>Since we can't really use true recursion because it will be too deep for the stack, we implement it iteratively. To do that, we unroll 1): the "invariant dive" is a single pass that successively refines the node base_partition with elements from non-singleton parts (the 'invariant node'), until all parts are singletons. We remember which nodes we picked as invariants, and also the successive partition sizes as we refine it, to allow us to backtrack. Then we'll perform 2) in the reverse order, backtracking the stack from 1) as using another dedicated stack for the search (see below).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo</a></b></dt><dd>(user): experiment with, and briefly describe the results of various algorithms for picking the invariant node:<ul>
<li>random selection</li>
<li>highest/lowest degree first</li>
<li>enumerate by part index; or by part size</li>
<li>etc. </li>
</ul>
</dd></dl>
<p>Now we've dived to the bottom: we're left with the identity permutation, which we don't need as a generator. We move on to phase 2).</p>
<p>Backtrack the last step of 1) (the invariant dive).</p>
<p>Now we'll try to map "root_node" to all image nodes that seem compatible and that aren't "root_node" itself.</p>
<p>Doing so, we're able to detect potential bad (or good) matches by refining the 'base' partition with "root_node"; and refining the 'image' partition (which represents the partition of images nodes, i.e. the nodes after applying the currently implicit permutation) with that candidate image node: if the two partitions don't match, then the candidate image isn't compatible. If the partitions do match, we might either find the underlying permutation directly, or we might need to further try and map other nodes to their image: this is a recursive search with backtracking.</p>
<p>The potential images of root_node are the nodes in its part. They can be pruned by the already computed equivalence classes. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo</a></b></dt><dd>(user): better elect the representative of each equivalence class in order to reduce the permutation support down the line </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo</a></b></dt><dd>(user): Don't build a list; but instead use direct, inline iteration on the representatives in the while() loop below, to benefit from the incremental merging of the equivalence classes. </dd></dl>
<p>Try to map "root_node" to all of its potential images. For each image, we only care about finding a single compatible permutation, if it exists.</p>
<p>We found a permutation. We store it in the list of generators, and further prune out the remaining 'root' image candidates, taking into account the permutation we just found.</p>
<p>HACK(user): to make sure that we keep root_image_node as the representant of its part, we temporarily move it to the front of the vector, then move it again to the back so that it gets deleted by the pop_back() below.</p>
<p>Register it onto the permutations_displacing_node vector.</p>
<p>Move the permutation to the generator list (this also transfers ownership).</p>
<p>We keep track of the size of the orbit of 'root_node' under the current subgroup: this is one of the factors of the total group size. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo</a></b></dt><dd>(user): better, more complete explanation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="find__graph__symmetries_8cc_source.html#l00448">448</a> of file <a class="el" href="find__graph__symmetries_8cc_source.html">find_graph_symmetries.cc</a>.</p>

</div>
</div>
<a id="afb920046454e1c278a6189cf6634a48c" name="afb920046454e1c278a6189cf6634a48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb920046454e1c278a6189cf6634a48c">&#9670;&#160;</a></span>IsGraphAutomorphism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::GraphSymmetryFinder::IsGraphAutomorphism </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1DynamicPermutation.html">DynamicPermutation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the given permutation is an automorphism of the graph given at construction. This costs O(sum(degree(x))) (the sum is over all nodes x that are displaced by the permutation). </p>
<p>The graph was not symmetric: we must also check the incoming arcs to displaced nodes.</p>

<p class="definition">Definition at line <a class="el" href="find__graph__symmetries_8cc_source.html#l00220">220</a> of file <a class="el" href="find__graph__symmetries_8cc_source.html">find_graph_symmetries.cc</a>.</p>

</div>
</div>
<a id="a70544105d8f21edcbed63fdd7f6d34ab" name="a70544105d8f21edcbed63fdd7f6d34ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70544105d8f21edcbed63fdd7f6d34ab">&#9670;&#160;</a></span>RecursivelyRefinePartitionByAdjacency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::GraphSymmetryFinder::RecursivelyRefinePartitionByAdjacency </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>first_unrefined_part_index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1DynamicPartition.html">DynamicPartition</a> *</td>          <td class="paramname"><span class="paramname"><em>partition</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fully refine the partition of nodes, using the graph as symmetry breaker. This means applying the following steps on each part P of the partition:</p><ul>
<li>Compute the aggregated in-degree of all nodes of the graph, only looking at arcs originating from nodes in P.</li>
<li>For each in-degree d=1...max_in_degree, refine the partition by the set of nodes with in-degree d. And recursively applying it on all new or modified parts.</li>
</ul>
<p>In our use cases, we may call this in a scenario where the partition was already partially refined on all parts #0...#K, then you should set "first_unrefined_part_index" to K+1. </p>
<p>Rename, for readability of the code below.</p>
<p>This function is the main bottleneck of the whole algorithm. We count the number of blocks in the inner-most loops in num_operations. At the end we will multiply it by a factor to have some deterministic time that we will append to the deterministic time counter.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo</a></b></dt><dd>(user): We are really imprecise in our counting, but it is fine. We just need a way to enforce a deterministic limit on the computation effort. </dd></dl>
<p>Assuming that the partition was refined based on the adjacency on parts [0 .. first_unrefined_part_index) already, we simply need to refine parts first_unrefined_part_index ... NumParts()-1, the latter bound being a moving target: When a part #p &lt; first_unrefined_part_index gets modified, it's always split in two: itself, and a new part #p'. Since #p was already refined on, we only need to further refine on <em>one</em> of its two split parts. And this will be done because p' &gt; first_unrefined_part_index.</p>
<p>Thus, the following loop really does the full recursive refinement as advertised.</p>
<p>Count the aggregated degree of all nodes, only looking at arcs that come from/to the current part.</p>
<p>Group the nodes by (nonzero) degree. Remember the maximum degree.</p>
<p>For each degree, refine the partition by the set of nodes with that degree.</p>
<p>We use a manually tuned factor 3 because Refine() does quite a bit of operations for each node in its argument.</p>
<p>The coefficient was manually tuned (only on a few instances) so that the time is roughly correlated with seconds on a fast desktop computer from</p><ol type="1">
<li></li>
</ol>

<p class="definition">Definition at line <a class="el" href="find__graph__symmetries_8cc_source.html#l00264">264</a> of file <a class="el" href="find__graph__symmetries_8cc_source.html">find_graph_symmetries.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/algorithms/<a class="el" href="find__graph__symmetries_8h_source.html">find_graph_symmetries.h</a></li>
<li>ortools/algorithms/<a class="el" href="find__graph__symmetries_8cc_source.html">find_graph_symmetries.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html">GraphSymmetryFinder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
