<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::IntegerEncoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1IntegerEncoder.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1IntegerEncoder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::IntegerEncoder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="integer_8h_source.html">integer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a56acaedd036489098fb1a9fffbf56299" id="r_a56acaedd036489098fb1a9fffbf56299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56acaedd036489098fb1a9fffbf56299">IntegerEncoder</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model)</td></tr>
<tr class="separator:a56acaedd036489098fb1a9fffbf56299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491edfd4777c3269fdaa5384d106986e" id="r_a491edfd4777c3269fdaa5384d106986e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491edfd4777c3269fdaa5384d106986e">IntegerEncoder</a> (const <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> &amp;)=delete</td></tr>
<tr class="memdesc:a491edfd4777c3269fdaa5384d106986e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is neither copyable nor movable.  <br /></td></tr>
<tr class="separator:a491edfd4777c3269fdaa5384d106986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d11b1d74955e3a43f40b3413f9eb05" id="r_a06d11b1d74955e3a43f40b3413f9eb05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d11b1d74955e3a43f40b3413f9eb05">operator=</a> (const <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> &amp;)=delete</td></tr>
<tr class="separator:a06d11b1d74955e3a43f40b3413f9eb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949fce00ad5651c2b2d1fa948b00bab3" id="r_a949fce00ad5651c2b2d1fa948b00bab3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a949fce00ad5651c2b2d1fa948b00bab3">~IntegerEncoder</a> ()</td></tr>
<tr class="separator:a949fce00ad5651c2b2d1fa948b00bab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c648e8ec1bcd260e3d4ed64b293bb28" id="r_a7c648e8ec1bcd260e3d4ed64b293bb28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c648e8ec1bcd260e3d4ed64b293bb28">ReserveSpaceForNumVariables</a> (int num_vars)</td></tr>
<tr class="memdesc:a7c648e8ec1bcd260e3d4ed64b293bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory optimization: you can call this before encoding variables.  <br /></td></tr>
<tr class="separator:a7c648e8ec1bcd260e3d4ed64b293bb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f7926d822f4f2f659be6f503090ac4" id="r_a44f7926d822f4f2f659be6f503090ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44f7926d822f4f2f659be6f503090ac4">FullyEncodeVariable</a> (IntegerVariable var)</td></tr>
<tr class="separator:a44f7926d822f4f2f659be6f503090ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59abe9efe4246f146066483c1955e602" id="r_a59abe9efe4246f146066483c1955e602"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59abe9efe4246f146066483c1955e602">VariableIsFullyEncoded</a> (IntegerVariable var) const</td></tr>
<tr class="separator:a59abe9efe4246f146066483c1955e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026bc28d991d58fbfc02170772610c9c" id="r_a026bc28d991d58fbfc02170772610c9c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a026bc28d991d58fbfc02170772610c9c">FullDomainEncoding</a> (IntegerVariable var) const</td></tr>
<tr class="separator:a026bc28d991d58fbfc02170772610c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9c6e26e6872022a6eca84b4d551df5" id="r_a6d9c6e26e6872022a6eca84b4d551df5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d9c6e26e6872022a6eca84b4d551df5">PartialDomainEncoding</a> (IntegerVariable var) const</td></tr>
<tr class="separator:a6d9c6e26e6872022a6eca84b4d551df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4e1df43e180231715e6fde6b4d0a8d" id="r_a1a4e1df43e180231715e6fde6b4d0a8d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4e1df43e180231715e6fde6b4d0a8d">Canonicalize</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit) const</td></tr>
<tr class="separator:a1a4e1df43e180231715e6fde6b4d0a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86897b73c47086f4bc261f9424b47de7" id="r_a86897b73c47086f4bc261f9424b47de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86897b73c47086f4bc261f9424b47de7">GetOrCreateAssociatedLiteral</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit)</td></tr>
<tr class="separator:a86897b73c47086f4bc261f9424b47de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a2aeea649e70334c5b44dca14a5ae2" id="r_af0a2aeea649e70334c5b44dca14a5ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a2aeea649e70334c5b44dca14a5ae2">GetOrCreateLiteralAssociatedToEquality</a> (IntegerVariable var, IntegerValue value)</td></tr>
<tr class="separator:af0a2aeea649e70334c5b44dca14a5ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec52e921c18df159386147aa3cdd7b4" id="r_a1ec52e921c18df159386147aa3cdd7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ec52e921c18df159386147aa3cdd7b4">AssociateToIntegerLiteral</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> literal, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit)</td></tr>
<tr class="separator:a1ec52e921c18df159386147aa3cdd7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf605bfbb224230f6c65067fdd26c34" id="r_a9bf605bfbb224230f6c65067fdd26c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> literal, IntegerVariable var, IntegerValue value)</td></tr>
<tr class="separator:a9bf605bfbb224230f6c65067fdd26c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6225ad79b815b7c047a1ac7cae7f9d5f" id="r_a6225ad79b815b7c047a1ac7cae7f9d5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6225ad79b815b7c047a1ac7cae7f9d5f">IsFixedOrHasAssociatedLiteral</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit) const</td></tr>
<tr class="separator:a6225ad79b815b7c047a1ac7cae7f9d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0b1234e31f51f99e14860cd628cde2" id="r_acb0b1234e31f51f99e14860cd628cde2"><td class="memItemLeft" align="right" valign="top">LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb0b1234e31f51f99e14860cd628cde2">GetAssociatedLiteral</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit) const</td></tr>
<tr class="separator:acb0b1234e31f51f99e14860cd628cde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e03d485f294f266fc5035623d118374" id="r_a6e03d485f294f266fc5035623d118374"><td class="memItemLeft" align="right" valign="top">LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e03d485f294f266fc5035623d118374">GetAssociatedEqualityLiteral</a> (IntegerVariable var, IntegerValue value) const</td></tr>
<tr class="separator:a6e03d485f294f266fc5035623d118374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb35d5a03917142051ba332e5b8c4f47" id="r_aeb35d5a03917142051ba332e5b8c4f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb35d5a03917142051ba332e5b8c4f47">DisableImplicationBetweenLiteral</a> ()</td></tr>
<tr class="separator:aeb35d5a03917142051ba332e5b8c4f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e6e7891342273c5e080447a0d11d81" id="r_a42e6e7891342273c5e080447a0d11d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42e6e7891342273c5e080447a0d11d81">AddAllImplicationsBetweenAssociatedLiterals</a> ()</td></tr>
<tr class="separator:a42e6e7891342273c5e080447a0d11d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cca994f8853c8db660f4e7a21fb8c5" id="r_a76cca994f8853c8db660f4e7a21fb8c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research_1_1sat.html#acd5fcd5e44b4b153afface289223dd33">InlinedIntegerLiteralVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76cca994f8853c8db660f4e7a21fb8c5">GetIntegerLiterals</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit) const</td></tr>
<tr class="memdesc:a76cca994f8853c8db660f4e7a21fb8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IntegerLiterals that were associated with the given <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>.  <br /></td></tr>
<tr class="separator:a76cca994f8853c8db660f4e7a21fb8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3facae69021dc097a83055e5d307a6d1" id="r_a3facae69021dc097a83055e5d307a6d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research_1_1sat.html#a5bdc7202e90489453a3bad10f80f09b2">InlinedIntegerValueVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3facae69021dc097a83055e5d307a6d1">GetEqualityLiterals</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit) const</td></tr>
<tr class="separator:a3facae69021dc097a83055e5d307a6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7344658433592dd6afade973a5a791e" id="r_aa7344658433592dd6afade973a5a791e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; IntegerVariable &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7344658433592dd6afade973a5a791e">GetAllAssociatedVariables</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit) const</td></tr>
<tr class="separator:aa7344658433592dd6afade973a5a791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ee6625cc77f06ede1a167e581d6b5d" id="r_a41ee6625cc77f06ede1a167e581d6b5d"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41ee6625cc77f06ede1a167e581d6b5d">GetLiteralView</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit) const</td></tr>
<tr class="separator:a41ee6625cc77f06ede1a167e581d6b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcdafc23f9a3bd469e4f1fa175c0c81" id="r_a9fcdafc23f9a3bd469e4f1fa175c0c81"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fcdafc23f9a3bd469e4f1fa175c0c81">LiteralOrNegationHasView</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit, IntegerVariable *view=nullptr, bool *view_is_direct=nullptr) const</td></tr>
<tr class="separator:a9fcdafc23f9a3bd469e4f1fa175c0c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77db48dfcede211913ef7ca139a4b2b6" id="r_a77db48dfcede211913ef7ca139a4b2b6"><td class="memItemLeft" align="right" valign="top">LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77db48dfcede211913ef7ca139a4b2b6">SearchForLiteralAtOrBefore</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit, IntegerValue *bound) const</td></tr>
<tr class="separator:a77db48dfcede211913ef7ca139a4b2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575c98a8e638de20b5a3a5861263c732" id="r_a575c98a8e638de20b5a3a5861263c732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a575c98a8e638de20b5a3a5861263c732">GetTrueLiteral</a> ()</td></tr>
<tr class="memdesc:a575c98a8e638de20b5a3a5861263c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the literal always set to true, make it if it does not exist.  <br /></td></tr>
<tr class="separator:a575c98a8e638de20b5a3a5861263c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435301889907352870b1ba8f2f013a21" id="r_a435301889907352870b1ba8f2f013a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a435301889907352870b1ba8f2f013a21">GetFalseLiteral</a> ()</td></tr>
<tr class="separator:a435301889907352870b1ba8f2f013a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab231c14715e9a2fc56ca0d12a0f3df5e" id="r_ab231c14715e9a2fc56ca0d12a0f3df5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab231c14715e9a2fc56ca0d12a0f3df5e">PartialGreaterThanEncoding</a> (IntegerVariable var) const</td></tr>
<tr class="separator:ab231c14715e9a2fc56ca0d12a0f3df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52e2afab935dc8da3b29e9391614b85" id="r_ae52e2afab935dc8da3b29e9391614b85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae52e2afab935dc8da3b29e9391614b85">UpdateEncodingOnInitialDomainChange</a> (IntegerVariable var, <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> domain)</td></tr>
<tr class="separator:ae52e2afab935dc8da3b29e9391614b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Each integer variable x will be associated with a set of literals encoding (x &gt;= v) for some values of v. This class maintains the relationship between the integer variables and such literals which can be created by a call to CreateAssociatedLiteral().</p>
<p>The advantage of creating such Boolean variables is that the <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> which is driving the search can then take this variable as a decision and maintain these variables activity and so on. These variables can also be propagated directly by the learned clauses.</p>
<p>This class also support a non-lazy full domain encoding which will create one literal per possible value in the domain. See <a class="el" href="#a44f7926d822f4f2f659be6f503090ac4">FullyEncodeVariable()</a>. This is meant to be called by constraints that directly work on the variable values like a table constraint or an all-diff constraint.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001812">Todo</a></b></dt><dd>(user): We could also lazily create precedences Booleans between two arbitrary IntegerVariable. This is better done in the <a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html">PrecedencesPropagator</a> though. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00100">100</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56acaedd036489098fb1a9fffbf56299" name="a56acaedd036489098fb1a9fffbf56299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56acaedd036489098fb1a9fffbf56299">&#9670;&#160;</a></span>IntegerEncoder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerEncoder::IntegerEncoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00102">102</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a491edfd4777c3269fdaa5384d106986e" name="a491edfd4777c3269fdaa5384d106986e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491edfd4777c3269fdaa5384d106986e">&#9670;&#160;</a></span>IntegerEncoder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerEncoder::IntegerEncoder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type is neither copyable nor movable. </p>

</div>
</div>
<a id="a949fce00ad5651c2b2d1fa948b00bab3" name="a949fce00ad5651c2b2d1fa948b00bab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949fce00ad5651c2b2d1fa948b00bab3">&#9670;&#160;</a></span>~IntegerEncoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerEncoder::~IntegerEncoder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00113">113</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a42e6e7891342273c5e080447a0d11d81" name="a42e6e7891342273c5e080447a0d11d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e6e7891342273c5e080447a0d11d81">&#9670;&#160;</a></span>AddAllImplicationsBetweenAssociatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::AddAllImplicationsBetweenAssociatedLiterals </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is tricky: AddBinaryClause() might trigger propagation that causes the encoding to be filtered. So we make a copy...</p>
<p>literal =&gt; previous.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00227">227</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a9bf605bfbb224230f6c65067fdd26c34" name="a9bf605bfbb224230f6c65067fdd26c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf605bfbb224230f6c65067fdd26c34">&#9670;&#160;</a></span>AssociateToIntegerEqualValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::AssociateToIntegerEqualValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is symmetric and we only deal with positive variable.</p>
<p>Detect literal view. Note that the same literal can be associated to more than one variable, and thus already have a view. We don't change it in this case.</p>
<p>We use the "do not insert if present" behavior of .insert() to do just one lookup.</p>
<p>If this key is already associated, make the two literals equal.</p>
<p>Fix literal for value outside the domain.</p>
<p>Update equality_by_var. Note that due to the equality_to_associated_literal_ hash table, there should never be any duplicate values for a given variable.</p>
<p>Fix literal for constant domain.</p>
<p>Special case for the first and last value.</p>
<dl class="section note"><dt>Note</dt><dd>this will recursively call <a class="el" href="#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue()</a> but since equality_to_associated_literal_[] is now set, the recursion will stop there. When a domain has just 2 values, this allows to call just once <a class="el" href="#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue()</a> and also associate the other value to the negation of the given literal.</dd></dl>
<p>(var == value) &lt;=&gt; (var &gt;= value) and (var &lt;= value).</p>
<p>Update reverse encoding.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00435">435</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a1ec52e921c18df159386147aa3cdd7b4" name="a1ec52e921c18df159386147aa3cdd7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec52e921c18df159386147aa3cdd7b4">&#9670;&#160;</a></span>AssociateToIntegerLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::AssociateToIntegerLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates the Boolean literal to (X &gt;= bound) or (X == value). If a literal was already associated to this fact, this will add an equality constraints between both literals. If the fact is trivially true or false, this will fix the given literal. </p>
<p>Always transform to positive variable.</p>
<p>We just insert the part corresponding to the literal with positive variable.</p>
<p>Corner case if adding implication cause this to be fixed.</p>
<p>Resize reverse encoding.</p>
<p>Detect the case &gt;= max or &lt;= min and properly register them. Note that both cases will happen at the same time if there is just two possible value in the domain.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00365">365</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a1a4e1df43e180231715e6fde6b4d0a8d" name="a1a4e1df43e180231715e6fde6b4d0a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4e1df43e180231715e6fde6b4d0a8d">&#9670;&#160;</a></span>Canonicalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; operations_research::sat::IntegerEncoder::Canonicalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the "canonical" (i_lit, negation of i_lit) pair. This mainly deal with domain with initial hole like [1,2][5,6] so that if one ask for x &lt;= 3, this get canonicalized in the pair (x &lt;= 2, x &gt;= 5).</p>
<dl class="section note"><dt>Note</dt><dd>it is an error to call this with a literal that is trivially true or trivially false according to the initial variable domain. This is CHECKed to make sure we don't create wasteful literal.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001817">Todo</a></b></dt><dd>(user): This is linear in the domain "complexity", we can do better if needed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00247">247</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="aeb35d5a03917142051ba332e5b8c4f47" name="aeb35d5a03917142051ba332e5b8c4f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb35d5a03917142051ba332e5b8c4f47">&#9670;&#160;</a></span>DisableImplicationBetweenLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::DisableImplicationBetweenLiteral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advanced usage. It is more efficient to create the associated literals in order, but it might be anoying to do so. Instead, you can first call <a class="el" href="#aeb35d5a03917142051ba332e5b8c4f47">DisableImplicationBetweenLiteral()</a> and when you are done creating all the associated literals, you can call (only at level zero) <a class="el" href="#a42e6e7891342273c5e080447a0d11d81">AddAllImplicationsBetweenAssociatedLiterals()</a> which will also turn back on the implications between literals for the one that will be added afterwards. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00209">209</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a026bc28d991d58fbfc02170772610c9c" name="a026bc28d991d58fbfc02170772610c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026bc28d991d58fbfc02170772610c9c">&#9670;&#160;</a></span>FullDomainEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; &amp; operations_research::sat::IntegerEncoder::FullDomainEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the list of literal &lt;=&gt; var == value currently associated to the given variable. The result is sorted by value. We filter literal at false, and if a literal is true, then you will get a singleton. To be sure to get the full set of encoded value, then you should call this at level zero.</p>
<p>The <a class="el" href="#a026bc28d991d58fbfc02170772610c9c">FullDomainEncoding()</a> just check <a class="el" href="#a59abe9efe4246f146066483c1955e602">VariableIsFullyEncoded()</a> and returns the same result.</p>
<dl class="section warning"><dt>Warning</dt><dd>The reference returned is only valid until the next call to one of these functions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00146">146</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a44f7926d822f4f2f659be6f503090ac4" name="a44f7926d822f4f2f659be6f503090ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f7926d822f4f2f659be6f503090ac4">&#9670;&#160;</a></span>FullyEncodeVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::FullyEncodeVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fully encode a variable using its current initial domain. If the variable is already fully encoded, this does nothing.</p>
<p>This creates new Booleans variables as needed: 1) num_values for the literals X == value. Except when there is just two value in which case only one variable is created. 2) num_values - 3 for the literals X &gt;= value or X &lt;= value (using their negation). The -3 comes from the fact that we can reuse the equality literals for the two extreme points.</p>
<p>The encoding for NegationOf(var) is automatically created too. It reuses the same Boolean variable as the encoding of var.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001816">Todo</a></b></dt><dd>(user): It is currently only possible to call that at the decision level zero because we cannot add ternary clause in the middle of the search (for now). This is Checked. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001789">Todo</a></b></dt><dd>(user): Maybe we can optimize the literal creation order and their polarity as our default SAT heuristics initially depends on this.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001790">Todo</a></b></dt><dd>(user): Currently, in some corner cases, <a class="el" href="#af0a2aeea649e70334c5b44dca14a5ae2">GetOrCreateLiteralAssociatedToEquality()</a> might trigger some propagation that update the domain of var, so we need to cache the values to not read garbage. Note that it is okay to call the function on values no longer reachable, as this will just do nothing. </dd></dl>
<p>Mark var and Negation(var) as fully encoded.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00080">80</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="aa7344658433592dd6afade973a5a791e" name="aa7344658433592dd6afade973a5a791e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7344658433592dd6afade973a5a791e">&#9670;&#160;</a></span>GetAllAssociatedVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; IntegerVariable &gt; &amp; operations_research::sat::IntegerEncoder::GetAllAssociatedVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all the variables for which this literal is associated to either var &gt;= value or var == value. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00231">231</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a6e03d485f294f266fc5035623d118374" name="a6e03d485f294f266fc5035623d118374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e03d485f294f266fc5035623d118374">&#9670;&#160;</a></span>GetAssociatedEqualityLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiteralIndex operations_research::sat::IntegerEncoder::GetAssociatedEqualityLiteral </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00318">318</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="acb0b1234e31f51f99e14860cd628cde2" name="acb0b1234e31f51f99e14860cd628cde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0b1234e31f51f99e14860cd628cde2">&#9670;&#160;</a></span>GetAssociatedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiteralIndex operations_research::sat::IntegerEncoder::GetAssociatedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001795">Todo</a></b></dt><dd>(user): Canonicalization might be slow. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00541">541</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a3facae69021dc097a83055e5d307a6d1" name="a3facae69021dc097a83055e5d307a6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3facae69021dc097a83055e5d307a6d1">&#9670;&#160;</a></span>GetEqualityLiterals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research_1_1sat.html#a5bdc7202e90489453a3bad10f80f09b2">InlinedIntegerValueVector</a> &amp; operations_research::sat::IntegerEncoder::GetEqualityLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the variable == value pairs that were associated with the given <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>. Note that only positive IntegerVariable appears here. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00222">222</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a435301889907352870b1ba8f2f013a21" name="a435301889907352870b1ba8f2f013a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435301889907352870b1ba8f2f013a21">&#9670;&#160;</a></span>GetFalseLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetFalseLiteral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00283">283</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a76cca994f8853c8db660f4e7a21fb8c5" name="a76cca994f8853c8db660f4e7a21fb8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cca994f8853c8db660f4e7a21fb8c5">&#9670;&#160;</a></span>GetIntegerLiterals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research_1_1sat.html#acd5fcd5e44b4b153afface289223dd33">InlinedIntegerLiteralVector</a> &amp; operations_research::sat::IntegerEncoder::GetIntegerLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the IntegerLiterals that were associated with the given <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00213">213</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a41ee6625cc77f06ede1a167e581d6b5d" name="a41ee6625cc77f06ede1a167e581d6b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ee6625cc77f06ede1a167e581d6b5d">&#9670;&#160;</a></span>GetLiteralView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerEncoder::GetLiteralView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If it exists, returns a [0,1] integer variable which is equal to 1 iff the given literal is true. Returns kNoIntegerVariable if such variable does not exist. Note that one can create one by creating a new IntegerVariable and calling <a class="el" href="#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue()</a>. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00247">247</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a86897b73c47086f4bc261f9424b47de7" name="a86897b73c47086f4bc261f9424b47de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86897b73c47086f4bc261f9424b47de7">&#9670;&#160;</a></span>GetOrCreateAssociatedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetOrCreateAssociatedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns, after creating it if needed, a Boolean literal such that:</p><ul>
<li>if true, then the <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> is true.</li>
<li>if false, then the negated <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> is true.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>this "canonicalize" the given literal first.</dd></dl>
<p>This add the proper implications with the two "neighbor" literals of this one if they exist. This is the "list encoding" in: Thibaut Feydy, Peter J. Stuckey, "Lazy Clause Generation Reengineered", CP 2009. </p>
<p>Remove trivial literal.</p>
<p>Canonicalize and see if we have an equivalent literal already.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001793">Todo</a></b></dt><dd>(user): on some problem this happens. We should probably make sure that we don't create extra fixed Boolean variable for no reason. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00274">274</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="af0a2aeea649e70334c5b44dca14a5ae2" name="af0a2aeea649e70334c5b44dca14a5ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a2aeea649e70334c5b44dca14a5ae2">&#9670;&#160;</a></span>GetOrCreateLiteralAssociatedToEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetOrCreateLiteralAssociatedToEquality </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for trivial true/false literal to avoid creating variable for no reasons.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001794">Todo</a></b></dt><dd>(user): this happens on some problem. We should probably make sure that we don't create extra fixed Boolean variable for no reason. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>here we could detect the case before creating the literal. The initial domain didn't contain it, but maybe the one of (&gt;= value) or (&lt;= value) is false?</dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00328">328</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a575c98a8e638de20b5a3a5861263c732" name="a575c98a8e638de20b5a3a5861263c732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575c98a8e638de20b5a3a5861263c732">&#9670;&#160;</a></span>GetTrueLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetTrueLiteral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the literal always set to true, make it if it does not exist. </p>
<p>This might return false if we are already UNSAT. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001818">Todo</a></b></dt><dd>(user): Make sure we abort right away on unsat! </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00270">270</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a6225ad79b815b7c047a1ac7cae7f9d5f" name="a6225ad79b815b7c047a1ac7cae7f9d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6225ad79b815b7c047a1ac7cae7f9d5f">&#9670;&#160;</a></span>IsFixedOrHasAssociatedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerEncoder::IsFixedOrHasAssociatedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns kNoLiteralIndex if there is no associated or the associated literal otherwise.</p>
<p>Tricky: for domain with hole, like [0,1][5,6], we assume some equivalence classes, like &gt;=2, &gt;=3, &gt;=4 are all the same as &gt;= 5. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00532">532</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a9fcdafc23f9a3bd469e4f1fa175c0c81" name="a9fcdafc23f9a3bd469e4f1fa175c0c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcdafc23f9a3bd469e4f1fa175c0c81">&#9670;&#160;</a></span>LiteralOrNegationHasView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::IntegerEncoder::LiteralOrNegationHasView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable *</td>          <td class="paramname"><span class="paramname"><em>view</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>view_is_direct</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this is true, then a literal can be linearized with an affine expression involving an integer variable. </p>
<p>If a literal has both views, we want to always keep the same representative: the smallest IntegerVariable.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00583">583</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a06d11b1d74955e3a43f40b3413f9eb05" name="a06d11b1d74955e3a43f40b3413f9eb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d11b1d74955e3a43f40b3413f9eb05">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> &amp; operations_research::sat::IntegerEncoder::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d9c6e26e6872022a6eca84b4d551df5" name="a6d9c6e26e6872022a6eca84b4d551df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9c6e26e6872022a6eca84b4d551df5">&#9670;&#160;</a></span>PartialDomainEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; &amp; operations_research::sat::IntegerEncoder::PartialDomainEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We can cleanup the current encoding in this case.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00152">152</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ab231c14715e9a2fc56ca0d12a0f3df5e" name="ab231c14715e9a2fc56ca0d12a0f3df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab231c14715e9a2fc56ca0d12a0f3df5e">&#9670;&#160;</a></span>PartialGreaterThanEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; operations_research::sat::IntegerEncoder::PartialGreaterThanEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> associated to <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> of the form var &gt;= value. We make a copy, because this can be easily invalidated when calling any function of this class. So it is less efficient but safer. </p>
<p>Tricky: we need to account for holes.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00603">603</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a7c648e8ec1bcd260e3d4ed64b293bb28" name="a7c648e8ec1bcd260e3d4ed64b293bb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c648e8ec1bcd260e3d4ed64b293bb28">&#9670;&#160;</a></span>ReserveSpaceForNumVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::ReserveSpaceForNumVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory optimization: you can call this before encoding variables. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001788">Todo</a></b></dt><dd>(user): Reserve vector index by literals? It is trickier, as we might not know beforehand how many we will need. Consider alternatives to not waste space like using dequeue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00074">74</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a77db48dfcede211913ef7ca139a4b2b6" name="a77db48dfcede211913ef7ca139a4b2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77db48dfcede211913ef7ca139a4b2b6">&#9670;&#160;</a></span>SearchForLiteralAtOrBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiteralIndex operations_research::sat::IntegerEncoder::SearchForLiteralAtOrBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue *</td>          <td class="paramname"><span class="paramname"><em>bound</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a Boolean literal associated with a bound lower than or equal to the one of the given <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>. If the given <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> is true, then the returned literal should be true too. Returns kNoLiteralIndex if no such literal was created.</p>
<p>Ex: if 'i' is (x &gt;= 4) and we already created a literal associated to (x &gt;= 2) but not to (x &gt;= 3), we will return the literal associated with (x &gt;= 2).</p>
<dl class="section note"><dt>Note</dt><dd>we assume the input literal is canonicalized and do not fall into a hole. Otherwise, this work but will likely return a literal before and not one equivalent to it (which can be after!). </dd></dl>
<p>We need the entry at or before. We take the element before the upper_bound() which is either the encoding of i if it already exists, or the encoding just before it.</p>
<p>We ask for who is implied by -var &gt;= -bound, so we look for the var &gt;= value with value &gt; bound and take its negation.</p>
<p>Compute tight bound if there are holes, we have X &lt;= candidate.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00555">555</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ae52e2afab935dc8da3b29e9391614b85" name="ae52e2afab935dc8da3b29e9391614b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52e2afab935dc8da3b29e9391614b85">&#9670;&#160;</a></span>UpdateEncodingOnInitialDomainChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerEncoder::UpdateEncodingOnInitialDomainChange </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a></td>          <td class="paramname"><span class="paramname"><em>domain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes sure all element in the &gt;= encoding are non-trivial and canonical. The input variable must be positive. </p>
<p>Fix &gt;= literal that can be fixed. We filter and canonicalize the encoding.</p>
<p>We are past the end, so always false.</p>
<p>We are at or before the beginning, so always true.</p>
<dl class="section note"><dt>Note</dt><dd>we canonicalize the literal if it fall into a hole.</dd></dl>
<p>Same for equality encoding. This will be lazily cleaned on the next <a class="el" href="#a6d9c6e26e6872022a6eca84b4d551df5">PartialDomainEncoding()</a> call.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00639">639</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a59abe9efe4246f146066483c1955e602" name="a59abe9efe4246f146066483c1955e602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59abe9efe4246f146066483c1955e602">&#9670;&#160;</a></span>VariableIsFullyEncoded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerEncoder::VariableIsFullyEncoded </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if we know that PartialDomainEncoding(var) span the full domain of var. This is always true if FullyEncodeVariable(var) has been called. </p>
<p>Once fully encoded, the status never changes.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001791">Todo</a></b></dt><dd>(user): Cache result as long as equality_by_var_[index] is unchanged? It might not be needed since if the variable is not fully encoded, then <a class="el" href="#a6d9c6e26e6872022a6eca84b4d551df5">PartialDomainEncoding()</a> will filter unreachable values, and so the size check will be false until further value have been encoded. </dd></dl>
<p>This cleans equality_by_var_[index] as a side effect and in particular, sorts it by values.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001792">Todo</a></b></dt><dd>(user): Comparing the size might be enough, but we want to be always valid even if either (*domains_[var]) or PartialDomainEncoding(var) are not properly synced because the propagation is not finished. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00111">111</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="integer_8h_source.html">integer.h</a></li>
<li>ortools/sat/<a class="el" href="integer_8cc_source.html">integer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
