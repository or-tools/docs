<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::IntegerEncoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.5</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classoperations__research_1_1sat_1_1IntegerEncoder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1IntegerEncoder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::IntegerEncoder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="integer_8h_source.html">integer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a56acaedd036489098fb1a9fffbf56299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a56acaedd036489098fb1a9fffbf56299">IntegerEncoder</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *<a class="el" href="gurobi__interface_8cc.html#a0728f23c9a47655d38e0bf1a2f200bcf">model</a>)</td></tr>
<tr class="separator:a56acaedd036489098fb1a9fffbf56299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949fce00ad5651c2b2d1fa948b00bab3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a949fce00ad5651c2b2d1fa948b00bab3">~IntegerEncoder</a> ()</td></tr>
<tr class="separator:a949fce00ad5651c2b2d1fa948b00bab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f7926d822f4f2f659be6f503090ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a44f7926d822f4f2f659be6f503090ac4">FullyEncodeVariable</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>)</td></tr>
<tr class="separator:a44f7926d822f4f2f659be6f503090ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59abe9efe4246f146066483c1955e602"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a59abe9efe4246f146066483c1955e602">VariableIsFullyEncoded</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:a59abe9efe4246f146066483c1955e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1595d32af53b8730a57ed36866707a23"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1595d32af53b8730a57ed36866707a23">FullDomainEncoding</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:a1595d32af53b8730a57ed36866707a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad17dae9d7ebf7bd70f4d3053a890d56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#aad17dae9d7ebf7bd70f4d3053a890d56">PartialDomainEncoding</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:aad17dae9d7ebf7bd70f4d3053a890d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc6f1787d26f16ce0c8ddece12f9993"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a2fc6f1787d26f16ce0c8ddece12f9993">RawDomainEncoding</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:a2fc6f1787d26f16ce0c8ddece12f9993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4e1df43e180231715e6fde6b4d0a8d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1a4e1df43e180231715e6fde6b4d0a8d">Canonicalize</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit) const</td></tr>
<tr class="separator:a1a4e1df43e180231715e6fde6b4d0a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86897b73c47086f4bc261f9424b47de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a86897b73c47086f4bc261f9424b47de7">GetOrCreateAssociatedLiteral</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit)</td></tr>
<tr class="separator:a86897b73c47086f4bc261f9424b47de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a2aeea649e70334c5b44dca14a5ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#af0a2aeea649e70334c5b44dca14a5ae2">GetOrCreateLiteralAssociatedToEquality</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>, IntegerValue <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:af0a2aeea649e70334c5b44dca14a5ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec52e921c18df159386147aa3cdd7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1ec52e921c18df159386147aa3cdd7b4">AssociateToIntegerLiteral</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="optimization_8cc.html#af63dcc00f2023fdf498e0829e6fb8a6b">literal</a>, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit)</td></tr>
<tr class="separator:a1ec52e921c18df159386147aa3cdd7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf605bfbb224230f6c65067fdd26c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="optimization_8cc.html#af63dcc00f2023fdf498e0829e6fb8a6b">literal</a>, IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>, IntegerValue <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a9bf605bfbb224230f6c65067fdd26c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c35b8f98baecd51741072760efdbefe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a2c35b8f98baecd51741072760efdbefe">LiteralIsAssociated</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit) const</td></tr>
<tr class="separator:a2c35b8f98baecd51741072760efdbefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0b1234e31f51f99e14860cd628cde2"><td class="memItemLeft" align="right" valign="top">LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#acb0b1234e31f51f99e14860cd628cde2">GetAssociatedLiteral</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit) const</td></tr>
<tr class="separator:acb0b1234e31f51f99e14860cd628cde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e03d485f294f266fc5035623d118374"><td class="memItemLeft" align="right" valign="top">LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a6e03d485f294f266fc5035623d118374">GetAssociatedEqualityLiteral</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>, IntegerValue <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>) const</td></tr>
<tr class="separator:a6e03d485f294f266fc5035623d118374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb35d5a03917142051ba332e5b8c4f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#aeb35d5a03917142051ba332e5b8c4f47">DisableImplicationBetweenLiteral</a> ()</td></tr>
<tr class="separator:aeb35d5a03917142051ba332e5b8c4f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e6e7891342273c5e080447a0d11d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a42e6e7891342273c5e080447a0d11d81">AddAllImplicationsBetweenAssociatedLiterals</a> ()</td></tr>
<tr class="separator:a42e6e7891342273c5e080447a0d11d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cca994f8853c8db660f4e7a21fb8c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research_1_1sat.html#a539d666be21909480bba1626e9c55090">InlinedIntegerLiteralVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a76cca994f8853c8db660f4e7a21fb8c5">GetIntegerLiterals</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit) const</td></tr>
<tr class="memdesc:a76cca994f8853c8db660f4e7a21fb8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IntegerLiterals that were associated with the given <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>.  <br /></td></tr>
<tr class="separator:a76cca994f8853c8db660f4e7a21fb8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1496a93332968c0e66cbc57c907b1fa7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceoperations__research_1_1sat.html#a539d666be21909480bba1626e9c55090">InlinedIntegerLiteralVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1496a93332968c0e66cbc57c907b1fa7">GetAllIntegerLiterals</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit) const</td></tr>
<tr class="separator:a1496a93332968c0e66cbc57c907b1fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a0bd75e741e84b5062d0e7a527995a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#ae8a0bd75e741e84b5062d0e7a527995a">NewlyFixedIntegerLiterals</a> () const</td></tr>
<tr class="separator:ae8a0bd75e741e84b5062d0e7a527995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb56ac18986a20dd9aeae6a83cfcb5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#abbb56ac18986a20dd9aeae6a83cfcb5f">ClearNewlyFixedIntegerLiterals</a> ()</td></tr>
<tr class="separator:abbb56ac18986a20dd9aeae6a83cfcb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67429ccec189e8be975f9c1956540ea9"><td class="memItemLeft" align="right" valign="top">const IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a67429ccec189e8be975f9c1956540ea9">GetLiteralView</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit) const</td></tr>
<tr class="separator:a67429ccec189e8be975f9c1956540ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcdafc23f9a3bd469e4f1fa175c0c81"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a9fcdafc23f9a3bd469e4f1fa175c0c81">LiteralOrNegationHasView</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> lit, IntegerVariable *view=nullptr, bool *view_is_direct=nullptr) const</td></tr>
<tr class="separator:a9fcdafc23f9a3bd469e4f1fa175c0c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597efd42efcef647f5ee211e658d8598"><td class="memItemLeft" align="right" valign="top">LiteralIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a597efd42efcef647f5ee211e658d8598">SearchForLiteralAtOrBefore</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>, IntegerValue *<a class="el" href="routing__filters_8cc.html#a4f1e8002734902ae1c65ccc3fc30c98e">bound</a>) const</td></tr>
<tr class="separator:a597efd42efcef647f5ee211e658d8598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575c98a8e638de20b5a3a5861263c732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a575c98a8e638de20b5a3a5861263c732">GetTrueLiteral</a> ()</td></tr>
<tr class="memdesc:a575c98a8e638de20b5a3a5861263c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the literal always set to true, make it if it does not exist.  <br /></td></tr>
<tr class="separator:a575c98a8e638de20b5a3a5861263c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435301889907352870b1ba8f2f013a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a435301889907352870b1ba8f2f013a21">GetFalseLiteral</a> ()</td></tr>
<tr class="separator:a435301889907352870b1ba8f2f013a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f01ceb93bb7d5fbe05105e557aabcb"><td class="memItemLeft" align="right" valign="top">absl::btree_map&lt; IntegerValue, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#ab8f01ceb93bb7d5fbe05105e557aabcb">PartialGreaterThanEncoding</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:ab8f01ceb93bb7d5fbe05105e557aabcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Each integer variable x will be associated with a set of literals encoding (x &gt;= v) for some values of v. This class maintains the relationship between the integer variables and such literals which can be created by a call to CreateAssociatedLiteral().</p>
<p>The advantage of creating such Boolean variables is that the <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> which is driving the search can then take this variable as a decision and maintain these variables activity and so on. These variables can also be propagated directly by the learned clauses.</p>
<p>This class also support a non-lazy full domain encoding which will create one literal per possible value in the domain. See <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a44f7926d822f4f2f659be6f503090ac4">FullyEncodeVariable()</a>. This is meant to be called by constraints that directly work on the variable values like a table constraint or an all-diff constraint.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001478">Todo:</a></b></dt><dd>(user): We could also lazily create precedences Booleans between two arbitrary IntegerVariable. This is better done in the <a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html">PrecedencesPropagator</a> though. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00393">393</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56acaedd036489098fb1a9fffbf56299" name="a56acaedd036489098fb1a9fffbf56299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56acaedd036489098fb1a9fffbf56299">&#9670;&#160;</a></span>IntegerEncoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerEncoder::IntegerEncoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00395">395</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a949fce00ad5651c2b2d1fa948b00bab3" name="a949fce00ad5651c2b2d1fa948b00bab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949fce00ad5651c2b2d1fa948b00bab3">&#9670;&#160;</a></span>~IntegerEncoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerEncoder::~IntegerEncoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00400">400</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a42e6e7891342273c5e080447a0d11d81" name="a42e6e7891342273c5e080447a0d11d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e6e7891342273c5e080447a0d11d81">&#9670;&#160;</a></span>AddAllImplicationsBetweenAssociatedLiterals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::AddAllImplicationsBetweenAssociatedLiterals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lit =&gt; previous.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00202">202</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a9bf605bfbb224230f6c65067fdd26c34" name="a9bf605bfbb224230f6c65067fdd26c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf605bfbb224230f6c65067fdd26c34">&#9670;&#160;</a></span>AssociateToIntegerEqualValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::AssociateToIntegerEqualValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detect literal view. Note that the same literal can be associated to more than one variable, and thus already have a view. We don't change it in this case.</p>
<p>We use the "do not insert if present" behavior of .insert() to do just one lookup.</p>
<p>If this key is already associated, make the two literals equal.</p>
<p>Fix literal for value outside the domain.</p>
<p>Update equality_by_var. Note that due to the equality_to_associated_literal_ hash table, there should never be any duplicate values for a given variable.</p>
<p>Fix literal for constant domain.</p>
<p>Special case for the first and last value.</p>
<dl class="section note"><dt>Note</dt><dd>this will recursively call <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue()</a> but since equality_to_associated_literal_[] is now set, the recursion will stop there. When a domain has just 2 values, this allows to call just once <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue()</a> and also associate the other value to the negation of the given literal.</dd></dl>
<p>(var == value) &lt;=&gt; (var &gt;= value) and (var &lt;= value).</p>
<p>Update reverse encoding.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00343">343</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a1ec52e921c18df159386147aa3cdd7b4" name="a1ec52e921c18df159386147aa3cdd7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec52e921c18df159386147aa3cdd7b4">&#9670;&#160;</a></span>AssociateToIntegerLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::AssociateToIntegerLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td>
          <td class="paramname"><em>i_lit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates the Boolean literal to (X &gt;= bound) or (X == value). If a literal was already associated to this fact, this will add an equality constraints between both literals. If the fact is trivially true or false, this will fix the given literal. </p>
<p>Detect the case &gt;= max or &lt;= min and properly register them. Note that both cases will happen at the same time if there is just two possible value in the domain.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00317">317</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a1a4e1df43e180231715e6fde6b4d0a8d" name="a1a4e1df43e180231715e6fde6b4d0a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4e1df43e180231715e6fde6b4d0a8d">&#9670;&#160;</a></span>Canonicalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; operations_research::sat::IntegerEncoder::Canonicalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td>
          <td class="paramname"><em>i_lit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the "canonical" (i_lit, negation of i_lit) pair. This mainly deal with domain with initial hole like [1,2][5,6] so that if one ask for x &lt;= 3, this get canonicalized in the pair (x &lt;= 2, x &gt;= 5).</p>
<dl class="section note"><dt>Note</dt><dd>it is an error to call this with a literal that is trivially true or trivially false according to the initial variable domain. This is CHECKed to make sure we don't create wasteful literal.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001484">Todo:</a></b></dt><dd>(user): This is linear in the domain "complexity", we can do better if needed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00219">219</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="abbb56ac18986a20dd9aeae6a83cfcb5f" name="abbb56ac18986a20dd9aeae6a83cfcb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb56ac18986a20dd9aeae6a83cfcb5f">&#9670;&#160;</a></span>ClearNewlyFixedIntegerLiterals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::ClearNewlyFixedIntegerLiterals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00522">522</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aeb35d5a03917142051ba332e5b8c4f47" name="aeb35d5a03917142051ba332e5b8c4f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb35d5a03917142051ba332e5b8c4f47">&#9670;&#160;</a></span>DisableImplicationBetweenLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::DisableImplicationBetweenLiteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advanced usage. It is more efficient to create the associated literals in order, but it might be anoying to do so. Instead, you can first call <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#aeb35d5a03917142051ba332e5b8c4f47">DisableImplicationBetweenLiteral()</a> and when you are done creating all the associated literals, you can call (only at level zero) <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a42e6e7891342273c5e080447a0d11d81">AddAllImplicationsBetweenAssociatedLiterals()</a> which will also turn back on the implications between literals for the one that will be added afterwards. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00496">496</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a1595d32af53b8730a57ed36866707a23" name="a1595d32af53b8730a57ed36866707a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1595d32af53b8730a57ed36866707a23">&#9670;&#160;</a></span>FullDomainEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; operations_research::sat::IntegerEncoder::FullDomainEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the full encoding of a variable on which <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a44f7926d822f4f2f659be6f503090ac4">FullyEncodeVariable()</a> has been called. The returned elements are always sorted by increasing IntegerValue and we filter values associated to false literals.</p>
<p>Performance note: This function is not particularly fast, however it should only be required during domain creation. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00130">130</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a44f7926d822f4f2f659be6f503090ac4" name="a44f7926d822f4f2f659be6f503090ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f7926d822f4f2f659be6f503090ac4">&#9670;&#160;</a></span>FullyEncodeVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerEncoder::FullyEncodeVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fully encode a variable using its current initial domain. If the variable is already fully encoded, this does nothing.</p>
<p>This creates new Booleans variables as needed: 1) num_values for the literals X == value. Except when there is just two value in which case only one variable is created. 2) num_values - 3 for the literals X &gt;= value or X &lt;= value (using their negation). The -3 comes from the fact that we can reuse the equality literals for the two extreme points.</p>
<p>The encoding for NegationOf(var) is automatically created too. It reuses the same Boolean variable as the encoding of var.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001483">Todo:</a></b></dt><dd>(user): It is currently only possible to call that at the decision level zero because we cannot add ternary clause in the middle of the search (for now). This is Checked. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001449">Todo:</a></b></dt><dd>(user): Maybe we can optimize the literal creation order and their polarity as our default SAT heuristics initially depends on this.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001450">Todo:</a></b></dt><dd>(user): Currently, in some corner cases, <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#af0a2aeea649e70334c5b44dca14a5ae2">GetOrCreateLiteralAssociatedToEquality()</a> might trigger some propagation that update the domain of var, so we need to cache the values to not read garbage. Note that it is okay to call the function on values no longer reachable, as this will just do nothing. </dd></dl>
<p>Mark var and Negation(var) as fully encoded.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00065">65</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a1496a93332968c0e66cbc57c907b1fa7" name="a1496a93332968c0e66cbc57c907b1fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1496a93332968c0e66cbc57c907b1fa7">&#9670;&#160;</a></span>GetAllIntegerLiterals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research_1_1sat.html#a539d666be21909480bba1626e9c55090">InlinedIntegerLiteralVector</a> &amp; operations_research::sat::IntegerEncoder::GetAllIntegerLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a76cca994f8853c8db660f4e7a21fb8c5" title="Returns the IntegerLiterals that were associated with the given Literal.">GetIntegerLiterals()</a>, but in addition, if the literal was associated to an integer == value, then the returned list will contain both (integer &gt;= value) and (integer &lt;= value). </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00510">510</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a6e03d485f294f266fc5035623d118374" name="a6e03d485f294f266fc5035623d118374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e03d485f294f266fc5035623d118374">&#9670;&#160;</a></span>GetAssociatedEqualityLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiteralIndex operations_research::sat::IntegerEncoder::GetAssociatedEqualityLiteral </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00273">273</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="acb0b1234e31f51f99e14860cd628cde2" name="acb0b1234e31f51f99e14860cd628cde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0b1234e31f51f99e14860cd628cde2">&#9670;&#160;</a></span>GetAssociatedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiteralIndex operations_research::sat::IntegerEncoder::GetAssociatedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td>
          <td class="paramname"><em>i_lit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00488">488</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a435301889907352870b1ba8f2f013a21" name="a435301889907352870b1ba8f2f013a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435301889907352870b1ba8f2f013a21">&#9670;&#160;</a></span>GetFalseLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetFalseLiteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00563">563</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a76cca994f8853c8db660f4e7a21fb8c5" name="a76cca994f8853c8db660f4e7a21fb8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cca994f8853c8db660f4e7a21fb8c5">&#9670;&#160;</a></span>GetIntegerLiterals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceoperations__research_1_1sat.html#a539d666be21909480bba1626e9c55090">InlinedIntegerLiteralVector</a> &amp; operations_research::sat::IntegerEncoder::GetIntegerLiterals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the IntegerLiterals that were associated with the given <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00500">500</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a67429ccec189e8be975f9c1956540ea9" name="a67429ccec189e8be975f9c1956540ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67429ccec189e8be975f9c1956540ea9">&#9670;&#160;</a></span>GetLiteralView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const IntegerVariable operations_research::sat::IntegerEncoder::GetLiteralView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If it exists, returns a [0,1] integer variable which is equal to 1 iff the given literal is true. Returns kNoIntegerVariable if such variable does not exist. Note that one can create one by creating a new IntegerVariable and calling <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a9bf605bfbb224230f6c65067fdd26c34">AssociateToIntegerEqualValue()</a>. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00530">530</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a86897b73c47086f4bc261f9424b47de7" name="a86897b73c47086f4bc261f9424b47de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86897b73c47086f4bc261f9424b47de7">&#9670;&#160;</a></span>GetOrCreateAssociatedLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetOrCreateAssociatedLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td>
          <td class="paramname"><em>i_lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns, after creating it if needed, a Boolean literal such that:</p><ul>
<li>if true, then the <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> is true.</li>
<li>if false, then the negated <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> is true.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>this "canonicalize" the given literal first.</dd></dl>
<p>This add the proper implications with the two "neighbor" literals of this one if they exist. This is the "list encoding" in: Thibaut Feydy, Peter J. Stuckey, "Lazy Clause Generation Reengineered", CP 2009. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001453">Todo:</a></b></dt><dd>(user): on some problem this happens. We should probably make sure that we don't create extra fixed Boolean variable for no reason. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00237">237</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="af0a2aeea649e70334c5b44dca14a5ae2" name="af0a2aeea649e70334c5b44dca14a5ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a2aeea649e70334c5b44dca14a5ae2">&#9670;&#160;</a></span>GetOrCreateLiteralAssociatedToEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetOrCreateLiteralAssociatedToEquality </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for trivial true/false literal to avoid creating variable for no reasons.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001454">Todo:</a></b></dt><dd>(user): this happens on some problem. We should probably make sure that we don't create extra fixed Boolean variable for no reason. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>here we could detect the case before creating the literal. The initial domain didn't contain it, but maybe the one of (&gt;= value) or (&lt;= value) is false?</dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00283">283</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a575c98a8e638de20b5a3a5861263c732" name="a575c98a8e638de20b5a3a5861263c732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575c98a8e638de20b5a3a5861263c732">&#9670;&#160;</a></span>GetTrueLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::IntegerEncoder::GetTrueLiteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the literal always set to true, make it if it does not exist. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00553">553</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a2c35b8f98baecd51741072760efdbefe" name="a2c35b8f98baecd51741072760efdbefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c35b8f98baecd51741072760efdbefe">&#9670;&#160;</a></span>LiteralIsAssociated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerEncoder::LiteralIsAssociated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td>
          <td class="paramname"><em>i_lit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the given integer literal is associated. The second version returns the associated literal or kNoLiteralIndex. Note that none of these function call <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1a4e1df43e180231715e6fde6b4d0a8d">Canonicalize()</a> first for speed, so it is possible that this returns false even though <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a86897b73c47086f4bc261f9424b47de7">GetOrCreateAssociatedLiteral()</a> would not create a new literal. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00481">481</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a9fcdafc23f9a3bd469e4f1fa175c0c81" name="a9fcdafc23f9a3bd469e4f1fa175c0c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcdafc23f9a3bd469e4f1fa175c0c81">&#9670;&#160;</a></span>LiteralOrNegationHasView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::IntegerEncoder::LiteralOrNegationHasView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>lit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable *&#160;</td>
          <td class="paramname"><em>view</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>view_is_direct</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this is true, then a literal can be linearized with an affine expression involving an integer variable. </p>
<p>If a literal has both views, we want to always keep the same representative: the smallest IntegerVariable.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00511">511</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ae8a0bd75e741e84b5062d0e7a527995a" name="ae8a0bd75e741e84b5062d0e7a527995a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a0bd75e741e84b5062d0e7a527995a">&#9670;&#160;</a></span>NewlyFixedIntegerLiterals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; operations_research::sat::IntegerEncoder::NewlyFixedIntegerLiterals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is part of a "hack" to deal with new association involving a fixed literal. Note that these are only allowed at the decision level zero. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00519">519</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aad17dae9d7ebf7bd70f4d3053a890d56" name="aad17dae9d7ebf7bd70f4d3053a890d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad17dae9d7ebf7bd70f4d3053a890d56">&#9670;&#160;</a></span>PartialDomainEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; operations_research::sat::IntegerEncoder::PartialDomainEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1595d32af53b8730a57ed36866707a23">FullDomainEncoding()</a> but only returns the list of value that are currently associated to a literal. In particular this has no guarantee to span the full domain of the given variable (but it might). </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00136">136</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ab8f01ceb93bb7d5fbe05105e557aabcb" name="ab8f01ceb93bb7d5fbe05105e557aabcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f01ceb93bb7d5fbe05105e557aabcb">&#9670;&#160;</a></span>PartialGreaterThanEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::btree_map&lt; IntegerValue, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::IntegerEncoder::PartialGreaterThanEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the set of <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> associated to <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> of the form var &gt;= value. We make a copy, because this can be easily invalidated when calling any function of this class. So it is less efficient but safer. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00568">568</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a2fc6f1787d26f16ce0c8ddece12f9993" name="a2fc6f1787d26f16ce0c8ddece12f9993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc6f1787d26f16ce0c8ddece12f9993">&#9670;&#160;</a></span>RawDomainEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1ValueLiteralPair.html">ValueLiteralPair</a> &gt; operations_research::sat::IntegerEncoder::RawDomainEncoding </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Raw encoding. May be incomplete and is not sorted. Contains all literals, true or false. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00166">166</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a597efd42efcef647f5ee211e658d8598" name="a597efd42efcef647f5ee211e658d8598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597efd42efcef647f5ee211e658d8598">&#9670;&#160;</a></span>SearchForLiteralAtOrBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiteralIndex operations_research::sat::IntegerEncoder::SearchForLiteralAtOrBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue *&#160;</td>
          <td class="paramname"><em>bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a Boolean literal associated with a bound lower than or equal to the one of the given <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>. If the given <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> is true, then the returned literal should be true too. Returns kNoLiteralIndex if no such literal was created.</p>
<p>Ex: if 'i' is (x &gt;= 4) and we already created a literal associated to (x &gt;= 2) but not to (x &gt;= 3), we will return the literal associated with (x &gt;= 2). </p>
<p>We take the element before the <a class="el" href="routing_8cc.html#a070da095a863e1b6c860e29e59e6db1b">upper_bound()</a> which is either the encoding of i if it already exists, or the encoding just before it.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00497">497</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a59abe9efe4246f146066483c1955e602" name="a59abe9efe4246f146066483c1955e602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59abe9efe4246f146066483c1955e602">&#9670;&#160;</a></span>VariableIsFullyEncoded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerEncoder::VariableIsFullyEncoded </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if we know that PartialDomainEncoding(var) span the full domain of var. This is always true if FullyEncodeVariable(var) has been called. </p>
<p>Once fully encoded, the status never changes.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001451">Todo:</a></b></dt><dd>(user): Cache result as long as equality_by_var_[index] is unchanged? It might not be needed since if the variable is not fully encoded, then <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#aad17dae9d7ebf7bd70f4d3053a890d56">PartialDomainEncoding()</a> will filter unreachable values, and so the size check will be false until further value have been encoded. </dd></dl>
<p>This cleans equality_by_var_[index] as a side effect and in particular, sorts it by values.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001452">Todo:</a></b></dt><dd>(user): Comparing the size might be enough, but we want to be always valid even if either (*domains_[var]) or PartialDomainEncoding(var) are not properly synced because the propagation is not finished. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00095">95</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="integer_8h_source.html">integer.h</a></li>
<li>ortools/sat/<a class="el" href="integer_8cc_source.html">integer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
