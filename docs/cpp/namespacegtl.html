<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: gtl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.8</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacegtl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">gtl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegtl_1_1detail" id="r_namespacegtl_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegtl_1_1internal" id="r_namespacegtl_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegtl_1_1stl__util__internal" id="r_namespacegtl_1_1stl__util__internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl_1_1stl__util__internal.html">stl_util_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1BaseDeleter.html">BaseDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1ElementDeleter.html">ElementDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1IntType.html">IntType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1linked__hash__map.html">linked_hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtl_1_1LogLegacy.html">LogLegacy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtl_1_1LogLegacyUpTo100.html">LogLegacyUpTo100</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtl_1_1LogMultiline.html">LogMultiline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtl_1_1LogMultilineUpTo100.html">LogMultilineUpTo100</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1LogMultilineUpToN.html">LogMultilineUpToN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtl_1_1LogShort.html">LogShort</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgtl_1_1LogShortUpTo100.html">LogShortUpTo100</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1LogShortUpToN.html">LogShortUpToN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1ReverseView.html">ReverseView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1small__map.html">small_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1STLElementDeleter.html">STLElementDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1STLValueDeleter.html">STLValueDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1TemplatedElementDeleter.html">TemplatedElementDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1TemplatedValueDeleter.html">TemplatedValueDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgtl_1_1ValueDeleter.html">ValueDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4f663b315f1f56d575e32524a9d06313" id="r_a4f663b315f1f56d575e32524a9d06313"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structgtl_1_1LogShortUpTo100.html">LogShortUpTo100</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a4f663b315f1f56d575e32524a9d06313">LogDefault</a></td></tr>
<tr class="memdesc:a4f663b315f1f56d575e32524a9d06313"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default policy for new code.  <br /></td></tr>
<tr class="separator:a4f663b315f1f56d575e32524a9d06313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae771af59e42d532c50c13eac05ffc725" id="r_ae771af59e42d532c50c13eac05ffc725"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename PolicyT &gt; </td></tr>
<tr class="memitem:ae771af59e42d532c50c13eac05ffc725"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#ae771af59e42d532c50c13eac05ffc725">LogRangeToStream</a> (std::ostream &amp;out, IteratorT <a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, IteratorT <a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>, const PolicyT &amp;policy)</td></tr>
<tr class="separator:ae771af59e42d532c50c13eac05ffc725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829be4587c2fbc742294381e89b71570" id="r_a829be4587c2fbc742294381e89b71570"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename PolicyT &gt; </td></tr>
<tr class="memitem:a829be4587c2fbc742294381e89b71570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtl_1_1detail_1_1RangeLogger.html">detail::RangeLogger</a>&lt; IteratorT, PolicyT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a829be4587c2fbc742294381e89b71570">LogRange</a> (const IteratorT &amp;<a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, const IteratorT &amp;<a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>, const PolicyT &amp;policy)</td></tr>
<tr class="separator:a829be4587c2fbc742294381e89b71570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f025bbd76056e4b95662c1adf0c754" id="r_a56f025bbd76056e4b95662c1adf0c754"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT &gt; </td></tr>
<tr class="memitem:a56f025bbd76056e4b95662c1adf0c754"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtl_1_1detail_1_1RangeLogger.html">detail::RangeLogger</a>&lt; IteratorT, <a class="el" href="namespacegtl.html#a4f663b315f1f56d575e32524a9d06313">LogDefault</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a56f025bbd76056e4b95662c1adf0c754">LogRange</a> (const IteratorT &amp;<a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, const IteratorT &amp;<a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>)</td></tr>
<tr class="separator:a56f025bbd76056e4b95662c1adf0c754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252ef610941828aa417152c3230ca670" id="r_a252ef610941828aa417152c3230ca670"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename PolicyT &gt; </td></tr>
<tr class="memitem:a252ef610941828aa417152c3230ca670"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a252ef610941828aa417152c3230ca670">LogContainer</a> (const ContainerT &amp;container, const PolicyT &amp;policy) -&gt; decltype(<a class="el" href="namespacegtl.html#a829be4587c2fbc742294381e89b71570">gtl::LogRange</a>(container.begin(), container.end(), policy))</td></tr>
<tr class="separator:a252ef610941828aa417152c3230ca670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef4d25cc294b5d4bec3549469b560e2" id="r_a6ef4d25cc294b5d4bec3549469b560e2"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT &gt; </td></tr>
<tr class="memitem:a6ef4d25cc294b5d4bec3549469b560e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a6ef4d25cc294b5d4bec3549469b560e2">LogContainer</a> (const ContainerT &amp;container) -&gt; decltype(gtl::LogContainer(container, <a class="el" href="namespacegtl.html#a4f663b315f1f56d575e32524a9d06313">LogDefault</a>()))</td></tr>
<tr class="separator:a6ef4d25cc294b5d4bec3549469b560e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b33b6e58e54dbc05433bc83268ae138" id="r_a7b33b6e58e54dbc05433bc83268ae138"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a7b33b6e58e54dbc05433bc83268ae138"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtl_1_1detail_1_1EnumLogger.html">detail::EnumLogger</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a7b33b6e58e54dbc05433bc83268ae138">LogEnum</a> (E e)</td></tr>
<tr class="separator:a7b33b6e58e54dbc05433bc83268ae138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf94e6a7dc7d9ec54a01de70d6ef91ca" id="r_adf94e6a7dc7d9ec54a01de70d6ef91ca"><td class="memTemplParams" colspan="2">template&lt;typename IntTypeName , typename ValueType &gt; </td></tr>
<tr class="memitem:adf94e6a7dc7d9ec54a01de70d6ef91ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#adf94e6a7dc7d9ec54a01de70d6ef91ca">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classgtl_1_1IntType.html">IntType</a>&lt; IntTypeName, ValueType &gt; arg)</td></tr>
<tr class="separator:adf94e6a7dc7d9ec54a01de70d6ef91ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005a7b730220139729dd3bc0ac7a3e37" id="r_a005a7b730220139729dd3bc0ac7a3e37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a005a7b730220139729dd3bc0ac7a3e37">INT_TYPE_ARITHMETIC_OP</a> (+)</td></tr>
<tr class="separator:a005a7b730220139729dd3bc0ac7a3e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a6ff92216ce2b6611fb8269e1eb471" id="r_a51a6ff92216ce2b6611fb8269e1eb471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a51a6ff92216ce2b6611fb8269e1eb471">INT_TYPE_ARITHMETIC_OP</a> (-)</td></tr>
<tr class="separator:a51a6ff92216ce2b6611fb8269e1eb471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af495b683b5004fc480042b33a5891463" id="r_af495b683b5004fc480042b33a5891463"><td class="memItemLeft" align="right" valign="top">INT_TYPE_ARITHMETIC_OP *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#af495b683b5004fc480042b33a5891463">INT_TYPE_ARITHMETIC_OP</a> (/);INT_TYPE_ARITHMETIC_OP(&lt;&lt;</td></tr>
<tr class="separator:af495b683b5004fc480042b33a5891463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855676c9b0426bf2cd9d1f207546830b" id="r_a855676c9b0426bf2cd9d1f207546830b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a855676c9b0426bf2cd9d1f207546830b">INT_TYPE_ARITHMETIC_OP</a> (&gt; &gt;)</td></tr>
<tr class="separator:a855676c9b0426bf2cd9d1f207546830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd7d17d32cf3586b8bf3fd43d52078" id="r_a25bd7d17d32cf3586b8bf3fd43d52078"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a25bd7d17d32cf3586b8bf3fd43d52078">INT_TYPE_ARITHMETIC_OP</a> (%)</td></tr>
<tr class="separator:a25bd7d17d32cf3586b8bf3fd43d52078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ac14d2b328e095ee63c5a40f7f6db" id="r_ab79ac14d2b328e095ee63c5a40f7f6db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#ab79ac14d2b328e095ee63c5a40f7f6db">INT_TYPE_COMPARISON_OP</a> (==)</td></tr>
<tr class="separator:ab79ac14d2b328e095ee63c5a40f7f6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2acf50f5c6a7668e5a2eedb2b3b9b4" id="r_a7f2acf50f5c6a7668e5a2eedb2b3b9b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a7f2acf50f5c6a7668e5a2eedb2b3b9b4">INT_TYPE_COMPARISON_OP</a> (!=)</td></tr>
<tr class="separator:a7f2acf50f5c6a7668e5a2eedb2b3b9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b9bce22ee2b4ddcaefd9c3a176d753" id="r_a75b9bce22ee2b4ddcaefd9c3a176d753"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a75b9bce22ee2b4ddcaefd9c3a176d753">INT_TYPE_COMPARISON_OP</a> (&lt;=)</td></tr>
<tr class="separator:a75b9bce22ee2b4ddcaefd9c3a176d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbc025b7b70df26625e6b0ca1ef1db9" id="r_a8fbc025b7b70df26625e6b0ca1ef1db9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a8fbc025b7b70df26625e6b0ca1ef1db9">INT_TYPE_COMPARISON_OP</a> (&gt;=)</td></tr>
<tr class="separator:a8fbc025b7b70df26625e6b0ca1ef1db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d76e4ed7c0294917917c69ef7313cf" id="r_a45d76e4ed7c0294917917c69ef7313cf"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a45d76e4ed7c0294917917c69ef7313cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgtl_1_1ReverseView.html">ReverseView</a>&lt; Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a45d76e4ed7c0294917917c69ef7313cf">reversed_view</a> (const Container &amp;c)</td></tr>
<tr class="separator:a45d76e4ed7c0294917917c69ef7313cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795ebdb62731938c8c31b221f0f074b4" id="r_a795ebdb62731938c8c31b221f0f074b4"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a795ebdb62731938c8c31b221f0f074b4"><td class="memTemplItemLeft" align="right" valign="top">const Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a795ebdb62731938c8c31b221f0f074b4">FindWithDefault</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a795ebdb62731938c8c31b221f0f074b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85658bbe1373f2a6acda2663582dd33f" id="r_a85658bbe1373f2a6acda2663582dd33f"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a85658bbe1373f2a6acda2663582dd33f"><td class="memTemplItemLeft" align="right" valign="top">const Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a85658bbe1373f2a6acda2663582dd33f">FindWithDefault</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="separator:a85658bbe1373f2a6acda2663582dd33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f74dcd1ec00022462cbf110edaafc6d" id="r_a9f74dcd1ec00022462cbf110edaafc6d"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a9f74dcd1ec00022462cbf110edaafc6d"><td class="memTemplItemLeft" align="right" valign="top">const Collection::value_type::second_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a9f74dcd1ec00022462cbf110edaafc6d">FindOrNull</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="separator:a9f74dcd1ec00022462cbf110edaafc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc85942861c64c1fe50253a648ed541" id="r_addc85942861c64c1fe50253a648ed541"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:addc85942861c64c1fe50253a648ed541"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type::second_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#addc85942861c64c1fe50253a648ed541">FindOrNull</a> (Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="separator:addc85942861c64c1fe50253a648ed541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ae48a53bb9d0ce3024501a7750260b" id="r_a10ae48a53bb9d0ce3024501a7750260b"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a10ae48a53bb9d0ce3024501a7750260b"><td class="memTemplItemLeft" align="right" valign="top">const Collection::value_type::second_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a10ae48a53bb9d0ce3024501a7750260b">FindPtrOrNull</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="separator:a10ae48a53bb9d0ce3024501a7750260b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b9600337fe4ae3077d7646fca2970f" id="r_a28b9600337fe4ae3077d7646fca2970f"><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key , class Value &gt; </td></tr>
<tr class="memitem:a28b9600337fe4ae3077d7646fca2970f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a28b9600337fe4ae3077d7646fca2970f">InsertOrUpdate</a> (Collection *const collection, const Key &amp;key, const Value &amp;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a28b9600337fe4ae3077d7646fca2970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea1e2b26e83387a5eea8d83d9406d34" id="r_a3ea1e2b26e83387a5eea8d83d9406d34"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a3ea1e2b26e83387a5eea8d83d9406d34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a3ea1e2b26e83387a5eea8d83d9406d34">InsertIfNotPresent</a> (Collection *const collection, const typename Collection::value_type &amp;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a3ea1e2b26e83387a5eea8d83d9406d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448c7622e34b60a1010a4c684292bc7f" id="r_a448c7622e34b60a1010a4c684292bc7f"><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key , class Value &gt; </td></tr>
<tr class="memitem:a448c7622e34b60a1010a4c684292bc7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a448c7622e34b60a1010a4c684292bc7f">InsertIfNotPresent</a> (Collection *const collection, const Key &amp;key, const Value &amp;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a448c7622e34b60a1010a4c684292bc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dafdccc2a76e528208724b3cedab6ab" id="r_a2dafdccc2a76e528208724b3cedab6ab"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a2dafdccc2a76e528208724b3cedab6ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a2dafdccc2a76e528208724b3cedab6ab">InsertOrDieNoPrint</a> (Collection *const collection, const typename Collection::value_type &amp;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a2dafdccc2a76e528208724b3cedab6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0d4dea208db4deaa285c06b78d8181" id="r_a5c0d4dea208db4deaa285c06b78d8181"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a5c0d4dea208db4deaa285c06b78d8181"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a5c0d4dea208db4deaa285c06b78d8181">InsertOrDie</a> (Collection *const collection, const typename Collection::value_type &amp;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a5c0d4dea208db4deaa285c06b78d8181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52960c638efa5b6c96d69f2a40d371e8" id="r_a52960c638efa5b6c96d69f2a40d371e8"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a52960c638efa5b6c96d69f2a40d371e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a52960c638efa5b6c96d69f2a40d371e8">InsertOrDie</a> (Collection *const collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;data)</td></tr>
<tr class="separator:a52960c638efa5b6c96d69f2a40d371e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea75330fcfcabf5467939b997a97e739" id="r_aea75330fcfcabf5467939b997a97e739"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:aea75330fcfcabf5467939b997a97e739"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#aea75330fcfcabf5467939b997a97e739">InsertKeyOrDie</a> (Collection *const collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="separator:aea75330fcfcabf5467939b997a97e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4238d2e35cf819a8e83d60d331ea64" id="r_a6a4238d2e35cf819a8e83d60d331ea64"><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key , class Value &gt; </td></tr>
<tr class="memitem:a6a4238d2e35cf819a8e83d60d331ea64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a6a4238d2e35cf819a8e83d60d331ea64">FindCopy</a> (const Collection &amp;collection, const Key &amp;key, Value *const <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a6a4238d2e35cf819a8e83d60d331ea64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae28e97bd1fa93cb0032642550da7455" id="r_aae28e97bd1fa93cb0032642550da7455"><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key &gt; </td></tr>
<tr class="memitem:aae28e97bd1fa93cb0032642550da7455"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#aae28e97bd1fa93cb0032642550da7455">ContainsKey</a> (const Collection &amp;collection, const Key &amp;key)</td></tr>
<tr class="separator:aae28e97bd1fa93cb0032642550da7455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f41ac11336b94768fdd41594153d59" id="r_a73f41ac11336b94768fdd41594153d59"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a73f41ac11336b94768fdd41594153d59"><td class="memTemplItemLeft" align="right" valign="top">const Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a73f41ac11336b94768fdd41594153d59">FindOrDie</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="separator:a73f41ac11336b94768fdd41594153d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9093d3af795feb9332cea022c20550f8" id="r_a9093d3af795feb9332cea022c20550f8"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a9093d3af795feb9332cea022c20550f8"><td class="memTemplItemLeft" align="right" valign="top">const Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a9093d3af795feb9332cea022c20550f8">FindOrDieNoPrint</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="memdesc:a9093d3af795feb9332cea022c20550f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as FindOrDie above, but doesn't log the key on failure.  <br /></td></tr>
<tr class="separator:a9093d3af795feb9332cea022c20550f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6864289d1f3ce3d6437e6b8a70314e" id="r_a8c6864289d1f3ce3d6437e6b8a70314e"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a8c6864289d1f3ce3d6437e6b8a70314e"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a8c6864289d1f3ce3d6437e6b8a70314e">FindOrDieNoPrint</a> (Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr class="memdesc:a8c6864289d1f3ce3d6437e6b8a70314e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but returns a non-const reference.  <br /></td></tr>
<tr class="separator:a8c6864289d1f3ce3d6437e6b8a70314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523b266127b26ec3817cae4c5f41c391" id="r_a523b266127b26ec3817cae4c5f41c391"><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr class="memitem:a523b266127b26ec3817cae4c5f41c391"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a523b266127b26ec3817cae4c5f41c391">LookupOrInsert</a> (Collection *const collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a523b266127b26ec3817cae4c5f41c391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288a1dc92da5d3ad62d4bc4cec9e8b1d" id="r_a288a1dc92da5d3ad62d4bc4cec9e8b1d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LessFunc &gt; </td></tr>
<tr class="memitem:a288a1dc92da5d3ad62d4bc4cec9e8b1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a288a1dc92da5d3ad62d4bc4cec9e8b1d">STLSortAndRemoveDuplicates</a> (T *v, const LessFunc &amp;less_func)</td></tr>
<tr class="separator:a288a1dc92da5d3ad62d4bc4cec9e8b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219f8706705d21297348360e7b014d97" id="r_a219f8706705d21297348360e7b014d97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a219f8706705d21297348360e7b014d97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a219f8706705d21297348360e7b014d97">STLSortAndRemoveDuplicates</a> (T *v)</td></tr>
<tr class="separator:a219f8706705d21297348360e7b014d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644fbff1e423c6f7e21e31b0c5942cc1" id="r_a644fbff1e423c6f7e21e31b0c5942cc1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LessFunc &gt; </td></tr>
<tr class="memitem:a644fbff1e423c6f7e21e31b0c5942cc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a644fbff1e423c6f7e21e31b0c5942cc1">STLStableSortAndRemoveDuplicates</a> (T *v, const LessFunc &amp;less_func)</td></tr>
<tr class="separator:a644fbff1e423c6f7e21e31b0c5942cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7ebcfb97acea44aeba8518597b7572" id="r_a1a7ebcfb97acea44aeba8518597b7572"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a7ebcfb97acea44aeba8518597b7572"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a1a7ebcfb97acea44aeba8518597b7572">STLStableSortAndRemoveDuplicates</a> (T *v)</td></tr>
<tr class="separator:a1a7ebcfb97acea44aeba8518597b7572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82eb98ee939aaa7b64a85fa63453689e" id="r_a82eb98ee939aaa7b64a85fa63453689e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a82eb98ee939aaa7b64a85fa63453689e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a82eb98ee939aaa7b64a85fa63453689e">STLEraseAllFromSequence</a> (T *v, const E &amp;e)</td></tr>
<tr class="separator:a82eb98ee939aaa7b64a85fa63453689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5262a5dd67f75add06e26f34e0673db2" id="r_a5262a5dd67f75add06e26f34e0673db2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename E &gt; </td></tr>
<tr class="memitem:a5262a5dd67f75add06e26f34e0673db2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a5262a5dd67f75add06e26f34e0673db2">STLEraseAllFromSequence</a> (std::list&lt; T, A &gt; *c, const E &amp;e)</td></tr>
<tr class="separator:a5262a5dd67f75add06e26f34e0673db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911c73c6bb68b07bb24dac74c219deeb" id="r_a911c73c6bb68b07bb24dac74c219deeb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename E &gt; </td></tr>
<tr class="memitem:a911c73c6bb68b07bb24dac74c219deeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a911c73c6bb68b07bb24dac74c219deeb">STLEraseAllFromSequence</a> (std::forward_list&lt; T, A &gt; *c, const E &amp;e)</td></tr>
<tr class="separator:a911c73c6bb68b07bb24dac74c219deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afa1e83cd6407fa4b77d49b8c136806" id="r_a4afa1e83cd6407fa4b77d49b8c136806"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a4afa1e83cd6407fa4b77d49b8c136806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a4afa1e83cd6407fa4b77d49b8c136806">STLEraseAllFromSequenceIf</a> (T *v, P pred)</td></tr>
<tr class="memdesc:a4afa1e83cd6407fa4b77d49b8c136806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove each element e in v satisfying pred(e).  <br /></td></tr>
<tr class="separator:a4afa1e83cd6407fa4b77d49b8c136806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232cdd3e66048c74ef1d5ec3cb2f86d" id="r_a0232cdd3e66048c74ef1d5ec3cb2f86d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename P &gt; </td></tr>
<tr class="memitem:a0232cdd3e66048c74ef1d5ec3cb2f86d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a0232cdd3e66048c74ef1d5ec3cb2f86d">STLEraseAllFromSequenceIf</a> (std::list&lt; T, A &gt; *c, P pred)</td></tr>
<tr class="separator:a0232cdd3e66048c74ef1d5ec3cb2f86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac241daf9051a05764c915d1c17e199a9" id="r_ac241daf9051a05764c915d1c17e199a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename P &gt; </td></tr>
<tr class="memitem:ac241daf9051a05764c915d1c17e199a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#ac241daf9051a05764c915d1c17e199a9">STLEraseAllFromSequenceIf</a> (std::forward_list&lt; T, A &gt; *c, P pred)</td></tr>
<tr class="separator:ac241daf9051a05764c915d1c17e199a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a0e7b0e74024284adc849a4499940f" id="r_a92a0e7b0e74024284adc849a4499940f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92a0e7b0e74024284adc849a4499940f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a92a0e7b0e74024284adc849a4499940f">STLClearObject</a> (T *obj)</td></tr>
<tr class="separator:a92a0e7b0e74024284adc849a4499940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e1fdee4ca438235865f1fed899bf7" id="r_af79e1fdee4ca438235865f1fed899bf7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:af79e1fdee4ca438235865f1fed899bf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#af79e1fdee4ca438235865f1fed899bf7">STLClearObject</a> (std::deque&lt; T, A &gt; *obj)</td></tr>
<tr class="memdesc:af79e1fdee4ca438235865f1fed899bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">STLClearObject overload for deque, which is missing reserve().  <br /></td></tr>
<tr class="separator:af79e1fdee4ca438235865f1fed899bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e5bdb50d313df878b8557e6aca45be" id="r_a38e5bdb50d313df878b8557e6aca45be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38e5bdb50d313df878b8557e6aca45be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a38e5bdb50d313df878b8557e6aca45be">STLClearIfBig</a> (T *obj, size_t limit=1&lt;&lt; 20)</td></tr>
<tr class="separator:a38e5bdb50d313df878b8557e6aca45be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9b8c786639c2a8ed09d7906eb4a3c9" id="r_a1f9b8c786639c2a8ed09d7906eb4a3c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a1f9b8c786639c2a8ed09d7906eb4a3c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a1f9b8c786639c2a8ed09d7906eb4a3c9">STLClearIfBig</a> (std::deque&lt; T, A &gt; *obj, size_t limit=1&lt;&lt; 20)</td></tr>
<tr class="memdesc:a1f9b8c786639c2a8ed09d7906eb4a3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">STLClearIfBig overload for deque, which is missing capacity().  <br /></td></tr>
<tr class="separator:a1f9b8c786639c2a8ed09d7906eb4a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b11464d5e8c5f0bb36a15d53abb8cc7" id="r_a8b11464d5e8c5f0bb36a15d53abb8cc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b11464d5e8c5f0bb36a15d53abb8cc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a8b11464d5e8c5f0bb36a15d53abb8cc7">STLClearHashIfBig</a> (T *obj, size_t limit)</td></tr>
<tr class="separator:a8b11464d5e8c5f0bb36a15d53abb8cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce1c176bd7c77b4d20245cecf80d0b2" id="r_afce1c176bd7c77b4d20245cecf80d0b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#afce1c176bd7c77b4d20245cecf80d0b2">STLStringReserveIfNeeded</a> (std::string *s, size_t min_capacity)</td></tr>
<tr class="separator:afce1c176bd7c77b4d20245cecf80d0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a9fdc8d80f428bfb1d6785df0f2049" id="r_a68a9fdc8d80f428bfb1d6785df0f2049"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:a68a9fdc8d80f428bfb1d6785df0f2049"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a68a9fdc8d80f428bfb1d6785df0f2049">STLStringResizeUninitialized</a> (std::basic_string&lt; T, Traits, Alloc &gt; *s, size_t new_size)</td></tr>
<tr class="separator:a68a9fdc8d80f428bfb1d6785df0f2049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1121a94564be31fe7a06032eaa591f" id="r_a5e1121a94564be31fe7a06032eaa591f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:a5e1121a94564be31fe7a06032eaa591f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a5e1121a94564be31fe7a06032eaa591f">STLStringSupportsNontrashingResize</a> (const std::basic_string&lt; T, Traits, Alloc &gt; &amp;s)</td></tr>
<tr class="separator:a5e1121a94564be31fe7a06032eaa591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfc7ed347f74887973daddd014047ec" id="r_a9dfc7ed347f74887973daddd014047ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a9dfc7ed347f74887973daddd014047ec">STLAssignToString</a> (std::string *str, const char *ptr, size_t n)</td></tr>
<tr class="separator:a9dfc7ed347f74887973daddd014047ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33bfe8a337682344d8d4dc06d0fc3ed" id="r_aa33bfe8a337682344d8d4dc06d0fc3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#aa33bfe8a337682344d8d4dc06d0fc3ed">STLAppendToString</a> (std::string *str, const char *ptr, size_t n)</td></tr>
<tr class="separator:aa33bfe8a337682344d8d4dc06d0fc3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85c1d939763eb4f7afba53cf0da49ba" id="r_ab85c1d939763eb4f7afba53cf0da49ba"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#ab85c1d939763eb4f7afba53cf0da49ba">string_as_array</a> (std::string *str)</td></tr>
<tr class="separator:ab85c1d939763eb4f7afba53cf0da49ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776bb5aac43dbc858cca094af43084e2" id="r_a776bb5aac43dbc858cca094af43084e2"><td class="memTemplParams" colspan="2">template&lt;typename HashSet &gt; </td></tr>
<tr class="memitem:a776bb5aac43dbc858cca094af43084e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a776bb5aac43dbc858cca094af43084e2">HashSetEquality</a> (const HashSet &amp;set_a, const HashSet &amp;set_b)</td></tr>
<tr class="separator:a776bb5aac43dbc858cca094af43084e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85eab207548c101c17223579824f7cb" id="r_af85eab207548c101c17223579824f7cb"><td class="memTemplParams" colspan="2">template&lt;typename HashMap , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:af85eab207548c101c17223579824f7cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#af85eab207548c101c17223579824f7cb">HashMapEquality</a> (const HashMap &amp;map_a, const HashMap &amp;map_b, BinaryPredicate mapped_type_equal)</td></tr>
<tr class="separator:af85eab207548c101c17223579824f7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad342a513d3cc1495d581ffb8accf7ee" id="r_aad342a513d3cc1495d581ffb8accf7ee"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename C , typename A &gt; </td></tr>
<tr class="memitem:aad342a513d3cc1495d581ffb8accf7ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#aad342a513d3cc1495d581ffb8accf7ee">HashMapEquality</a> (const std::map&lt; K, V, C, A &gt; &amp;map_a, const std::map&lt; K, V, C, A &gt; &amp;map_b)</td></tr>
<tr class="separator:aad342a513d3cc1495d581ffb8accf7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868cd1a78a83d74cfd437fbbc922b39" id="r_a3868cd1a78a83d74cfd437fbbc922b39"><td class="memTemplParams" colspan="2">template&lt;typename HashMap &gt; </td></tr>
<tr class="memitem:a3868cd1a78a83d74cfd437fbbc922b39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a3868cd1a78a83d74cfd437fbbc922b39">HashMapEquality</a> (const HashMap &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const HashMap &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a3868cd1a78a83d74cfd437fbbc922b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a7129153c63a150516ea2f617b767b" id="r_a88a7129153c63a150516ea2f617b767b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a88a7129153c63a150516ea2f617b767b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a88a7129153c63a150516ea2f617b767b">STLDeleteContainerPointers</a> (ForwardIterator <a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, ForwardIterator <a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>)</td></tr>
<tr class="separator:a88a7129153c63a150516ea2f617b767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cdbc2f98979cfa54442634df0757e6" id="r_a00cdbc2f98979cfa54442634df0757e6"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a00cdbc2f98979cfa54442634df0757e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a00cdbc2f98979cfa54442634df0757e6">STLDeleteContainerPairPointers</a> (ForwardIterator <a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, ForwardIterator <a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>)</td></tr>
<tr class="separator:a00cdbc2f98979cfa54442634df0757e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000377a1edd9573424f915486d7a34cd" id="r_a000377a1edd9573424f915486d7a34cd"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a000377a1edd9573424f915486d7a34cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a000377a1edd9573424f915486d7a34cd">STLDeleteContainerPairFirstPointers</a> (ForwardIterator <a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, ForwardIterator <a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>)</td></tr>
<tr class="separator:a000377a1edd9573424f915486d7a34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175be393c366b55cd2e438d5b318d4f" id="r_a5175be393c366b55cd2e438d5b318d4f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a5175be393c366b55cd2e438d5b318d4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a5175be393c366b55cd2e438d5b318d4f">STLDeleteContainerPairSecondPointers</a> (ForwardIterator <a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, ForwardIterator <a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>)</td></tr>
<tr class="separator:a5175be393c366b55cd2e438d5b318d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee3db0c4acaa0f277a0d7006f5ad1e6" id="r_a4ee3db0c4acaa0f277a0d7006f5ad1e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ee3db0c4acaa0f277a0d7006f5ad1e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a4ee3db0c4acaa0f277a0d7006f5ad1e6">STLDeleteElements</a> (T *container)</td></tr>
<tr class="separator:a4ee3db0c4acaa0f277a0d7006f5ad1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115efd2ec0ec9c7ced30f4daadd89ab7" id="r_a115efd2ec0ec9c7ced30f4daadd89ab7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a115efd2ec0ec9c7ced30f4daadd89ab7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a115efd2ec0ec9c7ced30f4daadd89ab7">STLDeleteValues</a> (T *v)</td></tr>
<tr class="separator:a115efd2ec0ec9c7ced30f4daadd89ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5297b48a390e2b2a1420bdba2b25fd" id="r_a2c5297b48a390e2b2a1420bdba2b25fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c5297b48a390e2b2a1420bdba2b25fd"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a2c5297b48a390e2b2a1420bdba2b25fd">release_ptr</a> (T **ptr)</td></tr>
<tr class="separator:a2c5297b48a390e2b2a1420bdba2b25fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e6f9ee67c1545cc1da3d0b9a2ba0fd" id="r_a68e6f9ee67c1545cc1da3d0b9a2ba0fd"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </td></tr>
<tr class="memitem:a68e6f9ee67c1545cc1da3d0b9a2ba0fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a68e6f9ee67c1545cc1da3d0b9a2ba0fd">STLSetDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out, Compare compare)</td></tr>
<tr class="separator:a68e6f9ee67c1545cc1da3d0b9a2ba0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d659ec14f4c5b2b847927734d6a4d6" id="r_a34d659ec14f4c5b2b847927734d6a4d6"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out &gt; </td></tr>
<tr class="memitem:a34d659ec14f4c5b2b847927734d6a4d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a34d659ec14f4c5b2b847927734d6a4d6">STLSetDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out)</td></tr>
<tr class="separator:a34d659ec14f4c5b2b847927734d6a4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab749b0077b0a46f1a66b0792d9a9392b" id="r_ab749b0077b0a46f1a66b0792d9a9392b"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:ab749b0077b0a46f1a66b0792d9a9392b"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#ab749b0077b0a46f1a66b0792d9a9392b">STLSetDifferenceAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare compare)</td></tr>
<tr class="memdesc:ab749b0077b0a46f1a66b0792d9a9392b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit comparator, explicit return type.  <br /></td></tr>
<tr class="separator:ab749b0077b0a46f1a66b0792d9a9392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5a29f3a64de210350ed8d98fab4df" id="r_a82f5a29f3a64de210350ed8d98fab4df"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a82f5a29f3a64de210350ed8d98fab4df"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a82f5a29f3a64de210350ed8d98fab4df">STLSetDifferenceAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="memdesc:a82f5a29f3a64de210350ed8d98fab4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit comparator, explicit return type.  <br /></td></tr>
<tr class="separator:a82f5a29f3a64de210350ed8d98fab4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e7314a966b2d0cf2e2b352b9365f6e" id="r_a09e7314a966b2d0cf2e2b352b9365f6e"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a09e7314a966b2d0cf2e2b352b9365f6e"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a09e7314a966b2d0cf2e2b352b9365f6e">STLSetDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare compare)</td></tr>
<tr class="memdesc:a09e7314a966b2d0cf2e2b352b9365f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit comparator, implicit return type.  <br /></td></tr>
<tr class="separator:a09e7314a966b2d0cf2e2b352b9365f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4c967916645e5517ae33bbc2758086" id="r_a8a4c967916645e5517ae33bbc2758086"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a8a4c967916645e5517ae33bbc2758086"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a8a4c967916645e5517ae33bbc2758086">STLSetDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="memdesc:a8a4c967916645e5517ae33bbc2758086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit comparator, implicit return type.  <br /></td></tr>
<tr class="separator:a8a4c967916645e5517ae33bbc2758086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3c94ab9628465d56d8be3d89e7e840" id="r_a8e3c94ab9628465d56d8be3d89e7e840"><td class="memTemplParams" colspan="2">template&lt;typename In1 &gt; </td></tr>
<tr class="memitem:a8e3c94ab9628465d56d8be3d89e7e840"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a8e3c94ab9628465d56d8be3d89e7e840">STLSetDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a8e3c94ab9628465d56d8be3d89e7e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd9f986b9af62c1844969ee8a9e008d" id="r_a2dd9f986b9af62c1844969ee8a9e008d"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </td></tr>
<tr class="memitem:a2dd9f986b9af62c1844969ee8a9e008d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a2dd9f986b9af62c1844969ee8a9e008d">STLSetUnion</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out, Compare compare)</td></tr>
<tr class="separator:a2dd9f986b9af62c1844969ee8a9e008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31dd30ff87bbd1625e34c9ed46b427" id="r_a6b31dd30ff87bbd1625e34c9ed46b427"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out &gt; </td></tr>
<tr class="memitem:a6b31dd30ff87bbd1625e34c9ed46b427"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a6b31dd30ff87bbd1625e34c9ed46b427">STLSetUnion</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out)</td></tr>
<tr class="separator:a6b31dd30ff87bbd1625e34c9ed46b427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e72b8b095b2e7dc9543f8ea6406756" id="r_a79e72b8b095b2e7dc9543f8ea6406756"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a79e72b8b095b2e7dc9543f8ea6406756"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a79e72b8b095b2e7dc9543f8ea6406756">STLSetUnionAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare compare)</td></tr>
<tr class="separator:a79e72b8b095b2e7dc9543f8ea6406756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98438211ff98a199a7256eb55c32e75e" id="r_a98438211ff98a199a7256eb55c32e75e"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a98438211ff98a199a7256eb55c32e75e"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a98438211ff98a199a7256eb55c32e75e">STLSetUnionAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a98438211ff98a199a7256eb55c32e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e76d0d1333e3f7729ffb523e1c53b81" id="r_a3e76d0d1333e3f7729ffb523e1c53b81"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a3e76d0d1333e3f7729ffb523e1c53b81"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a3e76d0d1333e3f7729ffb523e1c53b81">STLSetUnion</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare compare)</td></tr>
<tr class="separator:a3e76d0d1333e3f7729ffb523e1c53b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336e2142912eb8d3188b940de10e25a6" id="r_a336e2142912eb8d3188b940de10e25a6"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a336e2142912eb8d3188b940de10e25a6"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a336e2142912eb8d3188b940de10e25a6">STLSetUnion</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a336e2142912eb8d3188b940de10e25a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744d87cbc72fdcd1d7195f445513b3c2" id="r_a744d87cbc72fdcd1d7195f445513b3c2"><td class="memTemplParams" colspan="2">template&lt;typename In1 &gt; </td></tr>
<tr class="memitem:a744d87cbc72fdcd1d7195f445513b3c2"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a744d87cbc72fdcd1d7195f445513b3c2">STLSetUnion</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a744d87cbc72fdcd1d7195f445513b3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da478efe824239819e7b1278a7f6f5f" id="r_a8da478efe824239819e7b1278a7f6f5f"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </td></tr>
<tr class="memitem:a8da478efe824239819e7b1278a7f6f5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a8da478efe824239819e7b1278a7f6f5f">STLSetSymmetricDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out, Compare compare)</td></tr>
<tr class="separator:a8da478efe824239819e7b1278a7f6f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2b682785bf02b8427fa17a2ec824a7" id="r_a8e2b682785bf02b8427fa17a2ec824a7"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out &gt; </td></tr>
<tr class="memitem:a8e2b682785bf02b8427fa17a2ec824a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a8e2b682785bf02b8427fa17a2ec824a7">STLSetSymmetricDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out)</td></tr>
<tr class="separator:a8e2b682785bf02b8427fa17a2ec824a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8c075da0fea613720ee035e0ae914e" id="r_a7b8c075da0fea613720ee035e0ae914e"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a7b8c075da0fea613720ee035e0ae914e"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a7b8c075da0fea613720ee035e0ae914e">STLSetSymmetricDifferenceAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare comp)</td></tr>
<tr class="separator:a7b8c075da0fea613720ee035e0ae914e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9836946f5a578dfc175c38b0159b9d8" id="r_ab9836946f5a578dfc175c38b0159b9d8"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:ab9836946f5a578dfc175c38b0159b9d8"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#ab9836946f5a578dfc175c38b0159b9d8">STLSetSymmetricDifferenceAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:ab9836946f5a578dfc175c38b0159b9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7875a76c06f5c36d3687eed147df997d" id="r_a7875a76c06f5c36d3687eed147df997d"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a7875a76c06f5c36d3687eed147df997d"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a7875a76c06f5c36d3687eed147df997d">STLSetSymmetricDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare comp)</td></tr>
<tr class="separator:a7875a76c06f5c36d3687eed147df997d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72531dab8ec5c4dae1f6093a72c3717f" id="r_a72531dab8ec5c4dae1f6093a72c3717f"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a72531dab8ec5c4dae1f6093a72c3717f"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a72531dab8ec5c4dae1f6093a72c3717f">STLSetSymmetricDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a72531dab8ec5c4dae1f6093a72c3717f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae914498ef2a2c98cff5fbd7c16e61b" id="r_aeae914498ef2a2c98cff5fbd7c16e61b"><td class="memTemplParams" colspan="2">template&lt;typename In1 &gt; </td></tr>
<tr class="memitem:aeae914498ef2a2c98cff5fbd7c16e61b"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#aeae914498ef2a2c98cff5fbd7c16e61b">STLSetSymmetricDifference</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:aeae914498ef2a2c98cff5fbd7c16e61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee59124b5b3d1e4feea4fc18ceaad6a9" id="r_aee59124b5b3d1e4feea4fc18ceaad6a9"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </td></tr>
<tr class="memitem:aee59124b5b3d1e4feea4fc18ceaad6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#aee59124b5b3d1e4feea4fc18ceaad6a9">STLSetIntersection</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out, Compare compare)</td></tr>
<tr class="separator:aee59124b5b3d1e4feea4fc18ceaad6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2e3c4f3f61577f78ca4b7fa7d159ce" id="r_aac2e3c4f3f61577f78ca4b7fa7d159ce"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Out &gt; </td></tr>
<tr class="memitem:aac2e3c4f3f61577f78ca4b7fa7d159ce"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#aac2e3c4f3f61577f78ca4b7fa7d159ce">STLSetIntersection</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Out *out)</td></tr>
<tr class="separator:aac2e3c4f3f61577f78ca4b7fa7d159ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27406749fc6b129b31ac45eb056ea410" id="r_a27406749fc6b129b31ac45eb056ea410"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a27406749fc6b129b31ac45eb056ea410"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a27406749fc6b129b31ac45eb056ea410">STLSetIntersectionAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare compare)</td></tr>
<tr class="separator:a27406749fc6b129b31ac45eb056ea410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164fbb88e843abba3619fbc09431df88" id="r_a164fbb88e843abba3619fbc09431df88"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a164fbb88e843abba3619fbc09431df88"><td class="memTemplItemLeft" align="right" valign="top">Out&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a164fbb88e843abba3619fbc09431df88">STLSetIntersectionAs</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a164fbb88e843abba3619fbc09431df88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3e336e6a239ebe3c92b75a632313e" id="r_a13b3e336e6a239ebe3c92b75a632313e"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a13b3e336e6a239ebe3c92b75a632313e"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a13b3e336e6a239ebe3c92b75a632313e">STLSetIntersection</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare compare)</td></tr>
<tr class="separator:a13b3e336e6a239ebe3c92b75a632313e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b24da0ff8191b893296df91f04325a" id="r_a53b24da0ff8191b893296df91f04325a"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a53b24da0ff8191b893296df91f04325a"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a53b24da0ff8191b893296df91f04325a">STLSetIntersection</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a53b24da0ff8191b893296df91f04325a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f4dd90bac1ac8a80e81cdd6c73cdd" id="r_a170f4dd90bac1ac8a80e81cdd6c73cdd"><td class="memTemplParams" colspan="2">template&lt;typename In1 &gt; </td></tr>
<tr class="memitem:a170f4dd90bac1ac8a80e81cdd6c73cdd"><td class="memTemplItemLeft" align="right" valign="top">In1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a170f4dd90bac1ac8a80e81cdd6c73cdd">STLSetIntersection</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a170f4dd90bac1ac8a80e81cdd6c73cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285294b0cd1b9593f7228472ba24bea3" id="r_a285294b0cd1b9593f7228472ba24bea3"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Compare &gt; </td></tr>
<tr class="memitem:a285294b0cd1b9593f7228472ba24bea3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a285294b0cd1b9593f7228472ba24bea3">STLIncludes</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, Compare compare)</td></tr>
<tr class="separator:a285294b0cd1b9593f7228472ba24bea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230cab028d095beec20b4cf78ea40d35" id="r_a230cab028d095beec20b4cf78ea40d35"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:a230cab028d095beec20b4cf78ea40d35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a230cab028d095beec20b4cf78ea40d35">STLIncludes</a> (const In1 &amp;<a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, const In2 &amp;<a class="el" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>)</td></tr>
<tr class="separator:a230cab028d095beec20b4cf78ea40d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62ce377dfe8316835814287d559cddd" id="r_af62ce377dfe8316835814287d559cddd"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename Comp &gt; </td></tr>
<tr class="memitem:af62ce377dfe8316835814287d559cddd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#af62ce377dfe8316835814287d559cddd">SortedRangesHaveIntersection</a> (InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Comp comparator)</td></tr>
<tr class="separator:af62ce377dfe8316835814287d559cddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a7a5f72fc494c144ccb6544be012b8" id="r_a89a7a5f72fc494c144ccb6544be012b8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:a89a7a5f72fc494c144ccb6544be012b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a89a7a5f72fc494c144ccb6544be012b8">SortedRangesHaveIntersection</a> (InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2)</td></tr>
<tr class="separator:a89a7a5f72fc494c144ccb6544be012b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d71b8ac4e12acac0be3b2ef8e874c1f" id="r_a1d71b8ac4e12acac0be3b2ef8e874c1f"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 , typename Comp &gt; </td></tr>
<tr class="memitem:a1d71b8ac4e12acac0be3b2ef8e874c1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a1d71b8ac4e12acac0be3b2ef8e874c1f">SortedContainersHaveIntersection</a> (const In1 &amp;in1, const In2 &amp;in2, Comp comparator)</td></tr>
<tr class="separator:a1d71b8ac4e12acac0be3b2ef8e874c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf48060177e7164cbcc8d3ffd00d466c" id="r_acf48060177e7164cbcc8d3ffd00d466c"><td class="memTemplParams" colspan="2">template&lt;typename In1 , typename In2 &gt; </td></tr>
<tr class="memitem:acf48060177e7164cbcc8d3ffd00d466c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#acf48060177e7164cbcc8d3ffd00d466c">SortedContainersHaveIntersection</a> (const In1 &amp;in1, const In2 &amp;in2)</td></tr>
<tr class="separator:acf48060177e7164cbcc8d3ffd00d466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d644bca5e6dadc6b57cde24130a324" id="r_a86d644bca5e6dadc6b57cde24130a324"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86d644bca5e6dadc6b57cde24130a324"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegtl.html#a86d644bca5e6dadc6b57cde24130a324">FastTypeId</a> ()</td></tr>
<tr class="separator:a86d644bca5e6dadc6b57cde24130a324"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afce6b52584bb29e142d51b262b8451e5" id="r_afce6b52584bb29e142d51b262b8451e5"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classgtl_1_1IntType.html">gtl::IntType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegtl.html#afce6b52584bb29e142d51b262b8451e5">ABSL_ATTRIBUTE_PACKED</a></td></tr>
<tr class="separator:afce6b52584bb29e142d51b262b8451e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Utilities for container logging. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000056">Todo:</a></b></dt><dd>(user): Broaden the scope and rename to "stream_util.h"</dd></dl>
<p>The typical use looks like this:</p>
<p>LOG(INFO) &lt;&lt; gtl::LogContainer(container);</p>
<p>By default, <a class="el" href="namespacegtl.html#a252ef610941828aa417152c3230ca670">LogContainer()</a> uses the <a class="el" href="structgtl_1_1LogShortUpTo100.html">LogShortUpTo100</a> policy: comma-space separation, no newlines, and with limit of 100 items.</p>
<p>Policies can be specified:</p>
<p>LOG(INFO) &lt;&lt; gtl::LogContainer(container, gtl::LogMultiline());</p>
<p>The above example will print the container using newlines between elements, enclosed in [] braces.</p>
<p>See below for further details on policies.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. <a class="el" href="classgtl_1_1IntType.html">IntType</a> is a simple template class mechanism for defining "logical" integer-like class types that support many of the same functionalities as native integer types, but which prevent assignment, construction, and other operations from other similar integer-like types. Essentially, the template class IntType&lt;IntTypeName, ValueType&gt; (where ValueType assumes valid scalar types such as int, uint, int32_t, etc) has the additional property that it cannot be assigned to or constructed from other IntTypes or native integer types of equal or implicitly convertible type.</p>
<p>The class is useful for preventing mingling of integer variables with different logical roles or units. Unfortunately, C++ provides relatively good type-safety for user-defined classes but not for integer types. It is essentially up to the user to use nice variable names and comments to prevent accidental mismatches, such as confusing a user-index with a group-index or a time-in-milliseconds with a time-in-seconds. The use of typedefs are limited in that regard as they do not enforce type-safety.</p>
<p>USAGE --------------------------------------------------------------------&mdash; </p><div class="fragment"><div class="line"><a class="code hl_define" href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE</a>(IntTypeName, ValueType);</div>
<div class="ttc" id="aint__type_8h_html_a38b1a87de73c7c9bc9ff2bd0aa06536a"><div class="ttname"><a href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE</a></div><div class="ttdeci">#define DEFINE_INT_TYPE(int_type_name, value_type)</div><div class="ttdef"><b>Definition</b> <a href="int__type_8h_source.html#l00167">int_type.h:167</a></div></div>
</div><!-- fragment --><p> where: IntTypeName: is the desired (unique) name for the "logical" integer type. ValueType: is one of the integral types as defined by std::is_integral (see &lt;type_traits&gt;).</p>
<p>DISALLOWED OPERATIONS / TYPE-SAFETY ENFORCEMENT --------------------------&mdash;</p>
<p>Consider these definitions and variable declarations: <a class="el" href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE(GlobalDocID, int64_t)</a>; <a class="el" href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE(LocalDocID, int64_t)</a>; GlobalDocID global; LocalDocID local;</p>
<p>The class <a class="el" href="classgtl_1_1IntType.html">IntType</a> prevents:</p>
<p>1) Assignments of other IntTypes with different IntTypeNames. </p><div class="fragment"><div class="line">global = local;                  &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
<div class="line">local = global;                  &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
<div class="ttc" id="aone__tree__lower__bound_8h_html_a717d5dae07519577a5ed09ac24a4708b"><div class="ttname"><a href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a></div><div class="ttdeci">trees with all degrees equal to</div><div class="ttdef"><b>Definition</b> <a href="one__tree__lower__bound_8h_source.html#l00034">one_tree_lower_bound.h:34</a></div></div>
</div><!-- fragment --><p> 2) Explicit/implicit conversion from an <a class="el" href="classgtl_1_1IntType.html">IntType</a> to another <a class="el" href="classgtl_1_1IntType.html">IntType</a>. </p><div class="fragment"><div class="line">LocalDocID l(global);            &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
<div class="line">LocalDocID l = global;           &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> GetGlobalDoc(GlobalDocID global) { }</div>
<div class="line">GetGlobalDoc(global);            &lt;-- Compiles fine, types match!</div>
<div class="line">GetGlobalDoc(local);             &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
</div><!-- fragment --><p> 3) Implicit conversion from an <a class="el" href="classgtl_1_1IntType.html">IntType</a> to a native integer type. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> GetGlobalDoc(int64_t global) { ...</div>
<div class="line">GetGlobalDoc(global);            &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
<div class="line">GetGlobalDoc(local);             &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> GetLocalDoc(int32_t local) { ...</div>
<div class="line">GetLocalDoc(global);             &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
<div class="line">GetLocalDoc(local);              &lt;-- Fails <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> compile!</div>
</div><!-- fragment --><p> SUPPORTED OPERATIONS -----------------------------------------------------&mdash;</p>
<p>The following operators are supported: unary: ++ (both prefix and postfix), +, -, ! (logical not), ~ (one's complement); comparison: ==, !=, &lt;, &lt;=, &gt;, &gt;=; numerical: +, -, *, /; assignment: =, +=, -=, /=, *=; stream: &lt;&lt;. Each operator allows the same IntTypeName and the ValueType to be used on both left- and right-hand sides.</p>
<p>It also supports an accessor <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value()</a> returning the stored value as ValueType, and a templatized accessor <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value&lt;T&gt;()</a> method that serves as syntactic sugar for static_cast&lt;T&gt;(var.value()). These accessors are useful when assigning the stored value into protocol buffer fields and using it as printf args.</p>
<p>The class also defines a hash functor that allows the <a class="el" href="classgtl_1_1IntType.html">IntType</a> to be used as key to hashable containers such as hash_map and hash_set.</p>
<p>We suggest using the IntTypeIndexedContainer wrapper around google3's FixedArray and STL vector (see int-type-indexed-container.h) if an <a class="el" href="classgtl_1_1IntType.html">IntType</a> is intended to be used as an index into these containers. These wrappers are indexed in a type-safe manner using IntTypes to ensure type-safety.</p>
<p>NB: this implementation does not attempt to abide by or enforce dimensional analysis on these scalar types.</p>
<p>EXAMPLES -----------------------------------------------------------------&mdash; </p><div class="fragment"><div class="line"><a class="code hl_define" href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE</a>(GlobalDocID, int64_t);</div>
<div class="line">GlobalDocID global = 3;</div>
<div class="line">std::cout &lt;&lt; global;                      &lt;-- Prints 3 <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> stdout.</div>
<div class="line"> </div>
<div class="line">for (GlobalDocID i(0); i &lt; global; ++i) {</div>
<div class="line">  std::cout &lt;&lt; i;</div>
<div class="line">}                                    &lt;-- Print(ln)s 0 1 2 <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> stdout</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE</a>(LocalDocID, int64_t);</div>
<div class="line">LocalDocID local;</div>
<div class="line">std::cout &lt;&lt; local;                       &lt;-- Prints 0 <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> stdout it</div>
<div class="line"><span class="keywordflow">default</span></div>
<div class="line">                                         initializes the <a class="code hl_variable" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a> <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> 0.</div>
<div class="line"> </div>
<div class="line">local = 5;</div>
<div class="line">local *= 2;</div>
<div class="line">LocalDocID l(local);</div>
<div class="line">std::cout &lt;&lt; l + local;                   &lt;-- Prints 20 <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> stdout.</div>
<div class="line"> </div>
<div class="line">GenericSearchRequest request;</div>
<div class="line">request.set_doc_id(global.value());  &lt;-- Uses <a class="code hl_variable" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>() <a class="code hl_variable" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a> extract the <a class="code hl_variable" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a></div>
<div class="line">                                         from the IntType class.</div>
<div class="ttc" id="ademon__profiler_8cc_html_ac072af30c4ffbc834bb4c681f6ecb514"><div class="ttname"><a href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a></div><div class="ttdeci">int64_t value</div><div class="ttdef"><b>Definition</b> <a href="demon__profiler_8cc_source.html#l00045">demon_profiler.cc:45</a></div></div>
</div><!-- fragment --><p> REMARKS ------------------------------------------------------------------&mdash;</p>
<p>The following bad usage is permissible although discouraged. Essentially, it involves using the value*() accessors to extract the native integer type out of the <a class="el" href="classgtl_1_1IntType.html">IntType</a> class. Keep in mind that the primary reason for the <a class="el" href="classgtl_1_1IntType.html">IntType</a> class is to prevent <em>accidental</em> mingling of similar logical integer types &ndash; and not type casting from one type to another.</p>
<p><a class="el" href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE(GlobalDocID, int64_t)</a>; <a class="el" href="int__type_8h.html#a38b1a87de73c7c9bc9ff2bd0aa06536a">DEFINE_INT_TYPE(LocalDocID, int64_t)</a>; GlobalDocID global; LocalDocID local;</p>
<p>global = local.value(); &lt;&ndash; Compiles fine.</p>
<p>void GetGlobalDoc(GlobalDocID global) { ... GetGlobalDoc(local.value()); &lt;&ndash; Compiles fine.</p>
<p>void GetGlobalDoc(int64_t global) { ... GetGlobalDoc(local.value()); &lt;&ndash; Compiles fine.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This is a simplistic insertion-ordered map. It behaves similarly to an STL map, but only implements a small subset of the map's methods. Internally, we just keep a map and a list going in parallel.</p>
<p>This class provides no thread safety guarantees, beyond what you would normally see with std::list.</p>
<p>Iterators point into the list and should be stable in the face of mutations, except for an iterator pointing to an element that was just deleted.</p>
<p>This class supports heterogeneous lookups. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a4f663b315f1f56d575e32524a9d06313" name="a4f663b315f1f56d575e32524a9d06313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f663b315f1f56d575e32524a9d06313">&#9670;&#160;</a></span>LogDefault</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structgtl_1_1LogShortUpTo100.html">LogShortUpTo100</a> <a class="el" href="namespacegtl.html#a4f663b315f1f56d575e32524a9d06313">gtl::LogDefault</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default policy for new code. </p>

<p class="definition">Definition at line <a class="el" href="container__logging_8h_source.html#l00168">168</a> of file <a class="el" href="container__logging_8h_source.html">container_logging.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae28e97bd1fa93cb0032642550da7455" name="aae28e97bd1fa93cb0032642550da7455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae28e97bd1fa93cb0032642550da7455">&#9670;&#160;</a></span>ContainsKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::ContainsKey </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test to see if a std::set, std::map, std::unordered_set or std::unordered_map contains a particular key. Returns true if the key is in the collection. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00200">200</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a86d644bca5e6dadc6b57cde24130a324" name="a86d644bca5e6dadc6b57cde24130a324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d644bca5e6dadc6b57cde24130a324">&#9670;&#160;</a></span>FastTypeId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gtl::FastTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="typeid_8h_source.html#l00019">19</a> of file <a class="el" href="typeid_8h_source.html">typeid.h</a>.</p>

</div>
</div>
<a id="a6a4238d2e35cf819a8e83d60d331ea64" name="a6a4238d2e35cf819a8e83d60d331ea64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4238d2e35cf819a8e83d60d331ea64">&#9670;&#160;</a></span>FindCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::FindCopy </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a lookup in std::map or std::unordered_map. If the key is present and value is non-NULL then a copy of the value associated with the key is made into *value. Returns whether key was present. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00185">185</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a73f41ac11336b94768fdd41594153d59" name="a73f41ac11336b94768fdd41594153d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f41ac11336b94768fdd41594153d59">&#9670;&#160;</a></span>FindOrDie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type &amp; gtl::FindOrDie </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00206">206</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a8c6864289d1f3ce3d6437e6b8a70314e" name="a8c6864289d1f3ce3d6437e6b8a70314e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6864289d1f3ce3d6437e6b8a70314e">&#9670;&#160;</a></span>FindOrDieNoPrint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type::second_type &amp; gtl::FindOrDieNoPrint </td>
          <td>(</td>
          <td class="paramtype">Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but returns a non-const reference. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00226">226</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a9093d3af795feb9332cea022c20550f8" name="a9093d3af795feb9332cea022c20550f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9093d3af795feb9332cea022c20550f8">&#9670;&#160;</a></span>FindOrDieNoPrint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type &amp; gtl::FindOrDieNoPrint </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as FindOrDie above, but doesn't log the key on failure. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00216">216</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="addc85942861c64c1fe50253a648ed541" name="addc85942861c64c1fe50253a648ed541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc85942861c64c1fe50253a648ed541">&#9670;&#160;</a></span>FindOrNull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type::second_type * gtl::FindOrNull </td>
          <td>(</td>
          <td class="paramtype">Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a lookup in a std::map or std::unordered_map. Same as above but the returned pointer is not const and can be used to change the stored value. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00074">74</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a9f74dcd1ec00022462cbf110edaafc6d" name="a9f74dcd1ec00022462cbf110edaafc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f74dcd1ec00022462cbf110edaafc6d">&#9670;&#160;</a></span>FindOrNull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type * gtl::FindOrNull </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a lookup in a std::map or std::unordered_map. If the key is present a const pointer to the associated value is returned, otherwise a NULL pointer is returned. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00060">60</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a10ae48a53bb9d0ce3024501a7750260b" name="a10ae48a53bb9d0ce3024501a7750260b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ae48a53bb9d0ce3024501a7750260b">&#9670;&#160;</a></span>FindPtrOrNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type gtl::FindPtrOrNull </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a lookup in a std::map or std::unordered_map whose values are pointers. If the key is present a const pointer to the associated value is returned, otherwise a NULL pointer is returned. This function does not distinguish between a missing key and a key mapped to a NULL value. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00089">89</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a85658bbe1373f2a6acda2663582dd33f" name="a85658bbe1373f2a6acda2663582dd33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85658bbe1373f2a6acda2663582dd33f">&#9670;&#160;</a></span>FindWithDefault() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type &amp; gtl::FindWithDefault </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const reference to the value associated with the given key if it exists, otherwise returns a const reference to a value-initialized object that is never destroyed. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00044">44</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a795ebdb62731938c8c31b221f0f074b4" name="a795ebdb62731938c8c31b221f0f074b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795ebdb62731938c8c31b221f0f074b4">&#9670;&#160;</a></span>FindWithDefault() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type &amp; gtl::FindWithDefault </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::second_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a lookup in a std::map or std::unordered_map. If the key is present in the map then the value associated with that key is returned, otherwise the value passed as a default is returned.</p>
<p>Prefer the two-argument form unless you need to specify a custom default value (i.e., one that is not equal to a value-initialized instance). </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00029">29</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a3868cd1a78a83d74cfd437fbbc922b39" name="a3868cd1a78a83d74cfd437fbbc922b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868cd1a78a83d74cfd437fbbc922b39">&#9670;&#160;</a></span>HashMapEquality() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HashMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::HashMapEquality </td>
          <td>(</td>
          <td class="paramtype">const HashMap &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashMap &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00303">303</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="af85eab207548c101c17223579824f7cb" name="af85eab207548c101c17223579824f7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85eab207548c101c17223579824f7cb">&#9670;&#160;</a></span>HashMapEquality() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HashMap , typename BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::HashMapEquality </td>
          <td>(</td>
          <td class="paramtype">const HashMap &amp;&#160;</td>
          <td class="paramname"><em>map_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashMap &amp;&#160;</td>
          <td class="paramname"><em>map_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>mapped_type_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Using HashMapEquality for multiple-associative containers like multimap and hash_multimap will result in wrong behavior. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00282">282</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="aad342a513d3cc1495d581ffb8accf7ee" name="aad342a513d3cc1495d581ffb8accf7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad342a513d3cc1495d581ffb8accf7ee">&#9670;&#160;</a></span>HashMapEquality() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename C , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::HashMapEquality </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, V, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We overload for 'map' without a specialized functor and simply use its operator== function. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00297">297</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a776bb5aac43dbc858cca094af43084e2" name="a776bb5aac43dbc858cca094af43084e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776bb5aac43dbc858cca094af43084e2">&#9670;&#160;</a></span>HashSetEquality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HashSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::HashSetEquality </td>
          <td>(</td>
          <td class="paramtype">const HashSet &amp;&#160;</td>
          <td class="paramname"><em>set_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HashSet &amp;&#160;</td>
          <td class="paramname"><em>set_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests two hash maps/sets for equality. This exists because operator== in the STL can return false when the maps/sets contain identical elements. This is because it compares the internal hash tables which may be different if the order of insertions and deletions differed. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00270">270</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a448c7622e34b60a1010a4c684292bc7f" name="a448c7622e34b60a1010a4c684292bc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448c7622e34b60a1010a4c684292bc7f">&#9670;&#160;</a></span>InsertIfNotPresent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::InsertIfNotPresent </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a new key and value into a std::map or std::unordered_map. If the key is not present in the map the key and value are inserted, otherwise nothing happens. True indicates that an insert took place, false indicates the key was already present. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00134">134</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a3ea1e2b26e83387a5eea8d83d9406d34" name="a3ea1e2b26e83387a5eea8d83d9406d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea1e2b26e83387a5eea8d83d9406d34">&#9670;&#160;</a></span>InsertIfNotPresent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::InsertIfNotPresent </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a new key into a set. If the key is not present in the set the key is inserted, otherwise nothing happens. True indicates that an insert took place, false indicates the key was already present. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00122">122</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="aea75330fcfcabf5467939b997a97e739" name="aea75330fcfcabf5467939b997a97e739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea75330fcfcabf5467939b997a97e739">&#9670;&#160;</a></span>InsertKeyOrDie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; gtl::InsertKeyOrDie </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a key into a map with the default value or dies. Returns a reference to the inserted element. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00173">173</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a5c0d4dea208db4deaa285c06b78d8181" name="a5c0d4dea208db4deaa285c06b78d8181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0d4dea208db4deaa285c06b78d8181">&#9670;&#160;</a></span>InsertOrDie() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::InsertOrDie </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new std::pair&lt;key,value&gt; into a std::map or std::unordered_map. Insert a new key into a std::set or std::unordered_set. Dies if the key is already present. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00154">154</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a52960c638efa5b6c96d69f2a40d371e8" name="a52960c638efa5b6c96d69f2a40d371e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52960c638efa5b6c96d69f2a40d371e8">&#9670;&#160;</a></span>InsertOrDie() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::InsertOrDie </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::second_type &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new key/value into a std::map or std::unordered_map. Dies if the key is already present. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00162">162</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a2dafdccc2a76e528208724b3cedab6ab" name="a2dafdccc2a76e528208724b3cedab6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dafdccc2a76e528208724b3cedab6ab">&#9670;&#160;</a></span>InsertOrDieNoPrint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::InsertOrDieNoPrint </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new std::pair&lt;key,value&gt; into a std::map or std::unordered_map. Insert a new key into a std::set or std::unordered_set. Dies if the key is already present. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00145">145</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a28b9600337fe4ae3077d7646fca2970f" name="a28b9600337fe4ae3077d7646fca2970f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b9600337fe4ae3077d7646fca2970f">&#9670;&#160;</a></span>InsertOrUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::InsertOrUpdate </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value associated with a particular key in a std::map or std::unordered_map. If the key is not present in the map the key and value are inserted, otherwise the value is updated to be a copy of the value provided. True indicates that an insert took place, false indicates an update. </p>
<p>update</p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00105">105</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="a25bd7d17d32cf3586b8bf3fd43d52078" name="a25bd7d17d32cf3586b8bf3fd43d52078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bd7d17d32cf3586b8bf3fd43d52078">&#9670;&#160;</a></span>INT_TYPE_ARITHMETIC_OP() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_ARITHMETIC_OP </td>
          <td>(</td>
          <td class="paramtype">%&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a005a7b730220139729dd3bc0ac7a3e37" name="a005a7b730220139729dd3bc0ac7a3e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005a7b730220139729dd3bc0ac7a3e37">&#9670;&#160;</a></span>INT_TYPE_ARITHMETIC_OP() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_ARITHMETIC_OP </td>
          <td>(</td>
          <td class="paramtype">+&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51a6ff92216ce2b6611fb8269e1eb471" name="a51a6ff92216ce2b6611fb8269e1eb471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a6ff92216ce2b6611fb8269e1eb471">&#9670;&#160;</a></span>INT_TYPE_ARITHMETIC_OP() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_ARITHMETIC_OP </td>
          <td>(</td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af495b683b5004fc480042b33a5891463" name="af495b683b5004fc480042b33a5891463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af495b683b5004fc480042b33a5891463">&#9670;&#160;</a></span>INT_TYPE_ARITHMETIC_OP() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT_TYPE_ARITHMETIC_OP * gtl::INT_TYPE_ARITHMETIC_OP </td>
          <td>(</td>
          <td class="paramtype">/&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a855676c9b0426bf2cd9d1f207546830b" name="a855676c9b0426bf2cd9d1f207546830b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855676c9b0426bf2cd9d1f207546830b">&#9670;&#160;</a></span>INT_TYPE_ARITHMETIC_OP() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_ARITHMETIC_OP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f2acf50f5c6a7668e5a2eedb2b3b9b4" name="a7f2acf50f5c6a7668e5a2eedb2b3b9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2acf50f5c6a7668e5a2eedb2b3b9b4">&#9670;&#160;</a></span>INT_TYPE_COMPARISON_OP() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramtype">!&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75b9bce22ee2b4ddcaefd9c3a176d753" name="a75b9bce22ee2b4ddcaefd9c3a176d753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b9bce22ee2b4ddcaefd9c3a176d753">&#9670;&#160;</a></span>INT_TYPE_COMPARISON_OP() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramtype">&lt;=&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab79ac14d2b328e095ee63c5a40f7f6db" name="ab79ac14d2b328e095ee63c5a40f7f6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79ac14d2b328e095ee63c5a40f7f6db">&#9670;&#160;</a></span>INT_TYPE_COMPARISON_OP() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fbc025b7b70df26625e6b0ca1ef1db9" name="a8fbc025b7b70df26625e6b0ca1ef1db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbc025b7b70df26625e6b0ca1ef1db9">&#9670;&#160;</a></span>INT_TYPE_COMPARISON_OP() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gtl::INT_TYPE_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramtype">&gt;=&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ef4d25cc294b5d4bec3549469b560e2" name="a6ef4d25cc294b5d4bec3549469b560e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef4d25cc294b5d4bec3549469b560e2">&#9670;&#160;</a></span>LogContainer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gtl::LogContainer </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; decltype(gtl::LogContainer(container, <a class="el" href="namespacegtl.html#a4f663b315f1f56d575e32524a9d06313">LogDefault</a>())) </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log a container. For example:</p>
<p>LOG(INFO) &lt;&lt; gtl::LogContainer(container);</p>
<p>By default, Container() uses the <a class="el" href="structgtl_1_1LogShortUpTo100.html">LogShortUpTo100</a> policy: comma-space separation, no newlines, and with limit of 100 items. </p>

<p class="definition">Definition at line <a class="el" href="container__logging_8h_source.html#l00287">287</a> of file <a class="el" href="container__logging_8h_source.html">container_logging.h</a>.</p>

</div>
</div>
<a id="a252ef610941828aa417152c3230ca670" name="a252ef610941828aa417152c3230ca670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252ef610941828aa417152c3230ca670">&#9670;&#160;</a></span>LogContainer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename PolicyT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto gtl::LogContainer </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PolicyT &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacegtl.html#a829be4587c2fbc742294381e89b71570">gtl::LogRange</a>(container.begin(), container.end(), policy)) </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log a container using "policy". For example:</p>
<p>LOG(INFO) &lt;&lt; gtl::LogContainer(container, gtl::LogMultiline());</p>
<p>The above example will print the container using newlines between elements, enclosed in [] braces. </p>

<p class="definition">Definition at line <a class="el" href="container__logging_8h_source.html#l00275">275</a> of file <a class="el" href="container__logging_8h_source.html">container_logging.h</a>.</p>

</div>
</div>
<a id="a7b33b6e58e54dbc05433bc83268ae138" name="a7b33b6e58e54dbc05433bc83268ae138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b33b6e58e54dbc05433bc83268ae138">&#9670;&#160;</a></span>LogEnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtl_1_1detail_1_1EnumLogger.html">detail::EnumLogger</a>&lt; E &gt; gtl::LogEnum </td>
          <td>(</td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log a (possibly scoped) enum. For example:</p>
<p>enum class Color { kRed, kGreen, kBlue }; LOG(INFO) &lt;&lt; gtl::LogEnum(kRed); </p>

<p class="definition">Definition at line <a class="el" href="container__logging_8h_source.html#l00297">297</a> of file <a class="el" href="container__logging_8h_source.html">container_logging.h</a>.</p>

</div>
</div>
<a id="a56f025bbd76056e4b95662c1adf0c754" name="a56f025bbd76056e4b95662c1adf0c754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f025bbd76056e4b95662c1adf0c754">&#9670;&#160;</a></span>LogRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtl_1_1detail_1_1RangeLogger.html">detail::RangeLogger</a>&lt; IteratorT, <a class="el" href="namespacegtl.html#a4f663b315f1f56d575e32524a9d06313">LogDefault</a> &gt; gtl::LogRange </td>
          <td>(</td>
          <td class="paramtype">const IteratorT &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorT &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log a range. For example:</p>
<p>LOG(INFO) &lt;&lt; gtl::LogRange(start_pos, end_pos);</p>
<p>By default, Range() uses the <a class="el" href="structgtl_1_1LogShortUpTo100.html">LogShortUpTo100</a> policy: comma-space separation, no newlines, and with limit of 100 items. </p>

<p class="definition">Definition at line <a class="el" href="container__logging_8h_source.html#l00263">263</a> of file <a class="el" href="container__logging_8h_source.html">container_logging.h</a>.</p>

</div>
</div>
<a id="a829be4587c2fbc742294381e89b71570" name="a829be4587c2fbc742294381e89b71570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829be4587c2fbc742294381e89b71570">&#9670;&#160;</a></span>LogRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename PolicyT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtl_1_1detail_1_1RangeLogger.html">detail::RangeLogger</a>&lt; IteratorT, PolicyT &gt; gtl::LogRange </td>
          <td>(</td>
          <td class="paramtype">const IteratorT &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IteratorT &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PolicyT &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log a range using "policy". For example:</p>
<p>LOG(INFO) &lt;&lt; gtl::LogRange(start_pos, end_pos, gtl::LogMultiline());</p>
<p>The above example will print the range using newlines between elements, enclosed in [] braces. </p>

<p class="definition">Definition at line <a class="el" href="container__logging_8h_source.html#l00250">250</a> of file <a class="el" href="container__logging_8h_source.html">container_logging.h</a>.</p>

</div>
</div>
<a id="ae771af59e42d532c50c13eac05ffc725" name="ae771af59e42d532c50c13eac05ffc725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae771af59e42d532c50c13eac05ffc725">&#9670;&#160;</a></span>LogRangeToStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename PolicyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::LogRangeToStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PolicyT &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LogRangeToStream should be used to define operator&lt;&lt; for STL and STL-like containers. For example, see <a class="el" href="stl__logging_8h.html">stl_logging.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="container__logging_8h_source.html#l00173">173</a> of file <a class="el" href="container__logging_8h_source.html">container_logging.h</a>.</p>

</div>
</div>
<a id="a523b266127b26ec3817cae4c5f41c391" name="a523b266127b26ec3817cae4c5f41c391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523b266127b26ec3817cae4c5f41c391">&#9670;&#160;</a></span>LookupOrInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type::second_type &amp; gtl::LookupOrInsert </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::second_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup a key in a std::map or std::unordered_map, insert it if it is not present. Returns a reference to the value associated with the key. </p>

<p class="definition">Definition at line <a class="el" href="map__util_8h_source.html#l00237">237</a> of file <a class="el" href="map__util_8h_source.html">map_util.h</a>.</p>

</div>
</div>
<a id="adf94e6a7dc7d9ec54a01de70d6ef91ca" name="adf94e6a7dc7d9ec54a01de70d6ef91ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf94e6a7dc7d9ec54a01de70d6ef91ca">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntTypeName , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; gtl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgtl_1_1IntType.html">IntType</a>&lt; IntTypeName, ValueType &gt;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&ndash; NON-MEMBER STREAM OPERATORS -------------------------------------------&mdash; We provide the &lt;&lt; operator, primarily for logging purposes. Currently, there seems to be no need for an &gt;&gt; operator. </p>

<p class="definition">Definition at line <a class="el" href="int__type_8h_source.html#l00285">285</a> of file <a class="el" href="int__type_8h_source.html">int_type.h</a>.</p>

</div>
</div>
<a id="a2c5297b48a390e2b2a1420bdba2b25fd" name="a2c5297b48a390e2b2a1420bdba2b25fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5297b48a390e2b2a1420bdba2b25fd">&#9670;&#160;</a></span>release_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT T * gtl::release_ptr </td>
          <td>(</td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the referenced pointer to nullptr and returns its original value. This can be a convenient way to remove a pointer from a container to avoid the eventual deletion by an <a class="el" href="classgtl_1_1ElementDeleter.html">ElementDeleter</a>.</p>
<p>Example:</p>
<p>std::vector&lt;Foo*&gt; v{new Foo, new Foo, new Foo}; <a class="el" href="classgtl_1_1ElementDeleter.html">ElementDeleter</a> d(&amp;v); Foo* safe = release_ptr(&amp;v[1]); ///&lt; v[1] is now nullptr and the Foo it previously pointed to is now ///&lt; stored in "safe" </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00533">533</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a45d76e4ed7c0294917917c69ef7313cf" name="a45d76e4ed7c0294917917c69ef7313cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d76e4ed7c0294917917c69ef7313cf">&#9670;&#160;</a></span>reversed_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgtl_1_1ReverseView.html">ReverseView</a>&lt; Container &gt; gtl::reversed_view </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iterator__adaptors_8h_source.html#l00033">33</a> of file <a class="el" href="iterator__adaptors_8h_source.html">iterator_adaptors.h</a>.</p>

</div>
</div>
<a id="acf48060177e7164cbcc8d3ffd00d466c" name="acf48060177e7164cbcc8d3ffd00d466c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf48060177e7164cbcc8d3ffd00d466c">&#9670;&#160;</a></span>SortedContainersHaveIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::SortedContainersHaveIntersection </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>in2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00893">893</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a1d71b8ac4e12acac0be3b2ef8e874c1f" name="a1d71b8ac4e12acac0be3b2ef8e874c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d71b8ac4e12acac0be3b2ef8e874c1f">&#9670;&#160;</a></span>SortedContainersHaveIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::SortedContainersHaveIntersection </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the ordered containers 'in1' and 'in2' have a non-empty intersection. The container elements do not have to be the same type, but the elements must be sorted either by the specified comparator, or by '&lt;' if no comparator is given. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00887">887</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a89a7a5f72fc494c144ccb6544be012b8" name="a89a7a5f72fc494c144ccb6544be012b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a7a5f72fc494c144ccb6544be012b8">&#9670;&#160;</a></span>SortedRangesHaveIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::SortedRangesHaveIntersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00876">876</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="af62ce377dfe8316835814287d559cddd" name="af62ce377dfe8316835814287d559cddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62ce377dfe8316835814287d559cddd">&#9670;&#160;</a></span>SortedRangesHaveIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::SortedRangesHaveIntersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SortedRangesHaveIntersection: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="namespacegtl.html#af62ce377dfe8316835814287d559cddd">SortedRangesHaveIntersection</a>(begin1, end1, begin2, end2);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="namespacegtl.html#af62ce377dfe8316835814287d559cddd">SortedRangesHaveIntersection</a>(begin1, end1, begin2, end2,</div>
<div class="line">                                  comparator);</div>
<div class="ttc" id="anamespacegtl_html_af62ce377dfe8316835814287d559cddd"><div class="ttname"><a href="namespacegtl.html#af62ce377dfe8316835814287d559cddd">gtl::SortedRangesHaveIntersection</a></div><div class="ttdeci">bool SortedRangesHaveIntersection(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2, Comp comparator)</div><div class="ttdef"><b>Definition</b> <a href="stl__util_8h_source.html#l00857">stl_util.h:857</a></div></div>
</div><!-- fragment --><p> Returns true iff any element in the sorted range [begin1, end1) is equivalent to any element in the sorted range [begin2, end2). The iterators themselves do not have to be the same type, but the value types must be sorted either by the specified comparator, or by '&lt;' if no comparator is given. [Two elements a,b are considered equivalent if !(a &lt; b) &amp;&amp; !(b &lt; a) ]. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00857">857</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="aa33bfe8a337682344d8d4dc06d0fc3ed" name="aa33bfe8a337682344d8d4dc06d0fc3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33bfe8a337682344d8d4dc06d0fc3ed">&#9670;&#160;</a></span>STLAppendToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLAppendToString </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends the n bytes starting at ptr to the given string. This is intended to be faster than string::append() in SOME cases, however, it's actually slower in some cases as well.</p>
<p>Just use string::append directly unless you have benchmarks showing that this function makes your code faster. (Even then, a future version of string::append() may be faster than this.) </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00239">239</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a9dfc7ed347f74887973daddd014047ec" name="a9dfc7ed347f74887973daddd014047ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfc7ed347f74887973daddd014047ec">&#9670;&#160;</a></span>STLAssignToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLAssignToString </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns the n bytes starting at ptr to the given string. This is intended to be faster than string::assign() in SOME cases, however, it's actually slower in some cases as well.</p>
<p>Just use string::assign directly unless you have benchmarks showing that this function makes your code faster. (Even then, a future version of string::assign() may be faster than this.) </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00226">226</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a8b11464d5e8c5f0bb36a15d53abb8cc7" name="a8b11464d5e8c5f0bb36a15d53abb8cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b11464d5e8c5f0bb36a15d53abb8cc7">&#9670;&#160;</a></span>STLClearHashIfBig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLClearHashIfBig </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements and reduces the number of buckets in a hash_set or hash_map back to the default if the current number of buckets is "limit" or more.</p>
<p>Adding items to a hash container may add buckets, but removing items or calling clear() does not necessarily reduce the number of buckets. Having lots of buckets is good if you insert comparably many items in every iteration because you'll reduce collisions and table resizes. But having lots of buckets is bad if you insert few items in most subsequent iterations, because repeatedly clearing out all those buckets can get expensive.</p>
<p>One solution is to call <a class="el" href="namespacegtl.html#a8b11464d5e8c5f0bb36a15d53abb8cc7">STLClearHashIfBig()</a> with a "limit" value that is a small multiple of the typical number of items in your table. In the common case, this is equivalent to an ordinary clear. In the rare case where you insert a lot of items, the number of buckets is reset to the default to keep subsequent clear operations cheap. Note that the default number of buckets is 193 in the Gnu library implementation as of Jan '08. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00180">180</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a1f9b8c786639c2a8ed09d7906eb4a3c9" name="a1f9b8c786639c2a8ed09d7906eb4a3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9b8c786639c2a8ed09d7906eb4a3c9">&#9670;&#160;</a></span>STLClearIfBig() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLClearIfBig </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; T, A &gt; *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>1&#160;&lt;&lt;&#160;20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STLClearIfBig overload for deque, which is missing capacity(). </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00154">154</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a38e5bdb50d313df878b8557e6aca45be" name="a38e5bdb50d313df878b8557e6aca45be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e5bdb50d313df878b8557e6aca45be">&#9670;&#160;</a></span>STLClearIfBig() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLClearIfBig </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>1&#160;&lt;&lt;&#160;20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <a class="el" href="namespacegtl.html#a92a0e7b0e74024284adc849a4499940f">STLClearObject()</a> if the object is bigger than the specified limit, otherwise calls the object's clear() member. This can be useful if you want to allow the object to hold on to its allocated memory as long as it's not too much.</p>
<dl class="section note"><dt>Note</dt><dd>The name is misleading since the object is always cleared, regardless of its size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00145">145</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="af79e1fdee4ca438235865f1fed899bf7" name="af79e1fdee4ca438235865f1fed899bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e1fdee4ca438235865f1fed899bf7">&#9670;&#160;</a></span>STLClearObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLClearObject </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; T, A &gt; *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STLClearObject overload for deque, which is missing reserve(). </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00132">132</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a92a0e7b0e74024284adc849a4499940f" name="a92a0e7b0e74024284adc849a4499940f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a0e7b0e74024284adc849a4499940f">&#9670;&#160;</a></span>STLClearObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLClearObject </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears internal memory of an STL object by swapping the argument with a new, empty object. STL clear()/reserve(0) does not always free internal memory allocated. </p>
<p>This reserve(0) is needed because "T tmp" sometimes allocates memory (arena implementation?), even though this may not always work.</p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00123">123</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a000377a1edd9573424f915486d7a34cd" name="a000377a1edd9573424f915486d7a34cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000377a1edd9573424f915486d7a34cd">&#9670;&#160;</a></span>STLDeleteContainerPairFirstPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLDeleteContainerPairFirstPointers </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls delete (non-array version) on the FIRST item (pointer) in each pair in the range [begin, end). </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00338">338</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a00cdbc2f98979cfa54442634df0757e6" name="a00cdbc2f98979cfa54442634df0757e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cdbc2f98979cfa54442634df0757e6">&#9670;&#160;</a></span>STLDeleteContainerPairPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLDeleteContainerPairPointers </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls delete (non-array version) on BOTH items (pointers) in each pair in the range [begin, end). </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00325">325</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a5175be393c366b55cd2e438d5b318d4f" name="a5175be393c366b55cd2e438d5b318d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5175be393c366b55cd2e438d5b318d4f">&#9670;&#160;</a></span>STLDeleteContainerPairSecondPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLDeleteContainerPairSecondPointers </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls delete (non-array version) on the SECOND item (pointer) in each pair in the range [begin, end).</p>
<dl class="section note"><dt>Note</dt><dd>If you're calling this on an entire container, you probably want to call STLDeleteValues(&amp;container) instead, or use <a class="el" href="classgtl_1_1ValueDeleter.html">ValueDeleter</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00353">353</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a88a7129153c63a150516ea2f617b767b" name="a88a7129153c63a150516ea2f617b767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a7129153c63a150516ea2f617b767b">&#9670;&#160;</a></span>STLDeleteContainerPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLDeleteContainerPointers </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls delete (non-array version) on pointers in the range [begin, end).</p>
<dl class="section note"><dt>Note</dt><dd>If you're calling this on an entire container, you probably want to call STLDeleteElements(&amp;container) instead (which also clears the container), or use an <a class="el" href="classgtl_1_1ElementDeleter.html">ElementDeleter</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00314">314</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a4ee3db0c4acaa0f277a0d7006f5ad1e6" name="a4ee3db0c4acaa0f277a0d7006f5ad1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee3db0c4acaa0f277a0d7006f5ad1e6">&#9670;&#160;</a></span>STLDeleteElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLDeleteElements </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all the elements in an STL container and clears the container. This function is suitable for use with a vector, set, hash_set, or any other STL container which defines sensible <a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin()</a>, <a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end()</a>, and clear() methods.</p>
<p>If container is nullptr, this function is a no-op.</p>
<p>As an alternative to calling <a class="el" href="namespacegtl.html#a4ee3db0c4acaa0f277a0d7006f5ad1e6">STLDeleteElements()</a> directly, consider <a class="el" href="classgtl_1_1ElementDeleter.html">ElementDeleter</a> (defined below), which ensures that your container's elements are deleted when the <a class="el" href="classgtl_1_1ElementDeleter.html">ElementDeleter</a> goes out of scope. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00372">372</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a115efd2ec0ec9c7ced30f4daadd89ab7" name="a115efd2ec0ec9c7ced30f4daadd89ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115efd2ec0ec9c7ced30f4daadd89ab7">&#9670;&#160;</a></span>STLDeleteValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLDeleteValues </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an STL container consisting of (key, value) pairs, STLDeleteValues deletes all the "value" components and clears the container. Does nothing in the case it's given a nullptr. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00382">382</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a911c73c6bb68b07bb24dac74c219deeb" name="a911c73c6bb68b07bb24dac74c219deeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911c73c6bb68b07bb24dac74c219deeb">&#9670;&#160;</a></span>STLEraseAllFromSequence() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLEraseAllFromSequence </td>
          <td>(</td>
          <td class="paramtype">std::forward_list&lt; T, A &gt; *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00101">101</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a5262a5dd67f75add06e26f34e0673db2" name="a5262a5dd67f75add06e26f34e0673db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5262a5dd67f75add06e26f34e0673db2">&#9670;&#160;</a></span>STLEraseAllFromSequence() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLEraseAllFromSequence </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; T, A &gt; *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00097">97</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a82eb98ee939aaa7b64a85fa63453689e" name="a82eb98ee939aaa7b64a85fa63453689e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82eb98ee939aaa7b64a85fa63453689e">&#9670;&#160;</a></span>STLEraseAllFromSequence() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLEraseAllFromSequence </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove every occurrence of element e in v. See <a href="http://en.wikipedia.org/wiki/Erase-remove_idiom">http://en.wikipedia.org/wiki/Erase-remove_idiom</a>. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00093">93</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="ac241daf9051a05764c915d1c17e199a9" name="ac241daf9051a05764c915d1c17e199a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac241daf9051a05764c915d1c17e199a9">&#9670;&#160;</a></span>STLEraseAllFromSequenceIf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLEraseAllFromSequenceIf </td>
          <td>(</td>
          <td class="paramtype">std::forward_list&lt; T, A &gt; *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00115">115</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a0232cdd3e66048c74ef1d5ec3cb2f86d" name="a0232cdd3e66048c74ef1d5ec3cb2f86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0232cdd3e66048c74ef1d5ec3cb2f86d">&#9670;&#160;</a></span>STLEraseAllFromSequenceIf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLEraseAllFromSequenceIf </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; T, A &gt; *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00111">111</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a4afa1e83cd6407fa4b77d49b8c136806" name="a4afa1e83cd6407fa4b77d49b8c136806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afa1e83cd6407fa4b77d49b8c136806">&#9670;&#160;</a></span>STLEraseAllFromSequenceIf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLEraseAllFromSequenceIf </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove each element e in v satisfying pred(e). </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00107">107</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a230cab028d095beec20b4cf78ea40d35" name="a230cab028d095beec20b4cf78ea40d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230cab028d095beec20b4cf78ea40d35">&#9670;&#160;</a></span>STLIncludes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::STLIncludes </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00840">840</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a285294b0cd1b9593f7228472ba24bea3" name="a285294b0cd1b9593f7228472ba24bea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285294b0cd1b9593f7228472ba24bea3">&#9670;&#160;</a></span>STLIncludes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::STLIncludes </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff every element in "b" is also in "a". Both containers must be sorted by the specified comparator, or by '&lt;' if none is given. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00830">830</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a8e3c94ab9628465d56d8be3d89e7e840" name="a8e3c94ab9628465d56d8be3d89e7e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3c94ab9628465d56d8be3d89e7e840">&#9670;&#160;</a></span>STLSetDifference() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00640">640</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a8a4c967916645e5517ae33bbc2758086" name="a8a4c967916645e5517ae33bbc2758086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4c967916645e5517ae33bbc2758086">&#9670;&#160;</a></span>STLSetDifference() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implicit comparator, implicit return type. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00636">636</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a09e7314a966b2d0cf2e2b352b9365f6e" name="a09e7314a966b2d0cf2e2b352b9365f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e7314a966b2d0cf2e2b352b9365f6e">&#9670;&#160;</a></span>STLSetDifference() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit comparator, implicit return type. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00631">631</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a34d659ec14f4c5b2b847927734d6a4d6" name="a34d659ec14f4c5b2b847927734d6a4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d659ec14f4c5b2b847927734d6a4d6">&#9670;&#160;</a></span>STLSetDifference() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type gtl::STLSetDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append to output container, Implicit comparator. </p><dl class="section note"><dt>Note</dt><dd>The 'enable_if' keeps this overload from participating in overload resolution if 'out' is a function pointer, gracefully forcing the 3-argument overload that treats the third argument as a comparator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00613">613</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a68e6f9ee67c1545cc1da3d0b9a2ba0fd" name="a68e6f9ee67c1545cc1da3d0b9a2ba0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e6f9ee67c1545cc1da3d0b9a2ba0fd">&#9670;&#160;</a></span>STLSetDifference() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLSetDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STLSetDifference: </p><div class="fragment"><div class="line">In1 <a class="code hl_function" href="namespacegtl.html#a68e6f9ee67c1545cc1da3d0b9a2ba0fd">STLSetDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">In1 <a class="code hl_function" href="namespacegtl.html#a68e6f9ee67c1545cc1da3d0b9a2ba0fd">STLSetDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#a68e6f9ee67c1545cc1da3d0b9a2ba0fd">STLSetDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#a68e6f9ee67c1545cc1da3d0b9a2ba0fd">STLSetDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out, compare);</div>
<div class="line">Out STLSetDifferenceAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">Out STLSetDifferenceAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="ttc" id="aconstraint__solver_2table_8cc_html_a9293e4d29cac928301645070dd307683"><div class="ttname"><a href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a></div><div class="ttdeci">int64_t b</div><div class="ttdef"><b>Definition</b> <a href="constraint__solver_2table_8cc_source.html#l00048">table.cc:48</a></div></div>
<div class="ttc" id="aconstraint__solver_2table_8cc_html_acb18315d548212835cd8ed4287e6c0b6"><div class="ttname"><a href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a></div><div class="ttdeci">int64_t a</div><div class="ttdef"><b>Definition</b> <a href="constraint__solver_2table_8cc_source.html#l00047">table.cc:47</a></div></div>
<div class="ttc" id="anamespacegtl_html_a68e6f9ee67c1545cc1da3d0b9a2ba0fd"><div class="ttname"><a href="namespacegtl.html#a68e6f9ee67c1545cc1da3d0b9a2ba0fd">gtl::STLSetDifference</a></div><div class="ttdeci">void STLSetDifference(const In1 &amp;a, const In2 &amp;b, Out *out, Compare compare)</div><div class="ttdef"><b>Definition</b> <a href="stl__util_8h_source.html#l00595">stl_util.h:595</a></div></div>
</div><!-- fragment --><p> Appends the elements in "a" that are not in "b" to an output container. Optionally specify a comparator, or '&lt;' is used by default. Both input containers must be sorted with respect to the comparator. If specified, the output container must be distinct from both "a" and "b".</p>
<p>If an output container pointer is not given, a container will be returned by value. The return type can be explicitly specified by calling STLSetDifferenceAs, but it defaults to the type of argument "a".</p>
<p>See std::set_difference() for details on how set difference is computed.</p>
<p>The form taking 4 arguments. All other forms call into this one. Explicit comparator, append to output container. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00595">595</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a82f5a29f3a64de210350ed8d98fab4df" name="a82f5a29f3a64de210350ed8d98fab4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5a29f3a64de210350ed8d98fab4df">&#9670;&#160;</a></span>STLSetDifferenceAs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetDifferenceAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implicit comparator, explicit return type. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00625">625</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="ab749b0077b0a46f1a66b0792d9a9392b" name="ab749b0077b0a46f1a66b0792d9a9392b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab749b0077b0a46f1a66b0792d9a9392b">&#9670;&#160;</a></span>STLSetDifferenceAs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetDifferenceAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicit comparator, explicit return type. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00618">618</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a170f4dd90bac1ac8a80e81cdd6c73cdd" name="a170f4dd90bac1ac8a80e81cdd6c73cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170f4dd90bac1ac8a80e81cdd6c73cdd">&#9670;&#160;</a></span>STLSetIntersection() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetIntersection </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00823">823</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a53b24da0ff8191b893296df91f04325a" name="a53b24da0ff8191b893296df91f04325a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b24da0ff8191b893296df91f04325a">&#9670;&#160;</a></span>STLSetIntersection() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetIntersection </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00819">819</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a13b3e336e6a239ebe3c92b75a632313e" name="a13b3e336e6a239ebe3c92b75a632313e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b3e336e6a239ebe3c92b75a632313e">&#9670;&#160;</a></span>STLSetIntersection() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetIntersection </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00815">815</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="aac2e3c4f3f61577f78ca4b7fa7d159ce" name="aac2e3c4f3f61577f78ca4b7fa7d159ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2e3c4f3f61577f78ca4b7fa7d159ce">&#9670;&#160;</a></span>STLSetIntersection() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type gtl::STLSetIntersection </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The 'enable_if' keeps this overload from participating in overload resolution if 'out' is a function pointer, gracefully forcing the 3-argument overload that treats the third argument as a comparator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00799">799</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="aee59124b5b3d1e4feea4fc18ceaad6a9" name="aee59124b5b3d1e4feea4fc18ceaad6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee59124b5b3d1e4feea4fc18ceaad6a9">&#9670;&#160;</a></span>STLSetIntersection() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLSetIntersection </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STLSetIntersection: </p><div class="fragment"><div class="line">In1 <a class="code hl_function" href="namespacegtl.html#aee59124b5b3d1e4feea4fc18ceaad6a9">STLSetIntersection</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">In1 <a class="code hl_function" href="namespacegtl.html#aee59124b5b3d1e4feea4fc18ceaad6a9">STLSetIntersection</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#aee59124b5b3d1e4feea4fc18ceaad6a9">STLSetIntersection</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#aee59124b5b3d1e4feea4fc18ceaad6a9">STLSetIntersection</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out, compare);</div>
<div class="line">Out STLSetIntersectionAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">Out STLSetIntersectionAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="ttc" id="anamespacegtl_html_aee59124b5b3d1e4feea4fc18ceaad6a9"><div class="ttname"><a href="namespacegtl.html#aee59124b5b3d1e4feea4fc18ceaad6a9">gtl::STLSetIntersection</a></div><div class="ttdeci">void STLSetIntersection(const In1 &amp;a, const In2 &amp;b, Out *out, Compare compare)</div><div class="ttdef"><b>Definition</b> <a href="stl__util_8h_source.html#l00782">stl_util.h:782</a></div></div>
</div><!-- fragment --><p> Appends the elements that are in both "a" and "b" to output container "out". Both input containers must be sorted with operator '&lt;' or with "compare" if specified. "out" must be distinct from both "a" and "b".</p>
<p>See std::set_intersection() for how set intersection is computed. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00782">782</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a164fbb88e843abba3619fbc09431df88" name="a164fbb88e843abba3619fbc09431df88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164fbb88e843abba3619fbc09431df88">&#9670;&#160;</a></span>STLSetIntersectionAs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetIntersectionAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00810">810</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a27406749fc6b129b31ac45eb056ea410" name="a27406749fc6b129b31ac45eb056ea410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27406749fc6b129b31ac45eb056ea410">&#9670;&#160;</a></span>STLSetIntersectionAs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetIntersectionAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00804">804</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="aeae914498ef2a2c98cff5fbd7c16e61b" name="aeae914498ef2a2c98cff5fbd7c16e61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae914498ef2a2c98cff5fbd7c16e61b">&#9670;&#160;</a></span>STLSetSymmetricDifference() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00762">762</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a72531dab8ec5c4dae1f6093a72c3717f" name="a72531dab8ec5c4dae1f6093a72c3717f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72531dab8ec5c4dae1f6093a72c3717f">&#9670;&#160;</a></span>STLSetSymmetricDifference() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00757">757</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a7875a76c06f5c36d3687eed147df997d" name="a7875a76c06f5c36d3687eed147df997d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7875a76c06f5c36d3687eed147df997d">&#9670;&#160;</a></span>STLSetSymmetricDifference() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00753">753</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a8e2b682785bf02b8427fa17a2ec824a7" name="a8e2b682785bf02b8427fa17a2ec824a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2b682785bf02b8427fa17a2ec824a7">&#9670;&#160;</a></span>STLSetSymmetricDifference() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type gtl::STLSetSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The 'enable_if' keeps this overload from participating in overload resolution if 'out' is a function pointer, gracefully forcing the 3-argument overload that treats the third argument as a comparator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00737">737</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a8da478efe824239819e7b1278a7f6f5f" name="a8da478efe824239819e7b1278a7f6f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da478efe824239819e7b1278a7f6f5f">&#9670;&#160;</a></span>STLSetSymmetricDifference() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLSetSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STLSetSymmetricDifference: </p><div class="fragment"><div class="line">In1 <a class="code hl_function" href="namespacegtl.html#a8da478efe824239819e7b1278a7f6f5f">STLSetSymmetricDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">In1 <a class="code hl_function" href="namespacegtl.html#a8da478efe824239819e7b1278a7f6f5f">STLSetSymmetricDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#a8da478efe824239819e7b1278a7f6f5f">STLSetSymmetricDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#a8da478efe824239819e7b1278a7f6f5f">STLSetSymmetricDifference</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out, compare);</div>
<div class="line">Out STLSetSymmetricDifferenceAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">Out STLSetSymmetricDifferenceAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="ttc" id="anamespacegtl_html_a8da478efe824239819e7b1278a7f6f5f"><div class="ttname"><a href="namespacegtl.html#a8da478efe824239819e7b1278a7f6f5f">gtl::STLSetSymmetricDifference</a></div><div class="ttdeci">void STLSetSymmetricDifference(const In1 &amp;a, const In2 &amp;b, Out *out, Compare compare)</div><div class="ttdef"><b>Definition</b> <a href="stl__util_8h_source.html#l00719">stl_util.h:719</a></div></div>
</div><!-- fragment --><p> Appends the elements in "a" that are not in "b", and the elements in "b" that are not in "a", to output container "out". Both input containers must be sorted with operator '&lt;', or with the comparator if specified. "out" must be distinct from both "a" and "b".</p>
<p>See std::set_symmetric_difference() for how these elements are selected. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00719">719</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="ab9836946f5a578dfc175c38b0159b9d8" name="ab9836946f5a578dfc175c38b0159b9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9836946f5a578dfc175c38b0159b9d8">&#9670;&#160;</a></span>STLSetSymmetricDifferenceAs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetSymmetricDifferenceAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00748">748</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a7b8c075da0fea613720ee035e0ae914e" name="a7b8c075da0fea613720ee035e0ae914e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8c075da0fea613720ee035e0ae914e">&#9670;&#160;</a></span>STLSetSymmetricDifferenceAs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetSymmetricDifferenceAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00742">742</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a744d87cbc72fdcd1d7195f445513b3c2" name="a744d87cbc72fdcd1d7195f445513b3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744d87cbc72fdcd1d7195f445513b3c2">&#9670;&#160;</a></span>STLSetUnion() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetUnion </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00699">699</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a336e2142912eb8d3188b940de10e25a6" name="a336e2142912eb8d3188b940de10e25a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336e2142912eb8d3188b940de10e25a6">&#9670;&#160;</a></span>STLSetUnion() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetUnion </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00695">695</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a3e76d0d1333e3f7729ffb523e1c53b81" name="a3e76d0d1333e3f7729ffb523e1c53b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e76d0d1333e3f7729ffb523e1c53b81">&#9670;&#160;</a></span>STLSetUnion() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">In1 gtl::STLSetUnion </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00691">691</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a6b31dd30ff87bbd1625e34c9ed46b427" name="a6b31dd30ff87bbd1625e34c9ed46b427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b31dd30ff87bbd1625e34c9ed46b427">&#9670;&#160;</a></span>STLSetUnion() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_function&lt; Out &gt;<a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">::value</a>, void &gt;::type gtl::STLSetUnion </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The 'enable_if' keeps this overload from participating in overload resolution if 'out' is a function pointer, gracefully forcing the 3-argument overload that treats the third argument as a comparator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00676">676</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a2dd9f986b9af62c1844969ee8a9e008d" name="a2dd9f986b9af62c1844969ee8a9e008d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd9f986b9af62c1844969ee8a9e008d">&#9670;&#160;</a></span>STLSetUnion() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename In1 , typename In2 , typename Out , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLSetUnion </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STLSetUnion: </p><div class="fragment"><div class="line">In1 <a class="code hl_function" href="namespacegtl.html#a2dd9f986b9af62c1844969ee8a9e008d">STLSetUnion</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">In1 <a class="code hl_function" href="namespacegtl.html#a2dd9f986b9af62c1844969ee8a9e008d">STLSetUnion</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#a2dd9f986b9af62c1844969ee8a9e008d">STLSetUnion</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="namespacegtl.html#a2dd9f986b9af62c1844969ee8a9e008d">STLSetUnion</a>(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, &amp;out, compare);</div>
<div class="line">Out STLSetUnionAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>);</div>
<div class="line">Out STLSetUnionAs&lt;Out&gt;(<a class="code hl_variable" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="code hl_variable" href="constraint__solver_2table_8cc.html#a9293e4d29cac928301645070dd307683">b</a>, compare);</div>
<div class="ttc" id="anamespacegtl_html_a2dd9f986b9af62c1844969ee8a9e008d"><div class="ttname"><a href="namespacegtl.html#a2dd9f986b9af62c1844969ee8a9e008d">gtl::STLSetUnion</a></div><div class="ttdeci">void STLSetUnion(const In1 &amp;a, const In2 &amp;b, Out *out, Compare compare)</div><div class="ttdef"><b>Definition</b> <a href="stl__util_8h_source.html#l00660">stl_util.h:660</a></div></div>
</div><!-- fragment --><p> Appends the elements in one or both of the input containers to output container "out". Both input containers must be sorted with operator '&lt;', or with the comparator if specified. "out" must be distinct from both "a" and "b".</p>
<p>See std::set_union() for how set union is computed. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00660">660</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a98438211ff98a199a7256eb55c32e75e" name="a98438211ff98a199a7256eb55c32e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98438211ff98a199a7256eb55c32e75e">&#9670;&#160;</a></span>STLSetUnionAs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetUnionAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00687">687</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a79e72b8b095b2e7dc9543f8ea6406756" name="a79e72b8b095b2e7dc9543f8ea6406756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e72b8b095b2e7dc9543f8ea6406756">&#9670;&#160;</a></span>STLSetUnionAs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename In1 , typename In2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Out gtl::STLSetUnionAs </td>
          <td>(</td>
          <td class="paramtype">const In1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const In2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00681">681</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a219f8706705d21297348360e7b014d97" name="a219f8706705d21297348360e7b014d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219f8706705d21297348360e7b014d97">&#9670;&#160;</a></span>STLSortAndRemoveDuplicates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLSortAndRemoveDuplicates </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00065">65</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a288a1dc92da5d3ad62d4bc4cec9e8b1d" name="a288a1dc92da5d3ad62d4bc4cec9e8b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288a1dc92da5d3ad62d4bc4cec9e8b1d">&#9670;&#160;</a></span>STLSortAndRemoveDuplicates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LessFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLSortAndRemoveDuplicates </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LessFunc &amp;&#160;</td>
          <td class="paramname"><em>less_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts and removes duplicates from a sequence container. If specified, the 'less_func' is used to compose an equivalence comparator for the sorting and uniqueness tests. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00058">58</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a1a7ebcfb97acea44aeba8518597b7572" name="a1a7ebcfb97acea44aeba8518597b7572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7ebcfb97acea44aeba8518597b7572">&#9670;&#160;</a></span>STLStableSortAndRemoveDuplicates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLStableSortAndRemoveDuplicates </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stable sorts and removes duplicates from a sequence container, retaining the first equivalent element for each equivalence set, using &lt; comparison and == equivalence testing. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00085">85</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a644fbff1e423c6f7e21e31b0c5942cc1" name="a644fbff1e423c6f7e21e31b0c5942cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644fbff1e423c6f7e21e31b0c5942cc1">&#9670;&#160;</a></span>STLStableSortAndRemoveDuplicates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LessFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLStableSortAndRemoveDuplicates </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LessFunc &amp;&#160;</td>
          <td class="paramname"><em>less_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stable sorts and removes duplicates from a sequence container, retaining the first equivalent element for each equivalence set. The 'less_func' is used to compose an equivalence comparator for the sorting and uniqueness tests. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00075">75</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="afce1c176bd7c77b4d20245cecf80d0b2" name="afce1c176bd7c77b4d20245cecf80d0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce1c176bd7c77b4d20245cecf80d0b2">&#9670;&#160;</a></span>STLStringReserveIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLStringReserveIfNeeded </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserves space in the given string only if the existing capacity is not already enough. This is useful for strings because string::reserve() may <em>shrink</em> the capacity in some cases, which is usually not what users want. The behavior of this function is similar to that of vector::reserve() but for string. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00194">194</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a68a9fdc8d80f428bfb1d6785df0f2049" name="a68a9fdc8d80f428bfb1d6785df0f2049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a9fdc8d80f428bfb1d6785df0f2049">&#9670;&#160;</a></span>STLStringResizeUninitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtl::STLStringResizeUninitialized </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; T, Traits, Alloc &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like str-&gt;resize(new_size), except any new characters added to "*str" as a result of resizing may be left uninitialized, rather than being filled with '0' bytes. Typically used when code is then going to overwrite the backing store of the string with known data. </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00203">203</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="a5e1121a94564be31fe7a06032eaa591f" name="a5e1121a94564be31fe7a06032eaa591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1121a94564be31fe7a06032eaa591f">&#9670;&#160;</a></span>STLStringSupportsNontrashingResize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gtl::STLStringSupportsNontrashingResize </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T, Traits, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the string implementation supports a resize where the new characters added to the string are left untouched.</p>
<p>(A better name might be "STLStringSupportsUninitializedResize", alluding to the previous function.) </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00214">214</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="ab85c1d939763eb4f7afba53cf0da49ba" name="ab85c1d939763eb4f7afba53cf0da49ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85c1d939763eb4f7afba53cf0da49ba">&#9670;&#160;</a></span>string_as_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * gtl::string_as_array </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a mutable char* pointing to a string's internal buffer, which may not be null-terminated. Returns nullptr for an empty string. If not non-null, writing through this pointer will modify the string.</p>
<p>string_as_array(&amp;str)[i] is valid for 0 &lt;= i &lt; str.size() until the next call to a string method that invalidates iterators.</p>
<p>In C++11 you may simply use &amp;str[0] to get a mutable char*.</p>
<p>Prior to C++11, there was no standard-blessed way of getting a mutable reference to a string's internal buffer. The requirement that string be contiguous is officially part of the C++11 standard [string.require]/5. According to Matt Austern, this should already work on all current C++98 implementations. </p>
<p>DO NOT USE const_cast&lt;char*&gt;(str-&gt;data())! See the unittest for why.</p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00260">260</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afce6b52584bb29e142d51b262b8451e5" name="afce6b52584bb29e142d51b262b8451e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce6b52584bb29e142d51b262b8451e5">&#9670;&#160;</a></span>ABSL_ATTRIBUTE_PACKED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classgtl_1_1IntType.html">gtl::IntType</a> gtl::ABSL_ATTRIBUTE_PACKED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegtl.html">gtl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
