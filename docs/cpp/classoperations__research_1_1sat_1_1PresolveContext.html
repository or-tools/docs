<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::PresolveContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1PresolveContext.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classoperations__research_1_1sat_1_1PresolveContext-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::PresolveContext Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ace44b7515ea8289bbc7878a9f90f94e3" id="r_ace44b7515ea8289bbc7878a9f90f94e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace44b7515ea8289bbc7878a9f90f94e3">PresolveContext</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *model, CpModelProto *cp_model, CpModelProto *mapping)</td></tr>
<tr class="separator:ace44b7515ea8289bbc7878a9f90f94e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e2f15d439243fcc447d48fe120624e" id="r_a38e2f15d439243fcc447d48fe120624e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38e2f15d439243fcc447d48fe120624e">NewIntVar</a> (const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain)</td></tr>
<tr class="memdesc:a38e2f15d439243fcc447d48fe120624e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers to adds new variables to the presolved model.  <br /></td></tr>
<tr class="separator:a38e2f15d439243fcc447d48fe120624e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fe14466fe82586570c22769cfae527" id="r_a65fe14466fe82586570c22769cfae527"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65fe14466fe82586570c22769cfae527">NewBoolVar</a> (absl::string_view source)</td></tr>
<tr class="separator:a65fe14466fe82586570c22769cfae527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2b400df7ac9b5f827da6414de38553" id="r_a2f2b400df7ac9b5f827da6414de38553"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f2b400df7ac9b5f827da6414de38553">NewIntVarWithDefinition</a> (const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain, absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; definition, bool append_constraint_to_mapping_model=false)</td></tr>
<tr class="separator:a2f2b400df7ac9b5f827da6414de38553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760d703f051fb4cbb1df929049eb24e1" id="r_a760d703f051fb4cbb1df929049eb24e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760d703f051fb4cbb1df929049eb24e1">NewBoolVarWithClause</a> (absl::Span&lt; const int &gt; clause)</td></tr>
<tr class="separator:a760d703f051fb4cbb1df929049eb24e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af671882580db883e4a7467904227e0e8" id="r_af671882580db883e4a7467904227e0e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af671882580db883e4a7467904227e0e8">NewBoolVarWithConjunction</a> (absl::Span&lt; const int &gt; conjunction)</td></tr>
<tr class="separator:af671882580db883e4a7467904227e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a267b655bc398f01613bb195a7cb61f" id="r_a3a267b655bc398f01613bb195a7cb61f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a267b655bc398f01613bb195a7cb61f">GetTrueLiteral</a> ()</td></tr>
<tr class="separator:a3a267b655bc398f01613bb195a7cb61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa692158541395ad5e1f53a236de60ba5" id="r_aa692158541395ad5e1f53a236de60ba5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa692158541395ad5e1f53a236de60ba5">GetFalseLiteral</a> ()</td></tr>
<tr class="separator:aa692158541395ad5e1f53a236de60ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b5d3417fd42df1be2401e867caae2c" id="r_a34b5d3417fd42df1be2401e867caae2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34b5d3417fd42df1be2401e867caae2c">AddImplication</a> (int a, int <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a34b5d3417fd42df1be2401e867caae2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a =&gt; b.  <br /></td></tr>
<tr class="separator:a34b5d3417fd42df1be2401e867caae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5670894aad056fc4452807432b031858" id="r_a5670894aad056fc4452807432b031858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5670894aad056fc4452807432b031858">AddImplyInDomain</a> (int <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, int x, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain)</td></tr>
<tr class="memdesc:a5670894aad056fc4452807432b031858"><td class="mdescLeft">&#160;</td><td class="mdescRight">b =&gt; (x ∈ domain).  <br /></td></tr>
<tr class="separator:a5670894aad056fc4452807432b031858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3102d3d48b1fe0e958283ece21720a37" id="r_a3102d3d48b1fe0e958283ece21720a37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3102d3d48b1fe0e958283ece21720a37">AddImplyInDomain</a> (int <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, const LinearExpressionProto &amp;expr, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain)</td></tr>
<tr class="memdesc:a3102d3d48b1fe0e958283ece21720a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">b =&gt; (expr ∈ domain).  <br /></td></tr>
<tr class="separator:a3102d3d48b1fe0e958283ece21720a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa30837da268a9688f608013d857a7e" id="r_a2fa30837da268a9688f608013d857a7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fa30837da268a9688f608013d857a7e">DomainIsEmpty</a> (int ref) const</td></tr>
<tr class="memdesc:a2fa30837da268a9688f608013d857a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers to query the current domain of a variable.  <br /></td></tr>
<tr class="separator:a2fa30837da268a9688f608013d857a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1d359c4b268649c50d4c848c6aec0b" id="r_a4c1d359c4b268649c50d4c848c6aec0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c1d359c4b268649c50d4c848c6aec0b">IsFixed</a> (int ref) const</td></tr>
<tr class="separator:a4c1d359c4b268649c50d4c848c6aec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac995d5af22b14671e9e6ac5f7fa67fa6" id="r_ac995d5af22b14671e9e6ac5f7fa67fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac995d5af22b14671e9e6ac5f7fa67fa6">CanBeUsedAsLiteral</a> (int ref) const</td></tr>
<tr class="separator:ac995d5af22b14671e9e6ac5f7fa67fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8a0ca253cecac31ee6f9593992e56" id="r_afdb8a0ca253cecac31ee6f9593992e56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdb8a0ca253cecac31ee6f9593992e56">LiteralIsTrue</a> (int lit) const</td></tr>
<tr class="separator:afdb8a0ca253cecac31ee6f9593992e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc31dece12725d389ef55c86fde8d9b" id="r_a2cc31dece12725d389ef55c86fde8d9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cc31dece12725d389ef55c86fde8d9b">LiteralIsFalse</a> (int lit) const</td></tr>
<tr class="separator:a2cc31dece12725d389ef55c86fde8d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c777be53b24b90df4e7be5969d95fa" id="r_ad5c777be53b24b90df4e7be5969d95fa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5c777be53b24b90df4e7be5969d95fa">MinOf</a> (int ref) const</td></tr>
<tr class="separator:ad5c777be53b24b90df4e7be5969d95fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a56a53bed03585a5cba71fa3ea69be" id="r_ad9a56a53bed03585a5cba71fa3ea69be"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9a56a53bed03585a5cba71fa3ea69be">MaxOf</a> (int ref) const</td></tr>
<tr class="separator:ad9a56a53bed03585a5cba71fa3ea69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34067a2486e93d9eac27e465f9524aca" id="r_a34067a2486e93d9eac27e465f9524aca"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34067a2486e93d9eac27e465f9524aca">FixedValue</a> (int ref) const</td></tr>
<tr class="separator:a34067a2486e93d9eac27e465f9524aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b356c25b8affdfd9fd143751a429ca" id="r_af2b356c25b8affdfd9fd143751a429ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2b356c25b8affdfd9fd143751a429ca">DomainContains</a> (int ref, int64_t value) const</td></tr>
<tr class="separator:af2b356c25b8affdfd9fd143751a429ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044c0a30b120ca82eabf648156ce3d19" id="r_a044c0a30b120ca82eabf648156ce3d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044c0a30b120ca82eabf648156ce3d19">DomainOf</a> (int ref) const</td></tr>
<tr class="separator:a044c0a30b120ca82eabf648156ce3d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8192e7518d905cd6d6eb812ba8a530c8" id="r_a8192e7518d905cd6d6eb812ba8a530c8"><td class="memItemLeft" align="right" valign="top">absl::Span&lt; const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8192e7518d905cd6d6eb812ba8a530c8">AllDomains</a> () const</td></tr>
<tr class="separator:a8192e7518d905cd6d6eb812ba8a530c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e32308d4beea978b37461768798091" id="r_a34e32308d4beea978b37461768798091"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34e32308d4beea978b37461768798091">IntervalIsConstant</a> (int ct_ref) const</td></tr>
<tr class="memdesc:a34e32308d4beea978b37461768798091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to query the state of an interval.  <br /></td></tr>
<tr class="separator:a34e32308d4beea978b37461768798091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad060a6d7defa84a7a3b9e194f640a7d4" id="r_ad060a6d7defa84a7a3b9e194f640a7d4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad060a6d7defa84a7a3b9e194f640a7d4">StartMin</a> (int ct_ref) const</td></tr>
<tr class="separator:ad060a6d7defa84a7a3b9e194f640a7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb69d4b9fe286e3825190b0afdd3452" id="r_a9cb69d4b9fe286e3825190b0afdd3452"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb69d4b9fe286e3825190b0afdd3452">StartMax</a> (int ct_ref) const</td></tr>
<tr class="separator:a9cb69d4b9fe286e3825190b0afdd3452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58662aa4ff75862225aa88d319c423ac" id="r_a58662aa4ff75862225aa88d319c423ac"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58662aa4ff75862225aa88d319c423ac">SizeMin</a> (int ct_ref) const</td></tr>
<tr class="separator:a58662aa4ff75862225aa88d319c423ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47955e47d62eaffce306ff330e7f7826" id="r_a47955e47d62eaffce306ff330e7f7826"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47955e47d62eaffce306ff330e7f7826">SizeMax</a> (int ct_ref) const</td></tr>
<tr class="separator:a47955e47d62eaffce306ff330e7f7826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2df4dacfec58076552318ce49afd4e" id="r_a4f2df4dacfec58076552318ce49afd4e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f2df4dacfec58076552318ce49afd4e">EndMin</a> (int ct_ref) const</td></tr>
<tr class="separator:a4f2df4dacfec58076552318ce49afd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5098e7cbef49fc9630e1e3c4622f7b73" id="r_a5098e7cbef49fc9630e1e3c4622f7b73"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5098e7cbef49fc9630e1e3c4622f7b73">EndMax</a> (int ct_ref) const</td></tr>
<tr class="separator:a5098e7cbef49fc9630e1e3c4622f7b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ad52aff108d76ac1171f9442a0b982" id="r_a49ad52aff108d76ac1171f9442a0b982"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49ad52aff108d76ac1171f9442a0b982">IntervalDebugString</a> (int ct_ref) const</td></tr>
<tr class="separator:a49ad52aff108d76ac1171f9442a0b982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76145cb4d679559edda7c09d4008dab6" id="r_a76145cb4d679559edda7c09d4008dab6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76145cb4d679559edda7c09d4008dab6">MinOf</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="separator:a76145cb4d679559edda7c09d4008dab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7962f28e1a59532176ee5af3313fb81c" id="r_a7962f28e1a59532176ee5af3313fb81c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7962f28e1a59532176ee5af3313fb81c">MaxOf</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="separator:a7962f28e1a59532176ee5af3313fb81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ec01005eca2e8acd89dd803a909c47" id="r_a92ec01005eca2e8acd89dd803a909c47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92ec01005eca2e8acd89dd803a909c47">IsFixed</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="separator:a92ec01005eca2e8acd89dd803a909c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85526dd2e4d2a34d323a91e05df368" id="r_a1a85526dd2e4d2a34d323a91e05df368"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a85526dd2e4d2a34d323a91e05df368">FixedValue</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="separator:a1a85526dd2e4d2a34d323a91e05df368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff962ccabd1ddb157562b0620c50639" id="r_a7ff962ccabd1ddb157562b0620c50639"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ff962ccabd1ddb157562b0620c50639">FixedValueOrNullopt</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="memdesc:a7ff962ccabd1ddb157562b0620c50639"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is faster than testing <a class="el" href="#a4c1d359c4b268649c50d4c848c6aec0b">IsFixed()</a> + <a class="el" href="#a34067a2486e93d9eac27e465f9524aca">FixedValue()</a>.  <br /></td></tr>
<tr class="separator:a7ff962ccabd1ddb157562b0620c50639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623bc44b1287fc333a3210b8e2282b5f" id="r_a623bc44b1287fc333a3210b8e2282b5f"><td class="memTemplParams" colspan="2">template&lt;typename ProtoWithVarsAndCoeffs&gt; </td></tr>
<tr class="memitem:a623bc44b1287fc333a3210b8e2282b5f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a623bc44b1287fc333a3210b8e2282b5f">ComputeMinMaxActivity</a> (const ProtoWithVarsAndCoeffs &amp;proto) const</td></tr>
<tr class="separator:a623bc44b1287fc333a3210b8e2282b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e457fe5fabd8656ded206a1d5416937" id="r_a5e457fe5fabd8656ded206a1d5416937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e457fe5fabd8656ded206a1d5416937">CappedUpdateMinMaxActivity</a> (int var, int64_t coeff, int64_t *min_activity, int64_t *max_activity)</td></tr>
<tr class="memdesc:a5e457fe5fabd8656ded206a1d5416937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function.  <br /></td></tr>
<tr class="separator:a5e457fe5fabd8656ded206a1d5416937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9cfa1ea87ca40b15c2ed4ce25d8d14" id="r_afc9cfa1ea87ca40b15c2ed4ce25d8d14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc9cfa1ea87ca40b15c2ed4ce25d8d14">CanonicalizeLinearConstraint</a> (ConstraintProto *ct)</td></tr>
<tr class="separator:afc9cfa1ea87ca40b15c2ed4ce25d8d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf474172c863fee40c3f7a4b1f27c7f5" id="r_aaf474172c863fee40c3f7a4b1f27c7f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf474172c863fee40c3f7a4b1f27c7f5">CanonicalizeLinearExpression</a> (absl::Span&lt; const int &gt; enforcements, LinearExpressionProto *expr)</td></tr>
<tr class="separator:aaf474172c863fee40c3f7a4b1f27c7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0fa3dc65c8a6b695024acd5ffd3f0f" id="r_a1e0fa3dc65c8a6b695024acd5ffd3f0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e0fa3dc65c8a6b695024acd5ffd3f0f">DomainContains</a> (const LinearExpressionProto &amp;expr, int64_t value) const</td></tr>
<tr class="memdesc:a1e0fa3dc65c8a6b695024acd5ffd3f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This methods only works for affine expressions (checked).  <br /></td></tr>
<tr class="separator:a1e0fa3dc65c8a6b695024acd5ffd3f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d914783666534a61a6032f9c77bf34" id="r_a83d914783666534a61a6032f9c77bf34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83d914783666534a61a6032f9c77bf34">DomainSuperSetOf</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="memdesc:a83d914783666534a61a6032f9c77bf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a super-set of the domain of the linear expression.  <br /></td></tr>
<tr class="separator:a83d914783666534a61a6032f9c77bf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1bc99af7b7f09a7af40dc25905724b" id="r_a4b1bc99af7b7f09a7af40dc25905724b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b1bc99af7b7f09a7af40dc25905724b">ExpressionIsAffineBoolean</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="separator:a4b1bc99af7b7f09a7af40dc25905724b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55b4a0e9ef1a0345a8787a702471fd6" id="r_aa55b4a0e9ef1a0345a8787a702471fd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa55b4a0e9ef1a0345a8787a702471fd6">LiteralForExpressionMax</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="separator:aa55b4a0e9ef1a0345a8787a702471fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6584f3002678b48e00c3405472ed5f" id="r_a0e6584f3002678b48e00c3405472ed5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e6584f3002678b48e00c3405472ed5f">ExpressionIsSingleVariable</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="memdesc:a0e6584f3002678b48e00c3405472ed5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the expr is of the form 1 * var + 0.  <br /></td></tr>
<tr class="separator:a0e6584f3002678b48e00c3405472ed5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188528e271a7307bead68d00d351f4ef" id="r_a188528e271a7307bead68d00d351f4ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188528e271a7307bead68d00d351f4ef">ExpressionIsALiteral</a> (const LinearExpressionProto &amp;expr, int *literal=nullptr) const</td></tr>
<tr class="memdesc:a188528e271a7307bead68d00d351f4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the expr is a literal (x or not(x)).  <br /></td></tr>
<tr class="separator:a188528e271a7307bead68d00d351f4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c55b01ac54cd61519d8899d5badac8" id="r_ab1c55b01ac54cd61519d8899d5badac8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1c55b01ac54cd61519d8899d5badac8">DomainOfVarIsIncludedIn</a> (int var, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain)</td></tr>
<tr class="memdesc:ab1c55b01ac54cd61519d8899d5badac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a positive variable reference.  <br /></td></tr>
<tr class="separator:ab1c55b01ac54cd61519d8899d5badac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f26296a4c9f4280fda73ffed51d0eed" id="r_a8f26296a4c9f4280fda73ffed51d0eed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f26296a4c9f4280fda73ffed51d0eed">VariableIsUnique</a> (int ref) const</td></tr>
<tr class="memdesc:a8f26296a4c9f4280fda73ffed51d0eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this ref only appear in one constraint.  <br /></td></tr>
<tr class="separator:a8f26296a4c9f4280fda73ffed51d0eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbe5a730a5b9ed96b24c2c123e1c346" id="r_a1cbe5a730a5b9ed96b24c2c123e1c346"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cbe5a730a5b9ed96b24c2c123e1c346">VariableIsUniqueAndRemovable</a> (int ref) const</td></tr>
<tr class="separator:a1cbe5a730a5b9ed96b24c2c123e1c346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a019b435421dc660539167f29ec3e10" id="r_a8a019b435421dc660539167f29ec3e10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a019b435421dc660539167f29ec3e10">VariableIsNotUsedAnymore</a> (int ref) const</td></tr>
<tr class="memdesc:a8a019b435421dc660539167f29ec3e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this ref no longer appears in the model.  <br /></td></tr>
<tr class="separator:a8a019b435421dc660539167f29ec3e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe671160075d401086f71cac18bfef45" id="r_abe671160075d401086f71cac18bfef45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe671160075d401086f71cac18bfef45">MarkVariableAsRemoved</a> (int ref)</td></tr>
<tr class="separator:abe671160075d401086f71cac18bfef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9027a47ca0ff076eb618b4bbbb3eaffe" id="r_a9027a47ca0ff076eb618b4bbbb3eaffe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9027a47ca0ff076eb618b4bbbb3eaffe">VariableWasRemoved</a> (int ref) const</td></tr>
<tr class="separator:a9027a47ca0ff076eb618b4bbbb3eaffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3462352cb8945d9a90ef835a5413409" id="r_ae3462352cb8945d9a90ef835a5413409"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3462352cb8945d9a90ef835a5413409">VariableWithCostIsUnique</a> (int ref) const</td></tr>
<tr class="separator:ae3462352cb8945d9a90ef835a5413409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc7d287336c388e703889282993257d" id="r_a2dc7d287336c388e703889282993257d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dc7d287336c388e703889282993257d">VariableWithCostIsUniqueAndRemovable</a> (int ref) const</td></tr>
<tr class="separator:a2dc7d287336c388e703889282993257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5987035843beaea2cadbd7ab5a78889a" id="r_a5987035843beaea2cadbd7ab5a78889a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5987035843beaea2cadbd7ab5a78889a">VariableIsOnlyUsedInEncodingAndMaybeInObjective</a> (int var) const</td></tr>
<tr class="separator:a5987035843beaea2cadbd7ab5a78889a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507c1fe68c32e41d59517d951b1ea532" id="r_a507c1fe68c32e41d59517d951b1ea532"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a507c1fe68c32e41d59517d951b1ea532">VariableIsOnlyUsedInLinear1AndOneExtraConstraint</a> (int var) const</td></tr>
<tr class="separator:a507c1fe68c32e41d59517d951b1ea532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183cbc89ee5ff7b8bccefe3611ea9676" id="r_a183cbc89ee5ff7b8bccefe3611ea9676"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a183cbc89ee5ff7b8bccefe3611ea9676">IntersectDomainWith</a> (int ref, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain, bool *domain_modified=nullptr)</td></tr>
<tr class="separator:a183cbc89ee5ff7b8bccefe3611ea9676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394e849d9191a33e5052df380f79d0e4" id="r_a394e849d9191a33e5052df380f79d0e4"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394e849d9191a33e5052df380f79d0e4">SetLiteralToFalse</a> (int lit)</td></tr>
<tr class="memdesc:a394e849d9191a33e5052df380f79d0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the 'lit' doesn't have the desired value in the domain.  <br /></td></tr>
<tr class="separator:a394e849d9191a33e5052df380f79d0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2aab8b3e16828d9adda83f1c7a3dd0" id="r_a2a2aab8b3e16828d9adda83f1c7a3dd0"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a2aab8b3e16828d9adda83f1c7a3dd0">SetLiteralToTrue</a> (int lit)</td></tr>
<tr class="separator:a2a2aab8b3e16828d9adda83f1c7a3dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c0765d4c9e3b2ab0d3974aa7b192d0" id="r_a69c0765d4c9e3b2ab0d3974aa7b192d0"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69c0765d4c9e3b2ab0d3974aa7b192d0">IntersectDomainWith</a> (const LinearExpressionProto &amp;expr, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain, bool *domain_modified=nullptr)</td></tr>
<tr class="separator:a69c0765d4c9e3b2ab0d3974aa7b192d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee008e9272dbcc3132a667eefc41923" id="r_a3ee008e9272dbcc3132a667eefc41923"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ee008e9272dbcc3132a667eefc41923">NotifyThatModelIsUnsat</a> (absl::string_view message=&quot;&quot;)</td></tr>
<tr class="separator:a3ee008e9272dbcc3132a667eefc41923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c2e4b921ea89bdfc12181513bf28e4" id="r_af4c2e4b921ea89bdfc12181513bf28e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c2e4b921ea89bdfc12181513bf28e4">ModelIsUnsat</a> () const</td></tr>
<tr class="separator:af4c2e4b921ea89bdfc12181513bf28e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43f7366b32b2ac40cc0f7f668040c49" id="r_ab43f7366b32b2ac40cc0f7f668040c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab43f7366b32b2ac40cc0f7f668040c49">UpdateRuleStats</a> (const std::string &amp;name, int num_times=1)</td></tr>
<tr class="separator:ab43f7366b32b2ac40cc0f7f668040c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaebbe40a33ffb948566c7fb2ec6ad03" id="r_aaaebbe40a33ffb948566c7fb2ec6ad03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaebbe40a33ffb948566c7fb2ec6ad03">UpdateConstraintVariableUsage</a> (int c)</td></tr>
<tr class="separator:aaaebbe40a33ffb948566c7fb2ec6ad03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3712d2df9a0fb81962a7d9a528d699" id="r_a9b3712d2df9a0fb81962a7d9a528d699"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3712d2df9a0fb81962a7d9a528d699">ConstraintVariableGraphIsUpToDate</a> () const</td></tr>
<tr class="separator:a9b3712d2df9a0fb81962a7d9a528d699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a2f700fb28455324dd0268a9d510b" id="r_ac58a2f700fb28455324dd0268a9d510b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac58a2f700fb28455324dd0268a9d510b">UpdateNewConstraintsVariableUsage</a> ()</td></tr>
<tr class="memdesc:ac58a2f700fb28455324dd0268a9d510b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="#aaaebbe40a33ffb948566c7fb2ec6ad03">UpdateConstraintVariableUsage()</a> on all newly created constraints.  <br /></td></tr>
<tr class="separator:ac58a2f700fb28455324dd0268a9d510b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa9e96fd82123e73419f70c85690153" id="r_acfa9e96fd82123e73419f70c85690153"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfa9e96fd82123e73419f70c85690153">ConstraintVariableUsageIsConsistent</a> ()</td></tr>
<tr class="separator:acfa9e96fd82123e73419f70c85690153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a201fc9782615c652c779e56324388" id="r_a41a201fc9782615c652c779e56324388"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41a201fc9782615c652c779e56324388">HasUnusedAffineVariable</a> () const</td></tr>
<tr class="separator:a41a201fc9782615c652c779e56324388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccc5bf972c4cfe911eb430e97dd3c57" id="r_a2ccc5bf972c4cfe911eb430e97dd3c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ccc5bf972c4cfe911eb430e97dd3c57">CanonicalizeVariable</a> (int ref)</td></tr>
<tr class="separator:a2ccc5bf972c4cfe911eb430e97dd3c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8e358d0b25f1ccf7eeeb29a32aabde" id="r_a0e8e358d0b25f1ccf7eeeb29a32aabde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e8e358d0b25f1ccf7eeeb29a32aabde">CanonicalizeAffineVariable</a> (int ref, int64_t coeff, int64_t mod, int64_t rhs)</td></tr>
<tr class="separator:a0e8e358d0b25f1ccf7eeeb29a32aabde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f9fb012d35d444b8d3438157f5c9c3" id="r_a21f9fb012d35d444b8d3438157f5c9c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f9fb012d35d444b8d3438157f5c9c3">StoreAffineRelation</a> (int var_x, int var_y, int64_t coeff, int64_t offset, bool debug_no_recursion=false)</td></tr>
<tr class="separator:a21f9fb012d35d444b8d3438157f5c9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553eb7c65eeadc906305afd24c6e8ef5" id="r_a553eb7c65eeadc906305afd24c6e8ef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a553eb7c65eeadc906305afd24c6e8ef5">StoreBooleanEqualityRelation</a> (int ref_a, int ref_b)</td></tr>
<tr class="separator:a553eb7c65eeadc906305afd24c6e8ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08f3a483dad1815f8d9cfe1e4976f2a" id="r_aa08f3a483dad1815f8d9cfe1e4976f2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa08f3a483dad1815f8d9cfe1e4976f2a">GetLiteralRepresentative</a> (int ref) const</td></tr>
<tr class="memdesc:aa08f3a483dad1815f8d9cfe1e4976f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the representative of a literal.  <br /></td></tr>
<tr class="separator:aa08f3a483dad1815f8d9cfe1e4976f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6febea0946bc7a03f0b5efc3e2b0322" id="r_ac6febea0946bc7a03f0b5efc3e2b0322"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6febea0946bc7a03f0b5efc3e2b0322">NumAffineRelations</a> () const</td></tr>
<tr class="memdesc:ac6febea0946bc7a03f0b5efc3e2b0322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for statistics.  <br /></td></tr>
<tr class="separator:ac6febea0946bc7a03f0b5efc3e2b0322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d4fbe94ad2402fb6bad6225b423572" id="r_ab5d4fbe94ad2402fb6bad6225b423572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1AffineRelation_1_1Relation.html">AffineRelation::Relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5d4fbe94ad2402fb6bad6225b423572">GetAffineRelation</a> (int ref) const</td></tr>
<tr class="memdesc:ab5d4fbe94ad2402fb6bad6225b423572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the representative of ref under the affine relations.  <br /></td></tr>
<tr class="separator:ab5d4fbe94ad2402fb6bad6225b423572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc75ac7d8839a0ed3f2bc9faa5319fc" id="r_abcc75ac7d8839a0ed3f2bc9faa5319fc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcc75ac7d8839a0ed3f2bc9faa5319fc">RefDebugString</a> (int ref) const</td></tr>
<tr class="memdesc:abcc75ac7d8839a0ed3f2bc9faa5319fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">To facilitate debugging.  <br /></td></tr>
<tr class="separator:abcc75ac7d8839a0ed3f2bc9faa5319fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab5ebd19672746ed54cdcac50f9a2e" id="r_ad3ab5ebd19672746ed54cdcac50f9a2e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ab5ebd19672746ed54cdcac50f9a2e">AffineRelationDebugString</a> (int ref) const</td></tr>
<tr class="separator:ad3ab5ebd19672746ed54cdcac50f9a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84edac51ca0ef866aa9aa678cf666726" id="r_a84edac51ca0ef866aa9aa678cf666726"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84edac51ca0ef866aa9aa678cf666726">PropagateAffineRelation</a> (int var)</td></tr>
<tr class="separator:a84edac51ca0ef866aa9aa678cf666726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fd4bfc22bcc9b0dfeffc03c46ff134" id="r_a64fd4bfc22bcc9b0dfeffc03c46ff134"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64fd4bfc22bcc9b0dfeffc03c46ff134">PropagateAffineRelation</a> (int var, int rep, int64_t coeff, int64_t offset)</td></tr>
<tr class="separator:a64fd4bfc22bcc9b0dfeffc03c46ff134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a8a55ba2abd0c19cdc70864e90f8d1" id="r_a87a8a55ba2abd0c19cdc70864e90f8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87a8a55ba2abd0c19cdc70864e90f8d1">InitializeNewDomains</a> ()</td></tr>
<tr class="memdesc:a87a8a55ba2abd0c19cdc70864e90f8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the internal structure for any new variables in working_model.  <br /></td></tr>
<tr class="separator:a87a8a55ba2abd0c19cdc70864e90f8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac36698e66fbf7ae8920b82be903b0e0" id="r_aac36698e66fbf7ae8920b82be903b0e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac36698e66fbf7ae8920b82be903b0e0">ResetAfterCopy</a> ()</td></tr>
<tr class="separator:aac36698e66fbf7ae8920b82be903b0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212fc7df57af89e8314ab853ad9accb7" id="r_a212fc7df57af89e8314ab853ad9accb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a212fc7df57af89e8314ab853ad9accb7">ClearStats</a> ()</td></tr>
<tr class="memdesc:a212fc7df57af89e8314ab853ad9accb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the "rules" statistics.  <br /></td></tr>
<tr class="separator:a212fc7df57af89e8314ab853ad9accb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5377b5320ad26e469e680b7d3bab02b" id="r_ac5377b5320ad26e469e680b7d3bab02b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5377b5320ad26e469e680b7d3bab02b">InsertVarValueEncoding</a> (int literal, int var, int64_t value)</td></tr>
<tr class="separator:ac5377b5320ad26e469e680b7d3bab02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45893717d68218877a72b6f5a8337841" id="r_a45893717d68218877a72b6f5a8337841"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45893717d68218877a72b6f5a8337841">GetOrCreateVarValueEncoding</a> (int ref, int64_t value)</td></tr>
<tr class="separator:a45893717d68218877a72b6f5a8337841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16ac390cb27a7c227504191d332a722" id="r_aa16ac390cb27a7c227504191d332a722"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16ac390cb27a7c227504191d332a722">GetOrCreateAffineValueEncoding</a> (const LinearExpressionProto &amp;expr, int64_t value)</td></tr>
<tr class="separator:aa16ac390cb27a7c227504191d332a722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f3a878e8123ad62ad1cf17f7aba9b8" id="r_a42f3a878e8123ad62ad1cf17f7aba9b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42f3a878e8123ad62ad1cf17f7aba9b8">CanonicalizeDomainOfSizeTwo</a> (int var)</td></tr>
<tr class="separator:a42f3a878e8123ad62ad1cf17f7aba9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7885a2de2501c1001c45a797711d6e21" id="r_a7885a2de2501c1001c45a797711d6e21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7885a2de2501c1001c45a797711d6e21">HasVarValueEncoding</a> (int ref, int64_t value, int *literal=nullptr)</td></tr>
<tr class="separator:a7885a2de2501c1001c45a797711d6e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1524915705b3272bab45c634fb5a37" id="r_a6e1524915705b3272bab45c634fb5a37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e1524915705b3272bab45c634fb5a37">IsFullyEncoded</a> (int ref) const</td></tr>
<tr class="separator:a6e1524915705b3272bab45c634fb5a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa220c1d4e5bb95e12705c8c46d9ee29f" id="r_aa220c1d4e5bb95e12705c8c46d9ee29f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa220c1d4e5bb95e12705c8c46d9ee29f">IsFullyEncoded</a> (const LinearExpressionProto &amp;expr) const</td></tr>
<tr class="separator:aa220c1d4e5bb95e12705c8c46d9ee29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2e2998571c6d42aab23f0f4ad8b5a5" id="r_a1c2e2998571c6d42aab23f0f4ad8b5a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c2e2998571c6d42aab23f0f4ad8b5a5">StoreLiteralImpliesVarEqValue</a> (int literal, int var, int64_t value)</td></tr>
<tr class="separator:a1c2e2998571c6d42aab23f0f4ad8b5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b92e80b8333221127c9c1ca073418" id="r_ad98b92e80b8333221127c9c1ca073418"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98b92e80b8333221127c9c1ca073418">StoreLiteralImpliesVarNEqValue</a> (int literal, int var, int64_t value)</td></tr>
<tr class="separator:ad98b92e80b8333221127c9c1ca073418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecb80a62e74147541a2067b27392547" id="r_a3ecb80a62e74147541a2067b27392547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ecb80a62e74147541a2067b27392547">ReadObjectiveFromProto</a> ()</td></tr>
<tr class="separator:a3ecb80a62e74147541a2067b27392547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1551a7a2329e1f78b975af6c3f9931a4" id="r_a1551a7a2329e1f78b975af6c3f9931a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1551a7a2329e1f78b975af6c3f9931a4">AddToObjectiveOffset</a> (int64_t delta)</td></tr>
<tr class="separator:a1551a7a2329e1f78b975af6c3f9931a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cea62481e1a99b2c63fb352adfc813" id="r_a48cea62481e1a99b2c63fb352adfc813"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48cea62481e1a99b2c63fb352adfc813">CanonicalizeOneObjectiveVariable</a> (int var)</td></tr>
<tr class="separator:a48cea62481e1a99b2c63fb352adfc813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e57a4d478e6619ec142e1c0e3da51a3" id="r_a0e57a4d478e6619ec142e1c0e3da51a3"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e57a4d478e6619ec142e1c0e3da51a3">CanonicalizeObjective</a> (bool simplify_domain=true)</td></tr>
<tr class="separator:a0e57a4d478e6619ec142e1c0e3da51a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba68399455fe4b7df13160b225137d3" id="r_a4ba68399455fe4b7df13160b225137d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ba68399455fe4b7df13160b225137d3">WriteObjectiveToProto</a> () const</td></tr>
<tr class="separator:a4ba68399455fe4b7df13160b225137d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595b13253a5919b4d9c164b9887e621c" id="r_a595b13253a5919b4d9c164b9887e621c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a595b13253a5919b4d9c164b9887e621c">RecomputeSingletonObjectiveDomain</a> ()</td></tr>
<tr class="separator:a595b13253a5919b4d9c164b9887e621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac461a0ca5f496b70b12578939a12855e" id="r_ac461a0ca5f496b70b12578939a12855e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac461a0ca5f496b70b12578939a12855e">WriteVariableDomainsToProto</a> () const</td></tr>
<tr class="separator:ac461a0ca5f496b70b12578939a12855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d0184278c4480ccd3e9793e404305" id="r_ae30d0184278c4480ccd3e9793e404305"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae30d0184278c4480ccd3e9793e404305">ExploitExactlyOneInObjective</a> (absl::Span&lt; const int &gt; exactly_one)</td></tr>
<tr class="separator:ae30d0184278c4480ccd3e9793e404305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392085a404b28b5e5a405c4e115e5332" id="r_a392085a404b28b5e5a405c4e115e5332"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a392085a404b28b5e5a405c4e115e5332">ShiftCostInExactlyOne</a> (absl::Span&lt; const int &gt; exactly_one, int64_t shift)</td></tr>
<tr class="separator:a392085a404b28b5e5a405c4e115e5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c28c6dddefaa06e0c550a2de2cb16a4" id="r_a7c28c6dddefaa06e0c550a2de2cb16a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c28c6dddefaa06e0c550a2de2cb16a4">RemoveVariableFromObjective</a> (int ref)</td></tr>
<tr class="memdesc:a7c28c6dddefaa06e0c550a2de2cb16a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to manipulate the objective coefficients.  <br /></td></tr>
<tr class="separator:a7c28c6dddefaa06e0c550a2de2cb16a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7212c04bff33960705373584f86c678" id="r_ab7212c04bff33960705373584f86c678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7212c04bff33960705373584f86c678">AddToObjective</a> (int var, int64_t value)</td></tr>
<tr class="separator:ab7212c04bff33960705373584f86c678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44f2bf6c587fef730b061c92edfb8e0" id="r_ac44f2bf6c587fef730b061c92edfb8e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac44f2bf6c587fef730b061c92edfb8e0">AddLiteralToObjective</a> (int ref, int64_t value)</td></tr>
<tr class="separator:ac44f2bf6c587fef730b061c92edfb8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bffaf05dc1044c33640439b03a0a32" id="r_a31bffaf05dc1044c33640439b03a0a32"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31bffaf05dc1044c33640439b03a0a32">SubstituteVariableInObjective</a> (int var_in_equality, int64_t coeff_in_equality, const ConstraintProto &amp;equality)</td></tr>
<tr class="separator:a31bffaf05dc1044c33640439b03a0a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e8a2af54e81d21aa090779f8b28b50" id="r_a82e8a2af54e81d21aa090779f8b28b50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82e8a2af54e81d21aa090779f8b28b50">ObjectiveDomain</a> () const</td></tr>
<tr class="memdesc:a82e8a2af54e81d21aa090779f8b28b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objective getters.  <br /></td></tr>
<tr class="separator:a82e8a2af54e81d21aa090779f8b28b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecb9114e2e1d60557bb2969d8ff1345" id="r_acecb9114e2e1d60557bb2969d8ff1345"><td class="memItemLeft" align="right" valign="top">const absl::flat_hash_map&lt; int, int64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acecb9114e2e1d60557bb2969d8ff1345">ObjectiveMap</a> () const</td></tr>
<tr class="separator:acecb9114e2e1d60557bb2969d8ff1345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6680e64fee2819c2b225ec8aef000d" id="r_a3e6680e64fee2819c2b225ec8aef000d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e6680e64fee2819c2b225ec8aef000d">ObjectiveCoeff</a> (int var) const</td></tr>
<tr class="separator:a3e6680e64fee2819c2b225ec8aef000d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17adeab43ceaeb5bfc2eea6fc6d9f254" id="r_a17adeab43ceaeb5bfc2eea6fc6d9f254"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17adeab43ceaeb5bfc2eea6fc6d9f254">ObjectiveDomainIsConstraining</a> () const</td></tr>
<tr class="separator:a17adeab43ceaeb5bfc2eea6fc6d9f254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6515f2a16c6cf59218323ea6d06fdd" id="r_a6a6515f2a16c6cf59218323ea6d06fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a6515f2a16c6cf59218323ea6d06fdd">RemoveNonRepresentativeAffineVariableIfUnused</a> (int var)</td></tr>
<tr class="separator:a6a6515f2a16c6cf59218323ea6d06fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0082b9fa71a8e1acf3572b3d8c8b5e" id="r_ada0082b9fa71a8e1acf3572b3d8c8b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada0082b9fa71a8e1acf3572b3d8c8b5e">RemoveVariableFromAffineRelation</a> (int var)</td></tr>
<tr class="separator:ada0082b9fa71a8e1acf3572b3d8c8b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826298c0beaf21a67b822c6578bf24d2" id="r_a826298c0beaf21a67b822c6578bf24d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826298c0beaf21a67b822c6578bf24d2">RemoveAllVariablesFromAffineRelationConstraint</a> ()</td></tr>
<tr class="separator:a826298c0beaf21a67b822c6578bf24d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396d9e9ab419a4dc1707a291f2276272" id="r_a396d9e9ab419a4dc1707a291f2276272"><td class="memItemLeft" align="right" valign="top">absl::Span&lt; const int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a396d9e9ab419a4dc1707a291f2276272">ConstraintToVars</a> (int c) const</td></tr>
<tr class="separator:a396d9e9ab419a4dc1707a291f2276272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cbf3fdc8cc1d820606cddb63de4241" id="r_ab7cbf3fdc8cc1d820606cddb63de4241"><td class="memItemLeft" align="right" valign="top">const absl::flat_hash_set&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7cbf3fdc8cc1d820606cddb63de4241">VarToConstraints</a> (int var) const</td></tr>
<tr class="separator:ab7cbf3fdc8cc1d820606cddb63de4241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de0e589e441f11441a982e884a7da66" id="r_a0de0e589e441f11441a982e884a7da66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de0e589e441f11441a982e884a7da66">IntervalUsage</a> (int c) const</td></tr>
<tr class="separator:a0de0e589e441f11441a982e884a7da66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719fd0f82a7745b09b108d441f8b864e" id="r_a719fd0f82a7745b09b108d441f8b864e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a719fd0f82a7745b09b108d441f8b864e">ConstraintIsInactive</a> (int ct_index) const</td></tr>
<tr class="separator:a719fd0f82a7745b09b108d441f8b864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826022b6560870857df958cfed459b73" id="r_a826022b6560870857df958cfed459b73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826022b6560870857df958cfed459b73">ConstraintIsOptional</a> (int ct_ref) const</td></tr>
<tr class="separator:a826022b6560870857df958cfed459b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d119ebdd1d6b3b9cc8c1c6bdd4f629" id="r_a11d119ebdd1d6b3b9cc8c1c6bdd4f629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d119ebdd1d6b3b9cc8c1c6bdd4f629">RegisterVariablesUsedInAssumptions</a> ()</td></tr>
<tr class="separator:a11d119ebdd1d6b3b9cc8c1c6bdd4f629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84087f5101427229d7bc340e6c81d135" id="r_a84087f5101427229d7bc340e6c81d135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84087f5101427229d7bc340e6c81d135">ModelIsExpanded</a> () const</td></tr>
<tr class="separator:a84087f5101427229d7bc340e6c81d135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70894f2ef41b230cdd08ee88469234af" id="r_a70894f2ef41b230cdd08ee88469234af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70894f2ef41b230cdd08ee88469234af">NotifyThatModelIsExpanded</a> ()</td></tr>
<tr class="separator:a70894f2ef41b230cdd08ee88469234af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e5eb0b8b6161a63fecc9b3c9b25bd8" id="r_af6e5eb0b8b6161a63fecc9b3c9b25bd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6e5eb0b8b6161a63fecc9b3c9b25bd8">GetOrCreateReifiedPrecedenceLiteral</a> (const LinearExpressionProto &amp;time_i, const LinearExpressionProto &amp;time_j, int active_i, int active_j)</td></tr>
<tr class="separator:af6e5eb0b8b6161a63fecc9b3c9b25bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c18ce421cae00c8aaaef0f0fd95a03f" id="r_a5c18ce421cae00c8aaaef0f0fd95a03f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, int64_t, int, int64_t, int64_t, int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c18ce421cae00c8aaaef0f0fd95a03f">GetReifiedPrecedenceKey</a> (const LinearExpressionProto &amp;time_i, const LinearExpressionProto &amp;time_j, int active_i, int active_j)</td></tr>
<tr class="separator:a5c18ce421cae00c8aaaef0f0fd95a03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd90df6a9ab7768cf0f0fa3862c3538" id="r_a6bd90df6a9ab7768cf0f0fa3862c3538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bd90df6a9ab7768cf0f0fa3862c3538">ClearPrecedenceCache</a> ()</td></tr>
<tr class="memdesc:a6bd90df6a9ab7768cf0f0fa3862c3538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the precedence cache.  <br /></td></tr>
<tr class="separator:a6bd90df6a9ab7768cf0f0fa3862c3538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664a5c02d10b2b92e519333b27afbe90" id="r_a664a5c02d10b2b92e519333b27afbe90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a664a5c02d10b2b92e519333b27afbe90">LogInfo</a> ()</td></tr>
<tr class="memdesc:a664a5c02d10b2b92e519333b27afbe90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs stats to the logger.  <br /></td></tr>
<tr class="separator:a664a5c02d10b2b92e519333b27afbe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e26193d95208f1fe5669568fe562893" id="r_a6e26193d95208f1fe5669568fe562893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e26193d95208f1fe5669568fe562893">LoadSolutionHint</a> ()</td></tr>
<tr class="separator:a6e26193d95208f1fe5669568fe562893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd68da91643e55c494dc497262d92a3" id="r_afcd68da91643e55c494dc497262d92a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SolutionCrush.html">SolutionCrush</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcd68da91643e55c494dc497262d92a3">solution_crush</a> ()</td></tr>
<tr class="separator:afcd68da91643e55c494dc497262d92a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e52323006df0063f7107521c185871" id="r_a38e52323006df0063f7107521c185871"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38e52323006df0063f7107521c185871">DebugTestHintFeasibility</a> ()</td></tr>
<tr class="separator:a38e52323006df0063f7107521c185871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab971274eb7bdbdb94968186af59bec29" id="r_ab971274eb7bdbdb94968186af59bec29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab971274eb7bdbdb94968186af59bec29">logger</a> () const</td></tr>
<tr class="separator:ab971274eb7bdbdb94968186af59bec29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc6bad04e287ac6274685b274dfd5ed" id="r_a0cc6bad04e287ac6274685b274dfd5ed"><td class="memItemLeft" align="right" valign="top">const SatParameters &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cc6bad04e287ac6274685b274dfd5ed">params</a> () const</td></tr>
<tr class="separator:a0cc6bad04e287ac6274685b274dfd5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a606ad9026a599315765e615bcd9a2" id="r_ab9a606ad9026a599315765e615bcd9a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a606ad9026a599315765e615bcd9a2">time_limit</a> ()</td></tr>
<tr class="separator:ab9a606ad9026a599315765e615bcd9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6a4c93ee1cc7d4c058334f395b7757" id="r_adb6a4c93ee1cc7d4c058334f395b7757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1ModelRandomGenerator.html">ModelRandomGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb6a4c93ee1cc7d4c058334f395b7757">random</a> ()</td></tr>
<tr class="separator:adb6a4c93ee1cc7d4c058334f395b7757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9461dc66ac42662bc9c36774944536fe" id="r_a9461dc66ac42662bc9c36774944536fe"><td class="memItemLeft" align="right" valign="top">ConstraintProto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9461dc66ac42662bc9c36774944536fe">NewMappingConstraint</a> (absl::string_view file, int line)</td></tr>
<tr class="separator:a9461dc66ac42662bc9c36774944536fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a52cd28d5f7a200da251558b723665" id="r_a61a52cd28d5f7a200da251558b723665"><td class="memItemLeft" align="right" valign="top">ConstraintProto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a52cd28d5f7a200da251558b723665">NewMappingConstraint</a> (const ConstraintProto &amp;base_ct, absl::string_view file, int line)</td></tr>
<tr class="separator:a61a52cd28d5f7a200da251558b723665"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1a267c1154e80e2966e5a39128e55b21" id="r_a1a267c1154e80e2966e5a39128e55b21"><td class="memItemLeft" align="right" valign="top">CpModelProto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a267c1154e80e2966e5a39128e55b21">working_model</a> = nullptr</td></tr>
<tr class="separator:a1a267c1154e80e2966e5a39128e55b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdea9a3ee9d89bc4faf30c485fdbe93" id="r_aecdea9a3ee9d89bc4faf30c485fdbe93"><td class="memItemLeft" align="right" valign="top">CpModelProto *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecdea9a3ee9d89bc4faf30c485fdbe93">mapping_model</a> = nullptr</td></tr>
<tr class="separator:aecdea9a3ee9d89bc4faf30c485fdbe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466d33d9ecb905e979b48094e5b4d300" id="r_a466d33d9ecb905e979b48094e5b4d300"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a466d33d9ecb905e979b48094e5b4d300">num_presolve_operations</a> = 0</td></tr>
<tr class="separator:a466d33d9ecb905e979b48094e5b4d300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6a1238ac4eb29d5265fbd6ec6a33eb" id="r_aad6a1238ac4eb29d5265fbd6ec6a33eb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad6a1238ac4eb29d5265fbd6ec6a33eb">tmp_literals</a></td></tr>
<tr class="memdesc:aad6a1238ac4eb29d5265fbd6ec6a33eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary storage.  <br /></td></tr>
<tr class="separator:aad6a1238ac4eb29d5265fbd6ec6a33eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5b14b5437ebc3bbf7820747578a5fe" id="r_a1a5b14b5437ebc3bbf7820747578a5fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a5b14b5437ebc3bbf7820747578a5fe">tmp_term_domains</a></td></tr>
<tr class="separator:a1a5b14b5437ebc3bbf7820747578a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b078d19854dc81f894f25bf16df419" id="r_a72b078d19854dc81f894f25bf16df419"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72b078d19854dc81f894f25bf16df419">tmp_left_domains</a></td></tr>
<tr class="separator:a72b078d19854dc81f894f25bf16df419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4e4d1872cce837619b241b42b78f89" id="r_a8c4e4d1872cce837619b241b42b78f89"><td class="memItemLeft" align="right" valign="top">absl::flat_hash_set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c4e4d1872cce837619b241b42b78f89">tmp_literal_set</a></td></tr>
<tr class="separator:a8c4e4d1872cce837619b241b42b78f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2781de28b740a39c605bba56a0f65454" id="r_a2781de28b740a39c605bba56a0f65454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2781de28b740a39c605bba56a0f65454">modified_domains</a></td></tr>
<tr class="memdesc:a2781de28b740a39c605bba56a0f65454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each time a domain is modified this is set to true.  <br /></td></tr>
<tr class="separator:a2781de28b740a39c605bba56a0f65454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaefeb795ad5715de17b544daac7585e" id="r_aaaefeb795ad5715de17b544daac7585e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaefeb795ad5715de17b544daac7585e">var_with_reduced_small_degree</a></td></tr>
<tr class="separator:aaaefeb795ad5715de17b544daac7585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036dd9262c47acb71c05816e82f40f9d" id="r_a036dd9262c47acb71c05816e82f40f9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html">DomainDeductions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a036dd9262c47acb71c05816e82f40f9d">deductions</a></td></tr>
<tr class="memdesc:a036dd9262c47acb71c05816e82f40f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced presolve. See this class comment.  <br /></td></tr>
<tr class="separator:a036dd9262c47acb71c05816e82f40f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrap the CpModelProto we are presolving with extra data structure like the in-memory domain of each variables and the constraint variable graph. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00095">95</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ace44b7515ea8289bbc7878a9f90f94e3" name="ace44b7515ea8289bbc7878a9f90f94e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace44b7515ea8289bbc7878a9f90f94e3">&#9670;&#160;</a></span>PresolveContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::PresolveContext::PresolveContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>cp_model</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CpModelProto *</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00097">97</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a34b5d3417fd42df1be2401e867caae2c" name="a34b5d3417fd42df1be2401e867caae2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b5d3417fd42df1be2401e867caae2c">&#9670;&#160;</a></span>AddImplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::AddImplication </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a =&gt; b. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00152">152</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a3102d3d48b1fe0e958283ece21720a37" name="a3102d3d48b1fe0e958283ece21720a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3102d3d48b1fe0e958283ece21720a37">&#9670;&#160;</a></span>AddImplyInDomain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::AddImplyInDomain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>b =&gt; (expr ∈ domain). </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00172">172</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a5670894aad056fc4452807432b031858" name="a5670894aad056fc4452807432b031858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5670894aad056fc4452807432b031858">&#9670;&#160;</a></span>AddImplyInDomain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::AddImplyInDomain </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>b =&gt; (x ∈ domain). </p>
<p>b =&gt; x in [lb, ub]. </p>
<p>Doing it like this seems to use slightly less memory. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002204">Todo</a></b></dt><dd>(user): Find the best way to create such small proto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00160">160</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ac44f2bf6c587fef730b061c92edfb8e0" name="ac44f2bf6c587fef730b061c92edfb8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44f2bf6c587fef730b061c92edfb8e0">&#9670;&#160;</a></span>AddLiteralToObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::AddLiteralToObjective </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02097">2097</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ab7212c04bff33960705373584f86c678" name="ab7212c04bff33960705373584f86c678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7212c04bff33960705373584f86c678">&#9670;&#160;</a></span>AddToObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::AddToObjective </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02085">2085</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a1551a7a2329e1f78b975af6c3f9931a4" name="a1551a7a2329e1f78b975af6c3f9931a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1551a7a2329e1f78b975af6c3f9931a4">&#9670;&#160;</a></span>AddToObjectiveOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::AddToObjectiveOffset </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tricky: The objective domain is without the offset, so we need to shift it.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02114">2114</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ad3ab5ebd19672746ed54cdcac50f9a2e" name="ad3ab5ebd19672746ed54cdcac50f9a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ab5ebd19672746ed54cdcac50f9a2e">&#9670;&#160;</a></span>AffineRelationDebugString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::PresolveContext::AffineRelationDebugString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01333">1333</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a8192e7518d905cd6d6eb812ba8a530c8" name="a8192e7518d905cd6d6eb812ba8a530c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8192e7518d905cd6d6eb812ba8a530c8">&#9670;&#160;</a></span>AllDomains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Span&lt; const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &gt; operations_research::sat::PresolveContext::AllDomains </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00158">158</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="ac995d5af22b14671e9e6ac5f7fa67fa6" name="ac995d5af22b14671e9e6ac5f7fa67fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac995d5af22b14671e9e6ac5f7fa67fa6">&#9670;&#160;</a></span>CanBeUsedAsLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::CanBeUsedAsLiteral </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00192">192</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a0e8e358d0b25f1ccf7eeeb29a32aabde" name="a0e8e358d0b25f1ccf7eeeb29a32aabde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8e358d0b25f1ccf7eeeb29a32aabde">&#9670;&#160;</a></span>CanonicalizeAffineVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::CanonicalizeAffineVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>mod</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the relation (X * coeff % mod = rhs % mod), this creates a new variable so that X = mod * Y + cte.</p>
<p>This requires mod != 0 and coeff != 0.</p>
<dl class="section note"><dt>Note</dt><dd>the new variable will have a canonical domain (i.e. min == 0). We also do not create anything if this fixes the given variable or the relation simplifies. Returns false if the model is infeasible. </dd></dl>
<p>We just abort in this case as there is no point introducing a new variable.</p>
<p>From var * coeff % mod = rhs We have var = mod * X + offset.</p>
<p>Lets create a new integer variable and add the affine relation.</p>
<p>We make sure the new variable has a domain starting at zero to minimize future overflow issues. If it end up Boolean, it is also nice to be able to use it as such.</p>
<p>A potential problem with this is that it messes up the natural variable order chosen by the modeler. We try to correct that when mapping variables at the end of the presolve.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01019">1019</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a42f3a878e8123ad62ad1cf17f7aba9b8" name="a42f3a878e8123ad62ad1cf17f7aba9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f3a878e8123ad62ad1cf17f7aba9b8">&#9670;&#160;</a></span>CanonicalizeDomainOfSizeTwo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::CanonicalizeDomainOfSizeTwo </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If not already done, adds a Boolean to represent any integer variables that take only two values. Make sure all the relevant affine and encoding relations are updated.</p>
<dl class="section note"><dt>Note</dt><dd>this might create a new Boolean variable. </dd></dl>
<p>Find encoding for min if present.</p>
<p>Find encoding for max if present.</p>
<p>Insert missing encoding.</p>
<p>Add affine relation.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01404">1404</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="afc9cfa1ea87ca40b15c2ed4ce25d8d14" name="afc9cfa1ea87ca40b15c2ed4ce25d8d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9cfa1ea87ca40b15c2ed4ce25d8d14">&#9670;&#160;</a></span>CanonicalizeLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::CanonicalizeLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Canonicalization of linear constraint. This might also be needed when creating new constraint to make sure there are no duplicate variables. Returns true if the set of variables in the expression changed.</p>
<p>This uses affine relation and regroup duplicate/fixed terms. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02661">2661</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aaf474172c863fee40c3f7a4b1f27c7f5" name="aaf474172c863fee40c3f7a4b1f27c7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf474172c863fee40c3f7a4b1f27c7f5">&#9670;&#160;</a></span>CanonicalizeLinearExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::CanonicalizeLinearExpression </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>enforcements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinearExpressionProto *</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02674">2674</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a0e57a4d478e6619ec142e1c0e3da51a3" name="a0e57a4d478e6619ec142e1c0e3da51a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e57a4d478e6619ec142e1c0e3da51a3">&#9670;&#160;</a></span>CanonicalizeObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::CanonicalizeObjective </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>simplify_domain</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We replace each entry by its affine representative. </p><dl class="section note"><dt>Note</dt><dd>the non-deterministic loop is fine, but because we iterate one the map while modifying it, it is safer to do a copy rather than to try to handle that in one pass.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002213">Todo</a></b></dt><dd>(user): This is a bit duplicated with the presolve linear code. We also do not propagate back any domain restriction from the objective to the variables if any. </dd></dl>
<p>We need to sort the entries to be deterministic.</p>
<p>This is the new domain. </p><dl class="section note"><dt>Note</dt><dd>the domain never include the offset.</dd></dl>
<p>Depending on the use case, we cannot do that.</p>
<p>Maybe divide by GCD.</p>
<p>We update the offset accordingly.</p>
<p>To avoid overflow in (fixed_value * gcd + before_offset) * factor + after_offset because the objective is constant (and should fit on an int64_t), we can rewrite it as fixed_value + offset.</p>
<p>It is important to update the implied_domain for the "is constraining" test below.</p>
<p>Detect if the objective domain do not limit the "optimal" objective value. If this is true, then we can apply any reduction that reduce the objective value without any issues.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01957">1957</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a48cea62481e1a99b2c63fb352adfc813" name="a48cea62481e1a99b2c63fb352adfc813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cea62481e1a99b2c63fb352adfc813">&#9670;&#160;</a></span>CanonicalizeOneObjectiveVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::CanonicalizeOneObjectiveVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a variable only appear in objective, we can fix it! </p><dl class="section note"><dt>Note</dt><dd>we don't care if it was in affine relation, because if none of the relations are left, then we can still fix it.</dd></dl>
<p>After we removed the variable from the objective it might have become a unused affine. Add it to the list of variables to check so we reprocess it.</p>
<p>Do the substitution.</p>
<p>Process new term.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01899">1899</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a2ccc5bf972c4cfe911eb430e97dd3c57" name="a2ccc5bf972c4cfe911eb430e97dd3c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccc5bf972c4cfe911eb430e97dd3c57">&#9670;&#160;</a></span>CanonicalizeVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::CanonicalizeVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "canonical domain" always have a <a class="el" href="#ad5c777be53b24b90df4e7be5969d95fa">MinOf()</a> equal to zero. If needed we introduce a new variable with such canonical domain and add the relation X = Y + offset.</p>
<p>This is useful in some corner case to avoid overflow.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002223">Todo</a></b></dt><dd>(user): When we can always get rid of affine relation, it might be good to do a final pass to canonicalize all domains in a model after presolve. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00991">991</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a5e457fe5fabd8656ded206a1d5416937" name="a5e457fe5fabd8656ded206a1d5416937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e457fe5fabd8656ded206a1d5416937">&#9670;&#160;</a></span>CappedUpdateMinMaxActivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::CappedUpdateMinMaxActivity </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>min_activity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *</td>          <td class="paramname"><span class="paramname"><em>max_activity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00206">206</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a6bd90df6a9ab7768cf0f0fa3862c3538" name="a6bd90df6a9ab7768cf0f0fa3862c3538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd90df6a9ab7768cf0f0fa3862c3538">&#9670;&#160;</a></span>ClearPrecedenceCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::ClearPrecedenceCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the precedence cache. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02455">2455</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a212fc7df57af89e8314ab853ad9accb7" name="a212fc7df57af89e8314ab853ad9accb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212fc7df57af89e8314ab853ad9accb7">&#9670;&#160;</a></span>ClearStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::ClearStats </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the "rules" statistics. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00072">72</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a623bc44b1287fc333a3210b8e2282b5f" name="a623bc44b1287fc333a3210b8e2282b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623bc44b1287fc333a3210b8e2282b5f">&#9670;&#160;</a></span>ComputeMinMaxActivity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoWithVarsAndCoeffs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int64_t, int64_t &gt; operations_research::sat::PresolveContext::ComputeMinMaxActivity </td>
          <td>(</td>
          <td class="paramtype">const ProtoWithVarsAndCoeffs &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accepts any proto with two parallel vector .vars() and .coeffs(), like LinearConstraintProto or ObjectiveProto or LinearExpressionProto but beware that this ignore any offset. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00186">186</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a719fd0f82a7745b09b108d441f8b864e" name="a719fd0f82a7745b09b108d441f8b864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719fd0f82a7745b09b108d441f8b864e">&#9670;&#160;</a></span>ConstraintIsInactive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ConstraintIsInactive </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a constraint contains an enforcement literal set to false, or if it has been cleared. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00599">599</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a826022b6560870857df958cfed459b73" name="a826022b6560870857df958cfed459b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826022b6560870857df958cfed459b73">&#9670;&#160;</a></span>ConstraintIsOptional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ConstraintIsOptional </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a constraint contains an enforcement literal not fixed, and no enforcement literals set to false. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00611">611</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a396d9e9ab419a4dc1707a291f2276272" name="a396d9e9ab419a4dc1707a291f2276272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396d9e9ab419a4dc1707a291f2276272">&#9670;&#160;</a></span>ConstraintToVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Span&lt; const int &gt; operations_research::sat::PresolveContext::ConstraintToVars </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structVariable.html">Variable</a> &lt;-&gt; constraint graph. The vector list is sorted and contains unique elements.</p>
<p>Important: To properly handle the objective, var_to_constraints[objective] contains kObjectiveConstraint (i.e. -1) so that if the objective appear in only one constraint, the constraint cannot be simplified. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00567">567</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a9b3712d2df9a0fb81962a7d9a528d699" name="a9b3712d2df9a0fb81962a7d9a528d699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3712d2df9a0fb81962a7d9a528d699">&#9670;&#160;</a></span>ConstraintVariableGraphIsUpToDate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ConstraintVariableGraphIsUpToDate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At the beginning of the presolve, we delay the costly creation of this "graph" until we at least ran some basic presolve. This is because during a LNS neighborhood, many constraints will be reduced significantly by this "simple" presolve. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00757">757</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="acfa9e96fd82123e73419f70c85690153" name="acfa9e96fd82123e73419f70c85690153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa9e96fd82123e73419f70c85690153">&#9670;&#160;</a></span>ConstraintVariableUsageIsConsistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ConstraintVariableUsageIsConsistent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if our current constraints &lt;-&gt; variables graph is ok. This is meant to be used in DEBUG mode only.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002206">Todo</a></b></dt><dd>(user): Also test var_to_constraints_ !! </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00795">795</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a38e52323006df0063f7107521c185871" name="a38e52323006df0063f7107521c185871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e52323006df0063f7107521c185871">&#9670;&#160;</a></span>DebugTestHintFeasibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::DebugTestHintFeasibility </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is slow O(problem_size) but can be used to debug presolve, either by pinpointing the transition from feasible to infeasible or the other way around if for some reason the presolve drop constraint that it shouldn't. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02772">2772</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a1e0fa3dc65c8a6b695024acd5ffd3f0f" name="a1e0fa3dc65c8a6b695024acd5ffd3f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0fa3dc65c8a6b695024acd5ffd3f0f">&#9670;&#160;</a></span>DomainContains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::DomainContains </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This methods only works for affine expressions (checked). </p>
<p>We assume expression is validated for overflow initially, and the code below should be overflow safe.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00510">510</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="af2b356c25b8affdfd9fd143751a429ca" name="af2b356c25b8affdfd9fd143751a429ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b356c25b8affdfd9fd143751a429ca">&#9670;&#160;</a></span>DomainContains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::DomainContains </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00503">503</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a2fa30837da268a9688f608013d857a7e" name="a2fa30837da268a9688f608013d857a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa30837da268a9688f608013d857a7e">&#9670;&#160;</a></span>DomainIsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::DomainIsEmpty </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helpers to query the current domain of a variable. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00182">182</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a044c0a30b120ca82eabf648156ce3d19" name="a044c0a30b120ca82eabf648156ce3d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044c0a30b120ca82eabf648156ce3d19">&#9670;&#160;</a></span>DomainOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a> operations_research::sat::PresolveContext::DomainOf </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00493">493</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ab1c55b01ac54cd61519d8899d5badac8" name="ab1c55b01ac54cd61519d8899d5badac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c55b01ac54cd61519d8899d5badac8">&#9670;&#160;</a></span>DomainOfVarIsIncludedIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::DomainOfVarIsIncludedIn </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes a positive variable reference. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00245">245</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a83d914783666534a61a6032f9c77bf34" name="a83d914783666534a61a6032f9c77bf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d914783666534a61a6032f9c77bf34">&#9670;&#160;</a></span>DomainSuperSetOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a> operations_research::sat::PresolveContext::DomainSuperSetOf </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a super-set of the domain of the linear expression. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00288">288</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a5098e7cbef49fc9630e1e3c4622f7b73" name="a5098e7cbef49fc9630e1e3c4622f7b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5098e7cbef49fc9630e1e3c4622f7b73">&#9670;&#160;</a></span>EndMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::EndMax </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00391">391</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a4f2df4dacfec58076552318ce49afd4e" name="a4f2df4dacfec58076552318ce49afd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2df4dacfec58076552318ce49afd4e">&#9670;&#160;</a></span>EndMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::EndMin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00385">385</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ae30d0184278c4480ccd3e9793e404305" name="ae30d0184278c4480ccd3e9793e404305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30d0184278c4480ccd3e9793e404305">&#9670;&#160;</a></span>ExploitExactlyOneInObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ExploitExactlyOneInObjective </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>exactly_one</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given exactly_one is included in the objective, and simplify the objective by adding a constant value to all the exactly one terms.</p>
<p>Returns true if a simplification was done. </p>
<p>Objective = coeff * var = coeff * (1 - ref);</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02204">2204</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a4b1bc99af7b7f09a7af40dc25905724b" name="a4b1bc99af7b7f09a7af40dc25905724b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1bc99af7b7f09a7af40dc25905724b">&#9670;&#160;</a></span>ExpressionIsAffineBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ExpressionIsAffineBoolean </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the expr is of the form a * literal + b. The other function can be used to get the literal that achieve <a class="el" href="#ad9a56a53bed03585a5cba71fa3ea69be">MaxOf()</a>. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00298">298</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a188528e271a7307bead68d00d351f4ef" name="a188528e271a7307bead68d00d351f4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188528e271a7307bead68d00d351f4ef">&#9670;&#160;</a></span>ExpressionIsALiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ExpressionIsALiteral </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>literal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the expr is a literal (x or not(x)). </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00315">315</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a0e6584f3002678b48e00c3405472ed5f" name="a0e6584f3002678b48e00c3405472ed5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6584f3002678b48e00c3405472ed5f">&#9670;&#160;</a></span>ExpressionIsSingleVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ExpressionIsSingleVariable </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the expr is of the form 1 * var + 0. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00310">310</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a1a85526dd2e4d2a34d323a91e05df368" name="a1a85526dd2e4d2a34d323a91e05df368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85526dd2e4d2a34d323a91e05df368">&#9670;&#160;</a></span>FixedValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::FixedValue </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00267">267</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a34067a2486e93d9eac27e465f9524aca" name="a34067a2486e93d9eac27e465f9524aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34067a2486e93d9eac27e465f9524aca">&#9670;&#160;</a></span>FixedValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::FixedValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00227">227</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a7ff962ccabd1ddb157562b0620c50639" name="a7ff962ccabd1ddb157562b0620c50639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff962ccabd1ddb157562b0620c50639">&#9670;&#160;</a></span>FixedValueOrNullopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; operations_research::sat::PresolveContext::FixedValueOrNullopt </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is faster than testing <a class="el" href="#a4c1d359c4b268649c50d4c848c6aec0b">IsFixed()</a> + <a class="el" href="#a34067a2486e93d9eac27e465f9524aca">FixedValue()</a>. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00276">276</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ab5d4fbe94ad2402fb6bad6225b423572" name="ab5d4fbe94ad2402fb6bad6225b423572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d4fbe94ad2402fb6bad6225b423572">&#9670;&#160;</a></span>GetAffineRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1AffineRelation_1_1Relation.html">AffineRelation::Relation</a> operations_research::sat::PresolveContext::GetAffineRelation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the representative of ref under the affine relations. </p>
<p>This makes sure that the affine relation only uses one of the representative from the var_equiv_relations_. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01319">1319</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aa692158541395ad5e1f53a236de60ba5" name="aa692158541395ad5e1f53a236de60ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa692158541395ad5e1f53a236de60ba5">&#9670;&#160;</a></span>GetFalseLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::GetFalseLiteral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00149">149</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aa08f3a483dad1815f8d9cfe1e4976f2a" name="aa08f3a483dad1815f8d9cfe1e4976f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08f3a483dad1815f8d9cfe1e4976f2a">&#9670;&#160;</a></span>GetLiteralRepresentative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::GetLiteralRepresentative </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the representative of a literal. </p>
<p>Note(user): This can happen is some corner cases where the affine relation where added before the variable became usable as Boolean. When this is the case, the domain will be of the form [x, x + 1] and should be later remapped to a Boolean variable.</p>
<p>We made sure that the affine representative can always be used as a literal. However, if some variable are fixed, we might not have only (coeff=1 offset=0) or (coeff=-1 offset=1) and we might have something like (coeff=8 offset=0) which is only valid for both variable at zero...</p>
<p>What is sure is that depending on the value, only one mapping can be valid because r.coeff can never be zero.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01288">1288</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aa16ac390cb27a7c227504191d332a722" name="aa16ac390cb27a7c227504191d332a722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16ac390cb27a7c227504191d332a722">&#9670;&#160;</a></span>GetOrCreateAffineValueEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::GetOrCreateAffineValueEncoding </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the associated literal if it is already created. Otherwise create it, add the corresponding constraints and returns it.</p>
<p>Important: This does not update the constraint&lt;-&gt;variable graph, so <a class="el" href="#a9b3712d2df9a0fb81962a7d9a528d699">ConstraintVariableGraphIsUpToDate()</a> will be false until <a class="el" href="#ac58a2f700fb28455324dd0268a9d510b" title="Calls UpdateConstraintVariableUsage() on all newly created constraints.">UpdateNewConstraintsVariableUsage()</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01810">1810</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="af6e5eb0b8b6161a63fecc9b3c9b25bd8" name="af6e5eb0b8b6161a63fecc9b3c9b25bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e5eb0b8b6161a63fecc9b3c9b25bd8">&#9670;&#160;</a></span>GetOrCreateReifiedPrecedenceLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::GetOrCreateReifiedPrecedenceLiteral </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>time_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>time_j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>active_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>active_j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following helper adds the following constraint: result &lt;=&gt; (time_i &lt;= time_j &amp;&amp; active_i is true &amp;&amp; active_j is true) and returns the (cached) literal result.</p>
<dl class="section note"><dt>Note</dt><dd>this cache should just be used temporarily and then cleared with <a class="el" href="#a6bd90df6a9ab7768cf0f0fa3862c3538" title="Clear the precedence cache.">ClearPrecedenceCache()</a> because there is no mechanism to update the cached literals when literal equivalence are detected. </dd></dl>
<p>result =&gt; (time_i &lt;= time_j) &amp;&amp; active_i &amp;&amp; active_j.</p>
<p>Not(result) &amp;&amp; active_i &amp;&amp; active_j =&gt; (time_i &gt; time_j)</p>
<p>This is redundant but should improves performance.</p>
<p>If GetOrCreateReifiedPrecedenceLiteral(time_j, time_i, active_j, active_i) (the reverse precedence) has been called too, then we can link the two precedence literals, and the two active literals together.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02338">2338</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a45893717d68218877a72b6f5a8337841" name="a45893717d68218877a72b6f5a8337841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45893717d68218877a72b6f5a8337841">&#9670;&#160;</a></span>GetOrCreateVarValueEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::GetOrCreateVarValueEncoding </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the associated literal if it is already created. Otherwise create it, add the corresponding constraints and returns it.</p>
<p>Important: This does not update the constraint&lt;-&gt;variable graph, so <a class="el" href="#a9b3712d2df9a0fb81962a7d9a528d699">ConstraintVariableGraphIsUpToDate()</a> will be false until <a class="el" href="#ac58a2f700fb28455324dd0268a9d510b" title="Calls UpdateConstraintVariableUsage() on all newly created constraints.">UpdateNewConstraintsVariableUsage()</a> is called. </p>
<p>Positive after CanonicalizeEncoding().</p>
<p>Returns the false literal if the value is not in the domain.</p>
<p>Return the literal itself if this was called or canonicalized to a Boolean.</p>
<p>Returns the associated literal if already present.</p>
<p>If the variable was already removed, for now we create a new one. This should be rare hopefully.</p>
<p>Special case for fixed domains.</p>
<p>Special case for domains of size 2.</p>
<p>Checks if the other value is already encoded.</p>
<p>If the variable was already removed, for now we create a new one. This should be rare hopefully.</p>
<p>Update the encoding map. The domain could have been reduced to size two after the creation of the first literal.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01729">1729</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a5c18ce421cae00c8aaaef0f0fd95a03f" name="a5c18ce421cae00c8aaaef0f0fd95a03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c18ce421cae00c8aaaef0f0fd95a03f">&#9670;&#160;</a></span>GetReifiedPrecedenceKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; int, int64_t, int, int64_t, int64_t, int, int &gt; operations_research::sat::PresolveContext::GetReifiedPrecedenceKey </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>time_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>time_j</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>active_i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>active_j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In all formulas, active_i and active_j are symmetrical, we can sort the active literals.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02436">2436</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a3a267b655bc398f01613bb195a7cb61f" name="a3a267b655bc398f01613bb195a7cb61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a267b655bc398f01613bb195a7cb61f">&#9670;&#160;</a></span>GetTrueLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::GetTrueLiteral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some expansion code use constant literal to be simpler to write. This will create a <a class="el" href="#a65fe14466fe82586570c22769cfae527">NewBoolVar()</a> the first time, but later call will just returns it. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00140">140</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a41a201fc9782615c652c779e56324388" name="a41a201fc9782615c652c779e56324388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a201fc9782615c652c779e56324388">&#9670;&#160;</a></span>HasUnusedAffineVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::HasUnusedAffineVariable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all variable and return true if one of them is only used in affine relation and is not a representative. This is in O(num_vars) and only meant to be used in DCHECKs. </p>
<p>We can leave non-optimal stuff around if we reach the time limit.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00774">774</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a7885a2de2501c1001c45a797711d6e21" name="a7885a2de2501c1001c45a797711d6e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7885a2de2501c1001c45a797711d6e21">&#9670;&#160;</a></span>HasVarValueEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::HasVarValueEncoding </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>literal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a literal attached to ref == var exists. It assigns the corresponding to <code>literal</code> if non null. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01685">1685</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a87a8a55ba2abd0c19cdc70864e90f8d1" name="a87a8a55ba2abd0c19cdc70864e90f8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a8a55ba2abd0c19cdc70864e90f8d1">&#9670;&#160;</a></span>InitializeNewDomains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::InitializeNewDomains </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the internal structure for any new variables in working_model. </p>
<p>Create the internal structure for any new variables in working_model. </p>
<p>We mark the domain as modified so we will look at these new variable during our presolve loop.</p>
<p>We resize the hint too even if not loaded.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01350">1350</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ac5377b5320ad26e469e680b7d3bab02b" name="ac5377b5320ad26e469e680b7d3bab02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5377b5320ad26e469e680b7d3bab02b">&#9670;&#160;</a></span>InsertVarValueEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::InsertVarValueEncoding </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the given literal to encode var == value. If an encoding already exists, it adds the two implications between the previous encoding and the new encoding.</p>
<p>Important: This does not update the constraint&lt;-&gt;variable graph, so <a class="el" href="#a9b3712d2df9a0fb81962a7d9a528d699">ConstraintVariableGraphIsUpToDate()</a> will be false until <a class="el" href="#ac58a2f700fb28455324dd0268a9d510b" title="Calls UpdateConstraintVariableUsage() on all newly created constraints.">UpdateNewConstraintsVariableUsage()</a> is called.</p>
<p>Returns false if the model become UNSAT.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002225">Todo</a></b></dt><dd>(user): This function is not always correct if !context-&gt;DomainOf(var).contains(value), we could make it correct but it might be a bit expansive to do so. For now we just have a DCHECK(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01647">1647</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a69c0765d4c9e3b2ab0d3974aa7b192d0" name="a69c0765d4c9e3b2ab0d3974aa7b192d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c0765d4c9e3b2ab0d3974aa7b192d0">&#9670;&#160;</a></span>IntersectDomainWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::PresolveContext::IntersectDomainWith </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>domain_modified</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a183cbc89ee5ff7b8bccefe3611ea9676">IntersectDomainWith()</a> but take a linear expression as input. If this expression if of size &gt; 1, this does nothing for now, so it will only propagates for constant and affine expression. </p>
<p>We don't do anything for longer expression for now.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00566">566</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a183cbc89ee5ff7b8bccefe3611ea9676" name="a183cbc89ee5ff7b8bccefe3611ea9676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183cbc89ee5ff7b8bccefe3611ea9676">&#9670;&#160;</a></span>IntersectDomainWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::PresolveContext::IntersectDomainWith </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>domain_modified</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns false if the new domain is empty. Sets 'domain_modified' (if provided) to true iff the domain is modified otherwise does not change it. </p>
<p>Propagate the domain of the representative right away. </p><dl class="section note"><dt>Note</dt><dd>the recursive call should only by one level deep.</dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00525">525</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a49ad52aff108d76ac1171f9442a0b982" name="a49ad52aff108d76ac1171f9442a0b982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ad52aff108d76ac1171f9442a0b982">&#9670;&#160;</a></span>IntervalDebugString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::PresolveContext::IntervalDebugString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00347">347</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a34e32308d4beea978b37461768798091" name="a34e32308d4beea978b37461768798091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e32308d4beea978b37461768798091">&#9670;&#160;</a></span>IntervalIsConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::IntervalIsConstant </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to query the state of an interval. </p>
<dl class="section note"><dt>Note</dt><dd>we only support converted intervals. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00338">338</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a0de0e589e441f11441a982e884a7da66" name="a0de0e589e441f11441a982e884a7da66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de0e589e441f11441a982e884a7da66">&#9670;&#160;</a></span>IntervalUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::IntervalUsage </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00575">575</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a92ec01005eca2e8acd89dd803a909c47" name="a92ec01005eca2e8acd89dd803a909c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ec01005eca2e8acd89dd803a909c47">&#9670;&#160;</a></span>IsFixed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::IsFixed </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00260">260</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a4c1d359c4b268649c50d4c848c6aec0b" name="a4c1d359c4b268649c50d4c848c6aec0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1d359c4b268649c50d4c848c6aec0b">&#9670;&#160;</a></span>IsFixed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::IsFixed </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00186">186</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aa220c1d4e5bb95e12705c8c46d9ee29f" name="aa220c1d4e5bb95e12705c8c46d9ee29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa220c1d4e5bb95e12705c8c46d9ee29f">&#9670;&#160;</a></span>IsFullyEncoded() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::IsFullyEncoded </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This methods only works for affine expressions (checked). It returns true iff the expression is constant or its one variable is full encoded. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01723">1723</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a6e1524915705b3272bab45c634fb5a37" name="a6e1524915705b3272bab45c634fb5a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1524915705b3272bab45c634fb5a37">&#9670;&#160;</a></span>IsFullyEncoded() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::IsFullyEncoded </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if we have literal &lt;=&gt; var = value for all values of var.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002226">Todo</a></b></dt><dd>(user): If the domain was shrunk, we can have a false positive. Still it means that the number of values removed is greater than the number of values not encoded. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01715">1715</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aa55b4a0e9ef1a0345a8787a702471fd6" name="aa55b4a0e9ef1a0345a8787a702471fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55b4a0e9ef1a0345a8787a702471fd6">&#9670;&#160;</a></span>LiteralForExpressionMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::LiteralForExpressionMax </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00304">304</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a2cc31dece12725d389ef55c86fde8d9b" name="a2cc31dece12725d389ef55c86fde8d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc31dece12725d389ef55c86fde8d9b">&#9670;&#160;</a></span>LiteralIsFalse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::LiteralIsFalse </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00206">206</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="afdb8a0ca253cecac31ee6f9593992e56" name="afdb8a0ca253cecac31ee6f9593992e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb8a0ca253cecac31ee6f9593992e56">&#9670;&#160;</a></span>LiteralIsTrue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::LiteralIsTrue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00197">197</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a6e26193d95208f1fe5669568fe562893" name="a6e26193d95208f1fe5669568fe562893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e26193d95208f1fe5669568fe562893">&#9670;&#160;</a></span>LoadSolutionHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::LoadSolutionHint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This should be called only once after <a class="el" href="#a87a8a55ba2abd0c19cdc70864e90f8d1" title="Creates the internal structure for any new variables in working_model.">InitializeNewDomains()</a> to load the hint, in order to maintain it as best as possible during presolve. Hint values outside the domain of their variable are adjusted to the nearest value in this domain. Missing hint values are completed when possible (e.g. for the model proto's fixed variables). </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01377">1377</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ab971274eb7bdbdb94968186af59bec29" name="ab971274eb7bdbdb94968186af59bec29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab971274eb7bdbdb94968186af59bec29">&#9670;&#160;</a></span>logger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> * operations_research::sat::PresolveContext::logger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00638">638</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a664a5c02d10b2b92e519333b27afbe90" name="a664a5c02d10b2b92e519333b27afbe90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664a5c02d10b2b92e519333b27afbe90">&#9670;&#160;</a></span>LogInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::LogInfo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs stats to the logger. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02459">2459</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="abe671160075d401086f71cac18bfef45" name="abe671160075d401086f71cac18bfef45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe671160075d401086f71cac18bfef45">&#9670;&#160;</a></span>MarkVariableAsRemoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::MarkVariableAsRemoved </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Functions to make sure that once we remove a variable, we no longer reuse it. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00449">449</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a7962f28e1a59532176ee5af3313fb81c" name="a7962f28e1a59532176ee5af3313fb81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7962f28e1a59532176ee5af3313fb81c">&#9670;&#160;</a></span>MaxOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::MaxOf </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00247">247</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ad9a56a53bed03585a5cba71fa3ea69be" name="ad9a56a53bed03585a5cba71fa3ea69be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a56a53bed03585a5cba71fa3ea69be">&#9670;&#160;</a></span>MaxOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::MaxOf </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00221">221</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a76145cb4d679559edda7c09d4008dab6" name="a76145cb4d679559edda7c09d4008dab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76145cb4d679559edda7c09d4008dab6">&#9670;&#160;</a></span>MinOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::MinOf </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helpers to query the current domain of a linear expression. This doesn't check for integer overflow, but our linear expression should be such that this cannot happen (tested at validation). </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00234">234</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ad5c777be53b24b90df4e7be5969d95fa" name="ad5c777be53b24b90df4e7be5969d95fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c777be53b24b90df4e7be5969d95fa">&#9670;&#160;</a></span>MinOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::MinOf </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00215">215</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a84087f5101427229d7bc340e6c81d135" name="a84087f5101427229d7bc340e6c81d135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84087f5101427229d7bc340e6c81d135">&#9670;&#160;</a></span>ModelIsExpanded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ModelIsExpanded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The "expansion" phase should be done once and allow to transform complex constraints into basic ones (see <a class="el" href="cp__model__expand_8h.html">cp_model_expand.h</a>). Some presolve rules need to know if the expansion was ran before beeing applied. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00600">600</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="af4c2e4b921ea89bdfc12181513bf28e4" name="af4c2e4b921ea89bdfc12181513bf28e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c2e4b921ea89bdfc12181513bf28e4">&#9670;&#160;</a></span>ModelIsUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ModelIsUnsat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00306">306</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a65fe14466fe82586570c22769cfae527" name="a65fe14466fe82586570c22769cfae527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fe14466fe82586570c22769cfae527">&#9670;&#160;</a></span>NewBoolVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::NewBoolVar </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new Boolean variable. </p><dl class="section warning"><dt>Warning</dt><dd>this does not set any hint value for the new variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00122">122</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a760d703f051fb4cbb1df929049eb24e1" name="a760d703f051fb4cbb1df929049eb24e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760d703f051fb4cbb1df929049eb24e1">&#9670;&#160;</a></span>NewBoolVarWithClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::NewBoolVarWithClause </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>clause</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new bool var. Its hint value is set to the value of the given clause. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00127">127</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="af671882580db883e4a7467904227e0e8" name="af671882580db883e4a7467904227e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af671882580db883e4a7467904227e0e8">&#9670;&#160;</a></span>NewBoolVarWithConjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::NewBoolVarWithConjunction </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>conjunction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new bool var. Its hint value is set to the value of the given conjunction. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00133">133</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a38e2f15d439243fcc447d48fe120624e" name="a38e2f15d439243fcc447d48fe120624e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e2f15d439243fcc447d48fe120624e">&#9670;&#160;</a></span>NewIntVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::NewIntVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helpers to adds new variables to the presolved model. </p>
<p>Creates a new integer variable with the given domain. </p><dl class="section warning"><dt>Warning</dt><dd>this does not set any hint value for the new variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00074">74</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a2f2b400df7ac9b5f827da6414de38553" name="a2f2b400df7ac9b5f827da6414de38553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2b400df7ac9b5f827da6414de38553">&#9670;&#160;</a></span>NewIntVarWithDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::NewIntVarWithDefinition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>definition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>append_constraint_to_mapping_model</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new integer variable with the given domain and definition. By default this also creates the linking constraint new_var = definition. Its hint value is set to the value of the definition. Returns -1 if we couldn't create the definition due to overflow. </p>
<p>Create new linear constraint new_var = definition. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002203">Todo</a></b></dt><dd>(user): When we encounter overflow (rare), we still create a variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00081">81</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a9461dc66ac42662bc9c36774944536fe" name="a9461dc66ac42662bc9c36774944536fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9461dc66ac42662bc9c36774944536fe">&#9670;&#160;</a></span>NewMappingConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintProto * operations_research::sat::PresolveContext::NewMappingConstraint </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new constraint to the mapping proto. The version with the base constraint will copy that constraint to the new constraint.</p>
<p>If the flag &ndash;cp_model_debug_postsolve is set, we will use the caller file/line number to add debug info in the constraint name() field. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02683">2683</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a61a52cd28d5f7a200da251558b723665" name="a61a52cd28d5f7a200da251558b723665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a52cd28d5f7a200da251558b723665">&#9670;&#160;</a></span>NewMappingConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstraintProto * operations_research::sat::PresolveContext::NewMappingConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>base_ct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02693">2693</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a70894f2ef41b230cdd08ee88469234af" name="a70894f2ef41b230cdd08ee88469234af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70894f2ef41b230cdd08ee88469234af">&#9670;&#160;</a></span>NotifyThatModelIsExpanded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::NotifyThatModelIsExpanded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00601">601</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a3ee008e9272dbcc3132a667eefc41923" name="a3ee008e9272dbcc3132a667eefc41923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee008e9272dbcc3132a667eefc41923">&#9670;&#160;</a></span>NotifyThatModelIsUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::PresolveContext::NotifyThatModelIsUnsat </td>
          <td>(</td>
          <td class="paramtype">absl::string_view</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function always return false. It is just a way to make a little bit more sure that we abort right away when infeasibility is detected. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002222">Todo</a></b></dt><dd>(user): Report any explanation for the client in a nicer way? </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00299">299</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="ac6febea0946bc7a03f0b5efc3e2b0322" name="ac6febea0946bc7a03f0b5efc3e2b0322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6febea0946bc7a03f0b5efc3e2b0322">&#9670;&#160;</a></span>NumAffineRelations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::PresolveContext::NumAffineRelations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for statistics. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00382">382</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a3e6680e64fee2819c2b225ec8aef000d" name="a3e6680e64fee2819c2b225ec8aef000d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6680e64fee2819c2b225ec8aef000d">&#9670;&#160;</a></span>ObjectiveCoeff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::ObjectiveCoeff </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00538">538</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a82e8a2af54e81d21aa090779f8b28b50" name="a82e8a2af54e81d21aa090779f8b28b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e8a2af54e81d21aa090779f8b28b50">&#9670;&#160;</a></span>ObjectiveDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp; operations_research::sat::PresolveContext::ObjectiveDomain </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Objective getters. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00534">534</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a17adeab43ceaeb5bfc2eea6fc6d9f254" name="a17adeab43ceaeb5bfc2eea6fc6d9f254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17adeab43ceaeb5bfc2eea6fc6d9f254">&#9670;&#160;</a></span>ObjectiveDomainIsConstraining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ObjectiveDomainIsConstraining </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns false if the variables in the objective with a positive (resp. negative) coefficient can freely decrease (resp. increase) within their domain (if we ignore the other constraints). Otherwise, returns true. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00547">547</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="acecb9114e2e1d60557bb2969d8ff1345" name="acecb9114e2e1d60557bb2969d8ff1345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecb9114e2e1d60557bb2969d8ff1345">&#9670;&#160;</a></span>ObjectiveMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const absl::flat_hash_map&lt; int, int64_t &gt; &amp; operations_research::sat::PresolveContext::ObjectiveMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00535">535</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a0cc6bad04e287ac6274685b274dfd5ed" name="a0cc6bad04e287ac6274685b274dfd5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc6bad04e287ac6274685b274dfd5ed">&#9670;&#160;</a></span>params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SatParameters &amp; operations_research::sat::PresolveContext::params </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00639">639</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a84edac51ca0ef866aa9aa678cf666726" name="a84edac51ca0ef866aa9aa678cf666726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84edac51ca0ef866aa9aa678cf666726">&#9670;&#160;</a></span>PropagateAffineRelation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::PropagateAffineRelation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes sure the domain of ref and of its representative (ref = coeff * rep + offset) are in sync. Returns false on unsat. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00902">902</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a64fd4bfc22bcc9b0dfeffc03c46ff134" name="a64fd4bfc22bcc9b0dfeffc03c46ff134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fd4bfc22bcc9b0dfeffc03c46ff134">&#9670;&#160;</a></span>PropagateAffineRelation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::PropagateAffineRelation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate domains both ways. var = coeff * rep + offset</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00909">909</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="adb6a4c93ee1cc7d4c058334f395b7757" name="adb6a4c93ee1cc7d4c058334f395b7757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6a4c93ee1cc7d4c058334f395b7757">&#9670;&#160;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1ModelRandomGenerator.html">ModelRandomGenerator</a> * operations_research::sat::PresolveContext::random </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00641">641</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a3ecb80a62e74147541a2067b27392547" name="a3ecb80a62e74147541a2067b27392547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecb80a62e74147541a2067b27392547">&#9670;&#160;</a></span>ReadObjectiveFromProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::ReadObjectiveFromProto </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Objective handling functions. We load it at the beginning so that during presolve we can work on the more efficient hash_map representation.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#a3ecb80a62e74147541a2067b27392547">ReadObjectiveFromProto()</a> makes sure that var_to_constraints of all the variable that appear in the objective contains -1. This is later enforced by all the functions modifying the objective.</dd></dl>
<p>Note(user): Because we process affine relation only on <a class="el" href="#a0e57a4d478e6619ec142e1c0e3da51a3">CanonicalizeObjective()</a>, it is possible that when processing a canonicalized linear constraint, we don't detect that a variable in affine relation is in the objective. For now this is fine, because when this is the case, we also have an affine linear constraint, so we can't really do anything with that variable since it appear in at least two constraints. </p>
<p>We do some small canonicalization here</p>
<p>We might relax this in <a class="el" href="#a0e57a4d478e6619ec142e1c0e3da51a3">CanonicalizeObjective()</a> when we will compute the possible objective domain from the domains of the variables.</p>
<p>This is an upper bound of the higher magnitude that can be reach by summing an objective partial sum. Because of the model validation, this shouldn't overflow, and we make sure it stays this way.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002212">Todo</a></b></dt><dd>(user): There should be no negative reference here ! </dd></dl>
<p>We remove fixed terms as we read the objective. This can help a lot on LNS problems with a large proportions of fixed terms.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01829">1829</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a595b13253a5919b4d9c164b9887e621c" name="a595b13253a5919b4d9c164b9887e621c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595b13253a5919b4d9c164b9887e621c">&#9670;&#160;</a></span>RecomputeSingletonObjectiveDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::RecomputeSingletonObjectiveDomain </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When the objective is singleton, we can always restrict the domain of var so that the current objective domain is non-constraining. Returns false on UNSAT. </p>
<p>Transfer all the info to the domain of var.</p>
<p>Recompute a correct and non-constraining objective domain.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02060">2060</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="abcc75ac7d8839a0ed3f2bc9faa5319fc" name="abcc75ac7d8839a0ed3f2bc9faa5319fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc75ac7d8839a0ed3f2bc9faa5319fc">&#9670;&#160;</a></span>RefDebugString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::PresolveContext::RefDebugString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To facilitate debugging. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01328">1328</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a11d119ebdd1d6b3b9cc8c1c6bdd4f629" name="a11d119ebdd1d6b3b9cc8c1c6bdd4f629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d119ebdd1d6b3b9cc8c1c6bdd4f629">&#9670;&#160;</a></span>RegisterVariablesUsedInAssumptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::RegisterVariablesUsedInAssumptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure we never delete an "assumption" literal by using a special constraint for that. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00591">591</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a826298c0beaf21a67b822c6578bf24d2" name="a826298c0beaf21a67b822c6578bf24d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826298c0beaf21a67b822c6578bf24d2">&#9670;&#160;</a></span>RemoveAllVariablesFromAffineRelationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::RemoveAllVariablesFromAffineRelationConstraint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00932">932</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a6a6515f2a16c6cf59218323ea6d06fdd" name="a6a6515f2a16c6cf59218323ea6d06fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6515f2a16c6cf59218323ea6d06fdd">&#9670;&#160;</a></span>RemoveNonRepresentativeAffineVariableIfUnused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::RemoveNonRepresentativeAffineVariableIfUnused </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If var is an unused variable in an affine relation and is not a representative, we can remove it from the model. Note that this requires the variable usage graph to be up to date. </p>
<p>Add relation with current representative to the mapping model.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00938">938</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ada0082b9fa71a8e1acf3572b3d8c8b5e" name="ada0082b9fa71a8e1acf3572b3d8c8b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0082b9fa71a8e1acf3572b3d8c8b5e">&#9670;&#160;</a></span>RemoveVariableFromAffineRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::RemoveVariableFromAffineRelation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. This should be called when a variable can be removed from the problem, so we don't count it as part of an affine relation anymore.</p>
<p>We only call that for a non representative variable that is only used in the kAffineRelationConstraint. Such variable can be ignored and should never be seen again in the presolve. </p>
<p>We shouldn't reuse this variable again!</p>
<p>We do not call EraseFromVarToConstraint() on purpose here since the variable is removed.</p>
<p>If the representative is left alone, we can remove it from the special affine relation constraint too.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00963">963</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a7c28c6dddefaa06e0c550a2de2cb16a4" name="a7c28c6dddefaa06e0c550a2de2cb16a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c28c6dddefaa06e0c550a2de2cb16a4">&#9670;&#160;</a></span>RemoveVariableFromObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::RemoveVariableFromObjective </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to manipulate the objective coefficients. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02078">2078</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="aac36698e66fbf7ae8920b82be903b0e0" name="aac36698e66fbf7ae8920b82be903b0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac36698e66fbf7ae8920b82be903b0e0">&#9670;&#160;</a></span>ResetAfterCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::ResetAfterCopy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a bit hacky. Clear some fields. See call site.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002224">Todo</a></b></dt><dd>(user): The ModelCopier should probably not depend on the full context it only need to read/write domains and call <a class="el" href="#ab43f7366b32b2ac40cc0f7f668040c49">UpdateRuleStats()</a>, so we might want to split that part out so that we can just initialize the full context later. Alternatively, we could just move more complex part of the context out, like the graph, the encoding, the affine representative, and so on to individual and easier to manage classes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01339">1339</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a394e849d9191a33e5052df380f79d0e4" name="a394e849d9191a33e5052df380f79d0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394e849d9191a33e5052df380f79d0e4">&#9670;&#160;</a></span>SetLiteralToFalse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::PresolveContext::SetLiteralToFalse </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns false if the 'lit' doesn't have the desired value in the domain. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00589">589</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a2a2aab8b3e16828d9adda83f1c7a3dd0" name="a2a2aab8b3e16828d9adda83f1c7a3dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2aab8b3e16828d9adda83f1c7a3dd0">&#9670;&#160;</a></span>SetLiteralToTrue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::PresolveContext::SetLiteralToTrue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00595">595</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a392085a404b28b5e5a405c4e115e5332" name="a392085a404b28b5e5a405c4e115e5332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392085a404b28b5e5a405c4e115e5332">&#9670;&#160;</a></span>ShiftCostInExactlyOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::ShiftCostInExactlyOne </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>exactly_one</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We can always add a multiple of sum X - 1 == 0 to the objective. However, depending on which multiple we choose, this might break our overflow preconditions on the objective. So we return false and do nothing if this happens. </p>
<p>We have to be careful because shifting cost like this might increase the min/max possible activity of the sum.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002214">Todo</a></b></dt><dd>(user): Be more precise with this objective_overflow_detection_ and always keep it up to date on each offset / coeff change. </dd></dl>
<p>The value will be zero if it wasn't present.</p>
<p>Term = coeff * (1 - X) = coeff - coeff * X; So -coeff -&gt; -coeff -shift And Term = coeff + shift - shift - (coeff + shift) * X = (coeff + shift) * (1 - X) - shift;</p>
<dl class="section note"><dt>Note</dt><dd>the domain never include the offset, so we need to update it.</dd></dl>
<p>When we shift the cost using an exactly one, our objective implied bounds might be more or less precise. If the objective domain is not constraining (and thus just constraining the upper bound), we relax it to make sure its stay "non constraining".</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002215">Todo</a></b></dt><dd>(user): This is a bit hacky, find a nicer way. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02226">2226</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a47955e47d62eaffce306ff330e7f7826" name="a47955e47d62eaffce306ff330e7f7826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47955e47d62eaffce306ff330e7f7826">&#9670;&#160;</a></span>SizeMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::SizeMax </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00403">403</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a58662aa4ff75862225aa88d319c423ac" name="a58662aa4ff75862225aa88d319c423ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58662aa4ff75862225aa88d319c423ac">&#9670;&#160;</a></span>SizeMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::SizeMin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00397">397</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="afcd68da91643e55c494dc497262d92a3" name="afcd68da91643e55c494dc497262d92a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd68da91643e55c494dc497262d92a3">&#9670;&#160;</a></span>solution_crush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SolutionCrush.html">SolutionCrush</a> &amp; operations_research::sat::PresolveContext::solution_crush </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00632">632</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a9cb69d4b9fe286e3825190b0afdd3452" name="a9cb69d4b9fe286e3825190b0afdd3452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb69d4b9fe286e3825190b0afdd3452">&#9670;&#160;</a></span>StartMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::StartMax </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00379">379</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ad060a6d7defa84a7a3b9e194f640a7d4" name="ad060a6d7defa84a7a3b9e194f640a7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad060a6d7defa84a7a3b9e194f640a7d4">&#9670;&#160;</a></span>StartMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::StartMin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00373">373</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a21f9fb012d35d444b8d3438157f5c9c3" name="a21f9fb012d35d444b8d3438157f5c9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f9fb012d35d444b8d3438157f5c9c3">&#9670;&#160;</a></span>StoreAffineRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::StoreAffineRelation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>debug_no_recursion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the relation (var_x = coeff * var_y + offset) to the repository. Returns false if we detect infeasability because of this.</p>
<p>Once the relation is added, it doesn't need to be enforced by a constraint in the model proto, since we will propagate such relation directly and add them to the proto at the end of the presolve.</p>
<dl class="section note"><dt>Note</dt><dd>this should always add a relation, even though it might need to create a new representative for both var_x and var_y in some cases. Like if x = 3z and y = 5t are already added, if we add x = 2y, we have 3z = 10t and can only resolve this by creating a new variable r such that z = 10r and t = 3r.</dd></dl>
<p>All involved variables will be marked to appear in the special kAffineRelationConstraint. This will allow to identify when a variable is no longer needed (only appear there and is not a representative). </p>
<p>Sets var_y's value to the solution of "var_x's value - coeff * var_y's value = offset".</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002207">Todo</a></b></dt><dd>(user): I am not 100% sure why, but sometimes the representative is fixed but that is not propagated to var_x or var_y and this causes issues. </dd></dl>
<p>If both are already in the same class, we need to make sure the relations are compatible.</p>
<p>x = rx.coeff * rep + rx.offset; y = ry.coeff * rep + ry.offset; And x == coeff * ry.coeff * rep + (coeff * ry.offset + offset).</p>
<p>So we get the relation a * rep == b with a and b defined here:</p>
<p>var_x = coeff * var_y + offset; rx.coeff * rep_x + rx.offset = coeff * (ry.coeff * rep_y + ry.offset) + offset</p>
<p>We have a * rep_x + b * rep_y == o</p>
<p>In this (rare) case, we need to canonicalize one of the variable that will become the representative for both.</p>
<p>Re-add the relation now that a will resolve to a multiple of b.</p>
<p>Canonicalize from (a * rep_x + b * rep_y = o) to (x = c * y + o).</p>
<p>Lets propagate domains first.</p>
<p>To avoid corner cases where replacing x by y in a linear expression can cause overflow, we might want to canonicalize y first to avoid cases like x = c * [large_value, ...] - large_value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002208">Todo</a></b></dt><dd>(user): we can do better for overflow by not always choosing the min at zero, do the best things if it becomes needed. </dd></dl>
<p>Both these function recursively call <a class="el" href="#a21f9fb012d35d444b8d3438157f5c9c3">StoreAffineRelation()</a> but shouldn't be able to cascade (CHECKED).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002209">Todo</a></b></dt><dd>(user): can we force the rep and remove <a class="el" href="#ab5d4fbe94ad2402fb6bad6225b423572" title="Returns the representative of ref under the affine relations.">GetAffineRelation()</a>? </dd></dl>
<p>Lets propagate again the new relation. We might as well do it as early as possible and not all call site do it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002210">Todo</a></b></dt><dd>(user): I am not sure this is needed given the propagation above. </dd></dl>
<p>These maps should only contains representative, so only need to remap either x or y.</p>
<p>The domain didn't change, but this notification allows to re-process any constraint containing these variables. Note that we do not need to retrigger a propagation of the constraint containing a variable whose representative didn't change.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01083">1083</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a553eb7c65eeadc906305afd24c6e8ef5" name="a553eb7c65eeadc906305afd24c6e8ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553eb7c65eeadc906305afd24c6e8ef5">&#9670;&#160;</a></span>StoreBooleanEqualityRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::sat::PresolveContext::StoreBooleanEqualityRelation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref_b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the fact that ref_a == ref_b using <a class="el" href="#a21f9fb012d35d444b8d3438157f5c9c3">StoreAffineRelation()</a> above. Returns false if this makes the problem infeasible. </p>
<p>a = b</p>
<p>a = 1 - b</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01261">1261</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a1c2e2998571c6d42aab23f0f4ad8b5a5" name="a1c2e2998571c6d42aab23f0f4ad8b5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2e2998571c6d42aab23f0f4ad8b5a5">&#9670;&#160;</a></span>StoreLiteralImpliesVarEqValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::StoreLiteralImpliesVarEqValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the fact that literal implies var == value. It returns true if that information is new. </p>
<p>The literal cannot be true.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01665">1665</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ad98b92e80b8333221127c9c1ca073418" name="ad98b92e80b8333221127c9c1ca073418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b92e80b8333221127c9c1ca073418">&#9670;&#160;</a></span>StoreLiteralImpliesVarNEqValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::StoreLiteralImpliesVarNEqValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the fact that literal implies var != value. It returns true if that information is new. </p>
<p>The constraint is trivial.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l01675">1675</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a31bffaf05dc1044c33640439b03a0a32" name="a31bffaf05dc1044c33640439b03a0a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bffaf05dc1044c33640439b03a0a32">&#9670;&#160;</a></span>SubstituteVariableInObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::SubstituteVariableInObjective </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var_in_equality</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>coeff_in_equality</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstraintProto &amp;</td>          <td class="paramname"><span class="paramname"><em>equality</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a variable defined by the given inequality that also appear in the objective, remove it from the objective by transferring its cost to other variables in the equality.</p>
<p>Returns false, if the substitution cannot be done. This is the case if the model become UNSAT or if doing it will result in an objective that do not satisfy our overflow preconditions. Note that this can only happen if the substituted variable is not implied free (i.e. if its domain is smaller than the implied domain from the equality). </p>
<p>We can only "easily" substitute if the objective coefficient is a multiple of the one in the constraint.</p>
<p>Abort if the new objective seems to violate our overflow preconditions.</p>
<p>Compute the objective offset change.</p>
<p>We also need to make sure the integer_offset will not overflow.</p>
<p>Perform the substitution.</p>
<p>Because we can assume that the constraint we used was constraining (otherwise it would have been removed), the objective domain should be now constraining.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02127">2127</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ab9a606ad9026a599315765e615bcd9a2" name="ab9a606ad9026a599315765e615bcd9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a606ad9026a599315765e615bcd9a2">&#9670;&#160;</a></span>time_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> * operations_research::sat::PresolveContext::time_limit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00640">640</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="aaaebbe40a33ffb948566c7fb2ec6ad03" name="aaaebbe40a33ffb948566c7fb2ec6ad03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaebbe40a33ffb948566c7fb2ec6ad03">&#9670;&#160;</a></span>UpdateConstraintVariableUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::UpdateConstraintVariableUsage </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the constraints &lt;-&gt; variables graph. This needs to be called each time a constraint is modified. </p>
<p>We don't optimize the interval usage as this is not super frequent.</p>
<p>For the variables, we avoid an erase() followed by an insert() for the variables that didn't change.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00705">705</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ac58a2f700fb28455324dd0268a9d510b" name="ac58a2f700fb28455324dd0268a9d510b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58a2f700fb28455324dd0268a9d510b">&#9670;&#160;</a></span>UpdateNewConstraintsVariableUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::UpdateNewConstraintsVariableUsage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="#aaaebbe40a33ffb948566c7fb2ec6ad03">UpdateConstraintVariableUsage()</a> on all newly created constraints. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00762">762</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ab43f7366b32b2ac40cc0f7f668040c49" name="ab43f7366b32b2ac40cc0f7f668040c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43f7366b32b2ac40cc0f7f668040c49">&#9670;&#160;</a></span>UpdateRuleStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::UpdateRuleStats </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_times</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a description of a rule that was just applied to have a summary of what the presolve did at the end. </p>
<p>Hack: we don't want to count </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002205">Todo</a></b></dt><dd>rules as this is used to decide if we loop again. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00621">621</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a8a019b435421dc660539167f29ec3e10" name="a8a019b435421dc660539167f29ec3e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a019b435421dc660539167f29ec3e10">&#9670;&#160;</a></span>VariableIsNotUsedAnymore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableIsNotUsedAnymore </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this ref no longer appears in the model. </p>
<p>Here, even if the variable is equivalent to others, if its affine defining constraints where removed, then it is not needed anymore. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00444">444</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a5987035843beaea2cadbd7ab5a78889a" name="a5987035843beaea2cadbd7ab5a78889a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5987035843beaea2cadbd7ab5a78889a">&#9670;&#160;</a></span>VariableIsOnlyUsedInEncodingAndMaybeInObjective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableIsOnlyUsedInEncodingAndMaybeInObjective </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if an integer variable is only appearing in the rhs of constraints of the form lit =&gt; var in domain. When this is the case, then we can usually remove this variable and replace these constraints with the proper constraints on the enforcement literals. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00475">475</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a507c1fe68c32e41d59517d951b1ea532" name="a507c1fe68c32e41d59517d951b1ea532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507c1fe68c32e41d59517d951b1ea532">&#9670;&#160;</a></span>VariableIsOnlyUsedInLinear1AndOneExtraConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableIsOnlyUsedInLinear1AndOneExtraConstraint </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="#a5987035843beaea2cadbd7ab5a78889a">VariableIsOnlyUsedInEncodingAndMaybeInObjective()</a> for the case where we have one extra constraint instead of the objective. Sometimes it is possible to transfer the linear1 domain restrictions to another variable. for instance if the other constraint is of the form Y = abs(X) or Y = X^2, then a domain restriction on Y can be transferred to X. We can then move the extra constraint to the mapping model and remove one variable. This happens on the flatzinc celar problems for instance. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00485">485</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a8f26296a4c9f4280fda73ffed51d0eed" name="a8f26296a4c9f4280fda73ffed51d0eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f26296a4c9f4280fda73ffed51d0eed">&#9670;&#160;</a></span>VariableIsUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableIsUnique </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this ref only appear in one constraint. </p>
<p>Tricky: If this variable is equivalent to another one (but not the representative) and appear in just one constraint, then this constraint must be the affine defining one. And in this case the code using this function should do the proper stuff. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00413">413</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a1cbe5a730a5b9ed96b24c2c123e1c346" name="a1cbe5a730a5b9ed96b24c2c123e1c346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbe5a730a5b9ed96b24c2c123e1c346">&#9670;&#160;</a></span>VariableIsUniqueAndRemovable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableIsUniqueAndRemovable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00419">419</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a9027a47ca0ff076eb618b4bbbb3eaffe" name="a9027a47ca0ff076eb618b4bbbb3eaffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9027a47ca0ff076eb618b4bbbb3eaffe">&#9670;&#160;</a></span>VariableWasRemoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableWasRemoved </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note(user): I added an indirection and a function for this to be able to display debug information when this return false. This should actually never return false in the cases where it is used. </p>
<p>It is okay to reuse removed fixed variable.</p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00456">456</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ae3462352cb8945d9a90ef835a5413409" name="ae3462352cb8945d9a90ef835a5413409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3462352cb8945d9a90ef835a5413409">&#9670;&#160;</a></span>VariableWithCostIsUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableWithCostIsUnique </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a1cbe5a730a5b9ed96b24c2c123e1c346">VariableIsUniqueAndRemovable()</a> except that in this case the variable also appear in the objective in addition to a single constraint. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00424">424</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="a2dc7d287336c388e703889282993257d" name="a2dc7d287336c388e703889282993257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc7d287336c388e703889282993257d">&#9670;&#160;</a></span>VariableWithCostIsUniqueAndRemovable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::PresolveContext::VariableWithCostIsUniqueAndRemovable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tricky: Same remark as for <a class="el" href="#a1cbe5a730a5b9ed96b24c2c123e1c346">VariableIsUniqueAndRemovable()</a>.</p>
<p>Also if the objective domain is constraining, we can't have a preferred direction, so we cannot easily remove such variable. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l00435">435</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ab7cbf3fdc8cc1d820606cddb63de4241" name="ab7cbf3fdc8cc1d820606cddb63de4241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cbf3fdc8cc1d820606cddb63de4241">&#9670;&#160;</a></span>VarToConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const absl::flat_hash_set&lt; int &gt; &amp; operations_research::sat::PresolveContext::VarToConstraints </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00571">571</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a4ba68399455fe4b7df13160b225137d3" name="a4ba68399455fe4b7df13160b225137d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba68399455fe4b7df13160b225137d3">&#9670;&#160;</a></span>WriteObjectiveToProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::WriteObjectiveToProto </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We need to sort the entries to be deterministic. </p><dl class="section note"><dt>Note</dt><dd>&ndash;cpu_profile shows it is slightly faster to only compare key.</dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02298">2298</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<a id="ac461a0ca5f496b70b12578939a12855e" name="ac461a0ca5f496b70b12578939a12855e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac461a0ca5f496b70b12578939a12855e">&#9670;&#160;</a></span>WriteVariableDomainsToProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::PresolveContext::WriteVariableDomainsToProto </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some function need the domain to be up to date in the proto. This make sures our in-memory domain are written back to the proto. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8cc_source.html#l02332">2332</a> of file <a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a036dd9262c47acb71c05816e82f40f9d" name="a036dd9262c47acb71c05816e82f40f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036dd9262c47acb71c05816e82f40f9d">&#9670;&#160;</a></span>deductions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html">DomainDeductions</a> operations_research::sat::PresolveContext::deductions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced presolve. See this class comment. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00667">667</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="aecdea9a3ee9d89bc4faf30c485fdbe93" name="aecdea9a3ee9d89bc4faf30c485fdbe93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdea9a3ee9d89bc4faf30c485fdbe93">&#9670;&#160;</a></span>mapping_model</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpModelProto* operations_research::sat::PresolveContext::mapping_model = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00644">644</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a2781de28b740a39c605bba56a0f65454" name="a2781de28b740a39c605bba56a0f65454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2781de28b740a39c605bba56a0f65454">&#9670;&#160;</a></span>modified_domains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt;int&gt; operations_research::sat::PresolveContext::modified_domains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each time a domain is modified this is set to true. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00660">660</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a466d33d9ecb905e979b48094e5b4d300" name="a466d33d9ecb905e979b48094e5b4d300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466d33d9ecb905e979b48094e5b4d300">&#9670;&#160;</a></span>num_presolve_operations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::PresolveContext::num_presolve_operations = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of "rules" applied. This should be equal to the sum of all numbers in stats_by_rule_name. This is used to decide if we should do one more pass of the presolve or not. Note that depending on the presolve transformation, a rule can correspond to a tiny change or a big change. Because of that, this isn't a perfect proxy for the efficacy of the presolve. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00651">651</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a72b078d19854dc81f894f25bf16df419" name="a72b078d19854dc81f894f25bf16df419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b078d19854dc81f894f25bf16df419">&#9670;&#160;</a></span>tmp_left_domains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classoperations__research_1_1Domain.html">Domain</a>&gt; operations_research::sat::PresolveContext::tmp_left_domains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00656">656</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a8c4e4d1872cce837619b241b42b78f89" name="a8c4e4d1872cce837619b241b42b78f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4e4d1872cce837619b241b42b78f89">&#9670;&#160;</a></span>tmp_literal_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::flat_hash_set&lt;int&gt; operations_research::sat::PresolveContext::tmp_literal_set</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00657">657</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="aad6a1238ac4eb29d5265fbd6ec6a33eb" name="aad6a1238ac4eb29d5265fbd6ec6a33eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6a1238ac4eb29d5265fbd6ec6a33eb">&#9670;&#160;</a></span>tmp_literals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; operations_research::sat::PresolveContext::tmp_literals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temporary storage. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00654">654</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a1a5b14b5437ebc3bbf7820747578a5fe" name="a1a5b14b5437ebc3bbf7820747578a5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5b14b5437ebc3bbf7820747578a5fe">&#9670;&#160;</a></span>tmp_term_domains</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classoperations__research_1_1Domain.html">Domain</a>&gt; operations_research::sat::PresolveContext::tmp_term_domains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00655">655</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="aaaefeb795ad5715de17b544daac7585e" name="aaaefeb795ad5715de17b544daac7585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaefeb795ad5715de17b544daac7585e">&#9670;&#160;</a></span>var_with_reduced_small_degree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt;int&gt; operations_research::sat::PresolveContext::var_with_reduced_small_degree</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each time the constraint &lt;-&gt; variable graph is updated, we update this. A variable is added here iff its usage decreased and is now one or two. </p>

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00664">664</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<a id="a1a267c1154e80e2966e5a39128e55b21" name="a1a267c1154e80e2966e5a39128e55b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a267c1154e80e2966e5a39128e55b21">&#9670;&#160;</a></span>working_model</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpModelProto* operations_research::sat::PresolveContext::working_model = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__context_8h_source.html#l00643">643</a> of file <a class="el" href="presolve__context_8h_source.html">presolve_context.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="presolve__context_8h_source.html">presolve_context.h</a></li>
<li>ortools/sat/<a class="el" href="presolve__context_8cc_source.html">presolve_context.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
