<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::DualBoundStrengthening Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1DualBoundStrengthening.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1DualBoundStrengthening-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::DualBoundStrengthening Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="var__domination_8h_source.html">var_domination.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1692fb6955639aada418f71ce0036d1a" id="r_a1692fb6955639aada418f71ce0036d1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1692fb6955639aada418f71ce0036d1a">Reset</a> (int num_variables)</td></tr>
<tr class="separator:a1692fb6955639aada418f71ce0036d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f78681f549714a6bcfabc007aa985d" id="r_aa3f78681f549714a6bcfabc007aa985d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3f78681f549714a6bcfabc007aa985d">CannotDecrease</a> (absl::Span&lt; const int &gt; refs, int ct_index=-1)</td></tr>
<tr class="memdesc:aa3f78681f549714a6bcfabc007aa985d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All constraints should be mapped to one of more call to these functions.  <br /></td></tr>
<tr class="separator:aa3f78681f549714a6bcfabc007aa985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31edd0f3dd4c3007d38ba1525d2d8081" id="r_a31edd0f3dd4c3007d38ba1525d2d8081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31edd0f3dd4c3007d38ba1525d2d8081">CannotIncrease</a> (absl::Span&lt; const int &gt; refs, int ct_index=-1)</td></tr>
<tr class="separator:a31edd0f3dd4c3007d38ba1525d2d8081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08eeb32696d5fb41820ab88b1321b46" id="r_ac08eeb32696d5fb41820ab88b1321b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac08eeb32696d5fb41820ab88b1321b46">CannotMove</a> (absl::Span&lt; const int &gt; refs, int ct_index=-1)</td></tr>
<tr class="separator:ac08eeb32696d5fb41820ab88b1321b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfcf291ae4f0984309bbbb96439a8cf" id="r_afcfcf291ae4f0984309bbbb96439a8cf"><td class="memTemplParams" colspan="2">template&lt;typename LinearProto&gt; </td></tr>
<tr class="memitem:afcfcf291ae4f0984309bbbb96439a8cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afcfcf291ae4f0984309bbbb96439a8cf">ProcessLinearConstraint</a> (bool is_objective, const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;context, const LinearProto &amp;linear, int64_t min_activity, int64_t max_activity, int ct_index=-1)</td></tr>
<tr class="memdesc:afcfcf291ae4f0984309bbbb96439a8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most of the logic here deals with linear constraints.  <br /></td></tr>
<tr class="separator:afcfcf291ae4f0984309bbbb96439a8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162bcb064138a579ee8192ffb9c244cb" id="r_a162bcb064138a579ee8192ffb9c244cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a162bcb064138a579ee8192ffb9c244cb">Strengthen</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context)</td></tr>
<tr class="separator:a162bcb064138a579ee8192ffb9c244cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19828a65b8b23fc0070664bf10834df3" id="r_a19828a65b8b23fc0070664bf10834df3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19828a65b8b23fc0070664bf10834df3">CanFreelyDecreaseUntil</a> (int ref) const</td></tr>
<tr class="separator:a19828a65b8b23fc0070664bf10834df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad421f7918c277b38d6f988d7f30bd8d0" id="r_ad421f7918c277b38d6f988d7f30bd8d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad421f7918c277b38d6f988d7f30bd8d0">NumDeletedConstraints</a> () const</td></tr>
<tr class="memdesc:ad421f7918c277b38d6f988d7f30bd8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset on each <a class="el" href="#a162bcb064138a579ee8192ffb9c244cb">Strengthen()</a> call.  <br /></td></tr>
<tr class="separator:ad421f7918c277b38d6f988d7f30bd8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This detects variables that can move freely in one direction, or that can move freely as long as their value do not cross a bound.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002531">Todo</a></b></dt><dd>(user): This is actually an important step to do before scaling as it can usually reduce really large bounds! </dd></dl>

<p class="definition">Definition at line <a class="el" href="var__domination_8h_source.html#l00223">223</a> of file <a class="el" href="var__domination_8h_source.html">var_domination.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a19828a65b8b23fc0070664bf10834df3" name="a19828a65b8b23fc0070664bf10834df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19828a65b8b23fc0070664bf10834df3">&#9670;&#160;</a></span>CanFreelyDecreaseUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::DualBoundStrengthening::CanFreelyDecreaseUntil </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The given ref can always freely decrease until the returned value. </p><dl class="section note"><dt>Note</dt><dd>this does not take into account the domain of the variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="var__domination_8h_source.html#l00256">256</a> of file <a class="el" href="var__domination_8h_source.html">var_domination.h</a>.</p>

</div>
</div>
<a id="aa3f78681f549714a6bcfabc007aa985d" name="aa3f78681f549714a6bcfabc007aa985d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f78681f549714a6bcfabc007aa985d">&#9670;&#160;</a></span>CannotDecrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DualBoundStrengthening::CannotDecrease </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>refs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All constraints should be mapped to one of more call to these functions. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002510">Todo</a></b></dt><dd>(user): No need to set locking_ct_index_[var] if num_locks_[var] &gt; 1 </dd></dl>
<p>Optim: We cache pointers to avoid refetching them in the loop.</p>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l00564">564</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<a id="a31edd0f3dd4c3007d38ba1525d2d8081" name="a31edd0f3dd4c3007d38ba1525d2d8081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31edd0f3dd4c3007d38ba1525d2d8081">&#9670;&#160;</a></span>CannotIncrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DualBoundStrengthening::CannotIncrease </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>refs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optim: We cache pointers to avoid refetching them in the loop.</p>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l00578">578</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<a id="ac08eeb32696d5fb41820ab88b1321b46" name="ac08eeb32696d5fb41820ab88b1321b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08eeb32696d5fb41820ab88b1321b46">&#9670;&#160;</a></span>CannotMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DualBoundStrengthening::CannotMove </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>refs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optim: We cache pointers to avoid refetching them in the loop.</p>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l00592">592</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<a id="ad421f7918c277b38d6f988d7f30bd8d0" name="ad421f7918c277b38d6f988d7f30bd8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad421f7918c277b38d6f988d7f30bd8d0">&#9670;&#160;</a></span>NumDeletedConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::DualBoundStrengthening::NumDeletedConstraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset on each <a class="el" href="#a162bcb064138a579ee8192ffb9c244cb">Strengthen()</a> call. </p>

<p class="definition">Definition at line <a class="el" href="var__domination_8h_source.html#l00261">261</a> of file <a class="el" href="var__domination_8h_source.html">var_domination.h</a>.</p>

</div>
</div>
<a id="afcfcf291ae4f0984309bbbb96439a8cf" name="afcfcf291ae4f0984309bbbb96439a8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfcf291ae4f0984309bbbb96439a8cf">&#9670;&#160;</a></span>ProcessLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LinearProto&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DualBoundStrengthening::ProcessLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_objective</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LinearProto &amp;</td>          <td class="paramname"><span class="paramname"><em>linear</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>min_activity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_activity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ct_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most of the logic here deals with linear constraints. </p>
<p>lb side.</p>
<p>We never want to increase the objective value. Note that if the objective is lower bounded, we checked that on the lb side above.</p>
<p>ub side.</p>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l00611">611</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<a id="a1692fb6955639aada418f71ce0036d1a" name="a1692fb6955639aada418f71ce0036d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1692fb6955639aada418f71ce0036d1a">&#9670;&#160;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::DualBoundStrengthening::Reset </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_variables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the class to a clean state. This must be called before processing the constraints. </p>

<p class="definition">Definition at line <a class="el" href="var__domination_8h_source.html#l00227">227</a> of file <a class="el" href="var__domination_8h_source.html">var_domination.h</a>.</p>

</div>
</div>
<a id="a162bcb064138a579ee8192ffb9c244cb" name="a162bcb064138a579ee8192ffb9c244cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162bcb064138a579ee8192ffb9c244cb">&#9670;&#160;</a></span>Strengthen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::DualBoundStrengthening::Strengthen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Once ALL constraints have been processed, call this to fix variables or reduce their domain if possible.</p>
<dl class="section note"><dt>Note</dt><dd>this also tighten some constraint that are the only one blocking in one direction. Currently we only do that for implication, so that if we have two Booleans such that a + b &lt;= 1 we transform that to = 1 and we remove one variable since we have now an equivalence relation. </dd></dl>
<p>Fix to lb?</p>
<p>Fix to ub?</p>
<p>Here we can fix to any value in [ub_limit, lb_limit] that is compatible with the current domain. We prefer zero or the lowest possible magnitude.</p>
<p>Here we can reduce the domain, but we must be careful when the domain has holes.</p>
<p>For detecting near-duplicate constraint that can be made equivalent. hash -&gt; (ct_index, modified ref).</p>
<p>If there is only one blocking constraint, we can simplify the problem in a few situation.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002511">Todo</a></b></dt><dd>(user): Cover all the cases. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002512">Todo</a></b></dt><dd>(user): Fix variable right away rather than waiting for next call. </dd></dl>
<p>If we have an enforcement literal then we can always add the implication "not enforced" =&gt; var at its lower bound. If we also have enforced =&gt; fixed var, then var is in affine relation with the enforced literal and we can remove one variable.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002513">Todo</a></b></dt><dd>(user): We can also deal with more than one enforcement. </dd></dl>
<p>Corner case.</p>
<p>Note(user): If we have enforced =&gt; var fixed, we could actually just have removed var from the constraint it was implied by another constraint. If not, because of the new affine relation we could remove it right away.</p>
<p>The new affine relation added below can break the hint if hint(enf) is 0. In this case the only constraint blocking <code>ref</code> from decreasing [<code>ct</code> = enf =&gt; (var = implied)] does not apply. We can thus set the hint of <code>positive_ref</code> to <code>bound</code> to preserve the hint feasibility.</p>
<p>positive_ref = enf * implied + (1 - enf) * bound.</p>
<p>enf_var = PositiveRef(enf). positive_ref = (1 - enf_var) * implied + enf_var * bound.</p>
<p>If we have a literal, we always add the implication. This seems like a good thing to do.</p>
<p>The new implication can break the hint if hint(enf) is 0 and hint(ref) is 1. In this case the only locking constraint <code>ct</code> does not apply and thus does not prevent decreasing the hint of ref in order to preserve the hint feasibility.</p>
<p>We can add an implication not_enforced =&gt; var to its bound ?</p>
<p>We can make enf equivalent to the constraint instead of just =&gt;. This seems useful since internally we always use fully reified encoding.</p>
<p>If it is different, we have an equivalence now, and we can remove the constraint.</p>
<p>Extending <code>ct</code> = "not(ref) =&gt; encoding_lit" to an equality can break the hint only if hint(ref) = hint(encoding_lit) = 1. But in this case <code>ct</code> is actually not blocking ref from decreasing. We can thus set its hint to 0 to preserve the hint feasibility.</p>
<p>Extending <code>ct</code> = "not(ref) =&gt; not(encoding_lit)" to an equality can break the hint only if hint(encoding_lit) = 0 and hint(ref) = 1. But in this case <code>ct</code> is actually not blocking ref from decreasing. We can thus set its hint to 0 to preserve the hint feasibility.</p>
<p><code>encoding_lit</code> was maybe a new variable added during this loop, so make sure we cannot go out-of-bound.</p>
<p>The <code>new_ct</code> constraint <code>ref</code> =&gt; (<code>var</code> in <code>complement</code>) below can break the hint if hint(var) is not in <code>complement</code>. In this case, set the hint of <code>ref</code> to false. This should be safe since the only constraint blocking <code>ref</code> from decreasing is <code>ct</code> = not(ref) =&gt; (<code>var</code> in <code>rhs</code>) &ndash; which does not apply when <code>ref</code> is true.</p>
<p>If we have two Booleans, each with a single blocking constraint that is the same if we "swap" the Booleans reference, then we can make the Booleans equivalent. This is because they will be forced to their bad value only if it is needed by the other part of their respective blocking constraints. This is related to the FindAlmostIdenticalLinearConstraints() except that here we can deal with non-equality or enforced constraints.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002514">Todo</a></b></dt><dd>(user): Generalize to non-Boolean. Also for Boolean, we might miss some possible reduction if replacing X by 1 - X make a constraint near-duplicate of another.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002515">Todo</a></b></dt><dd>(user): We can generalize to non-linear constraint.</dd></dl>
<p>Optimization: Skip if this constraint was already used as a single blocking constraint of another variable. If this is the case, it cannot be equivalent to another constraint with "var" substituted, since otherwise var would have two blocking constraint. We can safely skip it. this make sure this is in O(num_entries) and not more.</p>
<p>Already present!</p>
<p>Corner case: We just discovered l =&gt; ct and not(l) =&gt; ct. So ct must just always be true. And since that was the only blocking constraint for l, we can just set l to an arbitrary value.</p>
<p>We have a true equality. The two ref can be made equivalent.</p>
<p>If the two hints are different, and since both refs have an equivalent blocking constraint, then the constraint is actually not blocking the ref at 1 from decreasing. Hence we can set its hint to false to preserve the hint feasibility despite the new Boolean equality constraint.</p>
<p>We can delete one of the constraint since they are duplicate now.</p>
<p>Other potential cases?</p>
<p>If (a =&gt; b) is the only constraint blocking a literal a in the up direction, then we can set a == b !</p>
<p>Recover a =&gt; b where a is having an unique up_lock (i.e this constraint). </p><dl class="section note"><dt>Note</dt><dd>if many implications are encoded in the same bool_and, we have to be careful that a is appearing in just one of them.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002516">Todo</a></b></dt><dd>(user): Make sure implication graph is transitively reduced to not miss such reduction. More generally, this might only use the graph rather than the encoding into bool_and / at_most_one ? Basically if a =&gt; all_direct_deduction, we can transform it into a &lt;=&gt; all_direct_deduction if that is interesting. This could always be done on a max-2sat problem in one of the two direction. Also think about max-2sat specific presolve. </dd></dl>
<p>Here, we can only add the equivalence if the literal is the only on the lhs, otherwise there is actually more lock.</p>
<p>If hint(a) is false we can always set it to hint(b) since this can only increase its value. If hint(a) is true then hint(b) must be true as well if the hint is feasible, due to the a =&gt; b constraint. Setting hint(a) to hint(b) is thus always safe. The opposite is true as well.</p>

<p class="definition">Definition at line <a class="el" href="var__domination_8cc_source.html#l00725">725</a> of file <a class="el" href="var__domination_8cc_source.html">var_domination.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="var__domination_8h_source.html">var_domination.h</a></li>
<li>ortools/sat/<a class="el" href="var__domination_8cc_source.html">var_domination.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html">DualBoundStrengthening</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
