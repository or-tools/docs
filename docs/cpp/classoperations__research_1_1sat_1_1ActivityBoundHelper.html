<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::ActivityBoundHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.9</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1ActivityBoundHelper.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1ActivityBoundHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::ActivityBoundHelper Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="presolve__util_8h_source.html">presolve_util.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac397a50c41675b3e5b4ca938e167e1b9" id="r_ac397a50c41675b3e5b4ca938e167e1b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac397a50c41675b3e5b4ca938e167e1b9">ActivityBoundHelper</a> ()=default</td></tr>
<tr class="separator:ac397a50c41675b3e5b4ca938e167e1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0479a3ccd9b93609871b72a28f0b0496" id="r_a0479a3ccd9b93609871b72a28f0b0496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0479a3ccd9b93609871b72a28f0b0496">ClearAtMostOnes</a> ()</td></tr>
<tr class="separator:a0479a3ccd9b93609871b72a28f0b0496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b3f1fb6f3eb25238908072ce9018a6" id="r_a90b3f1fb6f3eb25238908072ce9018a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90b3f1fb6f3eb25238908072ce9018a6">AddAtMostOne</a> (absl::Span&lt; const int &gt; amo)</td></tr>
<tr class="separator:a90b3f1fb6f3eb25238908072ce9018a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597d8e2ff729931de6b9e1e7df34298" id="r_a0597d8e2ff729931de6b9e1e7df34298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0597d8e2ff729931de6b9e1e7df34298">AddAllAtMostOnes</a> (const CpModelProto &amp;<a class="el" href="cp__model__fz__solver_8cc.html#aed003f5eb5197bc586b7ef2c36a63da2">proto</a>)</td></tr>
<tr class="separator:a0597d8e2ff729931de6b9e1e7df34298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569741972c7325665407db889dc36af" id="r_a7569741972c7325665407db889dc36af"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7569741972c7325665407db889dc36af">ComputeMaxActivity</a> (absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; terms, std::vector&lt; std::array&lt; int64_t, 2 &gt; &gt; *conditional=nullptr)</td></tr>
<tr class="separator:a7569741972c7325665407db889dc36af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d755f2c9cb18279897688370f7a7f" id="r_abf2d755f2c9cb18279897688370f7a7f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf2d755f2c9cb18279897688370f7a7f">ComputeMinActivity</a> (absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; terms, std::vector&lt; std::array&lt; int64_t, 2 &gt; &gt; *conditional=nullptr)</td></tr>
<tr class="separator:abf2d755f2c9cb18279897688370f7a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71179e60a9659f4899d68ad8472b679" id="r_ad71179e60a9659f4899d68ad8472b679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad71179e60a9659f4899d68ad8472b679">PresolveEnforcement</a> (absl::Span&lt; const int &gt; refs, ConstraintProto *<a class="el" href="demon__profiler_8cc.html#a05da18ca9c7b657a4a6ea24e07c9b695">ct</a>, absl::flat_hash_set&lt; int &gt; *literals_at_true)</td></tr>
<tr class="separator:ad71179e60a9659f4899d68ad8472b679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981ddaa8e6b0fba03b9aab2b491cde43" id="r_a981ddaa8e6b0fba03b9aab2b491cde43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981ddaa8e6b0fba03b9aab2b491cde43">RemoveEnforcementThatMakesConstraintTrivial</a> (absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; boolean_terms, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;other_terms, const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;rhs, ConstraintProto *<a class="el" href="demon__profiler_8cc.html#a05da18ca9c7b657a4a6ea24e07c9b695">ct</a>)</td></tr>
<tr class="separator:a981ddaa8e6b0fba03b9aab2b491cde43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfcc79dedf0f11235975e95d8e9a263" id="r_accfcc79dedf0f11235975e95d8e9a263"><td class="memItemLeft" align="right" valign="top">std::vector&lt; absl::Span&lt; const int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accfcc79dedf0f11235975e95d8e9a263">PartitionLiteralsIntoAmo</a> (absl::Span&lt; const int &gt; literals)</td></tr>
<tr class="memdesc:accfcc79dedf0f11235975e95d8e9a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar algo as above for this simpler case.  <br /></td></tr>
<tr class="separator:accfcc79dedf0f11235975e95d8e9a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0301f31120bf9d9b5ce799c2ef4983" id="r_aea0301f31120bf9d9b5ce799c2ef4983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea0301f31120bf9d9b5ce799c2ef4983">IsAmo</a> (absl::Span&lt; const int &gt; literals)</td></tr>
<tr class="memdesc:aea0301f31120bf9d9b5ce799c2ef4983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given literal are in at most one relationship.  <br /></td></tr>
<tr class="separator:aea0301f31120bf9d9b5ce799c2ef4983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2ab68ef37bce5ef7b4669909ae29c3" id="r_afb2ab68ef37bce5ef7b4669909ae29c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2ab68ef37bce5ef7b4669909ae29c3">NumAmoForVariable</a> (int <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="memdesc:afb2ab68ef37bce5ef7b4669909ae29c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in how many amo var or Not(var) are part of.  <br /></td></tr>
<tr class="separator:afb2ab68ef37bce5ef7b4669909ae29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Try to get more precise min/max activity of a linear constraints using at most ones from the model. This is heuristic based but should be relatively fast.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002083">Todo</a></b></dt><dd>(user): Use better algorithm. The problem is the same as finding upper bound to the classic problem: maximum-independent set in a graph. We also only use at most ones, but we could use the more general binary implication graph. </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__util_8h_source.html#l00167">167</a> of file <a class="el" href="presolve__util_8h_source.html">presolve_util.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac397a50c41675b3e5b4ca938e167e1b9" name="ac397a50c41675b3e5b4ca938e167e1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac397a50c41675b3e5b4ca938e167e1b9">&#9670;&#160;</a></span>ActivityBoundHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::ActivityBoundHelper::ActivityBoundHelper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0597d8e2ff729931de6b9e1e7df34298" name="a0597d8e2ff729931de6b9e1e7df34298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0597d8e2ff729931de6b9e1e7df34298">&#9670;&#160;</a></span>AddAllAtMostOnes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ActivityBoundHelper::AddAllAtMostOnes </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>proto</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002078">Todo</a></b></dt><dd>(user): Add long ones first, or at least the ones of size 2 after. </dd></dl>
<p>a =&gt; b same as amo(a, not(b)).</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00283">283</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="a90b3f1fb6f3eb25238908072ce9018a6" name="a90b3f1fb6f3eb25238908072ce9018a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b3f1fb6f3eb25238908072ce9018a6">&#9670;&#160;</a></span>AddAtMostOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ActivityBoundHelper::AddAtMostOne </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>amo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add it.</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00262">262</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="a0479a3ccd9b93609871b72a28f0b0496" name="a0479a3ccd9b93609871b72a28f0b0496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0479a3ccd9b93609871b72a28f0b0496">&#9670;&#160;</a></span>ClearAtMostOnes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ActivityBoundHelper::ClearAtMostOnes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The at most one constraint must be added before linear constraint are processed. The functions below will still works, but do nothing more than compute trivial bounds. </p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00257">257</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="a7569741972c7325665407db889dc36af" name="a7569741972c7325665407db889dc36af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569741972c7325665407db889dc36af">&#9670;&#160;</a></span>ComputeMaxActivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::ActivityBoundHelper::ComputeMaxActivity </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>terms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; int64_t, 2 &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>conditional</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the max/min activity of a linear expression involving only Booleans.</p>
<p>Accepts a list of (literal, coefficient). Note that all literal will be interpreted as referring to [0, 1] variables. We use the CpModelProto convention for negated literal index.</p>
<p>If conditional is not nullptr, then conditional[i][0/1] will give the max activity if the literal at position i is false/true. This can be used to fix variables or extract enforcement literal.</p>
<p>Important: We shouldn't have duplicates or a lit and NegatedRef(lit) appearing both.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002086">Todo</a></b></dt><dd>(user): Indicate when the bounds are trivial (i.e. not intersection with any amo) so that we don't waste more time processing the result? </dd></dl>

<p class="definition">Definition at line <a class="el" href="presolve__util_8h_source.html#l00194">194</a> of file <a class="el" href="presolve__util_8h_source.html">presolve_util.h</a>.</p>

</div>
</div>
<a id="abf2d755f2c9cb18279897688370f7a7f" name="abf2d755f2c9cb18279897688370f7a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d755f2c9cb18279897688370f7a7f">&#9670;&#160;</a></span>ComputeMinActivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::ActivityBoundHelper::ComputeMinActivity </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>terms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; int64_t, 2 &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>conditional</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="presolve__util_8h_source.html#l00199">199</a> of file <a class="el" href="presolve__util_8h_source.html">presolve_util.h</a>.</p>

</div>
</div>
<a id="aea0301f31120bf9d9b5ce799c2ef4983" name="aea0301f31120bf9d9b5ce799c2ef4983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0301f31120bf9d9b5ce799c2ef4983">&#9670;&#160;</a></span>IsAmo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ActivityBoundHelper::IsAmo </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the given literal are in at most one relationship. </p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00460">460</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="afb2ab68ef37bce5ef7b4669909ae29c3" name="afb2ab68ef37bce5ef7b4669909ae29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2ab68ef37bce5ef7b4669909ae29c3">&#9670;&#160;</a></span>NumAmoForVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::ActivityBoundHelper::NumAmoForVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in how many amo var or Not(var) are part of. </p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8h_source.html#l00234">234</a> of file <a class="el" href="presolve__util_8h_source.html">presolve_util.h</a>.</p>

</div>
</div>
<a id="accfcc79dedf0f11235975e95d8e9a263" name="accfcc79dedf0f11235975e95d8e9a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfcc79dedf0f11235975e95d8e9a263">&#9670;&#160;</a></span>PartitionLiteralsIntoAmo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; absl::Span&lt; const int &gt; &gt; operations_research::sat::ActivityBoundHelper::PartitionLiteralsIntoAmo </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar algo as above for this simpler case. </p>
<p>Partition the list of literals into disjoint at most ones. The returned spans are only valid until another function from this class is used. </p>
<p>New element.</p>
<p>We have the partition, lets construct the spans now.</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00408">408</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="ad71179e60a9659f4899d68ad8472b679" name="ad71179e60a9659f4899d68ad8472b679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71179e60a9659f4899d68ad8472b679">&#9670;&#160;</a></span>PresolveEnforcement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ActivityBoundHelper::PresolveEnforcement </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>refs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::flat_hash_set&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>literals_at_true</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes relevant info to presolve a constraint with enforcement using at most one information.</p>
<p>This returns false iff the enforcement list cannot be satisfied. It filters the enforcement list if some are consequences of other. It fills the given set with the literal that must be true due to the enforcement. Note that only literals or negated literal appearing in ref are filled. </p>
<p>If a previous enforcement literal implies this one, we can skip it.</p>
<p>Tricky: We need to do that before appending the amo containing ref in case an amo contains both ref and not(ref). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002080">Todo</a></b></dt><dd>(user): Ideally these amo should not be added to this class. </dd></dl>
<p>If some other literal is at one in this amo, literal must be false, and so the constraint cannot be enforced.</p>
<p>Keep this enforcement.</p>
<p>Skip already fixed.</p>
<p>If some other literal is at one in this amo, literal must be false.</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00532">532</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<a id="a981ddaa8e6b0fba03b9aab2b491cde43" name="a981ddaa8e6b0fba03b9aab2b491cde43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981ddaa8e6b0fba03b9aab2b491cde43">&#9670;&#160;</a></span>RemoveEnforcementThatMakesConstraintTrivial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::ActivityBoundHelper::RemoveEnforcementThatMakesConstraintTrivial </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>boolean_terms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other_terms</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each enforcement literal enf, if not(enf) implies that the constraint is trivial, then we can just remove not(enf) from the list.</p>
<p>Actually, we could even "lift" such enforcement so that if it is negative the constraint is still trivial but tighter. </p>
<p>Compute min_max activity when enf_lit is false.</p>
<p>This is not supposed to happen after <a class="el" href="#ad71179e60a9659f4899d68ad8472b679">PresolveEnforcement()</a>, so we just abort in this case.</p>
<p>Similarly, this is not supposed to happen after <a class="el" href="#ad71179e60a9659f4899d68ad8472b679">PresolveEnforcement()</a>.</p>

<p class="definition">Definition at line <a class="el" href="presolve__util_8cc_source.html#l00591">591</a> of file <a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="presolve__util_8h_source.html">presolve_util.h</a></li>
<li>ortools/sat/<a class="el" href="presolve__util_8cc_source.html">presolve_util.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">ActivityBoundHelper</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
