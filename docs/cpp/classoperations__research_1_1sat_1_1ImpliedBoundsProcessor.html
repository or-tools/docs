<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::ImpliedBoundsProcessor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::ImpliedBoundsProcessor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cuts_8h_source.html">cuts.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ImpliedBoundsProcessor_1_1BestImpliedBoundInfo.html">BestImpliedBoundInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a23b3aca01e279f03460758cb84586e" id="r_a5a23b3aca01e279f03460758cb84586e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a23b3aca01e279f03460758cb84586e">ImpliedBoundsProcessor</a> (absl::Span&lt; const IntegerVariable &gt; lp_vars_, <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *integer_trail, <a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html">ImpliedBounds</a> *implied_bounds)</td></tr>
<tr class="memdesc:a5a23b3aca01e279f03460758cb84586e"><td class="mdescLeft">&#160;</td><td class="mdescRight">We will only replace IntegerVariable appearing in lp_vars_.  <br /></td></tr>
<tr class="separator:a5a23b3aca01e279f03460758cb84586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7fcd3160d93b3084286547160eb208" id="r_a0f7fcd3160d93b3084286547160eb208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7fcd3160d93b3084286547160eb208">RecomputeCacheAndSeparateSomeImpliedBoundCuts</a> (const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;lp_values)</td></tr>
<tr class="separator:a0f7fcd3160d93b3084286547160eb208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa292900f68528b54007deb7cdb6f4aec" id="r_aa292900f68528b54007deb7cdb6f4aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa292900f68528b54007deb7cdb6f4aec">DecomposeWithImpliedLowerBound</a> (const <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;term, IntegerValue factor_t, <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;bool_term, <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;slack_term)</td></tr>
<tr class="separator:aa292900f68528b54007deb7cdb6f4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07ea8f89144bf9714261a08d9ddcb77" id="r_af07ea8f89144bf9714261a08d9ddcb77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af07ea8f89144bf9714261a08d9ddcb77">DecomposeWithImpliedUpperBound</a> (const <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;term, IntegerValue factor_t, <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;bool_term, <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;slack_term)</td></tr>
<tr class="separator:af07ea8f89144bf9714261a08d9ddcb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc85bd67065c500f99ed24f0dd044301" id="r_abc85bd67065c500f99ed24f0dd044301"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc85bd67065c500f99ed24f0dd044301">PostprocessWithImpliedBound</a> (const std::function&lt; IntegerValue(IntegerValue)&gt; &amp;f, IntegerValue factor_t, <a class="el" href="structoperations__research_1_1sat_1_1CutData.html">CutData</a> *cut)</td></tr>
<tr class="separator:abc85bd67065c500f99ed24f0dd044301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee15ed18f5569a246d4cc539da2c1f5" id="r_a1ee15ed18f5569a246d4cc539da2c1f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee15ed18f5569a246d4cc539da2c1f5">CacheDataForCut</a> (IntegerVariable first_slack, <a class="el" href="structoperations__research_1_1sat_1_1CutData.html">CutData</a> *cut)</td></tr>
<tr class="separator:a1ee15ed18f5569a246d4cc539da2c1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476cd1dece5678940ddedb54f6e41627" id="r_a476cd1dece5678940ddedb54f6e41627"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a476cd1dece5678940ddedb54f6e41627">TryToExpandWithLowerImpliedbound</a> (IntegerValue factor_t, bool complement, <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> *term, absl::int128 *rhs, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &gt; *new_bool_terms)</td></tr>
<tr class="separator:a476cd1dece5678940ddedb54f6e41627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbd37a1c84411764a0df5dacbcc06fd" id="r_a6fbd37a1c84411764a0df5dacbcc06fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1CutDataBuilder.html">CutDataBuilder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fbd37a1c84411764a0df5dacbcc06fd">MutableCutBuilder</a> ()</td></tr>
<tr class="memdesc:a6fbd37a1c84411764a0df5dacbcc06fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be used to share the hash-map memory.  <br /></td></tr>
<tr class="separator:a6fbd37a1c84411764a0df5dacbcc06fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa7a61a1bbd20d70d0928fc1c47cf92" id="r_a0aa7a61a1bbd20d70d0928fc1c47cf92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aa7a61a1bbd20d70d0928fc1c47cf92">ClearedMutableTempTerms</a> ()</td></tr>
<tr class="separator:a0aa7a61a1bbd20d70d0928fc1c47cf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618538c29ec3974591f1b5b38442270f" id="r_a618538c29ec3974591f1b5b38442270f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a618538c29ec3974591f1b5b38442270f">AddLpVariable</a> (IntegerVariable var)</td></tr>
<tr class="separator:a618538c29ec3974591f1b5b38442270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6897e016d6610d35940647ef434f906f" id="r_a6897e016d6610d35940647ef434f906f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1ImpliedBoundsProcessor_1_1BestImpliedBoundInfo.html">BestImpliedBoundInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6897e016d6610d35940647ef434f906f">GetCachedImpliedBoundInfo</a> (IntegerVariable var) const</td></tr>
<tr class="separator:a6897e016d6610d35940647ef434f906f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658717a9ed3e6d4389e9b8928c974e48" id="r_a658717a9ed3e6d4389e9b8928c974e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">TopNCuts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658717a9ed3e6d4389e9b8928c974e48">IbCutPool</a> ()</td></tr>
<tr class="separator:a658717a9ed3e6d4389e9b8928c974e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Given an upper-bounded linear relation (sum terms &lt;= ub), this algorithm inspects the integer variable appearing in the sum and try to replace each of them by a tight lower bound (&gt;= coeff * binary + lb) using the implied bound repository. By tight, we mean that it will take the same value under the current LP solution.</p>
<p>We use a class to reuse memory of the tmp terms. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8h_source.html#l00189">189</a> of file <a class="el" href="cuts_8h_source.html">cuts.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5a23b3aca01e279f03460758cb84586e" name="a5a23b3aca01e279f03460758cb84586e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a23b3aca01e279f03460758cb84586e">&#9670;&#160;</a></span>ImpliedBoundsProcessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::ImpliedBoundsProcessor::ImpliedBoundsProcessor </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>lp_vars_</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> *</td>          <td class="paramname"><span class="paramname"><em>integer_trail</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html">ImpliedBounds</a> *</td>          <td class="paramname"><span class="paramname"><em>implied_bounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We will only replace IntegerVariable appearing in lp_vars_. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8h_source.html#l00192">192</a> of file <a class="el" href="cuts_8h_source.html">cuts.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a618538c29ec3974591f1b5b38442270f" name="a618538c29ec3974591f1b5b38442270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618538c29ec3974591f1b5b38442270f">&#9670;&#160;</a></span>AddLpVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ImpliedBoundsProcessor::AddLpVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new variable that could be used in the new cuts. </p><dl class="section note"><dt>Note</dt><dd>the cache must be computed to take this into account. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cuts_8h_source.html#l00256">256</a> of file <a class="el" href="cuts_8h_source.html">cuts.h</a>.</p>

</div>
</div>
<a id="a1ee15ed18f5569a246d4cc539da2c1f5" name="a1ee15ed18f5569a246d4cc539da2c1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee15ed18f5569a246d4cc539da2c1f5">&#9670;&#160;</a></span>CacheDataForCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ImpliedBoundsProcessor::CacheDataForCut </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>first_slack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1CutData.html">CutData</a> *</td>          <td class="paramname"><span class="paramname"><em>cut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Precomputes quantities used by all cut generation. This allows to do that once rather than 6 times. Return false if there are no exploitable implied bounds. </p>
<p>Cache the <a class="el" href="structoperations__research_1_1sat_1_1ImpliedBoundsProcessor_1_1BestImpliedBoundInfo.html">BestImpliedBoundInfo</a> if relevant.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02319">2319</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a0aa7a61a1bbd20d70d0928fc1c47cf92" name="a0aa7a61a1bbd20d70d0928fc1c47cf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa7a61a1bbd20d70d0928fc1c47cf92">&#9670;&#160;</a></span>ClearedMutableTempTerms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &gt; * operations_research::sat::ImpliedBoundsProcessor::ClearedMutableTempTerms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be used as a temporary storage for <a class="el" href="#a476cd1dece5678940ddedb54f6e41627">TryToExpandWithLowerImpliedbound()</a>. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8h_source.html#l00249">249</a> of file <a class="el" href="cuts_8h_source.html">cuts.h</a>.</p>

</div>
</div>
<a id="aa292900f68528b54007deb7cdb6f4aec" name="aa292900f68528b54007deb7cdb6f4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa292900f68528b54007deb7cdb6f4aec">&#9670;&#160;</a></span>DecomposeWithImpliedLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ImpliedBoundsProcessor::DecomposeWithImpliedLowerBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>factor_t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bool_term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slack_term</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This assumes the term is simple: expr[0] = var - LB / UB - var. We use an implied lower bound on this expr, independently of the term.coeff sign.</p>
<p>If possible, returns true and express X = bool_term + slack_term. If coeff of X is positive, then all coeff will be positive here. </p>
<p>We only want to expand non-Boolean and non-slack term!</p>
<p>Try lower bounded direction for implied bound. This kind should always be beneficial if it exists:</p>
<p>Because X = bound_diff * B + S We can replace coeff * X by the expression before applying f: = f(coeff * bound_diff) * B + f(coeff) * [X - bound_diff * B] = f(coeff) * X + (f(coeff * bound_diff) - f(coeff) * bound_diff] * B So we can "lift" B into the cut with a non-negative coefficient.</p>
<dl class="section note"><dt>Note</dt><dd>this lifting is really the same as if we used that implied bound before since in f(coeff * bound_diff) * B + f(coeff) * S, if we replace S by its value [X - bound_diff * B] we get the same result.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001685">Todo</a></b></dt><dd>(user): Ignore if bound_diff == 1 ? But we can still merge B with another entry if it exists, so it can still be good in this case.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001686">Todo</a></b></dt><dd>(user): Only do it if coeff_b &gt; 0 ? But again we could still merge B with an existing Boolean for a better cut even if coeff_b == 0. </dd></dl>
<p>We have X/-X = info.diff * Boolean + slack.</p>
<p>Create slack. The expression is term.exp - bound_diff * bool_term The variable shouldn't be the same.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02119">2119</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="af07ea8f89144bf9714261a08d9ddcb77" name="af07ea8f89144bf9714261a08d9ddcb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07ea8f89144bf9714261a08d9ddcb77">&#9670;&#160;</a></span>DecomposeWithImpliedUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ImpliedBoundsProcessor::DecomposeWithImpliedUpperBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>factor_t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bool_term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slack_term</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This assumes the term is simple: expr[0] = var - LB / UB - var. We use an implied upper bound on this expr, independently of term.coeff sign.</p>
<p>If possible, returns true and express X = bool_term + slack_term. If coeff of X is positive, then bool_term will have a positive coeff but slack_term will have a negative one.</p>
<p>We use the fact that calling <a class="el" href="#aa292900f68528b54007deb7cdb6f4aec">DecomposeWithImpliedLowerBound()</a> with term.Complement() give us almost what we want. You have -complement(X) = -diff.B - slack</p><ul>
<li>(diff - X) = -diff.(1 -(1- B)) - slack X = diff.(1 - B) - slack; </li>
</ul>
<p>This is required not to have a constant term which might mess up our cut heuristics.</p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02189">2189</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a6897e016d6610d35940647ef434f906f" name="a6897e016d6610d35940647ef434f906f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6897e016d6610d35940647ef434f906f">&#9670;&#160;</a></span>GetCachedImpliedBoundInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1ImpliedBoundsProcessor_1_1BestImpliedBoundInfo.html">ImpliedBoundsProcessor::BestImpliedBoundInfo</a> operations_research::sat::ImpliedBoundsProcessor::GetCachedImpliedBoundInfo </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02029">2029</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a658717a9ed3e6d4389e9b8928c974e48" name="a658717a9ed3e6d4389e9b8928c974e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658717a9ed3e6d4389e9b8928c974e48">&#9670;&#160;</a></span>IbCutPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">TopNCuts</a> &amp; operations_research::sat::ImpliedBoundsProcessor::IbCutPool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As we compute the best implied bounds for each variable, we add violated cuts here. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8h_source.html#l00285">285</a> of file <a class="el" href="cuts_8h_source.html">cuts.h</a>.</p>

</div>
</div>
<a id="a6fbd37a1c84411764a0df5dacbcc06fd" name="a6fbd37a1c84411764a0df5dacbcc06fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbd37a1c84411764a0df5dacbcc06fd">&#9670;&#160;</a></span>MutableCutBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1CutDataBuilder.html">CutDataBuilder</a> * operations_research::sat::ImpliedBoundsProcessor::MutableCutBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This can be used to share the hash-map memory. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8h_source.html#l00245">245</a> of file <a class="el" href="cuts_8h_source.html">cuts.h</a>.</p>

</div>
</div>
<a id="abc85bd67065c500f99ed24f0dd044301" name="abc85bd67065c500f99ed24f0dd044301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc85bd67065c500f99ed24f0dd044301">&#9670;&#160;</a></span>PostprocessWithImpliedBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; int, int, int &gt; operations_research::sat::ImpliedBoundsProcessor::PostprocessWithImpliedBound </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; IntegerValue(IntegerValue)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>factor_t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1CutData.html">CutData</a> *</td>          <td class="paramname"><span class="paramname"><em>cut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We are about to apply the super-additive function f() to the <a class="el" href="structoperations__research_1_1sat_1_1CutData.html" title="Our cut are always of the form linear_expression &lt;= rhs.">CutData</a>. Use implied bound information to eventually substitute and make the cut stronger. Returns the number of {lb_ib, ub_ib, merges} applied.</p>
<p>This should lead to stronger cuts even if the norms migth be worse. </p>
<p>Score is just the final lp value. Higher is better since it is a &lt;= constraint.</p>
<p>This side is always good. c.X = c.d.B + c.S applying f to the result we have f(c.d).B + f(c).[X - d.B] which give f(c).X + [f(c.d) - f(c).d].B and the second term is always positive by super-additivity.</p>
<p>Test if it is better to use this "bad" side.</p>
<p>Use the implied bound on (-X) if it is beneficial to do so. Like complementing, this is not always good.</p>
<p>We have comp(X) = diff - X = diff * B + S X = diff * (1 - B) - S. So if we applies f, we will get: f(coeff * diff) * (1 - B) + f(-coeff) * S and substituing S = diff * (1 - B) - X, we get:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001687">Todo</a></b></dt><dd>(user): Note that while the violation might be higher, if the slack becomes large this will result in a less powerfull cut. Shall we do that? It is a bit the same problematic with complementing.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001688">Todo</a></b></dt><dd>(user): If the slack is close to zero, then this transformation will always increase the violation. So we could potentially do it in Before our divisor selection heuristic. But the norm of the final cut will increase too. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>because the slack is of the opposite sign, we might loose more, so we prefer to be a bit defensive.</dd></dl>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02210">2210</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a0f7fcd3160d93b3084286547160eb208" name="a0f7fcd3160d93b3084286547160eb208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7fcd3160d93b3084286547160eb208">&#9670;&#160;</a></span>RecomputeCacheAndSeparateSomeImpliedBoundCuts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::ImpliedBoundsProcessor::RecomputeCacheAndSeparateSomeImpliedBoundCuts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutil__intops_1_1StrongVector.html">util_intops::StrongVector</a>&lt; IntegerVariable, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lp_values</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See if some of the implied bounds equation are violated and add them to the IB cut pool if it is the case.</p>
<p>Important: This must be called before we process any constraints with a different lp_values or level zero bounds. </p>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02109">2109</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<a id="a476cd1dece5678940ddedb54f6e41627" name="a476cd1dece5678940ddedb54f6e41627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476cd1dece5678940ddedb54f6e41627">&#9670;&#160;</a></span>TryToExpandWithLowerImpliedbound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ImpliedBoundsProcessor::TryToExpandWithLowerImpliedbound </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>factor_t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>complement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> *</td>          <td class="paramname"><span class="paramname"><em>term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::int128 *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html">CutTerm</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>new_bool_terms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It should be good to use IB, but sometime we have things like 7.3 = 2 * bool@1 + 5.3 and the expanded Boolean is at its upper bound. It is always good to complement such variable.</p>
<dl class="section note"><dt>Note</dt><dd>here we do more and just complement anything closer to UB.</dd></dl>

<p class="definition">Definition at line <a class="el" href="cuts_8cc_source.html#l02291">2291</a> of file <a class="el" href="cuts_8cc_source.html">cuts.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="cuts_8h_source.html">cuts.h</a></li>
<li>ortools/sat/<a class="el" href="cuts_8cc_source.html">cuts.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html">ImpliedBoundsProcessor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
