<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::ProbingOptions Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.5</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structoperations__research_1_1sat_1_1ProbingOptions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structoperations__research_1_1sat_1_1ProbingOptions-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::ProbingOptions Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="probing_8h_source.html">probing.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae578e361b857faaf06fd4681ef482620"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#ae578e361b857faaf06fd4681ef482620">ToString</a> () const</td></tr>
<tr class="separator:ae578e361b857faaf06fd4681ef482620"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0ad34d874b506bc2be329d5cc4f8e185"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#a0ad34d874b506bc2be329d5cc4f8e185">deterministic_limit</a> = 1.0</td></tr>
<tr class="separator:a0ad34d874b506bc2be329d5cc4f8e185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a82baa2dc19e7fe7e018b63c499042"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#af5a82baa2dc19e7fe7e018b63c499042">extract_binary_clauses</a> = false</td></tr>
<tr class="separator:af5a82baa2dc19e7fe7e018b63c499042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7c7da830531da1e06e2ae75ffa81f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#a0c7c7da830531da1e06e2ae75ffa81f8">use_tree_look</a> = true</td></tr>
<tr class="separator:a0c7c7da830531da1e06e2ae75ffa81f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4df2ae2f59c5cb13fe680c9580fc64f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#ab4df2ae2f59c5cb13fe680c9580fc64f">use_queue</a> = true</td></tr>
<tr class="separator:ab4df2ae2f59c5cb13fe680c9580fc64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580728852731ebb40b0094e5c6ec0d59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#a580728852731ebb40b0094e5c6ec0d59">subsume_with_binary_clause</a> = true</td></tr>
<tr class="separator:a580728852731ebb40b0094e5c6ec0d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46fb63937631346a374ccfe8fb145e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#ad46fb63937631346a374ccfe8fb145e6">log_info</a> = false</td></tr>
<tr class="memdesc:ad46fb63937631346a374ccfe8fb145e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">We assume this is also true if &ndash;v 1 is activated.  <br /></td></tr>
<tr class="separator:ad46fb63937631346a374ccfe8fb145e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Options for the FailedLiteralProbing() code below.</p>
<p>A good reference for the algorithms involved here is the paper "Revisiting
Hyper Binary Resolution" Marijn J. H. Heule, Matti Jarvisalo, Armin Biere, <a href="http://www.cs.utexas.edu/~marijn/cpaior2013.pdf">http://www.cs.utexas.edu/~marijn/cpaior2013.pdf</a> </p>

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00149">149</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae578e361b857faaf06fd4681ef482620" name="ae578e361b857faaf06fd4681ef482620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae578e361b857faaf06fd4681ef482620">&#9670;&#160;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::sat::ProbingOptions::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00214">214</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0ad34d874b506bc2be329d5cc4f8e185" name="a0ad34d874b506bc2be329d5cc4f8e185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad34d874b506bc2be329d5cc4f8e185">&#9670;&#160;</a></span>deterministic_limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::ProbingOptions::deterministic_limit = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The probing will consume all this deterministic time or stop if nothing else can be deduced and everything has been probed until fix-point. The fix point depend on the extract_binay_clauses option:</p><ul>
<li>If false, we will just stop when no more failed literal can be found.</li>
<li><p class="startli">If true, we will do more work and stop when all failed literal have been found and all hyper binary resolution have been performed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001864">Todo:</a></b></dt><dd>(user): We can also provide a middle ground and probe all failed literal but do not extract all binary clauses.</dd></dl>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>the fix-point is unique, modulo the equivalent literal detection we do. And if we add binary clauses, modulo the transitive reduction of the binary implication graph.</dd></dl>
<p>To be fast, we only use the binary clauses in the binary implication graph for the equivalence detection. So the power of the equivalence detection changes if the extract_binay_clauses option is true or not.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001865">Todo:</a></b></dt><dd>(user): The fix point is not yet reached since we don't currently simplify non-binary clauses with these equivalence, but we will. </dd></dl>

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00170">170</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>

</div>
</div>
<a id="af5a82baa2dc19e7fe7e018b63c499042" name="af5a82baa2dc19e7fe7e018b63c499042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a82baa2dc19e7fe7e018b63c499042">&#9670;&#160;</a></span>extract_binary_clauses</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ProbingOptions::extract_binary_clauses = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is also called hyper binary resolution. Basically, we make sure that the binary implication graph is augmented with all the implication of the form a =&gt; b that can be derived by fixing 'a' at level zero and doing a propagation using all constraints. Note that we only add clauses that cannot be derived by the current implication graph.</p>
<p>With these extra clause the power of the equivalence literal detection using only the binary implication graph with increase. Note that it is possible to do exactly the same thing without adding these binary clause first. This is what is done by yet another probing algorithm (currently in <a class="el" href="simplification_8cc.html">simplification.cc</a>).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001866">Todo:</a></b></dt><dd>(user): Note that adding binary clause before/during the SAT presolve is currently not always a good idea. This is because we don't simplify the other clause as much as we could. Also, there can be up to a quadratic number of clauses added this way, which might slow down things a lot. But then because of the deterministic limit, we usually cannot add too much clauses, even for huge problems, since we will reach the limit before that. </dd></dl>

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00190">190</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>

</div>
</div>
<a id="ad46fb63937631346a374ccfe8fb145e6" name="ad46fb63937631346a374ccfe8fb145e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46fb63937631346a374ccfe8fb145e6">&#9670;&#160;</a></span>log_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ProbingOptions::log_info = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We assume this is also true if &ndash;v 1 is activated. </p>

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00212">212</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>

</div>
</div>
<a id="a580728852731ebb40b0094e5c6ec0d59" name="a580728852731ebb40b0094e5c6ec0d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580728852731ebb40b0094e5c6ec0d59">&#9670;&#160;</a></span>subsume_with_binary_clause</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ProbingOptions::subsume_with_binary_clause = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we detect as we probe that a new binary clause subsumes one of the non-binary clause, we will replace the long clause by the binary one. This is orthogonal to the extract_binary_clauses parameters which will add all binary clauses but not neceassirly check for subsumption. </p>

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00209">209</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>

</div>
</div>
<a id="ab4df2ae2f59c5cb13fe680c9580fc64f" name="ab4df2ae2f59c5cb13fe680c9580fc64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4df2ae2f59c5cb13fe680c9580fc64f">&#9670;&#160;</a></span>use_queue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ProbingOptions::use_queue = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There is two sligthly different implementation of the tree-look algo.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001867">Todo:</a></b></dt><dd>(user): Decide which one is better, currently the difference seems small but the queue seems slightly faster. </dd></dl>

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00203">203</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>

</div>
</div>
<a id="a0c7c7da830531da1e06e2ae75ffa81f8" name="a0c7c7da830531da1e06e2ae75ffa81f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7c7da830531da1e06e2ae75ffa81f8">&#9670;&#160;</a></span>use_tree_look</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::ProbingOptions::use_tree_look = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use a version of the "Tree look" algorithm as explained in the paper above. This is usually faster and more efficient. Note that when extracting binary clauses it might currently produce more "redundant" one in the sense that a transitive reduction of the binary implication graph after all hyper binary resolution have been performed may need to do more work. </p>

<p class="definition">Definition at line <a class="el" href="probing_8h_source.html#l00197">197</a> of file <a class="el" href="probing_8h_source.html">probing.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>ortools/sat/<a class="el" href="probing_8h_source.html">probing.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html">ProbingOptions</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
