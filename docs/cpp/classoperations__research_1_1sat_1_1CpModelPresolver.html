<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::CpModelPresolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1CpModelPresolver.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1CpModelPresolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::CpModelPresolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cp__model__presolve_8h_source.html">cp_model_presolve.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09ff637633412bd08b72312dd3fe5542" id="r_a09ff637633412bd08b72312dd3fe5542"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09ff637633412bd08b72312dd3fe5542">CpModelPresolver</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *context, std::vector&lt; int &gt; *postsolve_mapping)</td></tr>
<tr class="separator:a09ff637633412bd08b72312dd3fe5542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eea655cfbd484263d86d3d89af42bf5" id="r_a4eea655cfbd484263d86d3d89af42bf5"><td class="memItemLeft" align="right" valign="top">CpSolverStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eea655cfbd484263d86d3d89af42bf5">Presolve</a> ()</td></tr>
<tr class="separator:a4eea655cfbd484263d86d3d89af42bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60527deff64d7e3f0cc510973c8f6da9" id="r_a60527deff64d7e3f0cc510973c8f6da9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60527deff64d7e3f0cc510973c8f6da9">PresolveOneConstraint</a> (int c)</td></tr>
<tr class="memdesc:a60527deff64d7e3f0cc510973c8f6da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes presolve method for the given constraint. Public for testing only.  <br /></td></tr>
<tr class="separator:a60527deff64d7e3f0cc510973c8f6da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bbd0c3b5d951e791fba86a05d9e61d" id="r_a65bbd0c3b5d951e791fba86a05d9e61d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65bbd0c3b5d951e791fba86a05d9e61d">RemoveEmptyConstraints</a> ()</td></tr>
<tr class="memdesc:a65bbd0c3b5d951e791fba86a05d9e61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visible for testing.  <br /></td></tr>
<tr class="separator:a65bbd0c3b5d951e791fba86a05d9e61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b247edecbebdff3fadbd7661e484b9a" id="r_a6b247edecbebdff3fadbd7661e484b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b247edecbebdff3fadbd7661e484b9a">DetectDuplicateColumns</a> ()</td></tr>
<tr class="separator:a6b247edecbebdff3fadbd7661e484b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7a189b32ff5ccd484556256a04dc83" id="r_a0d7a189b32ff5ccd484556256a04dc83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7a189b32ff5ccd484556256a04dc83">DetectDifferentVariables</a> ()</td></tr>
<tr class="memdesc:a0d7a189b32ff5ccd484556256a04dc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects variable that must take different values.  <br /></td></tr>
<tr class="separator:a0d7a189b32ff5ccd484556256a04dc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Presolves the initial content of presolved_model.</p>
<p>This also creates a mapping model that encode the correspondence between the two problems. This works as follow:</p><ul>
<li>The first variables of mapping_model are in one to one correspondence with the variables of the initial model.</li>
<li>The presolved_model variables are in one to one correspondence with the variable at the indices given by postsolve_mapping in the mapping model.</li>
<li>Fixing one of the two sets of variables and solving the model will assign the other set to a feasible solution of the other problem. Moreover, the objective value of these solutions will be the same. Note that solving such problems will take little time in practice because the propagation will basically do all the work.</li>
</ul>
<p>Note(user): an optimization model can be transformed into a decision problem, if for instance the objective is fixed, or independent from the rest of the problem.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001504">Todo</a></b></dt><dd>(user): Identify disconnected components and returns a vector of presolved model? If we go this route, it may be nicer to store the indices inside the model. We can add a IntegerVariableProto::initial_index; </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8h_source.html#l00076">76</a> of file <a class="el" href="cp__model__presolve_8h_source.html">cp_model_presolve.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09ff637633412bd08b72312dd3fe5542" name="a09ff637633412bd08b72312dd3fe5542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ff637633412bd08b72312dd3fe5542">&#9670;&#160;</a></span>CpModelPresolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::CpModelPresolver::CpModelPresolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>postsolve_mapping</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l13063">13063</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0d7a189b32ff5ccd484556256a04dc83" name="a0d7a189b32ff5ccd484556256a04dc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7a189b32ff5ccd484556256a04dc83">&#9670;&#160;</a></span>DetectDifferentVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CpModelPresolver::DetectDifferentVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects variable that must take different values. </p>
<p>List the variable that are pairwise different, also store in offset[x, y] the offsets such that x &gt;= y + offset.second OR y &gt;= x + offset.first.</p>
<p>Process the fact "v1 - v2 \in Domain".</p>
<p>We have x - y not in exclusion, so x - y &gt; exclusion.Max() --&gt; x &gt; y + exclusion.Max(); OR x - y &lt; exclusion.Min() --&gt; y &gt; x - exclusion.Min();</p>
<p>Try to find identical linear constraint with incompatible domains. This works really well on neos16.mps.gz where we have a &lt;=&gt; x &lt;= y b &lt;=&gt; x &gt;= y and a =&gt; not(b), Because of this presolve, we detect that not(a) =&gt; b and thus that a and not(b) are equivalent. We can thus simplify the problem to just a =&gt; x &lt; y not(a) =&gt; x &gt; y</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001439">Todo</a></b></dt><dd>(user): On that same problem, we could actually just have x != y and remove the enforcement literal that is just used for that. But then we will just re-create it, since we don't have a native way to handle x != y.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001440">Todo</a></b></dt><dd>(user): Again on neos16.mps, we actually have cliques of x != y so we end up with a bunch of groups of 7 variables in [0, 6] that are all different. If we can detect that, then we close the problem quickly instead of not closing it. </dd></dl>
<p>Detect direct encoding of x != y. Note that we also see that from x &gt; y and related.</p>
<p>We assume the constraint was already divided by its gcd.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001441">Todo</a></b></dt><dd>(user): Handle this case? </dd></dl>
<p>Detect x != y via lit =&gt; x &gt; y &amp;&amp; not(lit) =&gt; x &lt; y.</p>
<p>We have x - y in domain1 or in domain2, so it must be in the union.</p>
<p>We assume the constraint was already divided by its gcd.</p>
<p>Detect all_different cliques. We reuse the max-clique code from sat.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001442">Todo</a></b></dt><dd>(user): To avoid doing that more than once, we only run it if there is no all-diff in the model already. This is not perfect.</dd></dl>
<p>Note(user): The all diff added here will not be expanded since we run this after expansion. This is fragile though. Not even sure this is what we want.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001443">Todo</a></b></dt><dd>(user): Start with the existing all diff and expand them rather than not running this if there are all_diff present.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001444">Todo</a></b></dt><dd>(user): Only add them at the end of the presolve! it hurt our presolve (like probing is slower) and only serve for linear relaxation. </dd></dl>
<p>All variables at false is always a valid solution of the local model, so this should never return UNSAT.</p>
<p>We have an all-diff, but inspect the offsets to see if we have a disjunctive ! Note that this is quadratic, but no more complex than the scan of the model we just did above, since we had one linear constraint per entry.</p>
<p>When this happens, it means this interval can never be before any other. We should probably handle this case better, but for now we abort.</p>
<p>We have one size greater than 1, lets add a no_overlap!</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001445">Todo</a></b></dt><dd>(user): try to remove all the quadratic boolean and their corresponding linear2 ? Any Boolean not used elsewhere could be removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l10157">10157</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="a6b247edecbebdff3fadbd7661e484b9a" name="a6b247edecbebdff3fadbd7661e484b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b247edecbebdff3fadbd7661e484b9a">&#9670;&#160;</a></span>DetectDuplicateColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CpModelPresolver::DetectDuplicateColumns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>our symmetry-detector will also identify full permutation group for these columns, but it is better to handle that even before. We can also detect variable with different domains but with indentical columns. </dd></dl>
<p>Our current implementation require almost a full copy. First construct a transpose var to columns (constraint_index, coeff).</p>
<p>We will only support columns that include:</p><ul>
<li>objective</li>
<li>linear (non-enforced part)</li>
<li><p class="startli">at_most_one/exactly_one/clauses (but with positive variable only).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001427">Todo</a></b></dt><dd>(user): deal with enforcement_literal, especially bool_and. It is a bit annoying to have to deal with all kind of constraints. Maybe convert bool_and to at_most_one first? We already do that in other places. Note however that an at most one of size 2 means at most 2 columns can be identical. If we have a bool and with many term on the left, all column could be indentical, but we have to linearize the constraint first. </dd></dl>
</li>
</ul>
<p>It is okay to ignore terms (the columns will not be full).</p>
<p>Use kObjectiveConstraint (-1) for the objective.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001428">Todo</a></b></dt><dd>(user): deal with equivalent column with different objective value. It might not be easy to presolve, but we can at least have a single variable = sum of var appearing only in objective. And we can transfer the min cost. </dd></dl>
<p>Now construct the graph.</p>
<p>Find duplicate columns using an hash map. We only consider "full" columns. var -&gt; var_representative using columns hash/comparison.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001429">Todo</a></b></dt><dd>(user): If we have duplicate columns appearing in Boolean constraint we can only easily substitute if the sum of columns is a Boolean (i.e. if it appear in an at most one or exactly one). Otherwise we will need to transform such constraint to linear, do that? </dd></dl>
<p>Process duplicates.</p>
<p>Since columns are the same, we can introduce a new variable = sum all columns. Note that the linear expression will not overflow, but the overflow check also requires that max_sum &lt; int_max/2, which might happen.</p>
<p>In the corner case where there is a lot of holes in the domain, and the sum domain is too complex, we skip. Hopefully this should be rare.</p>
<p>Deal with objective right away.</p>
<p>Lets rescan the model, and remove all variables, replacing them by the sum. We do that in one O(model size) pass.</p>
<p>Deal with bool case. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001430">Todo</a></b></dt><dd>(user): maybe converting to linear + single code is better? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001431">Todo</a></b></dt><dd>(user): clear amo/exo of size 1. </dd></dl>
<p>Deal with linear case.</p>
<p>We removed all occurrence of "var_to_remove" so we can remove them now. </p><dl class="section note"><dt>Note</dt><dd>since we introduce a new variable per equivalence class, we remove one less for each equivalent class.</dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l09532">9532</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="a4eea655cfbd484263d86d3d89af42bf5" name="a4eea655cfbd484263d86d3d89af42bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eea655cfbd484263d86d3d89af42bf5">&#9670;&#160;</a></span>Presolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpSolverStatus operations_research::sat::CpModelPresolver::Presolve </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We returns the status of the problem after presolve:</p><ul>
<li>UNKNOWN if everything was ok.</li>
<li>INFEASIBLE if the model was proven so during presolve</li>
<li>MODEL_INVALID if the model caused some issues, like if we are not able to scale a floating point objective with enough precision.</li>
</ul>
<p>The presolve works as follow:</p>
<p>First stage: We will process all active constraints until a fix point is reached. During this stage:</p><ul>
<li><a class="el" href="structVariable.html">Variable</a> will never be deleted, but their domain will be reduced.</li>
<li><a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a> will never be deleted (they will be marked as empty if needed).</li>
<li>New variables and new constraints can be added after the existing ones.</li>
<li>Constraints are added only when needed to the mapping_problem if they are needed during the postsolve.</li>
</ul>
<p>Second stage:</p><ul>
<li>All the variables domain will be copied to the mapping_model.</li>
<li>Everything will be remapped so that only the variables appearing in some constraints will be kept and their index will be in [0, num_new_variables). </li>
</ul>
<p>If the objective is a floating point one, we scale it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001487">Todo</a></b></dt><dd>(user): We should probably try to delay this even more. For that we just need to isolate more the "dual" reduction that usually need to look at the objective. </dd></dl>
<p>At this point, we didn't create any new variables, so the integer objective is in term of the orinal problem variables. We save it so that we can expose to the user what exact objective we are actually optimizing.</p>
<p>If there is a large proprotion of fixed variable, lets remap the model before we start the actual presolve. This is useful for LNS in particular.</p>
<p>fixed_postsolve_mapping[i] will contains the original index of the variable that will be at position i after MaybeRemoveFixedVariables(). If the mapping is left empty, it will be set to the identity mapping later by InitializeMappingModelVariables().</p>
<p>Initialize the initial context.working_model domains. Initialize the objective and the constraint &lt;-&gt; variable graph.</p>
<dl class="section note"><dt>Note</dt><dd>we did some basic presolving during the first copy of the model. This is important has initializing the constraint &lt;-&gt; variable graph can be costly, so better to remove trivially feasible constraint for instance.</dd></dl>
<p>If presolve is false, just run expansion.</p>
<p>We still write back the canonical objective has we don't deal well with uninitialized domain or duplicate variables.</p>
<p>We need to append all the variable equivalence that are still used!</p>
<p>Make sure we also have an initialized mapping model as we use this for filling the tightened variables. Even without presolve, we do some trivial presolving during the initial copy of the model, and expansion might do more.</p>
<p>We don't want to run postsolve when the presolve is disabled, but the expansion might have added some constraints to the mapping model. To restore correctness, we merge them with the working model.</p>
<p>Presolve all variable domain once. The PresolveToFixPoint() function will only reprocess domain that changed.</p>
<p>Try to canonicalize the domain, note that we should have detected all affine relations before, so we don't recreate "canononical" variables if they already exist in the model.</p>
<p>Main propagation loop.</p>
<p>Propagate the objective.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001488">Todo</a></b></dt><dd>(user): The presolve transformations we do after this is called might result in even more presolve if we were to call this again! improve the code. See for instance plusexample_6_sat.fzn were represolving the presolved problem reduces it even more. </dd></dl>
<p>Call expansion.</p>
<p>We need to re-evaluate the degree because some presolve rule only run after expansion.</p>
<p>We run the symmetry before more complex presolve rules as many of them are heuristic based and might break the symmetry present in the original problems. This happens for example on the flatzinc wordpress problem.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001489">Todo</a></b></dt><dd>(user): Decide where is the best place for this.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001490">Todo</a></b></dt><dd>(user): try not to break symmetry in our clique extension or other more advanced presolve rule? Ideally we could even exploit them. But in this case, it is still good to compute them early. </dd></dl>
<p>Both kind of duplications might introduce a lot of symmetries and we want to do that before we even compute them.</p>
<p>If the presolve always keep symmetry, we compute it once and for all.</p>
<p>We distinguish an empty symmetry message meaning that symmetry were computed and there is none, and the absence of symmetry message meaning we don't know.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001491">Todo</a></b></dt><dd>(user): Maybe this is a bit brittle. Also move this logic to <a class="el" href="namespaceoperations__research_1_1sat.html#aa71dfa5c438ceb1f2474eea8ceb3c4ad" title="Detects symmetries and fill the symmetry field.">DetectAndAddSymmetryToProto()</a> ? </dd></dl>
<p>Runs SAT specific presolve on the pure-SAT part of the problem. </p><dl class="section note"><dt>Note</dt><dd>because this can only remove/fix variable not used in the other part of the problem, there is no need to redo more presolve afterwards.</dd></dl>
<p>Extract redundant at most one constraint from the linear ones.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001492">Todo</a></b></dt><dd>(user): more generally if we do some probing, the same relation will be detected (and more). Also add an option to turn this off?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001493">Todo</a></b></dt><dd>(user): instead of extracting at most one, extract pairwise conflicts and add them to bool_and clauses? this is some sort of small scale probing, but good for sat presolve and clique later? </dd></dl>
<p>Deal with pair of constraints.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001494">Todo</a></b></dt><dd>(user): revisit when different transformation appear. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001495">Todo</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001496">Todo</a></b></dt><dd>(user): merge these code instead of doing many passes? </dd></dl>
<p>These operations might break symmetry. Or at the very least, the newly created variable must be incorporated in the generators.</p>
<p>Heuristic: vertical introduce smaller defining constraint and appear in many constraints, so might be more constrained. We might also still make horizontal rectangle with the variable introduced.</p>
<p>We do that after the duplicate, SAT and SetPPC constraints.</p>
<p>Merge clauses that differ in just one literal. Heuristic use at_most_one to try to tighten the initial LP Relaxation.</p>
<p>The TransformIntoMaxCliques() call above transform all bool and into at most one of size 2. This does the reverse and merge them.</p>
<p>Call the main presolve to remove the fixed variables and do more deductions.</p>
<p>Exit the loop if no operations were performed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001497">Todo</a></b></dt><dd>(user): try to be smarter and avoid looping again if little changed. </dd></dl>
<p>Regroup no-overlaps into max-cliques.</p>
<p>Tries to spread the objective amongst many variables. We re-do a canonicalization with the final linear expression.</p>
<p>If we have fixed variables or created new affine relations, there might be more things to presolve.</p>
<p>We re-do a canonicalization with the final linear expression.</p>
<p>Now that everything that could possibly be fixed was fixed, make sure we don't leave any linear constraint with fixed variables.</p>
<p>Take care of linear constraint with a complex rhs.</p>
<p>Adds all needed affine relation to context_-&gt;working_model.</p>
<p>If we have symmetry information, lets filter it.</p>
<p>The strategy variable indices will be remapped in <a class="el" href="namespaceoperations__research_1_1sat.html#a2440a5de857e7ceae843c21bc723167c">ApplyVariableMapping()</a> but first we use the representative of the affine relations for the variables that are not present anymore.</p>
<dl class="section note"><dt>Note</dt><dd>we properly take into account the sign of the coefficient which will result in the same domain reduction strategy. Moreover, if the variable order is not CHOOSE_FIRST, then we also encode the associated affine transformation in order to preserve the order.</dd></dl>
<p>Canonicalize each expression to use affine representative.</p>
<p>Remove fixed expression and affine corresponding to same variables.</p>
<p>Sync the domains and initialize the mapping model variables.</p>
<p>Remove all the unused variables from the presolved model.</p>
<p>Heuristic: If a variable is removed and has a representative that is not, we "move" the representative to the spot of that variable in the original order. This is to preserve any info encoded in the variable order by the modeler.</p>
<p>Deal with unused variables.</p>
<p>If the variable is not fixed, we have multiple feasible solution for this variable, so we can't remove it if we want all of them.</p>
<p>Tricky. Variables that where not removed by a presolve rule should be fixed first during postsolve, so that more complex postsolve rules can use their values. One way to do that is to fix them here.</p>
<p>We prefer to fix them to zero if possible.</p>
<p>Merge identical constant. Note that the only place were constant are still left are in the circuit and route constraint for fixed arcs.</p>
<p>The mapping might merge variable, so we have to be careful here.</p>
<p>Compact all non-empty constraint at the beginning.</p>
<p>Hack to display the number of deductions stored.</p>
<p>Stats and checks.</p>
<p>This is not supposed to happen, and is more indicative of an error than an INVALID model. But for our no-overflow preconditions, we might run into bad situation that causes the final model to be invalid.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l13195">13195</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="a60527deff64d7e3f0cc510973c8f6da9" name="a60527deff64d7e3f0cc510973c8f6da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60527deff64d7e3f0cc510973c8f6da9">&#9670;&#160;</a></span>PresolveOneConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::CpModelPresolver::PresolveOneConstraint </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes presolve method for the given constraint. Public for testing only. </p>
<p>Generic presolve to exploit variable/literal equivalence.</p>
<p>Generic presolve for reified constraint.</p>
<p>Call the presolve function for this constraint if any.</p>
<p>We first propagate the domains before calling this presolve rule.</p>
<p>There is no need to re-do a propagation here, but the constraint size might have been reduced.</p>
<p>If we extracted some enforcement, we redo some presolve.</p>
<p>For 2D, we don't exploit index duplication between x/y so it is not important to do it beforehand. Moreover in some situation PresolveNoOverlap2D() remove a lot of interval, so better to do it afterwards.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l08785">8785</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="a65bbd0c3b5d951e791fba86a05d9e61d" name="a65bbd0c3b5d951e791fba86a05d9e61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bbd0c3b5d951e791fba86a05d9e61d">&#9670;&#160;</a></span>RemoveEmptyConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CpModelPresolver::RemoveEmptyConstraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visible for testing. </p>
<p>Remove all empty constraints and duplicated intervals. Note that we need to remap the interval references.</p>
<p>Now that they have served their purpose, we also remove dummy constraints, otherwise that causes issue because our model are invalid in tests. </p>
<dl class="section warning"><dt>Warning</dt><dd>interval_representative_ holds a pointer to the working model to compute hashes, so we need to be careful about not changing a constraint after its index is added to the map.</dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l00122">122</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="cp__model__presolve_8h_source.html">cp_model_presolve.h</a></li>
<li>ortools/sat/<a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html">CpModelPresolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
