<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::CpModelPresolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.8</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classoperations__research_1_1sat_1_1CpModelPresolver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1CpModelPresolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::CpModelPresolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cp__model__presolve_8h_source.html">cp_model_presolve.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09ff637633412bd08b72312dd3fe5542" id="r_a09ff637633412bd08b72312dd3fe5542"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a09ff637633412bd08b72312dd3fe5542">CpModelPresolver</a> (<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *<a class="el" href="gurobi__interface_8cc.html#a5f287b83a753915ae862fed64f8640a6">context</a>, std::vector&lt; int &gt; *postsolve_mapping)</td></tr>
<tr class="separator:a09ff637633412bd08b72312dd3fe5542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eea655cfbd484263d86d3d89af42bf5" id="r_a4eea655cfbd484263d86d3d89af42bf5"><td class="memItemLeft" align="right" valign="top">CpSolverStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a4eea655cfbd484263d86d3d89af42bf5">Presolve</a> ()</td></tr>
<tr class="separator:a4eea655cfbd484263d86d3d89af42bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60527deff64d7e3f0cc510973c8f6da9" id="r_a60527deff64d7e3f0cc510973c8f6da9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a60527deff64d7e3f0cc510973c8f6da9">PresolveOneConstraint</a> (int c)</td></tr>
<tr class="memdesc:a60527deff64d7e3f0cc510973c8f6da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes presolve method for the given constraint. Public for testing only.  <br /></td></tr>
<tr class="separator:a60527deff64d7e3f0cc510973c8f6da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bbd0c3b5d951e791fba86a05d9e61d" id="r_a65bbd0c3b5d951e791fba86a05d9e61d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a65bbd0c3b5d951e791fba86a05d9e61d">RemoveEmptyConstraints</a> ()</td></tr>
<tr class="memdesc:a65bbd0c3b5d951e791fba86a05d9e61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public for testing only.  <br /></td></tr>
<tr class="separator:a65bbd0c3b5d951e791fba86a05d9e61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Presolves the initial content of presolved_model.</p>
<p>This also creates a mapping model that encode the correspondence between the two problems. This works as follow:</p><ul>
<li>The first variables of mapping_model are in one to one correspondence with the variables of the initial model.</li>
<li>The presolved_model variables are in one to one correspondence with the variable at the indices given by postsolve_mapping in the mapping model.</li>
<li>Fixing one of the two sets of variables and solving the model will assign the other set to a feasible solution of the other problem. Moreover, the objective value of these solutions will be the same. Note that solving such problems will take little time in practice because the propagation will basically do all the work.</li>
</ul>
<p>Note(user): an optimization model can be transformed into a decision problem, if for instance the objective is fixed, or independent from the rest of the problem.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001322">Todo:</a></b></dt><dd>(user): Identify disconnected components and returns a vector of presolved model? If we go this route, it may be nicer to store the indices inside the model. We can add a IntegerVariableProto::initial_index; </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8h_source.html#l00072">72</a> of file <a class="el" href="cp__model__presolve_8h_source.html">cp_model_presolve.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09ff637633412bd08b72312dd3fe5542" name="a09ff637633412bd08b72312dd3fe5542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ff637633412bd08b72312dd3fe5542">&#9670;&#160;</a></span>CpModelPresolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::CpModelPresolver::CpModelPresolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html">PresolveContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>postsolve_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l11569">11569</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4eea655cfbd484263d86d3d89af42bf5" name="a4eea655cfbd484263d86d3d89af42bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eea655cfbd484263d86d3d89af42bf5">&#9670;&#160;</a></span>Presolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CpSolverStatus operations_research::sat::CpModelPresolver::Presolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We returns the status of the problem after presolve:</p><ul>
<li>UNKNOWN if everything was ok.</li>
<li>INFEASIBLE if the model was proven so during presolve</li>
<li>MODEL_INVALID if the model caused some issues, like if we are not able to scale a floating point objective with enough precision.</li>
</ul>
<p>The presolve works as follow:</p>
<p>First stage: We will process all active constraints until a fix point is reached. During this stage:</p><ul>
<li>Variable will never be deleted, but their domain will be reduced.</li>
<li><a class="el" href="classoperations__research_1_1sat_1_1Constraint.html">Constraint</a> will never be deleted (they will be marked as empty if needed).</li>
<li>New variables and new constraints can be added after the existing ones.</li>
<li>Constraints are added only when needed to the mapping_problem if they are needed during the postsolve.</li>
</ul>
<p>Second stage:</p><ul>
<li>All the variables domain will be copied to the mapping_model.</li>
<li>Everything will be remapped so that only the variables appearing in some constraints will be kept and their index will be in [0, num_new_variables). </li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001303">Todo:</a></b></dt><dd>(user): move in the context. </dd></dl>
<p>We copy the search strategy to the mapping_model.</p>
<p>Initialize the initial context.working_model domains.</p>
<p>If the objective is a floating point one, we scale it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001304">Todo:</a></b></dt><dd>(user): We should probably try to delay this even more. For that we just need to isolate more the "dual" reduction that usually need to look at the objective. </dd></dl>
<p>At this point, we didn't create any new variables, so the integer objective is in term of the orinal problem variables. We save it so that we can expose to the user what exact objective we are actually optimizing.</p>
<p>Initialize the objective and the constraint &lt;-&gt; variable graph.</p>
<dl class="section note"><dt>Note</dt><dd>we did some basic presolving during the first copy of the model. This is important has initializing the constraint &lt;-&gt; variable graph can be costly, so better to remove trivially feasible constraint for instance.</dd></dl>
<p>If presolve is false, just run expansion.</p>
<p>We still write back the canonical objective has we don't deal well with uninitialized domain or duplicate variables.</p>
<p>We need to append all the variable equivalence that are still used!</p>
<p>Presolve all variable domain once. The PresolveToFixPoint() function will only reprocess domain that changed.</p>
<p>Try to canonicalize the domain, note that we should have detected all affine relations before, so we don't recreate "canononical" variables if they already exist in the model.</p>
<p>Main propagation loop.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001305">Todo:</a></b></dt><dd>(user): The presolve transformations we do after this is called might result in even more presolve if we were to call this again! improve the code. See for instance plusexample_6_sat.fzn were represolving the presolved problem reduces it even more. </dd></dl>
<p>Call expansion.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001306">Todo:</a></b></dt><dd>(user): Make sure we can't have duplicate in these constraint. These are due to <a class="el" href="namespaceoperations__research_1_1sat.html#a313297bca1475c995d9a4139cb790cc8">ExpandCpModel()</a> were we create such constraint with duplicate. The problem is that some code assumes these are presolved before being called. </dd></dl>
<p>We need to re-evaluate the degree because some presolve rule only run after expansion.</p>
<p>We run the symmetry before more complex presolve rules as many of them are heuristic based and might break the symmetry present in the original problems. This happens for example on the flatzinc wordpress problem.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001307">Todo:</a></b></dt><dd>(user): Decide where is the best place for this.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001308">Todo:</a></b></dt><dd>(user): try not to break symmetry in our clique extension or other more advanced presolve rule? Ideally we could even exploit them. But in this case, it is still good to compute them early. </dd></dl>
<p>Runs SAT specific presolve on the pure-SAT part of the problem. </p><dl class="section note"><dt>Note</dt><dd>because this can only remove/fix variable not used in the other part of the problem, there is no need to redo more presolve afterwards.</dd></dl>
<p>Extract redundant at most one constraint form the linear ones.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001309">Todo:</a></b></dt><dd>(user): more generally if we do some probing, the same relation will be detected (and more). Also add an option to turn this off?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001310">Todo:</a></b></dt><dd>(user): instead of extracting at most one, extract pairwise conflicts and add them to bool_and clauses? this is some sort of small scale probing, but good for sat presolve and clique later? </dd></dl>
<p>Deal with pair of constraints.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001311">Todo:</a></b></dt><dd>(user): revisit when different transformation appear. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001312">Todo:</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001313">Todo:</a></b></dt><dd>(user): merge these code instead of doing many passes? </dd></dl>
<p>We do that after the duplicate, SAT and SetPPC constraints.</p>
<p>Merge clauses that differ in just one literal. Heuristic use at_most_one to try to tighten the initial LP Relaxation.</p>
<p>The TransformIntoMaxCliques() call above transform all bool and into at most one of size 2. This does the reverse and merge them.</p>
<p>Call the main presolve to remove the fixed variables and do more deductions.</p>
<p>Exit the loop if no operations were performed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001314">Todo:</a></b></dt><dd>(user): try to be smarter and avoid looping again if little changed. </dd></dl>
<p>Regroup no-overlaps into max-cliques.</p>
<p>Tries to spread the objective amongst many variables. We re-do a canonicalization with the final linear expression.</p>
<p>We re-do a canonicalization with the final linear expression.</p>
<p>Take care of linear constraint with a complex rhs.</p>
<p>Adds all needed affine relation to context_-&gt;working_model.</p>
<p>The strategy variable indices will be remapped in <a class="el" href="namespaceoperations__research_1_1sat.html#a05ea17f6faee222ffd764edd4c16ae61">ApplyVariableMapping()</a> but first we use the representative of the affine relations for the variables that are not present anymore.</p>
<dl class="section note"><dt>Note</dt><dd>we properly take into account the sign of the coefficient which will result in the same domain reduction strategy. Moreover, if the variable order is not CHOOSE_FIRST, then we also encode the associated affine transformation in order to preserve the order.</dd></dl>
<p>Remove fixed variables.</p>
<p>There is not point having a variable appear twice, so we only keep the first occurrence in the first strategy in which it occurs.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001315">Todo:</a></b></dt><dd>(user): this variable was removed entirely by the presolve (no equivalent variable present). We simply ignore it entirely which might result in a different search... </dd></dl>
<p>Sync the domains.</p>
<p><a class="el" href="classoperations__research_1_1Set.html">Set</a> the variables of the mapping_model.</p>
<p>Remove all the unused variables from the presolved model.</p>
<p>Heuristic: If a variable is removed and has a representative that is not, we "move" the representative to the spot of that variable in the original order. This is to preserve any info encoded in the variable order by the modeler.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001316">Todo:</a></b></dt><dd>(user): we could still remove unused constant even if keep_all_feasible_solutions is true. </dd></dl>
<p>Tricky. Variables that where not removed by a presolve rule should be fixed first during postsolve, so that more complex postsolve rules can use their values. One way to do that is to fix them here.</p>
<p>We prefer to fix them to zero if possible.</p>
<p>Merge identical constant. Note that the only place were constant are still left are in the circuit and route constraint for fixed arcs.</p>
<p>The mapping might merge variable, so we have to be careful here.</p>
<p>Compact all non-empty constraint at the beginning.</p>
<p>Hack to display the number of deductions stored.</p>
<p>Stats and checks.</p>
<p>This is not supposed to happen, and is more indicative of an error than an INVALID model. But for our no-overflow preconditions, we might run into bad situation that causes the final model to be invalid.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l11596">11596</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="a60527deff64d7e3f0cc510973c8f6da9" name="a60527deff64d7e3f0cc510973c8f6da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60527deff64d7e3f0cc510973c8f6da9">&#9670;&#160;</a></span>PresolveOneConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::CpModelPresolver::PresolveOneConstraint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes presolve method for the given constraint. Public for testing only. </p>
<p>Generic presolve to exploit variable/literal equivalence.</p>
<p>Generic presolve for reified constraint.</p>
<p>Call the presolve function for this constraint if any.</p>
<p>We first propagate the domains before calling this presolve rule.</p>
<p>There is no need to re-do a propagation here, but the constraint size might have been reduced.</p>
<p>If we extracted some enforcement, we redo some presolve.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l07677">7677</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<a id="a65bbd0c3b5d951e791fba86a05d9e61d" name="a65bbd0c3b5d951e791fba86a05d9e61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bbd0c3b5d951e791fba86a05d9e61d">&#9670;&#160;</a></span>RemoveEmptyConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::CpModelPresolver::RemoveEmptyConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public for testing only. </p>
<p>Remove all empty constraints. Note that we need to remap the interval references.</p>
<p>Now that they have served their purpose, we also remove dummy constraints, otherwise that causes issue because our model are invalid in tests. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__presolve_8cc_source.html#l00110">110</a> of file <a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="cp__model__presolve_8h_source.html">cp_model_presolve.h</a></li>
<li>ortools/sat/<a class="el" href="cp__model__presolve_8cc_source.html">cp_model_presolve.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html">CpModelPresolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
