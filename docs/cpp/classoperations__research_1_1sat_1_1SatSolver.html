<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::SatSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1SatSolver.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1SatSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::SatSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Counters.html">Counters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Decision.html">Decision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8022922b9cf102d6697157b3f2ccc352" id="r_a8022922b9cf102d6697157b3f2ccc352"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">Status</a> { <a class="el" href="#a8022922b9cf102d6697157b3f2ccc352adc08829ed7a57463ccf45d0a6dd34cb2">ASSUMPTIONS_UNSAT</a>
, <a class="el" href="#a8022922b9cf102d6697157b3f2ccc352ae81c4874f5f1b05aeef8b9781e26b1ee">INFEASIBLE</a>
, <a class="el" href="#a8022922b9cf102d6697157b3f2ccc352a7a6b4bc49d7cd2f0e797b2223c1e605b">FEASIBLE</a>
, <a class="el" href="#a8022922b9cf102d6697157b3f2ccc352a71fe77dfe8a6957ad06c36275d7fcd62">LIMIT_REACHED</a>
 }</td></tr>
<tr class="separator:a8022922b9cf102d6697157b3f2ccc352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af34c6a454416c6dcb2e6310e510e976e" id="r_af34c6a454416c6dcb2e6310e510e976e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af34c6a454416c6dcb2e6310e510e976e">SatSolver</a> ()</td></tr>
<tr class="separator:af34c6a454416c6dcb2e6310e510e976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0abab4a2ce453f91aa0afb88db55433" id="r_ac0abab4a2ce453f91aa0afb88db55433"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0abab4a2ce453f91aa0afb88db55433">SatSolver</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *<a class="el" href="#a5420a6d871314779beeac0c074241c1a">model</a>)</td></tr>
<tr class="separator:ac0abab4a2ce453f91aa0afb88db55433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e7ce693a9601da649d9b52ee042d62" id="r_a30e7ce693a9601da649d9b52ee042d62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30e7ce693a9601da649d9b52ee042d62">SatSolver</a> (const <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp;)=delete</td></tr>
<tr class="memdesc:a30e7ce693a9601da649d9b52ee042d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is neither copyable nor movable.  <br /></td></tr>
<tr class="separator:a30e7ce693a9601da649d9b52ee042d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab044c123d6e5222d758c78d5a1cb9f18" id="r_ab044c123d6e5222d758c78d5a1cb9f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab044c123d6e5222d758c78d5a1cb9f18">operator=</a> (const <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp;)=delete</td></tr>
<tr class="separator:ab044c123d6e5222d758c78d5a1cb9f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3483e8be8a322018b9ff33f9d1591fb0" id="r_a3483e8be8a322018b9ff33f9d1591fb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3483e8be8a322018b9ff33f9d1591fb0">~SatSolver</a> ()</td></tr>
<tr class="separator:a3483e8be8a322018b9ff33f9d1591fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5420a6d871314779beeac0c074241c1a" id="r_a5420a6d871314779beeac0c074241c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5420a6d871314779beeac0c074241c1a">model</a> ()</td></tr>
<tr class="separator:a5420a6d871314779beeac0c074241c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c68be5db0ba121693811895e89de8c" id="r_af8c68be5db0ba121693811895e89de8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8c68be5db0ba121693811895e89de8c">SetParameters</a> (const SatParameters &amp;<a class="el" href="#a8904d8354eb343b3d0cc598a02f4140c">parameters</a>)</td></tr>
<tr class="separator:af8c68be5db0ba121693811895e89de8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8904d8354eb343b3d0cc598a02f4140c" id="r_a8904d8354eb343b3d0cc598a02f4140c"><td class="memItemLeft" align="right" valign="top">const SatParameters &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8904d8354eb343b3d0cc598a02f4140c">parameters</a> () const</td></tr>
<tr class="separator:a8904d8354eb343b3d0cc598a02f4140c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f40548efeb9f6bde6ff1cd872acc38" id="r_ae8f40548efeb9f6bde6ff1cd872acc38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8f40548efeb9f6bde6ff1cd872acc38">SetNumVariables</a> (int num_variables)</td></tr>
<tr class="separator:ae8f40548efeb9f6bde6ff1cd872acc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8b7f7a38df9c1f3111c5fc03eb79fa" id="r_ada8b7f7a38df9c1f3111c5fc03eb79fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada8b7f7a38df9c1f3111c5fc03eb79fa">NumVariables</a> () const</td></tr>
<tr class="separator:ada8b7f7a38df9c1f3111c5fc03eb79fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bb790559c188628c9e93530235a223" id="r_a52bb790559c188628c9e93530235a223"><td class="memItemLeft" align="right" valign="top">BooleanVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52bb790559c188628c9e93530235a223">NewBooleanVariable</a> ()</td></tr>
<tr class="separator:a52bb790559c188628c9e93530235a223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16f8b671ca15b9f82ee69236880c176" id="r_aa16f8b671ca15b9f82ee69236880c176"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16f8b671ca15b9f82ee69236880c176">AddUnitClause</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal)</td></tr>
<tr class="separator:aa16f8b671ca15b9f82ee69236880c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb2ddde70037269943ce72ac1d5b163" id="r_a6cb2ddde70037269943ce72ac1d5b163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb2ddde70037269943ce72ac1d5b163">AddBinaryClause</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> a, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a6cb2ddde70037269943ce72ac1d5b163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a647efe64188a8e657a25ab23ddcc08d8">AddProblemClause()</a> below, but for small clauses.  <br /></td></tr>
<tr class="separator:a6cb2ddde70037269943ce72ac1d5b163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e4956383538b097302c88080569a74" id="r_aa5e4956383538b097302c88080569a74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e4956383538b097302c88080569a74">AddTernaryClause</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> a, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> c)</td></tr>
<tr class="separator:aa5e4956383538b097302c88080569a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647efe64188a8e657a25ab23ddcc08d8" id="r_a647efe64188a8e657a25ab23ddcc08d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a647efe64188a8e657a25ab23ddcc08d8">AddProblemClause</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:a647efe64188a8e657a25ab23ddcc08d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098038f8e0409a8243ff3f7eafb517f8" id="r_a098038f8e0409a8243ff3f7eafb517f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a098038f8e0409a8243ff3f7eafb517f8">AddLinearConstraint</a> (bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *cst)</td></tr>
<tr class="separator:a098038f8e0409a8243ff3f7eafb517f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebdd03bb49157e1de8516e1dbfc4ef" id="r_a7aebdd03bb49157e1de8516e1dbfc4ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aebdd03bb49157e1de8516e1dbfc4ef">ModelIsUnsat</a> () const</td></tr>
<tr class="separator:a7aebdd03bb49157e1de8516e1dbfc4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e27e6cb848b3176ab5680292d116a8" id="r_a84e27e6cb848b3176ab5680292d116a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e27e6cb848b3176ab5680292d116a8">IsModelUnsat</a> () const</td></tr>
<tr class="separator:a84e27e6cb848b3176ab5680292d116a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af488df5e9f46c785660564688c91594d" id="r_af488df5e9f46c785660564688c91594d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af488df5e9f46c785660564688c91594d">AddPropagator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *propagator)</td></tr>
<tr class="separator:af488df5e9f46c785660564688c91594d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca79ff7f2192b5cd83d224a51485a2c0" id="r_aca79ff7f2192b5cd83d224a51485a2c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca79ff7f2192b5cd83d224a51485a2c0">AddLastPropagator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *propagator)</td></tr>
<tr class="separator:aca79ff7f2192b5cd83d224a51485a2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f2f42bb6656121254538958473c08" id="r_aab9f2f42bb6656121254538958473c08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab9f2f42bb6656121254538958473c08">TakePropagatorOwnership</a> (std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> &gt; propagator)</td></tr>
<tr class="separator:aab9f2f42bb6656121254538958473c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50484f243bcc0ec12ed3919d84dc38ad" id="r_a50484f243bcc0ec12ed3919d84dc38ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50484f243bcc0ec12ed3919d84dc38ad">SetAssignmentPreference</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> literal, float weight)</td></tr>
<tr class="separator:a50484f243bcc0ec12ed3919d84dc38ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d71ca32207f031cff5c0648452a30f0" id="r_a9d71ca32207f031cff5c0648452a30f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d71ca32207f031cff5c0648452a30f0">AllPreferences</a> () const</td></tr>
<tr class="separator:a9d71ca32207f031cff5c0648452a30f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a644e6b565ec38603e6db416136a8b1" id="r_a7a644e6b565ec38603e6db416136a8b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a644e6b565ec38603e6db416136a8b1">ResetDecisionHeuristic</a> ()</td></tr>
<tr class="separator:a7a644e6b565ec38603e6db416136a8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a32f2b63a24749a0c9f6e34d068f1b0" id="r_a8a32f2b63a24749a0c9f6e34d068f1b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve</a> ()</td></tr>
<tr class="separator:a8a32f2b63a24749a0c9f6e34d068f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11914d218bc38bf85e6e5b5222ede644" id="r_a11914d218bc38bf85e6e5b5222ede644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11914d218bc38bf85e6e5b5222ede644">SolveWithTimeLimit</a> (<a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *<a class="el" href="linear__solver_2solve_8cc.html#a5924b2104bcf836d8c82d6d5b6bf4b36">time_limit</a>)</td></tr>
<tr class="separator:a11914d218bc38bf85e6e5b5222ede644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20cec16641434c61d9185a0edef37a7" id="r_ab20cec16641434c61d9185a0edef37a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab20cec16641434c61d9185a0edef37a7">ResetAndSolveWithGivenAssumptions</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;assumptions, int64_t max_number_of_conflicts=-1)</td></tr>
<tr class="separator:ab20cec16641434c61d9185a0edef37a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2f6d9f21b096f25d8d093c664da6f4" id="r_a9a2f6d9f21b096f25d8d093c664da6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a2f6d9f21b096f25d8d093c664da6f4">SetAssumptionLevel</a> (int assumption_level)</td></tr>
<tr class="separator:a9a2f6d9f21b096f25d8d093c664da6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bdb41422d29fd811705a62ffc41877" id="r_ac3bdb41422d29fd811705a62ffc41877"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3bdb41422d29fd811705a62ffc41877">AssumptionLevel</a> () const</td></tr>
<tr class="separator:ac3bdb41422d29fd811705a62ffc41877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bfff1cfcd0f24e7a9ee2b583f594ea" id="r_a69bfff1cfcd0f24e7a9ee2b583f594ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69bfff1cfcd0f24e7a9ee2b583f594ea">GetLastIncompatibleDecisions</a> ()</td></tr>
<tr class="separator:a69bfff1cfcd0f24e7a9ee2b583f594ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bd2bfe51a3e42ac2f18fec4af24311" id="r_a96bd2bfe51a3e42ac2f18fec4af24311"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96bd2bfe51a3e42ac2f18fec4af24311">GetDecisionsFixing</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:a96bd2bfe51a3e42ac2f18fec4af24311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9e49e76092a3d062d5736f0214a4f4" id="r_a6f9e49e76092a3d062d5736f0214a4f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f9e49e76092a3d062d5736f0214a4f4">EnqueueDecisionAndBackjumpOnConflict</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal)</td></tr>
<tr class="separator:a6f9e49e76092a3d062d5736f0214a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d8cce319cec13c09f0089baebf746" id="r_a070d8cce319cec13c09f0089baebf746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070d8cce319cec13c09f0089baebf746">EnqueueDecisionAndBacktrackOnConflict</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal, int *first_propagation_index=nullptr)</td></tr>
<tr class="separator:a070d8cce319cec13c09f0089baebf746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb06019f0cfb5ac683c556c61d65e5" id="r_a89fb06019f0cfb5ac683c556c61d65e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89fb06019f0cfb5ac683c556c61d65e5">EnqueueDecisionIfNotConflicting</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal)</td></tr>
<tr class="separator:a89fb06019f0cfb5ac683c556c61d65e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0c2912da716e49c8b5d84108e463d7" id="r_a7c0c2912da716e49c8b5d84108e463d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0c2912da716e49c8b5d84108e463d7">Backtrack</a> (int target_level)</td></tr>
<tr class="separator:a7c0c2912da716e49c8b5d84108e463d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b42ef3040a15e72f3f7efa302e32583" id="r_a6b42ef3040a15e72f3f7efa302e32583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b42ef3040a15e72f3f7efa302e32583">RestoreSolverToAssumptionLevel</a> ()</td></tr>
<tr class="separator:a6b42ef3040a15e72f3f7efa302e32583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4458486171153c1793c28e2091140d9" id="r_ad4458486171153c1793c28e2091140d9"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4458486171153c1793c28e2091140d9">FinishPropagation</a> ()</td></tr>
<tr class="separator:ad4458486171153c1793c28e2091140d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dacb6b250d8bb139a1e7c3071892b7" id="r_ac4dacb6b250d8bb139a1e7c3071892b7"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4dacb6b250d8bb139a1e7c3071892b7">ResetToLevelZero</a> ()</td></tr>
<tr class="separator:ac4dacb6b250d8bb139a1e7c3071892b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552a7e42a1957d95b1cce7078ad29fdb" id="r_a552a7e42a1957d95b1cce7078ad29fdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a552a7e42a1957d95b1cce7078ad29fdb">ResetWithGivenAssumptions</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;assumptions)</td></tr>
<tr class="separator:a552a7e42a1957d95b1cce7078ad29fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82300521f18442372bb16efd01463cd9" id="r_a82300521f18442372bb16efd01463cd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82300521f18442372bb16efd01463cd9">ReapplyAssumptionsIfNeeded</a> ()</td></tr>
<tr class="separator:a82300521f18442372bb16efd01463cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c109f0e0a118d4d916aba5a54e84d" id="r_a402c109f0e0a118d4d916aba5a54e84d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a402c109f0e0a118d4d916aba5a54e84d">UnsatStatus</a> () const</td></tr>
<tr class="separator:a402c109f0e0a118d4d916aba5a54e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0174fd7221118d81a925d32aaed1cc79" id="r_a0174fd7221118d81a925d32aaed1cc79"><td class="memTemplParams" colspan="2">template&lt;typename Output&gt; </td></tr>
<tr class="memitem:a0174fd7221118d81a925d32aaed1cc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0174fd7221118d81a925d32aaed1cc79">ExtractClauses</a> (Output *out)</td></tr>
<tr class="separator:a0174fd7221118d81a925d32aaed1cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f805974da54c343a094962a8d709db3" id="r_a6f805974da54c343a094962a8d709db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f805974da54c343a094962a8d709db3">TrackBinaryClauses</a> (bool value)</td></tr>
<tr class="separator:a6f805974da54c343a094962a8d709db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eedb16093e09c9c03f34a80547c0f4d" id="r_a4eedb16093e09c9c03f34a80547c0f4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eedb16093e09c9c03f34a80547c0f4d">AddBinaryClauses</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt; clauses)</td></tr>
<tr class="separator:a4eedb16093e09c9c03f34a80547c0f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3087db3ee9aceca1a27369dff0d5ad61" id="r_a3087db3ee9aceca1a27369dff0d5ad61"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3087db3ee9aceca1a27369dff0d5ad61">NewlyAddedBinaryClauses</a> ()</td></tr>
<tr class="separator:a3087db3ee9aceca1a27369dff0d5ad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bd5458903038cd72064671d10c620d" id="r_a82bd5458903038cd72064671d10c620d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82bd5458903038cd72064671d10c620d">ClearNewlyAddedBinaryClauses</a> ()</td></tr>
<tr class="separator:a82bd5458903038cd72064671d10c620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad230258762a2fc372ece535a4e3b9f06" id="r_ad230258762a2fc372ece535a4e3b9f06"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Decision.html">Decision</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad230258762a2fc372ece535a4e3b9f06">Decisions</a> () const</td></tr>
<tr class="separator:ad230258762a2fc372ece535a4e3b9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1b11c4b39c9745a264638dc0381914" id="r_abf1b11c4b39c9745a264638dc0381914"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel</a> () const</td></tr>
<tr class="separator:abf1b11c4b39c9745a264638dc0381914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf67ece21b8195e56e577932269c130b" id="r_adf67ece21b8195e56e577932269c130b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf67ece21b8195e56e577932269c130b">LiteralTrail</a> () const</td></tr>
<tr class="separator:adf67ece21b8195e56e577932269c130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae9d5e427bdd44a6e581f3a06b7f703" id="r_abae9d5e427bdd44a6e581f3a06b7f703"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abae9d5e427bdd44a6e581f3a06b7f703">Assignment</a> () const</td></tr>
<tr class="separator:abae9d5e427bdd44a6e581f3a06b7f703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efb093cfaf3450b6816fab8c0759e19" id="r_a5efb093cfaf3450b6816fab8c0759e19"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5efb093cfaf3450b6816fab8c0759e19">num_branches</a> () const</td></tr>
<tr class="memdesc:a5efb093cfaf3450b6816fab8c0759e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some statistics since the creation of the solver.  <br /></td></tr>
<tr class="separator:a5efb093cfaf3450b6816fab8c0759e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b31c338ba4d070b8880539bc9a09eb" id="r_a75b31c338ba4d070b8880539bc9a09eb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b31c338ba4d070b8880539bc9a09eb">num_failures</a> () const</td></tr>
<tr class="separator:a75b31c338ba4d070b8880539bc9a09eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dd736a0e48550f444665f4c9848be3" id="r_a82dd736a0e48550f444665f4c9848be3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82dd736a0e48550f444665f4c9848be3">num_propagations</a> () const</td></tr>
<tr class="separator:a82dd736a0e48550f444665f4c9848be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870d1a233165edaf4f2838f027f609cc" id="r_a870d1a233165edaf4f2838f027f609cc"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a870d1a233165edaf4f2838f027f609cc">num_backtracks</a> () const</td></tr>
<tr class="separator:a870d1a233165edaf4f2838f027f609cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8e763148cc7f4b31e2efc3e3126cd4" id="r_a9f8e763148cc7f4b31e2efc3e3126cd4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f8e763148cc7f4b31e2efc3e3126cd4">num_restarts</a> () const</td></tr>
<tr class="separator:a9f8e763148cc7f4b31e2efc3e3126cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c9df3c27f93259f24d24ddd53a0bf2" id="r_ae9c9df3c27f93259f24d24ddd53a0bf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Counters.html">Counters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9c9df3c27f93259f24d24ddd53a0bf2">counters</a> () const</td></tr>
<tr class="separator:ae9c9df3c27f93259f24d24ddd53a0bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac88207c0228d80d19751186955240f" id="r_a1ac88207c0228d80d19751186955240f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ac88207c0228d80d19751186955240f">deterministic_time</a> () const</td></tr>
<tr class="separator:a1ac88207c0228d80d19751186955240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7db73938c1101728cb3c7ed61dfd72e" id="r_ac7db73938c1101728cb3c7ed61dfd72e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7db73938c1101728cb3c7ed61dfd72e">SaveDebugAssignment</a> ()</td></tr>
<tr class="separator:ac7db73938c1101728cb3c7ed61dfd72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10758f34598c390626b2a000d44aeee6" id="r_a10758f34598c390626b2a000d44aeee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10758f34598c390626b2a000d44aeee6">LoadDebugSolution</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; <a class="el" href="namespaceoperations__research.html#a35a30dc825cd0afa0e095f47118cd3cd">solution</a>)</td></tr>
<tr class="separator:a10758f34598c390626b2a000d44aeee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1825b361bdf46ac399ff264a402b6c40" id="r_a1825b361bdf46ac399ff264a402b6c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1825b361bdf46ac399ff264a402b6c40">SetDratProofHandler</a> (<a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *drat_proof_handler)</td></tr>
<tr class="separator:a1825b361bdf46ac399ff264a402b6c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61260f1f86d76b6605c82d69ad96186d" id="r_a61260f1f86d76b6605c82d69ad96186d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61260f1f86d76b6605c82d69ad96186d">NotifyThatModelIsUnsat</a> ()</td></tr>
<tr class="separator:a61260f1f86d76b6605c82d69ad96186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9ba983bd9f911d0605f7615ebf3725" id="r_a8b9ba983bd9f911d0605f7615ebf3725"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b9ba983bd9f911d0605f7615ebf3725">AddClauseDuringSearch</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:a8b9ba983bd9f911d0605f7615ebf3725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9188c70cc1096900a623a26319a1d4b8" id="r_a9188c70cc1096900a623a26319a1d4b8"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9188c70cc1096900a623a26319a1d4b8">Propagate</a> ()</td></tr>
<tr class="separator:a9188c70cc1096900a623a26319a1d4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530dbc523b77d414ae58830addba843" id="r_a3530dbc523b77d414ae58830addba843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3530dbc523b77d414ae58830addba843">MinimizeByPropagation</a> (double dtime, bool minimize_new_clauses_only=false)</td></tr>
<tr class="separator:a3530dbc523b77d414ae58830addba843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19f21598928ec3f2515db06515cb7c9" id="r_ab19f21598928ec3f2515db06515cb7c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19f21598928ec3f2515db06515cb7c9">AdvanceDeterministicTime</a> (<a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *limit)</td></tr>
<tr class="separator:ab19f21598928ec3f2515db06515cb7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e24044eed32b555fd94b40b8f6423c" id="r_a52e24044eed32b555fd94b40b8f6423c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e24044eed32b555fd94b40b8f6423c">ProcessNewlyFixedVariables</a> ()</td></tr>
<tr class="memdesc:a52e24044eed32b555fd94b40b8f6423c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the problem when new variables are assigned at level 0.  <br /></td></tr>
<tr class="separator:a52e24044eed32b555fd94b40b8f6423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14377fec21151aa9faaa12d861fe8dc" id="r_af14377fec21151aa9faaa12d861fe8dc"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14377fec21151aa9faaa12d861fe8dc">NumFixedVariables</a> () const</td></tr>
<tr class="separator:af14377fec21151aa9faaa12d861fe8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb1a5ce3dfe14d0ed05da23b66bff2a" id="r_a4cb1a5ce3dfe14d0ed05da23b66bff2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cb1a5ce3dfe14d0ed05da23b66bff2a">mutable_logger</a> ()</td></tr>
<tr class="memdesc:a4cb1a5ce3dfe14d0ed05da23b66bff2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hack to allow to temporarily disable logging if it is enabled.  <br /></td></tr>
<tr class="separator:a4cb1a5ce3dfe14d0ed05da23b66bff2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afed23ec8289b170f0a25ec4b10dd84" id="r_a3afed23ec8289b170f0a25ec4b10dd84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3afed23ec8289b170f0a25ec4b10dd84">ProcessCurrentConflict</a> ()</td></tr>
<tr class="separator:a3afed23ec8289b170f0a25ec4b10dd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a0da16b753cfbfc8251f91025f9f42" id="r_a75a0da16b753cfbfc8251f91025f9f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75a0da16b753cfbfc8251f91025f9f42">EnsureNewClauseIndexInitialized</a> ()</td></tr>
<tr class="separator:a75a0da16b753cfbfc8251f91025f9f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main SAT solver. It currently implements the CDCL algorithm. See <a href="http://en.wikipedia.org/wiki/Conflict_Driven_Clause_Learning">http://en.wikipedia.org/wiki/Conflict_Driven_Clause_Learning</a> </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00059">59</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8022922b9cf102d6697157b3f2ccc352" name="a8022922b9cf102d6697157b3f2ccc352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8022922b9cf102d6697157b3f2ccc352">&#9670;&#160;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">operations_research::sat::SatSolver::Status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the problem and returns its status. An empty problem is considered to be SAT.</p>
<dl class="section note"><dt>Note</dt><dd>the conflict limit applies only to this function and starts counting from the time it is called.</dd></dl>
<p>This will restart from the current solver configuration. If a previous call to <a class="el" href="#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a> was interrupted by a conflict or time limit, calling this again will resume the search exactly as it would have continued.</p>
<dl class="section note"><dt>Note</dt><dd>this will use the <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> singleton, so the time limit will be counted since the last time <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> was reset, not from the start of this function. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352adc08829ed7a57463ccf45d0a6dd34cb2" name="a8022922b9cf102d6697157b3f2ccc352adc08829ed7a57463ccf45d0a6dd34cb2"></a>ASSUMPTIONS_UNSAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352ae81c4874f5f1b05aeef8b9781e26b1ee" name="a8022922b9cf102d6697157b3f2ccc352ae81c4874f5f1b05aeef8b9781e26b1ee"></a>INFEASIBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352a7a6b4bc49d7cd2f0e797b2223c1e605b" name="a8022922b9cf102d6697157b3f2ccc352a7a6b4bc49d7cd2f0e797b2223c1e605b"></a>FEASIBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352a71fe77dfe8a6957ad06c36275d7fcd62" name="a8022922b9cf102d6697157b3f2ccc352a71fe77dfe8a6957ad06c36275d7fcd62"></a>LIMIT_REACHED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00188">188</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af34c6a454416c6dcb2e6310e510e976e" name="af34c6a454416c6dcb2e6310e510e976e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34c6a454416c6dcb2e6310e510e976e">&#9670;&#160;</a></span>SatSolver() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SatSolver::SatSolver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00057">57</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ac0abab4a2ce453f91aa0afb88db55433" name="ac0abab4a2ce453f91aa0afb88db55433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0abab4a2ce453f91aa0afb88db55433">&#9670;&#160;</a></span>SatSolver() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SatSolver::SatSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00062">62</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a30e7ce693a9601da649d9b52ee042d62" name="a30e7ce693a9601da649d9b52ee042d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e7ce693a9601da649d9b52ee042d62">&#9670;&#160;</a></span>SatSolver() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SatSolver::SatSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type is neither copyable nor movable. </p>

</div>
</div>
<a id="a3483e8be8a322018b9ff33f9d1591fb0" name="a3483e8be8a322018b9ff33f9d1591fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3483e8be8a322018b9ff33f9d1591fb0">&#9670;&#160;</a></span>~SatSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SatSolver::~SatSolver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00082">82</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6cb2ddde70037269943ce72ac1d5b163" name="a6cb2ddde70037269943ce72ac1d5b163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb2ddde70037269943ce72ac1d5b163">&#9670;&#160;</a></span>AddBinaryClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddBinaryClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#a647efe64188a8e657a25ab23ddcc08d8">AddProblemClause()</a> below, but for small clauses. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00195">195</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a4eedb16093e09c9c03f34a80547c0f4d" name="a4eedb16093e09c9c03f34a80547c0f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eedb16093e09c9c03f34a80547c0f4d">&#9670;&#160;</a></span>AddBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddBinaryClauses </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>clauses</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01065">1065</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a8b9ba983bd9f911d0605f7615ebf3725" name="a8b9ba983bd9f911d0605f7615ebf3725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9ba983bd9f911d0605f7615ebf3725">&#9670;&#160;</a></span>AddClauseDuringSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddClauseDuringSearch </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a clause at any level of the tree and propagate any new deductions. Returns false if the model becomes UNSAT. Important: We currently do not support adding a clause that is already falsified at a positive decision level. Doing that will cause a check fail.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002401">Todo</a></b></dt><dd>(user): Backjump and propagate on a falsified clause? this is currently not needed. </dd></dl>
<p>Let filter clauses if we are at level zero</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002357">Todo</a></b></dt><dd>(user): We generate in some corner cases clauses with literals[0].<a class="el" href="structVariable.html">Variable()</a> == literals[1].<a class="el" href="structVariable.html">Variable()</a>. Avoid doing that and adding such binary clauses to the graph? </dd></dl>
<p>Tricky: Even if nothing new is propagated, calling <a class="el" href="#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> might, via the LP, deduce new things. This is problematic because some code assumes that when we create newly associated literals, nothing else changes.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00158">158</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aca79ff7f2192b5cd83d224a51485a2c0" name="aca79ff7f2192b5cd83d224a51485a2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca79ff7f2192b5cd83d224a51485a2c0">&#9670;&#160;</a></span>AddLastPropagator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::AddLastPropagator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *</td>          <td class="paramname"><span class="paramname"><em>propagator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00447">447</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a098038f8e0409a8243ff3f7eafb517f8" name="a098038f8e0409a8243ff3f7eafb517f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098038f8e0409a8243ff3f7eafb517f8">&#9670;&#160;</a></span>AddLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a pseudo-Boolean constraint to the problem. Returns false if the problem is detected to be UNSAT. If the constraint is always true, this detects it and does nothing.</p>
<p>Note(user): There is an optimization if the same constraint is added consecutively (even if the bounds are different). This is particularly useful for an optimization problem when we want to constrain the objective of the problem more and more. Just re-adding such constraint is relatively efficient.</p>
<p>OVERFLOW: The sum of the absolute value of all the coefficients in the constraint must not overflow. This is currently CHECKed(). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002397">Todo</a></b></dt><dd>(user): Instead of failing, implement an error handling code. </dd></dl>
<p>We need to "re-canonicalize" in case some literal were fixed while we processed one direction.</p>
<p>We transform the constraint into an upper-bounded one.</p>
<p>Tricky: The PropagationIsDone() condition shouldn't change anything for a pure SAT problem, however in the CP-SAT context, calling <a class="el" href="#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> can tigger computation (like the LP) even if no domain changed since the last call. We do not want to do that.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00350">350</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a647efe64188a8e657a25ab23ddcc08d8" name="a647efe64188a8e657a25ab23ddcc08d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647efe64188a8e657a25ab23ddcc08d8">&#9670;&#160;</a></span>AddProblemClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddProblemClause </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a clause to the problem. Returns false if the problem is detected to be UNSAT.</p>
<p>This must only be called at level zero, use <a class="el" href="#a8b9ba983bd9f911d0605f7615ebf3725">AddClauseDuringSearch()</a> for adding clause at a positive level.</p>
<p>We call this a "problem" clause just because we will never delete such clause unless it is proven to always be satisfied. So this can be called with the initial clause of a problem, but also infered clause that we don't want to delete.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002396">Todo</a></b></dt><dd>(user): Rename this to AddClause() ? Also get rid of the specialized <a class="el" href="#aa16f8b671ca15b9f82ee69236880c176">AddUnitClause()</a>, <a class="el" href="#a6cb2ddde70037269943ce72ac1d5b163" title="Same as AddProblemClause() below, but for small clauses.">AddBinaryClause()</a> and <a class="el" href="#aa5e4956383538b097302c88080569a74">AddTernaryClause()</a> since they just end up calling this? </dd></dl>
<dl class="section note"><dt>Note</dt><dd>we will do a bit of presolve here, which might not always be necessary if we know we are already adding a "clean" clause with no duplicates or literal equivalent to others. However, we found that it is better to make sure we always have "clean" clause in the solver rather than to over-optimize this. In particular, presolve might be disabled or incomplete, so such unclean clause might find their way here. </dd></dl>
<p>Filter already assigned literals. Note that we also remap literal in case we discovered equivalence later in the search.</p>
<p>A clause with l and not(l) is trivially true.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00209">209</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="af488df5e9f46c785660564688c91594d" name="af488df5e9f46c785660564688c91594d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af488df5e9f46c785660564688c91594d">&#9670;&#160;</a></span>AddPropagator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::AddPropagator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *</td>          <td class="paramname"><span class="paramname"><em>propagator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds and registers the given propagator with the sat solver. Note that during propagation, they will be called in the order they were added. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00440">440</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aa5e4956383538b097302c88080569a74" name="aa5e4956383538b097302c88080569a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e4956383538b097302c88080569a74">&#9670;&#160;</a></span>AddTernaryClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddTernaryClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00199">199</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aa16f8b671ca15b9f82ee69236880c176" name="aa16f8b671ca15b9f82ee69236880c176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16f8b671ca15b9f82ee69236880c176">&#9670;&#160;</a></span>AddUnitClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddUnitClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>true_literal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fixes a variable so that the given literal is true. This can be used to solve a subproblem where some variables are fixed. Note that it is more efficient to add such unit clause before all the others. Returns false if the problem is detected to be UNSAT. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00191">191</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ab19f21598928ec3f2515db06515cb7c9" name="ab19f21598928ec3f2515db06515cb7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19f21598928ec3f2515db06515cb7c9">&#9670;&#160;</a></span>AdvanceDeterministicTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::AdvanceDeterministicTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>limit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the given time limit with all the deterministic time that was elapsed since last call. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00481">481</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a9d71ca32207f031cff5c0648452a30f0" name="a9d71ca32207f031cff5c0648452a30f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d71ca32207f031cff5c0648452a30f0">&#9670;&#160;</a></span>AllPreferences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, float &gt; &gt; operations_research::sat::SatSolver::AllPreferences </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00168">168</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="abae9d5e427bdd44a6e581f3a06b7f703" name="abae9d5e427bdd44a6e581f3a06b7f703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae9d5e427bdd44a6e581f3a06b7f703">&#9670;&#160;</a></span>Assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp; operations_research::sat::SatSolver::Assignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00393">393</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ac3bdb41422d29fd811705a62ffc41877" name="ac3bdb41422d29fd811705a62ffc41877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bdb41422d29fd811705a62ffc41877">&#9670;&#160;</a></span>AssumptionLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::AssumptionLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current assumption level. Note that if a solve was done since the last <a class="el" href="#a9a2f6d9f21b096f25d8d093c664da6f4">SetAssumptionLevel()</a>, then the returned level may be lower than the one that was set. This is because some assumptions may now be consequences of others before them due to the newly learned clauses. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00229">229</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a7c0c2912da716e49c8b5d84108e463d7" name="a7c0c2912da716e49c8b5d84108e463d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0c2912da716e49c8b5d84108e463d7">&#9670;&#160;</a></span>Backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::Backtrack </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>target_level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores the state to the given target decision level. The decision at that level and all its propagation will not be undone. But all the trail after this will be cleared. Calling this with 0 will revert all the decisions and only the fixed variables will be left on the trail. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002367">Todo</a></b></dt><dd>(user): The backtrack method should not be called when the model is unsat. Add a DCHECK to prevent that, but before fix the <a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html">bop::BopOptimizerBase</a> architecture. </dd></dl>
<p>Do nothing if the <a class="el" href="#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel()</a> is already correct. This is needed, otherwise target_trail_index below will remain at zero and that will cause some problems. Note that we could forbid a user to call <a class="el" href="#a7c0c2912da716e49c8b5d84108e463d7">Backtrack()</a> with the current level, but that is annoying when you just want to reset the solver with Backtrack(0).</p>
<p>Any backtrack to the root from a positive one is counted as a restart.</p>
<p>Per the <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints.">SatPropagator</a> interface, this is needed before calling Untrail.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01027">1027</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a82bd5458903038cd72064671d10c620d" name="a82bd5458903038cd72064671d10c620d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bd5458903038cd72064671d10c620d">&#9670;&#160;</a></span>ClearNewlyAddedBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ClearNewlyAddedBinaryClauses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01079">1079</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ae9c9df3c27f93259f24d24ddd53a0bf2" name="ae9c9df3c27f93259f24d24ddd53a0bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c9df3c27f93259f24d24ddd53a0bf2">&#9670;&#160;</a></span>counters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Counters.html">Counters</a> operations_research::sat::SatSolver::counters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00434">434</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="abf1b11c4b39c9745a264638dc0381914" name="abf1b11c4b39c9745a264638dc0381914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1b11c4b39c9745a264638dc0381914">&#9670;&#160;</a></span>CurrentDecisionLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::CurrentDecisionLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00391">391</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ad230258762a2fc372ece535a4e3b9f06" name="ad230258762a2fc372ece535a4e3b9f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad230258762a2fc372ece535a4e3b9f06">&#9670;&#160;</a></span>Decisions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Decision.html">Decision</a> &gt; &amp; operations_research::sat::SatSolver::Decisions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>the <a class="el" href="#ad230258762a2fc372ece535a4e3b9f06">Decisions()</a> vector is always of size <a class="el" href="#ada8b7f7a38df9c1f3111c5fc03eb79fa">NumVariables()</a>, and that only the first <a class="el" href="#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel()</a> entries have a meaning. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00390">390</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a1ac88207c0228d80d19751186955240f" name="a1ac88207c0228d80d19751186955240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac88207c0228d80d19751186955240f">&#9670;&#160;</a></span>deterministic_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::SatSolver::deterministic_time </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A deterministic number that should be correlated with the time spent in the <a class="el" href="#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a> function. The order of magnitude should be close to the time in seconds. </p>
<p>Each of these counters mesure really basic operations. The weight are just an estimate of the operation complexity. Note that these counters are never reset to zero once a <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> is created.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002356">Todo</a></b></dt><dd>(user): Find a better procedure to fix the weight than just educated guess. </dd></dl>
<p>Here there is a factor 2 because of the untrail.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00114">114</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a6f9e49e76092a3d062d5736f0214a4f4" name="a6f9e49e76092a3d062d5736f0214a4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9e49e76092a3d062d5736f0214a4f4">&#9670;&#160;</a></span>EnqueueDecisionAndBackjumpOnConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::EnqueueDecisionAndBackjumpOnConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>true_literal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. The next 3 functions allow to drive the search from outside the solver. Takes a new decision (the given true_literal must be unassigned) and propagates it. Returns the trail index of the first newly propagated literal. If there is a conflict and the problem is detected to be UNSAT, returns kUnsatTrailIndex.</p>
<p>Important: In the presence of assumptions, this also returns kUnsatTrailIndex on ASSUMPTION_UNSAT. One can know the difference with <a class="el" href="#a84e27e6cb848b3176ab5680292d116a8">IsModelUnsat()</a>.</p>
<p>A client can determine if there is a conflict by checking if the <a class="el" href="#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel()</a> was increased by 1 or not.</p>
<p>If there is a conflict, the given decision is not applied and:</p><ul>
<li>The conflict is learned.</li>
<li>The decisions are potentially backtracked to the first decision that propagates more variables because of the newly learned conflict.</li>
<li>The returned value is equal to trail_-&gt;Index() after this backtracking and just before the new propagation (due to the conflict) which is also performed by this function. </li>
</ul>
<p>We should never enqueue before the assumptions_.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00552">552</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a070d8cce319cec13c09f0089baebf746" name="a070d8cce319cec13c09f0089baebf746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d8cce319cec13c09f0089baebf746">&#9670;&#160;</a></span>EnqueueDecisionAndBacktrackOnConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::EnqueueDecisionAndBacktrackOnConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>true_literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>first_propagation_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function starts by calling <a class="el" href="#a6f9e49e76092a3d062d5736f0214a4f4">EnqueueDecisionAndBackjumpOnConflict()</a>. If there is no conflict, it stops there. Otherwise, it tries to reapply all the decisions that were backjumped over until the first one that can't be taken because it is incompatible. Note that during this process, more conflicts may happen and the trail may be backtracked even further.</p>
<p>In any case, the new decisions stack will be the largest valid "prefix" of the old stack. Note that decisions that are now consequence of the ones before them will no longer be decisions.</p>
<p>Returns INFEASIBLE if the model was proven infeasible, ASSUMPTION_UNSAT if the current decision and the one we are trying to take are not compatible together and FEASIBLE if all decisions are taken.</p>
<p>Note(user): This function can be called with an already assigned literal. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00998">998</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a89fb06019f0cfb5ac683c556c61d65e5" name="a89fb06019f0cfb5ac683c556c61d65e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fb06019f0cfb5ac683c556c61d65e5">&#9670;&#160;</a></span>EnqueueDecisionIfNotConflicting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::EnqueueDecisionIfNotConflicting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>true_literal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to enqueue the given decision and performs the propagation. Returns true if no conflict occurred. Otherwise, returns false and restores the solver to the state just before this was called.</p>
<p>Note(user): With this function, the solver doesn't learn anything. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01012">1012</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a75a0da16b753cfbfc8251f91025f9f42" name="a75a0da16b753cfbfc8251f91025f9f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a0da16b753cfbfc8251f91025f9f42">&#9670;&#160;</a></span>EnsureNewClauseIndexInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::EnsureNewClauseIndexInitialized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00508">508</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a0174fd7221118d81a925d32aaed1cc79" name="a0174fd7221118d81a925d32aaed1cc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0174fd7221118d81a925d32aaed1cc79">&#9670;&#160;</a></span>ExtractClauses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ExtractClauses </td>
          <td>(</td>
          <td class="paramtype">Output *</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract the current problem clauses. The Output type must support the two functions:</p><ul>
<li>void <a class="el" href="#a6cb2ddde70037269943ce72ac1d5b163" title="Same as AddProblemClause() below, but for small clauses.">AddBinaryClause(Literal a, Literal b)</a>;</li>
<li>void AddClause(absl::Span&lt;const Literal&gt; clause);</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002400">Todo</a></b></dt><dd>(user): also copy the removable clauses? </dd></dl>
<p>It is important to process the newly fixed variables, so they are not present in the clauses we export.</p>
<p>Note(user): Putting the binary clauses first help because the presolver currently process the clauses in order.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00351">351</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ad4458486171153c1793c28e2091140d9" name="ad4458486171153c1793c28e2091140d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4458486171153c1793c28e2091140d9">&#9670;&#160;</a></span>FinishPropagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::FinishPropagation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. Finish the progation if it was interrupted. Note that this might run into conflict and will propagate again until a fixed point is reached or the model was proven UNSAT. Returns <a class="el" href="#a84e27e6cb848b3176ab5680292d116a8">IsModelUnsat()</a>. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002361">Todo</a></b></dt><dd>(user): Exiting like this might cause issue since the propagation is not "finished" but some code might assume it is. However since we already might repropagate in the LP constraint, most of the code should support "not finished propagation". </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00577">577</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a96bd2bfe51a3e42ac2f18fec4af24311" name="a96bd2bfe51a3e42ac2f18fec4af24311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bd2bfe51a3e42ac2f18fec4af24311">&#9670;&#160;</a></span>GetDecisionsFixing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::SatSolver::GetDecisionsFixing </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a subset of decisions that are sufficient to ensure all literals in <code>literals</code> are fixed to their current value. </p>
<p>We just expand the conflict until we only have decisions.</p>
<p>Find next marked literal to expand from the trail.</p>
<p>Marks all the literals of its reason.</p>
<p>We reverse the assumptions so they are in the same order as the one in which the decision were made.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01563">1563</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a69bfff1cfcd0f24e7a9ee2b583f594ea" name="a69bfff1cfcd0f24e7a9ee2b583f594ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bfff1cfcd0f24e7a9ee2b583f594ea">&#9670;&#160;</a></span>GetLastIncompatibleDecisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::SatSolver::GetLastIncompatibleDecisions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be called just after SolveWithAssumptions() returned ASSUMPTION_UNSAT or after <a class="el" href="#a070d8cce319cec13c09f0089baebf746">EnqueueDecisionAndBacktrackOnConflict()</a> leaded to a conflict. It returns a subsequence (in the correct order) of the previously enqueued decisions that cannot be taken together without making the problem UNSAT. </p>
<p>literal at true in the conflict must be the last decision/assumption that could not be taken. Put it at the front to add to the result later.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01542">1542</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a84e27e6cb848b3176ab5680292d116a8" name="a84e27e6cb848b3176ab5680292d116a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e27e6cb848b3176ab5680292d116a8">&#9670;&#160;</a></span>IsModelUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::IsModelUnsat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002398">Todo</a></b></dt><dd>(user): remove this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00151">151</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="adf67ece21b8195e56e577932269c130b" name="adf67ece21b8195e56e577932269c130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf67ece21b8195e56e577932269c130b">&#9670;&#160;</a></span>LiteralTrail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp; operations_research::sat::SatSolver::LiteralTrail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00392">392</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a10758f34598c390626b2a000d44aeee6" name="a10758f34598c390626b2a000d44aeee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10758f34598c390626b2a000d44aeee6">&#9670;&#160;</a></span>LoadDebugSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::LoadDebugSolution </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>solution</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We should only call this with complete solution.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00483">483</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a3530dbc523b77d414ae58830addba843" name="a3530dbc523b77d414ae58830addba843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3530dbc523b77d414ae58830addba843">&#9670;&#160;</a></span>MinimizeByPropagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::MinimizeByPropagation </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>minimize_new_clauses_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tricky: we don't want TryToMinimizeClause() to delete to_minimize while we are processing it.</p>
<p>Note(user): In some corner cases, the function above might find a feasible assignment. I think it is okay to ignore this special case that should only happen on trivial problems and just reset the solver.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01499">1499</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a5420a6d871314779beeac0c074241c1a" name="a5420a6d871314779beeac0c074241c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5420a6d871314779beeac0c074241c1a">&#9670;&#160;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> * operations_research::sat::SatSolver::model </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002394">Todo</a></b></dt><dd>(user): Remove. This is temporary for accessing the model deep within some old code that didn't use the <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00072">72</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a7aebdd03bb49157e1de8516e1dbfc4ef" name="a7aebdd03bb49157e1de8516e1dbfc4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebdd03bb49157e1de8516e1dbfc4ef">&#9670;&#160;</a></span>ModelIsUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ModelIsUnsat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the model is UNSAT. Note that currently the status is "sticky" and once this happen, nothing else can be done with the solver.</p>
<p>Thanks to this function, a client can safely ignore the return value of any Add*() functions. If one of them return false, then <a class="el" href="#a7aebdd03bb49157e1de8516e1dbfc4ef">ModelIsUnsat()</a> will return true. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00148">148</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a4cb1a5ce3dfe14d0ed05da23b66bff2a" name="a4cb1a5ce3dfe14d0ed05da23b66bff2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb1a5ce3dfe14d0ed05da23b66bff2a">&#9670;&#160;</a></span>mutable_logger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1SolverLogger.html">SolverLogger</a> * operations_research::sat::SatSolver::mutable_logger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hack to allow to temporarily disable logging if it is enabled. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00498">498</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a52bb790559c188628c9e93530235a223" name="a52bb790559c188628c9e93530235a223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bb790559c188628c9e93530235a223">&#9670;&#160;</a></span>NewBooleanVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BooleanVariable operations_research::sat::SatSolver::NewBooleanVariable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We need to be able to encode the variable as a literal.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00090">90</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a3087db3ee9aceca1a27369dff0d5ad61" name="a3087db3ee9aceca1a27369dff0d5ad61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3087db3ee9aceca1a27369dff0d5ad61">&#9670;&#160;</a></span>NewlyAddedBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt; &amp; operations_research::sat::SatSolver::NewlyAddedBinaryClauses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01075">1075</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a61260f1f86d76b6605c82d69ad96186d" name="a61260f1f86d76b6605c82d69ad96186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61260f1f86d76b6605c82d69ad96186d">&#9670;&#160;</a></span>NotifyThatModelIsUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::NotifyThatModelIsUnsat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is here to deal with the case where a SAT/CP model is found to be trivially UNSAT while the user is constructing the model. Instead of having to test the status of all the lines adding a constraint, one can just check if the solver is not UNSAT once the model is constructed. Note that we usually log a warning on the first constraint that caused a "trival" unsatisfiability. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00461">461</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a870d1a233165edaf4f2838f027f609cc" name="a870d1a233165edaf4f2838f027f609cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870d1a233165edaf4f2838f027f609cc">&#9670;&#160;</a></span>num_backtracks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_backtracks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00110">110</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a5efb093cfaf3450b6816fab8c0759e19" name="a5efb093cfaf3450b6816fab8c0759e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efb093cfaf3450b6816fab8c0759e19">&#9670;&#160;</a></span>num_branches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_branches </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some statistics since the creation of the solver. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00102">102</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a75b31c338ba4d070b8880539bc9a09eb" name="a75b31c338ba4d070b8880539bc9a09eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b31c338ba4d070b8880539bc9a09eb">&#9670;&#160;</a></span>num_failures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_failures </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00104">104</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a82dd736a0e48550f444665f4c9848be3" name="a82dd736a0e48550f444665f4c9848be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dd736a0e48550f444665f4c9848be3">&#9670;&#160;</a></span>num_propagations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_propagations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00106">106</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a9f8e763148cc7f4b31e2efc3e3126cd4" name="a9f8e763148cc7f4b31e2efc3e3126cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8e763148cc7f4b31e2efc3e3126cd4">&#9670;&#160;</a></span>num_restarts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_restarts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>we count the number of backtrack to level zero from a positive level. Those can corresponds to actual restarts, or conflicts that learn unit clauses or any other reason that trigger such backtrack. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00112">112</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="af14377fec21151aa9faaa12d861fe8dc" name="af14377fec21151aa9faaa12d861fe8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14377fec21151aa9faaa12d861fe8dc">&#9670;&#160;</a></span>NumFixedVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::NumFixedVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00491">491</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ada8b7f7a38df9c1f3111c5fc03eb79fa" name="ada8b7f7a38df9c1f3111c5fc03eb79fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8b7f7a38df9c1f3111c5fc03eb79fa">&#9670;&#160;</a></span>NumVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::NumVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00089">89</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ab044c123d6e5222d758c78d5a1cb9f18" name="ab044c123d6e5222d758c78d5a1cb9f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab044c123d6e5222d758c78d5a1cb9f18">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp; operations_research::sat::SatSolver::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8904d8354eb343b3d0cc598a02f4140c" name="a8904d8354eb343b3d0cc598a02f4140c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904d8354eb343b3d0cc598a02f4140c">&#9670;&#160;</a></span>parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SatParameters &amp; operations_research::sat::SatSolver::parameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00132">132</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a3afed23ec8289b170f0a25ec4b10dd84" name="a3afed23ec8289b170f0a25ec4b10dd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afed23ec8289b170f0a25ec4b10dd84">&#9670;&#160;</a></span>ProcessCurrentConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ProcessCurrentConflict </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Processes the current conflict from trail-&gt;FailingClause().</p>
<p>This learns the conflict, backtracks, enqueues the consequence of the learned conflict and return. When handling assumptions, this might return false without backtracking in case of ASSUMPTIONS_UNSAT. This is only exposed to allow processing a conflict detected outside normal propagation. </p>
<p>A conflict occurred, compute a nice reason for this failure.</p>
<p>If the failing clause only contains literal at the assumptions level, we cannot use the ComputeFirstUIPConflict() code as we might have more than one decision.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002362">Todo</a></b></dt><dd>(user): We might still want to "learn" the clause, especially if it reduces to only one literal in which case we can just fix it. </dd></dl>
<p>An empty conflict means that the problem is UNSAT.</p>
<p>Update the activity of all the variables in the first UIP clause. Also update the activity of the last level variables expanded (and thus discarded) during the first UIP computation. Note that both sets are disjoint.</p>
<p>Bump the clause activities. </p><dl class="section note"><dt>Note</dt><dd>the activity of the learned clause will be bumped too by AddLearnedClauseAndEnqueueUnitPropagation().</dd></dl>
<p>Decay the activities.</p>
<p>Hack from Glucose that seems to perform well.</p>
<p>PB resolution. There is no point using this if the conflict and all the reasons involved in its resolution were clauses.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002363">Todo</a></b></dt><dd>(user): Note that we use the clause above to update the variable activities and not the pb conflict. Experiment. </dd></dl>
<p>Generic clause case.</p>
<p>We have a pseudo-Boolean conflict, so we start from there.</p>
<p>Convert the conflict into the vector&lt;LiteralWithCoeff&gt; form.</p>
<p>Check if the learned PB conflict is just a clause: all its coefficient must be 1, and the rhs must be its size minus 1.</p>
<p>Use the PB conflict.</p>
<p>Continue with the normal clause flow, but use the PB conflict clause if it has a lower backjump level.</p>
<p>The minimization functions below expect the conflict to be marked! </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002364">Todo</a></b></dt><dd>(user): This is error prone, find a better way? </dd></dl>
<p>Minimizing the conflict with binary clauses first has two advantages. First, there is no need to compute a reason for the variables eliminated this way. Second, more variables may be marked (in is_marked_) and MinimizeConflict() can take advantage of that. Because of this, the LBD of the learned conflict can change.</p>
<p>Minimize the learned conflict.</p>
<p>Minimize it further with binary clauses?</p>
<dl class="section note"><dt>Note</dt><dd>on the contrary to the MinimizeConflict() above that just uses the reason graph, this minimization can change the clause LBD and even the backtracking level.</dd></dl>
<p>We notify the decision before backtracking so that we can save the phase. The current heuristic is to try to take a trail prefix for which there is currently no conflict (hence just before the last decision was taken).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002365">Todo</a></b></dt><dd>(user): It is unclear what the best heuristic is here. Both the current trail index or the trail before the current decision perform well, but using the full trail seems slightly better even though it will contain the current conflicting literal. </dd></dl>
<p>Backtrack and add the reason to the set of learned clause.</p>
<dl class="section note"><dt>Note</dt><dd>we need to output the learned clause before cleaning the clause database. This is because we already backtracked and some of the clauses that were needed to infer the conflict may not be "reasons" anymore and may be deleted.</dd></dl>
<p>Because we might change the conflict with this minimization algorithm, we cannot just subsume clauses with it blindly.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002366">Todo</a></b></dt><dd>(user): Either remove that algorithm or support subsumption by just checking if it is okay to do so, or doing it on the fly while computing the first UIP. </dd></dl>
<p>Detach any subsumed clause. They will actually be deleted on the next clause cleanup phase.</p>
<p>Create and attach the new learned clause.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00681">681</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a52e24044eed32b555fd94b40b8f6423c" name="a52e24044eed32b555fd94b40b8f6423c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e24044eed32b555fd94b40b8f6423c">&#9670;&#160;</a></span>ProcessNewlyFixedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ProcessNewlyFixedVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the problem when new variables are assigned at level 0. </p>
<p>We remove the clauses that are always true and the fixed literals from the others. Note that none of the clause should be all false because we should have detected a conflict before this is called.</p>
<p>The clause is always true, detach it.</p>
<p>This clause is now a binary clause, treat it separately. Note that it is safe to do that because this clause can't be used as a reason since we are at level zero and the clause is not satisfied.</p>
<dl class="section note"><dt>Note</dt><dd>we will only delete the clauses during the next database cleanup.</dd></dl>
<p>We also clean the binary implication graph. Tricky: If we added the first binary clauses above, the binary graph is not in "propagated" state as it should be, so we call <a class="el" href="#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> so all the checks are happy.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01839">1839</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a9188c70cc1096900a623a26319a1d4b8" name="a9188c70cc1096900a623a26319a1d4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9188c70cc1096900a623a26319a1d4b8">&#9670;&#160;</a></span>Propagate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::Propagate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs propagation of the recently enqueued elements. Mainly visible for testing.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002378">Todo</a></b></dt><dd>(user): Support propagating only the "first" propagators. That can be useful for probing/in-processing, so we can control if we do only the SAT part or the full integer part... </dd></dl>
<p>Because we might potentially iterate often on this list below, we remove empty propagators.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002379">Todo</a></b></dt><dd>(user): This might not really be needed. </dd></dl>
<p>The idea here is to abort the inspection as soon as at least one propagation occurs so we can loop over and test again the highest priority constraint types using the new information.</p>
<dl class="section note"><dt>Note</dt><dd>the first propagators_ should be the binary_implication_graph_ and that its <a class="el" href="#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> functions will not abort on the first propagation to be slightly more efficient.</dd></dl>
<p>In some corner cases, we might add new constraint during propagation, which might trigger new propagator addition or some propagator to become non-empty() now.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01910">1910</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a82300521f18442372bb16efd01463cd9" name="a82300521f18442372bb16efd01463cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82300521f18442372bb16efd01463cd9">&#9670;&#160;</a></span>ReapplyAssumptionsIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ReapplyAssumptionsIfNeeded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. If the decision level is smaller than the assumption level, this will try to reapply all assumptions. Returns true if this was doable, otherwise returns false in which case the model is either UNSAT or ASSUMPTION_UNSAT.</p>
<dl class="section note"><dt>Note</dt><dd>we do not count these as "branches" for a reporting purpose. </dd></dl>
<p>When assumptions_ is not empty, the first "decision" actually contains multiple one, and we should never use its literal.</p>
<p>We enqueue all assumptions at once at decision level 1.</p>
<p>See <a class="el" href="#a69bfff1cfcd0f24e7a9ee2b583f594ea">GetLastIncompatibleDecisions()</a>.</p>
<p>This is needed to avoid an empty level that cause some CHECK fail.</p>
<p>Corner case: all assumptions are fixed at level zero, we ignore them.</p>
<p>Now that everything is enqueued, we propagate.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00630">630</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ab20cec16641434c61d9185a0edef37a7" name="ab20cec16641434c61d9185a0edef37a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20cec16641434c61d9185a0edef37a7">&#9670;&#160;</a></span>ResetAndSolveWithGivenAssumptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::ResetAndSolveWithGivenAssumptions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assumptions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>max_number_of_conflicts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple interface to solve a problem under the given assumptions. This simply ask the solver to solve a problem given a set of variables fixed to a given value (the assumptions). Compared to simply calling <a class="el" href="#aa16f8b671ca15b9f82ee69236880c176">AddUnitClause()</a> and fixing the variables once and for all, this allow to backtrack over the assumptions and thus exploit the incrementally between subsequent solves.</p>
<p>This function backtrack over all the current decision, tries to enqueue the given assumptions, sets the assumption level accordingly and finally calls <a class="el" href="#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a>.</p>
<p>If, given these assumptions, the model is UNSAT, this returns the ASSUMPTIONS_UNSAT status. INFEASIBLE is reserved for the case where the model is proven to be unsat without any assumptions.</p>
<p>If ASSUMPTIONS_UNSAT is returned, it is possible to get a "core" of unsat assumptions by calling <a class="el" href="#a69bfff1cfcd0f24e7a9ee2b583f594ea">GetLastIncompatibleDecisions()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01090">1090</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a7a644e6b565ec38603e6db416136a8b1" name="a7a644e6b565ec38603e6db416136a8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a644e6b565ec38603e6db416136a8b1">&#9670;&#160;</a></span>ResetDecisionHeuristic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ResetDecisionHeuristic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00171">171</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ac4dacb6b250d8bb139a1e7c3071892b7" name="ac4dacb6b250d8bb139a1e7c3071892b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dacb6b250d8bb139a1e7c3071892b7">&#9670;&#160;</a></span>ResetToLevelZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ResetToLevelZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like Backtrack(0) but make sure the propagation is finished and return false if unsat was detected. This also removes any assumptions level. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00605">605</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a552a7e42a1957d95b1cce7078ad29fdb" name="a552a7e42a1957d95b1cce7078ad29fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552a7e42a1957d95b1cce7078ad29fdb">&#9670;&#160;</a></span>ResetWithGivenAssumptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ResetWithGivenAssumptions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assumptions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the assumptions level and the current solver assumptions. Returns false if the model is UNSAT or ASSUMPTION_UNSAT, true otherwise.</p>
<p>This uses the "new" assumptions handling, where all assumptions are enqueued at once at decision level 1 before we start to propagate. This has many advantages. In particular, because we propagate with the binary implications first, if we ever have assumption =&gt; not(other_assumptions) we are guaranteed to find it and returns a core of size 2.</p>
<p>Paper: "Speeding Up Assumption-Based SAT", Randy Hickey and Fahiem Bacchus <a href="http://www.maxhs.org/docs/Hickey-Bacchus2019_Chapter_SpeedingUpAssumption-BasedSAT.pdf">http://www.maxhs.org/docs/Hickey-Bacchus2019_Chapter_SpeedingUpAssumption-BasedSAT.pdf</a> </p>
<p>For assumptions and core-based search, it is really important to add as many binary clauses as possible. This is because we do not wan to miss any early core of size 2.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00613">613</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a6b42ef3040a15e72f3f7efa302e32583" name="a6b42ef3040a15e72f3f7efa302e32583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b42ef3040a15e72f3f7efa302e32583">&#9670;&#160;</a></span>RestoreSolverToAssumptionLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::RestoreSolverToAssumptionLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. This is meant to restore the solver to a "proper" state after a solve was interrupted due to a limit reached.</p>
<p>Without assumption (i.e. if <a class="el" href="#ac3bdb41422d29fd811705a62ffc41877">AssumptionLevel()</a> is 0), this will revert all decisions and make sure that all the fixed literals are propagated. In presence of assumptions, this will either backtrack to the assumption level or re-enqueue any assumptions that may have been backtracked over due to conflits resolution. In both cases, the propagation is finished.</p>
<dl class="section note"><dt>Note</dt><dd>this may prove the model to be UNSAT or ASSUMPTION_UNSAT in which case it will return false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00567">567</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ac7db73938c1101728cb3c7ed61dfd72e" name="ac7db73938c1101728cb3c7ed61dfd72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7db73938c1101728cb3c7ed61dfd72e">&#9670;&#160;</a></span>SaveDebugAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SaveDebugAssignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only used for debugging. Save the current assignment in debug_assignment_. The idea is that if we know that a given assignment is satisfiable, then all the learned clauses or PB constraints must be satisfiable by it. In debug mode, and after this is called, all the learned clauses are tested to satisfy this saved assignment. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00475">475</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a50484f243bcc0ec12ed3919d84dc38ad" name="a50484f243bcc0ec12ed3919d84dc38ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50484f243bcc0ec12ed3919d84dc38ad">&#9670;&#160;</a></span>SetAssignmentPreference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetAssignmentPreference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>literal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>weight</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrapper around the same functions in <a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html">SatDecisionPolicy</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002399">Todo</a></b></dt><dd>(user): Clean this up by making clients directly talk to <a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html">SatDecisionPolicy</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00165">165</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a9a2f6d9f21b096f25d8d093c664da6f4" name="a9a2f6d9f21b096f25d8d093c664da6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2f6d9f21b096f25d8d093c664da6f4">&#9670;&#160;</a></span>SetAssumptionLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetAssumptionLevel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>assumption_level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the assumption level. All the decisions below this level will be treated as assumptions by the next <a class="el" href="#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a>. Note that this may impact some heuristics, like the LBD value of a clause. </p>
<p>New assumption code.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01106">1106</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a1825b361bdf46ac399ff264a402b6c40" name="a1825b361bdf46ac399ff264a402b6c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1825b361bdf46ac399ff264a402b6c40">&#9670;&#160;</a></span>SetDratProofHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetDratProofHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>drat_proof_handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00449">449</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ae8f40548efeb9f6bde6ff1cd872acc38" name="ae8f40548efeb9f6bde6ff1cd872acc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f40548efeb9f6bde6ff1cd872acc38">&#9670;&#160;</a></span>SetNumVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetNumVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_variables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the number of variables of the current problem.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002395">Todo</a></b></dt><dd>(user): Rename to IncreaseNumVariablesTo() until we support removing variables... </dd></dl>
<p>The +1 is a bit tricky, it is because in <a class="el" href="#a070d8cce319cec13c09f0089baebf746">EnqueueDecisionAndBacktrackOnConflict()</a> we artificially enqueue the decision before checking if it is not already assigned.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00084">84</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="af8c68be5db0ba121693811895e89de8c" name="af8c68be5db0ba121693811895e89de8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c68be5db0ba121693811895e89de8c">&#9670;&#160;</a></span>SetParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetParameters </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters management. Note that calling <a class="el" href="#af8c68be5db0ba121693811895e89de8c">SetParameters()</a> will reset the value of many heuristics. For instance:</p><ul>
<li>The restart strategy will be reinitialized.</li>
<li>The random seed and random generator will be reset to the value given in parameters.</li>
<li>The global <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> singleton will be reset and time will be counted from this call. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00137">137</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a8a32f2b63a24749a0c9f6e34d068f1b0" name="a8a32f2b63a24749a0c9f6e34d068f1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a32f2b63a24749a0c9f6e34d068f1b0">&#9670;&#160;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::Solve </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01123">1123</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a11914d218bc38bf85e6e5b5222ede644" name="a11914d218bc38bf85e6e5b5222ede644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11914d218bc38bf85e6e5b5222ede644">&#9670;&#160;</a></span>SolveWithTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::SolveWithTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *</td>          <td class="paramname"><span class="paramname"><em>time_limit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a>, but with a given time limit. Note that this will not update the <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> singleton, but only the passed object instead. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01118">1118</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aab9f2f42bb6656121254538958473c08" name="aab9f2f42bb6656121254538958473c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9f2f42bb6656121254538958473c08">&#9670;&#160;</a></span>TakePropagatorOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::TakePropagatorOwnership </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>propagator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00157">157</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a6f805974da54c343a094962a8d709db3" name="a6f805974da54c343a094962a8d709db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f805974da54c343a094962a8d709db3">&#9670;&#160;</a></span>TrackBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::TrackBinaryClauses </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions to manage the set of learned binary clauses. Only clauses added/learned when TrackBinaryClause() is true are managed. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00376">376</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a402c109f0e0a118d4d916aba5a54e84d" name="a402c109f0e0a118d4d916aba5a54e84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402c109f0e0a118d4d916aba5a54e84d">&#9670;&#160;</a></span>UnsatStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8022922b9cf102d6697157b3f2ccc352">Status</a> operations_research::sat::SatSolver::UnsatStatus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper functions to get the correct status when one of the functions above returns false. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00340">340</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="sat__solver_8h_source.html">sat_solver.h</a></li>
<li>ortools/sat/<a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
