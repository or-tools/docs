<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::SatSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.5</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classoperations__research_1_1sat_1_1SatSolver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1SatSolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::SatSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Decision.html">Decision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8022922b9cf102d6697157b3f2ccc352"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">Status</a> { <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352adc08829ed7a57463ccf45d0a6dd34cb2">ASSUMPTIONS_UNSAT</a>
, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352ae81c4874f5f1b05aeef8b9781e26b1ee">INFEASIBLE</a>
, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352a7a6b4bc49d7cd2f0e797b2223c1e605b">FEASIBLE</a>
, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352a71fe77dfe8a6957ad06c36275d7fcd62">LIMIT_REACHED</a>
 }</td></tr>
<tr class="separator:a8022922b9cf102d6697157b3f2ccc352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af34c6a454416c6dcb2e6310e510e976e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#af34c6a454416c6dcb2e6310e510e976e">SatSolver</a> ()</td></tr>
<tr class="separator:af34c6a454416c6dcb2e6310e510e976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0abab4a2ce453f91aa0afb88db55433"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ac0abab4a2ce453f91aa0afb88db55433">SatSolver</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a5420a6d871314779beeac0c074241c1a">model</a>)</td></tr>
<tr class="separator:ac0abab4a2ce453f91aa0afb88db55433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3483e8be8a322018b9ff33f9d1591fb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a3483e8be8a322018b9ff33f9d1591fb0">~SatSolver</a> ()</td></tr>
<tr class="separator:a3483e8be8a322018b9ff33f9d1591fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5420a6d871314779beeac0c074241c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a5420a6d871314779beeac0c074241c1a">model</a> ()</td></tr>
<tr class="separator:a5420a6d871314779beeac0c074241c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c68be5db0ba121693811895e89de8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#af8c68be5db0ba121693811895e89de8c">SetParameters</a> (const SatParameters &amp;<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8904d8354eb343b3d0cc598a02f4140c">parameters</a>)</td></tr>
<tr class="separator:af8c68be5db0ba121693811895e89de8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8904d8354eb343b3d0cc598a02f4140c"><td class="memItemLeft" align="right" valign="top">const SatParameters &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8904d8354eb343b3d0cc598a02f4140c">parameters</a> () const</td></tr>
<tr class="separator:a8904d8354eb343b3d0cc598a02f4140c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f40548efeb9f6bde6ff1cd872acc38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ae8f40548efeb9f6bde6ff1cd872acc38">SetNumVariables</a> (int num_variables)</td></tr>
<tr class="separator:ae8f40548efeb9f6bde6ff1cd872acc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8b7f7a38df9c1f3111c5fc03eb79fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ada8b7f7a38df9c1f3111c5fc03eb79fa">NumVariables</a> () const</td></tr>
<tr class="separator:ada8b7f7a38df9c1f3111c5fc03eb79fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bb790559c188628c9e93530235a223"><td class="memItemLeft" align="right" valign="top">BooleanVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a52bb790559c188628c9e93530235a223">NewBooleanVariable</a> ()</td></tr>
<tr class="separator:a52bb790559c188628c9e93530235a223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16f8b671ca15b9f82ee69236880c176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aa16f8b671ca15b9f82ee69236880c176">AddUnitClause</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal)</td></tr>
<tr class="separator:aa16f8b671ca15b9f82ee69236880c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb2ddde70037269943ce72ac1d5b163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a6cb2ddde70037269943ce72ac1d5b163">AddBinaryClause</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="memdesc:a6cb2ddde70037269943ce72ac1d5b163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a2613df5393b4e2285789856150543b70">AddProblemClause()</a> below, but for small clauses.  <br /></td></tr>
<tr class="separator:a6cb2ddde70037269943ce72ac1d5b163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e4956383538b097302c88080569a74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aa5e4956383538b097302c88080569a74">AddTernaryClause</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> c)</td></tr>
<tr class="separator:aa5e4956383538b097302c88080569a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2613df5393b4e2285789856150543b70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a2613df5393b4e2285789856150543b70">AddProblemClause</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals, bool is_safe=true)</td></tr>
<tr class="separator:a2613df5393b4e2285789856150543b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098038f8e0409a8243ff3f7eafb517f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a098038f8e0409a8243ff3f7eafb517f8">AddLinearConstraint</a> (bool use_lower_bound, Coefficient <a class="el" href="routing_8cc.html#a50aafce50706f66d29b8588fa463442c">lower_bound</a>, bool use_upper_bound, Coefficient <a class="el" href="routing_8cc.html#a070da095a863e1b6c860e29e59e6db1b">upper_bound</a>, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *cst)</td></tr>
<tr class="separator:a098038f8e0409a8243ff3f7eafb517f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebdd03bb49157e1de8516e1dbfc4ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7aebdd03bb49157e1de8516e1dbfc4ef">ModelIsUnsat</a> () const</td></tr>
<tr class="separator:a7aebdd03bb49157e1de8516e1dbfc4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e27e6cb848b3176ab5680292d116a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a84e27e6cb848b3176ab5680292d116a8">IsModelUnsat</a> () const</td></tr>
<tr class="separator:a84e27e6cb848b3176ab5680292d116a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af488df5e9f46c785660564688c91594d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#af488df5e9f46c785660564688c91594d">AddPropagator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *propagator)</td></tr>
<tr class="separator:af488df5e9f46c785660564688c91594d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca79ff7f2192b5cd83d224a51485a2c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aca79ff7f2192b5cd83d224a51485a2c0">AddLastPropagator</a> (<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *propagator)</td></tr>
<tr class="separator:aca79ff7f2192b5cd83d224a51485a2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f2f42bb6656121254538958473c08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aab9f2f42bb6656121254538958473c08">TakePropagatorOwnership</a> (std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> &gt; propagator)</td></tr>
<tr class="separator:aab9f2f42bb6656121254538958473c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac37795c9baf36781ceba43e454f9675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aac37795c9baf36781ceba43e454f9675">SetAssignmentPreference</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="optimization_8cc.html#af63dcc00f2023fdf498e0829e6fb8a6b">literal</a>, double <a class="el" href="pack_8cc.html#a4255f714cea26cdd64f6a0ee72d34a8c">weight</a>)</td></tr>
<tr class="separator:aac37795c9baf36781ceba43e454f9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2679b5ab2918a8a684fe57a3357b40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7b2679b5ab2918a8a684fe57a3357b40">AllPreferences</a> () const</td></tr>
<tr class="separator:a7b2679b5ab2918a8a684fe57a3357b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a644e6b565ec38603e6db416136a8b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7a644e6b565ec38603e6db416136a8b1">ResetDecisionHeuristic</a> ()</td></tr>
<tr class="separator:a7a644e6b565ec38603e6db416136a8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77588aee60e0853ef720ae277c8bea5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a77588aee60e0853ef720ae277c8bea5b">ResetDecisionHeuristicAndSetAllPreferences</a> (const std::vector&lt; std::pair&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, double &gt; &gt; &amp;prefs)</td></tr>
<tr class="separator:a77588aee60e0853ef720ae277c8bea5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a32f2b63a24749a0c9f6e34d068f1b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve</a> ()</td></tr>
<tr class="separator:a8a32f2b63a24749a0c9f6e34d068f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11914d218bc38bf85e6e5b5222ede644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a11914d218bc38bf85e6e5b5222ede644">SolveWithTimeLimit</a> (<a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *<a class="el" href="cp__model__solver_8cc.html#aec8af5c1be4e1b6d4330e1161028de21">time_limit</a>)</td></tr>
<tr class="separator:a11914d218bc38bf85e6e5b5222ede644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293e66e868e871cfd23c9d37f5576031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a293e66e868e871cfd23c9d37f5576031">ResetAndSolveWithGivenAssumptions</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;assumptions)</td></tr>
<tr class="separator:a293e66e868e871cfd23c9d37f5576031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2f6d9f21b096f25d8d093c664da6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9a2f6d9f21b096f25d8d093c664da6f4">SetAssumptionLevel</a> (int assumption_level)</td></tr>
<tr class="separator:a9a2f6d9f21b096f25d8d093c664da6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bdb41422d29fd811705a62ffc41877"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ac3bdb41422d29fd811705a62ffc41877">AssumptionLevel</a> () const</td></tr>
<tr class="separator:ac3bdb41422d29fd811705a62ffc41877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bfff1cfcd0f24e7a9ee2b583f594ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a69bfff1cfcd0f24e7a9ee2b583f594ea">GetLastIncompatibleDecisions</a> ()</td></tr>
<tr class="separator:a69bfff1cfcd0f24e7a9ee2b583f594ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9e49e76092a3d062d5736f0214a4f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a6f9e49e76092a3d062d5736f0214a4f4">EnqueueDecisionAndBackjumpOnConflict</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal)</td></tr>
<tr class="separator:a6f9e49e76092a3d062d5736f0214a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d8cce319cec13c09f0089baebf746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a070d8cce319cec13c09f0089baebf746">EnqueueDecisionAndBacktrackOnConflict</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal, int *first_propagation_index=nullptr)</td></tr>
<tr class="separator:a070d8cce319cec13c09f0089baebf746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb06019f0cfb5ac683c556c61d65e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a89fb06019f0cfb5ac683c556c61d65e5">EnqueueDecisionIfNotConflicting</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> true_literal)</td></tr>
<tr class="separator:a89fb06019f0cfb5ac683c556c61d65e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0c2912da716e49c8b5d84108e463d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7c0c2912da716e49c8b5d84108e463d7">Backtrack</a> (int target_level)</td></tr>
<tr class="separator:a7c0c2912da716e49c8b5d84108e463d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b42ef3040a15e72f3f7efa302e32583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a6b42ef3040a15e72f3f7efa302e32583">RestoreSolverToAssumptionLevel</a> ()</td></tr>
<tr class="separator:a6b42ef3040a15e72f3f7efa302e32583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4458486171153c1793c28e2091140d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ad4458486171153c1793c28e2091140d9">FinishPropagation</a> ()</td></tr>
<tr class="separator:ad4458486171153c1793c28e2091140d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dacb6b250d8bb139a1e7c3071892b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ac4dacb6b250d8bb139a1e7c3071892b7">ResetToLevelZero</a> ()</td></tr>
<tr class="separator:ac4dacb6b250d8bb139a1e7c3071892b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552a7e42a1957d95b1cce7078ad29fdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a552a7e42a1957d95b1cce7078ad29fdb">ResetWithGivenAssumptions</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;assumptions)</td></tr>
<tr class="separator:a552a7e42a1957d95b1cce7078ad29fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82300521f18442372bb16efd01463cd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a82300521f18442372bb16efd01463cd9">ReapplyAssumptionsIfNeeded</a> ()</td></tr>
<tr class="separator:a82300521f18442372bb16efd01463cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c109f0e0a118d4d916aba5a54e84d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a402c109f0e0a118d4d916aba5a54e84d">UnsatStatus</a> () const</td></tr>
<tr class="separator:a402c109f0e0a118d4d916aba5a54e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0174fd7221118d81a925d32aaed1cc79"><td class="memTemplParams" colspan="2">template&lt;typename Output &gt; </td></tr>
<tr class="memitem:a0174fd7221118d81a925d32aaed1cc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a0174fd7221118d81a925d32aaed1cc79">ExtractClauses</a> (Output *out)</td></tr>
<tr class="separator:a0174fd7221118d81a925d32aaed1cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f805974da54c343a094962a8d709db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a6f805974da54c343a094962a8d709db3">TrackBinaryClauses</a> (bool <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:a6f805974da54c343a094962a8d709db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa84a40c6ea30a7149aab5b09b43e18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a1fa84a40c6ea30a7149aab5b09b43e18">AddBinaryClauses</a> (const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt; &amp;<a class="el" href="cp__model__solver_8cc.html#a21696c8707868a3d522d1bee261f4185">clauses</a>)</td></tr>
<tr class="separator:a1fa84a40c6ea30a7149aab5b09b43e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3087db3ee9aceca1a27369dff0d5ad61"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a3087db3ee9aceca1a27369dff0d5ad61">NewlyAddedBinaryClauses</a> ()</td></tr>
<tr class="separator:a3087db3ee9aceca1a27369dff0d5ad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bd5458903038cd72064671d10c620d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a82bd5458903038cd72064671d10c620d">ClearNewlyAddedBinaryClauses</a> ()</td></tr>
<tr class="separator:a82bd5458903038cd72064671d10c620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad230258762a2fc372ece535a4e3b9f06"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Decision.html">Decision</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ad230258762a2fc372ece535a4e3b9f06">Decisions</a> () const</td></tr>
<tr class="separator:ad230258762a2fc372ece535a4e3b9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1b11c4b39c9745a264638dc0381914"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel</a> () const</td></tr>
<tr class="separator:abf1b11c4b39c9745a264638dc0381914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf67ece21b8195e56e577932269c130b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#adf67ece21b8195e56e577932269c130b">LiteralTrail</a> () const</td></tr>
<tr class="separator:adf67ece21b8195e56e577932269c130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae9d5e427bdd44a6e581f3a06b7f703"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#abae9d5e427bdd44a6e581f3a06b7f703">Assignment</a> () const</td></tr>
<tr class="separator:abae9d5e427bdd44a6e581f3a06b7f703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efb093cfaf3450b6816fab8c0759e19"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a5efb093cfaf3450b6816fab8c0759e19">num_branches</a> () const</td></tr>
<tr class="memdesc:a5efb093cfaf3450b6816fab8c0759e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some statistics since the creation of the solver.  <br /></td></tr>
<tr class="separator:a5efb093cfaf3450b6816fab8c0759e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b31c338ba4d070b8880539bc9a09eb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a75b31c338ba4d070b8880539bc9a09eb">num_failures</a> () const</td></tr>
<tr class="separator:a75b31c338ba4d070b8880539bc9a09eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dd736a0e48550f444665f4c9848be3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a82dd736a0e48550f444665f4c9848be3">num_propagations</a> () const</td></tr>
<tr class="separator:a82dd736a0e48550f444665f4c9848be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8e763148cc7f4b31e2efc3e3126cd4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9f8e763148cc7f4b31e2efc3e3126cd4">num_restarts</a> () const</td></tr>
<tr class="separator:a9f8e763148cc7f4b31e2efc3e3126cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac88207c0228d80d19751186955240f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a1ac88207c0228d80d19751186955240f">deterministic_time</a> () const</td></tr>
<tr class="separator:a1ac88207c0228d80d19751186955240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7db73938c1101728cb3c7ed61dfd72e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ac7db73938c1101728cb3c7ed61dfd72e">SaveDebugAssignment</a> ()</td></tr>
<tr class="separator:ac7db73938c1101728cb3c7ed61dfd72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65164219036d2b3a2155164145af413d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a65164219036d2b3a2155164145af413d">ProblemIsPureSat</a> () const</td></tr>
<tr class="memdesc:a65164219036d2b3a2155164145af413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the loaded problem only contains clauses.  <br /></td></tr>
<tr class="separator:a65164219036d2b3a2155164145af413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1825b361bdf46ac399ff264a402b6c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a1825b361bdf46ac399ff264a402b6c40">SetDratProofHandler</a> (<a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *drat_proof_handler)</td></tr>
<tr class="separator:a1825b361bdf46ac399ff264a402b6c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61260f1f86d76b6605c82d69ad96186d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a61260f1f86d76b6605c82d69ad96186d">NotifyThatModelIsUnsat</a> ()</td></tr>
<tr class="separator:a61260f1f86d76b6605c82d69ad96186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9ba983bd9f911d0605f7615ebf3725"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8b9ba983bd9f911d0605f7615ebf3725">AddClauseDuringSearch</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals)</td></tr>
<tr class="separator:a8b9ba983bd9f911d0605f7615ebf3725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9188c70cc1096900a623a26319a1d4b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">Propagate</a> ()</td></tr>
<tr class="separator:a9188c70cc1096900a623a26319a1d4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78df81717c2221f4624bcfc484826afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a78df81717c2221f4624bcfc484826afe">MinimizeSomeClauses</a> (int decisions_budget)</td></tr>
<tr class="separator:a78df81717c2221f4624bcfc484826afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc482ffe0012a7f67f7a5a65b84278c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#acdc482ffe0012a7f67f7a5a65b84278c">SetShareBinaryClauseCallback</a> (const std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>)&gt; &amp;shared_binary_clauses_callback)</td></tr>
<tr class="memdesc:acdc482ffe0012a7f67f7a5a65b84278c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the export function to the shared clauses manager.  <br /></td></tr>
<tr class="separator:acdc482ffe0012a7f67f7a5a65b84278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19f21598928ec3f2515db06515cb7c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ab19f21598928ec3f2515db06515cb7c9">AdvanceDeterministicTime</a> (<a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *limit)</td></tr>
<tr class="separator:ab19f21598928ec3f2515db06515cb7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e24044eed32b555fd94b40b8f6423c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a52e24044eed32b555fd94b40b8f6423c">ProcessNewlyFixedVariables</a> ()</td></tr>
<tr class="memdesc:a52e24044eed32b555fd94b40b8f6423c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the problem when new variables are assigned at level 0.  <br /></td></tr>
<tr class="separator:a52e24044eed32b555fd94b40b8f6423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14377fec21151aa9faaa12d861fe8dc"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#af14377fec21151aa9faaa12d861fe8dc">NumFixedVariables</a> () const</td></tr>
<tr class="separator:af14377fec21151aa9faaa12d861fe8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main SAT solver. It currently implements the CDCL algorithm. See <a href="http://en.wikipedia.org/wiki/Conflict_Driven_Clause_Learning">http://en.wikipedia.org/wiki/Conflict_Driven_Clause_Learning</a> </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00062">62</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8022922b9cf102d6697157b3f2ccc352" name="a8022922b9cf102d6697157b3f2ccc352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8022922b9cf102d6697157b3f2ccc352">&#9670;&#160;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">operations_research::sat::SatSolver::Status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the problem and returns its status. An empty problem is considered to be SAT.</p>
<dl class="section note"><dt>Note</dt><dd>the conflict limit applies only to this function and starts counting from the time it is called.</dd></dl>
<p>This will restart from the current solver configuration. If a previous call to <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a> was interrupted by a conflict or time limit, calling this again will resume the search exactly as it would have continued.</p>
<dl class="section note"><dt>Note</dt><dd>this will use the <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> singleton, so the time limit will be counted since the last time <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> was reset, not from the start of this function. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352adc08829ed7a57463ccf45d0a6dd34cb2" name="a8022922b9cf102d6697157b3f2ccc352adc08829ed7a57463ccf45d0a6dd34cb2"></a>ASSUMPTIONS_UNSAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352ae81c4874f5f1b05aeef8b9781e26b1ee" name="a8022922b9cf102d6697157b3f2ccc352ae81c4874f5f1b05aeef8b9781e26b1ee"></a>INFEASIBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352a7a6b4bc49d7cd2f0e797b2223c1e605b" name="a8022922b9cf102d6697157b3f2ccc352a7a6b4bc49d7cd2f0e797b2223c1e605b"></a>FEASIBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8022922b9cf102d6697157b3f2ccc352a71fe77dfe8a6957ad06c36275d7fcd62" name="a8022922b9cf102d6697157b3f2ccc352a71fe77dfe8a6957ad06c36275d7fcd62"></a>LIMIT_REACHED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00188">188</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af34c6a454416c6dcb2e6310e510e976e" name="af34c6a454416c6dcb2e6310e510e976e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34c6a454416c6dcb2e6310e510e976e">&#9670;&#160;</a></span>SatSolver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SatSolver::SatSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00057">57</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ac0abab4a2ce453f91aa0afb88db55433" name="ac0abab4a2ce453f91aa0afb88db55433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0abab4a2ce453f91aa0afb88db55433">&#9670;&#160;</a></span>SatSolver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SatSolver::SatSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00063">63</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a3483e8be8a322018b9ff33f9d1591fb0" name="a3483e8be8a322018b9ff33f9d1591fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3483e8be8a322018b9ff33f9d1591fb0">&#9670;&#160;</a></span>~SatSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::SatSolver::~SatSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00084">84</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6cb2ddde70037269943ce72ac1d5b163" name="a6cb2ddde70037269943ce72ac1d5b163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb2ddde70037269943ce72ac1d5b163">&#9670;&#160;</a></span>AddBinaryClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddBinaryClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a2613df5393b4e2285789856150543b70">AddProblemClause()</a> below, but for small clauses. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00190">190</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a1fa84a40c6ea30a7149aab5b09b43e18" name="a1fa84a40c6ea30a7149aab5b09b43e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa84a40c6ea30a7149aab5b09b43e18">&#9670;&#160;</a></span>AddBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddBinaryClauses </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clauses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01032">1032</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a8b9ba983bd9f911d0605f7615ebf3725" name="a8b9ba983bd9f911d0605f7615ebf3725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9ba983bd9f911d0605f7615ebf3725">&#9670;&#160;</a></span>AddClauseDuringSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddClauseDuringSearch </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td>
          <td class="paramname"><em>literals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a clause at any level of the tree and propagate any new deductions. Returns false if the model becomes UNSAT. Important: We currently do not support adding a clause that is already falsified at a positive decision level. Doing that will cause a check fail.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001995">Todo:</a></b></dt><dd>(user): Backjump and propagate on a falsified clause? this is currently not needed. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001955">Todo:</a></b></dt><dd>(user): We generate in some corner cases clauses with literals[0].Variable() == literals[1].Variable(). Avoid doing that and adding such binary clauses to the graph? </dd></dl>
<p>Tricky: Even if nothing new is propagated, calling <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> might, via the LP, deduce new things. This is problematic because some code assumes that when we create newly associated literals, nothing else changes.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00158">158</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aca79ff7f2192b5cd83d224a51485a2c0" name="aca79ff7f2192b5cd83d224a51485a2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca79ff7f2192b5cd83d224a51485a2c0">&#9670;&#160;</a></span>AddLastPropagator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::AddLastPropagator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *&#160;</td>
          <td class="paramname"><em>propagator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00456">456</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a098038f8e0409a8243ff3f7eafb517f8" name="a098038f8e0409a8243ff3f7eafb517f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098038f8e0409a8243ff3f7eafb517f8">&#9670;&#160;</a></span>AddLinearConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1LiteralWithCoeff.html">LiteralWithCoeff</a> &gt; *&#160;</td>
          <td class="paramname"><em>cst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a pseudo-Boolean constraint to the problem. Returns false if the problem is detected to be UNSAT. If the constraint is always true, this detects it and does nothing.</p>
<p>Note(user): There is an optimization if the same constraint is added consecutively (even if the bounds are different). This is particularly useful for an optimization problem when we want to constrain the objective of the problem more and more. Just re-adding such constraint is relatively efficient.</p>
<p>OVERFLOW: The sum of the absolute value of all the coefficients in the constraint must not overflow. This is currently CHECKed(). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo001991">Todo:</a></b></dt><dd>(user): Instead of failing, implement an error handling code. </dd></dl>
<p>We need to "re-canonicalize" in case some literal were fixed while we processed one direction.</p>
<p>We transform the constraint into an upper-bounded one.</p>
<p>Tricky: The PropagationIsDone() condition shouldn't change anything for a pure SAT problem, however in the CP-SAT context, calling <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> can tigger computation (like the LP) even if no domain changed since the last call. We do not want to do that.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00354">354</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a2613df5393b4e2285789856150543b70" name="a2613df5393b4e2285789856150543b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2613df5393b4e2285789856150543b70">&#9670;&#160;</a></span>AddProblemClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddProblemClause </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_safe</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a clause to the problem. Returns false if the problem is detected to be UNSAT. If is_safe is false, we will do some basic presolving like removing duplicate literals.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001990">Todo:</a></b></dt><dd>(user): Rename this to AddClause(), also get rid of the specialized <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aa16f8b671ca15b9f82ee69236880c176">AddUnitClause()</a>, <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a6cb2ddde70037269943ce72ac1d5b163" title="Same as AddProblemClause() below, but for small clauses.">AddBinaryClause()</a> and <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aa5e4956383538b097302c88080569a74">AddTernaryClause()</a> since they just end up calling this? </dd></dl>
<p>Note(user): we assume there is no duplicate literals in the clauses added here if is_safe is true. Most of the code works, but some advanced algo might be wrong/suboptimal if this is the case. So even when presolve is off we need some "cleanup" to enforce this invariant. Alternatively we could have robut algo in all the stack, but that seems a worse design. </p>
<p>Filter already assigned literals.</p>
<p>Tricky: The PropagationIsDone() condition shouldn't change anything for a pure SAT problem, however in the CP-SAT context, calling <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> can tigger computation (like the LP) even if no domain changed since the last call. We do not want to do that.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00203">203</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="af488df5e9f46c785660564688c91594d" name="af488df5e9f46c785660564688c91594d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af488df5e9f46c785660564688c91594d">&#9670;&#160;</a></span>AddPropagator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::AddPropagator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> *&#160;</td>
          <td class="paramname"><em>propagator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds and registers the given propagator with the sat solver. Note that during propagation, they will be called in the order they were added. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00448">448</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aa5e4956383538b097302c88080569a74" name="aa5e4956383538b097302c88080569a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e4956383538b097302c88080569a74">&#9670;&#160;</a></span>AddTernaryClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddTernaryClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00194">194</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aa16f8b671ca15b9f82ee69236880c176" name="aa16f8b671ca15b9f82ee69236880c176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16f8b671ca15b9f82ee69236880c176">&#9670;&#160;</a></span>AddUnitClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::AddUnitClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>true_literal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fixes a variable so that the given literal is true. This can be used to solve a subproblem where some variables are fixed. Note that it is more efficient to add such unit clause before all the others. Returns false if the problem is detected to be UNSAT. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00186">186</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ab19f21598928ec3f2515db06515cb7c9" name="ab19f21598928ec3f2515db06515cb7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19f21598928ec3f2515db06515cb7c9">&#9670;&#160;</a></span>AdvanceDeterministicTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::AdvanceDeterministicTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the given time limit with all the deterministic time that was elapsed since last call. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00454">454</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a7b2679b5ab2918a8a684fe57a3357b40" name="a7b2679b5ab2918a8a684fe57a3357b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2679b5ab2918a8a684fe57a3357b40">&#9670;&#160;</a></span>AllPreferences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, double &gt; &gt; operations_research::sat::SatSolver::AllPreferences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00161">161</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="abae9d5e427bdd44a6e581f3a06b7f703" name="abae9d5e427bdd44a6e581f3a06b7f703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae9d5e427bdd44a6e581f3a06b7f703">&#9670;&#160;</a></span>Assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1sat_1_1VariablesAssignment.html">VariablesAssignment</a> &amp; operations_research::sat::SatSolver::Assignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00388">388</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ac3bdb41422d29fd811705a62ffc41877" name="ac3bdb41422d29fd811705a62ffc41877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bdb41422d29fd811705a62ffc41877">&#9670;&#160;</a></span>AssumptionLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::AssumptionLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current assumption level. Note that if a solve was done since the last <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9a2f6d9f21b096f25d8d093c664da6f4">SetAssumptionLevel()</a>, then the returned level may be lower than the one that was set. This is because some assumptions may now be consequences of others before them due to the newly learned clauses. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00228">228</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a7c0c2912da716e49c8b5d84108e463d7" name="a7c0c2912da716e49c8b5d84108e463d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0c2912da716e49c8b5d84108e463d7">&#9670;&#160;</a></span>Backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::Backtrack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores the state to the given target decision level. The decision at that level and all its propagation will not be undone. But all the trail after this will be cleared. Calling this with 0 will revert all the decisions and only the fixed variables will be left on the trail. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001963">Todo:</a></b></dt><dd>(user): The backtrack method should not be called when the model is unsat. Add a DCHECK to prevent that, but before fix the <a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html">bop::BopOptimizerBase</a> architecture. </dd></dl>
<p>Do nothing if the <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel()</a> is already correct. This is needed, otherwise target_trail_index below will remain at zero and that will cause some problems. Note that we could forbid a user to call <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7c0c2912da716e49c8b5d84108e463d7">Backtrack()</a> with the current level, but that is annoying when you just want to reset the solver with Backtrack(0).</p>
<p>Any backtrack to the root from a positive one is counted as a restart.</p>
<p>Per the <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints.">SatPropagator</a> interface, this is needed before calling Untrail.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01003">1003</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a82bd5458903038cd72064671d10c620d" name="a82bd5458903038cd72064671d10c620d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bd5458903038cd72064671d10c620d">&#9670;&#160;</a></span>ClearNewlyAddedBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ClearNewlyAddedBinaryClauses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01046">1046</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="abf1b11c4b39c9745a264638dc0381914" name="abf1b11c4b39c9745a264638dc0381914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1b11c4b39c9745a264638dc0381914">&#9670;&#160;</a></span>CurrentDecisionLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::CurrentDecisionLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00386">386</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ad230258762a2fc372ece535a4e3b9f06" name="ad230258762a2fc372ece535a4e3b9f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad230258762a2fc372ece535a4e3b9f06">&#9670;&#160;</a></span>Decisions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1SatSolver_1_1Decision.html">Decision</a> &gt; &amp; operations_research::sat::SatSolver::Decisions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>the <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ad230258762a2fc372ece535a4e3b9f06">Decisions()</a> vector is always of size <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ada8b7f7a38df9c1f3111c5fc03eb79fa">NumVariables()</a>, and that only the first <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel()</a> entries have a meaning. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00385">385</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a1ac88207c0228d80d19751186955240f" name="a1ac88207c0228d80d19751186955240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac88207c0228d80d19751186955240f">&#9670;&#160;</a></span>deterministic_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::sat::SatSolver::deterministic_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A deterministic number that should be correlated with the time spent in the <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a> function. The order of magnitude should be close to the time in seconds. </p>
<p>Each of these counters mesure really basic operations. The weight are just an estimate of the operation complexity. Note that these counters are never reset to zero once a <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a> is created.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001954">Todo:</a></b></dt><dd>(user): Find a better procedure to fix the weight than just educated guess. </dd></dl>
<p>Here there is a factor 2 because of the untrail.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00114">114</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a6f9e49e76092a3d062d5736f0214a4f4" name="a6f9e49e76092a3d062d5736f0214a4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9e49e76092a3d062d5736f0214a4f4">&#9670;&#160;</a></span>EnqueueDecisionAndBackjumpOnConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::EnqueueDecisionAndBackjumpOnConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>true_literal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. The next 3 functions allow to drive the search from outside the solver. Takes a new decision (the given true_literal must be unassigned) and propagates it. Returns the trail index of the first newly propagated literal. If there is a conflict and the problem is detected to be UNSAT, returns kUnsatTrailIndex.</p>
<p>Important: In the presence of assumptions, this also returns kUnsatTrailIndex on ASSUMPTION_UNSAT. One can know the difference with <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a84e27e6cb848b3176ab5680292d116a8">IsModelUnsat()</a>.</p>
<p>A client can determine if there is a conflict by checking if the <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#abf1b11c4b39c9745a264638dc0381914">CurrentDecisionLevel()</a> was increased by 1 or not.</p>
<p>If there is a conflict, the given decision is not applied and:</p><ul>
<li>The conflict is learned.</li>
<li>The decisions are potentially backtracked to the first decision that propagates more variables because of the newly learned conflict.</li>
<li>The returned value is equal to trail_-&gt;Index() after this backtracking and just before the new propagation (due to the conflict) which is also performed by this function. </li>
</ul>
<p>We should never enqueue before the assumptions_.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00547">547</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a070d8cce319cec13c09f0089baebf746" name="a070d8cce319cec13c09f0089baebf746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d8cce319cec13c09f0089baebf746">&#9670;&#160;</a></span>EnqueueDecisionAndBacktrackOnConflict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::EnqueueDecisionAndBacktrackOnConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>true_literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>first_propagation_index</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function starts by calling <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a6f9e49e76092a3d062d5736f0214a4f4">EnqueueDecisionAndBackjumpOnConflict()</a>. If there is no conflict, it stops there. Otherwise, it tries to reapply all the decisions that were backjumped over until the first one that can't be taken because it is incompatible. Note that during this process, more conflicts may happen and the trail may be backtracked even further.</p>
<p>In any case, the new decisions stack will be the largest valid "prefix" of the old stack. Note that decisions that are now consequence of the ones before them will no longer be decisions.</p>
<p>Returns INFEASIBLE if the model was proven infeasible, ASSUMPTION_UNSAT if the current decision and the one we are trying to take are not compatible together and FEASIBLE if all decisions are taken.</p>
<p>Note(user): This function can be called with an already assigned literal. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00974">974</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a89fb06019f0cfb5ac683c556c61d65e5" name="a89fb06019f0cfb5ac683c556c61d65e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fb06019f0cfb5ac683c556c61d65e5">&#9670;&#160;</a></span>EnqueueDecisionIfNotConflicting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::EnqueueDecisionIfNotConflicting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>true_literal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to enqueue the given decision and performs the propagation. Returns true if no conflict occurred. Otherwise, returns false and restores the solver to the state just before this was called.</p>
<p>Note(user): With this function, the solver doesn't learn anything. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00988">988</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a0174fd7221118d81a925d32aaed1cc79" name="a0174fd7221118d81a925d32aaed1cc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0174fd7221118d81a925d32aaed1cc79">&#9670;&#160;</a></span>ExtractClauses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ExtractClauses </td>
          <td>(</td>
          <td class="paramtype">Output *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract the current problem clauses. The Output type must support the two functions:</p><ul>
<li>void <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a6cb2ddde70037269943ce72ac1d5b163" title="Same as AddProblemClause() below, but for small clauses.">AddBinaryClause(Literal a, Literal b)</a>;</li>
<li>void AddClause(absl::Span&lt;const Literal&gt; clause);</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001994">Todo:</a></b></dt><dd>(user): also copy the removable clauses? </dd></dl>
<p>It is important to process the newly fixed variables, so they are not present in the clauses we export.</p>
<p>Note(user): Putting the binary clauses first help because the presolver currently process the clauses in order.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00346">346</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ad4458486171153c1793c28e2091140d9" name="ad4458486171153c1793c28e2091140d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4458486171153c1793c28e2091140d9">&#9670;&#160;</a></span>FinishPropagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::FinishPropagation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. Finish the progation if it was interrupted. Note that this might run into conflict and will propagate again until a fixed point is reached or the model was proven UNSAT. Returns <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a84e27e6cb848b3176ab5680292d116a8">IsModelUnsat()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00572">572</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a69bfff1cfcd0f24e7a9ee2b583f594ea" name="a69bfff1cfcd0f24e7a9ee2b583f594ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bfff1cfcd0f24e7a9ee2b583f594ea">&#9670;&#160;</a></span>GetLastIncompatibleDecisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::SatSolver::GetLastIncompatibleDecisions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be called just after SolveWithAssumptions() returned ASSUMPTION_UNSAT or after <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a070d8cce319cec13c09f0089baebf746">EnqueueDecisionAndBacktrackOnConflict()</a> leaded to a conflict. It returns a subsequence (in the correct order) of the previously enqueued decisions that cannot be taken together without making the problem UNSAT. </p>
<p>literal at true in the conflict must be decision/assumptions that could not be taken.</p>
<p>We just expand the conflict until we only have decisions.</p>
<p>Find next marked literal to expand from the trail.</p>
<p>Marks all the literals of its reason.</p>
<p>We reverse the assumptions so they are in the same order as the one in which the decision were made.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01385">1385</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a84e27e6cb848b3176ab5680292d116a8" name="a84e27e6cb848b3176ab5680292d116a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e27e6cb848b3176ab5680292d116a8">&#9670;&#160;</a></span>IsModelUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::IsModelUnsat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001992">Todo:</a></b></dt><dd>(user): remove this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00144">144</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="adf67ece21b8195e56e577932269c130b" name="adf67ece21b8195e56e577932269c130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf67ece21b8195e56e577932269c130b">&#9670;&#160;</a></span>LiteralTrail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp; operations_research::sat::SatSolver::LiteralTrail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00387">387</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a78df81717c2221f4624bcfc484826afe" name="a78df81717c2221f4624bcfc484826afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78df81717c2221f4624bcfc484826afe">&#9670;&#160;</a></span>MinimizeSomeClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::MinimizeSomeClauses </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decisions_budget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This must be called at level zero. It will spend the given num decision and use propagation to try to minimize some clauses from the database. </p>
<p>Tricky: we don't want TryToMinimizeClause() to delete to_minimize while we are processing it.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01360">1360</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a5420a6d871314779beeac0c074241c1a" name="a5420a6d871314779beeac0c074241c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5420a6d871314779beeac0c074241c1a">&#9670;&#160;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> * operations_research::sat::SatSolver::model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001988">Todo:</a></b></dt><dd>(user): Remove. This is temporary for accessing the model deep within some old code that didn't use the <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00070">70</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a7aebdd03bb49157e1de8516e1dbfc4ef" name="a7aebdd03bb49157e1de8516e1dbfc4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebdd03bb49157e1de8516e1dbfc4ef">&#9670;&#160;</a></span>ModelIsUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ModelIsUnsat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the model is UNSAT. Note that currently the status is "sticky" and once this happen, nothing else can be done with the solver.</p>
<p>Thanks to this function, a client can safely ignore the return value of any Add*() functions. If one of them return false, then <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7aebdd03bb49157e1de8516e1dbfc4ef">ModelIsUnsat()</a> will return true. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00141">141</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a52bb790559c188628c9e93530235a223" name="a52bb790559c188628c9e93530235a223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bb790559c188628c9e93530235a223">&#9670;&#160;</a></span>NewBooleanVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BooleanVariable operations_research::sat::SatSolver::NewBooleanVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We need to be able to encode the variable as a literal.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00088">88</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a3087db3ee9aceca1a27369dff0d5ad61" name="a3087db3ee9aceca1a27369dff0d5ad61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3087db3ee9aceca1a27369dff0d5ad61">&#9670;&#160;</a></span>NewlyAddedBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1BinaryClause.html">BinaryClause</a> &gt; &amp; operations_research::sat::SatSolver::NewlyAddedBinaryClauses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01042">1042</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a61260f1f86d76b6605c82d69ad96186d" name="a61260f1f86d76b6605c82d69ad96186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61260f1f86d76b6605c82d69ad96186d">&#9670;&#160;</a></span>NotifyThatModelIsUnsat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::NotifyThatModelIsUnsat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is here to deal with the case where a SAT/CP model is found to be trivially UNSAT while the user is constructing the model. Instead of having to test the status of all the lines adding a constraint, one can just check if the solver is not UNSAT once the model is constructed. Note that we usually log a warning on the first constraint that caused a "trival" unsatisfiability. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00427">427</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a5efb093cfaf3450b6816fab8c0759e19" name="a5efb093cfaf3450b6816fab8c0759e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efb093cfaf3450b6816fab8c0759e19">&#9670;&#160;</a></span>num_branches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_branches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some statistics since the creation of the solver. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00104">104</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a75b31c338ba4d070b8880539bc9a09eb" name="a75b31c338ba4d070b8880539bc9a09eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b31c338ba4d070b8880539bc9a09eb">&#9670;&#160;</a></span>num_failures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_failures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00106">106</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a82dd736a0e48550f444665f4c9848be3" name="a82dd736a0e48550f444665f4c9848be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dd736a0e48550f444665f4c9848be3">&#9670;&#160;</a></span>num_propagations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_propagations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00108">108</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a9f8e763148cc7f4b31e2efc3e3126cd4" name="a9f8e763148cc7f4b31e2efc3e3126cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8e763148cc7f4b31e2efc3e3126cd4">&#9670;&#160;</a></span>num_restarts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::num_restarts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>we count the number of backtrack to level zero from a positive level. Those can corresponds to actual restarts, or conflicts that learn unit clauses or any other reason that trigger such backtrack. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00112">112</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="af14377fec21151aa9faaa12d861fe8dc" name="af14377fec21151aa9faaa12d861fe8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14377fec21151aa9faaa12d861fe8dc">&#9670;&#160;</a></span>NumFixedVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::SatSolver::NumFixedVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00464">464</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ada8b7f7a38df9c1f3111c5fc03eb79fa" name="ada8b7f7a38df9c1f3111c5fc03eb79fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8b7f7a38df9c1f3111c5fc03eb79fa">&#9670;&#160;</a></span>NumVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::SatSolver::NumVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00087">87</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a8904d8354eb343b3d0cc598a02f4140c" name="a8904d8354eb343b3d0cc598a02f4140c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904d8354eb343b3d0cc598a02f4140c">&#9670;&#160;</a></span>parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SatParameters &amp; operations_research::sat::SatSolver::parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00132">132</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a65164219036d2b3a2155164145af413d" name="a65164219036d2b3a2155164145af413d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65164219036d2b3a2155164145af413d">&#9670;&#160;</a></span>ProblemIsPureSat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ProblemIsPureSat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the loaded problem only contains clauses. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00413">413</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a52e24044eed32b555fd94b40b8f6423c" name="a52e24044eed32b555fd94b40b8f6423c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e24044eed32b555fd94b40b8f6423c">&#9670;&#160;</a></span>ProcessNewlyFixedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ProcessNewlyFixedVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the problem when new variables are assigned at level 0. </p>
<p>We remove the clauses that are always true and the fixed literals from the others. Note that none of the clause should be all false because we should have detected a conflict before this is called.</p>
<p>The clause is always true, detach it.</p>
<p>This clause is now a binary clause, treat it separately. Note that it is safe to do that because this clause can't be used as a reason since we are at level zero and the clause is not satisfied.</p>
<dl class="section note"><dt>Note</dt><dd>we will only delete the clauses during the next database cleanup.</dd></dl>
<p>We also clean the binary implication graph. Tricky: If we added the first binary clauses above, the binary graph is not in "propagated" state as it should be, so we call <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> so all the checks are happy.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01669">1669</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a9188c70cc1096900a623a26319a1d4b8" name="a9188c70cc1096900a623a26319a1d4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9188c70cc1096900a623a26319a1d4b8">&#9670;&#160;</a></span>Propagate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::Propagate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs propagation of the recently enqueued elements. Mainly visible for testing.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001972">Todo:</a></b></dt><dd>(user): Support propagating only the "first" propagators. That can be useful for probing/in-processing, so we can control if we do only the SAT part or the full integer part... </dd></dl>
<p>Because we might potentially iterate often on this list below, we remove empty propagators.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001973">Todo:</a></b></dt><dd>(user): This might not really be needed. </dd></dl>
<p>The idea here is to abort the inspection as soon as at least one propagation occurs so we can loop over and test again the highest priority constraint types using the new information.</p>
<dl class="section note"><dt>Note</dt><dd>the first propagators_ should be the binary_implication_graph_ and that its <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">Propagate()</a> functions will not abort on the first propagation to be slightly more efficient.</dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01741">1741</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a82300521f18442372bb16efd01463cd9" name="a82300521f18442372bb16efd01463cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82300521f18442372bb16efd01463cd9">&#9670;&#160;</a></span>ReapplyAssumptionsIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ReapplyAssumptionsIfNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. If the decision level is smaller than the assumption level, this will try to reapply all assumptions. Returns true if this was doable, otherwise returns false in which case the model is either UNSAT or ASSUMPTION_UNSAT.</p>
<dl class="section note"><dt>Note</dt><dd>we do not count these as "branches" for a reporting purpose. </dd></dl>
<p>When assumptions_ is not empty, the first "decision" actually contains multiple one, and we should never use its literal.</p>
<p>We enqueue all assumptions at once at decision level 1.</p>
<p>See <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a69bfff1cfcd0f24e7a9ee2b583f594ea">GetLastIncompatibleDecisions()</a>.</p>
<p>This is needed to avoid an empty level that cause some CHECK fail.</p>
<p>Corner case: all assumptions are fixed at level zero, we ignore them.</p>
<p>Now that everything is enqueued, we propagate.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00615">615</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a293e66e868e871cfd23c9d37f5576031" name="a293e66e868e871cfd23c9d37f5576031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293e66e868e871cfd23c9d37f5576031">&#9670;&#160;</a></span>ResetAndSolveWithGivenAssumptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::ResetAndSolveWithGivenAssumptions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>assumptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple interface to solve a problem under the given assumptions. This simply ask the solver to solve a problem given a set of variables fixed to a given value (the assumptions). Compared to simply calling <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aa16f8b671ca15b9f82ee69236880c176">AddUnitClause()</a> and fixing the variables once and for all, this allow to backtrack over the assumptions and thus exploit the incrementally between subsequent solves.</p>
<p>This function backtrack over all the current decision, tries to enqueue the given assumptions, sets the assumption level accordingly and finally calls <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a>.</p>
<p>If, given these assumptions, the model is UNSAT, this returns the ASSUMPTIONS_UNSAT status. INFEASIBLE is reserved for the case where the model is proven to be unsat without any assumptions.</p>
<p>If ASSUMPTIONS_UNSAT is returned, it is possible to get a "core" of unsat assumptions by calling <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a69bfff1cfcd0f24e7a9ee2b583f594ea">GetLastIncompatibleDecisions()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01057">1057</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a7a644e6b565ec38603e6db416136a8b1" name="a7a644e6b565ec38603e6db416136a8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a644e6b565ec38603e6db416136a8b1">&#9670;&#160;</a></span>ResetDecisionHeuristic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ResetDecisionHeuristic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00164">164</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a77588aee60e0853ef720ae277c8bea5b" name="a77588aee60e0853ef720ae277c8bea5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77588aee60e0853ef720ae277c8bea5b">&#9670;&#160;</a></span>ResetDecisionHeuristicAndSetAllPreferences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::ResetDecisionHeuristicAndSetAllPreferences </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00167">167</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ac4dacb6b250d8bb139a1e7c3071892b7" name="ac4dacb6b250d8bb139a1e7c3071892b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dacb6b250d8bb139a1e7c3071892b7">&#9670;&#160;</a></span>ResetToLevelZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ResetToLevelZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like Backtrack(0) but make sure the propagation is finished and return false if unsat was detected. This also removes any assumptions level. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00590">590</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a552a7e42a1957d95b1cce7078ad29fdb" name="a552a7e42a1957d95b1cce7078ad29fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552a7e42a1957d95b1cce7078ad29fdb">&#9670;&#160;</a></span>ResetWithGivenAssumptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::ResetWithGivenAssumptions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>assumptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the assumptions level and the current solver assumptions. Returns false if the model is UNSAT or ASSUMPTION_UNSAT, true otherwise.</p>
<p>This uses the "new" assumptions handling, where all assumptions are enqueued at once at decision level 1 before we start to propagate. This has many advantages. In particular, because we propagate with the binary implications first, if we ever have assumption =&gt; not(other_assumptions) we are guaranteed to find it and returns a core of size 2.</p>
<p>Paper: "Speeding Up Assumption-Based SAT", Randy Hickey and Fahiem Bacchus <a href="http://www.maxhs.org/docs/Hickey-Bacchus2019_Chapter_SpeedingUpAssumption-BasedSAT.pdf">http://www.maxhs.org/docs/Hickey-Bacchus2019_Chapter_SpeedingUpAssumption-BasedSAT.pdf</a> </p>
<p>For assumptions and core-based search, it is really important to add as many binary clauses as possible. This is because we do not wan to miss any early core of size 2.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00598">598</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a6b42ef3040a15e72f3f7efa302e32583" name="a6b42ef3040a15e72f3f7efa302e32583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b42ef3040a15e72f3f7efa302e32583">&#9670;&#160;</a></span>RestoreSolverToAssumptionLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::SatSolver::RestoreSolverToAssumptionLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. This is meant to restore the solver to a "proper" state after a solve was interrupted due to a limit reached.</p>
<p>Without assumption (i.e. if <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ac3bdb41422d29fd811705a62ffc41877">AssumptionLevel()</a> is 0), this will revert all decisions and make sure that all the fixed literals are propagated. In presence of assumptions, this will either backtrack to the assumption level or re-enqueue any assumptions that may have been backtracked over due to conflits resolution. In both cases, the propagation is finished.</p>
<dl class="section note"><dt>Note</dt><dd>this may prove the model to be UNSAT or ASSUMPTION_UNSAT in which case it will return false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00562">562</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="ac7db73938c1101728cb3c7ed61dfd72e" name="ac7db73938c1101728cb3c7ed61dfd72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7db73938c1101728cb3c7ed61dfd72e">&#9670;&#160;</a></span>SaveDebugAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SaveDebugAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only used for debugging. Save the current assignment in debug_assignment_. The idea is that if we know that a given assignment is satisfiable, then all the learned clauses or PB constraints must be satisfiable by it. In debug mode, and after this is called, all the learned clauses are tested to satisfy this saved assignment. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00485">485</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aac37795c9baf36781ceba43e454f9675" name="aac37795c9baf36781ceba43e454f9675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac37795c9baf36781ceba43e454f9675">&#9670;&#160;</a></span>SetAssignmentPreference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetAssignmentPreference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>literal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrapper around the same functions in <a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html">SatDecisionPolicy</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001993">Todo:</a></b></dt><dd>(user): Clean this up by making clients directly talk to <a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html">SatDecisionPolicy</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00158">158</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a9a2f6d9f21b096f25d8d093c664da6f4" name="a9a2f6d9f21b096f25d8d093c664da6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2f6d9f21b096f25d8d093c664da6f4">&#9670;&#160;</a></span>SetAssumptionLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetAssumptionLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>assumption_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the assumption level. All the decisions below this level will be treated as assumptions by the next <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a>. Note that this may impact some heuristics, like the LBD value of a clause. </p>
<p>New assumption code.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01070">1070</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a1825b361bdf46ac399ff264a402b6c40" name="a1825b361bdf46ac399ff264a402b6c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1825b361bdf46ac399ff264a402b6c40">&#9670;&#160;</a></span>SetDratProofHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetDratProofHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *&#160;</td>
          <td class="paramname"><em>drat_proof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00415">415</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="ae8f40548efeb9f6bde6ff1cd872acc38" name="ae8f40548efeb9f6bde6ff1cd872acc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f40548efeb9f6bde6ff1cd872acc38">&#9670;&#160;</a></span>SetNumVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetNumVariables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the number of variables of the current problem.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001989">Todo:</a></b></dt><dd>(user): Rename to IncreaseNumVariablesTo() until we support removing variables... </dd></dl>
<p>The +1 is a bit tricky, it is because in <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a070d8cce319cec13c09f0089baebf746">EnqueueDecisionAndBacktrackOnConflict()</a> we artificially enqueue the decision before checking if it is not already assigned.</p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00086">86</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="af8c68be5db0ba121693811895e89de8c" name="af8c68be5db0ba121693811895e89de8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c68be5db0ba121693811895e89de8c">&#9670;&#160;</a></span>SetParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetParameters </td>
          <td>(</td>
          <td class="paramtype">const SatParameters &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters management. Note that calling <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#af8c68be5db0ba121693811895e89de8c">SetParameters()</a> will reset the value of many heuristics. For instance:</p><ul>
<li>The restart strategy will be reinitialized.</li>
<li>The random seed and random generator will be reset to the value given in parameters.</li>
<li>The global <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> singleton will be reset and time will be counted from this call. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l00137">137</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="acdc482ffe0012a7f67f7a5a65b84278c" name="acdc482ffe0012a7f67f7a5a65b84278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc482ffe0012a7f67f7a5a65b84278c">&#9670;&#160;</a></span>SetShareBinaryClauseCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::SetShareBinaryClauseCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>shared_binary_clauses_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the export function to the shared clauses manager. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00447">447</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a8a32f2b63a24749a0c9f6e34d068f1b0" name="a8a32f2b63a24749a0c9f6e34d068f1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a32f2b63a24749a0c9f6e34d068f1b0">&#9670;&#160;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::Solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01086">1086</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="a11914d218bc38bf85e6e5b5222ede644" name="a11914d218bc38bf85e6e5b5222ede644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11914d218bc38bf85e6e5b5222ede644">&#9670;&#160;</a></span>SolveWithTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::SatSolver::SolveWithTimeLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> *&#160;</td>
          <td class="paramname"><em>time_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8a32f2b63a24749a0c9f6e34d068f1b0">Solve()</a>, but with a given time limit. Note that this will not update the <a class="el" href="classoperations__research_1_1TimeLimit.html">TimeLimit</a> singleton, but only the passed object instead. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8cc_source.html#l01082">1082</a> of file <a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a>.</p>

</div>
</div>
<a id="aab9f2f42bb6656121254538958473c08" name="aab9f2f42bb6656121254538958473c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9f2f42bb6656121254538958473c08">&#9670;&#160;</a></span>TakePropagatorOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::TakePropagatorOwnership </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> &gt;&#160;</td>
          <td class="paramname"><em>propagator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00150">150</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a6f805974da54c343a094962a8d709db3" name="a6f805974da54c343a094962a8d709db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f805974da54c343a094962a8d709db3">&#9670;&#160;</a></span>TrackBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::SatSolver::TrackBinaryClauses </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Functions to manage the set of learned binary clauses. Only clauses added/learned when TrackBinaryClause() is true are managed. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00371">371</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<a id="a402c109f0e0a118d4d916aba5a54e84d" name="a402c109f0e0a118d4d916aba5a54e84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402c109f0e0a118d4d916aba5a54e84d">&#9670;&#160;</a></span>UnsatStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">Status</a> operations_research::sat::SatSolver::UnsatStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper functions to get the correct status when one of the functions above returns false. </p>

<p class="definition">Definition at line <a class="el" href="sat__solver_8h_source.html#l00335">335</a> of file <a class="el" href="sat__solver_8h_source.html">sat_solver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="sat__solver_8h_source.html">sat_solver.h</a></li>
<li>ortools/sat/<a class="el" href="sat__solver_8cc_source.html">sat_solver.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html">SatSolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
