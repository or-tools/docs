<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::BinaryImplicationGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.5</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classoperations__research_1_1sat_1_1BinaryImplicationGraph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1BinaryImplicationGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::BinaryImplicationGraph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="clause_8h_source.html">clause.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for operations_research::sat::BinaryImplicationGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classoperations__research_1_1sat_1_1BinaryImplicationGraph.png" usemap="#operations_5Fresearch::sat::BinaryImplicationGraph_map" alt=""/>
  <map id="operations_5Fresearch::sat::BinaryImplicationGraph_map" name="operations_5Fresearch::sat::BinaryImplicationGraph_map">
<area href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints." alt="operations_research::sat::SatPropagator" shape="rect" coords="0,0,288,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86ea320dad04144939131e7e12dc8659"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a86ea320dad04144939131e7e12dc8659">BinaryImplicationGraph</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *<a class="el" href="gurobi__interface_8cc.html#a0728f23c9a47655d38e0bf1a2f200bcf">model</a>)</td></tr>
<tr class="separator:a86ea320dad04144939131e7e12dc8659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a61ae210f4a8b23b28c793952d6b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#af70a61ae210f4a8b23b28c793952d6b0">~BinaryImplicationGraph</a> () override</td></tr>
<tr class="separator:af70a61ae210f4a8b23b28c793952d6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a5d176dddf3a86e0b08a9d94195d46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a33a5d176dddf3a86e0b08a9d94195d46">Propagate</a> (<a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> *trail) final</td></tr>
<tr class="memdesc:a33a5d176dddf3a86e0b08a9d94195d46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints.">SatPropagator</a> interface.  <br /></td></tr>
<tr class="separator:a33a5d176dddf3a86e0b08a9d94195d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb76657b65cc3ae9aed6d1e38444a083"><td class="memItemLeft" align="right" valign="top">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#abb76657b65cc3ae9aed6d1e38444a083">Reason</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, int trail_index) const final</td></tr>
<tr class="separator:abb76657b65cc3ae9aed6d1e38444a083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e21fcb1c0adc1356d2d04102fe920af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a1e21fcb1c0adc1356d2d04102fe920af">Resize</a> (int num_variables)</td></tr>
<tr class="memdesc:a1e21fcb1c0adc1356d2d04102fe920af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the data structure.  <br /></td></tr>
<tr class="separator:a1e21fcb1c0adc1356d2d04102fe920af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de69e3bb9c8a73570b3e9e8c290bdab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a6de69e3bb9c8a73570b3e9e8c290bdab">IsEmpty</a> () const final</td></tr>
<tr class="memdesc:a6de69e3bb9c8a73570b3e9e8c290bdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is no constraints in this class.  <br /></td></tr>
<tr class="separator:a6de69e3bb9c8a73570b3e9e8c290bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf7cda61327a0ee3b07971ef7270e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#afdf7cda61327a0ee3b07971ef7270e49">AddBinaryClause</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="separator:afdf7cda61327a0ee3b07971ef7270e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62ebb2b39378e342cbb94a9db055ae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ae62ebb2b39378e342cbb94a9db055ae1">AddImplication</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="separator:ae62ebb2b39378e342cbb94a9db055ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed43b605ef8ae6ef7c66aacae24ced4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a4ed43b605ef8ae6ef7c66aacae24ced4">AddBinaryClauseDuringSearch</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="constraint__solver_2table_8cc.html#acb18315d548212835cd8ed4287e6c0b6">a</a>, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="namespaceoperations__research_1_1sat.html#aea68c208c5e7f0abb9afc90d9188d3d4">b</a>)</td></tr>
<tr class="separator:a4ed43b605ef8ae6ef7c66aacae24ced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18864358e7e3f0d4c9c7cf81e3757de"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ae18864358e7e3f0d4c9c7cf81e3757de">AddAtMostOne</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; at_most_one)</td></tr>
<tr class="separator:ae18864358e7e3f0d4c9c7cf81e3757de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbe67b46860621bfa57c87f5247a385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a3cbe67b46860621bfa57c87f5247a385">MinimizeConflictWithReachability</a> (std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *c)</td></tr>
<tr class="separator:a3cbe67b46860621bfa57c87f5247a385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37e2a622549d733c3bbb8b340f3c473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa37e2a622549d733c3bbb8b340f3c473">MinimizeConflictExperimental</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *c)</td></tr>
<tr class="separator:aa37e2a622549d733c3bbb8b340f3c473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5846564f39bf6ba28ecdced8429d492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab5846564f39bf6ba28ecdced8429d492">MinimizeConflictFirst</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *c, <a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt; BooleanVariable &gt; *marked)</td></tr>
<tr class="separator:ab5846564f39bf6ba28ecdced8429d492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8095f7dce1a603c1b387317c756319e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa8095f7dce1a603c1b387317c756319e">MinimizeConflictFirstWithTransitiveReduction</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *c, absl::BitGenRef random)</td></tr>
<tr class="separator:aa8095f7dce1a603c1b387317c756319e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4e6130c59dffa6ab52a1cff24400a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a7e4e6130c59dffa6ab52a1cff24400a2">RemoveFixedVariables</a> ()</td></tr>
<tr class="separator:a7e4e6130c59dffa6ab52a1cff24400a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80bafd5aaf59cc6c7a67176c6304239"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences</a> (bool log_info=false)</td></tr>
<tr class="separator:aa80bafd5aaf59cc6c7a67176c6304239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030e1fb5dde77ceb0054b7b0d49bd08e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a030e1fb5dde77ceb0054b7b0d49bd08e">IsDag</a> () const</td></tr>
<tr class="separator:a030e1fb5dde77ceb0054b7b0d49bd08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0f1a1d8161f86fabf9305062799a9d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; LiteralIndex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aca0f1a1d8161f86fabf9305062799a9d">ReverseTopologicalOrder</a> () const</td></tr>
<tr class="separator:aca0f1a1d8161f86fabf9305062799a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37d5785578f8515dde315f5f1ec9495"><td class="memItemLeft" align="right" valign="top">const absl::InlinedVector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, 6 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#af37d5785578f8515dde315f5f1ec9495">Implications</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l) const</td></tr>
<tr class="separator:af37d5785578f8515dde315f5f1ec9495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa73e314fd241df54be6f7a0bf97704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a0fa73e314fd241df54be6f7a0bf97704">RepresentativeOf</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l) const</td></tr>
<tr class="separator:a0fa73e314fd241df54be6f7a0bf97704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e88e219614208bf02f4bed078504f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a07e88e219614208bf02f4bed078504f9">ComputeTransitiveReduction</a> (bool log_info=false)</td></tr>
<tr class="separator:a07e88e219614208bf02f4bed078504f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7ae378f427890ed11dfa8efb7c1db7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a4a7ae378f427890ed11dfa8efb7c1db7">TransformIntoMaxCliques</a> (std::vector&lt; std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; *at_most_ones, int64_t max_num_explored_nodes=1e8)</td></tr>
<tr class="separator:a4a7ae378f427890ed11dfa8efb7c1db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4f40564f3adae0c9b904663bf62637"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aba4f40564f3adae0c9b904663bf62637">GenerateAtMostOnesWithLargeWeight</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;literals, const std::vector&lt; double &gt; &amp;lp_values)</td></tr>
<tr class="separator:aba4f40564f3adae0c9b904663bf62637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00903273dd562494127e2bac03942806"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a00903273dd562494127e2bac03942806">num_propagations</a> () const</td></tr>
<tr class="memdesc:a00903273dd562494127e2bac03942806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of literal propagated by this class (including conflicts).  <br /></td></tr>
<tr class="separator:a00903273dd562494127e2bac03942806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92a90e6228d2b1adde4574bf1c51d72"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#af92a90e6228d2b1adde4574bf1c51d72">num_inspections</a> () const</td></tr>
<tr class="memdesc:af92a90e6228d2b1adde4574bf1c51d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of literals inspected by this class during propagation.  <br /></td></tr>
<tr class="separator:af92a90e6228d2b1adde4574bf1c51d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38267138f9430df5773fb280c9fb9efb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a38267138f9430df5773fb280c9fb9efb">num_minimization</a> () const</td></tr>
<tr class="memdesc:a38267138f9430df5773fb280c9fb9efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">MinimizeClause() stats.  <br /></td></tr>
<tr class="separator:a38267138f9430df5773fb280c9fb9efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41556a2163546a7b20d67e8d76fcd2f7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a41556a2163546a7b20d67e8d76fcd2f7">num_literals_removed</a> () const</td></tr>
<tr class="separator:a41556a2163546a7b20d67e8d76fcd2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00e517674b03a53afd9dd16ca625921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa00e517674b03a53afd9dd16ca625921">IsRedundant</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l) const</td></tr>
<tr class="separator:aa00e517674b03a53afd9dd16ca625921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b6b522ac5025d862ebda39ea161d72"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a17b6b522ac5025d862ebda39ea161d72">num_redundant_literals</a> () const</td></tr>
<tr class="separator:a17b6b522ac5025d862ebda39ea161d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8a5b6838659b4a6c42419a2c54cc51"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a6d8a5b6838659b4a6c42419a2c54cc51">num_redundant_implications</a> () const</td></tr>
<tr class="memdesc:a6d8a5b6838659b4a6c42419a2c54cc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of implications removed by transitive reduction.  <br /></td></tr>
<tr class="separator:a6d8a5b6838659b4a6c42419a2c54cc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f885ed25be7c4afbf6952ec5c872cce"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a2f885ed25be7c4afbf6952ec5c872cce">num_implications</a> () const</td></tr>
<tr class="separator:a2f885ed25be7c4afbf6952ec5c872cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b69ac5d57f5b4e6ace24c0407487ab"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ac5b69ac5d57f5b4e6ace24c0407487ab">literal_size</a> () const</td></tr>
<tr class="separator:ac5b69ac5d57f5b4e6ace24c0407487ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2735353cc3b14a2ef6574ad9f52c06b7"><td class="memTemplParams" colspan="2">template&lt;typename Output &gt; </td></tr>
<tr class="memitem:a2735353cc3b14a2ef6574ad9f52c06b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a2735353cc3b14a2ef6574ad9f52c06b7">ExtractAllBinaryClauses</a> (Output *out) const</td></tr>
<tr class="separator:a2735353cc3b14a2ef6574ad9f52c06b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb0838ece7c13cea59b8d02c18c5dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aacb0838ece7c13cea59b8d02c18c5dd6">SetDratProofHandler</a> (<a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *drat_proof_handler)</td></tr>
<tr class="separator:aacb0838ece7c13cea59b8d02c18c5dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3148e8d06e9ddd01e63eff285b9bb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ad3148e8d06e9ddd01e63eff285b9bb9a">ChangeReason</a> (int trail_index, <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> new_reason)</td></tr>
<tr class="separator:ad3148e8d06e9ddd01e63eff285b9bb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab589014979b15460c0cb295527097731"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab589014979b15460c0cb295527097731">DirectImplications</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="optimization_8cc.html#af63dcc00f2023fdf498e0829e6fb8a6b">literal</a>)</td></tr>
<tr class="separator:ab589014979b15460c0cb295527097731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d75a576284b4b229eee6aa8c24e4c45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a7d75a576284b4b229eee6aa8c24e4c45">DirectImplicationsEstimatedSize</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="optimization_8cc.html#af63dcc00f2023fdf498e0829e6fb8a6b">literal</a>) const</td></tr>
<tr class="separator:a7d75a576284b4b229eee6aa8c24e4c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d4a6613825674f5a0e494343c5976f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ad3d4a6613825674f5a0e494343c5976f">FindFailedLiteralAroundVar</a> (BooleanVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>, bool *is_unsat)</td></tr>
<tr class="separator:ad3d4a6613825674f5a0e494343c5976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0180d303834fab315cf079bb442e30"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a5f0180d303834fab315cf079bb442e30">NumImplicationOnVariableRemoval</a> (BooleanVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>)</td></tr>
<tr class="separator:a5f0180d303834fab315cf079bb442e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f13e4a1fd53766aed09fec7a2429e3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a9f13e4a1fd53766aed09fec7a2429e3f">RemoveBooleanVariable</a> (BooleanVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>, std::deque&lt; std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; *postsolve_clauses)</td></tr>
<tr class="memdesc:a9f13e4a1fd53766aed09fec7a2429e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all possible a =&gt; var =&gt; b, add a =&gt; b.  <br /></td></tr>
<tr class="separator:a9f13e4a1fd53766aed09fec7a2429e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca8f89cbb57b5deeec57292257138c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aeca8f89cbb57b5deeec57292257138c3">IsRemoved</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l) const</td></tr>
<tr class="separator:aeca8f89cbb57b5deeec57292257138c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77e8fba04708d2b664eef31e13f9d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ac77e8fba04708d2b664eef31e13f9d22">CleanupAllRemovedVariables</a> ()</td></tr>
<tr class="separator:ac77e8fba04708d2b664eef31e13f9d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe87170234d2d0464fca7dddd5194d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#adfe87170234d2d0464fca7dddd5194d8">ResetWorkDone</a> ()</td></tr>
<tr class="separator:adfe87170234d2d0464fca7dddd5194d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2377211a723ddb7ec81fd5580ba44c65"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a2377211a723ddb7ec81fd5580ba44c65">WorkDone</a> () const</td></tr>
<tr class="separator:a2377211a723ddb7ec81fd5580ba44c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829522e9eed5248e37074f378a48c3f0"><td class="memTemplParams" colspan="2">template&lt;bool use_weight = true&gt; </td></tr>
<tr class="memitem:a829522e9eed5248e37074f378a48c3f0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a829522e9eed5248e37074f378a48c3f0">ExpandAtMostOneWithWeight</a> (const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; at_most_one, const <a class="el" href="classabsl_1_1StrongVector.html">absl::StrongVector</a>&lt; LiteralIndex, bool &gt; &amp;can_be_included, const <a class="el" href="classabsl_1_1StrongVector.html">absl::StrongVector</a>&lt; LiteralIndex, double &gt; &amp;expanded_lp_values)</td></tr>
<tr class="memdesc:a829522e9eed5248e37074f378a48c3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ExpandAtMostOne() but try to maximize the weight in the clique.  <br /></td></tr>
<tr class="separator:a829522e9eed5248e37074f378a48c3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classoperations__research_1_1sat_1_1SatPropagator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">operations_research::sat::SatPropagator</a></td></tr>
<tr class="memitem:a338bfb8cc78f5ac5dd1f69d87a4f57f3 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a338bfb8cc78f5ac5dd1f69d87a4f57f3">SatPropagator</a> (const std::string &amp;<a class="el" href="default__search_8cc.html#ac673bc430bdc3fdaa09f7becf98ef267">name</a>)</td></tr>
<tr class="separator:a338bfb8cc78f5ac5dd1f69d87a4f57f3 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0d293b9e2530dcd849bbbece3b5ab inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#ae1c0d293b9e2530dcd849bbbece3b5ab">~SatPropagator</a> ()</td></tr>
<tr class="separator:ae1c0d293b9e2530dcd849bbbece3b5ab inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5876a992300dcbcf936d11d9b9dd0512 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a5876a992300dcbcf936d11d9b9dd0512">SetPropagatorId</a> (int id)</td></tr>
<tr class="memdesc:a5876a992300dcbcf936d11d9b9dd0512 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets/Gets this propagator unique id.  <br /></td></tr>
<tr class="separator:a5876a992300dcbcf936d11d9b9dd0512 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5afb5d4be1ac4f9c4f0758fb8dc40d inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a2e5afb5d4be1ac4f9c4f0758fb8dc40d">PropagatorId</a> () const</td></tr>
<tr class="separator:a2e5afb5d4be1ac4f9c4f0758fb8dc40d inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8417cfbc49d425aac62ce622b058b018 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a8417cfbc49d425aac62ce622b058b018">Propagate</a> (<a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> *trail)=0</td></tr>
<tr class="separator:a8417cfbc49d425aac62ce622b058b018 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68acada7af835c9c6870ceb876dc2d9c inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a68acada7af835c9c6870ceb876dc2d9c">Untrail</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, int trail_index)</td></tr>
<tr class="separator:a68acada7af835c9c6870ceb876dc2d9c inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb6fb80bf098bfca298973026b7398 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">virtual absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#aebfb6fb80bf098bfca298973026b7398">Reason</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, int trail_index) const</td></tr>
<tr class="separator:aebfb6fb80bf098bfca298973026b7398 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bde4f8c3d7c6326050ac164391bf2a7 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a2bde4f8c3d7c6326050ac164391bf2a7">PropagatePreconditionsAreSatisfied</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail) const</td></tr>
<tr class="separator:a2bde4f8c3d7c6326050ac164391bf2a7 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c40cad4e160b493cb16c9f4373275e inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#ad1c40cad4e160b493cb16c9f4373275e">PropagationIsDone</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail) const</td></tr>
<tr class="memdesc:ad1c40cad4e160b493cb16c9f4373275e inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff all the trail was inspected by this propagator.  <br /></td></tr>
<tr class="separator:ad1c40cad4e160b493cb16c9f4373275e inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab639102372f03758b18523b613ae69e1 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#ab639102372f03758b18523b613ae69e1">IsEmpty</a> () const</td></tr>
<tr class="separator:ab639102372f03758b18523b613ae69e1 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classoperations__research_1_1sat_1_1SatPropagator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">operations_research::sat::SatPropagator</a></td></tr>
<tr class="memitem:a5edc374f55007ef72a87fd7516bad764 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a5edc374f55007ef72a87fd7516bad764">name_</a></td></tr>
<tr class="separator:a5edc374f55007ef72a87fd7516bad764 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6484a3ad51a1f74b403fc21c47055601 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a6484a3ad51a1f74b403fc21c47055601">propagator_id_</a></td></tr>
<tr class="separator:a6484a3ad51a1f74b403fc21c47055601 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5714ef513aadb9a616a215de533b9eb4 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a5714ef513aadb9a616a215de533b9eb4">propagation_trail_index_</a></td></tr>
<tr class="separator:a5714ef513aadb9a616a215de533b9eb4 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Special class to store and propagate clauses of size 2 (i.e. implication). Such clauses are never deleted. Together, they represent the 2-SAT part of the problem. Note that 2-SAT satisfiability is a polynomial problem, but W2SAT (weighted 2-SAT) is NP-complete.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000961">Todo:</a></b></dt><dd>(user): Most of the note below are done, but we currently only applies the reduction before the solve. We should consider doing more in-processing. The code could probably still be improved too.</dd></dl>
<p>Note(user): All the variables in a strongly connected component are equivalent and can be thus merged as one. This is relatively cheap to compute from time to time (linear complexity). We will also get contradiction (a &lt;=&gt; not a) this way. This is done by <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a>.</p>
<p>Note(user): An implication (a =&gt; not a) implies that a is false. I am not sure it is worth detecting that because if the solver assign a to true, it will learn that right away. I don't think we can do it faster.</p>
<p>Note(user): The implication graph can be pruned. This is called the transitive reduction of a graph. For instance If a =&gt; {b,c} and b =&gt; {c}, then there is no need to store a =&gt; {c}. The transitive reduction is unique on an acyclic graph. Computing it will allow for a faster propagation and memory reduction. It is however not cheap. Maybe simple lazy heuristics to remove redundant arcs are better. Note that all the learned clauses we add will never be redundant (but they could introduce cycles). This is done by <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a07e88e219614208bf02f4bed078504f9">ComputeTransitiveReduction()</a>.</p>
<p>Note(user): This class natively support at most one constraints. This is a way to reduced significantly the memory and size of some 2-SAT instances. However, it is not fully exploited for pure SAT problems. See <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a4a7ae378f427890ed11dfa8efb7c1db7">TransformIntoMaxCliques()</a>.</p>
<p>Note(user): Add a preprocessor to remove duplicates in the implication lists. </p><dl class="section note"><dt>Note</dt><dd>all the learned clauses we add will never create duplicates.</dd></dl>
<p>References for most of the above and more:</p><ul>
<li>Brafman RI, "A simplifier for propositional formulas with many binary
  clauses", IEEE Trans Syst Man Cybern B Cybern. 2004 Feb;34(1):52-9. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.4911">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.4911</a></li>
<li>Marijn J. H. Heule, Matti JÃ¤rvisalo, Armin Biere, "Efficient CNF
  Simplification Based on Binary Implication Graphs", Theory and Applications of Satisfiability Testing - SAT 2011, Lecture Notes in Computer Science Volume 6695, 2011, pp 201-215 <a href="http://www.cs.helsinki.fi/u/mjarvisa/papers/heule-jarvisalo-biere.sat11.pdf">http://www.cs.helsinki.fi/u/mjarvisa/papers/heule-jarvisalo-biere.sat11.pdf</a> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00457">457</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a86ea320dad04144939131e7e12dc8659" name="a86ea320dad04144939131e7e12dc8659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ea320dad04144939131e7e12dc8659">&#9670;&#160;</a></span>BinaryImplicationGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::BinaryImplicationGraph::BinaryImplicationGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00459">459</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="af70a61ae210f4a8b23b28c793952d6b0" name="af70a61ae210f4a8b23b28c793952d6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70a61ae210f4a8b23b28c793952d6b0">&#9670;&#160;</a></span>~BinaryImplicationGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::BinaryImplicationGraph::~BinaryImplicationGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00468">468</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae18864358e7e3f0d4c9c7cf81e3757de" name="ae18864358e7e3f0d4c9c7cf81e3757de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18864358e7e3f0d4c9c7cf81e3757de">&#9670;&#160;</a></span>AddAtMostOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::AddAtMostOne </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td>
          <td class="paramname"><em>at_most_one</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An at most one constraint of size n is a compact way to encode n * (n - 1) implications. This must only be called at level zero.</p>
<p>Returns false if this creates a conflict. Currently this can only happens if there is duplicate literal already assigned to true in this constraint.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000963">Todo:</a></b></dt><dd>(user): Our algorithm could generalize easily to at_most_ones + a list of literals that will be false if one of the literal in the amo is at one. It is a way to merge common list of implications. </dd></dl>
<p>Temporarily copy the at_most_one constraint at the end of at_most_one_buffer_. It will be cleaned up and added by CleanUpAndAddAtMostOnes().</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00553">553</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="afdf7cda61327a0ee3b07971ef7270e49" name="afdf7cda61327a0ee3b07971ef7270e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf7cda61327a0ee3b07971ef7270e49">&#9670;&#160;</a></span>AddBinaryClause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::AddBinaryClause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the binary clause (a OR b), which is the same as (not a =&gt; b). </p><dl class="section note"><dt>Note</dt><dd>it is also equivalent to (not b =&gt; a).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000941">Todo:</a></b></dt><dd>(user): Not all of the solver knows about representative literal, do use them here and in <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a4ed43b605ef8ae6ef7c66aacae24ced4">AddBinaryClauseDuringSearch()</a> to maintains invariant? Explore this when we start cleaning our clauses using equivalence during search. We can easily do it for every conflict we learn instead of here. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000942">Todo:</a></b></dt><dd>(user): Like this we will duplicate all binary clause from the problem. However this leads to a simpler API (since we don't need to special case the loading of the original clauses) and we mainly use drat proof for testing anyway. </dd></dl>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00509">509</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a4ed43b605ef8ae6ef7c66aacae24ced4" name="a4ed43b605ef8ae6ef7c66aacae24ced4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed43b605ef8ae6ef7c66aacae24ced4">&#9670;&#160;</a></span>AddBinaryClauseDuringSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::AddBinaryClauseDuringSearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#afdf7cda61327a0ee3b07971ef7270e49">AddBinaryClause()</a> but enqueues a possible unit propagation. Note that if the binary clause propagates, it must do so at the last level, this is DCHECKed.</p>
<p>Return false and do nothing if both a and b are currently false. </p>
<p>Tricky: If this is the first clause, the propagator will be added and assumed to be in a "propagated" state. This makes sure this is the case.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00526">526</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="ae62ebb2b39378e342cbb94a9db055ae1" name="ae62ebb2b39378e342cbb94a9db055ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62ebb2b39378e342cbb94a9db055ae1">&#9670;&#160;</a></span>AddImplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::AddImplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00491">491</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="ad3148e8d06e9ddd01e63eff285b9bb9a" name="ad3148e8d06e9ddd01e63eff285b9bb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3148e8d06e9ddd01e63eff285b9bb9a">&#9670;&#160;</a></span>ChangeReason()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::ChangeReason </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trail_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>new_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the reason of the variable at trail index to a binary reason. </p><dl class="section note"><dt>Note</dt><dd>the implication "new_reason =&gt; trail_[trail_index]" should be part of the implication graph. </dd></dl>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00682">682</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="ac77e8fba04708d2b664eef31e13f9d22" name="ac77e8fba04708d2b664eef31e13f9d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77e8fba04708d2b664eef31e13f9d22">&#9670;&#160;</a></span>CleanupAllRemovedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::CleanupAllRemovedVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000968">Todo:</a></b></dt><dd>(user): consider at most ones. </dd></dl>
<p>Clean-up at most ones.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l02066">2066</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a07e88e219614208bf02f4bed078504f9" name="a07e88e219614208bf02f4bed078504f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e88e219614208bf02f4bed078504f9">&#9670;&#160;</a></span>ComputeTransitiveReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::ComputeTransitiveReduction </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log_info</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prunes the implication graph by calling first <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a> to remove cycle and then by computing the transitive reduction of the remaining DAG.</p>
<dl class="section note"><dt>Note</dt><dd>this can be slow (num_literals graph traversals), so we abort early if we start doing too much work.</dd></dl>
<p>Returns false if the model is detected to be UNSAT (this needs to call <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a> if not already done).</p>
<dl class="section note"><dt>Note</dt><dd>as a side effect this also do a full "failed literal probing" using the binary implication graph only.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000951">Todo:</a></b></dt><dd>(user): Track which literal have new implications, and only process the antecedants of these. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000952">Todo:</a></b></dt><dd>(user): the situation with fixed variable is not really "clean". Simplify the code so we are sure we don't run into issue or have to deal with any of that here. </dd></dl>
<p>For each node we do a graph traversal and only keep the literals at maximum distance 1. This only works because we have a DAG when ignoring the "redundant" literal marked by <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a>. Note that we also need no duplicates in the implications list for correctness which is also guaranteed by <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000953">Todo:</a></b></dt><dd>(user): We should be able to reuse some propagation like it is done for tree-look. Once a node is processed, we just need to process a node that implies it. Test if we can make this faster. Alternatively, only clear a part of is_marked_ (after the first child of root in reverse topo order).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000954">Todo:</a></b></dt><dd>(user): Can we exploit the fact that the implication graph is a skew-symmetric graph (isomorphic to its transposed) so that we do less work? Also it would be nice to keep the property that even if we abort during the algorithm, if a =&gt; b, then not(b) =&gt; not(a) is also present in the other direct implication list. </dd></dl>
<p>In most situation reverse_topological_order_ contains no redundant, fixed or removed variables. But the reverse_topological_order_ is only recomputed when new binary are added to the graph, not when new variable are fixed.</p>
<p>This is a "poor" version of the tree look stuff, but it does show good improvement. If we just processed one of the child of root, we don't need to re-explore it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000955">Todo:</a></b></dt><dd>(user): Another optim we can do is that we never need to expand any node with a reverse topo order smaller or equal to the min of the ones in this list. </dd></dl>
<p>This is a corner case where because of equivalent literal, root appear in implications_[root], we will remove it below.</p>
<p>When this happens, then root must be false, we handle this just after the loop.</p>
<p>We have a DAG, so direct_child could only be marked first.</p>
<p>Failed literal probing. If both x and not(x) are marked then root must be false. Note that because we process "roots" in reverse topological order, we will fix the LCA of x and not(x) first.</p>
<p>We tested that at the beginning.</p>
<p>We propagate right away the binary implications so that we do not need to consider all antecedants of root in the transitive reduction.</p>
<dl class="section note"><dt>Note</dt><dd>direct_implications will be cleared by <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a7e4e6130c59dffa6ab52a1cff24400a2">RemoveFixedVariables()</a> that will need to inspect it to completely remove Literal(root) from all lists.</dd></dl>
<p>Only keep the non-marked literal (and the redundant one which are never marked). We mark root to remove it in the corner case where it was there.</p>
<p>Abort if the computation involved is too big.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01363">1363</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="aa80bafd5aaf59cc6c7a67176c6304239" name="aa80bafd5aaf59cc6c7a67176c6304239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80bafd5aaf59cc6c7a67176c6304239">&#9670;&#160;</a></span>DetectEquivalences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::DetectEquivalences </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log_info</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns false if the model is unsat, otherwise detects equivalent variable (with respect to the implications only) and reorganize the propagation lists accordingly.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000964">Todo:</a></b></dt><dd>(user): Completely get rid of such literal instead? it might not be reasonable code-wise to remap our literals in all of our constraints though. </dd></dl>
<p>This was already called, and no new constraint where added. Note that new fixed variable cannote create new equivalence, only new binary clauses do.</p>
<p>Lets remove all fixed variables first.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000950">Todo:</a></b></dt><dd>(user): We could just do it directly though. </dd></dl>
<p>The old values will still be valid.</p>
<p>If one is fixed then all must be fixed. Note that the reason why the propagation didn't already do that and we don't always get fixed component of size 1 is because of the potential newly fixed literals above.</p>
<p>In any case, all fixed literals are marked as redundant.</p>
<p>Next component.</p>
<p>We ignore variable that appear in no constraints.</p>
<p>We always take the smallest literal index (which also corresponds to the smallest BooleanVariable index) as a representative. This make sure that the representative of a literal l and the one of not(l) will be the negation of each other. There is also reason to think that it is heuristically better to use a BooleanVariable that was created first.</p>
<dl class="section note"><dt>Note</dt><dd>because we process list in reverse topological order, this is only needed if there is any equivalence before this point.</dd></dl>
<p>Sets the representative.</p>
<p>Detect if x &lt;=&gt; not(x) which means unsat. Note that we relly on the fact that when sorted, they will both be consecutive in the list.</p>
<p>Merge all the lists in implications_[representative]. </p><dl class="section note"><dt>Note</dt><dd>we do not want representative in its own list.</dd></dl>
<p>Add representative &lt;=&gt; literal.</p>
<p>Remark: this relation do not need to be added to a DRAT proof since the redundant variables should never be used again for a pure SAT problem.</p>
<p>Remap all at most ones. Remove fixed variables, process duplicates. Note that this might result in more implications when we expand small at most one.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01176">1176</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="ab589014979b15460c0cb295527097731" name="ab589014979b15460c0cb295527097731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab589014979b15460c0cb295527097731">&#9670;&#160;</a></span>DirectImplications()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp; operations_research::sat::BinaryImplicationGraph::DirectImplications </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The literals that are "directly" implied when literal is set to true. This is not a full "reachability". It includes at most ones propagation. The set of all direct implications is enough to describe the implications graph completely.</p>
<p>When doing blocked clause elimination of bounded variable elimination, one only need to consider this list and not the full reachability.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000958">Todo:</a></b></dt><dd><p class="startdd">(user): lazy cleanup the lists on is_removed_? </p>
<p class="enddd">(user): Mark fixed variable as is_removed_ for faster iteration? </p>
</dd></dl>
<p>Clear old state.</p>
<p>Fill new state.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01935">1935</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a7d75a576284b4b229eee6aa8c24e4c45" name="a7d75a576284b4b229eee6aa8c24e4c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d75a576284b4b229eee6aa8c24e4c45">&#9670;&#160;</a></span>DirectImplicationsEstimatedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::BinaryImplicationGraph::DirectImplicationsEstimatedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>literal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A proxy for <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab589014979b15460c0cb295527097731">DirectImplications()</a>.size(), However we currently do not maintain it perfectly. It is exact each time <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab589014979b15460c0cb295527097731">DirectImplications()</a> is called, and we update it in some situation but we don't deal with fixed variables, at_most ones and duplicates implications for now. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00701">701</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a829522e9eed5248e37074f378a48c3f0" name="a829522e9eed5248e37074f378a48c3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829522e9eed5248e37074f378a48c3f0">&#9670;&#160;</a></span>ExpandAtMostOneWithWeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_weight&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::BinaryImplicationGraph::ExpandAtMostOneWithWeight&lt; false &gt; </td>
          <td>(</td>
          <td class="paramtype">const absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td>
          <td class="paramname"><em>at_most_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classabsl_1_1StrongVector.html">absl::StrongVector</a>&lt; LiteralIndex, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>can_be_included</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classabsl_1_1StrongVector.html">absl::StrongVector</a>&lt; LiteralIndex, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded_lp_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as ExpandAtMostOne() but try to maximize the weight in the clique. </p>
<p>Make sure both version are compiled. </p>
<p>Do not spend too much time here.</p>
<p>We can't generate a violated cut this way. This is because intersection contains all the possible ways to extend the current clique.</p>
<p>Expand? The negation of any literal in the intersection is a valid way to extend the clique.</p>
<p>Heuristic: use literal with largest lp value. We randomize slightly.</p>
<p>If we don't use weight, we prefer variable that comes first.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01688">1688</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a2735353cc3b14a2ef6574ad9f52c06b7" name="a2735353cc3b14a2ef6574ad9f52c06b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2735353cc3b14a2ef6574ad9f52c06b7">&#9670;&#160;</a></span>ExtractAllBinaryClauses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::ExtractAllBinaryClauses </td>
          <td>(</td>
          <td class="paramtype">Output *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all the binary clauses managed by this class. The Output type must support an <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#afdf7cda61327a0ee3b07971ef7270e49">AddBinaryClause(Literal a, Literal b)</a> function.</p>
<p>Important: This currently does NOT include at most one constraints.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000966">Todo:</a></b></dt><dd>(user): When extracting to <a class="el" href="cp__model_8proto.html">cp_model.proto</a> we could be more efficient by extracting bool_and constraint with many lhs terms. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000967">Todo:</a></b></dt><dd>(user): Ideally we should just never have duplicate clauses in this class. But it seems we do in some corner cases, so lets not output them twice. </dd></dl>
<p>Note(user): We almost always have both a =&gt; b and not(b) =&gt; not(a) in our implications_ database. Except if <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a07e88e219614208bf02f4bed078504f9">ComputeTransitiveReduction()</a> was aborted early, but in this case, if only one is present, the other could be removed, so we shouldn't need to output it.</p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00654">654</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="ad3d4a6613825674f5a0e494343c5976f" name="ad3d4a6613825674f5a0e494343c5976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d4a6613825674f5a0e494343c5976f">&#9670;&#160;</a></span>FindFailedLiteralAroundVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::FindFailedLiteralAroundVar </td>
          <td>(</td>
          <td class="paramtype">BooleanVariable&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_unsat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable elimination by replacing everything of the form a =&gt; var =&gt; b by a =&gt; b. We ignore any a =&gt; a so the number of new implications is not always just the product of the two direct implication list of var and not(var). However, if a =&gt; var =&gt; a, then a and var are equivalent, so this case will be removed if one run <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a> before this. Similarly, if a =&gt; var =&gt; not(a) then a must be false and this is detected and dealt with by <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ad3d4a6613825674f5a0e494343c5976f">FindFailedLiteralAroundVar()</a>. </p>
<p>not(l) =&gt; literal =&gt; l.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01978">1978</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="aba4f40564f3adae0c9b904663bf62637" name="aba4f40564f3adae0c9b904663bf62637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4f40564f3adae0c9b904663bf62637">&#9670;&#160;</a></span>GenerateAtMostOnesWithLargeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; &amp; operations_research::sat::BinaryImplicationGraph::GenerateAtMostOnesWithLargeWeight </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lp_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LP clique cut heuristic. Returns a set of "at most one" constraints on the given literals or their negation that are violated by the current LP solution. Note that this assumes that lp_value(lit) = 1 - lp_value(lit.Negated()).</p>
<p>The literal and lp_values vector are in one to one correspondence. We will only generate clique with these literals or their negation.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000965">Todo:</a></b></dt><dd>(user): Refine the heuristic and unit test! </dd></dl>
<p>We only want to generate a cut with literals from the LP, not extra ones.</p>
<p>We want highest sum first.</p>
<p>First heuristic. Currently we only consider violated at most one of size 2, and extend them. Right now, the code is a bit slow to try too many at every LP node so it is why we are defensive like this. Note also that because we currently still statically add the initial implications, this will only add cut based on newly learned binary clause. Or the one that were not added to the relaxation in the first place.</p>
<p>We consider only one candidate for each current_literal.</p>
<p>Do not genate too many cut at once.</p>
<p>Expand to a maximal at most one each candidates before returning them. </p><dl class="section note"><dt>Note</dt><dd>we only expand using literal from the LP.</dd></dl>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01778">1778</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="af37d5785578f8515dde315f5f1ec9495" name="af37d5785578f8515dde315f5f1ec9495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37d5785578f8515dde315f5f1ec9495">&#9670;&#160;</a></span>Implications()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const absl::InlinedVector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>, 6 &gt; &amp; operations_research::sat::BinaryImplicationGraph::Implications </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of literal "directly" implied by l. Beware that this can easily change behind your back if you modify the solver state. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00561">561</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a030e1fb5dde77ceb0054b7b0d49bd08e" name="a030e1fb5dde77ceb0054b7b0d49bd08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030e1fb5dde77ceb0054b7b0d49bd08e">&#9670;&#160;</a></span>IsDag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::IsDag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a> has been called and no new binary clauses have been added since then. When this is true then there is no cycle in the binary implication graph (modulo the redundant literals that form a cycle with their representative). </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00550">550</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a6de69e3bb9c8a73570b3e9e8c290bdab" name="a6de69e3bb9c8a73570b3e9e8c290bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de69e3bb9c8a73570b3e9e8c290bdab">&#9670;&#160;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there is no constraints in this class. </p>

<p>Reimplemented from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#ab639102372f03758b18523b613ae69e1">operations_research::sat::SatPropagator</a>.</p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00484">484</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="aa00e517674b03a53afd9dd16ca625921" name="aa00e517674b03a53afd9dd16ca625921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00e517674b03a53afd9dd16ca625921">&#9670;&#160;</a></span>IsRedundant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::IsRedundant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this literal is fixed or is equivalent to another literal. This means that it can just be ignored in most situation.</p>
<dl class="section note"><dt>Note</dt><dd>the set (and thus number) of redundant literal can only grow over time. This is because we always use the lowest index as representative of an equivalent class, so a redundant literal will stay that way. </dd></dl>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00628">628</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="aeca8f89cbb57b5deeec57292257138c3" name="aeca8f89cbb57b5deeec57292257138c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca8f89cbb57b5deeec57292257138c3">&#9670;&#160;</a></span>IsRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::IsRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00716">716</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="ac5b69ac5d57f5b4e6ace24c0407487ab" name="ac5b69ac5d57f5b4e6ace24c0407487ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b69ac5d57f5b4e6ace24c0407487ab">&#9670;&#160;</a></span>literal_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::literal_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00644">644</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="aa37e2a622549d733c3bbb8b340f3c473" name="aa37e2a622549d733c3bbb8b340f3c473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37e2a622549d733c3bbb8b340f3c473">&#9670;&#160;</a></span>MinimizeConflictExperimental()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::MinimizeConflictExperimental </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;&#160;</td>
          <td class="paramname"><em>trail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *&#160;</td>
          <td class="paramname"><em>conflict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000947">Todo:</a></b></dt><dd>(user): Also consider at most one? </dd></dl>
<p>Identify and remove the redundant literals from the given conflict. 1/ If a -&gt; b then a can be removed from the conflict clause. This is because not b -&gt; not a. 2/ a -&gt; b can only happen if level(a) &lt;= level(b). 3/ Because of 2/, cycles can appear only at the same level. The vector is_simplified_ is used to avoid removing all elements of a cycle. Note that this is not optimal in the sense that we may not remove a literal that can be removed.</p>
<dl class="section note"><dt>Note</dt><dd>there is no need to explore the unique literal of the highest decision level since it can't be removed. Because this is a conflict, such literal is always at position 0, so we start directly at 1.</dd></dl>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00961">961</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="ab5846564f39bf6ba28ecdced8429d492" name="ab5846564f39bf6ba28ecdced8429d492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5846564f39bf6ba28ecdced8429d492">&#9670;&#160;</a></span>MinimizeConflictFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::MinimizeConflictFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;&#160;</td>
          <td class="paramname"><em>trail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *&#160;</td>
          <td class="paramname"><em>conflict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt; BooleanVariable &gt; *&#160;</td>
          <td class="paramname"><em>marked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a3cbe67b46860621bfa57c87f5247a385">MinimizeConflictWithReachability()</a> but also mark (in the given <a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>) the reachable literal already assigned to false. These literals will be implied if the 1-UIP literal is assigned to false, and the classic minimization algorithm can take advantage of that. </p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00881">881</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="aa8095f7dce1a603c1b387317c756319e" name="aa8095f7dce1a603c1b387317c756319e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8095f7dce1a603c1b387317c756319e">&#9670;&#160;</a></span>MinimizeConflictFirstWithTransitiveReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::MinimizeConflictFirstWithTransitiveReduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;&#160;</td>
          <td class="paramname"><em>trail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *&#160;</td>
          <td class="paramname"><em>conflict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef&#160;</td>
          <td class="paramname"><em>random</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab5846564f39bf6ba28ecdced8429d492">MinimizeConflictFirst()</a> but take advantage of this reachability computation to remove redundant implication in the implication list of the first UIP conflict. </p>
<p>The randomization allow to find more redundant implication since to find a =&gt; b and remove b, a must be before b in direct_implications. Note that a std::reverse() could work too. But randomization seems to work better. Probably because it has other impact on the search tree.</p>
<p>The literal is already marked! so it must be implied by one of the previous literal in the direct_implications list. We can safely remove it.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00899">899</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a3cbe67b46860621bfa57c87f5247a385" name="a3cbe67b46860621bfa57c87f5247a385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbe67b46860621bfa57c87f5247a385">&#9670;&#160;</a></span>MinimizeConflictWithReachability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::MinimizeConflictWithReachability </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *&#160;</td>
          <td class="paramname"><em>conflict</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the binary implication graph to minimize the given conflict by removing literals that implies others. The idea is that if a and b are two literals from the given conflict and a =&gt; b (which is the same as not(b) =&gt; not(a)) then a is redundant and can be removed.</p>
<dl class="section note"><dt>Note</dt><dd>removing as many literals as possible is too time consuming, so we use different heuristics/algorithms to do this minimization. See the binary_minimization_algorithm SAT parameter and the .cc for more details about the different algorithms.</dd></dl>
<p>Here, we remove all the literal whose negation are implied by the negation of the 1-UIP literal (which always appear first in the given conflict). Note that this algorithm is "optimal" in the sense that it leads to a minimized conflict with a backjump level as low as possible. However, not all possible literals are removed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000945">Todo:</a></b></dt><dd>(user): Also consider at most one? </dd></dl>
<p>Compute the reachability from the literal "not(conflict-&gt;front())" using an iterative dfs.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000946">Todo:</a></b></dt><dd>(user): This sounds like a good idea, but somehow it seems better not to do that even though it is almost for free. Investigate more.</dd></dl>
<p>The idea here is that since we already compute the reachability from the root literal, we can use this computation to remove any implication root_literal =&gt; b if there is already root_literal =&gt; a and b is reachable from a.</p>
<p>We treat the direct implications differently so we can also remove the redundant implications from this list at the same time.</p>
<p>The "trick" is to unmark 'l'. This way, if we explore it twice, it means that this l is reachable from some other 'l' from the direct implication list. Remarks:</p><ul>
<li>We don't loose too much complexity when this happen since a literal can be unmarked only once, so in the worst case we loop twice over its children. Moreover, this literal will be pruned for later calls.</li>
<li>This is correct, i.e. we can't prune too many literals because of a strongly connected component. Proof by contradiction: If we take the first (in direct_implications) literal from a removed SCC, it must have marked all the others. But because they are marked, they will not be explored again and so can't mark the first literal.</li>
</ul>
<p>Now we can prune the direct implications list and make sure are the literals there are marked.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00804">804</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a2f885ed25be7c4afbf6952ec5c872cce" name="a2f885ed25be7c4afbf6952ec5c872cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f885ed25be7c4afbf6952ec5c872cce">&#9670;&#160;</a></span>num_implications()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::num_implications </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of current implications. Note that a =&gt; b and not(b) =&gt; not(a) are counted separately since they appear separately in our propagation lists. The number of size 2 clauses that represent the same thing is half this number. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00643">643</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="af92a90e6228d2b1adde4574bf1c51d72" name="af92a90e6228d2b1adde4574bf1c51d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92a90e6228d2b1adde4574bf1c51d72">&#9670;&#160;</a></span>num_inspections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::num_inspections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of literals inspected by this class during propagation. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00616">616</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a41556a2163546a7b20d67e8d76fcd2f7" name="a41556a2163546a7b20d67e8d76fcd2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41556a2163546a7b20d67e8d76fcd2f7">&#9670;&#160;</a></span>num_literals_removed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::num_literals_removed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00620">620</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a38267138f9430df5773fb280c9fb9efb" name="a38267138f9430df5773fb280c9fb9efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38267138f9430df5773fb280c9fb9efb">&#9670;&#160;</a></span>num_minimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::num_minimization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MinimizeClause() stats. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00619">619</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a00903273dd562494127e2bac03942806" name="a00903273dd562494127e2bac03942806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00903273dd562494127e2bac03942806">&#9670;&#160;</a></span>num_propagations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::num_propagations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of literal propagated by this class (including conflicts). </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00613">613</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a6d8a5b6838659b4a6c42419a2c54cc51" name="a6d8a5b6838659b4a6c42419a2c54cc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8a5b6838659b4a6c42419a2c54cc51">&#9670;&#160;</a></span>num_redundant_implications()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::num_redundant_implications </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of implications removed by transitive reduction. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00635">635</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a17b6b522ac5025d862ebda39ea161d72" name="a17b6b522ac5025d862ebda39ea161d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b6b522ac5025d862ebda39ea161d72">&#9670;&#160;</a></span>num_redundant_literals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::num_redundant_literals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00629">629</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a5f0180d303834fab315cf079bb442e30" name="a5f0180d303834fab315cf079bb442e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0180d303834fab315cf079bb442e30">&#9670;&#160;</a></span>NumImplicationOnVariableRemoval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::NumImplicationOnVariableRemoval </td>
          <td>(</td>
          <td class="paramtype">BooleanVariable&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We should have dealt with that in <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ad3d4a6613825674f5a0e494343c5976f">FindFailedLiteralAroundVar()</a>.</p>
<p>l =&gt; literal =&gt; l: equivalent variable!</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l02003">2003</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a33a5d176dddf3a86e0b08a9d94195d46" name="a33a5d176dddf3a86e0b08a9d94195d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a5d176dddf3a86e0b08a9d94195d46">&#9670;&#160;</a></span>Propagate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::Propagate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> *&#160;</td>
          <td class="paramname"><em>trail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints.">SatPropagator</a> interface. </p>

<p>Implements <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a8417cfbc49d425aac62ce622b058b018">operations_research::sat::SatPropagator</a>.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00780">780</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="abb76657b65cc3ae9aed6d1e38444a083" name="abb76657b65cc3ae9aed6d1e38444a083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb76657b65cc3ae9aed6d1e38444a083">&#9670;&#160;</a></span>Reason()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::BinaryImplicationGraph::Reason </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;&#160;</td>
          <td class="paramname"><em>trail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trail_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Explains why the literal at given trail_index was propagated by returning a reason for this propagation. This will only be called for literals that are on the trail and were propagated by this class.</p>
<p>The interpretation is that because all the literals of a reason were assigned to false, we could deduce the assignment of the given variable.</p>
<p>The returned Span has to be valid until the literal is untrailed. A client can use trail_.GetEmptyVectorToStoreReason() if it doesn't have a memory location that already contains the reason. </p>

<p>Reimplemented from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#aebfb6fb80bf098bfca298973026b7398">operations_research::sat::SatPropagator</a>.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00792">792</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a9f13e4a1fd53766aed09fec7a2429e3f" name="a9f13e4a1fd53766aed09fec7a2429e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f13e4a1fd53766aed09fec7a2429e3f">&#9670;&#160;</a></span>RemoveBooleanVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::RemoveBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">BooleanVariable&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; *&#160;</td>
          <td class="paramname"><em>postsolve_clauses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For all possible a =&gt; var =&gt; b, add a =&gt; b. </p>
<p>Notify the deletion to the proof checker and the postsolve. </p><dl class="section note"><dt>Note</dt><dd>we want var first in these clauses for the postsolve.</dd></dl>
<p>We need to remove any occurrence of var in our implication lists, this will be delayed to the <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ac77e8fba04708d2b664eef31e13f9d22">CleanupAllRemovedVariables()</a> call.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l02023">2023</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a7e4e6130c59dffa6ab52a1cff24400a2" name="a7e4e6130c59dffa6ab52a1cff24400a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4e6130c59dffa6ab52a1cff24400a2">&#9670;&#160;</a></span>RemoveFixedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::RemoveFixedVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This must only be called at decision level 0 after all the possible propagations. It:</p><ul>
<li>Removes the variable at true from the implications lists.</li>
<li>Frees the propagation list of the assigned literals. </li>
</ul>
<p>Nothing to do if nothing changed since last call.</p>
<p>The code assumes that everything is already propagated. Otherwise we will remove implications that didn't propagate yet!</p>
<p>If b is true and a -&gt; b then because not b -&gt; not a, all the implications list that contains b will be marked by this process. And the ones that contains not(b) should correspond to a false literal!</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000948">Todo:</a></b></dt><dd>(user): This might not be true if we remove implication by transitive reduction and the process was aborted due to the computation limit. I think it will be good to maintain that invariant though, otherwise fixed literals might never be removed from these lists... </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000949">Todo:</a></b></dt><dd>(user): This might be a bit slow. Do not call all the time if needed, this shouldn't change the correctness of the code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01012">1012</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a0fa73e314fd241df54be6f7a0bf97704" name="a0fa73e314fd241df54be6f7a0bf97704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa73e314fd241df54be6f7a0bf97704">&#9670;&#160;</a></span>RepresentativeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> operations_research::sat::BinaryImplicationGraph::RepresentativeOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a>&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the representative of the equivalence class of l (or l itself if it is on its own). Note that <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a> should have been called to get any non-trival results. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00568">568</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="adfe87170234d2d0464fca7dddd5194d8" name="adfe87170234d2d0464fca7dddd5194d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe87170234d2d0464fca7dddd5194d8">&#9670;&#160;</a></span>ResetWorkDone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::ResetWorkDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a829522e9eed5248e37074f378a48c3f0" title="Same as ExpandAtMostOne() but try to maximize the weight in the clique.">ExpandAtMostOneWithWeight()</a> will increase this, so a client can put a limit on this possibly expansive operation. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00723">723</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a1e21fcb1c0adc1356d2d04102fe920af" name="a1e21fcb1c0adc1356d2d04102fe920af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e21fcb1c0adc1356d2d04102fe920af">&#9670;&#160;</a></span>Resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::Resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the data structure. </p>
<p>--&mdash; <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">BinaryImplicationGraph</a> --&mdash; </p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l00495">495</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="aca0f1a1d8161f86fabf9305062799a9d" name="aca0f1a1d8161f86fabf9305062799a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0f1a1d8161f86fabf9305062799a9d">&#9670;&#160;</a></span>ReverseTopologicalOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; LiteralIndex &gt; &amp; operations_research::sat::BinaryImplicationGraph::ReverseTopologicalOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>One must call <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a> first, this is CHECKed. Returns a list so that if x =&gt; y, then x is after y. </p>

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00554">554</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="aacb0838ece7c13cea59b8d02c18c5dd6" name="aacb0838ece7c13cea59b8d02c18c5dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb0838ece7c13cea59b8d02c18c5dd6">&#9670;&#160;</a></span>SetDratProofHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::BinaryImplicationGraph::SetDratProofHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html">DratProofHandler</a> *&#160;</td>
          <td class="paramname"><em>drat_proof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00675">675</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<a id="a4a7ae378f427890ed11dfa8efb7c1db7" name="a4a7ae378f427890ed11dfa8efb7c1db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7ae378f427890ed11dfa8efb7c1db7">&#9670;&#160;</a></span>TransformIntoMaxCliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::BinaryImplicationGraph::TransformIntoMaxCliques </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; &gt; *&#160;</td>
          <td class="paramname"><em>at_most_ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_num_explored_nodes</em> = <code>1e8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another way of representing an implication graph is a list of maximal "at
most one" constraints, each forming a max-clique in the incompatibility graph. This representation is useful for having a good linear relaxation.</p>
<p>This function will transform each of the given constraint into a maximal one in the underlying implication graph. Constraints that are redundant after other have been expanded (i.e. included into) will be cleared. </p><dl class="section note"><dt>Note</dt><dd>the order of constraints will be conserved.</dd></dl>
<p>Returns false if the model is detected to be UNSAT (this needs to call <a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">DetectEquivalences()</a> if not already done). </p>
<p>The code below assumes a DAG.</p>
<p>Data to detect inclusion of base amo into extend amo.</p>
<p>We starts by processing larger constraints first. But we want the output order to be stable.</p>
<p>Note(user): Because we always use literal with the smallest variable indices as representative, this make sure that if possible, we express the clique in term of user provided variable (that are always created first).</p>
<p>Remap the clique to only use representative.</p>
<p>We skip anything that can be presolved further as the code below do not handle duplicate well.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000956">Todo:</a></b></dt><dd>(user): Shall we presolve it here? </dd></dl>
<p>Special case for clique of size 2, we don't expand them if they are included in an already added clique.</p>
<p>Save the non-extended version as possible subset. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000957">Todo:</a></b></dt><dd>(user): Detect on the fly is superset already exist. </dd></dl>
<p>We only expand the clique as long as we didn't spend too much time.</p>
<p>Save the extended version as possible superset.</p>
<p>Also index clique for size 2 quick lookup.</p>
<p>Remove clique (before extension) that are included in an extended one.</p>
<p>Abort if one was already deleted.</p>
<p>If an extended clique already cover a deleted one, we cannot try to remove it by looking at its non-extended version.</p>

<p class="definition">Definition at line <a class="el" href="clause_8cc_source.html#l01542">1542</a> of file <a class="el" href="clause_8cc_source.html">clause.cc</a>.</p>

</div>
</div>
<a id="a2377211a723ddb7ec81fd5580ba44c65" name="a2377211a723ddb7ec81fd5580ba44c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2377211a723ddb7ec81fd5580ba44c65">&#9670;&#160;</a></span>WorkDone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::BinaryImplicationGraph::WorkDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="clause_8h_source.html#l00724">724</a> of file <a class="el" href="clause_8h_source.html">clause.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="clause_8h_source.html">clause.h</a></li>
<li>ortools/sat/<a class="el" href="clause_8cc_source.html">clause.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">BinaryImplicationGraph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
