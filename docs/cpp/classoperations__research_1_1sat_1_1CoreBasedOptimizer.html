<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::CoreBasedOptimizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.11</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1CoreBasedOptimizer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1CoreBasedOptimizer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::CoreBasedOptimizer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="optimization_8h_source.html">optimization.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3c6366424e84d20b6270765af293ada" id="r_ac3c6366424e84d20b6270765af293ada"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c6366424e84d20b6270765af293ada">CoreBasedOptimizer</a> (IntegerVariable objective_var, absl::Span&lt; const IntegerVariable &gt; variables, absl::Span&lt; const IntegerValue &gt; <a class="el" href="gscip__solver_8cc.html#aa59e74cc299dbf75fa6e2234dd0849a2">coefficients</a>, std::function&lt; void()&gt; feasible_solution_observer, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *<a class="el" href="gurobi__interface_8cc.html#a0728f23c9a47655d38e0bf1a2f200bcf">model</a>)</td></tr>
<tr class="separator:ac3c6366424e84d20b6270765af293ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a342f8fad2c4262b0ddec85b98bdf8" id="r_ab0a342f8fad2c4262b0ddec85b98bdf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0a342f8fad2c4262b0ddec85b98bdf8">Optimize</a> ()</td></tr>
<tr class="separator:ab0a342f8fad2c4262b0ddec85b98bdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4a53c17d32408e49285f11171673fa" id="r_a5a4a53c17d32408e49285f11171673fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a4a53c17d32408e49285f11171673fa">OptimizeWithSatEncoding</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const Coefficient &gt; <a class="el" href="gscip__solver_8cc.html#aa59e74cc299dbf75fa6e2234dd0849a2">coefficients</a>, Coefficient offset)</td></tr>
<tr class="separator:a5a4a53c17d32408e49285f11171673fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Same as <a class="el" href="namespaceoperations__research_1_1sat.html#ab231dff94744f73429364e7180b1397f">MinimizeIntegerVariableWithLinearScanAndLazyEncoding()</a> but use a core-based approach instead. Note that the given objective_var is just used for reporting the lower-bound/upper-bound and do not need to be linked with its linear representation.</p>
<p>Unlike <a class="el" href="namespaceoperations__research_1_1sat.html#ab231dff94744f73429364e7180b1397f">MinimizeIntegerVariableWithLinearScanAndLazyEncoding()</a> this function just return the last solver status. In particular if it is INFEASIBLE but feasible_solution_observer() was called, it means we are at OPTIMAL. </p>

<p class="definition">Definition at line <a class="el" href="optimization_8h_source.html#l00093">93</a> of file <a class="el" href="optimization_8h_source.html">optimization.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3c6366424e84d20b6270765af293ada" name="ac3c6366424e84d20b6270765af293ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c6366424e84d20b6270765af293ada">&#9670;&#160;</a></span>CoreBasedOptimizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::CoreBasedOptimizer::CoreBasedOptimizer </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>objective_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>feasible_solution_observer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used by the "stratified" approach. We will only consider terms with a weight not lower than this threshold. The threshold will decrease as the algorithm progress.</p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00436">436</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0a342f8fad2c4262b0ddec85b98bdf8" name="ab0a342f8fad2c4262b0ddec85b98bdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a342f8fad2c4262b0ddec85b98bdf8">&#9670;&#160;</a></span>Optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::CoreBasedOptimizer::Optimize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002042">Todo</a></b></dt><dd>(user): Change the algo slighlty to allow resuming from the last aborted position. Currently, the search is "resumable", but it will restart some of the work already done, so it might just never find anything. </dd></dl>
<p>Hack: If the objective is fully Boolean, we use the <a class="el" href="#a5a4a53c17d32408e49285f11171673fa">OptimizeWithSatEncoding()</a> version as it seems to be better.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002028">Todo</a></b></dt><dd>(user): Try to understand exactly why and merge both code path. </dd></dl>
<p>In some corner case, it is possible the GetOrCreateAssociatedLiteral() returns identical or negated literal of another term. We don't support this below, so we need to make sure this is not the case.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002029">Todo</a></b></dt><dd>(user): It might be interesting to redo this kind of presolving once high cost booleans have been fixed as we might have more at most one between literal in the objective by then.</dd></dl>
<p>Or alternatively, we could try this or something like it on the literals from the cores as they are found. We should probably make sure that if it exist, a core of size two is always added. And for such core, we can always try to see if the "at most one" can be extended.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002030">Todo</a></b></dt><dd>(user): The core is returned in the same order as the assumptions, so we don't really need this map, we could just do a linear scan to recover which node are part of the core. This however needs to be properly unit tested before usage. </dd></dl>
<p>Start the algorithm.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002031">Todo</a></b></dt><dd>(user): This always resets the solver to level zero. Because of that we don't resume a solve in "chunk" perfectly. Fix. </dd></dl>
<p>Bulk cover optimization.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002032">Todo</a></b></dt><dd>(user): If the search is aborted during this phase and we solve in "chunk", we don't resume perfectly from where it was. Fix. </dd></dl>
<p>We assumes all terms (modulo stratification) at their lower-bound.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002033">Todo</a></b></dt><dd>(user): These can be simply removed from the list. </dd></dl>
<p>Skip fixed terms. We still keep them around for a proper lower-bound computation.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002034">Todo</a></b></dt><dd>(user): we could keep an objective offset instead. </dd></dl>
<p>Only consider the terms above the threshold.</p>
<p>No assumptions with the current stratification? use the next one.</p>
<p>If there is only one or two assumptions left, we switch the algorithm.</p>
<p>Display the progress.</p>
<p>Convert integer_assumptions to Literals.</p>
<p>Tricky: In some rare case, it is possible that the same literal correspond to more that one assumptions. In this case, we can just pick one of them when converting back a core to term indices.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002035">Todo</a></b></dt><dd>(user): We can probably be smarter about the cost of the assumptions though. </dd></dl>
<p>Solve under the assumptions.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002036">Todo</a></b></dt><dd>(user): If the "search" is interrupted while computing cores, we currently do not resume it flawlessly. We however add any cores we found before aborting. </dd></dl>
<p>Process the cores by creating new variables and transferring the minimum weight of each core to it.</p>
<p>This just increase the lower-bound of the corresponding node. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002037">Todo</a></b></dt><dd>(user): Maybe the solver should do it right away. </dd></dl>
<p>Compute the min weight of all the terms in the core. The lower bound will be increased by that much because at least one assumption in the core must be true. This is also why we can start at 1 for new_var_lb.</p>
<p>When this happen, the core is now trivially "minimized" by the new bound on this variable, so there is no point in adding it.</p>
<p>We will "transfer" min_weight from all the variables of the core to a new variable.</p>
<p>Sum variables in the core &lt;= new_var.</p>
<p>Abort if we reached the time limit. Note that we still add any cores we found in case the solve is split in "chunk".</p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l01028">1028</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<a id="a5a4a53c17d32408e49285f11171673fa" name="a5a4a53c17d32408e49285f11171673fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4a53c17d32408e49285f11171673fa">&#9670;&#160;</a></span>OptimizeWithSatEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8022922b9cf102d6697157b3f2ccc352">SatSolver::Status</a> operations_research::sat::CoreBasedOptimizer::OptimizeWithSatEncoding </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const Coefficient &gt;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coefficient</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A different way to encode the objective as core are found.</p>
<p>If the vector if literals is passed it will use that, otherwise it will encode the passed integer variables. In both cases, the vector used should be of the same size as the coefficients vector.</p>
<p>It seems to be more powerful, but it isn't completely implemented yet. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002043">Todo</a></b></dt><dd>(user):<ul>
<li>Support resuming for interleaved search.</li>
<li>Implement all core heurisitics. </li>
</ul>
</dd></dl>
<p>Create one initial nodes per variables with cost. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo002021">Todo</a></b></dt><dd>(user): We could create <a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html">EncodingNode</a> out of IntegerVariable.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the nodes order and assumptions extracted from it will be stable. In particular, new nodes will be appended at the end, which make the solver more likely to find core involving only the first assumptions. This is important at the beginning so the solver as a chance to find a lot of non-overlapping small cores without the need to have dedicated non-overlapping core finder. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002022">Todo</a></b></dt><dd>(user): It could still be beneficial to add one. Experiments. </dd></dl>
<p>All Booleans.</p>
<p>Use integer encoding.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002023">Todo</a></b></dt><dd>(user): This might not be ideal if there are holes in the domain. It should work by adding duplicates literal, but we should be able to be more efficient. </dd></dl>
<p>Initialize the bounds. This is in term of number of variables not at their minimal value.</p>
<p>This is used by the "stratified" approach.</p>
<p>Start the algorithm.</p>
<dl class="section note"><dt>Note</dt><dd>the objective_var_ upper bound is the one from the "improving" problem, so if we have a feasible solution, it will be the best solution objective value - 1.</dd></dl>
<p>Report the improvement. </p><dl class="section note"><dt>Note</dt><dd>we have a callback that will do the same, but doing it earlier allow us to add more information.</dd></dl>
<p>We adapt the stratified lower bound when the gap is small. All literals with such weight will be in an at_most_one relationship, which will lead to a nice encoding if we find a core.</p>
<p>We do not have any assumptions anymore, but we still need to see if the problem is feasible or not!</p>
<p>Solve under the assumptions.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002024">Todo</a></b></dt><dd>(user): Find multiple core like in the "main" algorithm. This is just trying to solve with assumptions not involving the newly found core.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002025">Todo</a></b></dt><dd>(user): With stratification, sometime we just spend too much time trying to find a feasible solution/prove infeasibility and we could instead just use stratification=0 to find easty core and improve lower bound. </dd></dl>
<p>If not all assumptions were taken, continue with a lower stratified bound. Otherwise we have an optimal solution.</p>
<p>We have a new core.</p>
<p>Compute the min weight of all the nodes in the core. The lower bound will be increased by that much.</p>
<p>We only count an iter when we found a core.</p>

<p class="definition">Definition at line <a class="el" href="optimization_8cc_source.html#l00669">669</a> of file <a class="el" href="optimization_8cc_source.html">optimization.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="optimization_8h_source.html">optimization.h</a></li>
<li>ortools/sat/<a class="el" href="optimization_8cc_source.html">optimization.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html">CoreBasedOptimizer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
