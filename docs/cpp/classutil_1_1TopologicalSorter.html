<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: util::TopologicalSorter&lt; T, stable_sort, Hash, KeyEqual &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.11</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classutil_1_1TopologicalSorter.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classutil_1_1TopologicalSorter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">util::TopologicalSorter&lt; T, stable_sort, Hash, KeyEqual &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for util::TopologicalSorter&lt; T, stable_sort, Hash, KeyEqual &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classutil_1_1TopologicalSorter.png" usemap="#util::TopologicalSorter_3C_20T_2C_20stable_5Fsort_2C_20Hash_2C_20KeyEqual_20_3E_map" alt=""/>
  <map id="util::TopologicalSorter_3C_20T_2C_20stable_5Fsort_2C_20Hash_2C_20KeyEqual_20_3E_map" name="util::TopologicalSorter_3C_20T_2C_20stable_5Fsort_2C_20Hash_2C_20KeyEqual_20_3E_map">
<area href="classTopologicalSorter.html" alt="TopologicalSorter&lt; T, stable_sort, Hash, KeyEqual &gt;" shape="rect" coords="0,56,335,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a174fefc0d24b4b75055d0d9f7590da0d" id="r_a174fefc0d24b4b75055d0d9f7590da0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a174fefc0d24b4b75055d0d9f7590da0d">TopologicalSorter</a> ()</td></tr>
<tr class="separator:a174fefc0d24b4b75055d0d9f7590da0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3459f4c238bdec5f8e558c35441cf41" id="r_af3459f4c238bdec5f8e558c35441cf41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3459f4c238bdec5f8e558c35441cf41">TopologicalSorter</a> (const <a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> &amp;)=delete</td></tr>
<tr class="memdesc:af3459f4c238bdec5f8e558c35441cf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is neither copyable nor movable.  <br /></td></tr>
<tr class="separator:af3459f4c238bdec5f8e558c35441cf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64675d79226be5908a5fc5e2e725e3af" id="r_a64675d79226be5908a5fc5e2e725e3af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64675d79226be5908a5fc5e2e725e3af">operator=</a> (const <a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> &amp;)=delete</td></tr>
<tr class="separator:a64675d79226be5908a5fc5e2e725e3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17ba020939949433d5f84e2cdaefae3" id="r_ab17ba020939949433d5f84e2cdaefae3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab17ba020939949433d5f84e2cdaefae3">~TopologicalSorter</a> ()</td></tr>
<tr class="separator:ab17ba020939949433d5f84e2cdaefae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a9f56918018035264dd7aaee552b72" id="r_af1a9f56918018035264dd7aaee552b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1a9f56918018035264dd7aaee552b72">AddNode</a> (const T &amp;node)</td></tr>
<tr class="separator:af1a9f56918018035264dd7aaee552b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3478eb6cdef1baec4a8b4f6251b22ee5" id="r_a3478eb6cdef1baec4a8b4f6251b22ee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3478eb6cdef1baec4a8b4f6251b22ee5">AddEdges</a> (const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;edges)</td></tr>
<tr class="memdesc:a3478eb6cdef1baec4a8b4f6251b22ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut to <a class="el" href="#aff8189d7dc4131f357d3d70ebc9b82dc">AddEdge()</a> in bulk. Not optimized.  <br /></td></tr>
<tr class="separator:a3478eb6cdef1baec4a8b4f6251b22ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8189d7dc4131f357d3d70ebc9b82dc" id="r_aff8189d7dc4131f357d3d70ebc9b82dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8189d7dc4131f357d3d70ebc9b82dc">AddEdge</a> (const T &amp;from, const T &amp;<a class="el" href="one__tree__lower__bound_8h.html#a717d5dae07519577a5ed09ac24a4708b">to</a>)</td></tr>
<tr class="separator:aff8189d7dc4131f357d3d70ebc9b82dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4817c5037d38dc217f3458646f3e73e" id="r_af4817c5037d38dc217f3458646f3e73e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4817c5037d38dc217f3458646f3e73e">GetNext</a> (T *node, bool *cyclic_ptr, std::vector&lt; T &gt; *output_cycle_nodes=nullptr)</td></tr>
<tr class="separator:af4817c5037d38dc217f3458646f3e73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc9a1a9e8ae17f6065edf87f0a39117" id="r_aadc9a1a9e8ae17f6065edf87f0a39117"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadc9a1a9e8ae17f6065edf87f0a39117">GetCurrentFringeSize</a> ()</td></tr>
<tr class="separator:aadc9a1a9e8ae17f6065edf87f0a39117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb454078968dc55d691e05ace39dead" id="r_aabb454078968dc55d691e05ace39dead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabb454078968dc55d691e05ace39dead">StartTraversal</a> ()</td></tr>
<tr class="separator:aabb454078968dc55d691e05ace39dead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75639fa421a00d3324acb392b4fb358" id="r_ac75639fa421a00d3324acb392b4fb358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac75639fa421a00d3324acb392b4fb358">TraversalStarted</a> () const</td></tr>
<tr class="separator:ac75639fa421a00d3324acb392b4fb358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, bool stable_sort = false, typename Hash = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt;<br />
class util::TopologicalSorter&lt; T, stable_sort, Hash, KeyEqual &gt;</div><p>A copy of each Node is stored internally. Duplicated edges are allowed, and discarded lazily so that <a class="el" href="#aff8189d7dc4131f357d3d70ebc9b82dc">AddEdge()</a> keeps an amortized constant time, yet the total memory usage remains O(number of different edges + number of nodes).</p>
<p>DenseIntTopologicalSorter implements the core topological sort algorithm. For greater efficiency it can be used directly (TopologicalSorter&lt;int&gt; is about 1.5-3x slower).</p>
<p><a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> requires that all nodes and edges be added before traversing the nodes, otherwise it will die with a fatal error.</p>
<p><a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> is -compatible</p>
<p>Note(user): since all the real work is done by DenseIntTopologicalSorterTpl, and this class is a template, we inline every function here in the .h.</p>
<p>If stable_sort is true then the topological sort will preserve the original order of the nodes as much as possible. Note, the order which is preserved is the order in which the nodes are added (if you use AddEdge it will add the first argument and then the second). </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00325">325</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a174fefc0d24b4b75055d0d9f7590da0d" name="a174fefc0d24b4b75055d0d9f7590da0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174fefc0d24b4b75055d0d9f7590da0d">&#9670;&#160;</a></span>TopologicalSorter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;<a class="el" href="classTopologicalSorter.html">::TopologicalSorter</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00327">327</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="af3459f4c238bdec5f8e558c35441cf41" name="af3459f4c238bdec5f8e558c35441cf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3459f4c238bdec5f8e558c35441cf41">&#9670;&#160;</a></span>TopologicalSorter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;<a class="el" href="classTopologicalSorter.html">::TopologicalSorter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type is neither copyable nor movable. </p>

</div>
</div>
<a id="ab17ba020939949433d5f84e2cdaefae3" name="ab17ba020939949433d5f84e2cdaefae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17ba020939949433d5f84e2cdaefae3">&#9670;&#160;</a></span>~TopologicalSorter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::~<a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00332">332</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff8189d7dc4131f357d3d70ebc9b82dc" name="aff8189d7dc4131f357d3d70ebc9b82dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8189d7dc4131f357d3d70ebc9b82dc">&#9670;&#160;</a></span>AddEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::AddEdge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a directed edge with the given endpoints to the graph. There is no requirement (nor is it an error) to call <a class="el" href="#af1a9f56918018035264dd7aaee552b72">AddNode()</a> for the endpoints. Dies with a fatal error if called after a traversal has been started (see <a class="el" href="#ac75639fa421a00d3324acb392b4fb358">TraversalStarted()</a>). </p>
<p>The lookups are not inlined into AddEdge because we need to ensure that "from" is inserted before "to".</p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00353">353</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a3478eb6cdef1baec4a8b4f6251b22ee5" name="a3478eb6cdef1baec4a8b4f6251b22ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3478eb6cdef1baec4a8b4f6251b22ee5">&#9670;&#160;</a></span>AddEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::AddEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut to <a class="el" href="#aff8189d7dc4131f357d3d70ebc9b82dc">AddEdge()</a> in bulk. Not optimized. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00345">345</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="af1a9f56918018035264dd7aaee552b72" name="af1a9f56918018035264dd7aaee552b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a9f56918018035264dd7aaee552b72">&#9670;&#160;</a></span>AddNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::AddNode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a node to the graph, if it has not already been added via previous calls to <a class="el" href="#af1a9f56918018035264dd7aaee552b72">AddNode()</a>/AddEdge(). If no edges are later added connecting this node, then it remains an isolated node in the graph. <a class="el" href="#af1a9f56918018035264dd7aaee552b72">AddNode()</a> only exists to support isolated nodes. There is no requirement (nor is it an error) to call <a class="el" href="#af1a9f56918018035264dd7aaee552b72">AddNode()</a> for the endpoints used in a call to <a class="el" href="#aff8189d7dc4131f357d3d70ebc9b82dc">AddEdge()</a>. Dies with a fatal error if called after a traversal has been started (see <a class="el" href="#ac75639fa421a00d3324acb392b4fb358">TraversalStarted()</a>), or if more than INT_MAX nodes are being added. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00342">342</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="aadc9a1a9e8ae17f6065edf87f0a39117" name="aadc9a1a9e8ae17f6065edf87f0a39117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc9a1a9e8ae17f6065edf87f0a39117">&#9670;&#160;</a></span>GetCurrentFringeSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::GetCurrentFringeSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of nodes that currently have zero indegree. This starts a traversal (if not started already). </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00399">399</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="af4817c5037d38dc217f3458646f3e73e" name="af4817c5037d38dc217f3458646f3e73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4817c5037d38dc217f3458646f3e73e">&#9670;&#160;</a></span>GetNext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::GetNext </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>cyclic_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>output_cycle_nodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Visits the least node in topological order over the current set of nodes and edges, and marks that node as visited, so that repeated calls to <a class="el" href="#af4817c5037d38dc217f3458646f3e73e">GetNext()</a> will visit all nodes in order. Writes the newly visited node in *node and returns true with *cyclic set to false (assuming the graph has not yet been discovered to be cyclic). Returns false if all nodes have been visited, or if the graph is discovered to be cyclic, in which case *cyclic is also set to true.</p>
<p>If you set the optional argument "output_cycle_nodes" to non-NULL and a cycle is detected, it will dump an arbitrary cycle of the graph (whose length will be between 1 and #number_of_nodes, inclusive), in the natural order: for example if "output_cycle_nodes" is filled with ["A", "C", "B"], it means that A-&gt;C-&gt;B-&gt;A is a directed cycle of the graph.</p>
<p>This starts a traversal (if not started already). Note that the graph can only be traversed once. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00378">378</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a64675d79226be5908a5fc5e2e725e3af" name="a64675d79226be5908a5fc5e2e725e3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64675d79226be5908a5fc5e2e725e3af">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> &amp; <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabb454078968dc55d691e05ace39dead" name="aabb454078968dc55d691e05ace39dead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb454078968dc55d691e05ace39dead">&#9670;&#160;</a></span>StartTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::StartTraversal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a traversal. See <a class="el" href="#ac75639fa421a00d3324acb392b4fb358">TraversalStarted()</a>. This initializes the various data structures of the sorter. Since this takes O(num_nodes</p><ul>
<li>num_edges) time, users may want to call this at their convenience, instead of making it happen with the first <a class="el" href="#af4817c5037d38dc217f3458646f3e73e">GetNext()</a>. </li>
</ul>
<p>We move elements from the absl::flat_hash_map to this vector, without extra copy (if they are movable).</p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00408">408</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ac75639fa421a00d3324acb392b4fb358" name="ac75639fa421a00d3324acb392b4fb358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75639fa421a00d3324acb392b4fb358">&#9670;&#160;</a></span>TraversalStarted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool stable_sort = false, typename Hash  = typename absl::flat_hash_map&lt;T, int&gt;::hasher, typename KeyEqual  = typename absl::flat_hash_map&lt;T, int, Hash&gt;::key_equal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classutil_1_1TopologicalSorter.html">util::TopologicalSorter</a>&lt; T, stable_sort, Hash, KeyEqual &gt;::TraversalStarted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether a traversal has started. If true, <a class="el" href="#af1a9f56918018035264dd7aaee552b72">AddNode()</a> and <a class="el" href="#aff8189d7dc4131f357d3d70ebc9b82dc">AddEdge()</a> can no longer be called. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00422">422</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ortools/graph/<a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutil.html">util</a></li><li class="navelem"><a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
