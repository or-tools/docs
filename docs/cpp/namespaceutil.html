<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.8</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceutil.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A collections of i/o utilities for the Graph classes in ./graph.h.  
<a href="namespaceutil.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutil_1_1graph" id="r_namespaceutil_1_1graph"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1graph.html">graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutil_1_1internal" id="r_namespaceutil_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1BaseGraph.html">BaseGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1BeginEndReverseIteratorWrapper.html">BeginEndReverseIteratorWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1CompleteBipartiteGraph.html">CompleteBipartiteGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1CompleteGraph.html">CompleteGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntegerRange.html">IntegerRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntegerRangeIterator.html">IntegerRangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple iterator on an integer range, see <a class="el" href="classutil_1_1IntegerRange.html">IntegerRange</a> below.  <a href="classutil_1_1IntegerRangeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1MutableVectorIteration.html">MutableVectorIteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow iterating over a vector&lt;T&gt; as a mutable vector&lt;T*&gt;.  <a href="structutil_1_1MutableVectorIteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1SVector.html">SVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classutil_1_1SVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1UndirectedAdjacencyListsOfDirectedGraph.html">UndirectedAdjacencyListsOfDirectedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae76339cb2dcd3bc05ad762146f91fdda" id="r_ae76339cb2dcd3bc05ad762146f91fdda"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a></td></tr>
<tr class="memdesc:ae76339cb2dcd3bc05ad762146f91fdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining the simplest Graph interface as Graph for convenience.  <br /></td></tr>
<tr class="separator:ae76339cb2dcd3bc05ad762146f91fdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ee3a3e236b0c89bb6e89d7f0a069f0" id="r_ab8ee3a3e236b0c89bb6e89d7f0a069f0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab8ee3a3e236b0c89bb6e89d7f0a069f0">DenseIntStableTopologicalSorter</a></td></tr>
<tr class="separator:ab8ee3a3e236b0c89bb6e89d7f0a069f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9be35eb706de2777ef8b80262a293a" id="r_a0e9be35eb706de2777ef8b80262a293a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0e9be35eb706de2777ef8b80262a293a">DenseIntTopologicalSorter</a></td></tr>
<tr class="separator:a0e9be35eb706de2777ef8b80262a293a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae705e1342dacc10a13fb3f11f91d0696" id="r_ae705e1342dacc10a13fb3f11f91d0696"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a> { <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd">PRINT_GRAPH_ARCS</a>
, <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565">PRINT_GRAPH_ADJACENCY_LISTS</a>
, <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef">PRINT_GRAPH_ADJACENCY_LISTS_SORTED</a>
 }</td></tr>
<tr class="memdesc:ae705e1342dacc10a13fb3f11f91d0696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a graph.  <a href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">More...</a><br /></td></tr>
<tr class="separator:ae705e1342dacc10a13fb3f11f91d0696"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6c7131ba28e4222397d1cdb048da94d7" id="r_a6c7131ba28e4222397d1cdb048da94d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a6c7131ba28e4222397d1cdb048da94d7">AbortedErrorBuilder</a> ()</td></tr>
<tr class="separator:a6c7131ba28e4222397d1cdb048da94d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0f7d99f534361679bd82e09a56c30a" id="r_a9f0f7d99f534361679bd82e09a56c30a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a9f0f7d99f534361679bd82e09a56c30a">AlreadyExistsErrorBuilder</a> ()</td></tr>
<tr class="separator:a9f0f7d99f534361679bd82e09a56c30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4135532bf8cf1a7559e12f568d54d1" id="r_aac4135532bf8cf1a7559e12f568d54d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aac4135532bf8cf1a7559e12f568d54d1">CancelledErrorBuilder</a> ()</td></tr>
<tr class="separator:aac4135532bf8cf1a7559e12f568d54d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8b955fd01d92c38c96d50dd7b36fa9" id="r_a5a8b955fd01d92c38c96d50dd7b36fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a5a8b955fd01d92c38c96d50dd7b36fa9">DataLossErrorBuilder</a> ()</td></tr>
<tr class="separator:a5a8b955fd01d92c38c96d50dd7b36fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6967409cb3e0a291eda5807f3edf796" id="r_ae6967409cb3e0a291eda5807f3edf796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae6967409cb3e0a291eda5807f3edf796">DeadlineExceededErrorBuilder</a> ()</td></tr>
<tr class="separator:ae6967409cb3e0a291eda5807f3edf796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb73fb4c4369ff7beb4a819f3cc5831c" id="r_aeb73fb4c4369ff7beb4a819f3cc5831c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aeb73fb4c4369ff7beb4a819f3cc5831c">FailedPreconditionErrorBuilder</a> ()</td></tr>
<tr class="separator:aeb73fb4c4369ff7beb4a819f3cc5831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302ee4bfcb86ea9ed64a193ed0b14648" id="r_a302ee4bfcb86ea9ed64a193ed0b14648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a302ee4bfcb86ea9ed64a193ed0b14648">InternalErrorBuilder</a> ()</td></tr>
<tr class="separator:a302ee4bfcb86ea9ed64a193ed0b14648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c886e6b95bc531d4a39884a87c0101" id="r_ad0c886e6b95bc531d4a39884a87c0101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ad0c886e6b95bc531d4a39884a87c0101">InvalidArgumentErrorBuilder</a> ()</td></tr>
<tr class="separator:ad0c886e6b95bc531d4a39884a87c0101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1146d4103ad0b93801f626715519d6" id="r_afe1146d4103ad0b93801f626715519d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#afe1146d4103ad0b93801f626715519d6">NotFoundErrorBuilder</a> ()</td></tr>
<tr class="separator:afe1146d4103ad0b93801f626715519d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86ac164f0f951fca26cc3e9b34d9632" id="r_aa86ac164f0f951fca26cc3e9b34d9632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aa86ac164f0f951fca26cc3e9b34d9632">OutOfRangeErrorBuilder</a> ()</td></tr>
<tr class="separator:aa86ac164f0f951fca26cc3e9b34d9632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85d86fd35e985c0fb4c4a200d72adda" id="r_ab85d86fd35e985c0fb4c4a200d72adda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab85d86fd35e985c0fb4c4a200d72adda">PermissionDeniedErrorBuilder</a> ()</td></tr>
<tr class="separator:ab85d86fd35e985c0fb4c4a200d72adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf5136a95272248cacae1d1a036e8ea" id="r_a5bf5136a95272248cacae1d1a036e8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a5bf5136a95272248cacae1d1a036e8ea">UnauthenticatedErrorBuilder</a> ()</td></tr>
<tr class="separator:a5bf5136a95272248cacae1d1a036e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007b8813fdd1c082efc4e08fbcb8a83e" id="r_a007b8813fdd1c082efc4e08fbcb8a83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a007b8813fdd1c082efc4e08fbcb8a83e">ResourceExhaustedErrorBuilder</a> ()</td></tr>
<tr class="separator:a007b8813fdd1c082efc4e08fbcb8a83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532f9a3e8b48bd067e8576789fe36bc" id="r_a5532f9a3e8b48bd067e8576789fe36bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a5532f9a3e8b48bd067e8576789fe36bc">UnavailableErrorBuilder</a> ()</td></tr>
<tr class="separator:a5532f9a3e8b48bd067e8576789fe36bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34739da67ea599226350b0cb5d1cbad6" id="r_a34739da67ea599226350b0cb5d1cbad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a34739da67ea599226350b0cb5d1cbad6">UnimplementedErrorBuilder</a> ()</td></tr>
<tr class="separator:a34739da67ea599226350b0cb5d1cbad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23561d268e106df9d3aeba1897ab3c2a" id="r_a23561d268e106df9d3aeba1897ab3c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a23561d268e106df9d3aeba1897ab3c2a">UnknownErrorBuilder</a> ()</td></tr>
<tr class="separator:a23561d268e106df9d3aeba1897ab3c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f1c7c8153d3d3ef062a2bb08c0c310" id="r_ac4f1c7c8153d3d3ef062a2bb08c0c310"><td class="memTemplParams" colspan="2">template&lt;class UndirectedGraph , class NodeType &gt; </td></tr>
<tr class="memitem:ac4f1c7c8153d3d3ef062a2bb08c0c310"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac4f1c7c8153d3d3ef062a2bb08c0c310">GetConnectedComponentsTpl</a> (NodeType num_nodes, const UndirectedGraph &amp;graph)</td></tr>
<tr class="separator:ac4f1c7c8153d3d3ef062a2bb08c0c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f0e8f7e15873600cf8e395958c71e1" id="r_a13f0e8f7e15873600cf8e395958c71e1"><td class="memTemplParams" colspan="2">template&lt;class UndirectedGraph &gt; </td></tr>
<tr class="memitem:a13f0e8f7e15873600cf8e395958c71e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents</a> (int num_nodes, const UndirectedGraph &amp;graph)</td></tr>
<tr class="separator:a13f0e8f7e15873600cf8e395958c71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9470623ca7db3c4a62ce3b326c6b07d8" id="r_a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memTemplParams" colspan="2">template&lt;class IntVector , class Array , class ElementType &gt; </td></tr>
<tr class="memitem:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a9470623ca7db3c4a62ce3b326c6b07d8">PermuteWithExplicitElementType</a> (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)</td></tr>
<tr class="separator:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c227a057c1ce9d46b1185abf77ad91e" id="r_a8c227a057c1ce9d46b1185abf77ad91e"><td class="memTemplParams" colspan="2">template&lt;class IntVector , class Array &gt; </td></tr>
<tr class="memitem:a8c227a057c1ce9d46b1185abf77ad91e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a8c227a057c1ce9d46b1185abf77ad91e">Permute</a> (const IntVector &amp;permutation, Array *array_to_permute)</td></tr>
<tr class="separator:a8c227a057c1ce9d46b1185abf77ad91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac497881c4166bc694adc4bee62746118" id="r_ac497881c4166bc694adc4bee62746118"><td class="memTemplParams" colspan="2">template&lt;class IntVector &gt; </td></tr>
<tr class="memitem:ac497881c4166bc694adc4bee62746118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac497881c4166bc694adc4bee62746118">Permute</a> (const IntVector &amp;permutation, std::vector&lt; bool &gt; *array_to_permute)</td></tr>
<tr class="separator:ac497881c4166bc694adc4bee62746118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37be0131ae922e30a286797a0bef0c96" id="r_a37be0131ae922e30a286797a0bef0c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a37be0131ae922e30a286797a0bef0c96">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>, Outgoing, Base::kNilArc)</td></tr>
<tr class="memdesc:a37be0131ae922e30a286797a0bef0c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a> implementation -------------------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:a37be0131ae922e30a286797a0bef0c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c40fc068f645d9dcd15c332e44fc25" id="r_af3c40fc068f645d9dcd15c332e44fc25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#af3c40fc068f645d9dcd15c332e44fc25">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>, Outgoing, DirectArcLimit(node))</td></tr>
<tr class="separator:af3c40fc068f645d9dcd15c332e44fc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3098e161a6aceeca482be78d2d221b3b" id="r_a3098e161a6aceeca482be78d2d221b3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3098e161a6aceeca482be78d2d221b3b">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, Outgoing, Base::kNilArc)</td></tr>
<tr class="memdesc:a3098e161a6aceeca482be78d2d221b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a> implementation ---------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:a3098e161a6aceeca482be78d2d221b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0ae05975a2063f2edbeb749f690fc7" id="r_a4d0ae05975a2063f2edbeb749f690fc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a4d0ae05975a2063f2edbeb749f690fc7">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, Incoming, Base::kNilArc)</td></tr>
<tr class="separator:a4d0ae05975a2063f2edbeb749f690fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b5dcc01043ab8da01ebab71ec3ad31" id="r_a22b5dcc01043ab8da01ebab71ec3ad31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a22b5dcc01043ab8da01ebab71ec3ad31">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, OutgoingOrOppositeIncoming, Base::kNilArc)</td></tr>
<tr class="separator:a22b5dcc01043ab8da01ebab71ec3ad31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ccdb51afb5ef92fe6c94188a5f7e0" id="r_a863ccdb51afb5ef92fe6c94188a5f7e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a863ccdb51afb5ef92fe6c94188a5f7e0">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, OppositeIncoming, Base::kNilArc)</td></tr>
<tr class="separator:a863ccdb51afb5ef92fe6c94188a5f7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc2a1037195d237820edc97d35404be" id="r_a2cc2a1037195d237820edc97d35404be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a2cc2a1037195d237820edc97d35404be">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, Outgoing, DirectArcLimit(node))</td></tr>
<tr class="memdesc:a2cc2a1037195d237820edc97d35404be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a> implementation -------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:a2cc2a1037195d237820edc97d35404be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51d676cd5d9354bfe1f80d09c44f39" id="r_a2a51d676cd5d9354bfe1f80d09c44f39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a2a51d676cd5d9354bfe1f80d09c44f39">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, Incoming, ReverseArcLimit(node))</td></tr>
<tr class="separator:a2a51d676cd5d9354bfe1f80d09c44f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1a919e67261878ff8abda53e664c7" id="r_a1db1a919e67261878ff8abda53e664c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a1db1a919e67261878ff8abda53e664c7">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, OutgoingOrOppositeIncoming, DirectArcLimit(node))</td></tr>
<tr class="separator:a1db1a919e67261878ff8abda53e664c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1728675285eb75f9f18d6ed7c134d0b6" id="r_a1728675285eb75f9f18d6ed7c134d0b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a1728675285eb75f9f18d6ed7c134d0b6">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, OppositeIncoming, ReverseArcLimit(node))</td></tr>
<tr class="separator:a1728675285eb75f9f18d6ed7c134d0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3308688d13e59e2351bef038ce1fdb0" id="r_ab3308688d13e59e2351bef038ce1fdb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab3308688d13e59e2351bef038ce1fdb0">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, Outgoing, DirectArcLimit(node))</td></tr>
<tr class="memdesc:ab3308688d13e59e2351bef038ce1fdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a> implementation --------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:ab3308688d13e59e2351bef038ce1fdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c022b68f68916770fe09996df2f35a3" id="r_a3c022b68f68916770fe09996df2f35a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3c022b68f68916770fe09996df2f35a3">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, Incoming, Base::kNilArc)</td></tr>
<tr class="separator:a3c022b68f68916770fe09996df2f35a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97910ddfce7560b406aa3f4939434eb8" id="r_a97910ddfce7560b406aa3f4939434eb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a97910ddfce7560b406aa3f4939434eb8">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, OutgoingOrOppositeIncoming, DirectArcLimit(node))</td></tr>
<tr class="separator:a97910ddfce7560b406aa3f4939434eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce1a67d16c75b202f56301321a457c6" id="r_a6ce1a67d16c75b202f56301321a457c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a6ce1a67d16c75b202f56301321a457c6">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, OppositeIncoming, Base::kNilArc)</td></tr>
<tr class="separator:a6ce1a67d16c75b202f56301321a457c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed79554a202aaa8bda5b5e98c3a6b2" id="r_affed79554a202aaa8bda5b5e98c3a6b2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:affed79554a202aaa8bda5b5e98c3a6b2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#affed79554a202aaa8bda5b5e98c3a6b2">GraphToString</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a> format)</td></tr>
<tr class="memdesc:affed79554a202aaa8bda5b5e98c3a6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of the templated methods.  <br /></td></tr>
<tr class="separator:affed79554a202aaa8bda5b5e98c3a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e255c1426a060140494d15add27c66" id="r_a83e255c1426a060140494d15add27c66"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a83e255c1426a060140494d15add27c66"><td class="memTemplItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a83e255c1426a060140494d15add27c66">WriteGraphToFile</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::string &amp;filename, bool directed, const std::vector&lt; int &gt; &amp;num_nodes_with_color)</td></tr>
<tr class="separator:a83e255c1426a060140494d15add27c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a4999be011343be06bd28753bf8ecc" id="r_a30a4999be011343be06bd28753bf8ecc"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a30a4999be011343be06bd28753bf8ecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a30a4999be011343be06bd28753bf8ecc">BeginEndRange</a> (Iterator <a class="el" href="strong__vector_8h.html#aeeb2d4a0b8035603af696a5c1a73d100">begin</a>, Iterator <a class="el" href="sparse__submatrix_8cc.html#a4d53eac2ef2732c28fa9fb663e0c19a7">end</a>)</td></tr>
<tr class="separator:a30a4999be011343be06bd28753bf8ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be0ef9f4566f20fbf5238b24385216" id="r_a68be0ef9f4566f20fbf5238b24385216"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a68be0ef9f4566f20fbf5238b24385216"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a68be0ef9f4566f20fbf5238b24385216">BeginEndRange</a> (std::pair&lt; Iterator, Iterator &gt; begin_end)</td></tr>
<tr class="separator:a68be0ef9f4566f20fbf5238b24385216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628255019800e5a053d08b1f0c5a05f2" id="r_a628255019800e5a053d08b1f0c5a05f2"><td class="memTemplParams" colspan="2">template&lt;typename MultiMap &gt; </td></tr>
<tr class="memitem:a628255019800e5a053d08b1f0c5a05f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a628255019800e5a053d08b1f0c5a05f2">EqualRange</a> (MultiMap &amp;multi_map, const typename MultiMap::key_type &amp;key)</td></tr>
<tr class="separator:a628255019800e5a053d08b1f0c5a05f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203f5498a7e1bc70f8ff62c0cfaaf8b1" id="r_a203f5498a7e1bc70f8ff62c0cfaaf8b1"><td class="memTemplParams" colspan="2">template&lt;typename MultiMap &gt; </td></tr>
<tr class="memitem:a203f5498a7e1bc70f8ff62c0cfaaf8b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a203f5498a7e1bc70f8ff62c0cfaaf8b1">EqualRange</a> (const MultiMap &amp;multi_map, const typename MultiMap::key_type &amp;key)</td></tr>
<tr class="separator:a203f5498a7e1bc70f8ff62c0cfaaf8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208121f27c615b309e2ab37bb85280f1" id="r_a208121f27c615b309e2ab37bb85280f1"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a208121f27c615b309e2ab37bb85280f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndReverseIteratorWrapper.html">BeginEndReverseIteratorWrapper</a>&lt; Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a208121f27c615b309e2ab37bb85280f1">Reverse</a> (const Container &amp;c)</td></tr>
<tr class="separator:a208121f27c615b309e2ab37bb85280f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49200d01f1aec6ee7837ad3e09b0d880" id="r_a49200d01f1aec6ee7837ad3e09b0d880"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49200d01f1aec6ee7837ad3e09b0d880"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a49200d01f1aec6ee7837ad3e09b0d880">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:a49200d01f1aec6ee7837ad3e09b0d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adc100d0fc2606414e4cdf062a80c97" id="r_a3adc100d0fc2606414e4cdf062a80c97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3adc100d0fc2606414e4cdf062a80c97"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3adc100d0fc2606414e4cdf062a80c97">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:a3adc100d0fc2606414e4cdf062a80c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:a3adc100d0fc2606414e4cdf062a80c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75288075e89561fd1564e40123cd7dd" id="r_ab75288075e89561fd1564e40123cd7dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab75288075e89561fd1564e40123cd7dd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab75288075e89561fd1564e40123cd7dd">TopologicalSortOrDie</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs)</td></tr>
<tr class="memdesc:ab75288075e89561fd1564e40123cd7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">OrDie() variant of the above.  <br /></td></tr>
<tr class="separator:ab75288075e89561fd1564e40123cd7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8f58bd1b46837f8305d316bb84d0e1" id="r_a9f8f58bd1b46837f8305d316bb84d0e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f8f58bd1b46837f8305d316bb84d0e1"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a9f8f58bd1b46837f8305d316bb84d0e1">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:a9f8f58bd1b46837f8305d316bb84d0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac974be3bae074c99c0d7d7a5aedbc757" id="r_ac974be3bae074c99c0d7d7a5aedbc757"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac974be3bae074c99c0d7d7a5aedbc757"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac974be3bae074c99c0d7d7a5aedbc757">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:ac974be3bae074c99c0d7d7a5aedbc757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:ac974be3bae074c99c0d7d7a5aedbc757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b0775ffcab4f306414763e156b97e5" id="r_ae8b0775ffcab4f306414763e156b97e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8b0775ffcab4f306414763e156b97e5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae8b0775ffcab4f306414763e156b97e5">StableTopologicalSortOrDie</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs)</td></tr>
<tr class="memdesc:ae8b0775ffcab4f306414763e156b97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">OrDie() variant of the above.  <br /></td></tr>
<tr class="separator:ae8b0775ffcab4f306414763e156b97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8fe0e94677e886c26ba2f3bade9a7f" id="r_afa8fe0e94677e886c26ba2f3bade9a7f"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#afa8fe0e94677e886c26ba2f3bade9a7f">FindCycleInDenseIntGraph</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="memdesc:afa8fe0e94677e886c26ba2f3bade9a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">______________________ END OF THE RECOMMENDED API ___________________________  <br /></td></tr>
<tr class="separator:afa8fe0e94677e886c26ba2f3bade9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ca9916b6307f51dd4983ffd2896ca" id="r_af88ca9916b6307f51dd4983ffd2896ca"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#af88ca9916b6307f51dd4983ffd2896ca">DenseIntTopologicalSort</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs, std::vector&lt; int &gt; *topological_order)</td></tr>
<tr class="memdesc:af88ca9916b6307f51dd4983ffd2896ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of the "simple API" functions declared at the top.  <br /></td></tr>
<tr class="separator:af88ca9916b6307f51dd4983ffd2896ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cda68f8ed2a159f060cfaafe2017e6f" id="r_a5cda68f8ed2a159f060cfaafe2017e6f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a5cda68f8ed2a159f060cfaafe2017e6f">DenseIntStableTopologicalSortOrDie</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="separator:a5cda68f8ed2a159f060cfaafe2017e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f7a974e2fa9b8cde91cbcab0242c2e" id="r_a48f7a974e2fa9b8cde91cbcab0242c2e"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a48f7a974e2fa9b8cde91cbcab0242c2e">DenseIntStableTopologicalSort</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs, std::vector&lt; int &gt; *topological_order)</td></tr>
<tr class="separator:a48f7a974e2fa9b8cde91cbcab0242c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0578f3afba5eb142e0dcca8063f6e66a" id="r_a0578f3afba5eb142e0dcca8063f6e66a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0578f3afba5eb142e0dcca8063f6e66a">DenseIntTopologicalSortOrDie</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="separator:a0578f3afba5eb142e0dcca8063f6e66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ae803e2d0270a720f294269b30fc10" id="r_ad2ae803e2d0270a720f294269b30fc10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ae803e2d0270a720f294269b30fc10"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ad2ae803e2d0270a720f294269b30fc10">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:ad2ae803e2d0270a720f294269b30fc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da65a9795112f2e6b57c9cfe950f4a3" id="r_a6da65a9795112f2e6b57c9cfe950f4a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6da65a9795112f2e6b57c9cfe950f4a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a6da65a9795112f2e6b57c9cfe950f4a3">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:a6da65a9795112f2e6b57c9cfe950f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:a6da65a9795112f2e6b57c9cfe950f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed25a07b58c38bbfba6e2912024e541" id="r_a4ed25a07b58c38bbfba6e2912024e541"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ed25a07b58c38bbfba6e2912024e541"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a4ed25a07b58c38bbfba6e2912024e541">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:a4ed25a07b58c38bbfba6e2912024e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f37ea5a316975b7039dc07929a5b65" id="r_a37f37ea5a316975b7039dc07929a5b65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37f37ea5a316975b7039dc07929a5b65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a37f37ea5a316975b7039dc07929a5b65">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:a37f37ea5a316975b7039dc07929a5b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:a37f37ea5a316975b7039dc07929a5b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c2faec725bc47baf08421b377f643" id="r_aca9c2faec725bc47baf08421b377f643"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aca9c2faec725bc47baf08421b377f643">IsSubsetOf0N</a> (absl::Span&lt; const int &gt; v, int n)</td></tr>
<tr class="separator:aca9c2faec725bc47baf08421b377f643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4af76993c891ee4ad507783edec2a1c" id="r_ac4af76993c891ee4ad507783edec2a1c"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:ac4af76993c891ee4ad507783edec2a1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac4af76993c891ee4ad507783edec2a1c">GraphHasSelfArcs</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac4af76993c891ee4ad507783edec2a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of the templated methods.  <br /></td></tr>
<tr class="separator:ac4af76993c891ee4ad507783edec2a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37593970a26f5c88b3d2ea9acea9d2" id="r_a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a6b37593970a26f5c88b3d2ea9acea9d2">GraphHasDuplicateArcs</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784b483eeae1b49164a8a02fe9c0d3ba" id="r_a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a784b483eeae1b49164a8a02fe9c0d3ba">GraphIsSymmetric</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97311561fd1f01e9f35b2f7ce18b0af3" id="r_a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a97311561fd1f01e9f35b2f7ce18b0af3">GraphIsWeaklyConnected</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed748741b17dad9e6cc485728bb0043" id="r_a0ed748741b17dad9e6cc485728bb0043"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a0ed748741b17dad9e6cc485728bb0043"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0ed748741b17dad9e6cc485728bb0043">CopyGraph</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a0ed748741b17dad9e6cc485728bb0043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fresh copy of a given graph.  <br /></td></tr>
<tr class="separator:a0ed748741b17dad9e6cc485728bb0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfecdce43e9933bde2a94fd879f12f5f" id="r_acfecdce43e9933bde2a94fd879f12f5f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:acfecdce43e9933bde2a94fd879f12f5f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#acfecdce43e9933bde2a94fd879f12f5f">RemapGraph</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::vector&lt; int &gt; &amp;new_node_index)</td></tr>
<tr class="separator:acfecdce43e9933bde2a94fd879f12f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbba6a42d616fc4fb5c9ab3afe649197" id="r_adbba6a42d616fc4fb5c9ab3afe649197"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:adbba6a42d616fc4fb5c9ab3afe649197"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#adbba6a42d616fc4fb5c9ab3afe649197">GetSubgraphOfNodes</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, absl::Span&lt; const int &gt; <a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>)</td></tr>
<tr class="separator:adbba6a42d616fc4fb5c9ab3afe649197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a31111f9a74492f1de9238e463edd2a" id="r_a8a31111f9a74492f1de9238e463edd2a"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a8a31111f9a74492f1de9238e463edd2a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a8a31111f9a74492f1de9238e463edd2a">GetWeaklyConnectedComponents</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a8a31111f9a74492f1de9238e463edd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7986b01cf61a31c09a27b4a97db6a83" id="r_ad7986b01cf61a31c09a27b4a97db6a83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ad7986b01cf61a31c09a27b4a97db6a83">IsValidPermutation</a> (const std::vector&lt; int &gt; &amp;v)</td></tr>
<tr class="memdesc:ad7986b01cf61a31c09a27b4a97db6a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given vector is a permutation of [0..size()-1].  <br /></td></tr>
<tr class="separator:ad7986b01cf61a31c09a27b4a97db6a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06031908a024a50dbdddc394a22490" id="r_a8a06031908a024a50dbdddc394a22490"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a8a06031908a024a50dbdddc394a22490"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a8a06031908a024a50dbdddc394a22490">RemoveSelfArcsAndDuplicateArcs</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a8a06031908a024a50dbdddc394a22490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of "graph", without self-arcs and duplicate arcs.  <br /></td></tr>
<tr class="separator:a8a06031908a024a50dbdddc394a22490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa201576c927d92657e090fa86bfdb" id="r_a06fa201576c927d92657e090fa86bfdb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:a06fa201576c927d92657e090fa86bfdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a06fa201576c927d92657e090fa86bfdb">RemoveCyclesFromPath</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, std::vector&lt; int &gt; *arc_path)</td></tr>
<tr class="separator:a06fa201576c927d92657e090fa86bfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb18bcb2f9d64cbbaeb57c328f57e7b" id="r_adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#adbb18bcb2f9d64cbbaeb57c328f57e7b">PathHasCycle</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::vector&lt; int &gt; &amp;arc_path)</td></tr>
<tr class="memdesc:adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given path contains a cycle.  <br /></td></tr>
<tr class="separator:adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae469c559688b92f36bae2788c2e6063e" id="r_ae469c559688b92f36bae2788c2e6063e"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </td></tr>
<tr class="memitem:ae469c559688b92f36bae2788c2e6063e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae469c559688b92f36bae2788c2e6063e">ComputeOnePossibleReverseArcMapping</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, bool die_if_not_symmetric)</td></tr>
<tr class="separator:ae469c559688b92f36bae2788c2e6063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collections of i/o utilities for the Graph classes in ./graph.h. </p>
<p>A collections of utilities for the Graph classes in ./graph.h.</p>
<p>Helper classes to make it easy to implement range-based for loops.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Finds the connected components in an undirected graph: <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">https://en.wikipedia.org/wiki/Connected_component_(graph_theory)</a></p>
<p>If you have a fixed graph where the node are dense integers, use <a class="el" href="namespaceutil.html#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents()</a>: it's very fast and uses little memory.</p>
<p>If you have a more dynamic scenario where you want to incrementally add nodes or edges and query the connectivity between them, use the [Dense]<a class="el" href="classConnectedComponentsFinder.html">ConnectedComponentsFinder</a> class, which uses the union-find algorithm aka disjoint sets: <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>.</p>
<p>Implementations of the method templates</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file defines a generic graph interface on which most algorithms can be built and provides a few efficient implementations with a fast construction time. Its design is based on the experience acquired by the Operations Research team in their various graph algorithm implementations.</p>
<p>The main ideas are:</p><ul>
<li>Graph nodes and arcs are represented by integers.</li>
<li>Node or arc annotations (weight, cost, ...) are not part of the graph class, they can be stored outside in one or more arrays and can be easily retrieved using a node or arc as an index.</li>
</ul>
<p>Terminology:</p><ul>
<li>An arc of a graph is directed and going from a tail node to a head node.</li>
<li>Some implementations also store 'reverse' arcs and can be used for undirected graph or flow-like algorithm.</li>
<li>A node or arc index is 'valid' if it represents a node or arc of the graph. The validity ranges are always [0, num_nodes()) for nodes and [0, num_arcs()) for forward arcs. Reverse arcs are elements of [-num_arcs(), 0) and are also considered valid by the implementations that store them.</li>
</ul>
<p>Provided implementations:</p><ul>
<li>ListGraph&lt;&gt; for the simplest api. Also aliased to <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">util::Graph</a>.</li>
<li>StaticGraph&lt;&gt; for performance, but require calling Build(), see below</li>
<li>CompleteGraph&lt;&gt; if you need a fully connected graph</li>
<li>CompleteBipartiteGraph&lt;&gt; if you need a fully connected bipartite graph</li>
<li>ReverseArcListGraph&lt;&gt; to add reverse arcs to ListGraph&lt;&gt;</li>
<li>ReverseArcStaticGraph&lt;&gt; to add reverse arcs to StaticGraph&lt;&gt;</li>
<li>ReverseArcMixedGraph&lt;&gt; for a smaller memory footprint</li>
</ul>
<p>Utility classes &amp; functions:</p><ul>
<li><a class="el" href="namespaceutil.html#a8c227a057c1ce9d46b1185abf77ad91e">Permute()</a> to permute an array according to a given permutation.</li>
<li>SVector&lt;&gt; vector with index range [-size(), size()) for ReverseArcGraph.</li>
</ul>
<p>Basic usage: typedef ListGraph&lt;&gt; Graph; ///&lt; Choose a graph implementation. Graph graph; for (...) { graph.AddArc(tail, head); } ... for (int node = 0; node &lt; graph.num_nodes(); ++node) { for (const int arc : graph.OutgoingArcs(node)) { head = graph.Head(arc); tail = node; ///&lt; or graph.Tail(arc) which is fast but not as much. } }</p>
<p>Iteration over the arcs touching a node:</p>
<ul>
<li>OutgoingArcs(node): All the forward arcs leaving the node.</li>
<li>IncomingArcs(node): All the forward arcs arriving at the node.</li>
</ul>
<p>And two more involved ones:</p>
<ul>
<li>OutgoingOrOppositeIncomingArcs(node): This returns both the forward arcs leaving the node (i.e. OutgoingArcs(node)) and the reverse arcs leaving the node (i.e. the opposite arcs of the ones returned by IncomingArcs(node)).</li>
<li>OppositeIncomingArcs(node): This returns the reverse arcs leaving the node.</li>
</ul>
<p>Note on iteration efficiency: When re-indexing the arcs it is not possible to have both the outgoing arcs and the incoming ones form a consecutive range.</p>
<p>It is however possible to do so for the outgoing arcs and the opposite incoming arcs. It is why the OutgoingOrOppositeIncomingArcs() and OutgoingArcs() iterations are more efficient than the IncomingArcs() one.</p>
<p>If you know the graph size in advance, this already set the number of nodes, reserve space for the arcs and check in DEBUG mode that you don't go over the bounds: Graph graph(num_nodes, arc_capacity);</p>
<p>Storing and using node annotations: vector&lt;bool&gt; is_visited(graph.num_nodes(), false); ... for (int node = 0; node &lt; graph.num_nodes(); ++node) { if (!is_visited[node]) ... }</p>
<p>Storing and using arc annotations: vector&lt;int&gt; weights; for (...) { graph.AddArc(tail, head); weights.push_back(arc_weight); } ... for (const int arc : graph.OutgoingArcs(node)) { ... weights[arc] ...; }</p>
<p>More efficient version: typedef StaticGraph&lt;&gt; Graph; Graph graph(num_nodes, arc_capacity); ///&lt; Optional, but help memory usage. vector&lt;int&gt; weights; weights.reserve(arc_capacity); ///&lt; Optional, but help memory usage. for (...) { graph.AddArc(tail, head); weights.push_back(arc_weight); } ... vector&lt;Graph::ArcIndex&gt; permutation; graph.Build(&amp;permutation); ///&lt; A static graph must be Build() before usage. Permute(permutation, &amp;weights); ///&lt; Build() may permute the arc index. ...</p>
<p>Encoding an undirected graph: If you don't need arc annotation, then the best is to add two arcs for each edge (one in each direction) to a directed graph. Otherwise you can do the following.</p>
<p>typedef ReverseArc... Graph; Graph graph; for (...) { graph.AddArc(tail, head); ///&lt; or graph.AddArc(head, tail) but not both. edge_annotations.push_back(value); } ... for (const <a class="el" href="classutil_1_1BaseGraph.html#adb271cf4bcf2de5b5bbe300d7054af29">Graph::NodeIndex</a> node : graph.AllNodes()) { for (const <a class="el" href="classutil_1_1BaseGraph.html#a0eba6e5899924388644dfa2258ae8929">Graph::ArcIndex</a> arc : graph.OutgoingOrOppositeIncomingArcs(node)) { destination = graph.Head(arc); annotation = edge_annotations[arc &lt; 0 ? graph.OppositeArc(arc) : arc]; } }</p>
<dl class="section note"><dt>Note</dt><dd>The graphs are primarily designed to be constructed first and then used because it covers most of the use cases. It is possible to extend the interface with more dynamicity (like removing arcs), but this is not done at this point. Note that a "dynamic" implementation will break some assumptions we make on what node or arc are valid and also on the indices returned by AddArc(). Some arguments for simplifying the interface at the cost of dynamicity are:</dd></dl>
<ul>
<li>It is always possible to construct a static graph from a dynamic one before calling a complex algo.</li>
<li>If you really need a dynamic graph, maybe it is better to compute a graph property incrementally rather than calling an algorithm that starts from scratch each time.</li>
</ul>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file provides topologically sorted traversal of the nodes of a directed acyclic graph (DAG) with up to INT_MAX nodes. It sorts ancestor nodes before their descendants. Multi-arcs are fine.</p>
<p>If your graph is not a DAG and you're reading this, you are probably looking for <a class="el" href="strongly__connected__components_8h.html">ortools/graph/strongly_connected_components.h</a> which does the topological decomposition of a directed graph.</p>
<p>USAGE:</p><ul>
<li>If performance matters, use FastTopologicalSort().</li>
<li>If your nodes are non-integers, or you need to break topological ties by node index (like "stable_sort"), use one of the <a class="el" href="namespaceutil.html#af88ca9916b6307f51dd4983ffd2896ca" title="Implementations of the &quot;simple API&quot; functions declared at the top.">DenseIntTopologicalSort()</a> or TopologicalSort variants (see below).</li>
<li>If you need more control (cycle extraction?), or a step-by-step topological sort, see the <a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> classes below. </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab8ee3a3e236b0c89bb6e89d7f0a069f0" name="ab8ee3a3e236b0c89bb6e89d7f0a069f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ee3a3e236b0c89bb6e89d7f0a069f0">&#9670;&#160;</a></span>DenseIntStableTopologicalSorter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; true&gt; <a class="el" href="namespaceutil.html#ab8ee3a3e236b0c89bb6e89d7f0a069f0">util::DenseIntStableTopologicalSorter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recommended version for general usage. The stability makes it more deterministic, and its behavior is guaranteed to never change. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00287">287</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a0e9be35eb706de2777ef8b80262a293a" name="a0e9be35eb706de2777ef8b80262a293a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9be35eb706de2777ef8b80262a293a">&#9670;&#160;</a></span>DenseIntTopologicalSorter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; false&gt; <a class="el" href="namespaceutil.html#a0e9be35eb706de2777ef8b80262a293a">util::DenseIntTopologicalSorter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this version if you are certain you don't care about the tie-breaking order and need the 5 to 10% performance gain. The performance gain can be more significant for large graphs with large numbers of source nodes (for example 2 Million nodes with 2 Million random edges sees a factor of 0.7 difference in completion time). </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00296">296</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ae76339cb2dcd3bc05ad762146f91fdda" name="ae76339cb2dcd3bc05ad762146f91fdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76339cb2dcd3bc05ad762146f91fdda">&#9670;&#160;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1ListGraph.html">ListGraph</a> <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">util::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defining the simplest Graph interface as Graph for convenience. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l02407">2407</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae705e1342dacc10a13fb3f11f91d0696" name="ae705e1342dacc10a13fb3f11f91d0696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae705e1342dacc10a13fb3f11f91d0696">&#9670;&#160;</a></span>GraphToStringFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">util::GraphToStringFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a graph. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd" name="ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd"></a>PRINT_GRAPH_ARCS&#160;</td><td class="fielddoc"><p>One arc per line, eg. "3-&gt;1". </p>
</td></tr>
<tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565" name="ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565"></a>PRINT_GRAPH_ADJACENCY_LISTS&#160;</td><td class="fielddoc"><p>One space-separated adjacency list per line, eg. "3: 5 1 3 1". Nodes with no outgoing arc get an empty list. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef" name="ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef"></a>PRINT_GRAPH_ADJACENCY_LISTS_SORTED&#160;</td><td class="fielddoc"><p>Ditto, but the adjacency lists are sorted. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00039">39</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6c7131ba28e4222397d1cdb048da94d7" name="a6c7131ba28e4222397d1cdb048da94d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7131ba28e4222397d1cdb048da94d7">&#9670;&#160;</a></span>AbortedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::AbortedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00079">79</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a9f0f7d99f534361679bd82e09a56c30a" name="a9f0f7d99f534361679bd82e09a56c30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0f7d99f534361679bd82e09a56c30a">&#9670;&#160;</a></span>AlreadyExistsErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::AlreadyExistsErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00083">83</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a30a4999be011343be06bd28753bf8ecc" name="a30a4999be011343be06bd28753bf8ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a4999be011343be06bd28753bf8ecc">&#9670;&#160;</a></span>BeginEndRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt; util::BeginEndRange </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inline wrapper methods, to make the client code even simpler. The harm of overloading is probably less than the benefit of the nice, compact name, in this special case. </p>

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00059">59</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="a68be0ef9f4566f20fbf5238b24385216" name="a68be0ef9f4566f20fbf5238b24385216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68be0ef9f4566f20fbf5238b24385216">&#9670;&#160;</a></span>BeginEndRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt; util::BeginEndRange </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; Iterator, Iterator &gt;&#160;</td>
          <td class="paramname"><em>begin_end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00063">63</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="aac4135532bf8cf1a7559e12f568d54d1" name="aac4135532bf8cf1a7559e12f568d54d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4135532bf8cf1a7559e12f568d54d1">&#9670;&#160;</a></span>CancelledErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::CancelledErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00087">87</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="ae469c559688b92f36bae2788c2e6063e" name="ae469c559688b92f36bae2788c2e6063e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae469c559688b92f36bae2788c2e6063e">&#9670;&#160;</a></span>ComputeOnePossibleReverseArcMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::ComputeOnePossibleReverseArcMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>die_if_not_symmetric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector representing a mapping from arcs to arcs such that each arc is mapped to another arc with its (tail, head) flipped, if such an arc exists (otherwise it is mapped to -1). If the graph is symmetric, the returned mapping is bijective and reflexive, i.e. out[out[arc]] = arc for all "arc", where "out" is the returned vector. If "die_if_not_symmetric" is true, this function CHECKs() that the graph is symmetric.</p>
<p>Self-arcs are always mapped to themselves.</p>
<dl class="section note"><dt>Note</dt><dd>since graphs may have multi-arcs, the mapping isn't necessarily unique, hence the function name.</dd></dl>
<p>PERFORMANCE: If you see this function taking too much memory and/or too much time, reach out to viger@: one could halve the memory usage and speed it up. </p>
<p>We need a multi-map since a given (tail,head) may appear several times. NOTE(user): It's free, in terms of space, to use InlinedVector&lt;int, 4&gt; rather than std::vector&lt;int&gt;.</p>
<p>Special case: directly map any self-arc to itself.</p>
<p>Lookup for the reverse arc of the current one...</p>
<p>Found a reverse arc! Store the mapping and remove the reverse arc from the map.</p>
<p>Reverse arc not in the map. Add the current arc to the map.</p>
<p>Algorithm check, for debugging.</p>
<p>We need a multi-map since a given (tail,head) may appear several times. NOTE(user): It's free, in terms of space, to use InlinedVector&lt;int, 4&gt; rather than std::vector&lt;int&gt;.</p>
<p>Special case: directly map any self-arc to itself.</p>
<p>Lookup for the reverse arc of the current one...</p>
<p>Found a reverse arc! Store the mapping and remove the reverse arc from the map.</p>
<p>Reverse arc not in the map. Add the current arc to the map.</p>
<p>Algorithm check, for debugging.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00390">390</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a0ed748741b17dad9e6cc485728bb0043" name="a0ed748741b17dad9e6cc485728bb0043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed748741b17dad9e6cc485728bb0043">&#9670;&#160;</a></span>CopyGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::CopyGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a fresh copy of a given graph. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00266">266</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a5a8b955fd01d92c38c96d50dd7b36fa9" name="a5a8b955fd01d92c38c96d50dd7b36fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8b955fd01d92c38c96d50dd7b36fa9">&#9670;&#160;</a></span>DataLossErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::DataLossErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00091">91</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="ae6967409cb3e0a291eda5807f3edf796" name="ae6967409cb3e0a291eda5807f3edf796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6967409cb3e0a291eda5807f3edf796">&#9670;&#160;</a></span>DeadlineExceededErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::DeadlineExceededErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00095">95</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a37be0131ae922e30a286797a0bef0c96" name="a37be0131ae922e30a286797a0bef0c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37be0131ae922e30a286797a0bef0c96">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a> implementation -------------------------------------------------&mdash;. </p>

</div>
</div>
<a id="a4d0ae05975a2063f2edbeb749f690fc7" name="a4d0ae05975a2063f2edbeb749f690fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0ae05975a2063f2edbeb749f690fc7">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a863ccdb51afb5ef92fe6c94188a5f7e0" name="a863ccdb51afb5ef92fe6c94188a5f7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ccdb51afb5ef92fe6c94188a5f7e0">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3098e161a6aceeca482be78d2d221b3b" name="a3098e161a6aceeca482be78d2d221b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3098e161a6aceeca482be78d2d221b3b">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a> implementation ---------------------------------------&mdash;. </p>

</div>
</div>
<a id="a22b5dcc01043ab8da01ebab71ec3ad31" name="a22b5dcc01043ab8da01ebab71ec3ad31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b5dcc01043ab8da01ebab71ec3ad31">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c022b68f68916770fe09996df2f35a3" name="a3c022b68f68916770fe09996df2f35a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c022b68f68916770fe09996df2f35a3">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ce1a67d16c75b202f56301321a457c6" name="a6ce1a67d16c75b202f56301321a457c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce1a67d16c75b202f56301321a457c6">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3308688d13e59e2351bef038ce1fdb0" name="ab3308688d13e59e2351bef038ce1fdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3308688d13e59e2351bef038ce1fdb0">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a> implementation --------------------------------------&mdash;. </p>

</div>
</div>
<a id="a97910ddfce7560b406aa3f4939434eb8" name="a97910ddfce7560b406aa3f4939434eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97910ddfce7560b406aa3f4939434eb8">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a51d676cd5d9354bfe1f80d09c44f39" name="a2a51d676cd5d9354bfe1f80d09c44f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a51d676cd5d9354bfe1f80d09c44f39">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReverseArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1728675285eb75f9f18d6ed7c134d0b6" name="a1728675285eb75f9f18d6ed7c134d0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1728675285eb75f9f18d6ed7c134d0b6">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReverseArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc2a1037195d237820edc97d35404be" name="a2cc2a1037195d237820edc97d35404be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc2a1037195d237820edc97d35404be">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a> implementation -------------------------------------&mdash;. </p>

</div>
</div>
<a id="a1db1a919e67261878ff8abda53e664c7" name="a1db1a919e67261878ff8abda53e664c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1a919e67261878ff8abda53e664c7">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3c40fc068f645d9dcd15c332e44fc25" name="af3c40fc068f645d9dcd15c332e44fc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c40fc068f645d9dcd15c332e44fc25">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f7a974e2fa9b8cde91cbcab0242c2e" name="a48f7a974e2fa9b8cde91cbcab0242c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f7a974e2fa9b8cde91cbcab0242c2e">&#9670;&#160;</a></span>DenseIntStableTopologicalSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::DenseIntStableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00523">523</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a5cda68f8ed2a159f060cfaafe2017e6f" name="a5cda68f8ed2a159f060cfaafe2017e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cda68f8ed2a159f060cfaafe2017e6f">&#9670;&#160;</a></span>DenseIntStableTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::DenseIntStableTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00568">568</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="af88ca9916b6307f51dd4983ffd2896ca" name="af88ca9916b6307f51dd4983ffd2896ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88ca9916b6307f51dd4983ffd2896ca">&#9670;&#160;</a></span>DenseIntTopologicalSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::DenseIntTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of the "simple API" functions declared at the top. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>DenseInt[Stable]TopologicalSort[OrDie]. Kept here for legacy reasons, but most new users should use FastTopologicalSort():<ul>
<li>If your input is a list of edges, build you own StaticGraph&lt;&gt; (see ./graph.h) and pass it to FastTopologicalSort().</li>
<li>If you need the "stable sort" bit, contact viger@ and/or or-core-team@ to see if they can create FastStableTopologicalSort(). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00516">516</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a0578f3afba5eb142e0dcca8063f6e66a" name="a0578f3afba5eb142e0dcca8063f6e66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0578f3afba5eb142e0dcca8063f6e66a">&#9670;&#160;</a></span>DenseIntTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::DenseIntTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00563">563</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a203f5498a7e1bc70f8ff62c0cfaaf8b1" name="a203f5498a7e1bc70f8ff62c0cfaaf8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203f5498a7e1bc70f8ff62c0cfaaf8b1">&#9670;&#160;</a></span>EqualRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MultiMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::const_iterator &gt; util::EqualRange </td>
          <td>(</td>
          <td class="paramtype">const MultiMap &amp;&#160;</td>
          <td class="paramname"><em>multi_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MultiMap::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00077">77</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="a628255019800e5a053d08b1f0c5a05f2" name="a628255019800e5a053d08b1f0c5a05f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628255019800e5a053d08b1f0c5a05f2">&#9670;&#160;</a></span>EqualRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MultiMap &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::iterator &gt; util::EqualRange </td>
          <td>(</td>
          <td class="paramtype">MultiMap &amp;&#160;</td>
          <td class="paramname"><em>multi_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MultiMap::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shortcut for BeginEndRange(multimap::equal_range(key)). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000632">Todo:</a></b></dt><dd>(user): go further and expose only the values, not the pairs (key, values) since the caller already knows the key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00072">72</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="aeb73fb4c4369ff7beb4a819f3cc5831c" name="aeb73fb4c4369ff7beb4a819f3cc5831c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb73fb4c4369ff7beb4a819f3cc5831c">&#9670;&#160;</a></span>FailedPreconditionErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::FailedPreconditionErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00099">99</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="afa8fe0e94677e886c26ba2f3bade9a7f" name="afa8fe0e94677e886c26ba2f3bade9a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8fe0e94677e886c26ba2f3bade9a7f">&#9670;&#160;</a></span>FindCycleInDenseIntGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT std::vector&lt; int &gt; util::FindCycleInDenseIntGraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>______________________ END OF THE RECOMMENDED API ___________________________ </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespaceutil_1_1graph.html#a440afdf238e5a752bbe4e1bcc8878fe7">util::graph::FindCycleInGraph()</a> directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00144">144</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a13f0e8f7e15873600cf8e395958c71e1" name="a13f0e8f7e15873600cf8e395958c71e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f0e8f7e15873600cf8e395958c71e1">&#9670;&#160;</a></span>GetConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UndirectedGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::GetConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UndirectedGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the connected components of the graph, using BFS internally. Works on any <em>undirected</em> graph class whose nodes are dense integers and that supports the [] operator for adjacency lists: graph[x] must be an integer container listing the nodes that are adjacent to node #x. Example: std::vector&lt;std::vector&lt;int&gt;&gt;.</p>
<p>"Undirected" means that for all y in graph[x], x is in graph[y].</p>
<p>Returns the mapping from node to component index. The component indices are deterministic: Component #0 will be the one that has node #0, component #1 the one that has the lowest-index node that isn't in component #0, and so on.</p>
<p>Example on the following 6-node graph: 5&ndash;3&ndash;0&ndash;1 2&ndash;4 vector&lt;vector&lt;int&gt;&gt; graph = {{1, 3}, {0}, {4}, {0, 5}, {2}, {3}}; GetConnectedComponents(graph); ///&lt; returns [0, 0, 1, 0, 1, 0]. </p>

<p class="definition">Definition at line <a class="el" href="connected__components_8h_source.html#l00078">78</a> of file <a class="el" href="connected__components_8h_source.html">connected_components.h</a>.</p>

</div>
</div>
<a id="ac4f1c7c8153d3d3ef062a2bb08c0c310" name="ac4f1c7c8153d3d3ef062a2bb08c0c310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f1c7c8153d3d3ef062a2bb08c0c310">&#9670;&#160;</a></span>GetConnectedComponentsTpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UndirectedGraph , class NodeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; util::GetConnectedComponentsTpl </td>
          <td>(</td>
          <td class="paramtype">NodeType&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UndirectedGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic version of <a class="el" href="namespaceutil.html#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents()</a> (see below) that supports other integer types, e.g. int64_t for huge graphs with more than 2^31 nodes. </p>
<p>We use 'num_nodes' as special component id meaning 'unknown', because it's of the right type, and -1 is tricky to use with unsigned ints.</p>
<p>We use 'num_nodes' as special component id meaning 'unknown', because it's of the right type, and -1 is tricky to use with unsigned ints.</p>

<p class="definition">Definition at line <a class="el" href="connected__components_8h_source.html#l00333">333</a> of file <a class="el" href="connected__components_8h_source.html">connected_components.h</a>.</p>

</div>
</div>
<a id="adbba6a42d616fc4fb5c9ab3afe649197" name="adbba6a42d616fc4fb5c9ab3afe649197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbba6a42d616fc4fb5c9ab3afe649197">&#9670;&#160;</a></span>GetSubgraphOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::GetSubgraphOfNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the induced subgraph of "graph" restricted to the nodes in "nodes": the resulting graph will have exactly nodes.size() nodes, and its node #0 will be the former graph's node <a class="el" href="routing__search_8cc.html#a6b7983ccd32c86cbbc3d4d9cda4cac17">nodes</a>[0], etc. See <a href="https://en.wikipedia.org/wiki/Induced_subgraph">https://en.wikipedia.org/wiki/Induced_subgraph</a> . The "nodes" must be a valid subset (no repetitions) of [0..graph.num_nodes()-1], or the behavior is undefined (it may die). </p><dl class="section note"><dt>Note</dt><dd>you can call <a class="el" href="namespaceutil.html#aca9c2faec725bc47baf08421b377f643">IsSubsetOf0N()</a> to check it yourself.</dd></dl>
<p>Current complexity: O(num old nodes + num new arcs). It could easily be done in O(num new nodes + num new arcs) but with a higher constant. </p>
<p>Do a first pass to count the arcs, so that we don't allocate more memory than needed.</p>
<p>A second pass where we actually copy the subgraph. NOTE(user): there might seem to be a bit of duplication with RemapGraph(), but there is a key difference: the loop below only iterates on "nodes", which could be much smaller than all the graph's nodes.</p>
<p>Do a first pass to count the arcs, so that we don't allocate more memory than needed.</p>
<p>A second pass where we actually copy the subgraph. NOTE(user): there might seem to be a bit of duplication with RemapGraph(), but there is a key difference: the loop below only iterates on "nodes", which could be much smaller than all the graph's nodes.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00298">298</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a8a31111f9a74492f1de9238e463edd2a" name="a8a31111f9a74492f1de9238e463edd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a31111f9a74492f1de9238e463edd2a">&#9670;&#160;</a></span>GetWeaklyConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::GetWeaklyConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the weakly connected components of a directed graph that provides the OutgoingOrOppositeIncomingArcs() API, and returns them as a mapping from node to component index. See <a class="el" href="namespaceutil.html#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents()</a>. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00137">137</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a6b37593970a26f5c88b3d2ea9acea9d2" name="a6b37593970a26f5c88b3d2ea9acea9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b37593970a26f5c88b3d2ea9acea9d2">&#9670;&#160;</a></span>GraphHasDuplicateArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphHasDuplicateArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00203">203</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ac4af76993c891ee4ad507783edec2a1c" name="ac4af76993c891ee4ad507783edec2a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4af76993c891ee4ad507783edec2a1c">&#9670;&#160;</a></span>GraphHasSelfArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphHasSelfArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementations of the templated methods. </p>
<p>Here's a set of simple diagnosis tools. Notes:</p><ul>
<li>A self-arc is an arc from a node to itself.</li>
<li>We say that an arc A-&gt;B is duplicate when there is another arc A-&gt;B in the same graph.</li>
<li>A graph is said "weakly connected" if it is connected when considering all arcs as undirected edges.</li>
<li>A graph is said "symmetric" iff for all (a, b), the number of arcs a-&gt;b is equal to the number of arcs b-&gt;a.</li>
</ul>
<p>All these diagnosis work in O(graph size), since the inverse Ackerman function is &lt;= 5 for all practical instances, and are very fast.</p>
<p>If the graph is a "static" kind, they must be finalized, except for <a class="el" href="namespaceutil.html#ac4af76993c891ee4ad507783edec2a1c" title="Implementations of the templated methods.">GraphHasSelfArcs()</a> and <a class="el" href="namespaceutil.html#a97311561fd1f01e9f35b2f7ce18b0af3">GraphIsWeaklyConnected()</a> which also support non-finalized StaticGraph&lt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00195">195</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a784b483eeae1b49164a8a02fe9c0d3ba" name="a784b483eeae1b49164a8a02fe9c0d3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784b483eeae1b49164a8a02fe9c0d3ba">&#9670;&#160;</a></span>GraphIsSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphIsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a reverse copy of the graph.</p>
<p>Compare the graph to its reverse, one adjacency list at a time.</p>
<p>Create a reverse copy of the graph.</p>
<p>Compare the graph to its reverse, one adjacency list at a time.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00221">221</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a97311561fd1f01e9f35b2f7ce18b0af3" name="a97311561fd1f01e9f35b2f7ce18b0af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97311561fd1f01e9f35b2f7ce18b0af3">&#9670;&#160;</a></span>GraphIsWeaklyConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphIsWeaklyConnected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00250">250</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="affed79554a202aaa8bda5b5e98c3a6b2" name="affed79554a202aaa8bda5b5e98c3a6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affed79554a202aaa8bda5b5e98c3a6b2">&#9670;&#160;</a></span>GraphToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string util::GraphToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementations of the templated methods. </p>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00073">73</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="a302ee4bfcb86ea9ed64a193ed0b14648" name="a302ee4bfcb86ea9ed64a193ed0b14648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302ee4bfcb86ea9ed64a193ed0b14648">&#9670;&#160;</a></span>InternalErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::InternalErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00103">103</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="ad0c886e6b95bc531d4a39884a87c0101" name="ad0c886e6b95bc531d4a39884a87c0101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c886e6b95bc531d4a39884a87c0101">&#9670;&#160;</a></span>InvalidArgumentErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::InvalidArgumentErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00107">107</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="aca9c2faec725bc47baf08421b377f643" name="aca9c2faec725bc47baf08421b377f643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c2faec725bc47baf08421b377f643">&#9670;&#160;</a></span>IsSubsetOf0N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool util::IsSubsetOf0N </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the given vector is a subset of [0..n-1], i.e. all elements i are such that 0 &lt;= i &lt; n and no two elements are equal. "n" must be &gt;= 0 or the result is undefined. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8cc_source.html#l00022">22</a> of file <a class="el" href="graph_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="ad7986b01cf61a31c09a27b4a97db6a83" name="ad7986b01cf61a31c09a27b4a97db6a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7986b01cf61a31c09a27b4a97db6a83">&#9670;&#160;</a></span>IsValidPermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::IsValidPermutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the given vector is a permutation of [0..size()-1]. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00148">148</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="afe1146d4103ad0b93801f626715519d6" name="afe1146d4103ad0b93801f626715519d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1146d4103ad0b93801f626715519d6">&#9670;&#160;</a></span>NotFoundErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::NotFoundErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00111">111</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="aa86ac164f0f951fca26cc3e9b34d9632" name="aa86ac164f0f951fca26cc3e9b34d9632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86ac164f0f951fca26cc3e9b34d9632">&#9670;&#160;</a></span>OutOfRangeErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::OutOfRangeErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00115">115</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="adbb18bcb2f9d64cbbaeb57c328f57e7b" name="adbb18bcb2f9d64cbbaeb57c328f57e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb18bcb2f9d64cbbaeb57c328f57e7b">&#9670;&#160;</a></span>PathHasCycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::PathHasCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>arc_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the given path contains a cycle. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00379">379</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ab85d86fd35e985c0fb4c4a200d72adda" name="ab85d86fd35e985c0fb4c4a200d72adda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85d86fd35e985c0fb4c4a200d72adda">&#9670;&#160;</a></span>PermissionDeniedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::PermissionDeniedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00119">119</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a8c227a057c1ce9d46b1185abf77ad91e" name="a8c227a057c1ce9d46b1185abf77ad91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c227a057c1ce9d46b1185abf77ad91e">&#9670;&#160;</a></span>Permute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector , class Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::Permute </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>array_to_permute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00758">758</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ac497881c4166bc694adc4bee62746118" name="ac497881c4166bc694adc4bee62746118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac497881c4166bc694adc4bee62746118">&#9670;&#160;</a></span>Permute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::Permute </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>array_to_permute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We need a specialization for vector&lt;bool&gt;, because the default code uses (*array_to_permute)[0] as ElementType, which isn't 'bool' in that case. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00769">769</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a9470623ca7db3c4a62ce3b326c6b07d8" name="a9470623ca7db3c4a62ce3b326c6b07d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9470623ca7db3c4a62ce3b326c6b07d8">&#9670;&#160;</a></span>PermuteWithExplicitElementType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector , class Array , class ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::PermuteWithExplicitElementType </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>array_to_permute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permutes the elements of array_to_permute: element #i will be moved to position permutation[i]. permutation must be either empty (in which case nothing happens), or a permutation of [0, permutation.size()).</p>
<p>The algorithm is fast but need extra memory for a copy of the permuted part of array_to_permute.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000608">Todo:</a></b></dt><dd>(user): consider slower but more memory efficient implementations that follow the cycles of the permutation and use a bitmap to indicate what has been permuted or to mark the beginning of each cycle. </dd></dl>
<p>Some compiler do not know typeof(), so we have to use this extra function internally. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00745">745</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="acfecdce43e9933bde2a94fd879f12f5f" name="acfecdce43e9933bde2a94fd879f12f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfecdce43e9933bde2a94fd879f12f5f">&#9670;&#160;</a></span>RemapGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::RemapGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a remapped copy of graph "graph", where node i becomes node new_node_index[i]. "new_node_index" must be a valid permutation of [0..num_nodes-1] or the behavior is undefined (it may die). </p><dl class="section note"><dt>Note</dt><dd>you can call <a class="el" href="namespaceutil.html#ad7986b01cf61a31c09a27b4a97db6a83" title="Returns true iff the given vector is a permutation of [0..size()-1].">IsValidPermutation()</a> to check it yourself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00279">279</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a06fa201576c927d92657e090fa86bfdb" name="a06fa201576c927d92657e090fa86bfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fa201576c927d92657e090fa86bfdb">&#9670;&#160;</a></span>RemoveCyclesFromPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::RemoveCyclesFromPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>arc_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an arc path, changes it to a sub-path with the same source and destination but without any cycle. Nothing happen if the path was already without cycle.</p>
<p>The graph class should support Tail(arc) and Head(arc). They should both return an integer representing the corresponding tail/head of the passed arc.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000699">Todo:</a></b></dt><dd>(user): In some cases, there is more than one possible solution. We could take some arc costs and return the cheapest path instead. Or return the shortest path in term of number of arcs. </dd></dl>
<p>This maps each node to the latest arc in the given path that leaves it.</p>
<p>Special case for the destination. </p><dl class="section note"><dt>Note</dt><dd>this requires that -1 is not a valid arc of Graph.</dd></dl>
<p>Reconstruct the path by starting at the source and then following the "next" arcs. We override the given arc_path at the same time.</p>
<p>This maps each node to the latest arc in the given path that leaves it.</p>
<p>Special case for the destination. </p><dl class="section note"><dt>Note</dt><dd>this requires that -1 is not a valid arc of Graph.</dd></dl>
<p>Reconstruct the path by starting at the source and then following the "next" arcs. We override the given arc_path at the same time.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00354">354</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a8a06031908a024a50dbdddc394a22490" name="a8a06031908a024a50dbdddc394a22490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a06031908a024a50dbdddc394a22490">&#9670;&#160;</a></span>RemoveSelfArcsAndDuplicateArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::RemoveSelfArcsAndDuplicateArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of "graph", without self-arcs and duplicate arcs. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00332">332</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a007b8813fdd1c082efc4e08fbcb8a83e" name="a007b8813fdd1c082efc4e08fbcb8a83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007b8813fdd1c082efc4e08fbcb8a83e">&#9670;&#160;</a></span>ResourceExhaustedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::ResourceExhaustedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00127">127</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a208121f27c615b309e2ab37bb85280f1" name="a208121f27c615b309e2ab37bb85280f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208121f27c615b309e2ab37bb85280f1">&#9670;&#160;</a></span>Reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndReverseIteratorWrapper.html">BeginEndReverseIteratorWrapper</a>&lt; Container &gt; util::Reverse </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00099">99</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="a9f8f58bd1b46837f8305d316bb84d0e1" name="a9f8f58bd1b46837f8305d316bb84d0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8f58bd1b46837f8305d316bb84d0e1">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "Stable" variants are a little slower but preserve the input order of nodes, if possible. More precisely, the returned topological order will be the lexicographically minimal valid order, where "lexicographic" applies to the indices of the nodes. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00547">547</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a4ed25a07b58c38bbfba6e2912024e541" name="a4ed25a07b58c38bbfba6e2912024e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed25a07b58c38bbfba6e2912024e541">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "Stable" variants are a little slower but preserve the input order of nodes, if possible. More precisely, the returned topological order will be the lexicographically minimal valid order, where "lexicographic" applies to the indices of the nodes. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00547">547</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ac974be3bae074c99c0d7d7a5aedbc757" name="ac974be3bae074c99c0d7d7a5aedbc757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac974be3bae074c99c0d7d7a5aedbc757">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00555">555</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a37f37ea5a316975b7039dc07929a5b65" name="a37f37ea5a316975b7039dc07929a5b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f37ea5a316975b7039dc07929a5b65">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00555">555</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ae8b0775ffcab4f306414763e156b97e5" name="ae8b0775ffcab4f306414763e156b97e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b0775ffcab4f306414763e156b97e5">&#9670;&#160;</a></span>StableTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; util::StableTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OrDie() variant of the above. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00580">580</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a49200d01f1aec6ee7837ad3e09b0d880" name="a49200d01f1aec6ee7837ad3e09b0d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49200d01f1aec6ee7837ad3e09b0d880">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[Stable]TopologicalSort[OrDie]:</p>
<p>These variants are much slower than FastTopologicalSort(), but support non-integer (or integer, but sparse) nodes. </p><dl class="section note"><dt>Note</dt><dd>if performance matters, you're probably better off building your own mapping from node to dense index with a flat_hash_map and calling FastTopologicalSort(). Returns true if the graph was a DAG, and outputs the topological order in "topological_order". Returns false if the graph is cyclic, and outputs the detected cycle in "cycle". </dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00531">531</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ad2ae803e2d0270a720f294269b30fc10" name="ad2ae803e2d0270a720f294269b30fc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ae803e2d0270a720f294269b30fc10">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[Stable]TopologicalSort[OrDie]:</p>
<p>These variants are much slower than FastTopologicalSort(), but support non-integer (or integer, but sparse) nodes. </p><dl class="section note"><dt>Note</dt><dd>if performance matters, you're probably better off building your own mapping from node to dense index with a flat_hash_map and calling FastTopologicalSort(). Returns true if the graph was a DAG, and outputs the topological order in "topological_order". Returns false if the graph is cyclic, and outputs the detected cycle in "cycle". </dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00531">531</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a3adc100d0fc2606414e4cdf062a80c97" name="a3adc100d0fc2606414e4cdf062a80c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adc100d0fc2606414e4cdf062a80c97">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00539">539</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a6da65a9795112f2e6b57c9cfe950f4a3" name="a6da65a9795112f2e6b57c9cfe950f4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da65a9795112f2e6b57c9cfe950f4a3">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>topological_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00539">539</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ab75288075e89561fd1564e40123cd7dd" name="ab75288075e89561fd1564e40123cd7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75288075e89561fd1564e40123cd7dd">&#9670;&#160;</a></span>TopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; util::TopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OrDie() variant of the above. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00574">574</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a5bf5136a95272248cacae1d1a036e8ea" name="a5bf5136a95272248cacae1d1a036e8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf5136a95272248cacae1d1a036e8ea">&#9670;&#160;</a></span>UnauthenticatedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnauthenticatedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00123">123</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a5532f9a3e8b48bd067e8576789fe36bc" name="a5532f9a3e8b48bd067e8576789fe36bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5532f9a3e8b48bd067e8576789fe36bc">&#9670;&#160;</a></span>UnavailableErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnavailableErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00131">131</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a34739da67ea599226350b0cb5d1cbad6" name="a34739da67ea599226350b0cb5d1cbad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34739da67ea599226350b0cb5d1cbad6">&#9670;&#160;</a></span>UnimplementedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnimplementedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00135">135</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a23561d268e106df9d3aeba1897ab3c2a" name="a23561d268e106df9d3aeba1897ab3c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23561d268e106df9d3aeba1897ab3c2a">&#9670;&#160;</a></span>UnknownErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnknownErrorBuilder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00139">139</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a83e255c1426a060140494d15add27c66" name="a83e255c1426a060140494d15add27c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e255c1426a060140494d15add27c66">&#9670;&#160;</a></span>WriteGraphToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::Status util::WriteGraphToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_nodes_with_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a graph to the ".g" file format described above. If "directed" is true, all arcs are written to the file. If it is false, the graph is expected to be undirected (i.e. the number of arcs a-&gt;b is equal to the number of arcs b-&gt;a for all nodes a,b); and only the arcs a-&gt;b where a&lt;=b are written. Note however that in this case, the symmetry of the graph is not fully checked (only the parity of the number of non-self arcs is).</p>
<p>"num_nodes_with_color" is optional. If it is not empty, then the color information will be written to the header of the .g file. See ReadGraphFile.</p>
<p>This method is the reverse of ReadGraphFile (with the same value for "directed"). </p>
<p>In undirected mode, we must count the self-arcs separately. All other arcs should be duplicated.</p>
<p>In undirected mode, we must count the self-arcs separately. All other arcs should be duplicated.</p>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00098">98</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutil.html">util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
