<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceutil.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A collections of i/o utilities for the <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> classes in ./graph.h.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1graph.html">graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1BaseGraph.html">BaseGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1BeginEndReverseIteratorWrapper.html">BeginEndReverseIteratorWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1CompleteBipartiteGraph.html">CompleteBipartiteGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1CompleteGraph.html">CompleteGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1FlowGraph.html">FlowGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntegerRange.html">IntegerRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1IntegerRangeIterator.html">IntegerRangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple iterator on an integer range, see <a class="el" href="classutil_1_1IntegerRange.html">IntegerRange</a> below.  <a href="classutil_1_1IntegerRangeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1MutableVectorIteration.html">MutableVectorIteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow iterating over a vector&lt;T&gt; as a mutable vector&lt;T*&gt;.  <a href="structutil_1_1MutableVectorIteration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1SVector.html">SVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classutil_1_1SVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1UndirectedAdjacencyListsOfDirectedGraph.html">UndirectedAdjacencyListsOfDirectedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae76339cb2dcd3bc05ad762146f91fdda" id="r_ae76339cb2dcd3bc05ad762146f91fdda"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a></td></tr>
<tr class="memdesc:ae76339cb2dcd3bc05ad762146f91fdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining the simplest <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> interface as <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> for convenience.  <br /></td></tr>
<tr class="separator:ae76339cb2dcd3bc05ad762146f91fdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ee3a3e236b0c89bb6e89d7f0a069f0" id="r_ab8ee3a3e236b0c89bb6e89d7f0a069f0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ee3a3e236b0c89bb6e89d7f0a069f0">DenseIntStableTopologicalSorter</a></td></tr>
<tr class="separator:ab8ee3a3e236b0c89bb6e89d7f0a069f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9be35eb706de2777ef8b80262a293a" id="r_a0e9be35eb706de2777ef8b80262a293a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e9be35eb706de2777ef8b80262a293a">DenseIntTopologicalSorter</a></td></tr>
<tr class="separator:a0e9be35eb706de2777ef8b80262a293a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae705e1342dacc10a13fb3f11f91d0696" id="r_ae705e1342dacc10a13fb3f11f91d0696"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a> { <a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd">PRINT_GRAPH_ARCS</a>
, <a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565">PRINT_GRAPH_ADJACENCY_LISTS</a>
, <a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef">PRINT_GRAPH_ADJACENCY_LISTS_SORTED</a>
, <a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696aed2f19e9eb3369c6a16ecdb356afead8">PRINT_GRAPH_DOT</a>
 }</td></tr>
<tr class="memdesc:ae705e1342dacc10a13fb3f11f91d0696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a graph.  <a href="#ae705e1342dacc10a13fb3f11f91d0696">More...</a><br /></td></tr>
<tr class="separator:ae705e1342dacc10a13fb3f11f91d0696"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6c7131ba28e4222397d1cdb048da94d7" id="r_a6c7131ba28e4222397d1cdb048da94d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c7131ba28e4222397d1cdb048da94d7">AbortedErrorBuilder</a> ()</td></tr>
<tr class="separator:a6c7131ba28e4222397d1cdb048da94d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0f7d99f534361679bd82e09a56c30a" id="r_a9f0f7d99f534361679bd82e09a56c30a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f0f7d99f534361679bd82e09a56c30a">AlreadyExistsErrorBuilder</a> ()</td></tr>
<tr class="separator:a9f0f7d99f534361679bd82e09a56c30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4135532bf8cf1a7559e12f568d54d1" id="r_aac4135532bf8cf1a7559e12f568d54d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac4135532bf8cf1a7559e12f568d54d1">CancelledErrorBuilder</a> ()</td></tr>
<tr class="separator:aac4135532bf8cf1a7559e12f568d54d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8b955fd01d92c38c96d50dd7b36fa9" id="r_a5a8b955fd01d92c38c96d50dd7b36fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a8b955fd01d92c38c96d50dd7b36fa9">DataLossErrorBuilder</a> ()</td></tr>
<tr class="separator:a5a8b955fd01d92c38c96d50dd7b36fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6967409cb3e0a291eda5807f3edf796" id="r_ae6967409cb3e0a291eda5807f3edf796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6967409cb3e0a291eda5807f3edf796">DeadlineExceededErrorBuilder</a> ()</td></tr>
<tr class="separator:ae6967409cb3e0a291eda5807f3edf796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb73fb4c4369ff7beb4a819f3cc5831c" id="r_aeb73fb4c4369ff7beb4a819f3cc5831c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb73fb4c4369ff7beb4a819f3cc5831c">FailedPreconditionErrorBuilder</a> ()</td></tr>
<tr class="separator:aeb73fb4c4369ff7beb4a819f3cc5831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302ee4bfcb86ea9ed64a193ed0b14648" id="r_a302ee4bfcb86ea9ed64a193ed0b14648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302ee4bfcb86ea9ed64a193ed0b14648">InternalErrorBuilder</a> ()</td></tr>
<tr class="separator:a302ee4bfcb86ea9ed64a193ed0b14648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c886e6b95bc531d4a39884a87c0101" id="r_ad0c886e6b95bc531d4a39884a87c0101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c886e6b95bc531d4a39884a87c0101">InvalidArgumentErrorBuilder</a> ()</td></tr>
<tr class="separator:ad0c886e6b95bc531d4a39884a87c0101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1146d4103ad0b93801f626715519d6" id="r_afe1146d4103ad0b93801f626715519d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe1146d4103ad0b93801f626715519d6">NotFoundErrorBuilder</a> ()</td></tr>
<tr class="separator:afe1146d4103ad0b93801f626715519d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86ac164f0f951fca26cc3e9b34d9632" id="r_aa86ac164f0f951fca26cc3e9b34d9632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa86ac164f0f951fca26cc3e9b34d9632">OutOfRangeErrorBuilder</a> ()</td></tr>
<tr class="separator:aa86ac164f0f951fca26cc3e9b34d9632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85d86fd35e985c0fb4c4a200d72adda" id="r_ab85d86fd35e985c0fb4c4a200d72adda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab85d86fd35e985c0fb4c4a200d72adda">PermissionDeniedErrorBuilder</a> ()</td></tr>
<tr class="separator:ab85d86fd35e985c0fb4c4a200d72adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf5136a95272248cacae1d1a036e8ea" id="r_a5bf5136a95272248cacae1d1a036e8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf5136a95272248cacae1d1a036e8ea">UnauthenticatedErrorBuilder</a> ()</td></tr>
<tr class="separator:a5bf5136a95272248cacae1d1a036e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007b8813fdd1c082efc4e08fbcb8a83e" id="r_a007b8813fdd1c082efc4e08fbcb8a83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a007b8813fdd1c082efc4e08fbcb8a83e">ResourceExhaustedErrorBuilder</a> ()</td></tr>
<tr class="separator:a007b8813fdd1c082efc4e08fbcb8a83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532f9a3e8b48bd067e8576789fe36bc" id="r_a5532f9a3e8b48bd067e8576789fe36bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5532f9a3e8b48bd067e8576789fe36bc">UnavailableErrorBuilder</a> ()</td></tr>
<tr class="separator:a5532f9a3e8b48bd067e8576789fe36bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34739da67ea599226350b0cb5d1cbad6" id="r_a34739da67ea599226350b0cb5d1cbad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34739da67ea599226350b0cb5d1cbad6">UnimplementedErrorBuilder</a> ()</td></tr>
<tr class="separator:a34739da67ea599226350b0cb5d1cbad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23561d268e106df9d3aeba1897ab3c2a" id="r_a23561d268e106df9d3aeba1897ab3c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23561d268e106df9d3aeba1897ab3c2a">UnknownErrorBuilder</a> ()</td></tr>
<tr class="separator:a23561d268e106df9d3aeba1897ab3c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f1c7c8153d3d3ef062a2bb08c0c310" id="r_ac4f1c7c8153d3d3ef062a2bb08c0c310"><td class="memTemplParams" colspan="2">template&lt;class UndirectedGraph, class NodeType&gt; </td></tr>
<tr class="memitem:ac4f1c7c8153d3d3ef062a2bb08c0c310"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4f1c7c8153d3d3ef062a2bb08c0c310">GetConnectedComponentsTpl</a> (NodeType num_nodes, const UndirectedGraph &amp;graph)</td></tr>
<tr class="separator:ac4f1c7c8153d3d3ef062a2bb08c0c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f0e8f7e15873600cf8e395958c71e1" id="r_a13f0e8f7e15873600cf8e395958c71e1"><td class="memTemplParams" colspan="2">template&lt;class UndirectedGraph&gt; </td></tr>
<tr class="memitem:a13f0e8f7e15873600cf8e395958c71e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents</a> (int num_nodes, const UndirectedGraph &amp;graph)</td></tr>
<tr class="separator:a13f0e8f7e15873600cf8e395958c71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9470623ca7db3c4a62ce3b326c6b07d8" id="r_a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memTemplParams" colspan="2">template&lt;class IntVector, class Array, class ElementType&gt; </td></tr>
<tr class="memitem:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9470623ca7db3c4a62ce3b326c6b07d8">PermuteWithExplicitElementType</a> (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)</td></tr>
<tr class="separator:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c227a057c1ce9d46b1185abf77ad91e" id="r_a8c227a057c1ce9d46b1185abf77ad91e"><td class="memTemplParams" colspan="2">template&lt;class IntVector, class Array&gt; </td></tr>
<tr class="memitem:a8c227a057c1ce9d46b1185abf77ad91e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c227a057c1ce9d46b1185abf77ad91e">Permute</a> (const IntVector &amp;permutation, Array *array_to_permute)</td></tr>
<tr class="separator:a8c227a057c1ce9d46b1185abf77ad91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac497881c4166bc694adc4bee62746118" id="r_ac497881c4166bc694adc4bee62746118"><td class="memTemplParams" colspan="2">template&lt;class IntVector&gt; </td></tr>
<tr class="memitem:ac497881c4166bc694adc4bee62746118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac497881c4166bc694adc4bee62746118">Permute</a> (const IntVector &amp;permutation, std::vector&lt; bool &gt; *array_to_permute)</td></tr>
<tr class="separator:ac497881c4166bc694adc4bee62746118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e88af7abf0237fef40aa76fe1ced1f" id="r_aa5e88af7abf0237fef40aa76fe1ced1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e88af7abf0237fef40aa76fe1ced1f">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>, Outgoing)</td></tr>
<tr class="memdesc:aa5e88af7abf0237fef40aa76fe1ced1f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a> implementation -------------------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:aa5e88af7abf0237fef40aa76fe1ced1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade20378d1ceb21797e3d393ec809f07d" id="r_ade20378d1ceb21797e3d393ec809f07d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade20378d1ceb21797e3d393ec809f07d">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>, Outgoing)</td></tr>
<tr class="separator:ade20378d1ceb21797e3d393ec809f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bbf0716a9d1cac8bd6c0ad66783daa" id="r_ad9bbf0716a9d1cac8bd6c0ad66783daa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9bbf0716a9d1cac8bd6c0ad66783daa">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, Outgoing)</td></tr>
<tr class="memdesc:ad9bbf0716a9d1cac8bd6c0ad66783daa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a> implementation ---------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:ad9bbf0716a9d1cac8bd6c0ad66783daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9509e821dd6c64b6f4c6c6c63c45b3" id="r_a2d9509e821dd6c64b6f4c6c6c63c45b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d9509e821dd6c64b6f4c6c6c63c45b3">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, Incoming)</td></tr>
<tr class="separator:a2d9509e821dd6c64b6f4c6c6c63c45b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08398f12eb94e794d43a1045faf7e60" id="r_ad08398f12eb94e794d43a1045faf7e60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad08398f12eb94e794d43a1045faf7e60">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, OutgoingOrOppositeIncoming)</td></tr>
<tr class="separator:ad08398f12eb94e794d43a1045faf7e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb04ea52a19b7c3ae4c86957850ab35" id="r_aceb04ea52a19b7c3ae4c86957850ab35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceb04ea52a19b7c3ae4c86957850ab35">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, OppositeIncoming)</td></tr>
<tr class="separator:aceb04ea52a19b7c3ae4c86957850ab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e87fd0da3ad033e247a92e879f1d31" id="r_a19e87fd0da3ad033e247a92e879f1d31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e87fd0da3ad033e247a92e879f1d31">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, Outgoing)</td></tr>
<tr class="memdesc:a19e87fd0da3ad033e247a92e879f1d31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a> implementation -------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:a19e87fd0da3ad033e247a92e879f1d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1af2fada3816b822836dd33f559bbea" id="r_ac1af2fada3816b822836dd33f559bbea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1af2fada3816b822836dd33f559bbea">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, Incoming)</td></tr>
<tr class="separator:ac1af2fada3816b822836dd33f559bbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d5cbf5cffa2a95ccd65c153548d111" id="r_a62d5cbf5cffa2a95ccd65c153548d111"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62d5cbf5cffa2a95ccd65c153548d111">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, OutgoingOrOppositeIncoming)</td></tr>
<tr class="separator:a62d5cbf5cffa2a95ccd65c153548d111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7013887aa554dc3e08cefb6849e0a22b" id="r_a7013887aa554dc3e08cefb6849e0a22b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7013887aa554dc3e08cefb6849e0a22b">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, OppositeIncoming)</td></tr>
<tr class="separator:a7013887aa554dc3e08cefb6849e0a22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85a5d3a1aad9e7bfda6d12c98bb369b" id="r_ac85a5d3a1aad9e7bfda6d12c98bb369b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac85a5d3a1aad9e7bfda6d12c98bb369b">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, Outgoing)</td></tr>
<tr class="memdesc:ac85a5d3a1aad9e7bfda6d12c98bb369b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a> implementation --------------------------------------&mdash;.  <br /></td></tr>
<tr class="separator:ac85a5d3a1aad9e7bfda6d12c98bb369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d0ef31f62ff56ff0ad11e5721a8080" id="r_ac8d0ef31f62ff56ff0ad11e5721a8080"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8d0ef31f62ff56ff0ad11e5721a8080">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, Incoming)</td></tr>
<tr class="separator:ac8d0ef31f62ff56ff0ad11e5721a8080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573de155eb302c0bf5784e27704eb8e2" id="r_a573de155eb302c0bf5784e27704eb8e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573de155eb302c0bf5784e27704eb8e2">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, OutgoingOrOppositeIncoming)</td></tr>
<tr class="separator:a573de155eb302c0bf5784e27704eb8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09214d52f0cc00ecd35b503cac3cf000" id="r_a09214d52f0cc00ecd35b503cac3cf000"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09214d52f0cc00ecd35b503cac3cf000">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, OppositeIncoming)</td></tr>
<tr class="separator:a09214d52f0cc00ecd35b503cac3cf000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed79554a202aaa8bda5b5e98c3a6b2" id="r_affed79554a202aaa8bda5b5e98c3a6b2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:affed79554a202aaa8bda5b5e98c3a6b2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affed79554a202aaa8bda5b5e98c3a6b2">GraphToString</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, <a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a> format)</td></tr>
<tr class="memdesc:affed79554a202aaa8bda5b5e98c3a6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of the templated methods.  <br /></td></tr>
<tr class="separator:affed79554a202aaa8bda5b5e98c3a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc3683e5d8f49f745bea0fa513f1675" id="r_a2bc3683e5d8f49f745bea0fa513f1675"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a2bc3683e5d8f49f745bea0fa513f1675"><td class="memTemplItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2bc3683e5d8f49f745bea0fa513f1675">WriteGraphToFile</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::string &amp;filename, bool directed, absl::Span&lt; const int &gt; num_nodes_with_color)</td></tr>
<tr class="separator:a2bc3683e5d8f49f745bea0fa513f1675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a4999be011343be06bd28753bf8ecc" id="r_a30a4999be011343be06bd28753bf8ecc"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a30a4999be011343be06bd28753bf8ecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30a4999be011343be06bd28753bf8ecc">BeginEndRange</a> (Iterator begin, Iterator end)</td></tr>
<tr class="separator:a30a4999be011343be06bd28753bf8ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be0ef9f4566f20fbf5238b24385216" id="r_a68be0ef9f4566f20fbf5238b24385216"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a68be0ef9f4566f20fbf5238b24385216"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68be0ef9f4566f20fbf5238b24385216">BeginEndRange</a> (std::pair&lt; Iterator, Iterator &gt; begin_end)</td></tr>
<tr class="separator:a68be0ef9f4566f20fbf5238b24385216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628255019800e5a053d08b1f0c5a05f2" id="r_a628255019800e5a053d08b1f0c5a05f2"><td class="memTemplParams" colspan="2">template&lt;typename MultiMap&gt; </td></tr>
<tr class="memitem:a628255019800e5a053d08b1f0c5a05f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a628255019800e5a053d08b1f0c5a05f2">EqualRange</a> (MultiMap &amp;multi_map, const typename MultiMap::key_type &amp;key)</td></tr>
<tr class="separator:a628255019800e5a053d08b1f0c5a05f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203f5498a7e1bc70f8ff62c0cfaaf8b1" id="r_a203f5498a7e1bc70f8ff62c0cfaaf8b1"><td class="memTemplParams" colspan="2">template&lt;typename MultiMap&gt; </td></tr>
<tr class="memitem:a203f5498a7e1bc70f8ff62c0cfaaf8b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a203f5498a7e1bc70f8ff62c0cfaaf8b1">EqualRange</a> (const MultiMap &amp;multi_map, const typename MultiMap::key_type &amp;key)</td></tr>
<tr class="separator:a203f5498a7e1bc70f8ff62c0cfaaf8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208121f27c615b309e2ab37bb85280f1" id="r_a208121f27c615b309e2ab37bb85280f1"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a208121f27c615b309e2ab37bb85280f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1BeginEndReverseIteratorWrapper.html">BeginEndReverseIteratorWrapper</a>&lt; Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a208121f27c615b309e2ab37bb85280f1">Reverse</a> (const Container &amp;c)</td></tr>
<tr class="separator:a208121f27c615b309e2ab37bb85280f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514fe075bc41a004214a90ff2542c992" id="r_a514fe075bc41a004214a90ff2542c992"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a514fe075bc41a004214a90ff2542c992">GenerateRandomMultiGraph</a> (int num_nodes, int num_arcs, bool finalized, absl::BitGenRef gen)</td></tr>
<tr class="separator:a514fe075bc41a004214a90ff2542c992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e79bcc13a6ff8ac5a0e2187888e540b" id="r_a8e79bcc13a6ff8ac5a0e2187888e540b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e79bcc13a6ff8ac5a0e2187888e540b">GenerateRandomDirectedSimpleGraph</a> (int num_nodes, int num_arcs, bool finalized, absl::BitGenRef gen)</td></tr>
<tr class="separator:a8e79bcc13a6ff8ac5a0e2187888e540b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972b9b2f0e8122bf87ac39f89a7360c7" id="r_a972b9b2f0e8122bf87ac39f89a7360c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a972b9b2f0e8122bf87ac39f89a7360c7">GenerateRandomUndirectedSimpleGraph</a> (int num_nodes, int num_edges, bool finalized, absl::BitGenRef gen)</td></tr>
<tr class="separator:a972b9b2f0e8122bf87ac39f89a7360c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8366c7e3d087665b74eef9ef0e51de1" id="r_ae8366c7e3d087665b74eef9ef0e51de1"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:ae8366c7e3d087665b74eef9ef0e51de1"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8366c7e3d087665b74eef9ef0e51de1">Create2DGridGraph</a> (int64_t width, int64_t height)</td></tr>
<tr class="separator:ae8366c7e3d087665b74eef9ef0e51de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49200d01f1aec6ee7837ad3e09b0d880" id="r_a49200d01f1aec6ee7837ad3e09b0d880"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a49200d01f1aec6ee7837ad3e09b0d880"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49200d01f1aec6ee7837ad3e09b0d880">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:a49200d01f1aec6ee7837ad3e09b0d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adc100d0fc2606414e4cdf062a80c97" id="r_a3adc100d0fc2606414e4cdf062a80c97"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3adc100d0fc2606414e4cdf062a80c97"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3adc100d0fc2606414e4cdf062a80c97">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:a3adc100d0fc2606414e4cdf062a80c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:a3adc100d0fc2606414e4cdf062a80c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75288075e89561fd1564e40123cd7dd" id="r_ab75288075e89561fd1564e40123cd7dd"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab75288075e89561fd1564e40123cd7dd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab75288075e89561fd1564e40123cd7dd">TopologicalSortOrDie</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs)</td></tr>
<tr class="memdesc:ab75288075e89561fd1564e40123cd7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">OrDie() variant of the above.  <br /></td></tr>
<tr class="separator:ab75288075e89561fd1564e40123cd7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8f58bd1b46837f8305d316bb84d0e1" id="r_a9f8f58bd1b46837f8305d316bb84d0e1"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9f8f58bd1b46837f8305d316bb84d0e1"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f8f58bd1b46837f8305d316bb84d0e1">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:a9f8f58bd1b46837f8305d316bb84d0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac974be3bae074c99c0d7d7a5aedbc757" id="r_ac974be3bae074c99c0d7d7a5aedbc757"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac974be3bae074c99c0d7d7a5aedbc757"><td class="memTemplItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac974be3bae074c99c0d7d7a5aedbc757">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:ac974be3bae074c99c0d7d7a5aedbc757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:ac974be3bae074c99c0d7d7a5aedbc757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b0775ffcab4f306414763e156b97e5" id="r_ae8b0775ffcab4f306414763e156b97e5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae8b0775ffcab4f306414763e156b97e5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8b0775ffcab4f306414763e156b97e5">StableTopologicalSortOrDie</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs)</td></tr>
<tr class="memdesc:ae8b0775ffcab4f306414763e156b97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">OrDie() variant of the above.  <br /></td></tr>
<tr class="separator:ae8b0775ffcab4f306414763e156b97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8fe0e94677e886c26ba2f3bade9a7f" id="r_afa8fe0e94677e886c26ba2f3bade9a7f"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8fe0e94677e886c26ba2f3bade9a7f">FindCycleInDenseIntGraph</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="memdesc:afa8fe0e94677e886c26ba2f3bade9a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">______________________ END OF THE RECOMMENDED API ___________________________  <br /></td></tr>
<tr class="separator:afa8fe0e94677e886c26ba2f3bade9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ca9916b6307f51dd4983ffd2896ca" id="r_af88ca9916b6307f51dd4983ffd2896ca"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af88ca9916b6307f51dd4983ffd2896ca">DenseIntTopologicalSort</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs, std::vector&lt; int &gt; *topological_order)</td></tr>
<tr class="memdesc:af88ca9916b6307f51dd4983ffd2896ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of the "simple API" functions declared at the top.  <br /></td></tr>
<tr class="separator:af88ca9916b6307f51dd4983ffd2896ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cda68f8ed2a159f060cfaafe2017e6f" id="r_a5cda68f8ed2a159f060cfaafe2017e6f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cda68f8ed2a159f060cfaafe2017e6f">DenseIntStableTopologicalSortOrDie</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="separator:a5cda68f8ed2a159f060cfaafe2017e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f7a974e2fa9b8cde91cbcab0242c2e" id="r_a48f7a974e2fa9b8cde91cbcab0242c2e"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48f7a974e2fa9b8cde91cbcab0242c2e">DenseIntStableTopologicalSort</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs, std::vector&lt; int &gt; *topological_order)</td></tr>
<tr class="separator:a48f7a974e2fa9b8cde91cbcab0242c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0578f3afba5eb142e0dcca8063f6e66a" id="r_a0578f3afba5eb142e0dcca8063f6e66a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0578f3afba5eb142e0dcca8063f6e66a">DenseIntTopologicalSortOrDie</a> (int num_nodes, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;arcs)</td></tr>
<tr class="separator:a0578f3afba5eb142e0dcca8063f6e66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ae803e2d0270a720f294269b30fc10" id="r_ad2ae803e2d0270a720f294269b30fc10"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad2ae803e2d0270a720f294269b30fc10"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2ae803e2d0270a720f294269b30fc10">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:ad2ae803e2d0270a720f294269b30fc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da65a9795112f2e6b57c9cfe950f4a3" id="r_a6da65a9795112f2e6b57c9cfe950f4a3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6da65a9795112f2e6b57c9cfe950f4a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6da65a9795112f2e6b57c9cfe950f4a3">TopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:a6da65a9795112f2e6b57c9cfe950f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:a6da65a9795112f2e6b57c9cfe950f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed25a07b58c38bbfba6e2912024e541" id="r_a4ed25a07b58c38bbfba6e2912024e541"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a4ed25a07b58c38bbfba6e2912024e541"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ed25a07b58c38bbfba6e2912024e541">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order)</td></tr>
<tr class="separator:a4ed25a07b58c38bbfba6e2912024e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f37ea5a316975b7039dc07929a5b65" id="r_a37f37ea5a316975b7039dc07929a5b65"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a37f37ea5a316975b7039dc07929a5b65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a37f37ea5a316975b7039dc07929a5b65">StableTopologicalSort</a> (const std::vector&lt; T &gt; &amp;nodes, const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;arcs, std::vector&lt; T &gt; *topological_order, std::vector&lt; T &gt; *cycle)</td></tr>
<tr class="memdesc:a37f37ea5a316975b7039dc07929a5b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of the above that outputs the detected cycle.  <br /></td></tr>
<tr class="separator:a37f37ea5a316975b7039dc07929a5b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c2faec725bc47baf08421b377f643" id="r_aca9c2faec725bc47baf08421b377f643"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca9c2faec725bc47baf08421b377f643">IsSubsetOf0N</a> (absl::Span&lt; const int &gt; v, int n)</td></tr>
<tr class="separator:aca9c2faec725bc47baf08421b377f643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4af76993c891ee4ad507783edec2a1c" id="r_ac4af76993c891ee4ad507783edec2a1c"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:ac4af76993c891ee4ad507783edec2a1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4af76993c891ee4ad507783edec2a1c">GraphHasSelfArcs</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac4af76993c891ee4ad507783edec2a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of the templated methods.  <br /></td></tr>
<tr class="separator:ac4af76993c891ee4ad507783edec2a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37593970a26f5c88b3d2ea9acea9d2" id="r_a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b37593970a26f5c88b3d2ea9acea9d2">GraphHasDuplicateArcs</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784b483eeae1b49164a8a02fe9c0d3ba" id="r_a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a784b483eeae1b49164a8a02fe9c0d3ba">GraphIsSymmetric</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97311561fd1f01e9f35b2f7ce18b0af3" id="r_a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97311561fd1f01e9f35b2f7ce18b0af3">GraphIsWeaklyConnected</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed748741b17dad9e6cc485728bb0043" id="r_a0ed748741b17dad9e6cc485728bb0043"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a0ed748741b17dad9e6cc485728bb0043"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ed748741b17dad9e6cc485728bb0043">CopyGraph</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a0ed748741b17dad9e6cc485728bb0043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fresh copy of a given graph.  <br /></td></tr>
<tr class="separator:a0ed748741b17dad9e6cc485728bb0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c65bcf51a7c679ad0159e09ecfb3fc" id="r_a88c65bcf51a7c679ad0159e09ecfb3fc"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a88c65bcf51a7c679ad0159e09ecfb3fc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88c65bcf51a7c679ad0159e09ecfb3fc">RemapGraph</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, absl::Span&lt; const int &gt; new_node_index)</td></tr>
<tr class="separator:a88c65bcf51a7c679ad0159e09ecfb3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbba6a42d616fc4fb5c9ab3afe649197" id="r_adbba6a42d616fc4fb5c9ab3afe649197"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:adbba6a42d616fc4fb5c9ab3afe649197"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbba6a42d616fc4fb5c9ab3afe649197">GetSubgraphOfNodes</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, absl::Span&lt; const int &gt; nodes)</td></tr>
<tr class="separator:adbba6a42d616fc4fb5c9ab3afe649197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a31111f9a74492f1de9238e463edd2a" id="r_a8a31111f9a74492f1de9238e463edd2a"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a8a31111f9a74492f1de9238e463edd2a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a31111f9a74492f1de9238e463edd2a">GetWeaklyConnectedComponents</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a8a31111f9a74492f1de9238e463edd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab823d80d85f004d3d2139cc4f6c2f" id="r_a0aab823d80d85f004d3d2139cc4f6c2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aab823d80d85f004d3d2139cc4f6c2f">IsValidPermutation</a> (absl::Span&lt; const int &gt; v)</td></tr>
<tr class="memdesc:a0aab823d80d85f004d3d2139cc4f6c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given vector is a permutation of [0..size()-1].  <br /></td></tr>
<tr class="separator:a0aab823d80d85f004d3d2139cc4f6c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06031908a024a50dbdddc394a22490" id="r_a8a06031908a024a50dbdddc394a22490"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a8a06031908a024a50dbdddc394a22490"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a06031908a024a50dbdddc394a22490">RemoveSelfArcsAndDuplicateArcs</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a8a06031908a024a50dbdddc394a22490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of "graph", without self-arcs and duplicate arcs.  <br /></td></tr>
<tr class="separator:a8a06031908a024a50dbdddc394a22490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa201576c927d92657e090fa86bfdb" id="r_a06fa201576c927d92657e090fa86bfdb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a06fa201576c927d92657e090fa86bfdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06fa201576c927d92657e090fa86bfdb">RemoveCyclesFromPath</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, std::vector&lt; int &gt; *arc_path)</td></tr>
<tr class="separator:a06fa201576c927d92657e090fa86bfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34114d206959f75a472b167c806da2cb" id="r_a34114d206959f75a472b167c806da2cb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:a34114d206959f75a472b167c806da2cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a34114d206959f75a472b167c806da2cb">PathHasCycle</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, absl::Span&lt; const int &gt; arc_path)</td></tr>
<tr class="memdesc:a34114d206959f75a472b167c806da2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given path contains a cycle.  <br /></td></tr>
<tr class="separator:a34114d206959f75a472b167c806da2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae469c559688b92f36bae2788c2e6063e" id="r_ae469c559688b92f36bae2788c2e6063e"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </td></tr>
<tr class="memitem:ae469c559688b92f36bae2788c2e6063e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae469c559688b92f36bae2788c2e6063e">ComputeOnePossibleReverseArcMapping</a> (const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, bool die_if_not_symmetric)</td></tr>
<tr class="separator:ae469c559688b92f36bae2788c2e6063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a418964a1c3ba7d63e28316baf980cec6" id="r_a418964a1c3ba7d63e28316baf980cec6"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndexType, typename ArcIndexType, bool HasNegativeReverseArcs&gt; </td></tr>
<tr class="memitem:a418964a1c3ba7d63e28316baf980cec6"><td class="memTemplItemLeft" align="right" valign="top">const NodeIndexType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a418964a1c3ba7d63e28316baf980cec6">BaseGraph&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::kNilNode</a></td></tr>
<tr class="separator:a418964a1c3ba7d63e28316baf980cec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e53dea0266bc3a290c6fde611d3cf87" id="r_a1e53dea0266bc3a290c6fde611d3cf87"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndexType, typename ArcIndexType, bool HasNegativeReverseArcs&gt; </td></tr>
<tr class="memitem:a1e53dea0266bc3a290c6fde611d3cf87"><td class="memTemplItemLeft" align="right" valign="top">const ArcIndexType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e53dea0266bc3a290c6fde611d3cf87">BaseGraph&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::kNilArc</a></td></tr>
<tr class="separator:a1e53dea0266bc3a290c6fde611d3cf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collections of i/o utilities for the <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> classes in ./graph.h. </p>
<p>A collections of utilities for the <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> classes in ./graph.h.</p>
<p>Unit test utilities related to <a class="el" href="graph_8h.html">graph.h</a>.</p>
<p>Helper classes to make it easy to implement range-based for loops.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Provides faster division in situations where the same divisor is used repeatedly but is not known at compile time. For example, a hash table might not be sized until the model is loaded, but once loaded it is not resized for the life of the model. As this is not a compile time constant, the compiler can not optimize away the division.</p>
<p>However the cost of precomputing coefficients when the hash table is sized can be dwarfed by the cycles saved avoiding hardware division on every lookup. See benchmark section below to estimate the breakeven point. This reduces the CPU penalty of non-power of two sized hash tables, bloom filters, etc.</p>
<p>The following template and specializations are defined in this file:</p><ul>
<li>ConstantDivisor&lt;T&gt;</li>
<li>ConstantDivisor&lt;uint8_t&gt;</li>
<li>ConstantDivisor&lt;uint16_t&gt;</li>
<li>ConstantDivisor&lt;uint32_t&gt; (Only supports denominators &gt; 1)</li>
<li>ConstantDivisor&lt;uint64_t&gt; (Only supports denominators &gt; 1)</li>
</ul>
<p>Fast div/mod implementation based on "Faster Remainder by Direct Computation: Applications to Compilers and
Software Libraries" Daniel Lemire, Owen Kaser, Nathan Kurz arXiv:1902.01961</p>
<p>Usage: uint64_t n; ///&lt; Not known at compile time! ConstantDivisor&lt;uint64_t&gt; divisor(n); uint64_t m = ...; EXPECT_EQ(m / n, divisor.div(m)); EXPECT_EQ(m % n, divisor.mod(m));</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. These 3 functions give the full functionality of a BFS (Breadth-First-Search) on any type of <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> on dense integers that implements the [] operator to yield the adjacency list: graph[i] should yield a vector&lt;int&gt;-like object that lists all the (outgoing) neighbors of node #i.</p>
<p>If your graph is undirected, it means that for each edge (i,j), graph[i] must contain j and graph[j] must contain i.</p>
<p>Self-arcs and multi-arcs are supported, since they don't affect BFS.</p>
<p>These functions are fast: they have the optimal asymptotic complexity, and are reasonably optimized. You may still get performance gains if you implement your own BFS for your application. In particular, this API is optimized for repeated calls to GetBFSShortestPath(); if you only care about GetBFSDistances() there exists more optimized implementations.</p>
<p>ERRORS: This library does perform many checks at runtime, and returns an error Status if it detects a problem, but it doesn't fully protect you from crashes if the input is ill-formed in some ways this library can't check. For example, if calling graph[i] crashes for some i in 0..num_nodes-1, this won't detect it.</p>
<p>Example: const int num_nodes = 3; vector&lt;vector&lt;int&gt;&gt; <a class="el" href="namespaceutil_1_1graph.html">graph(num_nodes)</a> = {{1}, {0}, {1, 2}}; ///&lt; 0↔1←2⟲ const int source = 1; vector&lt;int&gt; bfs_tree = GetBFSRootedTree(graph, num_nodes, source).value(); LOG(INFO) &lt;&lt; <a class="el" href="dump__vars_8h.html#a7f47f1b526f076743c5ffd6f4dc3141b">DUMP_VARS(GetBFSDistances(bfs_tree))</a>; for (int target : {0, 1, 2}) { vector&lt;int&gt; path = GetBFSShortestPath(bfs_tree, target); LOG(INFO) &lt;&lt; <a class="el" href="dump__vars_8h.html#a7f47f1b526f076743c5ffd6f4dc3141b">DUMP_VARS(path)</a>; }</p>
<p>Would log this: GetBFSDistances(bfs_tree) = [1, 0, -1] path = [1, 0] path = [1] path = [] ///&lt; no path from 1 to 2.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Finds the connected components in an undirected graph: <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">https://en.wikipedia.org/wiki/Connected_component_(graph_theory)</a></p>
<p>If you have a fixed graph where the node are dense integers, use <a class="el" href="#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents()</a>: it's very fast and uses little memory.</p>
<p>If you have a more dynamic scenario where you want to incrementally add nodes or edges and query the connectivity between them, use the [Dense]<a class="el" href="classConnectedComponentsFinder.html">ConnectedComponentsFinder</a> class, which uses the union-find algorithm aka disjoint sets: <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>.</p>
<p>Implementations of the method templates</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file defines a generic graph interface on which most algorithms can be built and provides a few efficient implementations with a fast construction time. Its design is based on the experience acquired by the Operations Research team in their various graph algorithm implementations.</p>
<p>The main ideas are:</p><ul>
<li><a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> nodes and arcs are represented by integers.</li>
<li>Node or arc annotations (weight, cost, ...) are not part of the graph class, they can be stored outside in one or more arrays and can be easily retrieved using a node or arc as an index.</li>
</ul>
<p>Terminology:</p><ul>
<li>An arc of a graph is directed and going from a tail node to a head node.</li>
<li>Some implementations also store 'reverse' arcs and can be used for undirected graph or flow-like algorithm.</li>
<li>A node or arc index is 'valid' if it represents a node or arc of the graph. The validity ranges are always [0, num_nodes()) for nodes and [0, num_arcs()) for forward arcs. Reverse arcs are elements of [-num_arcs(), 0) and are also considered valid by the implementations that store them.</li>
</ul>
<p>Provided implementations:</p><ul>
<li><a class="el" href="classutil_1_1ListGraph.html">ListGraph&lt;&gt;</a> for the simplest api. Also aliased to <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">util::Graph</a>.</li>
<li><a class="el" href="classutil_1_1StaticGraph.html">StaticGraph&lt;&gt;</a> for performance, but require calling Build(), see below</li>
<li><a class="el" href="classutil_1_1CompleteGraph.html">CompleteGraph&lt;&gt;</a> if you need a fully connected graph</li>
<li><a class="el" href="classutil_1_1CompleteBipartiteGraph.html">CompleteBipartiteGraph&lt;&gt;</a> if you need a fully connected bipartite graph</li>
<li><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph&lt;&gt;</a> to add reverse arcs to <a class="el" href="classutil_1_1ListGraph.html">ListGraph&lt;&gt;</a></li>
<li><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph&lt;&gt;</a> to add reverse arcs to <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph&lt;&gt;</a></li>
<li><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph&lt;&gt;</a> for a smaller memory footprint</li>
</ul>
<p>Utility classes &amp; functions:</p><ul>
<li><a class="el" href="#a8c227a057c1ce9d46b1185abf77ad91e">Permute()</a> to permute an array according to a given permutation.</li>
<li><a class="el" href="classutil_1_1SVector.html" title="Forward declaration.">SVector&lt;&gt;</a> vector with index range [-size(), size()) for ReverseArcGraph.</li>
</ul>
<p>Basic usage: typedef <a class="el" href="classutil_1_1ListGraph.html">ListGraph&lt;&gt;</a> <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a>; ///&lt; Choose a graph implementation. <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> graph; for (...) { graph.AddArc(tail, head); } ... for (int node = 0; node &lt; graph.num_nodes(); ++node) { for (const int arc : graph.OutgoingArcs(node)) { head = graph.Head(arc); tail = node; ///&lt; or graph.Tail(arc) which is fast but not as much. } }</p>
<p>Iteration over the arcs touching a node:</p>
<ul>
<li>OutgoingArcs(node): All the forward arcs leaving the node.</li>
<li>IncomingArcs(node): All the forward arcs arriving at the node.</li>
</ul>
<p>And two more involved ones:</p>
<ul>
<li>OutgoingOrOppositeIncomingArcs(node): This returns both the forward arcs leaving the node (i.e. OutgoingArcs(node)) and the reverse arcs leaving the node (i.e. the opposite arcs of the ones returned by IncomingArcs(node)).</li>
<li>OppositeIncomingArcs(node): This returns the reverse arcs leaving the node.</li>
</ul>
<p>Note on iteration efficiency: When re-indexing the arcs it is not possible to have both the outgoing arcs and the incoming ones form a consecutive range.</p>
<p>It is however possible to do so for the outgoing arcs and the opposite incoming arcs. It is why the OutgoingOrOppositeIncomingArcs() and OutgoingArcs() iterations are more efficient than the IncomingArcs() one. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000687">Todo</a></b></dt><dd>(b/385094969): Once we no longer use <code><a class="el" href="one__tree__lower__bound_8h.html#a3947d19ac087ef2cd68c2409920339c4">Next()</a>/Ok()</code> for iterators, we can get rid of <code>limit_</code>, which will make iteration much more efficient.</dd></dl>
<p>If you know the graph size in advance, this already set the number of nodes, reserve space for the arcs and check in DEBUG mode that you don't go over the bounds: <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> <a class="el" href="namespaceutil_1_1graph.html">graph(num_nodes, arc_capacity)</a>;</p>
<p>Storing and using node annotations: vector&lt;bool&gt; is_visited(graph.num_nodes(), false); ... for (int node = 0; node &lt; graph.num_nodes(); ++node) { if (!is_visited[node]) ... }</p>
<p>Storing and using arc annotations: vector&lt;int&gt; weights; for (...) { graph.AddArc(tail, head); weights.push_back(arc_weight); } ... for (const int arc : graph.OutgoingArcs(node)) { ... weights[arc] ...; }</p>
<p>More efficient version: typedef <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph&lt;&gt;</a> <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a>; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> <a class="el" href="namespaceutil_1_1graph.html">graph(num_nodes, arc_capacity)</a>; ///&lt; Optional, but help memory usage. vector&lt;int&gt; weights; weights.reserve(arc_capacity); ///&lt; Optional, but help memory usage. for (...) { graph.AddArc(tail, head); weights.push_back(arc_weight); } ... vector&lt;Graph::ArcIndex&gt; permutation; graph.Build(&amp;permutation); ///&lt; A static graph must be Build() before usage. Permute(permutation, &amp;weights); ///&lt; Build() may permute the arc index. ...</p>
<p>Encoding an undirected graph: If you don't need arc annotation, then the best is to add two arcs for each edge (one in each direction) to a directed graph. Otherwise you can do the following.</p>
<p>typedef ReverseArc... <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a>; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> graph; for (...) { graph.AddArc(tail, head); ///&lt; or graph.AddArc(head, tail) but not both. edge_annotations.push_back(value); } ... for (const <a class="el" href="classutil_1_1BaseGraph.html#af79cd652ad4b1e7142c1acbec35b01a6">Graph::NodeIndex</a> node : graph.AllNodes()) { for (const <a class="el" href="classutil_1_1BaseGraph.html#a68014ae932b1c5f50d7365cecae209fd">Graph::ArcIndex</a> arc : graph.OutgoingOrOppositeIncomingArcs(node)) { destination = graph.Head(arc); annotation = edge_annotations[arc &lt; 0 ? graph.OppositeArc(arc) : arc]; } }</p>
<dl class="section note"><dt>Note</dt><dd>The graphs are primarily designed to be constructed first and then used because it covers most of the use cases. It is possible to extend the interface with more dynamicity (like removing arcs), but this is not done at this point. Note that a "dynamic" implementation will break some assumptions we make on what node or arc are valid and also on the indices returned by AddArc(). Some arguments for simplifying the interface at the cost of dynamicity are:</dd></dl>
<ul>
<li>It is always possible to construct a static graph from a dynamic one before calling a complex algo.</li>
<li>If you really need a dynamic graph, maybe it is better to compute a graph property incrementally rather than calling an algorithm that starts from scratch each time.</li>
</ul>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A collection of functions to be used in unit tests involving the ortools/graph/... library.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div>
</div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file provides topologically sorted traversal of the nodes of a directed acyclic graph (DAG) with up to INT_MAX nodes. It sorts ancestor nodes before their descendants. Multi-arcs are fine.</p>
<p>If your graph is not a DAG and you're reading this, you are probably looking for <a class="el" href="strongly__connected__components_8h.html">ortools/graph/strongly_connected_components.h</a> which does the topological decomposition of a directed graph.</p>
<p>USAGE:</p><ul>
<li>If performance matters, use FastTopologicalSort().</li>
<li>If your nodes are non-integers, or you need to break topological ties by node index (like "stable_sort"), use one of the <a class="el" href="#af88ca9916b6307f51dd4983ffd2896ca" title="Implementations of the &quot;simple API&quot; functions declared at the top.">DenseIntTopologicalSort()</a> or TopologicalSort variants (see below).</li>
<li>If you need more control (cycle extraction?), or a step-by-step topological sort, see the <a class="el" href="classutil_1_1TopologicalSorter.html">TopologicalSorter</a> classes below. </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab8ee3a3e236b0c89bb6e89d7f0a069f0" name="ab8ee3a3e236b0c89bb6e89d7f0a069f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ee3a3e236b0c89bb6e89d7f0a069f0">&#9670;&#160;</a></span>DenseIntStableTopologicalSorter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; true&gt; <a class="el" href="#ab8ee3a3e236b0c89bb6e89d7f0a069f0">util::DenseIntStableTopologicalSorter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recommended version for general usage. The stability makes it more deterministic, and its behavior is guaranteed to never change. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00288">288</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a0e9be35eb706de2777ef8b80262a293a" name="a0e9be35eb706de2777ef8b80262a293a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9be35eb706de2777ef8b80262a293a">&#9670;&#160;</a></span>DenseIntTopologicalSorter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1internal_1_1DenseIntTopologicalSorterTpl.html">::util::internal::DenseIntTopologicalSorterTpl</a>&lt; false&gt; <a class="el" href="#a0e9be35eb706de2777ef8b80262a293a">util::DenseIntTopologicalSorter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this version if you are certain you don't care about the tie-breaking order and need the 5 to 10% performance gain. The performance gain can be more significant for large graphs with large numbers of source nodes (for example 2 Million nodes with 2 Million random edges sees a factor of 0.7 difference in completion time). </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00297">297</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ae76339cb2dcd3bc05ad762146f91fdda" name="ae76339cb2dcd3bc05ad762146f91fdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76339cb2dcd3bc05ad762146f91fdda">&#9670;&#160;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1ListGraph.html">ListGraph</a> <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">util::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defining the simplest <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> interface as <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a> for convenience. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l02456">2456</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae705e1342dacc10a13fb3f11f91d0696" name="ae705e1342dacc10a13fb3f11f91d0696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae705e1342dacc10a13fb3f11f91d0696">&#9670;&#160;</a></span>GraphToStringFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696">util::GraphToStringFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a graph. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd" name="ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd"></a>PRINT_GRAPH_ARCS&#160;</td><td class="fielddoc"><p>One arc per line, eg. "3-&gt;1". </p>
</td></tr>
<tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565" name="ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565"></a>PRINT_GRAPH_ADJACENCY_LISTS&#160;</td><td class="fielddoc"><p>One space-separated adjacency list per line, eg. "3: 5 1 3 1". Nodes with no outgoing arc get an empty list. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef" name="ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef"></a>PRINT_GRAPH_ADJACENCY_LISTS_SORTED&#160;</td><td class="fielddoc"><p>Ditto, but the adjacency lists are sorted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696aed2f19e9eb3369c6a16ecdb356afead8" name="ae705e1342dacc10a13fb3f11f91d0696aed2f19e9eb3369c6a16ecdb356afead8"></a>PRINT_GRAPH_DOT&#160;</td><td class="fielddoc"><p>Dot format, can be visualized with Graphviz. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="graph__io_8h_source.html#l00041">41</a> of file <a class="el" href="graph__io_8h_source.html">graph_io.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6c7131ba28e4222397d1cdb048da94d7" name="a6c7131ba28e4222397d1cdb048da94d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7131ba28e4222397d1cdb048da94d7">&#9670;&#160;</a></span>AbortedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::AbortedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00079">79</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a9f0f7d99f534361679bd82e09a56c30a" name="a9f0f7d99f534361679bd82e09a56c30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0f7d99f534361679bd82e09a56c30a">&#9670;&#160;</a></span>AlreadyExistsErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::AlreadyExistsErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00083">83</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a30a4999be011343be06bd28753bf8ecc" name="a30a4999be011343be06bd28753bf8ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a4999be011343be06bd28753bf8ecc">&#9670;&#160;</a></span>BeginEndRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt; util::BeginEndRange </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inline wrapper methods, to make the client code even simpler. The harm of overloading is probably less than the benefit of the nice, compact name, in this special case. </p>

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00059">59</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="a68be0ef9f4566f20fbf5238b24385216" name="a68be0ef9f4566f20fbf5238b24385216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68be0ef9f4566f20fbf5238b24385216">&#9670;&#160;</a></span>BeginEndRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; Iterator &gt; util::BeginEndRange </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; Iterator, Iterator &gt;</td>          <td class="paramname"><span class="paramname"><em>begin_end</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00063">63</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="aac4135532bf8cf1a7559e12f568d54d1" name="aac4135532bf8cf1a7559e12f568d54d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4135532bf8cf1a7559e12f568d54d1">&#9670;&#160;</a></span>CancelledErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::CancelledErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00087">87</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="ae469c559688b92f36bae2788c2e6063e" name="ae469c559688b92f36bae2788c2e6063e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae469c559688b92f36bae2788c2e6063e">&#9670;&#160;</a></span>ComputeOnePossibleReverseArcMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::ComputeOnePossibleReverseArcMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>die_if_not_symmetric</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector representing a mapping from arcs to arcs such that each arc is mapped to another arc with its (tail, head) flipped, if such an arc exists (otherwise it is mapped to -1). If the graph is symmetric, the returned mapping is bijective and reflexive, i.e. out[out[arc]] = arc for all "arc", where "out" is the returned vector. If "die_if_not_symmetric" is true, this function CHECKs() that the graph is symmetric.</p>
<p>Self-arcs are always mapped to themselves.</p>
<dl class="section note"><dt>Note</dt><dd>since graphs may have multi-arcs, the mapping isn't necessarily unique, hence the function name.</dd></dl>
<p>PERFORMANCE: If you see this function taking too much memory and/or too much time, reach out to viger@: one could halve the memory usage and speed it up. </p>
<p>We need a multi-map since a given (tail,head) may appear several times. NOTE(user): It's free, in terms of space, to use InlinedVector&lt;int, 4&gt; rather than std::vector&lt;int&gt;.</p>
<p>Special case: directly map any self-arc to itself.</p>
<p>Lookup for the reverse arc of the current one...</p>
<p>Found a reverse arc! Store the mapping and remove the reverse arc from the map.</p>
<p>Reverse arc not in the map. Add the current arc to the map.</p>
<p>Algorithm check, for debugging.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00390">390</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a0ed748741b17dad9e6cc485728bb0043" name="a0ed748741b17dad9e6cc485728bb0043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed748741b17dad9e6cc485728bb0043">&#9670;&#160;</a></span>CopyGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::CopyGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a fresh copy of a given graph. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00266">266</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ae8366c7e3d087665b74eef9ef0e51de1" name="ae8366c7e3d087665b74eef9ef0e51de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8366c7e3d087665b74eef9ef0e51de1">&#9670;&#160;</a></span>Create2DGridGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::Create2DGridGraph </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a 2-dimensional undirected grid graph.</p>
<p>Eg. for width=3, height=2, it generates this: 0 &lt;---&gt; 1 &lt;---&gt; 2 ^ ^ ^ | | | v v v 3 &lt;---&gt; 4 &lt;---&gt; 5 </p>
<p>Add horizontal edges.</p>
<p>Add vertical edges.</p>

<p class="definition">Definition at line <a class="el" href="graph_2test__util_8h_source.html#l00037">37</a> of file <a class="el" href="graph_2test__util_8h_source.html">test_util.h</a>.</p>

</div>
</div>
<a id="a5a8b955fd01d92c38c96d50dd7b36fa9" name="a5a8b955fd01d92c38c96d50dd7b36fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8b955fd01d92c38c96d50dd7b36fa9">&#9670;&#160;</a></span>DataLossErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::DataLossErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00091">91</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="ae6967409cb3e0a291eda5807f3edf796" name="ae6967409cb3e0a291eda5807f3edf796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6967409cb3e0a291eda5807f3edf796">&#9670;&#160;</a></span>DeadlineExceededErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::DeadlineExceededErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00095">95</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="aa5e88af7abf0237fef40aa76fe1ced1f" name="aa5e88af7abf0237fef40aa76fe1ced1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e88af7abf0237fef40aa76fe1ced1f">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a> implementation -------------------------------------------------&mdash;. </p>

</div>
</div>
<a id="a2d9509e821dd6c64b6f4c6c6c63c45b3" name="a2d9509e821dd6c64b6f4c6c6c63c45b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9509e821dd6c64b6f4c6c6c63c45b3">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aceb04ea52a19b7c3ae4c86957850ab35" name="aceb04ea52a19b7c3ae4c86957850ab35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb04ea52a19b7c3ae4c86957850ab35">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9bbf0716a9d1cac8bd6c0ad66783daa" name="ad9bbf0716a9d1cac8bd6c0ad66783daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bbf0716a9d1cac8bd6c0ad66783daa">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a> implementation ---------------------------------------&mdash;. </p>

</div>
</div>
<a id="ad08398f12eb94e794d43a1045faf7e60" name="ad08398f12eb94e794d43a1045faf7e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08398f12eb94e794d43a1045faf7e60">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8d0ef31f62ff56ff0ad11e5721a8080" name="ac8d0ef31f62ff56ff0ad11e5721a8080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d0ef31f62ff56ff0ad11e5721a8080">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09214d52f0cc00ecd35b503cac3cf000" name="a09214d52f0cc00ecd35b503cac3cf000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09214d52f0cc00ecd35b503cac3cf000">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac85a5d3a1aad9e7bfda6d12c98bb369b" name="ac85a5d3a1aad9e7bfda6d12c98bb369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85a5d3a1aad9e7bfda6d12c98bb369b">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a> implementation --------------------------------------&mdash;. </p>

</div>
</div>
<a id="a573de155eb302c0bf5784e27704eb8e2" name="a573de155eb302c0bf5784e27704eb8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573de155eb302c0bf5784e27704eb8e2">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1af2fada3816b822836dd33f559bbea" name="ac1af2fada3816b822836dd33f559bbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1af2fada3816b822836dd33f559bbea">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7013887aa554dc3e08cefb6849e0a22b" name="a7013887aa554dc3e08cefb6849e0a22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7013887aa554dc3e08cefb6849e0a22b">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19e87fd0da3ad033e247a92e879f1d31" name="a19e87fd0da3ad033e247a92e879f1d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e87fd0da3ad033e247a92e879f1d31">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a> implementation -------------------------------------&mdash;. </p>

</div>
</div>
<a id="a62d5cbf5cffa2a95ccd65c153548d111" name="a62d5cbf5cffa2a95ccd65c153548d111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d5cbf5cffa2a95ccd65c153548d111">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade20378d1ceb21797e3d393ec809f07d" name="ade20378d1ceb21797e3d393ec809f07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade20378d1ceb21797e3d393ec809f07d">&#9670;&#160;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f7a974e2fa9b8cde91cbcab0242c2e" name="a48f7a974e2fa9b8cde91cbcab0242c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f7a974e2fa9b8cde91cbcab0242c2e">&#9670;&#160;</a></span>DenseIntStableTopologicalSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::DenseIntStableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00524">524</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a5cda68f8ed2a159f060cfaafe2017e6f" name="a5cda68f8ed2a159f060cfaafe2017e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cda68f8ed2a159f060cfaafe2017e6f">&#9670;&#160;</a></span>DenseIntStableTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::DenseIntStableTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00569">569</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="af88ca9916b6307f51dd4983ffd2896ca" name="af88ca9916b6307f51dd4983ffd2896ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88ca9916b6307f51dd4983ffd2896ca">&#9670;&#160;</a></span>DenseIntTopologicalSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::DenseIntTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of the "simple API" functions declared at the top. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated</a></b></dt><dd>DenseInt[Stable]TopologicalSort[OrDie]. Kept here for legacy reasons, but most new users should use FastTopologicalSort():<ul>
<li>If your input is a list of edges, build you own <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph&lt;&gt;</a> (see ./graph.h) and pass it to FastTopologicalSort().</li>
<li>If you need the "stable sort" bit, contact viger@ and/or or-core-team@ to see if they can create FastStableTopologicalSort(). </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00517">517</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a0578f3afba5eb142e0dcca8063f6e66a" name="a0578f3afba5eb142e0dcca8063f6e66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0578f3afba5eb142e0dcca8063f6e66a">&#9670;&#160;</a></span>DenseIntTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::DenseIntTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00564">564</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a203f5498a7e1bc70f8ff62c0cfaaf8b1" name="a203f5498a7e1bc70f8ff62c0cfaaf8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203f5498a7e1bc70f8ff62c0cfaaf8b1">&#9670;&#160;</a></span>EqualRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MultiMap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::const_iterator &gt; util::EqualRange </td>
          <td>(</td>
          <td class="paramtype">const MultiMap &amp;</td>          <td class="paramname"><span class="paramname"><em>multi_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MultiMap::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00077">77</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="a628255019800e5a053d08b1f0c5a05f2" name="a628255019800e5a053d08b1f0c5a05f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628255019800e5a053d08b1f0c5a05f2">&#9670;&#160;</a></span>EqualRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MultiMap&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndWrapper.html">BeginEndWrapper</a>&lt; typename MultiMap::iterator &gt; util::EqualRange </td>
          <td>(</td>
          <td class="paramtype">MultiMap &amp;</td>          <td class="paramname"><span class="paramname"><em>multi_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MultiMap::key_type &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shortcut for BeginEndRange(multimap::equal_range(key)). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000711">Todo</a></b></dt><dd>(user): go further and expose only the values, not the pairs (key, values) since the caller already knows the key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00072">72</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="aeb73fb4c4369ff7beb4a819f3cc5831c" name="aeb73fb4c4369ff7beb4a819f3cc5831c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb73fb4c4369ff7beb4a819f3cc5831c">&#9670;&#160;</a></span>FailedPreconditionErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::FailedPreconditionErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00099">99</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="afa8fe0e94677e886c26ba2f3bade9a7f" name="afa8fe0e94677e886c26ba2f3bade9a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8fe0e94677e886c26ba2f3bade9a7f">&#9670;&#160;</a></span>FindCycleInDenseIntGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT std::vector&lt; int &gt; util::FindCycleInDenseIntGraph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>______________________ END OF THE RECOMMENDED API ___________________________ </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated</a></b></dt><dd>Use <a class="el" href="namespaceutil_1_1graph.html#a440afdf238e5a752bbe4e1bcc8878fe7">util::graph::FindCycleInGraph()</a> directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00145">145</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a8e79bcc13a6ff8ac5a0e2187888e540b" name="a8e79bcc13a6ff8ac5a0e2187888e540b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e79bcc13a6ff8ac5a0e2187888e540b">&#9670;&#160;</a></span>GenerateRandomDirectedSimpleGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&lt;&gt; &gt; util::GenerateRandomDirectedSimpleGraph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finalized</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="#a514fe075bc41a004214a90ff2542c992">GenerateRandomMultiGraph()</a>, but with neither multi-arcs nor self-arcs: the generated graph will have exactly num_arcs arcs. It will be picked uniformly at random from the set of all simple graphs with that number of nodes and arcs. </p>

<p class="definition">Definition at line <a class="el" href="random__graph_8cc_source.html#l00161">161</a> of file <a class="el" href="random__graph_8cc_source.html">random_graph.cc</a>.</p>

</div>
</div>
<a id="a514fe075bc41a004214a90ff2542c992" name="a514fe075bc41a004214a90ff2542c992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514fe075bc41a004214a90ff2542c992">&#9670;&#160;</a></span>GenerateRandomMultiGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&lt;&gt; &gt; util::GenerateRandomMultiGraph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finalized</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a random graph where multi-arcs and self-arcs are allowed (and therefore expected): exactly "num_arcs" are generated, each from a node picked uniformly at random to another node picked uniformly at random. Calls Build() on the graph iff "finalized" is true. </p>

<p class="definition">Definition at line <a class="el" href="random__graph_8cc_source.html#l00054">54</a> of file <a class="el" href="random__graph_8cc_source.html">random_graph.cc</a>.</p>

</div>
</div>
<a id="a972b9b2f0e8122bf87ac39f89a7360c7" name="a972b9b2f0e8122bf87ac39f89a7360c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972b9b2f0e8122bf87ac39f89a7360c7">&#9670;&#160;</a></span>GenerateRandomUndirectedSimpleGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&lt;&gt; &gt; util::GenerateRandomUndirectedSimpleGraph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>finalized</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::BitGenRef</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="#a8e79bcc13a6ff8ac5a0e2187888e540b">GenerateRandomDirectedSimpleGraph()</a>, but where an undirected edge is represented by two arcs: a-&gt;b and b-&gt;a. As a result, the amount of arcs in the generated graph is 2*num_edges. </p>

<p class="definition">Definition at line <a class="el" href="random__graph_8cc_source.html#l00167">167</a> of file <a class="el" href="random__graph_8cc_source.html">random_graph.cc</a>.</p>

</div>
</div>
<a id="a13f0e8f7e15873600cf8e395958c71e1" name="a13f0e8f7e15873600cf8e395958c71e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f0e8f7e15873600cf8e395958c71e1">&#9670;&#160;</a></span>GetConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UndirectedGraph&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::GetConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UndirectedGraph &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the connected components of the graph, using BFS internally. Works on any <em>undirected</em> graph class whose nodes are dense integers and that supports the [] operator for adjacency lists: graph[x] must be an integer container listing the nodes that are adjacent to node #x. Example: std::vector&lt;std::vector&lt;int&gt;&gt;.</p>
<p>"Undirected" means that for all y in graph[x], x is in graph[y].</p>
<p>Returns the mapping from node to component index. The component indices are deterministic: Component #0 will be the one that has node #0, component #1 the one that has the lowest-index node that isn't in component #0, and so on.</p>
<p>Example on the following 6-node graph: 5&ndash;3&ndash;0&ndash;1 2&ndash;4 vector&lt;vector&lt;int&gt;&gt; graph = {{1, 3}, {0}, {4}, {0, 5}, {2}, {3}}; GetConnectedComponents(graph); ///&lt; returns [0, 0, 1, 0, 1, 0]. </p>

<p class="definition">Definition at line <a class="el" href="connected__components_8h_source.html#l00078">78</a> of file <a class="el" href="connected__components_8h_source.html">connected_components.h</a>.</p>

</div>
</div>
<a id="ac4f1c7c8153d3d3ef062a2bb08c0c310" name="ac4f1c7c8153d3d3ef062a2bb08c0c310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f1c7c8153d3d3ef062a2bb08c0c310">&#9670;&#160;</a></span>GetConnectedComponentsTpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UndirectedGraph, class NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; util::GetConnectedComponentsTpl </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UndirectedGraph &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic version of <a class="el" href="#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents()</a> (see below) that supports other integer types, e.g. int64_t for huge graphs with more than 2^31 nodes. </p>
<p>We use 'num_nodes' as special component id meaning 'unknown', because it's of the right type, and -1 is tricky to use with unsigned ints.</p>

<p class="definition">Definition at line <a class="el" href="connected__components_8h_source.html#l00333">333</a> of file <a class="el" href="connected__components_8h_source.html">connected_components.h</a>.</p>

</div>
</div>
<a id="adbba6a42d616fc4fb5c9ab3afe649197" name="adbba6a42d616fc4fb5c9ab3afe649197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbba6a42d616fc4fb5c9ab3afe649197">&#9670;&#160;</a></span>GetSubgraphOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::GetSubgraphOfNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the induced subgraph of "graph" restricted to the nodes in "nodes": the resulting graph will have exactly nodes.size() nodes, and its node #0 will be the former graph's node #nodes[0], etc. See <a href="https://en.wikipedia.org/wiki/Induced_subgraph">https://en.wikipedia.org/wiki/Induced_subgraph</a> . The "nodes" must be a valid subset (no repetitions) of [0..graph.num_nodes()-1], or the behavior is undefined (it may die). </p><dl class="section note"><dt>Note</dt><dd>you can call <a class="el" href="#aca9c2faec725bc47baf08421b377f643">IsSubsetOf0N()</a> to check it yourself.</dd></dl>
<p>Current complexity: O(num old nodes + num new arcs). It could easily be done in O(num new nodes + num new arcs) but with a higher constant. </p>
<p>Do a first pass to count the arcs, so that we don't allocate more memory than needed.</p>
<p>A second pass where we actually copy the subgraph. NOTE(user): there might seem to be a bit of duplication with <a class="el" href="#a88c65bcf51a7c679ad0159e09ecfb3fc">RemapGraph()</a>, but there is a key difference: the loop below only iterates on "nodes", which could be much smaller than all the graph's nodes.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00298">298</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a8a31111f9a74492f1de9238e463edd2a" name="a8a31111f9a74492f1de9238e463edd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a31111f9a74492f1de9238e463edd2a">&#9670;&#160;</a></span>GetWeaklyConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::GetWeaklyConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the weakly connected components of a directed graph that provides the OutgoingOrOppositeIncomingArcs() API, and returns them as a mapping from node to component index. See <a class="el" href="#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents()</a>. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00137">137</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a6b37593970a26f5c88b3d2ea9acea9d2" name="a6b37593970a26f5c88b3d2ea9acea9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b37593970a26f5c88b3d2ea9acea9d2">&#9670;&#160;</a></span>GraphHasDuplicateArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphHasDuplicateArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00203">203</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ac4af76993c891ee4ad507783edec2a1c" name="ac4af76993c891ee4ad507783edec2a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4af76993c891ee4ad507783edec2a1c">&#9670;&#160;</a></span>GraphHasSelfArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphHasSelfArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementations of the templated methods. </p>
<p>Here's a set of simple diagnosis tools. Notes:</p><ul>
<li>A self-arc is an arc from a node to itself.</li>
<li>We say that an arc A-&gt;B is duplicate when there is another arc A-&gt;B in the same graph.</li>
<li>A graph is said "weakly connected" if it is connected when considering all arcs as undirected edges.</li>
<li>A graph is said "symmetric" iff for all (a, b), the number of arcs a-&gt;b is equal to the number of arcs b-&gt;a.</li>
</ul>
<p>All these diagnosis work in O(graph size), since the inverse Ackerman function is &lt;= 5 for all practical instances, and are very fast.</p>
<p>If the graph is a "static" kind, they must be finalized, except for <a class="el" href="#ac4af76993c891ee4ad507783edec2a1c" title="Implementations of the templated methods.">GraphHasSelfArcs()</a> and <a class="el" href="#a97311561fd1f01e9f35b2f7ce18b0af3">GraphIsWeaklyConnected()</a> which also support non-finalized <a class="el" href="classutil_1_1StaticGraph.html">StaticGraph&lt;&gt;</a>. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00195">195</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a784b483eeae1b49164a8a02fe9c0d3ba" name="a784b483eeae1b49164a8a02fe9c0d3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784b483eeae1b49164a8a02fe9c0d3ba">&#9670;&#160;</a></span>GraphIsSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphIsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a reverse copy of the graph.</p>
<p>Compare the graph to its reverse, one adjacency list at a time.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00221">221</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a97311561fd1f01e9f35b2f7ce18b0af3" name="a97311561fd1f01e9f35b2f7ce18b0af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97311561fd1f01e9f35b2f7ce18b0af3">&#9670;&#160;</a></span>GraphIsWeaklyConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphIsWeaklyConnected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00250">250</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="affed79554a202aaa8bda5b5e98c3a6b2" name="affed79554a202aaa8bda5b5e98c3a6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affed79554a202aaa8bda5b5e98c3a6b2">&#9670;&#160;</a></span>GraphToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string util::GraphToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementations of the templated methods. </p>

<p class="definition">Definition at line <a class="el" href="graph__io_8h_source.html#l00078">78</a> of file <a class="el" href="graph__io_8h_source.html">graph_io.h</a>.</p>

</div>
</div>
<a id="a302ee4bfcb86ea9ed64a193ed0b14648" name="a302ee4bfcb86ea9ed64a193ed0b14648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302ee4bfcb86ea9ed64a193ed0b14648">&#9670;&#160;</a></span>InternalErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::InternalErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00103">103</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="ad0c886e6b95bc531d4a39884a87c0101" name="ad0c886e6b95bc531d4a39884a87c0101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c886e6b95bc531d4a39884a87c0101">&#9670;&#160;</a></span>InvalidArgumentErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::InvalidArgumentErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00107">107</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="aca9c2faec725bc47baf08421b377f643" name="aca9c2faec725bc47baf08421b377f643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c2faec725bc47baf08421b377f643">&#9670;&#160;</a></span>IsSubsetOf0N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool util::IsSubsetOf0N </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the given vector is a subset of [0..n-1], i.e. all elements i are such that 0 &lt;= i &lt; n and no two elements are equal. "n" must be &gt;= 0 or the result is undefined. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8cc_source.html#l00022">22</a> of file <a class="el" href="graph_2util_8cc_source.html">util.cc</a>.</p>

</div>
</div>
<a id="a0aab823d80d85f004d3d2139cc4f6c2f" name="a0aab823d80d85f004d3d2139cc4f6c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aab823d80d85f004d3d2139cc4f6c2f">&#9670;&#160;</a></span>IsValidPermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::IsValidPermutation </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the given vector is a permutation of [0..size()-1]. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00148">148</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="afe1146d4103ad0b93801f626715519d6" name="afe1146d4103ad0b93801f626715519d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1146d4103ad0b93801f626715519d6">&#9670;&#160;</a></span>NotFoundErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::NotFoundErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00111">111</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="aa86ac164f0f951fca26cc3e9b34d9632" name="aa86ac164f0f951fca26cc3e9b34d9632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86ac164f0f951fca26cc3e9b34d9632">&#9670;&#160;</a></span>OutOfRangeErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::OutOfRangeErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00115">115</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a34114d206959f75a472b167c806da2cb" name="a34114d206959f75a472b167c806da2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34114d206959f75a472b167c806da2cb">&#9670;&#160;</a></span>PathHasCycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::PathHasCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the given path contains a cycle. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00379">379</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ab85d86fd35e985c0fb4c4a200d72adda" name="ab85d86fd35e985c0fb4c4a200d72adda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85d86fd35e985c0fb4c4a200d72adda">&#9670;&#160;</a></span>PermissionDeniedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::PermissionDeniedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00119">119</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a8c227a057c1ce9d46b1185abf77ad91e" name="a8c227a057c1ce9d46b1185abf77ad91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c227a057c1ce9d46b1185abf77ad91e">&#9670;&#160;</a></span>Permute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector, class Array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::Permute </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array *</td>          <td class="paramname"><span class="paramname"><em>array_to_permute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00756">756</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ac497881c4166bc694adc4bee62746118" name="ac497881c4166bc694adc4bee62746118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac497881c4166bc694adc4bee62746118">&#9670;&#160;</a></span>Permute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::Permute </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; *</td>          <td class="paramname"><span class="paramname"><em>array_to_permute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We need a specialization for vector&lt;bool&gt;, because the default code uses (*array_to_permute)[0] as ElementType, which isn't 'bool' in that case. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00767">767</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a9470623ca7db3c4a62ce3b326c6b07d8" name="a9470623ca7db3c4a62ce3b326c6b07d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9470623ca7db3c4a62ce3b326c6b07d8">&#9670;&#160;</a></span>PermuteWithExplicitElementType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector, class Array, class ElementType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::PermuteWithExplicitElementType </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array *</td>          <td class="paramname"><span class="paramname"><em>array_to_permute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType</td>          <td class="paramname"><span class="paramname"><em>unused</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permutes the elements of array_to_permute: element #i will be moved to position permutation[i]. permutation must be either empty (in which case nothing happens), or a permutation of [0, permutation.size()).</p>
<p>The algorithm is fast but need extra memory for a copy of the permuted part of array_to_permute.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000688">Todo</a></b></dt><dd>(user): consider slower but more memory efficient implementations that follow the cycles of the permutation and use a bitmap to indicate what has been permuted or to mark the beginning of each cycle. </dd></dl>
<p>Some compiler do not know typeof(), so we have to use this extra function internally. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00743">743</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a88c65bcf51a7c679ad0159e09ecfb3fc" name="a88c65bcf51a7c679ad0159e09ecfb3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c65bcf51a7c679ad0159e09ecfb3fc">&#9670;&#160;</a></span>RemapGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::RemapGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>new_node_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a remapped copy of graph "graph", where node i becomes node new_node_index[i]. "new_node_index" must be a valid permutation of [0..num_nodes-1] or the behavior is undefined (it may die). </p><dl class="section note"><dt>Note</dt><dd>you can call <a class="el" href="#a0aab823d80d85f004d3d2139cc4f6c2f" title="Returns true iff the given vector is a permutation of [0..size()-1].">IsValidPermutation()</a> to check it yourself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00279">279</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a06fa201576c927d92657e090fa86bfdb" name="a06fa201576c927d92657e090fa86bfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fa201576c927d92657e090fa86bfdb">&#9670;&#160;</a></span>RemoveCyclesFromPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::RemoveCyclesFromPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>arc_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an arc path, changes it to a sub-path with the same source and destination but without any cycle. Nothing happen if the path was already without cycle.</p>
<p>The graph class should support Tail(arc) and Head(arc). They should both return an integer representing the corresponding tail/head of the passed arc.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000770">Todo</a></b></dt><dd>(user): In some cases, there is more than one possible solution. We could take some arc costs and return the cheapest path instead. Or return the shortest path in term of number of arcs. </dd></dl>
<p>This maps each node to the latest arc in the given path that leaves it.</p>
<p>Special case for the destination. </p><dl class="section note"><dt>Note</dt><dd>this requires that -1 is not a valid arc of <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">Graph</a>.</dd></dl>
<p>Reconstruct the path by starting at the source and then following the "next" arcs. We override the given arc_path at the same time.</p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00354">354</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a8a06031908a024a50dbdddc394a22490" name="a8a06031908a024a50dbdddc394a22490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a06031908a024a50dbdddc394a22490">&#9670;&#160;</a></span>RemoveSelfArcsAndDuplicateArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::RemoveSelfArcsAndDuplicateArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of "graph", without self-arcs and duplicate arcs. </p>

<p class="definition">Definition at line <a class="el" href="graph_2util_8h_source.html#l00332">332</a> of file <a class="el" href="graph_2util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a007b8813fdd1c082efc4e08fbcb8a83e" name="a007b8813fdd1c082efc4e08fbcb8a83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007b8813fdd1c082efc4e08fbcb8a83e">&#9670;&#160;</a></span>ResourceExhaustedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::ResourceExhaustedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00127">127</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a208121f27c615b309e2ab37bb85280f1" name="a208121f27c615b309e2ab37bb85280f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208121f27c615b309e2ab37bb85280f1">&#9670;&#160;</a></span>Reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1BeginEndReverseIteratorWrapper.html">BeginEndReverseIteratorWrapper</a>&lt; Container &gt; util::Reverse </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_2iterators_8h_source.html#l00099">99</a> of file <a class="el" href="graph_2iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="a9f8f58bd1b46837f8305d316bb84d0e1" name="a9f8f58bd1b46837f8305d316bb84d0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8f58bd1b46837f8305d316bb84d0e1">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "Stable" variants are a little slower but preserve the input order of nodes, if possible. More precisely, the returned topological order will be the lexicographically minimal valid order, where "lexicographic" applies to the indices of the nodes. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00548">548</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a4ed25a07b58c38bbfba6e2912024e541" name="a4ed25a07b58c38bbfba6e2912024e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed25a07b58c38bbfba6e2912024e541">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "Stable" variants are a little slower but preserve the input order of nodes, if possible. More precisely, the returned topological order will be the lexicographically minimal valid order, where "lexicographic" applies to the indices of the nodes. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00548">548</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ac974be3bae074c99c0d7d7a5aedbc757" name="ac974be3bae074c99c0d7d7a5aedbc757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac974be3bae074c99c0d7d7a5aedbc757">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>cycle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00556">556</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a37f37ea5a316975b7039dc07929a5b65" name="a37f37ea5a316975b7039dc07929a5b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f37ea5a316975b7039dc07929a5b65">&#9670;&#160;</a></span>StableTopologicalSort() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::StableTopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>cycle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00556">556</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ae8b0775ffcab4f306414763e156b97e5" name="ae8b0775ffcab4f306414763e156b97e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b0775ffcab4f306414763e156b97e5">&#9670;&#160;</a></span>StableTopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; util::StableTopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OrDie() variant of the above. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00581">581</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a49200d01f1aec6ee7837ad3e09b0d880" name="a49200d01f1aec6ee7837ad3e09b0d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49200d01f1aec6ee7837ad3e09b0d880">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[Stable]TopologicalSort[OrDie]:</p>
<p>These variants are much slower than FastTopologicalSort(), but support non-integer (or integer, but sparse) nodes. </p><dl class="section note"><dt>Note</dt><dd>if performance matters, you're probably better off building your own mapping from node to dense index with a flat_hash_map and calling FastTopologicalSort(). Returns true if the graph was a DAG, and outputs the topological order in "topological_order". Returns false if the graph is cyclic, and outputs the detected cycle in "cycle". </dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00532">532</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ad2ae803e2d0270a720f294269b30fc10" name="ad2ae803e2d0270a720f294269b30fc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ae803e2d0270a720f294269b30fc10">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[Stable]TopologicalSort[OrDie]:</p>
<p>These variants are much slower than FastTopologicalSort(), but support non-integer (or integer, but sparse) nodes. </p><dl class="section note"><dt>Note</dt><dd>if performance matters, you're probably better off building your own mapping from node to dense index with a flat_hash_map and calling FastTopologicalSort(). Returns true if the graph was a DAG, and outputs the topological order in "topological_order". Returns false if the graph is cyclic, and outputs the detected cycle in "cycle". </dd></dl>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00532">532</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a3adc100d0fc2606414e4cdf062a80c97" name="a3adc100d0fc2606414e4cdf062a80c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adc100d0fc2606414e4cdf062a80c97">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>cycle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00540">540</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a6da65a9795112f2e6b57c9cfe950f4a3" name="a6da65a9795112f2e6b57c9cfe950f4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da65a9795112f2e6b57c9cfe950f4a3">&#9670;&#160;</a></span>TopologicalSort() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::TopologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>cycle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override of the above that outputs the detected cycle. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00540">540</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="ab75288075e89561fd1564e40123cd7dd" name="ab75288075e89561fd1564e40123cd7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75288075e89561fd1564e40123cd7dd">&#9670;&#160;</a></span>TopologicalSortOrDie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; util::TopologicalSortOrDie </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arcs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OrDie() variant of the above. </p>

<p class="definition">Definition at line <a class="el" href="topologicalsorter_8h_source.html#l00575">575</a> of file <a class="el" href="topologicalsorter_8h_source.html">topologicalsorter.h</a>.</p>

</div>
</div>
<a id="a5bf5136a95272248cacae1d1a036e8ea" name="a5bf5136a95272248cacae1d1a036e8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf5136a95272248cacae1d1a036e8ea">&#9670;&#160;</a></span>UnauthenticatedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnauthenticatedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00123">123</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a5532f9a3e8b48bd067e8576789fe36bc" name="a5532f9a3e8b48bd067e8576789fe36bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5532f9a3e8b48bd067e8576789fe36bc">&#9670;&#160;</a></span>UnavailableErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnavailableErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00131">131</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a34739da67ea599226350b0cb5d1cbad6" name="a34739da67ea599226350b0cb5d1cbad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34739da67ea599226350b0cb5d1cbad6">&#9670;&#160;</a></span>UnimplementedErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnimplementedErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00135">135</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a23561d268e106df9d3aeba1897ab3c2a" name="a23561d268e106df9d3aeba1897ab3c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23561d268e106df9d3aeba1897ab3c2a">&#9670;&#160;</a></span>UnknownErrorBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1StatusBuilder.html">StatusBuilder</a> util::UnknownErrorBuilder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="status__builder_8h_source.html#l00139">139</a> of file <a class="el" href="status__builder_8h_source.html">status_builder.h</a>.</p>

</div>
</div>
<a id="a2bc3683e5d8f49f745bea0fa513f1675" name="a2bc3683e5d8f49f745bea0fa513f1675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc3683e5d8f49f745bea0fa513f1675">&#9670;&#160;</a></span>WriteGraphToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::Status util::WriteGraphToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>directed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const int &gt;</td>          <td class="paramname"><span class="paramname"><em>num_nodes_with_color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a graph to the ".g" file format described above. If "directed" is true, all arcs are written to the file. If it is false, the graph is expected to be undirected (i.e. the number of arcs a-&gt;b is equal to the number of arcs b-&gt;a for all nodes a,b); and only the arcs a-&gt;b where a&lt;=b are written. Note however that in this case, the symmetry of the graph is not fully checked (only the parity of the number of non-self arcs is).</p>
<p>"num_nodes_with_color" is optional. If it is not empty, then the color information will be written to the header of the .g file. See ReadGraphFile.</p>
<p>This method is the reverse of ReadGraphFile (with the same value for "directed"). </p>
<p>In undirected mode, we must count the self-arcs separately. All other arcs should be duplicated.</p>

<p class="definition">Definition at line <a class="el" href="graph__io_8h_source.html#l00114">114</a> of file <a class="el" href="graph__io_8h_source.html">graph_io.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1e53dea0266bc3a290c6fde611d3cf87" name="a1e53dea0266bc3a290c6fde611d3cf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e53dea0266bc3a290c6fde611d3cf87">&#9670;&#160;</a></span>BaseGraph&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::kNilArc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndexType, typename ArcIndexType, bool HasNegativeReverseArcs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ArcIndexType <a class="el" href="classutil_1_1BaseGraph.html">util::BaseGraph</a>&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::kNilArc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::numeric_limits&lt;ArcIndexType&gt;::max()</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00989">989</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a418964a1c3ba7d63e28316baf980cec6" name="a418964a1c3ba7d63e28316baf980cec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418964a1c3ba7d63e28316baf980cec6">&#9670;&#160;</a></span>BaseGraph&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::kNilNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndexType, typename ArcIndexType, bool HasNegativeReverseArcs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const NodeIndexType <a class="el" href="classutil_1_1BaseGraph.html">util::BaseGraph</a>&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::kNilNode</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::numeric_limits&lt;NodeIndexType&gt;::max()</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00983">983</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutil.html">util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
