<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.5</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('todo.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Todo List </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="lp__solver_8cc.html#aa3003ab2d06a8ff3b490c100232fc05c">ABSL_FLAG</a>  (bool, lp_dump_to_proto_file, false, "Tells whether do dump the problem to a protobuf file.")</dt>
<dd><a class="anchor" id="_todo000391"></a>(user): abstract this in some way to the port directory.  </dd>
<dt>Member <a class="el" href="cp__model__search_8cc.html#a5254d8329101ce8f7213c759d6ad56b4">ABSL_FLAG</a>  (bool, cp_model_use_max_hs, false, "Use max_hs in search portfolio.")</dt>
<dd><a class="anchor" id="_todo001227"></a>(user): remove this when the code is stable and does not use SCIP anymore.  </dd>
<dt>Member <a class="el" href="max__hs_8cc.html#a1bcd4379e7db62efdf5ffc541a76255f">ABSL_FLAG</a>  (int, max_hs_strategy, 0, "MaxHsStrategy: 0 extract only objective variable, 1 extract all variables " "colocated with objective variables, 2 extract all variables in the " "linearization")</dt>
<dd><a class="anchor" id="_todo001710"></a>(user): Remove this flag when experiments are stable.  </dd>
<dt>Member <a class="el" href="min__cost__flow_8cc.html#ab29882272822b270edac48bc8b0ab14e">ABSL_FLAG</a>  (int64_t, min_cost_flow_alpha, 5, "Divide factor for epsilon at each refine step.")</dt>
<dd><a class="anchor" id="_todo000620"></a>(user): Remove these flags and expose the parameters in the API. New clients, please do not use these flags!  </dd>
<dt>Class <a class="el" href="classCycleTimer.html">CycleTimer</a>  </dt>
<dd><a class="anchor" id="_todo000039"></a>(user): implement it.  </dd>
<dt>Member <a class="el" href="revised__simplex_8cc.html#a8806083a7bf6a4ee4a4976c226b93788">DCHECK_ROW_BOUNDS</a>  (row)</dt>
<dd><a class="anchor" id="_todo000493"></a>(user): Remove this function.  </dd>
<dt>Member <a class="el" href="fp__utils_8h.html#a417a0547a8cf6eff90b4430609e054b0">EXPECT_COMPARABLE</a>  (expected, obtained, epsilon)</dt>
<dd><a class="anchor" id="_todo002130"></a>(user): investigate moving this to ortools/base/ or some other place.  </dd>
<dt>Member <a class="el" href="rounding__modes__benchmark_8cc.html#ab050a9a2102dedebc6fe56b739cb32ab">GetFloatingPointControlRegister</a>  ()</dt>
<dd><a class="anchor" id="_todo002142"></a>(user): implement for other architectures.  </dd>
<dt>Member <a class="el" href="namespacegoogle.html#aca101991c49a382dd4097e6b9681ae50">google::InitVLOG3__</a>  (int32_t **vmodule_info, bool *initialized, const char *fname, int32_t verbose_level)</dt>
<dd><a class="anchor" id="_todo000040"></a>: Trim out _unittest suffix? Perhaps it is better to have the extra control and just leave it there.  </dd>
<dt>Namespace <a class="el" href="namespacegtl.html">gtl</a>  </dt>
<dd><a class="anchor" id="_todo000037"></a>(user): Broaden the scope and rename to "stream_util.h" </dd>
<dt>Namespace <a class="el" href="namespaceoperations__research.html">operations_research</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000422"></a>(user): Determine whether any of these would bring any benefit:</p><ul>
<li>S.C. Eisenstat and J.W.H. Liu, "The theory of elimination trees for
  sparse unsymmetric matrices," SIAM J. Matrix Anal. Appl., 26:686-705, January 2005</li>
<li>S.C. Eisenstat and J.W.H. Liu. "Algorithmic aspects of elimination trees
  for sparse unsymmetric matrices," SIAM J. Matrix Anal. Appl., 29:1363-1381, January 2008.</li>
<li><a href="http://perso.ens-lyon.fr/~bucar/papers/kauc.pdf">http://perso.ens-lyon.fr/~bucar/papers/kauc.pdf</a> </li>
</ul>
<p class="interdd"><a class="anchor" id="_todo000612"></a>(user): implement the above active node choice rule.</p>
<p class="interdd"><a class="anchor" id="_todo000004"></a>(user): refine this toplevel comment when this file settles.</p>
<p class="interdd"><a class="anchor" id="_todo000031"></a>(user): Merge this code with algorithms/knapsack_solver.</p>
<p class="interdd"><a class="anchor" id="_todo002143"></a>(user): make this implementation the default everywhere. </p>
<p class="interdd"></p>
<p class="interdd">(user): investigate the code generated by MSVC. </p>
<p class="interdd"><a class="anchor" id="_todo000315"></a>(user): Move all existing routing search code here. </p>
<p class="interdd"><a class="anchor" id="_todo000709"></a>(user): post c++ 14, instead use std::pair&lt;MPSolver::OptimizationProblemType, const absl::string_view&gt; once pair gets a constexpr constructor. </p>
<p class="interdd"><a class="anchor" id="_todo000703"></a>(user): handle timeouts, compute row and column statuses. </p>
<p class="interdd"><a class="anchor" id="_todo000613"></a>(user): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow
Problem.‚Äù In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008.
http://www.springerlink.com/index/5535k2j1mt646338.pdf&lt;p&gt; \anchor _todo000026 (user): base this code on LinearSumAssignment.&lt;p&gt; \anchor _todo000338 (user) : treat optional intervals
 &lt;p&gt; &lt;p&gt;(user) : Call DecisionVisitor and pass name of variable 
 &lt;p&gt; \anchor _todo000227 (user): Move most of the following settings to a model parameter
proto. 
 &lt;p&gt; \anchor _todo001945 (user): for now it is mainly presolve, but the idea is to call these
function during the search so they should be as incremental as possible. That
is avoid doing work that is not useful because nothing changed or exploring
parts that were not done during the last round. 
 &lt;p&gt; \anchor _todo000649 (user): This is a work in progress. The algo is not fully implemented
yet. The initial version is closer to Blossom IV since we update the dual
values for all trees at once with the same delta. 
 &lt;p&gt; \anchor _todo000573 (user) although it is already possible, using the
   GroupForwardArcsByFunctor method, to group all the outgoing (resp.
   incoming) arcs of a node, the iterator logic could still be improved to
   allow traversing the outgoing (resp. incoming) arcs in O(out_degree(node))
   (resp. O(in_degree(node))) instead of O(degree(node)).
 *  &lt;p&gt; &lt;p&gt;(user) it is possible to implement arc deletion and garbage collection
   in an efficient (relatively) manner. For the time being we haven't seen an
   application for this.&lt;p&gt; \anchor _todo001985 (user): Expand. 
 &lt;p&gt; \anchor _todo000627 (user): See whether the following can bring any improvements on real-life
problems.
R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost flows by double scaling," Mathematical Programming, (1992) 53:243-266.
http://www.springerlink.com/index/gu7404218u6kt166.pdf&lt;p&gt; \anchor _todo000589 (user): implement pruning procedures on top of the Held-Karp algorithm.&lt;p&gt; \anchor _todo000809 (b/180617976): change this behavior.&lt;p&gt; \anchor _todo000673 (user): either implement with SCIP constraint handlers or use a solver
independent implementation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::@124 Namespace \_internalref namespaceoperations__research_1_1_0d124 "<a class="el" href="namespaceoperations__research.html" title="In SWIG mode, we don&#39;t want anything besides these top-level includes.">operations_research</a>::@124" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000175 (user): improve code when assume_paths is false (currently does an
expensive n^2 loop). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::@148 Namespace \_internalref namespaceoperations__research_1_1_0d148 "<a class="el" href="namespaceoperations__research.html" title="In SWIG mode, we don&#39;t want anything besides these top-level includes.">operations_research</a>::@148" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000329 (user): Clean up to match other first solution strategies. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AdaptiveParameterValue Class \_internalref classoperations__research_1_1AdaptiveParameterValue "<a class="el" href="classoperations__research_1_1AdaptiveParameterValue.html">operations_research::AdaptiveParameterValue</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002121 (user): The current logic work well in practice, but has no strong
theoretical foundation. We should be able to come up with a better understood
formula that converge way faster. It will also be nice to generalize the 0.5
above to a target probability p. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#acc3626b36637c627bb520724b3524c58 "<a class="el" href="namespaceoperations__research.html#acc3626b36637c627bb520724b3524c58">operations_research::AddLocalSearchNeighborhoodOperatorsFromFlags</a>" (RoutingSearchParameters *parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000283 (user): Remove these overrides: they should be set by the caller, via
a baseline RoutingSearchParameters obtained from DefaultSearchParameters(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a93bd93f028c18a4b55b30056ef60df44 "<a class="el" href="namespaceoperations__research.html#a93bd93f028c18a4b55b30056ef60df44">operations_research::AddOverflows</a>" (int64_t x, int64_t y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002144 (user): consider making some operations overflow-sticky, some others
not, but make an explicit choice throughout. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AffineRelation Class \_internalref classoperations__research_1_1AffineRelation "<a class="el" href="classoperations__research_1_1AffineRelation.html">operations_research::AffineRelation</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002122 (user): it might be possible to do something fancier and drop less
relations if all the affine relations are given before hand. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AffineRelation Member \_internalref classoperations__research_1_1AffineRelation#a42c79bfbcf36db0e14d942a6079a8564 "<a class="el" href="classoperations__research_1_1AffineRelation.html#a5c2556af84128ec02d7f72be8c51a43d">operations_research::AffineRelation::TryAdd</a>" (int x, int y, int64_t coeff, int64_t offset, bool allow_rep_x, bool allow_rep_y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002123 (user): It should be possible to optimize this code block a bit, for
instance depending on the magnitude of new_coeff vs coeff_x, we may already
know that one of the two merge is not possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a38cd9519fdea9ef6c87480955852a8c7 "<a class="el" href="namespaceoperations__research.html#a38cd9519fdea9ef6c87480955852a8c7">operations_research::ApplyMipPresolveSteps</a>" (const glop::GlopParameters &amp;glop_params, MPModelProto *model, std::vector&lt; std::unique_ptr&lt; glop::Preprocessor &gt; &gt; *for_postsolve, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000732 (user): General constraints are currently not supported.
 &lt;p&gt; \anchor _todo000735 (user): Usually it is good to run the ImpliedFreePreprocessor before
this one. However this seems to cause problem on atm20-100.mps. Moreover,
for the conversion, it is better to have tight bounds even if the bound
propagator is supposed to undo what this presolve would have done. 
 &lt;p&gt; \anchor _todo000733 (user): Remove this back and forth conversion. We could convert
the LinearProgram directly to a CpModelProto, or we could have a custom
implementation of these presolve steps. 
 &lt;p&gt; \anchor _todo000734 (user): transform the hint instead of disabling presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Assignment Member \_internalref classoperations__research_1_1Assignment#aa4afa275944d2cc69a7a252bafc1e311 "<a class="el" href="classoperations__research_1_1Assignment.html#aa4afa275944d2cc69a7a252bafc1e311">operations_research::Assignment::IntVarContainer</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000123 (user): Add element iterators to avoid exposing container class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a270548116df8ad74e03d376c40025566 "<a class="el" href="namespaceoperations__research.html#a270548116df8ad74e03d376c40025566">operations_research::AutomaticFirstSolutionStrategy</a>" (bool has_pickup_deliveries, bool has_node_precedences, bool has_single_vehicle_node)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000316 (user): Make this smarter. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BaseInactiveNodeToPathOperator Member \_internalref classoperations__research_1_1BaseInactiveNodeToPathOperator#ae5c0379aedc108402f038bc324bdc175 "<a class="el" href="classoperations__research_1_1BaseInactiveNodeToPathOperator.html#ae5c0379aedc108402f038bc324bdc175">operations_research::BaseInactiveNodeToPathOperator::BaseInactiveNodeToPathOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;secondary_vars, int number_of_base_nodes, std::function&lt; int(int64_t)&gt; start_empty_path_class)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000204 (user): Activate skipping optimal paths.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Bitmap Member \_internalref classoperations__research_1_1Bitmap#a10079c77d15fd313c09b89b46756d4e3 "<a class="el" href="classoperations__research_1_1Bitmap.html#a10079c77d15fd313c09b89b46756d4e3">operations_research::Bitmap::Resize</a>" (uint32_t size, bool fill=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000036 (user) : optimize next loop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab7253ffd8b7aba4b7cb5f981c7627526 "<a class="el" href="namespaceoperations__research.html#ab7253ffd8b7aba4b7cb5f981c7627526" title="Bit operators used to manipulates bitsets.">operations_research::BitPos64</a>" (uint64_t pos)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002125 (user): rename BitPos and BitOffset to something more understandable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Bitset64 Member \_internalref classoperations__research_1_1Bitset64#adde7d1500621913ae1f3e71cda4fb502 "<a class="el" href="classoperations__research_1_1Bitset64.html#adde7d1500621913ae1f3e71cda4fb502" title="Changes the number of bits the Bitset64 can hold and set all of them to 0.">operations_research::Bitset64&lt; IndexType &gt;::ClearAndResize</a>" (IndexType size)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002126 (user): Ideally if a realloc happens, we don't need to copy the old
data... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Class \_internalref classoperations__research_1_1BlossomGraph "<a class="el" href="classoperations__research_1_1BlossomGraph.html">operations_research::BlossomGraph</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000651 (user): For now we use CHECKs in many places to facilitate development.
Switch them to DCHECKs for speed once the code is more stable. 
 &lt;p&gt; \anchor _todo000650 (user): For now this class does not maintain a second graph of edges
between the trees nor does it maintains priority queue of edges.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a1cc997de6330ea47db84ebfbc97c3855 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a1cc997de6330ea47db84ebfbc97c3855">operations_research::BlossomGraph::Augment</a>" (EdgeIndex e)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000646 (user): This could probably be optimized if needed. But we do usually
iterate a lot more over it than we update it. Note that as long as we use
the same delta for all trees, this is not even needed. 
 &lt;p&gt; \anchor _todo000643 (user): Check all dual/slack same after primal op?
 &lt;p&gt; \anchor _todo000644 (user): It seems that we may waste some computation since the part of
the tree not in the path between roots can lead to the same Grow()
operations later when one of its node is ratched to a new root.&lt;p&gt; \anchor _todo000645 (user): Reduce this O(num_nodes) complexity. We might be able to
even do O(num_node_in_path) with lazy updates. Note that this operation
will only be performed at most num_initial_unmatched_nodes / 2 times
though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a2efd43d890e6d53cbab9f160b5ecd745 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a2efd43d890e6d53cbab9f160b5ecd745">operations_research::BlossomGraph::ComputeMaxCommonTreeDualDeltaAndResetPrimalEdgeQueue</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000640 (user): Avoid this linear loop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph::Edge Member \_internalref structoperations__research_1_1BlossomGraph_1_1Edge#a152f6be1dfb3d3057d875f9371da5a29 "<a class="el" href="structoperations__research_1_1BlossomGraph_1_1Edge.html#a152f6be1dfb3d3057d875f9371da5a29">operations_research::BlossomGraph::Edge::tail</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000657 (user): Consider using node_a/node_b instead to remove the "directed"
meaning. I do need to think a bit more about it though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a23c2ea31a1b81f23e929abdc839f9153 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a23c2ea31a1b81f23e929abdc839f9153" title="This must be called at the end of the algorithm to recover the matching.">operations_research::BlossomGraph::ExpandAllBlossoms</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000648 (user): remove duplication with expand?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#aea1e702f3161c4bd45d69ac7ef50d562 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#aea1e702f3161c4bd45d69ac7ef50d562">operations_research::BlossomGraph::Initialize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000636 (user): Add a preprocessing step that performs the 'forced' matches? 
 &lt;p&gt; \anchor _todo000637 (user): We might be able to do better for odd min_cost, but then
we might need to scale by 4? think about it. 
 &lt;p&gt; \anchor _todo000638 (user): Optimize by merging this loop with the one above? 
 &lt;p&gt; \anchor _todo000639 (user): Reduce the number of loops we do in the initialization. We
could likely just scale the edge cost as we fill them. 
 &lt;p&gt; \anchor _todo000635 (user): Code the more advanced "Fractional matching initialization"
heuristic.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a4e57765af9aa45f409d540937922cb15 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a4e57765af9aa45f409d540937922cb15">operations_research::BlossomGraph::PrimalUpdates</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000641 (user): avoid adding duplicates? 
 &lt;p&gt; \anchor _todo000642 (user): Avoid doing a O(num_nodes). Also expand all blossom
recursively? I am not sure it is a good heuristic to expand all possible
blossom before trying the other operations though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#af8800c5729866189248b48ea006f2787 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#af8800c5729866189248b48ea006f2787">operations_research::BlossomGraph::Shrink</a>" (EdgeIndex e)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000647 (user): It would be nicer to not to have to read the memory of
the other node at all. It might be possible once we store the
parent edge instead of the parent node since then we will only need
to know if this edges point to a new-internal node or not. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer Member \_internalref classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer#a74b09c69f37b7aee6c511622f13ff935 "<a class="el" href="classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer.html#a74b09c69f37b7aee6c511622f13ff935">operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer::DebugString</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000065 (user): show the backtrack levels.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer Member \_internalref classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer#ab9b52ed71802a8f4ae56d61b3e6f42ea "<a class="el" href="classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer.html#ab9b52ed71802a8f4ae56d61b3e6f42ea">operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer::PotentialOneFlipRepairs</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000064 (user): If this starts to show-up in a performance profile, we can
easily maintain this hash incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopOptimizerBase Member \_internalref classoperations__research_1_1bop_1_1BopOptimizerBase#a881ed93d8f98879bbbfddf21807fff63ab5cd6094ad1ef99cfb1c8e77da1f59b1 "<a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html#a881ed93d8f98879bbbfddf21807fff63ab5cd6094ad1ef99cfb1c8e77da1f59b1">operations_research::bop::BopOptimizerBase::INFORMATION_FOUND</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000044 (user): replace by learned_info-&gt;IsEmpty()? but we will need to clear
    the BopSolution there first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopOptimizerBase Member \_internalref classoperations__research_1_1bop_1_1BopOptimizerBase#a881ed93d8f98879bbbfddf21807fff63 "<a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html#a881ed93d8f98879bbbfddf21807fff63">operations_research::bop::BopOptimizerBase::Status</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000043 (user): To redesign, some are not needed anymore thanks to the
             problem state, e.g. IsOptimal(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopRandomFirstSolutionGenerator Class \_internalref classoperations__research_1_1bop_1_1BopRandomFirstSolutionGenerator "<a class="el" href="classoperations__research_1_1bop_1_1BopRandomFirstSolutionGenerator.html">operations_research::bop::BopRandomFirstSolutionGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000051 (user): Coupled with some Local Search it might be used to diversify
             the solutions. To try. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop Member \_internalref namespaceoperations__research_1_1bop#aa5e7fc23cf65709ac2894d88db807c57 "<a class="el" href="namespaceoperations__research_1_1bop.html#ac596370dab965471b2aaf0acf94c3940">operations_research::bop::DEFINE_STRONG_INDEX_TYPE</a>" (SparseIndex)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000080 (user): Remove.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::IntegralSolver Member \_internalref classoperations__research_1_1bop_1_1IntegralSolver#ade95d98b233882c2b9004ec144ded32e "<a class="el" href="classoperations__research_1_1bop_1_1IntegralSolver.html#adb59bf670fd51c4fd701f34200bb371b" title="Solves the given linear program and returns the solve status.">operations_research::bop::IntegralSolver::Solve</a>" (const glop::LinearProgram &amp;linear_problem, const glop::DenseRow &amp;user_provided_initial_solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000092 (user): Change the API to accept a partial solution instead since the
underlying solver supports it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LinearRelaxation Member \_internalref classoperations__research_1_1bop_1_1LinearRelaxation#ae7b5dc2f2554218d68e6013b9a3c10d8 "<a class="el" href="classoperations__research_1_1bop_1_1LinearRelaxation.html#ae7b5dc2f2554218d68e6013b9a3c10d8">operations_research::bop::LinearRelaxation::ShouldBeRun</a>" (const ProblemState &amp;problem_state) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000047 (user): also deal with problem_already_solved_ 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LocalSearchAssignmentIterator Member \_internalref classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator#a8b33fbbde1b28b4f19eac558f3bcc968 "<a class="el" href="classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator.html#a8b33fbbde1b28b4f19eac558f3bcc968">operations_research::bop::LocalSearchAssignmentIterator::deterministic_time</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000067 (user): The 1.2 multiplier is an approximation only based on the time
             spent in the SAT wrapper. So far experiments show a good
             correlation with real time, but we might want to be more
             accurate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LocalSearchAssignmentIterator Member \_internalref classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator#abba388e3e639729c28998d52ecea6a19 "<a class="el" href="classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator.html#abba388e3e639729c28998d52ecea6a19" title="Move to the next assignment. Returns false when the search is finished.">operations_research::bop::LocalSearchAssignmentIterator::NextAssignment</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000066 (user): Perform more experiments with this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OneFlipConstraintRepairer Member \_internalref classoperations__research_1_1bop_1_1OneFlipConstraintRepairer#a07e60997ff23293fa7f3b9d21765fb32 "<a class="el" href="classoperations__research_1_1bop_1_1OneFlipConstraintRepairer.html#a07e60997ff23293fa7f3b9d21765fb32">operations_research::bop::OneFlipConstraintRepairer::OneFlipConstraintRepairer</a>" (const sat::LinearBooleanProblem &amp;problem, const AssignmentAndConstraintFeasibilityMaintainer &amp;maintainer, const sat::VariablesAssignment &amp;sat_assignment)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000071 (user): maybe merge the two classes? maintaining this implicit indices
convention between the two classes sounds like a bad idea. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OptimizerSelector Member \_internalref classoperations__research_1_1bop_1_1OptimizerSelector#a39afee83d9f173f951fd8bef5668d1cc "<a class="el" href="classoperations__research_1_1bop_1_1OptimizerSelector.html#a39afee83d9f173f951fd8bef5668d1cc">operations_research::bop::OptimizerSelector::SelectOptimizer</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000078 (user): Remove this recursive call, even if in practice it's
             safe because the max depth is the number of optimizers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OptimizerSelector Member \_internalref classoperations__research_1_1bop_1_1OptimizerSelector#a90899a835ba61dd5404514594bac26d1 "<a class="el" href="classoperations__research_1_1bop_1_1OptimizerSelector.html#a90899a835ba61dd5404514594bac26d1">operations_research::bop::OptimizerSelector::SetOptimizerRunnability</a>" (OptimizerIndex optimizer_index, bool runnable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000079 (user): Maybe we should simply have the notion of selectability here
and let the client handle the logic to decide what optimizer are selectable
or not. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::PortfolioOptimizer Member \_internalref classoperations__research_1_1bop_1_1PortfolioOptimizer#a80a6069365c385e427e6e5a1c08d1757 "<a class="el" href="classoperations__research_1_1bop_1_1PortfolioOptimizer.html#a80a6069365c385e427e6e5a1c08d1757">operations_research::bop::PortfolioOptimizer::Optimize</a>" (const BopParameters &amp;parameters, const ProblemState &amp;problem_state, LearnedInfo *learned_info, TimeLimit *time_limit) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000074 (user): Is 1 the right value? It might be better to use a percentage
             of the gap, or use the same gain as for the second solution. 
 &lt;p&gt; \anchor _todo000075 (user): don't penalize the SatCoreBasedOptimizer or the
LinearRelaxation when they improve the lower bound.
&lt;p&gt; \anchor _todo000076 &lt;p&gt; \anchor _todo000077 (user): Do we want to re-order the optimizers in the selector when
             the status is BopOptimizerBase::INFORMATION_FOUND? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::ProblemState Member \_internalref classoperations__research_1_1bop_1_1ProblemState#a559199c417440cd27d38fc73ce4eb3f0 "<a class="el" href="classoperations__research_1_1bop_1_1ProblemState.html#a559199c417440cd27d38fc73ce4eb3f0">operations_research::bop::ProblemState::GetLearnedInfo</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000045 (user): In the current implementation the learned information only
             contains binary clauses added since the last call to
             SynchronizationDone().
             Add an iterator on the sat::BinaryClauseManager. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::ProblemState Member \_internalref classoperations__research_1_1bop_1_1ProblemState#a66e1a0e14cfd6b3310237e4243df1295 "<a class="el" href="classoperations__research_1_1bop_1_1ProblemState.html#a66e1a0e14cfd6b3310237e4243df1295">operations_research::bop::ProblemState::MergeLearnedInfo</a>" (const LearnedInfo &amp;learned_info, BopOptimizerBase::Status optimization_status)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000042 (user): refactor this to not rely on the optimization status.
All the information can be encoded in the learned_info bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::ProblemState Member \_internalref classoperations__research_1_1bop_1_1ProblemState#aaf3f17f2ef9a1ef1982d5d78fd71e23c "<a class="el" href="classoperations__research_1_1bop_1_1ProblemState.html#aaf3f17f2ef9a1ef1982d5d78fd71e23c">operations_research::bop::ProblemState::ProblemState</a>" (const sat::LinearBooleanProblem &amp;problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000041 (user): Extract to a function used by all solvers.
Compute trivial unscaled lower bound. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::RelationGraphBasedNeighborhood Member \_internalref classoperations__research_1_1bop_1_1RelationGraphBasedNeighborhood#a325429e8a64a26196122aa1b0e430cdb "<a class="el" href="classoperations__research_1_1bop_1_1RelationGraphBasedNeighborhood.html#a325429e8a64a26196122aa1b0e430cdb">operations_research::bop::RelationGraphBasedNeighborhood::RelationGraphBasedNeighborhood</a>" (const sat::LinearBooleanProblem &amp;problem, absl::BitGenRef random)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000056 (user): Factor this out with the similar factor in
ConstraintBasedNeighborhood? also maybe a better approach is to order the
constraint, and stop the neighborhood extension without considering all of
them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatCoreBasedOptimizer Class \_internalref classoperations__research_1_1bop_1_1SatCoreBasedOptimizer "<a class="el" href="classoperations__research_1_1bop_1_1SatCoreBasedOptimizer.html">operations_research::bop::SatCoreBasedOptimizer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000082 (user): Merge this with the code in sat/optimization.cc
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatCoreBasedOptimizer Member \_internalref classoperations__research_1_1bop_1_1SatCoreBasedOptimizer#aa4bc0effba94384800ed5500479d4e6a "<a class="el" href="classoperations__research_1_1bop_1_1SatCoreBasedOptimizer.html#aa4bc0effba94384800ed5500479d4e6a">operations_research::bop::SatCoreBasedOptimizer::Optimize</a>" (const BopParameters &amp;parameters, const ProblemState &amp;problem_state, LearnedInfo *learned_info, TimeLimit *time_limit) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000081 (user): Check that this cannot fail because of the conflict limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatWrapper Class \_internalref classoperations__research_1_1bop_1_1SatWrapper "<a class="el" href="classoperations__research_1_1bop_1_1SatWrapper.html">operations_research::bop::SatWrapper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000070 (user): remove? the meat of the logic is used in just one place, so I am
not sure having this extra layer improve the readability. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#ada6578145939501210ef6b92ca38158d "<a class="el" href="classoperations__research_1_1BopInterface.html#ada6578145939501210ef6b92ca38158d">operations_research::BopInterface::ExtractNewConstraints</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000679 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a7aaa64ff52a59fb3e02dde9e52897ace "<a class="el" href="classoperations__research_1_1BopInterface.html#a7aaa64ff52a59fb3e02dde9e52897ace">operations_research::BopInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000678 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a9bd4d93025988cd4a244584d930b8ff8 "<a class="el" href="classoperations__research_1_1BopInterface.html#a9bd4d93025988cd4a244584d930b8ff8">operations_research::BopInterface::ExtractObjective</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000680 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#ac52f933217a15933ccc9d816712e85f7 "<a class="el" href="classoperations__research_1_1BopInterface.html#ac52f933217a15933ccc9d816712e85f7">operations_research::BopInterface::SetPresolveMode</a>" (int value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000681 (user): add this to BopParameters.
 &lt;p&gt; \anchor _todo000682 (user): add this to BopParameters.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#afd586dcfbf76c853a9331113cea5ad2f "<a class="el" href="classoperations__research_1_1BopInterface.html#afd586dcfbf76c853a9331113cea5ad2f" title="--‚Äî Solve --‚Äî">operations_research::BopInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000676 (user): Implement the row status.
 &lt;p&gt; \anchor _todo000675 (user): Implement the column status.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a8055a5ae37344bb12601db78c75336ca "<a class="el" href="classoperations__research_1_1BopInterface.html#a8055a5ae37344bb12601db78c75336ca" title="Returns a string describing the underlying solver and its version.">operations_research::BopInterface::SolverVersion</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000677 (user): Decide how to version bop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aefd088882d7ba8d27157eba391b02792 "<a class="el" href="namespaceoperations__research.html#aefd088882d7ba8d27157eba391b02792">operations_research::BuildKruskalMinimumSpanningTreeFromSortedArcs</a>" (const Graph &amp;graph, const std::vector&lt; typename Graph::ArcIndex &gt; &amp;sorted_arcs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000630 (user): Add a global Minimum Spanning Tree API automatically switching
between Prim and Kruskal depending on problem size. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a95da1d3a46432afd40024f79279a48b2 "<a class="el" href="namespaceoperations__research.html#a95da1d3a46432afd40024f79279a48b2">operations_research::BuildSearchParametersFromFlags</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000284 (user): Make this return a StatusOr, verifying that the flags
describe a valid set of routing search parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#adfcad7c607afe2de123ac91fcd2b87c0 "<a class="el" href="namespaceoperations__research.html#adfcad7c607afe2de123ac91fcd2b87c0">operations_research::CapProdGeneric</a>" (int64_t x, int64_t y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002145 (user): avoid this by writing function Log2(a) with Log2(0) == -1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#af820a38fd9b79c6bccdf806ff44df433 "<a class="el" href="classoperations__research_1_1CBCInterface.html#af820a38fd9b79c6bccdf806ff44df433">operations_research::CBCInterface::ExtractModel</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000684 (user): separate the solve from the model extraction.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#abe31f5b2faa04f2e7d0a82b2f7c56eba "<a class="el" href="classoperations__research_1_1CBCInterface.html#abe31f5b2faa04f2e7d0a82b2f7c56eba" title="Modifies integrality of an extracted variable.">operations_research::CBCInterface::SetVariableInteger</a>" (int var_index, bool integer) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000683 (user) : Check if this is actually a change.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#aff8df81038ade1c6d8ff118dbcf92ff2 "<a class="el" href="classoperations__research_1_1CBCInterface.html#aff8df81038ade1c6d8ff118dbcf92ff2">operations_research::CBCInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000685 (user): Maybe we should expose the CbcModel build from osi_
instead, but a new CbcModel is built every time Solve is called,
so it is not possible right now. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a6a5db12c8eb55529c5717db21d40f856 "<a class="el" href="namespaceoperations__research.html#a6a5db12c8eb55529c5717db21d40f856">operations_research::CeilRatio</a>" (int64_t value, int64_t positive_coeff)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002146 (user): Use MathUtil::CeilOfRatio / FloorOfRatio instead.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1CheapestInsertionFilteredHeuristic#aabcdb4b93d8aed00bc35f8f04a3c5f0a "<a class="el" href="classoperations__research_1_1CheapestInsertionFilteredHeuristic.html#aabcdb4b93d8aed00bc35f8f04a3c5f0a">operations_research::CheapestInsertionFilteredHeuristic::ComputeStartEndDistanceForVehicles</a>" (const std::vector&lt; int &gt; &amp;vehicles)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000318 (user): consider checking search limits.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1CheapestInsertionFilteredHeuristic#a1a109ae320b663d295dfdfc68f608810 "<a class="el" href="classoperations__research_1_1CheapestInsertionFilteredHeuristic.html#a1a109ae320b663d295dfdfc68f608810">operations_research::CheapestInsertionFilteredHeuristic::GetInsertionCostForNodeAtPosition</a>" (int64_t node_to_insert, int64_t insert_after, int64_t insert_before, int vehicle) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000334 (user): Replace 'insert_before' and 'insert_after' by 'predecessor'
and 'successor' in the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesFilteredHeuristic Member \_internalref classoperations__research_1_1ChristofidesFilteredHeuristic#a30f60a5304f5bd801ece16fb0868b0fb "<a class="el" href="classoperations__research_1_1ChristofidesFilteredHeuristic.html#a30f60a5304f5bd801ece16fb0868b0fb">operations_research::ChristofidesFilteredHeuristic::BuildSolutionInternal</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000328 (user): Investigate if sorting paths per cost improves solutions.
 &lt;p&gt; \anchor _todo000327 (user): Investigate if ChristofidesPathSolver should not
return a status to bail out fast in case of problem. 
 &lt;p&gt; \anchor _todo000326 (user): Add robustness to fixed arcs by collapsing them into meta-
nodes. 
 &lt;p&gt; \anchor _todo000325 (user): Support pickup &amp; delivery.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesPathSolver Member \_internalref classoperations__research_1_1ChristofidesPathSolver#a76c636e1d48da64087686dd06bc45519 "<a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a76c636e1d48da64087686dd06bc45519">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::SetMatchingAlgorithm</a>" (MatchingAlgorithm matching)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000571 (user): Change the default when minimum matching gets faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesPathSolver Member \_internalref classoperations__research_1_1ChristofidesPathSolver#a0fd40e5b4dd3c4d2eec044aafc9cdc7a "<a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a0fd40e5b4dd3c4d2eec044aafc9cdc7a">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000569 (user): Make this code available as an independent algorithm. 
 &lt;p&gt; \anchor _todo000570 (user): Cost caching was added and can gain up to 20% but
increases memory usage; see if we can avoid caching. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CLPInterface Member \_internalref classoperations__research_1_1CLPInterface#adbecc3c53101ed075d7078a7ea8f3e19 "<a class="el" href="classoperations__research_1_1CLPInterface.html#adbecc3c53101ed075d7078a7ea8f3e19" title="Define new variables and add them to existing constraints.">operations_research::CLPInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000687 (user): This could perhaps be made slightly faster by
iterating through old constraints, constructing by hand the
column-major representation of the addition to them and call
clp_-&gt;addColumns. But this is good enough for now.
Create new variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a53bf12f941f978cc1b1b985816c1fbdf "<a class="el" href="namespaceoperations__research.html#a53bf12f941f978cc1b1b985816c1fbdf">operations_research::ComputeMinimumWeightMatchingWithMIP</a>" (const GraphType &amp;graph, const WeightFunctionType &amp;weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000568 (user): Handle infeasible cases if this algorithm is used outside of
Christofides. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#a6dfd72260599acdb0d30d0eb612a9b2c "<a class="el" href="classoperations__research_1_1CplexInterface.html#a6dfd72260599acdb0d30d0eb612a9b2c" title="Extract all variables that have not yet been extracted.">operations_research::CplexInterface::ExtractNewVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000689 : Use a bitarray to flag the constraints that actually
      intersect new variables? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#ade9838d567be0055711f0d0246878123 "<a class="el" href="classoperations__research_1_1CplexInterface.html#ade9838d567be0055711f0d0246878123" title="Sets the scaling mode.">operations_research::CplexInterface::SetScalingMode</a>" (int value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000690 : 0 is equilibrium scaling (the default), CPLEX also supports
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#a6f29640b71cf1b2be18d08c4888d654f "<a class="el" href="classoperations__research_1_1CplexInterface.html#a6f29640b71cf1b2be18d08c4888d654f" title="Modifies integrality of an extracted variable.">operations_research::CplexInterface::SetVariableInteger</a>" (int var_index, bool integer)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000688 : Should we check the current type and don't do anything
      in case the type does not change? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CVRPToursParser Member \_internalref classoperations__research_1_1CVRPToursParser#aa36bf9878697f417c237563de888fe97 "<a class="el" href="classoperations__research_1_1CVRPToursParser.html#aa36bf9878697f417c237563de888fe97" title="Loads and parses a given tours file.">operations_research::CVRPToursParser::LoadFile</a>" (const std::string &amp;file_name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000913 (user): Return false when issues were encountered while parsing the
file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DemonProfiler Member \_internalref classoperations__research_1_1DemonProfiler#a7b7c6355eb1daf5a3db8f0d575947ed2 "<a class="el" href="classoperations__research_1_1DemonProfiler.html#a7b7c6355eb1daf5a3db8f0d575947ed2">operations_research::DemonProfiler::CurrentTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000138 (user): rename and return nanoseconds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionChecker Member \_internalref classoperations__research_1_1DimensionChecker#a0f3d75f9157801c9a32ab3e5d9bdc23e "<a class="el" href="classoperations__research_1_1DimensionChecker.html#a0f3d75f9157801c9a32ab3e5d9bdc23e">operations_research::DimensionChecker::DimensionChecker</a>" (const PathState *path_state, std::vector&lt; Interval &gt; path_capacity, std::vector&lt; int &gt; path_class, std::vector&lt; std::function&lt; Interval(int64_t, int64_t)&gt; &gt; demand_per_path_class, std::vector&lt; Interval &gt; node_capacity, int min_range_size_for_riq=kOptimalMinRangeSizeForRIQ)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000134 (user): the addition of kMinRangeSizeForRIQ slowed down Check().
See if using a template parameter makes it faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionChecker::ExtendedInterval Class \_internalref structoperations__research_1_1DimensionChecker_1_1ExtendedInterval "<a class="el" href="structoperations__research_1_1DimensionChecker_1_1ExtendedInterval.html">operations_research::DimensionChecker::ExtendedInterval</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000133 (user): benchmark different implementation details for this class:
- num_negative/positive_infinity to int32_t
- use int128_t or absl's int128 to avoid counting infinities.
- use Interval instead of min/max. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#aede20bc3ae1e196588b610cfd10e7843 "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#aede20bc3ae1e196588b610cfd10e7843">operations_research::DimensionCumulOptimizerCore::Optimize</a>" (const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const std::vector&lt; RouteDimensionTravelInfo &gt; &amp;dimension_travel_info_per_route, RoutingLinearSolverWrapper *solver, std::vector&lt; int64_t &gt; *cumul_values, std::vector&lt; int64_t &gt; *break_values, std::vector&lt; std::vector&lt; int &gt; &gt; *resource_indices_per_group, int64_t *cost, int64_t *transit_cost, bool clear_lp=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000294 (user): In case the status is RELAXED_OPTIMAL_ONLY, check we can
safely avoid filling variable and cost values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#ab6499a2a9523227eee2869d06bfa75ca "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#ab6499a2a9523227eee2869d06bfa75ca">operations_research::DimensionCumulOptimizerCore::OptimizeAndPack</a>" (const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const std::vector&lt; RouteDimensionTravelInfo &gt; &amp;dimension_travel_info_per_route, RoutingLinearSolverWrapper *solver, std::vector&lt; int64_t &gt; *cumul_values, std::vector&lt; int64_t &gt; *break_values, std::vector&lt; std::vector&lt; int &gt; &gt; *resource_indices_per_group)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000295 (user): In case the status is RELAXED_OPTIMAL_ONLY, check we can
safely avoid filling variable values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad0b44ed99c3501d7a797dfa6ac52714f "<a class="el" href="namespaceoperations__research.html#af223cfc20a19613cbf63b9b9f08795cb">operations_research::DisplayPlan</a>" (const operations_research::RoutingIndexManager &amp;manager, const operations_research::RoutingModel &amp;routing, const operations_research::Assignment &amp;plan, bool use_same_vehicle_costs, int64_t max_nodes_per_group, int64_t same_vehicle_cost, const operations_research::RoutingDimension &amp;capacity_dimension, const operations_research::RoutingDimension &amp;time_dimension)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000908 (user): Move the display code to the routing library. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DistributionStat Member \_internalref classoperations__research_1_1DistributionStat#a68349bcba1db1a5a68ebd1d855bdd078 "<a class="el" href="classoperations__research_1_1DistributionStat.html#a68349bcba1db1a5a68ebd1d855bdd078">operations_research::DistributionStat::StdDeviation</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002155 (user): We could also use on top the Kahan summation algorithm to be
even more precise but a bit slower too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#a714a1473bb78dab3195bd5cd5e90af42 "<a class="el" href="classoperations__research_1_1Domain.html#a714a1473bb78dab3195bd5cd5e90af42">operations_research::Domain::AdditionWith</a>" (const Domain &amp;domain) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002147 (user): Use a better algorithm.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#a9cbde5d21e680b86f4ecf822b4049187 "<a class="el" href="classoperations__research_1_1Domain.html#a9cbde5d21e680b86f4ecf822b4049187">operations_research::Domain::intervals</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002152 (user): remove, this makes a copy and is of a different type that our
internal InlinedVector() anyway. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Class \_internalref classoperations__research_1_1DynamicPartition "<a class="el" href="classoperations__research_1_1DynamicPartition.html">operations_research::DynamicPartition</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000005 (user): rename this to BacktrackableSplittingPartition. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Member \_internalref classoperations__research_1_1DynamicPartition#ae0789ce355b93a5161e63666b4467e67 "<a class="el" href="classoperations__research_1_1DynamicPartition.html#afe6f90b99c0b1d646b00ad2d1bb0a09d">operations_research::DynamicPartition::DynamicPartition</a>" (const std::vector&lt; int &gt; &amp;initial_part_of_element)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000001 (user): either remove this or factor it out if it can be used
elsewhere. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Member \_internalref classoperations__research_1_1DynamicPartition#a16fce09dd4c359a6acfd0a864e0a5ebd "<a class="el" href="classoperations__research_1_1DynamicPartition.html#a16fce09dd4c359a6acfd0a864e0a5ebd">operations_research::DynamicPartition::Refine</a>" (const std::vector&lt; int &gt; &amp;distinguished_subset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000002 (user): optimize the common singleton case.
 &lt;p&gt; \anchor _todo000003 (user): automatically switch to an O(N) sort when it's faster
than this one, which is O(K log K) with K = tmp_affected_parts_.size(). 
 &lt;p&gt; \anchor _todo000006 (user): the graph symmetry finder could probably benefit a lot from
keeping track of one additional bit of information for each part that
remains unchanged by a Refine() operation: was that part entirely &lt;em&gt;in&lt;/em&gt;
the distinguished subset or entirely &lt;em&gt;out&lt;/em&gt;? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPermutation Member \_internalref classoperations__research_1_1DynamicPermutation#a529b7a5b760666c049da283212991a5b "<a class="el" href="classoperations__research_1_1DynamicPermutation.html#a529b7a5b760666c049da283212991a5b">operations_research::DynamicPermutation::LooseEnds</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000007 (user): use a faster underlying container like SparseBitSet, and
tweak this API accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::EbertGraphBase Member \_internalref classoperations__research_1_1EbertGraphBase#a7adcbbf1af098a96abf7a3397246304d "<a class="el" href="classoperations__research_1_1EbertGraphBase.html#a7adcbbf1af098a96abf7a3397246304d">operations_research::EbertGraphBase&lt; NodeIndexType, ArcIndexType, DerivedGraph &gt;::GroupForwardArcsByFunctor</a>" (const ArcIndexTypeStrictWeakOrderingFunctor &amp;compare, PermutationCycleHandler&lt; ArcIndexType &gt; *annotation_handler)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000576 (user): Configure SWIG to handle the GroupForwardArcsByFunctor
member template and the CycleHandlerForAnnotatedArcs class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ElementIterator Class \_internalref classoperations__research_1_1ElementIterator "operations_research::ElementIterator&lt; Set &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000590 (user): Move the Set-related classbelow to util/bitset.h
Iterates over the elements of a set represented as an unsigned integer,
starting from the smallest element.  (See the class Set&lt;Integer&gt; below.) 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab0da8bffc5e8eafc798d8b3b1750f05b "<a class="el" href="namespaceoperations__research.html#ab0da8bffc5e8eafc798d8b3b1750f05b">operations_research::FillPathEvaluation</a>" (const std::vector&lt; int64_t &gt; &amp;path, const RoutingModel::TransitCallback2 &amp;evaluator, std::vector&lt; int64_t &gt; *values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000250 (user): Apply -pointer-following.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FilteredHeuristicLocalSearchOperator Class \_internalref classoperations__research_1_1FilteredHeuristicLocalSearchOperator "<a class="el" href="classoperations__research_1_1FilteredHeuristicLocalSearchOperator.html">operations_research::FilteredHeuristicLocalSearchOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000308 (user): Put these methods in an object with helper methods instead
of adding a layer to the class hierarchy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FilteredHeuristicLocalSearchOperator Member \_internalref classoperations__research_1_1FilteredHeuristicLocalSearchOperator#a27a42fcdb24320190aa6760ab0aa2c7a "<a class="el" href="classoperations__research_1_1FilteredHeuristicLocalSearchOperator.html#a27a42fcdb24320190aa6760ab0aa2c7a">operations_research::FilteredHeuristicLocalSearchOperator::model_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000309 (user): Remove the dependency from RoutingModel by storing an
IntVarFilteredHeuristic here instead and storing information on path
start/ends like PathOperator does (instead of relying on the model). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ae4ee4d82cf625670cdc1f52197454654 "<a class="el" href="namespaceoperations__research.html#ae4ee4d82cf625670cdc1f52197454654">operations_research::FindFeasibilityErrorInSolutionHint</a>" (const MPModelProto &amp;model, double tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000723 (user): Add a general FindFeasibilityErrorInSolution() and factor out the
common code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FindOneNeighbor Member \_internalref classoperations__research_1_1FindOneNeighbor#a574c9f481726ad590ec083046cb7341f "<a class="el" href="classoperations__research_1_1FindOneNeighbor.html#a574c9f481726ad590ec083046cb7341f">operations_research::FindOneNeighbor::FindOneNeighbor</a>" (Assignment *const assignment, IntVar *objective, SolutionPool *const pool, LocalSearchOperator *const ls_operator, DecisionBuilder *const sub_decision_builder, const RegularLimit *const limit, LocalSearchFilterManager *filter_manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000197 (user): Support skipping neighborhood checks for limits accepting
more than one solution (e.g. best accept). For now re-enabling systematic
checks. 
 &lt;p&gt; \anchor _todo000198 (user): Support skipping neighborhood checks with LNS (at least on
the non-LNS operators). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FindOneNeighbor Member \_internalref classoperations__research_1_1FindOneNeighbor#a8ce20599958d57352cc4ddb059edb523 "<a class="el" href="classoperations__research_1_1FindOneNeighbor.html#a8ce20599958d57352cc4ddb059edb523">operations_research::FindOneNeighbor::Next</a>" (Solver *const solver) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000202 (user): Restore state of local search operators to
make sure we are exploring neighbors in the same order. This can
affect the local optimum found. 
 &lt;p&gt; \anchor _todo000199 (user) : SyncNeed(assignment_) ?
 &lt;p&gt; \anchor _todo000200 (user): Don't call both if no filter is incremental and one
of them returned false. 
 &lt;p&gt; \anchor _todo000201 (user): support the case were limit_ accepts more than
one solution (e.g. best accept). 
 &lt;p&gt; \anchor _todo000203 (user): Compare assignments in addition to their cost. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ac8ccb5bc825d46925984e259059f1045 "<a class="el" href="namespaceoperations__research.html#ac8ccb5bc825d46925984e259059f1045" title="Formats a solution or solver statistic according to the given format.">operations_research::FormatStatistic</a>" (const std::string &amp;name, T value, RoutingOutputFormat format)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000911 (user): think about using an enum instead of names (or even a
full-fledged struct/class) for the various types of fields. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ForwardStaticGraph::CycleHandlerForAnnotatedArcs Class \_internalref classoperations__research_1_1ForwardStaticGraph_1_1CycleHandlerForAnnotatedArcs "operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::CycleHandlerForAnnotatedArcs" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000574 (user): Configure SWIG to handle the
CycleHandlerForAnnotatedArcs class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ForwardStaticGraph Member \_internalref classoperations__research_1_1ForwardStaticGraph#a299d30373ebbfcb70fc84ecc66d95b92 "<a class="el" href="classoperations__research_1_1ForwardStaticGraph.html#a299d30373ebbfcb70fc84ecc66d95b92">operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::ForwardStaticGraph</a>" (const NodeIndexType num_nodes, const ArcIndexType num_arcs, const bool sort_arcs_by_head, std::vector&lt; std::pair&lt; NodeIndexType, NodeIndexType &gt; &gt; *client_input_arcs, operations_research::PermutationCycleHandler&lt; ArcIndexType &gt; *const client_cycle_handler)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000575 (user): For some reason, SWIG breaks if the
  operations_research namespace is not explicit in the
  following argument declaration.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Constraint Member \_internalref structoperations__research_1_1fz_1_1Constraint#a4d53b3107ef0dbfb3e99a52a2f4c0d42 "<a class="el" href="structoperations__research_1_1fz_1_1Constraint.html#a4d53b3107ef0dbfb3e99a52a2f4c0d42" title="Helpers to be used during presolve.">operations_research::fz::Constraint::MarkAsInactive</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000363 (user): Reclaim arguments and memory.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Class \_internalref structoperations__research_1_1fz_1_1Domain "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html">operations_research::fz::Domain</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000365 (user): Rework domains, all int64_t should be kintmin..kint64max.
               It is a bit tricky though as we must take care of overflows.
If is_a_set is true, then this domain has a set semantics. For a set
variable, any subset of the initial set of values is a valid assignment,
instead of exactly one value. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ac4d428774d29f823cc82a1e9094f1926 "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ac4d428774d29f823cc82a1e9094f1926">operations_research::fz::Domain::HasOneValue</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000367 (user): Do we need SetOfFloats() ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ade58ffc63429a64164236b2bf56ec480 "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ade58ffc63429a64164236b2bf56ec480">operations_research::fz::Domain::IntersectWithListOfIntegers</a>" (const std::vector&lt; int64_t &gt; &amp;integers)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000361 (user): Investigate faster code for small arrays.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ae4c771e4304fd0443a538c84d3c62870 "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ae4c771e4304fd0443a538c84d3c62870">operations_research::fz::Domain::OverlapsIntList</a>" (const std::vector&lt; int64_t &gt; &amp;vec) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000362 (user): Better algorithm, sort and compare increasingly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::LexerInfo Class \_internalref structoperations__research_1_1fz_1_1LexerInfo "<a class="el" href="structoperations__research_1_1fz_1_1LexerInfo.html">operations_research::fz::LexerInfo</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000375 (user): Use std::unique_ptr&lt;vector&lt; &gt;&gt; to ease memory management. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz Member \_internalref namespaceoperations__research_1_1fz#a0d0d1d18eea7879af81671f8395b8b1d "<a class="el" href="namespaceoperations__research_1_1fz.html#a0d0d1d18eea7879af81671f8395b8b1d">operations_research::fz::Lookup</a>" (const std::vector&lt; T &gt; &amp;v, int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000374 (user): replace this by a macro for better logging.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Model Member \_internalref classoperations__research_1_1fz_1_1Model#affdfad9a0c88744ef4cfe7c80adc4fb1 "<a class="el" href="classoperations__research_1_1fz_1_1Model.html#affdfad9a0c88744ef4cfe7c80adc4fb1">operations_research::fz::Model::AddConstant</a>" (int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000364 (user): Create only once constant per value.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::ModelStatistics Class \_internalref classoperations__research_1_1fz_1_1ModelStatistics "<a class="el" href="classoperations__research_1_1fz_1_1ModelStatistics.html">operations_research::fz::ModelStatistics</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000366 (user): Clean up API to pass a Model* in argument. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Presolver Class \_internalref classoperations__research_1_1fz_1_1Presolver "<a class="el" href="classoperations__research_1_1fz_1_1Presolver.html">operations_research::fz::Presolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000379 (user): Error reporting of unfeasible models. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a92fbc9576b457ceddeb21395181b3273 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a92fbc9576b457ceddeb21395181b3273">operations_research::GenericMaxFlow&lt; Graph &gt;::check_result_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000619 (user): Make the check more exhaustive by checking the optimality? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#ad7892ad5aa8338015f320267fb7f298f "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ad7892ad5aa8338015f320267fb7f298f">operations_research::GenericMaxFlow&lt; Graph &gt;::GetSinkSideMinCut</a>" (std::vector&lt; NodeIndex &gt; *result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000618 (user): In the two-phases algorithm, we can get this minimum cut
without doing the second phase. Add an option for this if there is a need
to, note that the second phase is pretty fast so the gain will be small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#ad3925f2137b18b1555563ed149ada740 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ad3925f2137b18b1555563ed149ada740">operations_research::GenericMaxFlow&lt; Graph &gt;::GlobalUpdate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000606 (user): This is another argument for another anti-overflow algorithm. 
 &lt;p&gt; \anchor _todo000604 (user): By using more memory we can speed this up quite a bit by
avoiding to take the opposite arc here, too options:
- if (residual_arc_capacity_[arc] != arc_capacity_[arc])
- if (opposite_arc_is_admissible_[arc])  ///&lt; need updates.
Experiment with the first option shows more than 10% gain on this
function running time, which is the bottleneck on many instances. 
 &lt;p&gt; \anchor _todo000605 (user): Investigate more and maybe write a publication :) 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a20139b839cd5764939afc8df968a2484 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a20139b839cd5764939afc8df968a2484" title="Initializes the preflow to a state that enables to run Refine.">operations_research::GenericMaxFlow&lt; Graph &gt;::InitializePreflow</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000603 (user): find a way to make the re-solving incremental (not an obvious
task, and there has not been a lot of literature on the subject.) 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#aa96647a33c0a0898055642bd6d039f83 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ac4278804a3c23b3a7f340930a81ff15f" title="Maximum manageable flow.">operations_research::GenericMaxFlow&lt; Graph &gt;::kMaxFlowQuantity</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000611 (user): moves this code out of a .cc file and include it at the end of
the header so it can work with any graph implementation ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a1c31c96effb1f91f800895be2339045b "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a1c31c96effb1f91f800895be2339045b">operations_research::GenericMaxFlow&lt; Graph &gt;::PushFlow</a>" (FlowQuantity flow, ArcIndex arc)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000607 (user): Do not allow a zero flow after fixing the UniformMaxFlow code.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a1061c1ce94ccc0d379390b8542bfaa23 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a1061c1ce94ccc0d379390b8542bfaa23" title="Performs optimization step.">operations_research::GenericMaxFlow&lt; Graph &gt;::Refine</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000608 (user): This may not be the most efficient algorithm if we need to loop
many times. An alternative may be to handle the source like the other nodes
in the algorithm, initially putting an excess of kMaxFlowQuantity on it,
and making the source active like any other node with positive excess. To
investigate.&lt;p&gt; \anchor _todo000609 (user): The code below is buggy when more than kMaxFlowQuantity can be
pushed out of the source (i.e. when we loop more than once in the while()).
This is not critical, since this code is not used in the default algorithm
computation. The issue is twofold:
- InitializeActiveNodeContainer() doesn't push the nodes in
  the correct order.
- PushFlowExcessBackToSource() may break the node potential properties, and
  we will need a call to GlobalUpdate() to fix that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a91d754521a7d43dd215e5d6200ec1062 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a91d754521a7d43dd215e5d6200ec1062">operations_research::GenericMaxFlow&lt; Graph &gt;::RefineWithGlobalUpdate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000610 (user): This should be graph_-&gt;num_nodes(), but ebert graph does not
have a correct size if the highest index nodes have no arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a05f2661c573eb445212f4eddd694fc2f "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a05f2661c573eb445212f4eddd694fc2f" title="Sets the capacity for arc to new_capacity.">operations_research::GenericMaxFlow&lt; Graph &gt;::SetArcCapacity</a>" (ArcIndex arc, FlowQuantity new_capacity)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000602 (user): The easiest is probably to allow negative node excess in
other places than the source, but the current implementation does not
deal with this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMinCostFlow Class \_internalref classoperations__research_1_1GenericMinCostFlow "operations_research::GenericMinCostFlow&lt; Graph, ArcFlowType, ArcScaledCostType &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000629 (user): Avoid using the globally defined type CostValue and FlowQuantity.
Also uses the Arc*Type where there is no risk of overflow in more places. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMinCostFlow Member \_internalref classoperations__research_1_1GenericMinCostFlow#a01f13e85a3d12e356f26d80210a6755f "<a class="el" href="classoperations__research_1_1GenericMinCostFlow.html#a01f13e85a3d12e356f26d80210a6755f">operations_research::GenericMinCostFlow&lt; Graph, ArcFlowType, ArcScaledCostType &gt;::CheckFeasibility</a>" (std::vector&lt; NodeIndex &gt; *const infeasible_supply_node, std::vector&lt; NodeIndex &gt; *const infeasible_demand_node)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000621 (user): make it possible to share a graph by MaxFlow and MinCostFlow.
For this it is necessary to make StarGraph resizable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a838df3808f198b2cbc781e426a601b29 "<a class="el" href="namespaceoperations__research.html#a23c0a81713062e858a04dd7293c07f16">operations_research::GetBestScalingOfDoublesToInt64</a>" (const std::vector&lt; double &gt; &amp;input, int64_t max_absolute_sum, double *scaling_factor, double *max_relative_coeff_error)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002131 (user): incorporate the gcd computation here? The issue is that I am
not sure if I just do factor /= gcd that round(x * factor) will be the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GlobalCheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1GlobalCheapestInsertionFilteredHeuristic#abe76b53e07ae6db10cda5c6fd70d0001 "<a class="el" href="classoperations__research_1_1GlobalCheapestInsertionFilteredHeuristic.html#abe76b53e07ae6db10cda5c6fd70d0001" title="Virtual method to redefine how to build a solution.">operations_research::GlobalCheapestInsertionFilteredHeuristic::BuildSolutionInternal</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000319 (user): Adapt the pair insertions to also support seed and
sequential insertion. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aeacc29c42c7fddda875937d3bdfc7e08 "<a class="el" href="namespaceoperations__research_1_1glop.html#aeacc29c42c7fddda875937d3bdfc7e08">operations_research::glop::ABSL_DEPRECATED</a>" ("Use the direct methods instead") MPSReader&lt;/dt&gt;&lt;dd&gt; \anchor _todo000778 (user): Remove the MPSReader class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::AddSlackVariablesPreprocessor Class \_internalref classoperations__research_1_1glop_1_1AddSlackVariablesPreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1AddSlackVariablesPreprocessor.html">operations_research::glop::AddSlackVariablesPreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000471 (user): Do not require this step to talk to the revised simplex. On large
LPs like supportcase11.mps, this step alone can add 1.5 GB to the solver peak
memory for no good reason. The internal matrix representation used in glop is
a lot more efficient, and there is no point keeping the slacks in
LinearProgram. It is also bad for incrementaly modifying the LP. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#acf14406acccf01da7c2dd2fa1c66425e "<a class="el" href="namespaceoperations__research_1_1glop.html#acf14406acccf01da7c2dd2fa1c66425e">operations_research::glop::ApplyPermutation</a>" (const Permutation&lt; IndexType &gt; &amp;perm, const ITIVectorType &amp;b, ITIVectorType *result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000779 (user): Try to restrict this method to using the same integer type in
the permutation and for the vector indices, i.e.
IndexType == ITIVectorType::IndexType. Some client code will need to be
refactored. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aac6525bf47674e01c5d51e956ce13a63 "<a class="el" href="namespaceoperations__research_1_1glop.html#aac6525bf47674e01c5d51e956ce13a63">operations_research::glop::AreFirstColumnsAndRowsExactlyEquals</a>" (RowIndex num_rows, ColIndex num_cols, const SparseMatrix &amp;matrix_a, const CompactSparseMatrix &amp;matrix_b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000772 (user): Also DCHECK() that matrix_b is ordered by rows.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#a370b080a5be3e81960457e53261e7cd5 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#a370b080a5be3e81960457e53261e7cd5">operations_research::glop::BasisFactorization::ComputeInitialBasis</a>" (const std::vector&lt; ColIndex &gt; &amp;candidates)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000384 (user): This "double" factorization is a bit inefficient, and we should
probably Initialize() right away the factorization with the new basis, but
more code is needed for that. It is also not that easy also because we want
to permute all the added slack first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#af2eba683b05901eb982dcade3fda53d3 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#af2eba683b05901eb982dcade3fda53d3">operations_research::glop::BasisFactorization::ComputeInverseOneNorm</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000382 (user): try to merge the computation of the norm of inverses
with that of MatrixView. Maybe use a wrapper class for InverseMatrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#a90e327f8ea7f4594bab0686230735287 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#a90e327f8ea7f4594bab0686230735287">operations_research::glop::BasisFactorization::RightSolveForProblemColumn</a>" (ColIndex col, ScatteredColumn *d) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000381 (user): if right_pool_mapping_[col] != kInvalidCol, we can reuse it and
just apply the last rank one update since it was computed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisState Class \_internalref structoperations__research_1_1glop_1_1BasisState "<a class="el" href="structoperations__research_1_1glop_1_1BasisState.html">operations_research::glop::BasisState</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000564 (user): Introduce another state class to store a complete state of the
solver. Using this state and the original linear program, the solver can be
restarted with as little time overhead as possible. This is especially useful
for strong branching in a MIP context. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisState Member \_internalref structoperations__research_1_1glop_1_1BasisState#a8403627807a2ba65e69b8fb58061293f "<a class="el" href="structoperations__research_1_1glop_1_1BasisState.html#a8403627807a2ba65e69b8fb58061293f">operations_research::glop::BasisState::statuses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000565 (user): A MIP solver will potentially store a lot of BasisStates so
memory usage is important. It is possible to use only 2 bits for one
VariableStatus enum. To achieve this, the FIXED_VALUE status can be
converted to either AT_LOWER_BOUND or AT_UPPER_BOUND and decoded properly
later since this will be used with a given linear program. This way we can
even encode more information by using the reduced cost sign to choose to
which bound the fixed status correspond. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ColumnView Member \_internalref classoperations__research_1_1glop_1_1ColumnView#a37aadf4689cf83d4e92724df18788c26 "<a class="el" href="classoperations__research_1_1glop_1_1ColumnView.html#a37aadf4689cf83d4e92724df18788c26">operations_research::glop::ColumnView::LookUpCoefficient</a>" (RowIndex index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000794 (user): investigate whether an optimized version of
LookUpCoefficient for "clean" columns yields speed-ups. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::CompactSparseMatrix Member \_internalref classoperations__research_1_1glop_1_1CompactSparseMatrix#aa5613aefbe167b3a7060c47adbc18257 "<a class="el" href="classoperations__research_1_1glop_1_1CompactSparseMatrix.html#a6b48362b8f25d4949d85e9bee4f58cda">operations_research::glop::CompactSparseMatrix::CompactSparseMatrix</a>" (const SparseMatrix &amp;matrix)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000789 (user): If this is needed in production code, it can be done faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DataWrapper&lt; MPModelProto &gt; Member \_internalref classoperations__research_1_1glop_1_1DataWrapper_3_01MPModelProto_01_4#ae847ea2baa71fe069259a785a2f793ba "operations_research::glop::DataWrapper&lt; MPModelProto &gt;::CleanUp" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000777 (user): Experiment with the switch constant.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a02a36a3bb1bee8ca88e9d07f4e914ad2 "<a class="el" href="namespaceoperations__research_1_1glop.html#a02a36a3bb1bee8ca88e9d07f4e914ad2">operations_research::glop::Density</a>" (const DenseRow &amp;row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000768 (user): Take a Scattered row/col instead. This is only used to report
stats, but we should still have a sparse version to do it faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonEqualityRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor#a417519507dabcad60034e4b158755bf5 "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor.html#a417519507dabcad60034e4b158755bf5">operations_research::glop::DoubletonEqualityRowPreprocessor::RecoverSolution</a>" (ProblemSolution *solution) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000459 (user): We can probably use something better than a vector of set,
but the number of entry is really sparse though. And the size of a set&lt;int&gt;
is 24 bytes, same as a std::vector&lt;int&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonEqualityRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor#aee8ab3fb7503d6267c9a09854ecd7a2d "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor.html#aee8ab3fb7503d6267c9a09854ecd7a2d">operations_research::glop::DoubletonEqualityRowPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000457 (user): consider skipping the problematic rows in this preprocessor,
or trying harder to avoid the under/overflow. 
 &lt;p&gt; \anchor _todo000454 (user): Get rid of the FIXED status instead to avoid spending
time/memory for no good reason here. 
 &lt;p&gt; \anchor _todo000455 (user): There is probably some more robust ways. 
 &lt;p&gt; \anchor _todo000456 (user): make a smarter choice of which column to delete, and
swap col[] and coeff[] accordingly. 
 &lt;p&gt; \anchor _todo000458 (user): rename that method to reflect the fact that it also updates
the objective offset, in the other direction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonFreeColumnPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonFreeColumnPreprocessor#ab64cfa1fb6ff03f45291fcb60f506963 "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonFreeColumnPreprocessor.html#ab64cfa1fb6ff03f45291fcb60f506963">operations_research::glop::DoubletonFreeColumnPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000436 (user): Impact? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DualEdgeNorms Member \_internalref classoperations__research_1_1glop_1_1DualEdgeNorms#ab9c06f7b3b7e0337da531ca86c3fd43c "<a class="el" href="classoperations__research_1_1glop_1_1DualEdgeNorms.html#ab9c06f7b3b7e0337da531ca86c3fd43c">operations_research::glop::DualEdgeNorms::UpdateBeforeBasisPivot</a>" (ColIndex entering_col, RowIndex leaving_row, const ScatteredColumn &amp;direction, const ScatteredRow &amp;unit_row_left_inverse)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000385 (user): use a more precise lower bound depending on the column norm?
We can do that with Cauchy-Swartz inequality:
  (edge . leaving_column)^2 = 1.0 &lt; |&lt;tt&gt;edge&lt;/tt&gt;|^2 * |&lt;tt&gt;leaving_column&lt;/tt&gt;|^2 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DualizerPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DualizerPreprocessor#afb190878213f1da31a0daa0f03b9e017 "<a class="el" href="classoperations__research_1_1glop_1_1DualizerPreprocessor.html#afb190878213f1da31a0daa0f03b9e017">operations_research::glop::DualizerPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000462 (user): There are two different ways to deal with ranged rows when
taking the dual. The default way is to duplicate such rows, see
PopulateFromDual() for details. Another way is to call
lp-&gt;AddSlackVariablesForFreeAndBoxedRows() before calling
PopulateFromDual(). Adds an option to switch between the two as this may
change the running time?&lt;p&gt; \anchor _todo000461 (user): This will break if PopulateFromDual() is changed. so document
the convention or make the function fill these vectors? 
 &lt;p&gt; \anchor _todo000460 (user): This effect can be lowered if we use some of the extra
variables as slack variable which we are not doing at this point. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DynamicMaximum Member \_internalref classoperations__research_1_1glop_1_1DynamicMaximum#a5a1cf0bc9507c1dfcef22b8d89d2d9f0 "<a class="el" href="classoperations__research_1_1glop_1_1DynamicMaximum.html#a5a1cf0bc9507c1dfcef22b8d89d2d9f0">operations_research::glop::DynamicMaximum&lt; Index &gt;::GetMaximum</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000478 (user): Add a mode when we do not maintain the TopK for small sizes
(like n &lt; 1000) ? The gain might not be worth the extra code though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#a3c3a0b006ecdc59714cd1c66f50e7cff "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#a3c3a0b006ecdc59714cd1c66f50e7cff">operations_research::glop::EnteringVariable::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000389 (user): Be exhausitive and more precise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#a863b59030d198656afffb23fcd533948 "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#a863b59030d198656afffb23fcd533948">operations_research::glop::EnteringVariable::DualChooseEnteringColumn</a>" (bool nothing_to_recompute, const UpdateRow &amp;update_row, Fractional cost_variation, std::vector&lt; ColIndex &gt; *bound_flip_candidates, ColIndex *entering_col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000387 (user): We want to maximize both the ratio (objective improvement)
and the coeff_magnitude (stable pivot), so we have to make some
trade-offs. Investigate alternative strategies. 
 &lt;p&gt; \anchor _todo000386 (user): It is unclear if this is a good idea, but the primal simplex
have pretty good/stable behavior with a similar logic. Experiment seems
to show that this works well with the dual too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#ad20764201d083354bdf18a8def790e4a "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#ad20764201d083354bdf18a8def790e4a">operations_research::glop::EnteringVariable::DualPhaseIChooseEnteringColumn</a>" (bool nothing_to_recompute, const UpdateRow &amp;update_row, Fractional cost_variation, ColIndex *entering_col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000388 (user): This is the same in DualChooseEnteringColumn(), remove
duplication? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aed75af61dbbe6d3c628c274f271f9000 "<a class="el" href="namespaceoperations__research_1_1glop.html#aed75af61dbbe6d3c628c274f271f9000">operations_research::glop::FindProportionalColumns</a>" (const SparseMatrix &amp;matrix, Fractional tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000771 (user): Derive precise bounds on what this tolerance should be so
that no proportional columns are missed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#ac55fddbd6cdae02b8a88e2c845f0d4d7 "<a class="el" href="namespaceoperations__research_1_1glop.html#ac55fddbd6cdae02b8a88e2c845f0d4d7">operations_research::glop::FixConstraintWithFixedStatuses</a>" (const DenseColumn &amp;row_lower_bounds, const DenseColumn &amp;row_upper_bounds, ProblemSolution *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000469 (user): A better solution would simply be to get rid of the FIXED status
altogether, it is better to simply use AT_LOWER_BOUND/AT_UPPER_BOUND
depending on the constraining bound in the optimal solution. Note that we can
always at the end transform any variable/constraint with a fixed domain to
FIXED_VALUE if needed to keep the same external API. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ImpliedFreePreprocessor Class \_internalref classoperations__research_1_1glop_1_1ImpliedFreePreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1ImpliedFreePreprocessor.html">operations_research::glop::ImpliedFreePreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000467 (user): Only process doubleton columns so we have more chance in the
later passes to create more doubleton columns? Such columns lead to a smaller
problem thanks to the DoubletonFreeColumnPreprocessor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ImpliedFreePreprocessor Member \_internalref classoperations__research_1_1glop_1_1ImpliedFreePreprocessor#a22a4d717e6ac86260356defc467e980e "<a class="el" href="classoperations__research_1_1glop_1_1ImpliedFreePreprocessor.html#a22a4d717e6ac86260356defc467e980e">operations_research::glop::ImpliedFreePreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000432 (user): Only process degree-two so in subsequent passes more degree-two
columns could be made free. And only when no other reduction can be
applied, process the higher degree column?&lt;p&gt; \anchor _todo000431 (user) : Replace SumWithNegativeInfiniteAndOneMissing and
SumWithPositiveInfiniteAndOneMissing with IntervalSumWithOneMissing. 
 &lt;p&gt; \anchor _todo000435 (user): This trick is already used in the DualizerPreprocessor,
maybe we should just have a preprocessor that shifts all the variables
bounds to have at least one of them at 0.0, will that improve precision
and speed of the simplex? One advantage is that we can compute the
new constraint bounds with better precision using AccurateSum. 
 &lt;p&gt; \anchor _todo000434 (user): As of July 2013, with our preprocessors this case is never
triggered on the Netlib. Note however that if it appears it can have a
big impact since by fixing the variable, the two involved constraints
are forcing and can be removed too (with all the variables they touch).
The postsolve step is quite involved though. 
 &lt;p&gt; \anchor _todo000433 (user): Be smarter about the order that maximizes the number of free
column. For instance if we have 3 doubleton columns that use the rows (1,2)
(2,3) and (3,4) then it is better not to make (2,3) free so the two other
two can be made free. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a451faba66f544c02438a3ce062b69900 "<a class="el" href="namespaceoperations__research_1_1glop.html#a451faba66f544c02438a3ce062b69900">operations_research::glop::KahanSum</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000766 (user): For some Fractional types, it may not gain much (or even nothing
if we are in infinite precision) to use this sum. A solution is to templatize
this class and specialize it to a normal sum for the Fractional type we want
so in this case the PreciseXXX() functions below will become equivalent to
their normal version. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#abbaca14cc7f5a0f3aaeb027fef37e0ca "<a class="el" href="namespaceoperations__research_1_1glop.html#abbaca14cc7f5a0f3aaeb027fef37e0ca">operations_research::glop::kNonPivotal</a>" (-1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000793 (user): Consider using kInvalidRow for this?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a65b22be15b4caa784b8d7c690e2418ae "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a65b22be15b4caa784b8d7c690e2418ae">operations_research::glop::LinearProgram::AddSlackVariablesWhereNecessary</a>" (bool detect_integer_constraints)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000761 (user): investigate the impact on the running time. It seems low
because we almost never iterate on fixed variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#ab7e81c6d3e23deb4d58662661bf07f70 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#ab7e81c6d3e23deb4d58662661bf07f70">operations_research::glop::LinearProgram::Dump</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000756 (user): if needed provide similar output for binary variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a87ada5361f8f85b8429dff857bcd29ec "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a87ada5361f8f85b8429dff857bcd29ec">operations_research::glop::LinearProgram::FindOrCreateVariable</a>" (const std::string &amp;variable_id)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000758 (user): Move these and the two corresponding hash_table into a new
LinearProgramBuilder class to simplify the code of some functions like
DeleteColumns() here and make the behavior on copy clear? or simply remove
them as it is almost as easy to maintain a hash_table on the client side. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#abdf54cae5dbc76354d86e34108dcb3f3 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#abdf54cae5dbc76354d86e34108dcb3f3">operations_research::glop::LinearProgram::GetNonZeroStats</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000760 (user): Theses are statistics about the underlying matrix and should be
moved to SparseMatrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8c6c53f53e930c90d42930e648946ec6 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8c6c53f53e930c90d42930e648946ec6" title="Returns whether the variable at column col must take binary values or not.">operations_research::glop::LinearProgram::IsVariableBinary</a>" (ColIndex col) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000755 (user): bounds of binary variables (and of integer ones) should
be integer. Add a preprocessor for that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#afdef8d3fad551379c138ea96f9b695d3 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#afdef8d3fad551379c138ea96f9b695d3">operations_research::glop::LinearProgram::PopulateFromDual</a>" (const LinearProgram &amp;dual, RowToColMapping *duplicated_rows)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000762 (user): Do not interpret as a minimization problem? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8c83436c29274ad2930e716a0032d708 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8c83436c29274ad2930e716a0032d708">operations_research::glop::LinearProgram::ScaleObjective</a>" (GlopParameters::CostScalingAlgorithm method)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000763 (user): Another more aggressive idea is to set the median/mean/geomean
of the magnitudes to one. Investigate if this leads to better results. It
does look more robust.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#aafd3e53a18570f0757a0a58f666b88c8 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#aafd3e53a18570f0757a0a58f666b88c8">operations_research::glop::LinearProgram::SetVariableName</a>" (ColIndex col, absl::string_view name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000759 (user): Add PopulateIdsFromNames() so names added via
Set{Variable|Constraint}Name() can be found. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#a9546370ee7138da64e3fb67577230bad "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#a9546370ee7138da64e3fb67577230bad">operations_research::glop::LPSolver::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000406 (user): Currently, this is only modified when the simplex code is
executed.&lt;p&gt; \anchor _todo000407 (user): Improve the correlation with the running time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#ae525d5598b932514635be5f0329610a4 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#ae525d5598b932514635be5f0329610a4">operations_research::glop::LPSolver::LoadAndVerifySolution</a>" (const LinearProgram &amp;lp, const ProblemSolution &amp;solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000393 (user): Try to also check the precision of an INFEASIBLE or UNBOUNDED
return status. 
 &lt;p&gt; \anchor _todo000394 (user): the name is not really consistent since in practice those are
the "residual" since the primal/dual infeasibility are zero when
parameters_.provide_strong_optimal_guarantee() is true. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#adb7f0e515ab9d9503a454e05904c0376 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#adb7f0e515ab9d9503a454e05904c0376">operations_research::glop::LPSolver::MayHaveMultipleOptimalSolutions</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000405 (user): Test this behavior extensively if a client relies on it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#ac1d303dc79dae9cefd6185fda6c60e33 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#ac1d303dc79dae9cefd6185fda6c60e33">operations_research::glop::LPSolver::SolveWithTimeLimit</a>" (const LinearProgram &amp;lp, TimeLimit *time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000392 (user): Unfortunately we are not really helpful with the error message
here. We could do a better job. However most client should talk to glop via
an input protocol buffer which should have better validation messages. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LuFactorization Member \_internalref classoperations__research_1_1glop_1_1LuFactorization#ab7b32a56a250336b4f954ad707f24b90 "<a class="el" href="classoperations__research_1_1glop_1_1LuFactorization.html#ab7b32a56a250336b4f954ad707f24b90">operations_research::glop::LuFactorization::ComputeLowerTimesUpper</a>" (SparseMatrix *product) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000410 (user): avoid the matrix conversion by multiplying TriangularMatrix
directly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LuFactorization Member \_internalref classoperations__research_1_1glop_1_1LuFactorization#a9af5d602c804b0b6b64ace6d1b61f169 "<a class="el" href="classoperations__research_1_1glop_1_1LuFactorization.html#a9af5d602c804b0b6b64ace6d1b61f169">operations_research::glop::LuFactorization::ComputeOneNormConditionNumber</a>" (const CompactSparseMatrixView &amp;matrix) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000409 (user): separate this from LuFactorization. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MainLpPreprocessor Member \_internalref classoperations__research_1_1glop_1_1MainLpPreprocessor#a2d3237c0758f6628b102fcbe5b2002c8 "<a class="el" href="classoperations__research_1_1glop_1_1MainLpPreprocessor.html#a2d3237c0758f6628b102fcbe5b2002c8">operations_research::glop::MainLpPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000425 (user): Run them in the loop above if the effect on the running time
is good. This needs more investigation. 
 &lt;p&gt; \anchor _todo000426 (user): We probably want to scale the costs before and after this
preprocessor so that the rhs/objective of the dual are with a good
magnitude. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Markowitz Member \_internalref classoperations__research_1_1glop_1_1Markowitz#a57adb2bec33795ce391f871a1acbf761 "<a class="el" href="classoperations__research_1_1glop_1_1Markowitz.html#a57adb2bec33795ce391f871a1acbf761">operations_research::glop::Markowitz::ComputeRowAndColumnPermutation</a>" (const CompactSparseMatrixView &amp;basis_matrix, RowPermutation *row_perm, ColumnPermutation *col_perm)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000411 (user): If we don't need L and U, we can abort when the residual
matrix becomes dense (i.e. when its density factor is above a certain
threshold). The residual size is 'end_index - index' and the
density can either be computed exactly or estimated from min_markowitz. 
 &lt;p&gt; \anchor _todo000412 (user): This step can be skipped, once a fully dense matrix is
obtained. But note that permuted_lower_column_needs_solve_ needs to be
updated. 
 &lt;p&gt; \anchor _todo000413 (user): Note that in some rare cases, because of numerical
cancellation, the column degree may actually be smaller than
pivot_col_degree. Exploit that better? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MatrixEntry Class \_internalref structoperations__research_1_1glop_1_1MatrixEntry "<a class="el" href="structoperations__research_1_1glop_1_1MatrixEntry.html" title="Holds a triplet (row, col, coefficient).">operations_research::glop::MatrixEntry</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000466 (user): Generalize the design used in this preprocessor to a general
"propagation" framework in order to apply as many reductions as possible in
an efficient manner. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MatrixNonZeroPattern Member \_internalref classoperations__research_1_1glop_1_1MatrixNonZeroPattern#acba2eb03de47fb8c7cabe51848d04612 "<a class="el" href="classoperations__research_1_1glop_1_1MatrixNonZeroPattern.html#acba2eb03de47fb8c7cabe51848d04612">operations_research::glop::MatrixNonZeroPattern::Update</a>" (RowIndex pivot_row, ColIndex pivot_col, const SparseColumn &amp;column)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000421 (user): Add unit tests before using this. 
 &lt;p&gt; \anchor _todo000420 (user): Special case if row_non_zero_[pivot_row].size() == 1?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#af8a64136c69a6dfc1b38c22c754cbe65 "<a class="el" href="namespaceoperations__research_1_1glop.html#af8a64136c69a6dfc1b38c22c754cbe65" title="Converts a MPModelProto to a LinearProgram.">operations_research::glop::MPModelProtoToLinearProgram</a>" (const MPModelProto &amp;input, LinearProgram *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000780 (user): clean up loops to use natural range iteration.
 &lt;p&gt; \anchor _todo000781 (user): implement strong proto validation in the
linear solver server and re-use it here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MPSReaderImpl Member \_internalref classoperations__research_1_1glop_1_1MPSReaderImpl#a01c6b0a7a9edd5f785eec2bf5a1ad4d1 "<a class="el" href="classoperations__research_1_1glop_1_1MPSReaderImpl.html#a01c6b0a7a9edd5f785eec2bf5a1ad4d1">operations_research::glop::MPSReaderImpl::MPSReaderImpl</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000776 (user): Support 'SI' (semi integer).
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Preprocessor Class \_internalref classoperations__research_1_1glop_1_1Preprocessor "<a class="el" href="classoperations__research_1_1glop_1_1Preprocessor.html">operations_research::glop::Preprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000465 (user): On most preprocessors, calling Run() more than once will not work
as expected. Fix? or document and crash in debug if this happens. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Preprocessor Member \_internalref classoperations__research_1_1glop_1_1Preprocessor#ab755069ed133ea14ffec0bba56930559 "<a class="el" href="classoperations__research_1_1glop_1_1Preprocessor.html#ab755069ed133ea14ffec0bba56930559">operations_research::glop::Preprocessor::IsSmallerWithinPreprocessorZeroTolerance</a>" (Fractional a, Fractional b) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000472 (user): use an absolute tolerance here to be even more defensive?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::PrimalPrices Class \_internalref classoperations__research_1_1glop_1_1PrimalPrices "<a class="el" href="classoperations__research_1_1glop_1_1PrimalPrices.html">operations_research::glop::PrimalPrices</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000490 (user): Not high priority but should probably be moved to its own file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::PrimalPrices Member \_internalref classoperations__research_1_1glop_1_1PrimalPrices#ab2a479cbb008b8ae4b9ec2d294f79c07 "<a class="el" href="classoperations__research_1_1glop_1_1PrimalPrices.html#ab2a479cbb008b8ae4b9ec2d294f79c07">operations_research::glop::PrimalPrices::PrimalPrices</a>" (absl::BitGenRef random, const VariablesInfo &amp;variables_info, PrimalEdgeNorms *primal_edge_norms, ReducedCosts *reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000492 (user): Switch to a model based API like in CP-SAT. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ProportionalColumnPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ProportionalColumnPreprocessor#afdfcacb0413c8aefe02ff1b9eae0ac68 "<a class="el" href="classoperations__research_1_1glop_1_1ProportionalColumnPreprocessor.html#afdfcacb0413c8aefe02ff1b9eae0ac68">operations_research::glop::ProportionalColumnPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000428 (user): Change FindProportionalColumns for this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ProportionalRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ProportionalRowPreprocessor#adddaa59a5bbb8b300795e6f2b9287d3c "<a class="el" href="classoperations__research_1_1glop_1_1ProportionalRowPreprocessor.html#adddaa59a5bbb8b300795e6f2b9287d3c">operations_research::glop::ProportionalRowPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000430 (user): if the bounds are equal, use the largest row in magnitude?
 &lt;p&gt; \anchor _todo000429 (user): Already return such a mapping from
FindProportionalColumns()? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RandomAccessSparseColumn Member \_internalref classoperations__research_1_1glop_1_1RandomAccessSparseColumn#a59461735207f0d09b1175d3522762f2a "<a class="el" href="classoperations__research_1_1glop_1_1RandomAccessSparseColumn.html#a59461735207f0d09b1175d3522762f2a">operations_research::glop::RandomAccessSparseColumn::PopulateSparseColumn</a>" (SparseColumn *sparse_column) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000792 (user): Do that only if (value != 0.0) ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RankOneUpdateFactorization Member \_internalref classoperations__research_1_1glop_1_1RankOneUpdateFactorization#a3b877b20ffaa0ba743da5c3cb7fa7744 "<a class="el" href="classoperations__research_1_1glop_1_1RankOneUpdateFactorization.html#a3b877b20ffaa0ba743da5c3cb7fa7744">operations_research::glop::RankOneUpdateFactorization::DeterministicTimeSinceLastReset</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000487 (user): This is quite precise. However we overcount a bit, because in
each elementary solves, if the scalar product involved is zero, we skip
some of the operations counted here. Is it worth spending a bit more time
to be more precise here? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RankOneUpdateFactorization Member \_internalref classoperations__research_1_1glop_1_1RankOneUpdateFactorization#af68318310cfb9859c6d98a3e31ccafac "<a class="el" href="classoperations__research_1_1glop_1_1RankOneUpdateFactorization.html#af68318310cfb9859c6d98a3e31ccafac">operations_research::glop::RankOneUpdateFactorization::RankOneUpdateFactorization</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000486 (user): make the 5% a parameter and share it between all the places
that switch between a sparse/dense version. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RemoveNearZeroEntriesPreprocessor Class \_internalref classoperations__research_1_1glop_1_1RemoveNearZeroEntriesPreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1RemoveNearZeroEntriesPreprocessor.html">operations_research::glop::RemoveNearZeroEntriesPreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000468 (user): This preprocessor doesn't work well on badly scaled problems. In
particular, it will set the objective to zero if all the objective
coefficients are small! Run it after ScalingPreprocessor or fix the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RemoveNearZeroEntriesPreprocessor Member \_internalref classoperations__research_1_1glop_1_1RemoveNearZeroEntriesPreprocessor#a2a761d615b31eac9f0d1cc87e9a5d3c1 "<a class="el" href="classoperations__research_1_1glop_1_1RemoveNearZeroEntriesPreprocessor.html#a2a761d615b31eac9f0d1cc87e9a5d3c1">operations_research::glop::RemoveNearZeroEntriesPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000452 (user): Our criteria ensure that during presolve a primal feasible
solution will stay primal feasible. However, we have no guarantee on the
dual-feasibility (because the dual variable values range is not taken into
account). Fix that? or find a better criteria since it seems that on all
our current problems, this preprocessor helps and doesn't introduce errors. 
 &lt;p&gt; \anchor _todo000453 (user): Write a small class that takes a matrix, its transpose, row
and column bounds, and "propagate" the bounds as much as possible so we
can use this better estimate here and remove more near-zero entries. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#ac81a24729018987c4d0668b7dc92b7c7 "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#ac81a24729018987c4d0668b7dc92b7c7">operations_research::glop::RevisedSimplex::ComputeDictionary</a>" (const DenseRow *column_scales)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000546 (user): Use row scales as well. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#ada2f59f7b385068f27d172f1f9bff72a "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#ada2f59f7b385068f27d172f1f9bff72a">operations_research::glop::RevisedSimplex::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000502 (user): Count what is missing.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#ac08f8edb988e06b034fa6f9516913368 "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#ac08f8edb988e06b034fa6f9516913368">operations_research::glop::RevisedSimplex::Solve</a>" (const LinearProgram &amp;lp, TimeLimit *time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000495 (user): Not ideal in an incremental setting. 
 &lt;p&gt; \anchor _todo000494 (user): Avoid doing the first phase checks when we know from the
incremental solve that the solution is already dual or primal feasible. 
 &lt;p&gt; \anchor _todo000496 (user): Note that if there was cost shifts, we just keep them
until the end of the optim.&lt;p&gt; \anchor _todo000497 (user): What if slightly infeasible? we shouldn't really stop.
Call primal ? use higher tolerance ? It seems we can always kind of
continue and deal with the issue later. Find a way other than this +
1e-6 hack. 
 &lt;p&gt; \anchor _todo000498 (user): We should also confirm the PRIMAL_UNBOUNDED or DUAL_UNBOUNDED
status by checking with the other phase I that the problem is really
DUAL_INFEASIBLE or PRIMAL_INFEASIBLE. For instance we currently report
PRIMAL_UNBOUNDED with the primal on the problem l30.mps instead of
OPTIMAL and the dual does not have issues on this problem.&lt;p&gt; \anchor _todo000499 (user): There is another issue on infeas/qual.mps. I think we should
just check the dual ray, not really the current solution dual
feasibility. 
 &lt;p&gt; \anchor _todo000500 (user): we currently skip the DUAL_INFEASIBLE status because the
quantities are not up to date in this case. 
 &lt;p&gt; \anchor _todo000501 (user): We should re-check for feasibility at this point and
apply clean-up as needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplexDictionary Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplexDictionary#a23359894a725f27972fc3a3b6b919db9 "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplexDictionary.html#a23359894a725f27972fc3a3b6b919db9">operations_research::glop::RevisedSimplexDictionary::GetBasicColumnForRow</a>" (RowIndex r) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000550 (user): This function is a better fit for the future custom iterator.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplexDictionary Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplexDictionary#a79cca8bd83c2bde1691dd782335d767e "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplexDictionary.html#a79cca8bd83c2bde1691dd782335d767e">operations_research::glop::RevisedSimplexDictionary::RevisedSimplexDictionary</a>" (const DenseRow *col_scales, RevisedSimplex *revised_simplex)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000549 (user): Overload this to take RevisedSimplex* alone when the
caller would normally pass a nullptr for col_scales so this and
ComputeDictionary can take a const&amp; argument. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a46935a48ea28abfec1c2569fe4aea70f "<a class="el" href="namespaceoperations__research_1_1glop.html#a3d9874910f9632900fe8677463b1c0be">operations_research::glop::ScalarProduct</a>" (const DenseRowOrColumn &amp;u, const SparseColumn &amp;v)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000767 (user): Optimize this more (SSE or unroll with two sums). Another
option is to skip the u[col] that are 0.0 rather than fetching the coeff
and doing a Fractional multiplication. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ScatteredVector Class \_internalref structoperations__research_1_1glop_1_1ScatteredVector "operations_research::glop::ScatteredVector&lt; Index, Iterator &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000782 (user): This should be changed from struct to class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ScatteredVector Member \_internalref structoperations__research_1_1glop_1_1ScatteredVector#a1863a881c8165a5b4217f58e70dcbc97 "<a class="el" href="structoperations__research_1_1glop_1_1ScatteredVector.html#a1863a881c8165a5b4217f58e70dcbc97">operations_research::glop::ScatteredVector&lt; Index, Iterator &gt;::kDefaultRatioForUsingDenseIteration</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000783 (user): The constant should depend on what algorithm is used. Clearing
a dense vector is a lot more efficient than doing more complex stuff. Clean
this up by extracting all the currently used constants in one place with
meaningful names. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ShiftVariableBoundsPreprocessor Class \_internalref classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor.html">operations_research::glop::ShiftVariableBoundsPreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000470 (user): Having for each variable one of their bounds at zero is a
requirement for the DualizerPreprocessor and for the implied free column in
the ImpliedFreePreprocessor. However, shifting a variable with a domain like
[-1e10, 1e10] may introduce numerical issues. Relax the definition of
a free variable so that only having a domain containing 0.0 is enough? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ShiftVariableBoundsPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor#aaa5aa6fd0a5ab4229ab8b8f1ca6f638c "<a class="el" href="classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor.html#aaa5aa6fd0a5ab4229ab8b8f1ca6f638c">operations_research::glop::ShiftVariableBoundsPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000463 (user): This would not be needed, if we always make the bound
of an integer variable integer before applying this preprocessor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SingletonPreprocessor Member \_internalref classoperations__research_1_1glop_1_1SingletonPreprocessor#ad57922a716f7058c76b5f524950b8953 "<a class="el" href="classoperations__research_1_1glop_1_1SingletonPreprocessor.html#ad57922a716f7058c76b5f524950b8953">operations_research::glop::SingletonPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000451 (user): We should be able to restrict the variable bounds with the
ones of the constraint all the time. However, some situation currently
break the presolve, and it seems hard to fix in a 100% safe way. 
 &lt;p&gt; \anchor _todo000450 (user): It seems better to process all the singleton columns with
a cost of zero first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseMatrixScaler Member \_internalref classoperations__research_1_1glop_1_1SparseMatrixScaler#a5b7f75e659b008634b2979b3a9f2ab91 "<a class="el" href="classoperations__research_1_1glop_1_1SparseMatrixScaler.html#a5b7f75e659b008634b2979b3a9f2ab91">operations_research::glop::SparseMatrixScaler::col_scale</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000770 (user): rename function and field to col_scales (and row_scales)
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseMatrixScaler Member \_internalref classoperations__research_1_1glop_1_1SparseMatrixScaler#abe05dd74a745d50bce6f9b6f14ab0bbc "<a class="el" href="classoperations__research_1_1glop_1_1SparseMatrixScaler.html#abe05dd74a745d50bce6f9b6f14ab0bbc" title="Scales the matrix.">operations_research::glop::SparseMatrixScaler::Scale</a>" (GlopParameters::ScalingAlgorithm method)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000769 (user): Decide precisely for which value of dynamic range we should cut
off geometric scaling. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseRow Class \_internalref classoperations__research_1_1glop_1_1SparseRow "<a class="el" href="classoperations__research_1_1glop_1_1SparseRow.html">operations_research::glop::SparseRow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000795 (user): Use this class where appropriate, i.e. when a SparseColumn is
used to store a row vector (by means of RowIndex to ColIndex casting). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Class \_internalref classoperations__research_1_1glop_1_1SparseVector "operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000796 (user): un-expose this type to client; by getting rid of the
index-based APIs and leveraging iterator-based APIs; if possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#a281b1ceefbefc14e321958f139dd8ea3 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a281b1ceefbefc14e321958f139dd8ea3">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::AllEntryIndices</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000801 (user): consider removing this, in favor of the natural range
iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#afb0952c189b9c921d79526b96295a2c8 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afb0952c189b9c921d79526b96295a2c8">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::CleanUp</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000797 (user): Implement in-place sorting of the entries and cleanup. The
current version converts the data to an array-of-pairs representation that
can be sorted easily with std::stable_sort, and the converts the sorted
data back to the struct-of-arrays implementation.
The current version is ~20% slower than the in-place sort on the
array-of-struct representation. It is not visible on GLOP benchmarks, but
it increases peak memory usage by ~8%.
Implementing in-place search will require either implementing a custom
sorting code, or custom iterators that abstract away the internal
representation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#afbae873b1b6a1f33cac11606834b6d0e "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afbae873b1b6a1f33cac11606834b6d0e">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::LookUpCoefficient</a>" (Index index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000800 (user): investigate whether an optimized version of
LookUpCoefficient for "clean" columns yields speed-ups. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#ac8066cbc5d5b7f8e794677b027cd96a2 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac8066cbc5d5b7f8e794677b027cd96a2">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::MoveTaggedEntriesTo</a>" (const IndexPermutation &amp;index_perm, SparseVector *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000799 (user): In the way we use this function, we know that will not
happen, but it is better to be careful so we can check that properly in
debug mode. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::StrictITISpan Member \_internalref classoperations__research_1_1glop_1_1StrictITISpan#a567f91a908d6143535f19afba8b2066b "<a class="el" href="classoperations__research_1_1glop_1_1StrictITISpan.html#a567f91a908d6143535f19afba8b2066b">operations_research::glop::StrictITISpan&lt; IntType, T &gt;::begin</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000765 (user): This should probably be a strictly typed iterator too, but
&lt;tt&gt;StrongVector::begin()&lt;/tt&gt; already suffers from this problem. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::StrictITIVector Class \_internalref classoperations__research_1_1glop_1_1StrictITIVector "operations_research::glop::StrictITIVector&lt; IntType, T &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000764 (user): This should probably move into ITIVector, but note that this
version is more strict and does not allow any other size types. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#ad5f38322fa7495d265b8a9d165e04661 "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#ad5f38322fa7495d265b8a9d165e04661">operations_research::glop::TriangularMatrix::AddAndNormalizeTriangularColumn</a>" (const SparseColumn &amp;column, RowIndex diagonal_row, Fractional diagonal_coefficient)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000785 (user): use division by a constant using multiplication.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#ac20baed56dfc7f31921f5bbb64e6950e "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#ac20baed56dfc7f31921f5bbb64e6950e">operations_research::glop::TriangularMatrix::ComputeRowsToConsiderInSortedOrder</a>" (RowIndexVector *non_zero_rows, Fractional sparsity_ratio, Fractional num_ops_ratio) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000788 (user): Investigate the best thresholds.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#adbf1ad02396e91500821d368dcd2ed4a "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#adbf1ad02396e91500821d368dcd2ed4a">operations_research::glop::TriangularMatrix::ComputeRowsToConsiderWithDfs</a>" (RowIndexVector *non_zero_rows) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000787 (user): Investigate the best thresholds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#accd27fcf09dbc70b99c5ff3420df68ab "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#accd27fcf09dbc70b99c5ff3420df68ab">operations_research::glop::TriangularMatrix::PermutedLowerSparseSolve</a>" (const ColumnView &amp;rhs, const RowPermutation &amp;row_perm, SparseColumn *lower, SparseColumn *upper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000786 (user): The size of lower is exact, so we could be slighly faster here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#a85bc81777e98efdcf8e96566dc7b34b5 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#a85bc81777e98efdcf8e96566dc7b34b5">operations_research::glop::UnconstrainedVariablePreprocessor::RecoverSolution</a>" (ProblemSolution *solution) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000443 (user): In presence of free row, we must move them to 0.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#ab9d32efc837e15a7512083c4e450d459 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#ab9d32efc837e15a7512083c4e450d459">operations_research::glop::UnconstrainedVariablePreprocessor::RemoveZeroCostUnconstrainedVariable</a>" (ColIndex col, Fractional target_bound, LinearProgram *lp)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000437 (user): Here, we may render the row free, so subsequent columns
processed by the columns loop in Run() have more chance to be removed.
However, we need to be more careful during the postsolve() if we do that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#a59fa9c1508a94256ea5cb1d79597d170 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#a59fa9c1508a94256ea5cb1d79597d170">operations_research::glop::UnconstrainedVariablePreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000438 (user): Expose it as a parameter. We could rename both to
preprocessor_low_tolerance and preprocessor_high_tolerance. 
 &lt;p&gt; \anchor _todo000439 (user): expose this as a parameter? IMO it isn't really needed as we
shouldn't reach this limit except in corner cases. 
 &lt;p&gt; \anchor _todo000440 (user): deal with the more generic case. 
 &lt;p&gt; \anchor _todo000441 (user): this also works if the variable is integer, but we must
choose an integer value during the post-solve. Implement this. 
 &lt;p&gt; \anchor _todo000442 (user): It should probably
work with only small modification, investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a83458aab35755e7f4e0f1a2b38c912c2 "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a83458aab35755e7f4e0f1a2b38c912c2">operations_research::glop::UpdateRow::ComputeUnitRowLeftInverse</a>" (RowIndex leaving_row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000551 (user): Refactorize if the estimated accuracy is above a threshold.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a87bff95c808ef1850684ba48f3bf044f "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a87bff95c808ef1850684ba48f3bf044f">operations_research::glop::UpdateRow::ComputeUpdateRow</a>" (RowIndex leaving_row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000553 (user): The impact is not as high as I hopped though, so not too
important. 
 &lt;p&gt; \anchor _todo000554 (user): automate the computation of these constants at run-time? 
 &lt;p&gt; \anchor _todo000552 (user): So far we didn't generalize the use of drop tolerances
everywhere in the solver, so we make sure to not modify
unit_row_left_inverse_ that is also used elsewhere. However, because of
that, we will not get the exact same result depending on the algortihm
used below because the ComputeUpdatesColumnWise() will still use these
small entries (no complexity changes). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a0574601e3d61bdd8bafbd8996c78516b "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a0574601e3d61bdd8bafbd8996c78516b">operations_research::glop::UpdateRow::GetCoefficients</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000556 (user): Consider returning a packed vector of coefficient parallel to
GetNonZeroPositions() instead. It should be fast to compute and iteration
later should be quicker. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#a29fdd427dcae4052217c2977b7a11868 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#a29fdd427dcae4052217c2977b7a11868">operations_research::glop::VariablesInfo::EndDualPhaseI</a>" (Fractional dual_feasibility_tolerance, const DenseRow &amp;reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000563 (user): When there is a choice, use the previous status that might
have been warm-started ? but then this is not high priority since
warm-starting with a non-dual feasible basis seems unfrequent. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#a3e74d6566e11d92438687f6dbb48daf1 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#a3e74d6566e11d92438687f6dbb48daf1">operations_research::glop::VariablesInfo::TransformToDualPhaseIProblem</a>" (Fractional dual_feasibility_tolerance, const DenseRow &amp;reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000566 (user): Shall we re-add the bound when the variable is moved out of
the base? it is not needed, but might allow for more bound flips? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#aa6ae2139d9427d7dc458a93e2f8b5588 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#aa6ae2139d9427d7dc458a93e2f8b5588">operations_research::glop::VariablesInfo::UpdateToBasicStatus</a>" (ColIndex col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000559 (user): A bit annoying that we need to test this even if we
don't use the dual. But the cost is minimal. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariableValues Member \_internalref classoperations__research_1_1glop_1_1VariableValues#ab0a189867045312e53d3f0c88974e81e "<a class="el" href="classoperations__research_1_1glop_1_1VariableValues.html#ab0a189867045312e53d3f0c88974e81e">operations_research::glop::VariableValues::RecomputeDualPrices</a>" (bool put_more_importance_on_norm=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000557 (user): On some problem like stp3d.mps or pds-100.mps, using different
price like abs(infeasibility) / squared_norms give better result. Some
solver switch according to a criteria like all entry are +1/-1, the column
have no more than 24 non-zero and the average column size is no more than
6! Understand and implement some variant of this? I think the gain is
mainly because of using sparser vectors? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLOPInterface Member \_internalref classoperations__research_1_1GLOPInterface#ac495bd550d8588e457e6998d9af89b53 "<a class="el" href="classoperations__research_1_1GLOPInterface.html#ac495bd550d8588e457e6998d9af89b53">operations_research::GLOPInterface::SetDualTolerance</a>" (double value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000692 (user): Modify parameters_ with the correct value.
The problem is that this is set by default by the wrapper to 1e-7 and for
now we want to use higher default tolerances in Glop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLOPInterface Member \_internalref classoperations__research_1_1GLOPInterface#a5e4f4b2a7b1140077d676a179a349dc3 "<a class="el" href="classoperations__research_1_1GLOPInterface.html#a5e4f4b2a7b1140077d676a179a349dc3">operations_research::GLOPInterface::SetPrimalTolerance</a>" (double value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000691 (user): Modify parameters_ with the correct value.
The problem is that this is set by default by the wrapper to 1e-7 and for
now we want to use higher default tolerances in Glop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a09ec441521b625aa6d45620f6b26d781 "<a class="el" href="namespaceoperations__research.html#a09ec441521b625aa6d45620f6b26d781">operations_research::GlopToMPSolverResultStatus</a>" (glop::ProblemStatus s)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000693 (user): We could argue that it is infeasible to find the optimal of
an unbounded problem. So it might just be simpler to completely get rid
of the MpSolver::UNBOUNDED status that seems to never be used
programmatically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLPKInterface Member \_internalref classoperations__research_1_1GLPKInterface#a2a1e883d9de9f8d855a561dea457c8a4 "<a class="el" href="classoperations__research_1_1GLPKInterface.html#a2a1e883d9de9f8d855a561dea457c8a4">operations_research::GLPKInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000694 (user): support MIP.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#a42c71ed3bac0344dfe9964839806566b "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#a42c71ed3bac0344dfe9964839806566b">operations_research::GraphSymmetryFinder::FindSymmetries</a>" (std::vector&lt; int &gt; *node_equivalence_classes_io, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators, std::vector&lt; int &gt; *factorized_automorphism_group_size, TimeLimit *time_limit=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000012 (user): Don't build a list; but instead use direct, inline iteration
on the representatives in the while() loop below, to benefit from the
incremental merging of the equivalence classes. 
 &lt;p&gt; \anchor _todo000011 &lt;p&gt; \anchor _todo000024 (user): verify the minimality in unit tests.&lt;p&gt; \anchor _todo000009 (user): experiment with, and briefly describe the results of various
algorithms for picking the invariant node:
- random selection
- highest/lowest degree first
- enumerate by part index; or by part size
- etc. 
 &lt;p&gt; \anchor _todo000010 (user): better elect the representative of each equivalence class
in order to reduce the permutation support down the line
&lt;p&gt; \anchor _todo000013 (user): better, more complete explanation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#af670a8f7f325e3a7431f2723c52ec25d "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#af670a8f7f325e3a7431f2723c52ec25d">operations_research::GraphSymmetryFinder::GraphSymmetryFinder</a>" (const Graph &amp;graph, bool is_undirected)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000023 (user): support multi-arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#a70544105d8f21edcbed63fdd7f6d34ab "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#a70544105d8f21edcbed63fdd7f6d34ab">operations_research::GraphSymmetryFinder::RecursivelyRefinePartitionByAdjacency</a>" (int first_unrefined_part_index, DynamicPartition *partition)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000008 (user): We are really imprecise in our counting, but it is fine. We
just need a way to enforce a deterministic limit on the computation effort. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScip Member \_internalref classoperations__research_1_1GScip#a7ecb44c965a5d5c2e8a14c9b89d36c83 "<a class="el" href="classoperations__research_1_1GScip.html#a7ecb44c965a5d5c2e8a14c9b89d36c83">operations_research::GScip::InterruptSolve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000667 (user): should we add a lock here? Seems a little dangerous to block
in a destructor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScip Member \_internalref classoperations__research_1_1GScip#ab7136ff892af60a8dd914f5953f39e9b "<a class="el" href="classoperations__research_1_1GScip.html#ab7136ff892af60a8dd914f5953f39e9b">operations_research::GScip::SetBranchingPriority</a>" (SCIP_VAR *var, int priority)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000666 (user): Add support for BranchingFactor as well, this is typically
more useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScip Member \_internalref classoperations__research_1_1GScip#ab1e8e1eb53b45e5a8199f9085b99e601 "<a class="el" href="classoperations__research_1_1GScip.html#ab1e8e1eb53b45e5a8199f9085b99e601">operations_research::GScip::SetLb</a>" (SCIP_VAR *var, double lb)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000664 (b/246342145): A crash may occur if you attempt to set a lb &lt;= -1.0 on
a binary variable. SCIP can also silently change the vartype of a variable
after construction, so you should check it via &lt;tt&gt;VarType()&lt;/tt&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScip Member \_internalref classoperations__research_1_1GScip#afbb8ce39eb848e6f1ad16e1846bab991 "<a class="el" href="classoperations__research_1_1GScip.html#afbb8ce39eb848e6f1ad16e1846bab991">operations_research::GScip::SetLinearConstraintCoef</a>" (SCIP_CONS *constraint, SCIP_VAR *var, double value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000661 (user): this operation is slow (linear in the nnz in the constraint).
It would be better to just use a bulk operation, but there doesn't appear
to be any? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScip Member \_internalref classoperations__research_1_1GScip#ad8b6b87e1106371b67be3c718c9bc8b8 "<a class="el" href="classoperations__research_1_1GScip.html#ad8b6b87e1106371b67be3c718c9bc8b8">operations_research::GScip::SetUb</a>" (SCIP_VAR *var, double ub)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000665 (b/246342145): A crash may occur if you attempt to set an ub &gt;= 2.0 on
a binary variable. SCIP can also silently change the vartype of a variable
after construction, so you should check it via &lt;tt&gt;VarType()&lt;/tt&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScip Member \_internalref classoperations__research_1_1GScip#aa5a4bcffe985cbb706fac06101049004 "<a class="el" href="classoperations__research_1_1GScip.html#aa5a4bcffe985cbb706fac06101049004">operations_research::GScip::Solve</a>" (const GScipParameters &amp;params=GScipParameters(), const std::string &amp;legacy_params="", GScipMessageHandler message_handler=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000662 (user): refactor this into a new method.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a2ae4481bf6aa10bc1937cb0362116114 "<a class="el" href="namespaceoperations__research.html#a2ae4481bf6aa10bc1937cb0362116114">operations_research::GScipCreateMaximum</a>" (GScip *gscip, const GScipLinearExpr &amp;resultant, const std::vector&lt; GScipLinearExpr &gt; &amp;terms, const std::string &amp;name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000672 (user): it may be better to write this in terms of the disjuntive
constraint, we need to support disjunctions in gscip.h to do this.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipEventHandler Member \_internalref classoperations__research_1_1GScipEventHandler#a55733bd35aafd3ae06df04760d7fe05d "<a class="el" href="classoperations__research_1_1GScipEventHandler.html#a55733bd35aafd3ae06df04760d7fe05d">operations_research::GScipEventHandler::CatchEvent</a>" (SCIP_EVENTTYPE event_type)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000671 (user): Support registering events in the EVENTINITSOL
callback, which would cause them to be trapped only after presolve. 
 &lt;p&gt; \anchor _todo000670 (user): Support Var and Row events.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipLinearExpr Class \_internalref structoperations__research_1_1GScipLinearExpr "<a class="el" href="structoperations__research_1_1GScipLinearExpr.html">operations_research::GScipLinearExpr</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000674 (user): delete this type and the methods below, use a generic version
templated on the variable type that supports operator overloads. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipQuadraticRange Member \_internalref structoperations__research_1_1GScipQuadraticRange#a625a69d159292a2c717436158af9bece "<a class="el" href="structoperations__research_1_1GScipQuadraticRange.html#a625a69d159292a2c717436158af9bece">operations_research::GScipQuadraticRange::quadratic_variables1</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000668 (user): investigate, the documentation seems to suggest that when
linear_variables[i] == quadratic_variables1[i] == quadratic_variables2[i]
there is some advantage. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a6e6dd79c5599c9ccf1b7a12aebe8f622 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a6e6dd79c5599c9ccf1b7a12aebe8f622" title="Clears a constraint from all its terms.">operations_research::GurobiInterface::ClearConstraint</a>" (MPConstraint *const constraint) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000698 (user): this is difficult to make incremental, like
 SetConstraintBounds(), because of the auxiliary Gurobi variables that
 range constraints introduce. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a80f01ad50450397a74e29c3db67ff69c "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a80f01ad50450397a74e29c3db67ff69c">operations_research::GurobiInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000701 (user): Not yet working.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#abdc377748278a3c5c35a847bfd146a31 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#abdc377748278a3c5c35a847bfd146a31" title="Iterates through the solutions in Gurobi&#39;s solution pool.">operations_research::GurobiInterface::NextSolution</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000700 (user): This reset may not be necessary, investigate.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a17ee8d162458efb5f3a5a4cce64ab2cd "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a17ee8d162458efb5f3a5a4cce64ab2cd" title="Changes a coefficient in a constraint.">operations_research::GurobiInterface::SetCoefficient</a>" (MPConstraint *const constraint, const MPVariable *const variable, double new_value, double old_value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000697 (user): investigate if this has bad performance.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a937c9e7503e0bc746f8fa40c7591f16a "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a937c9e7503e0bc746f8fa40c7591f16a" title="Modify bounds of an extracted variable.">operations_research::GurobiInterface::SetConstraintBounds</a>" (int row_index, double lb, double ub) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000696 (user): this is nontrivial to make incremental:
  1. Make sure it is a linear constraint (not an indicator or indicator
     range constraint).
  2. Check if the sense of the constraint changes. If it was previously a
     range constraint, we can do nothing, and if it becomes a range
     constraint, we can do nothing. We could support range constraints if
     we tracked the auxiliary variable that is added with range
     constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a3fdaaef4033cbc2f6e0ef07ade784682 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a3fdaaef4033cbc2f6e0ef07ade784682">operations_research::GurobiInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000699 (user): We could introduce our own "infeasible or unbounded" status. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HamiltonianPathSolver Member \_internalref classoperations__research_1_1HamiltonianPathSolver#ab7380d5367176d7d567876433d1dd918 "<a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html#ab7380d5367176d7d567876433d1dd918">operations_research::HamiltonianPathSolver&lt; CostType, CostFunction &gt;::Integer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000597 (user): remove this limitation by using pruning techniques. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aee1401375b23909949cce272a3b787db "<a class="el" href="namespaceoperations__research.html#aee1401375b23909949cce272a3b787db">operations_research::Hash1</a>" (uint64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000124 (user): use murmurhash. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::InsertionGenerator Member \_internalref classoperations__research_1_1InsertionGenerator#a0c381600e21efcf683907ac1e4e384fb "<a class="el" href="classoperations__research_1_1InsertionGenerator.html#a0c381600e21efcf683907ac1e4e384fb">operations_research::InsertionGenerator::AppendPickupDeliveryMultitourInsertions</a>" (int pickup, const std::vector&lt; int &gt; &amp;path, const std::vector&lt; bool &gt; &amp;node_is_pickup, const std::vector&lt; bool &gt; &amp;node_is_delivery, std::vector&lt; PickupDeliveryInsertion &gt; &amp;insertions)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000322 (user): Allow to reuse generated insertions for several
pickup/delivery pairs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntegerPriorityQueue Member \_internalref classoperations__research_1_1IntegerPriorityQueue#a660816e2b5398fc18dd92a58327f630c "<a class="el" href="classoperations__research_1_1IntegerPriorityQueue.html#a660816e2b5398fc18dd92a58327f630c">operations_research::IntegerPriorityQueue&lt; Element, Compare &gt;::Clear</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002132 (user): we could make this sparse if it is needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVar Member \_internalref classoperations__research_1_1IntVar#af3c6b509b9279db09301192b57dfb3cd "<a class="el" href="classoperations__research_1_1IntVar.html#af3c6b509b9279db09301192b57dfb3cd" title="This method remove the values from the domain of the variable.">operations_research::IntVar::RemoveValues</a>" (const std::vector&lt; int64_t &gt; &amp;values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000160 (user) : Sort values! 
 &lt;p&gt; \anchor _todo000159 (user): Check and maybe inline this code.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVar Member \_internalref classoperations__research_1_1IntVar#a3b3b2ee0dc78430a3008c0894531196f "<a class="el" href="classoperations__research_1_1IntVar.html#a3b3b2ee0dc78430a3008c0894531196f" title="This method intersects the current domain with the values in the array.">operations_research::IntVar::SetValues</a>" (const std::vector&lt; int64_t &gt; &amp;values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000166 (user) : We could find the first position &gt;= vmin by dichotomy.
 &lt;p&gt; \anchor _todo000165 (user): We could filter out values not in the var. 
 &lt;p&gt; \anchor _todo000164 &lt;p&gt; \anchor _todo000162 &lt;p&gt; \anchor _todo000161 (user): use a clean and safe SortedUniqueCopy() class
that uses a global, static shared (and locked) storage.
&lt;p&gt; \anchor _todo000163 (user): [optional] consider porting
STLSortAndRemoveDuplicates from ortools/base/stl_util.h to the
existing open_source/base/stl_util.h and using it here.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVarFilteredDecisionBuilder Class \_internalref classoperations__research_1_1IntVarFilteredDecisionBuilder "<a class="el" href="classoperations__research_1_1IntVarFilteredDecisionBuilder.html">operations_research::IntVarFilteredDecisionBuilder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000333 (user): Eventually move this to the core CP solver library
when the code is mature enough. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVarLocalSearchOperator Member \_internalref classoperations__research_1_1IntVarLocalSearchOperator#ac8bc688def85b27b6aa66e1f099050a4 "<a class="el" href="classoperations__research_1_1IntVarLocalSearchOperator.html#ac8bc688def85b27b6aa66e1f099050a4">operations_research::IntVarLocalSearchOperator::MakeOneNeighbor</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000126 (user): make it pure virtual, implies porting all apps overriding
MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator. 
 &lt;p&gt; \anchor _todo000188 (user): Make this a pure virtual.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackAssignment Class \_internalref structoperations__research_1_1KnapsackAssignment "<a class="el" href="structoperations__research_1_1KnapsackAssignment.html">operations_research::KnapsackAssignment</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000029 (user): Add a new propagator class for conflict constraint.
 &lt;p&gt; &lt;p&gt;(user): Add a new propagator class used as a guide when the problem has
several dimensions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackBruteForceSolver Member \_internalref classoperations__research_1_1KnapsackBruteForceSolver#a0b4c315873262155800b2645fdab0535 "<a class="el" href="classoperations__research_1_1KnapsackBruteForceSolver.html#a0b4c315873262155800b2645fdab0535" title="Initializes the solver and enters the problem to be solved.">operations_research::KnapsackBruteForceSolver::Init</a>" (const std::vector&lt; int64_t &gt; &amp;profits, const std::vector&lt; std::vector&lt; int64_t &gt; &gt; &amp;weights, const std::vector&lt; int64_t &gt; &amp;capacities) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000028 (user): Implement multi-dimensional brute force solver.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackCapacityPropagator Member \_internalref classoperations__research_1_1KnapsackCapacityPropagator#af1d7d1e175e652c64962af490ab42247 "<a class="el" href="classoperations__research_1_1KnapsackCapacityPropagator.html#af1d7d1e175e652c64962af490ab42247">operations_research::KnapsackCapacityPropagator::ComputeProfitBounds</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000027 (user): Make it more incremental, by saving the break item in a
search node for instance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackGenericSolver Class \_internalref classoperations__research_1_1KnapsackGenericSolver "<a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html">operations_research::KnapsackGenericSolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000030 (user): In the case of a multi-dimensional knapsack problem, implement
an aggregated propagator to combine all dimensions and give a better guide
to select the next item (see, for instance, Dobson's aggregated efficiency). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#ac5b423c249b7d295b22cd367d60a915a "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#ac5b423c249b7d295b22cd367d60a915a" title="Returns the basis status of a constraint.">operations_research::KnapsackInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000706 (user): set properly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#a91cb6e2a4e0c037e5ce12887e13d5a11 "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#a91cb6e2a4e0c037e5ce12887e13d5a11" title="Returns the basis status of a row.">operations_research::KnapsackInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000705 (user): set properly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#ad8e2065e33ed1870e473b6f296a93cba "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#ad8e2065e33ed1870e473b6f296a93cba" title="--‚Äî Solve --‚Äî">operations_research::KnapsackInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000704 (user): Refine Analysis of the model to choose better solvers.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LatticeMemoryManager Member \_internalref classoperations__research_1_1LatticeMemoryManager#af1eb6109d2fbc58a4f9709fc12472100 "<a class="el" href="classoperations__research_1_1LatticeMemoryManager.html#af1eb6109d2fbc58a4f9709fc12472100">operations_research::LatticeMemoryManager&lt; Set, CostType &gt;::BaseOffset</a>" (int card, Set s) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000596 (user): Investigate how to compute BaseOffset(card - 1, s \ { n })
from BaseOffset(card, n) to speed up the DP iteration. 
 &lt;p&gt; \anchor _todo000591 (user): Evaluate the interest of the above.
There are 'card' f(set, j) to store. That is why we need to multiply
local_offset by card before adding it to the corresponding base_offset_. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LightPairRelocateOperator Class \_internalref classoperations__research_1_1LightPairRelocateOperator "<a class="el" href="classoperations__research_1_1LightPairRelocateOperator.html">operations_research::LightPairRelocateOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000307 (user): Add a version which inserts the first node before the other
pair's first node; there are many redundant neighbors if done blindly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LightPairRelocateOperator Member \_internalref classoperations__research_1_1LightPairRelocateOperator#ab5a8f9eadcc60ebb142f301ad0206f45 "<a class="el" href="classoperations__research_1_1LightPairRelocateOperator.html#ab5a8f9eadcc60ebb142f301ad0206f45">operations_research::LightPairRelocateOperator::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000302 (user): extend to relocating before the start of sub-tours (when all
pairs have been matched). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LinearExpr Member \_internalref classoperations__research_1_1LinearExpr#ac387e7f248b39ad0c52ad355fa646696 "<a class="el" href="classoperations__research_1_1LinearExpr.html#ac387e7f248b39ad0c52ad355fa646696">operations_research::LinearExpr::ToString</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000707 (user): support optionally cropping long strings.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalCheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1LocalCheapestInsertionFilteredHeuristic#a9b1b23f0e8438c5bcae0eda914bf0a6c "<a class="el" href="classoperations__research_1_1LocalCheapestInsertionFilteredHeuristic.html#a9b1b23f0e8438c5bcae0eda914bf0a6c" title="Takes ownership of evaluator.">operations_research::LocalCheapestInsertionFilteredHeuristic::LocalCheapestInsertionFilteredHeuristic</a>" (RoutingModel *model, std::function&lt; bool()&gt; stop_search, std::function&lt; int64_t(int64_t, int64_t, int64_t)&gt; evaluator, RoutingSearchParameters::PairInsertionStrategy pair_insertion_strategy, LocalSearchFilterManager *filter_manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000323 (user): Add support for penalty costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalDimensionCumulOptimizer Member \_internalref classoperations__research_1_1LocalDimensionCumulOptimizer#a30f6536c9b12eb7d0c6bcba75c50b158 "<a class="el" href="classoperations__research_1_1LocalDimensionCumulOptimizer.html#a30f6536c9b12eb7d0c6bcba75c50b158" title="LocalDimensionCumulOptimizer.">operations_research::LocalDimensionCumulOptimizer::LocalDimensionCumulOptimizer</a>" (const RoutingDimension *dimension, RoutingSearchParameters::SchedulingSolver solver_type)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000293 (user): Instead of passing false, detect if the relaxation
will always violate the MIPL constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchFilter Member \_internalref classoperations__research_1_1LocalSearchFilter#a7ba0d3a0fab70da68c44fcc603b29bc9 "<a class="el" href="classoperations__research_1_1LocalSearchFilter.html#a7ba0d3a0fab70da68c44fcc603b29bc9">operations_research::LocalSearchFilter::Accept</a>" (const Assignment *delta, const Assignment *deltadelta, int64_t objective_min, int64_t objective_max)=0&lt;/dt&gt;&lt;dd&gt; \anchor _todo000130 (user): Remove arguments when there are no more need for those. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchFilterManager Member \_internalref classoperations__research_1_1LocalSearchFilterManager#af92bbf3b52fe1fceeab678de018ae63b "<a class="el" href="classoperations__research_1_1LocalSearchFilterManager.html#af92bbf3b52fe1fceeab678de018ae63b">operations_research::LocalSearchFilterManager::Accept</a>" (LocalSearchMonitor *const monitor, const Assignment *delta, const Assignment *deltadelta, int64_t objective_min, int64_t objective_max)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000196 (user): handle objective min.
 &lt;p&gt; \anchor _todo000195 (user): the behaviour of Accept relies on the initial order of
filters having at most one filter with negative objective values,
this could be fixed by having filters return their general bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchMonitor Member \_internalref classoperations__research_1_1LocalSearchMonitor#aa69f2ddc0e76eecc333aa6505f7d6a8e "<a class="el" href="classoperations__research_1_1LocalSearchMonitor.html#aa69f2ddc0e76eecc333aa6505f7d6a8e" title="-------‚Äî Local Search Monitor --------‚Äî">operations_research::LocalSearchMonitor::LocalSearchMonitor</a>" (Solver *const solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000131 (user): Add monitoring of local search filters.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchOperator Class \_internalref classoperations__research_1_1LocalSearchOperator "<a class="el" href="classoperations__research_1_1LocalSearchOperator.html">operations_research::LocalSearchOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000125 (user): rename Start to Synchronize ?
 &lt;p&gt; &lt;p&gt;(user): decouple the iterating from the defining of a neighbor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchState Member \_internalref classoperations__research_1_1LocalSearchState#ab21fa79fdab637a71137bfb392c3bc42 "<a class="el" href="classoperations__research_1_1LocalSearchState.html#ab21fa79fdab637a71137bfb392c3bc42">operations_research::LocalSearchState::Commit</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000194 (user): When the class has more users, find a threshold ratio of
saved/total variables under which a sparse clear would be more efficient
for both Commit() and Revert(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocationContainer Member \_internalref classoperations__research_1_1LocationContainer#ad936b94007fe596c6ac61668da043262 "<a class="el" href="classoperations__research_1_1LocationContainer.html#ad936b94007fe596c6ac61668da043262">operations_research::LocationContainer::SameLocationFromIndex</a>" (int64_t node1, int64_t node2) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000907 (user): Fetch proper indices from routing model. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakePairActiveOperator Class \_internalref classoperations__research_1_1MakePairActiveOperator "<a class="el" href="classoperations__research_1_1MakePairActiveOperator.html">operations_research::MakePairActiveOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000306 (user): Add option to prune neighbords where the order of node pairs
               is violated (ie precedence between pickup and delivery nodes).
 &lt;p&gt; &lt;p&gt;(user): Move this to local_search.cc if it's generic enough.
 &lt;p&gt; &lt;p&gt;(user): Detect pairs automatically by parsing the constraint model;
               we could then get rid of the pair API in the RoutingModel
               class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakeRelocateNeighborsOperator Class \_internalref classoperations__research_1_1MakeRelocateNeighborsOperator "<a class="el" href="classoperations__research_1_1MakeRelocateNeighborsOperator.html">operations_research::MakeRelocateNeighborsOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000304 (user): Consider merging with standard Relocate in local_search.cc. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#abd2e26542d0c64cb9bdb653e943cd892 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#abd2e26542d0c64cb9bdb653e943cd892">operations_research::math_opt::CheckIdsSubset</a>" (absl::Span&lt; const int64_t &gt; ids, const IdNameBiMap &amp;universe, std::optional&lt; int64_t &gt; upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000884 (b/232526223): try merge this with the CheckIdsSubset overload below, or
at least have one call the other. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GlpkSolver Member \_internalref classoperations__research_1_1math__opt_1_1GlpkSolver#ae0dd8a4b4d2f341b1300cf539b74bcda "<a class="el" href="classoperations__research_1_1math__opt_1_1GlpkSolver.html#ae0dd8a4b4d2f341b1300cf539b74bcda">operations_research::math_opt::GlpkSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000832 (b/187027049): glp_intopt with presolve off requires an optional
solution of the relaxed problem. Here we simply always enable pre-solve
but we should support disabling the presolve and call glp_simplex() in
that case. 
 &lt;p&gt; \anchor _todo000833 (b/259557110): the emptiness is tested by glp_interior() &lt;em&gt;after&lt;/em&gt;
some pre-processing (including removing fixed variables). The current
IsEmpty() is thus not good enough to deal with all cases. 
 &lt;p&gt; \anchor _todo000834 (b/187027049): add solver specific parameters for
glp_iptcp.ord_alg. 
 &lt;p&gt; \anchor _todo000835 (b/187027049): add option to use glp_exact().
 &lt;p&gt; \anchor _todo000836 (b/187027049): compute the dual value when the dual is feasible (or
problem optimal for interior point) based on the bounds and the dual values
for LPs. 
 &lt;p&gt; \anchor _todo000837 (b/200695800): add a parameter to enable the computation of the
rays. This involves matrices inversion so this is not free to compute and
should thus be only done when the user wants it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GScipSolver Member \_internalref classoperations__research_1_1math__opt_1_1GScipSolver#a91f57e875b852057eeaf6eeb837d1613 "<a class="el" href="classoperations__research_1_1math__opt_1_1GScipSolver.html#a91f57e875b852057eeaf6eeb837d1613">operations_research::math_opt::GScipSolver::Update</a>" (const ModelUpdateProto &amp;model_update) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000843 (b/215722113): maybe we could use SCIPaddCoefLinear() for sub-matrix 1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GScipSolverCallbackHandler Class \_internalref classoperations__research_1_1math__opt_1_1GScipSolverCallbackHandler "<a class="el" href="classoperations__research_1_1math__opt_1_1GScipSolverCallbackHandler.html">operations_research::math_opt::GScipSolverCallbackHandler</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000847 (b/193537362): see if we need to share code with the handling of
SolveInterrupter. It is likely that it could the case to make sure the
&lt;tt&gt;userinterrupt&lt;/tt&gt; flag is not lost. It may require sharing the same SCIP event
handler to make sure the user callback is called first; but maybe that is not
necessary. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GScipSolverCallbackHandler Member \_internalref classoperations__research_1_1math__opt_1_1GScipSolverCallbackHandler#aa6d054aae24f97d6ab394f72f3d56d68 "<a class="el" href="classoperations__research_1_1math__opt_1_1GScipSolverCallbackHandler.html#aa6d054aae24f97d6ab394f72f3d56d68">operations_research::math_opt::GScipSolverCallbackHandler::RegisterIfNeeded</a>" (const CallbackRegistrationProto &amp;callback_registration, SolverInterface::Callback callback, absl::Time solve_start, SCIP *scip)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000845 (b/180617976): Don't ignore unknown callbacks.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GurobiSolver Member \_internalref classoperations__research_1_1math__opt_1_1GurobiSolver#a26f4dd4213100e750b8253e394abf91a "<a class="el" href="classoperations__research_1_1math__opt_1_1GurobiSolver.html#a26f4dd4213100e750b8253e394abf91a">operations_research::math_opt::GurobiSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000862 (user): ensure that resetting parameters does not degrade
incrementalism performance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal Member \_internalref namespaceoperations__research_1_1math__opt_1_1internal#aa5b5865fba481a062135fc78e632b85c "<a class="el" href="namespaceoperations__research_1_1math__opt_1_1internal.html#aa5b5865fba481a062135fc78e632b85c">operations_research::math_opt::internal::CheckIdsRangeAndStrictlyIncreasing2</a>" (absl::Span&lt; const int64_t &gt; ids)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000807 (b/232526223): this is an exact copy of
CheckIdsRangeAndStrictlyIncreasing from ids_validator.h, find a way to share
the code.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::LinearExpression Class \_internalref classoperations__research_1_1math__opt_1_1LinearExpression "<a class="el" href="classoperations__research_1_1math__opt_1_1LinearExpression.html">operations_research::math_opt::LinearExpression</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000823 (b/169415098): add a function to remove zero terms.
 &lt;p&gt; &lt;p&gt;(b/169415834): study if exact zeros should be automatically removed.
 &lt;p&gt; &lt;p&gt;(b/169415103): add tests that some expressions don't compile. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a5d8c9048c51c1bc6685751a7cb8514fe "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a5d8c9048c51c1bc6685751a7cb8514fe">operations_research::math_opt::MathOptModelToMPModelProto</a>" (const ::operations_research::math_opt::ModelProto &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000825 (user): use the constraint iterator from scip_solver.cc here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#a06cd12d3df5d04b34fde1050692bc46a "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#a06cd12d3df5d04b34fde1050692bc46a">operations_research::math_opt::Model::storage</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000815 (user): expose a way to efficiently iterate through the nonzeros of
the linear constraint matrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#a737b42a14db864ac3afa891ecb212688 "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#a737b42a14db864ac3afa891ecb212688">operations_research::math_opt::Model::ValidateExistingLinearConstraintOfThisModel</a>" (LinearConstraint linear_constraint) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000814 (b/239810718): use &lt;&lt; for LinearConstraint once it does not CHECK.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#ae3a2f02a80238331fcdb90fc410682df "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#ae3a2f02a80238331fcdb90fc410682df" title="-----------------------‚Äî Linear constraints ----------------------------‚Äî">operations_research::math_opt::Model::ValidateExistingVariableOfThisModel</a>" (Variable variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000813 (b/239810718): use &lt;&lt; for Variable once it does not CHECK.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::ModelSolveParameters Member \_internalref structoperations__research_1_1math__opt_1_1ModelSolveParameters#a7f2865236a76bb6d14d3ac4accae433c "<a class="el" href="structoperations__research_1_1math__opt_1_1ModelSolveParameters.html#a7f2865236a76bb6d14d3ac4accae433c">operations_research::math_opt::ModelSolveParameters::Proto</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000816 (b/183616124): consolidate code. Probably best to add an
export_to_proto to IdMap 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::ModelSummary Class \_internalref structoperations__research_1_1math__opt_1_1ModelSummary "<a class="el" href="structoperations__research_1_1math__opt_1_1ModelSummary.html">operations_research::math_opt::ModelSummary</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000806 (b/232619901): In the guide for how to add new constraints, include how
this class must updated. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a529b5def5ea854858d5e3a6c094a0988 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const IndicatorConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000802 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af7ba8f15f41011f5b8109d7bef66511f "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const QuadraticConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000803 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a1a9e610368627bfdb61a92bc85274327 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Sos1Constraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000804 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af810f3a175629e517744c9f265470b61 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Sos2Constraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000805 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ae8f450a61d6f3613fa723a717c3cbca3 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Variable &amp;variable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000824 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a9019e3ceb6908ea58dee5e0ea0e627f9 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const QuadraticExpression &amp;expr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000822 (b/169415597): improve quadratic expression formatting. See b/170991498
for desired improvements for LinearExpression streaming which are also
applicable here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ab1d61842701172037b05e011df664d90 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const LinearExpression &amp;expression)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000821 (b/169415597): improve linear expression format:
 - make sure to quote the variable name so that we support: 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a99d303a9027f99623639c132198aa097 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const LinearConstraint &amp;linear_constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000810 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a0c5b0162f1414d908ad71eca691451b1 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Termination &amp;termination)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000818 (b/200835670): quote detail and escape it properly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::PdlpBridge Member \_internalref classoperations__research_1_1math__opt_1_1PdlpBridge#a5be3dbbc95b4b889956096613a822e40 "<a class="el" href="classoperations__research_1_1math__opt_1_1PdlpBridge.html#a5be3dbbc95b4b889956096613a822e40">operations_research::math_opt::PdlpBridge::PrimalVariablesToProto</a>" (const Eigen::VectorXd &amp;primal_values, const SparseVectorFilterProto &amp;variable_filter) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000863 (b/183616124): we need to support the inverse of these methods for
warm start. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::PdlpSolver Member \_internalref classoperations__research_1_1math__opt_1_1PdlpSolver#a7ae27d6f7ce1879c3babd8b8612b1a05 "<a class="el" href="classoperations__research_1_1math__opt_1_1PdlpSolver.html#a7ae27d6f7ce1879c3babd8b8612b1a05">operations_research::math_opt::PdlpSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000867 (b/183502493): Implement message callback when PDLP supports that.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a0f93e74fa1aa47b2dd62ed67f9ca4c1a "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a0f93e74fa1aa47b2dd62ed67f9ca4c1a">operations_research::math_opt::PrintTo</a>" (const Termination &amp;termination, std::ostream *os)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000811 (b/200835670): use the &lt;&lt; operator on Termination instead once it
 supports quoting/escaping on termination.detail. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Solver Member \_internalref classoperations__research_1_1math__opt_1_1Solver#aa9c5136714d04b0c012116a57d64585f "<a class="el" href="classoperations__research_1_1math__opt_1_1Solver.html#aa9c5136714d04b0c012116a57d64585f" title="Solves the current model (included all updates).">operations_research::math_opt::Solver::Solve</a>" (const SolveArgs &amp;arguments)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000808 (b/168037341): we should validate the result maths. Since the result
can be filtered, this should be included in the solver_interface
implementations. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SolveResult Member \_internalref structoperations__research_1_1math__opt_1_1SolveResult#af140dea39dec0ce602200f2d2b0cc2e9 "<a class="el" href="structoperations__research_1_1math__opt_1_1SolveResult.html#af140dea39dec0ce602200f2d2b0cc2e9">operations_research::math_opt::SolveResult::Proto</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000820 (b/231134639): investigate removing the oneof from the proto. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SolveResultMatcherOptions Member \_internalref structoperations__research_1_1math__opt_1_1SolveResultMatcherOptions#ae41b54030c8d6d4345348e188263eb7b "<a class="el" href="structoperations__research_1_1math__opt_1_1SolveResultMatcherOptions.html#ae41b54030c8d6d4345348e188263eb7b">operations_research::math_opt::SolveResultMatcherOptions::check_solutions_if_inf_or_unbounded</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000812 (b/201099290): this is perhaps not a good default. Gurobi as
 implemented is returning primal solutions for both unbounded and
 infeasible problems. We need to add unit tests that inspect this value
 and turn them on one solver at a time with a new parameter on
 SimpleLpTestParameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SolveStats Member \_internalref structoperations__research_1_1math__opt_1_1SolveStats#a6da9f711f67f11cd89544224f90c5579 "<a class="el" href="structoperations__research_1_1math__opt_1_1SolveStats.html#a6da9f711f67f11cd89544224f90c5579">operations_research::math_opt::SolveStats::best_primal_bound</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000819 (b/195295177): Update to add clearer contracts once PDLP's bounds
contract is clarified. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a1ef6c0a7d0962256e329df83b34a3668 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a1ef6c0a7d0962256e329df83b34a3668">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::column</a>" (ColumnId column_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000880 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a5b93353672b48d531e16f26eeb6c1238 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a5b93353672b48d531e16f26eeb6c1238">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::ColumnTerms</a>" (ColumnId col_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000882 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a35c2edd872d547e250e828a62e65ce71 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a35c2edd872d547e250e828a62e65ce71">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::row</a>" (RowId row_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000879 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#af45684890602a0abd734552aef5b53eb "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#af45684890602a0abd734552aef5b53eb">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::RowTerms</a>" (RowId row_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000881 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a6aca40055cfa8c9e5767ce467f5c89ae "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a6aca40055cfa8c9e5767ce467f5c89ae">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::Terms</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000883 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a346f0dd1bc945b8a3f6acce2f868b0f3 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a346f0dd1bc945b8a3f6acce2f868b0f3">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::Update</a>" (const absl::flat_hash_set&lt; RowId &gt; &amp;deleted_rows, absl::Span&lt; const RowId &gt; new_rows, const absl::flat_hash_set&lt; ColumnId &gt; &amp;deleted_columns, absl::Span&lt; const ColumnId &gt; new_columns, const absl::flat_hash_set&lt; std::pair&lt; RowId, ColumnId &gt; &gt; &amp;dirty) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000872 (b/233630053): use iterator API.
 &lt;p&gt; \anchor _todo000873 (b/233630053) use iterator API.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#ae7fd3ba62ed1002264117fa864e7144f "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#ae7fd3ba62ed1002264117fa864e7144f">operations_research::math_opt::SparseSymmetricMatrix::Proto</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000870 (b/233630053): reuse the allocation once an iterator API is
supported. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a43ee2fbaa504f90f7690b0bf87861c97 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a43ee2fbaa504f90f7690b0bf87861c97">operations_research::math_opt::SparseSymmetricMatrix::RelatedVariables</a>" (VariableId variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000875 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a4568f0449320e9203ed9969bad5d26dd "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a5daadc06a91ff1edeb4871b1801b84f9">operations_research::math_opt::SparseSymmetricMatrix::Terms</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000877 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a5daadc06a91ff1edeb4871b1801b84f9 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a5daadc06a91ff1edeb4871b1801b84f9">operations_research::math_opt::SparseSymmetricMatrix::Terms</a>" (VariableId variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000876 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a007fc8188b348177988fb88dffe12f3f "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a007fc8188b348177988fb88dffe12f3f">operations_research::math_opt::SparseSymmetricMatrix::Update</a>" (const absl::flat_hash_set&lt; VariableId &gt; &amp;deleted_variables, absl::Span&lt; const VariableId &gt; new_variables, const absl::flat_hash_set&lt; std::pair&lt; VariableId, VariableId &gt; &gt; &amp;dirty) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000871 (b/233630053): do not allocate here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a6297413386fb1ed24d1a6087c3f900cb "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a6297413386fb1ed24d1a6087c3f900cb">operations_research::math_opt::SparseSymmetricMatrix::values</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000878 (b/233630053): do not expose values_ directly, instead offer a way to
iterate over all the nonzero entries.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a89e72a700578de83bbd4eb42102bdc7a "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a89e72a700578de83bbd4eb42102bdc7a">operations_research::math_opt::SparseSymmetricMatrix::Variables</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000874 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#aa782b35203234b683975688b30f3110f "<a class="el" href="namespaceoperations__research_1_1math__opt.html#aa782b35203234b683975688b30f3110f">operations_research::math_opt::ValidateSolution</a>" (const SolutionProto &amp;solution, const ModelSolveParametersProto &amp;parameters, const ModelSummary &amp;model_summary)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000887 (b/204457524): consider checking equality of statuses for single-sided
LPs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af099801286ce760f79dda3ce9b7be78d "<a class="el" href="namespaceoperations__research_1_1math__opt.html#af099801286ce760f79dda3ce9b7be78d">operations_research::math_opt::ValidateSolveParameters</a>" (const SolveParametersProto &amp;parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000889 (b/213697045): some parameters are still not validated.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a2e7baa28b18e97ddd47c264de703a0be "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a2e7baa28b18e97ddd47c264de703a0be">operations_research::math_opt::ValidateTerminationConsistency</a>" (const SolveResultProto &amp;result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000885 (b/211679884): update when imprecise solutions are added.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MaxFlow Class \_internalref classoperations__research_1_1MaxFlow "<a class="el" href="classoperations__research_1_1MaxFlow.html">operations_research::MaxFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000615 (user): Modify this code and remove it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a6f94ee8ea8298d25de3607ed56d2d94e "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a6f94ee8ea8298d25de3607ed56d2d94e">operations_research::MinCostPerfectMatching::AddEdgeWithCost</a>" (int tail, int head, int64_t cost)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000655 (user): We could just presolve them away. 
 &lt;p&gt; \anchor _todo000654 (user): We can easily shift all costs if negative costs are needed.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a4d798c6f197b745924e4e0ca184c3642 "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a4d798c6f197b745924e4e0ca184c3642">operations_research::MinCostPerfectMatching::MinCostPerfectMatching</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000652 (user): For now we ask the number of nodes at construction, but we
could automatically infer it from the added edges if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a5f89c8890f72a582d15baf027b9cfeb9 "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a5f89c8890f72a582d15baf027b9cfeb9">operations_research::MinCostPerfectMatching::Reset</a>" (int num_nodes)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000653 (user): Eventually, we may support incremental Solves(). Or at least
memory reuse if one wants to solve many problems in a row. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#acce484fd341b33e5c371f0a1046821ed "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#acce484fd341b33e5c371f0a1046821ed">operations_research::MinCostPerfectMatching::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000633 (user): Improve the overflow detection if needed. The current one seems
ok though. 
 &lt;p&gt; \anchor _todo000634 (user): Maybe there is a faster/better way to recover the mapping
in the presence of blossoms. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ModelSolverHelper Member \_internalref classoperations__research_1_1ModelSolverHelper#a0a3942146394eec75729ef0d79319237 "<a class="el" href="classoperations__research_1_1ModelSolverHelper.html#a0a3942146394eec75729ef0d79319237">operations_research::ModelSolverHelper::Solve</a>" (const ModelBuilderHelper &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000750 (user): Enable interrupt_solve. 
 &lt;p&gt; \anchor _todo000749 &lt;p&gt; \anchor _todo000748 (user): Enable log_callback support.
&lt;p&gt; \anchor _todo000747 (user): Enable log_callback support.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a84aec4c6ee3b17edc9979b12ecdb5f63 "<a class="el" href="classoperations__research_1_1MPSolver.html#a84aec4c6ee3b17edc9979b12ecdb5f63">operations_research::MPSolver::ComputeConstraintActivities</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000714 (user): test this failure case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a9c8cc8b3c36fe9c08d8e0eefbc98b774 "<a class="el" href="classoperations__research_1_1MPSolver.html#a9c8cc8b3c36fe9c08d8e0eefbc98b774" title="Exports model to protocol buffer.">operations_research::MPSolver::ExportModelToProto</a>" (MPModelProto *output_model) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000711 (user): remove this step. 
 &lt;p&gt; \anchor _todo000710 (user): Add option to avoid filling the var name to avoid overly
large protocol buffers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#aae2800c3df9ebf5f1e3c21cd5af3c9a9 "<a class="el" href="classoperations__research_1_1MPSolver.html#aae2800c3df9ebf5f1e3c21cd5af3c9a9">operations_research::MPSolver::LoadSolutionFromProto</a>" (const MPSolutionResponse &amp;response, double tolerance=std::numeric_limits&lt; double &gt;::infinity())&lt;/dt&gt;&lt;dd&gt; \anchor _todo000712 (user): Use parameter when they become available in this class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a9f2efb3304b325430e46e848574d63e5 "<a class="el" href="classoperations__research_1_1MPSolver.html#a18aef4e4cdea4ee15ce472d3b5f57962" title="Solves the problem using the default parameter values.">operations_research::MPSolver::Solve</a>" (const MPSolverParameters &amp;param)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000713 (user): replace this by model extraction to proto + proto validation
(the proto has very low overhead compared to the wrapper, both in
performance and memory, so it's ok). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a2a4a0234b5830d4ea82d549b3b6b5baf "<a class="el" href="classoperations__research_1_1MPSolver.html#a2a4a0234b5830d4ea82d549b3b6b5baf">operations_research::MPSolver::VerifySolution</a>" (double tolerance, bool log_errors) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000715 (user): split.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#a152b3f16428c0a1c58247ba88d95f0a4 "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#a152b3f16428c0a1c58247ba88d95f0a4">operations_research::MPSolverInterface::MPSolverInterface</a>" (MPSolver *const solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000716 (user): Initialize objective value and bound to +/- inf (depending on
optimization direction). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#a3fd73560f782eaf5093a435c61783d09 "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#a3fd73560f782eaf5093a435c61783d09" title="Resets the extraction information.">operations_research::MPSolverInterface::ResetExtractionInformation</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000717 (user): remove this method.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#ad237855fa79fc36fbf9baedce589384c "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#ad237855fa79fc36fbf9baedce589384c" title="Sets parameters common to LP and MIP in the underlying solver.">operations_research::MPSolverInterface::SetCommonParameters</a>" (const MPSolverParameters &amp;param)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000719 (user): In the future, we could distinguish between the
algorithm to solve the root LP and the algorithm to solve node
LPs. Not sure if underlying solvers support it. 
 &lt;p&gt; \anchor _todo000718 (user): Overhaul the code that sets parameters to enable changing
GLOP parameters without issuing warnings.
By default, we let GLOP keep its own default tolerance, much more accurate
than for the rest of the solvers.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::NearestNeighbors Member \_internalref classoperations__research_1_1NearestNeighbors#af61cd5ece87302a1054745def342cf71 "<a class="el" href="classoperations__research_1_1NearestNeighbors.html#af61cd5ece87302a1054745def342cf71">operations_research::NearestNeighbors::Initialize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000191 (user): recompute if node changes path ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::OptimizeVar Class \_internalref classoperations__research_1_1OptimizeVar "<a class="el" href="classoperations__research_1_1OptimizeVar.html">operations_research::OptimizeVar</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000103 (user): Refactor this into an Objective class:
  - print methods for AtNode and AtSolution.
  - support for weighted objective and lexicographical objective. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::OptimizeVar Member \_internalref classoperations__research_1_1OptimizeVar#ab25c4a1c9365c926d2459c700460802d "<a class="el" href="classoperations__research_1_1OptimizeVar.html#ab25c4a1c9365c926d2459c700460802d" title="-------‚Äî Objective Management -------‚Äî">operations_research::OptimizeVar::OptimizeVar</a>" (Solver *const s, bool maximize, IntVar *const a, int64_t step)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000342 (user): Store optimization direction in Solver. Besides making the
code simpler it would also having two monitors optimizing in opposite
directions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Pack Member \_internalref classoperations__research_1_1Pack#af13898c8553d217fa3d52c6e2b504f8d "<a class="el" href="classoperations__research_1_1Pack.html#af13898c8553d217fa3d52c6e2b504f8d">operations_research::Pack::OneDomain</a>" (int var_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000210 (user): We know var ranges from 0 to bins_. There are lots
of simplifications possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathLns Member \_internalref classoperations__research_1_1PathLns#a869e1cdf41f26c362721696997202bf7 "<a class="el" href="classoperations__research_1_1PathLns.html#a869e1cdf41f26c362721696997202bf7">operations_research::PathLns::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000192 (user): make this more efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#adbd9065c5b91dde20b8f4c0759233971 "<a class="el" href="classoperations__research_1_1PathOperator.html#adbd9065c5b91dde20b8f4c0759233971">operations_research::PathOperator::OnSamePathAsPreviousBase</a>" (int64_t base_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000129 (user): ideally this should be OnSamePath(int64_t node1, int64_t
node2);
it's currently way more complicated to implement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#a6580d6cdf003656019a25f7e9f2d8496 "<a class="el" href="classoperations__research_1_1PathOperator.html#a6580d6cdf003656019a25f7e9f2d8496">operations_research::PathOperator::RestartAtPathStartOnSynchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000128 (user): remove this when automatic detection of such cases in done. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#a13fc3f3cb8f8de7198d1b16338df06ad "<a class="el" href="classoperations__research_1_1PathOperator.html#a13fc3f3cb8f8de7198d1b16338df06ad">operations_research::PathOperator::SkipUnchanged</a>" (int index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000127 (user): Make the following methods protected.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a7bd16384c5572b001a57e9987bf5b0e9 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a7bd16384c5572b001a57e9987bf5b0e9" title="Finds an approximately optimal scaling factor for the solution of the trust region subproblem,...">operations_research::pdlp::FindScalingFactor</a>" (const DiagonalTrustRegionProblem &amp;problem, const Sharder &amp;sharder, const double target_radius, const double solve_tol)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000905 (user): figure out what accuracy is useful to callers and redo the
stopping criterion accordingly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp::internal Member \_internalref namespaceoperations__research_1_1pdlp_1_1internal#a0d1a488cd88b2db320196184c8a60713 "<a class="el" href="namespaceoperations__research_1_1pdlp_1_1internal.html#a0d1a488cd88b2db320196184c8a60713">operations_research::pdlp::internal::ComputeInitialUndecidedComponents</a>" (const TrustRegionProblem &amp;problem, int64_t start_index, int64_t end_index, std::vector&lt; int64_t &gt; &amp;undecided_components)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000906 (user): Evaluate dropping this reserve(), since it wastes space
if many components are decided. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a80b7dc41ed788020cbaf942674f623d9 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a80b7dc41ed788020cbaf942674f623d9">operations_research::pdlp::ReadQuadraticProgramOrDie</a>" (const std::string &amp;filename, bool include_names)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000901 (user): Update internal helper functions to use references instead of
pointers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp::ShardedWeightedAverage Member \_internalref classoperations__research_1_1pdlp_1_1ShardedWeightedAverage#a832ecd48fecace426aeb1c32f0322fbb "<a class="el" href="classoperations__research_1_1pdlp_1_1ShardedWeightedAverage.html#a832ecd48fecace426aeb1c32f0322fbb">operations_research::pdlp::ShardedWeightedAverage::ComputeAverage</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000902 (user): consider returning a reference to avoid this copy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#aeba91f0ed5437b1264431fc6562ff094 "<a class="el" href="classoperations__research_1_1PdlpInterface.html#aeba91f0ed5437b1264431fc6562ff094" title="Returns the basis status of a constraint.">operations_research::PdlpInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000726 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#aecba606519ca8ae9dfb6493a4653cbfc "<a class="el" href="classoperations__research_1_1PdlpInterface.html#aecba606519ca8ae9dfb6493a4653cbfc" title="Returns the basis status of a row.">operations_research::PdlpInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000725 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#a22fcf7b9b53475d97d46e1eb057d1b87 "<a class="el" href="classoperations__research_1_1PdlpInterface.html#a22fcf7b9b53475d97d46e1eb057d1b87">operations_research::PdlpInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000727 (user): Consider returning the SolveLog here, as it could be essential
for interpreting the PDLP solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PiecewiseLinearExpr Member \_internalref classoperations__research_1_1PiecewiseLinearExpr#a29f2fd207e34ba398b1b772d21852f33 "<a class="el" href="classoperations__research_1_1PiecewiseLinearExpr.html#a29f2fd207e34ba398b1b772d21852f33" title="Accepts the given visitor.">operations_research::PiecewiseLinearExpr::Accept</a>" (ModelVisitor *const visitor) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000174 (user): Implement visitor.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PiecewiseLinearFunction Member \_internalref classoperations__research_1_1PiecewiseLinearFunction#adb77fb211d172324d3d02e974af56c5b "<a class="el" href="classoperations__research_1_1PiecewiseLinearFunction.html#adb77fb211d172324d3d02e974af56c5b" title="Returns the value of the piecewise linear function for x.">operations_research::PiecewiseLinearFunction::Value</a>" (int64_t x) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002133 (user): Allow the user to specify the
undefined value and use kint64max as the default. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PruningHamiltonianSolver Member \_internalref classoperations__research_1_1PruningHamiltonianSolver#aee868e1ea38d845f3da2cb0d38ad6d3f "<a class="el" href="classoperations__research_1_1PruningHamiltonianSolver.html#aee868e1ea38d845f3da2cb0d38ad6d3f">operations_research::PruningHamiltonianSolver&lt; CostType, CostFunction &gt;::Integer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000599 (user): Use generic map-based cache instead of lattice-based one.
 &lt;p&gt; &lt;p&gt;(user): Use SaturatedArithmetic for better precision. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Queue Member \_internalref classoperations__research_1_1Queue#a014c7261e4c1b40cd8d81d22e22c3e94 "<a class="el" href="classoperations__research_1_1Queue.html#a014c7261e4c1b40cd8d81d22e22c3e94">operations_research::Queue::ProcessConstraints</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000101 (user): Make to_add_ a queue to make the behavior more obvious. 
 &lt;p&gt; \anchor _todo000102 (user): Add profiling to initial propagation
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RangeIntToIntFunction Member \_internalref classoperations__research_1_1RangeIntToIntFunction#a95dc968eea4874e0099cc74f38bd4aca "<a class="el" href="classoperations__research_1_1RangeIntToIntFunction.html#a95dc968eea4874e0099cc74f38bd4aca">operations_research::RangeIntToIntFunction::Query</a>" (int64_t argument) const =0&lt;/dt&gt;&lt;dd&gt; \anchor _todo002135 (user): Rename to Run 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a9dc92cf61d5051e6ec16fa5dc7e371ae "<a class="el" href="namespaceoperations__research.html#a9dc92cf61d5051e6ec16fa5dc7e371ae">operations_research::RationalApproximation</a>" (const double x, const double precision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002136 (user): make a parameterized template with integer and floating-point
type parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a69a780b033f05ccd016fa3ce547f90f5 "<a class="el" href="namespaceoperations__research.html#a69a780b033f05ccd016fa3ce547f90f5">operations_research::ReadQapProblemOrDie</a>" (const std::string &amp;filepath)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002134 (user): Unit test cases when the function dies, or return
(and test) a status instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RelocateAndMakeActiveOperator Class \_internalref classoperations__research_1_1RelocateAndMakeActiveOperator "<a class="el" href="classoperations__research_1_1RelocateAndMakeActiveOperator.html" title="-‚Äî RelocateAndMakeActiveOperator --‚Äî">operations_research::RelocateAndMakeActiveOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000190 (user): Naming is close to MakeActiveAndRelocate but this one is
correct; rename MakeActiveAndRelocate if it is actually used. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RevBitMatrix Member \_internalref classoperations__research_1_1RevBitMatrix#ae2bcb32bc27553f598733168bbc46fd2 "<a class="el" href="classoperations__research_1_1RevBitMatrix.html#ae2bcb32bc27553f598733168bbc46fd2" title="Does the &#39;row&#39; bitset contains only one bit set?">operations_research::RevBitMatrix::IsCardinalityOne</a>" (int row) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000354 (user) : Optimize this one.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RevVector Member \_internalref classoperations__research_1_1RevVector#a576b88e9d92029753f73f012e2b57599 "<a class="el" href="classoperations__research_1_1RevVector.html#a576b88e9d92029753f73f012e2b57599">operations_research::RevVector&lt; IndexType, T &gt;::MutableRef</a>" (IndexType index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002138 (user): Maybe we could have also used the [] operator, but it is harder
to be 100% sure that the mutable version is only called when we modify
the vector. And I had performance bug because of that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingFilteredHeuristic Member \_internalref classoperations__research_1_1RoutingFilteredHeuristic#a9204fb248465631cfa566b47d30b19dd "<a class="el" href="classoperations__research_1_1RoutingFilteredHeuristic.html#a9204fb248465631cfa566b47d30b19dd" title="Builds a solution starting from the routes formed by the next accessor.">operations_research::RoutingFilteredHeuristic::BuildSolutionFromRoutes</a>" (const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000317 (user): Add vehicle values to delta when this method will be
used with cost filtering. The code should be similar to this:
if (HasSecondaryVars()) {
  SetValue(SecondaryVarIndex(node), v);
} 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingGlopWrapper Member \_internalref classoperations__research_1_1RoutingGlopWrapper#a6e9afdf1ffb0dba256ae65a29dcc3e64 "<a class="el" href="classoperations__research_1_1RoutingGlopWrapper.html#a6e9afdf1ffb0dba256ae65a29dcc3e64">operations_research::RoutingGlopWrapper::PrintModel</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000301 (user): Improve output readability. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingGlopWrapper Member \_internalref classoperations__research_1_1RoutingGlopWrapper#ae230124d932c4d9f0da5d5b9538b88ba "<a class="el" href="classoperations__research_1_1RoutingGlopWrapper.html#ae230124d932c4d9f0da5d5b9538b88ba">operations_research::RoutingGlopWrapper::SetVariableDisjointBounds</a>" (int index, const std::vector&lt; int64_t &gt; &amp;starts, const std::vector&lt; int64_t &gt; &amp;ends) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000300 (user): Investigate if we can avoid rebuilding the interval list
each time (we could keep a reference to the forbidden interval list in
RoutingDimension but we would need to store cumul offsets and use them
when checking intervals). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingIndexManager Member \_internalref classoperations__research_1_1RoutingIndexManager#a148a071cb5a92fe73501c7c299ed5eb1 "<a class="el" href="classoperations__research_1_1RoutingIndexManager.html#a148a071cb5a92fe73501c7c299ed5eb1">operations_research::RoutingIndexManager::num_unique_depots</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000292 (user) Add unit tests for NodesToIndices and IndicesToNodes.
 &lt;p&gt; &lt;p&gt;(user): Remove when removal of NodeIndex from RoutingModel is
complete. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingModelInspector Member \_internalref classoperations__research_1_1RoutingModelInspector#a84dbe032f5cce5e2e3acc042382b1f85 "<a class="el" href="classoperations__research_1_1RoutingModelInspector.html#a84dbe032f5cce5e2e3acc042382b1f85">operations_research::RoutingModelInspector::EndVisitModel</a>" (const std::string &amp;) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000262 (user): Perform transitive closure of dimension precedence graphs.
&lt;p&gt; \anchor _todo000263 &lt;p&gt; \anchor _todo000264 (user): Have a single annotated precedence graph. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aac65f6cb5816150efa463314f16ee1cd "<a class="el" href="namespaceoperations__research.html#aac65f6cb5816150efa463314f16ee1cd">operations_research::RunSeparation</a>" (internal::ScipCallbackRunner *runner, const ScipConstraintHandlerContext &amp;context, absl::Span&lt; SCIP_CONS * &gt; constraints, bool is_integral)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000740 (user): when infeasible is true, it better to have the scip
return status be cutoff instead of cutting plane added (e.g. see
cs/scip/src/scip/cons_knapsack.c). However, as we use
SCIPaddRow(), it isn't clear this will even happen. 
 &lt;p&gt; \anchor _todo000741 (user): Maybe it is better to expose more of these options,
potentially through user_suggested_constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Class \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">operations_research::sat::ActivityBoundHelper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001846 (user): Use better algorithm. The problem is the same as finding upper
bound to the classic problem: maximum-independent set in a graph. We also
only use at most ones, but we could use the more general binary implication
graph. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#a0597d8e2ff729931de6b9e1e7df34298 "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#a0597d8e2ff729931de6b9e1e7df34298">operations_research::sat::ActivityBoundHelper::AddAllAtMostOnes</a>" (const CpModelProto &amp;proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001841 (user): Add long ones first, or at least the ones of size 2 after.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#a7569741972c7325665407db889dc36af "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#a7569741972c7325665407db889dc36af">operations_research::sat::ActivityBoundHelper::ComputeMaxActivity</a>" (absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; terms, std::vector&lt; std::array&lt; int64_t, 2 &gt; &gt; *conditional=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001849 (user): Indicate when the bounds are trivial (i.e. not intersection
with any amo) so that we don't waste more time processing the result? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#ad71179e60a9659f4899d68ad8472b679 "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#ad71179e60a9659f4899d68ad8472b679">operations_research::sat::ActivityBoundHelper::PresolveEnforcement</a>" (absl::Span&lt; const int &gt; refs, ConstraintProto *ct, absl::flat_hash_set&lt; int &gt; *literals_at_true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001843 (user): Ideally these amo should not be added to this class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a6f5d90e7de4e0877e0abff9cb2467bdd "<a class="el" href="namespaceoperations__research_1_1sat.html#a6f5d90e7de4e0877e0abff9cb2467bdd">operations_research::sat::AddDisjunctiveWithBooleanPrecedencesOnly</a>" (const std::vector&lt; IntervalVariable &gt; &amp;intervals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001396 (user): Cache boolean_var.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#abf0e8ef0b1ad01ad3a9aae0a009e5f13 "<a class="el" href="namespaceoperations__research_1_1sat.html#abf0e8ef0b1ad01ad3a9aae0a009e5f13">operations_research::sat::AddLinMaxCutGenerator</a>" (const ConstraintProto &amp;ct, Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001689 (user): Move this out of here.&lt;p&gt; \anchor _todo001688 (user): Support linearization of general target expression.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AffineExpression Member \_internalref structoperations__research_1_1sat_1_1AffineExpression#ae2df741604041f566520f58d28482eef "<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html#ae2df741604041f566520f58d28482eef">operations_research::sat::AffineExpression::var</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001482 (user): Make this private to enforce the invariant that coeff cannot be
negative. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentBoundsPropagator Class \_internalref classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator.html">operations_research::sat::AllDifferentBoundsPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000917 (user): It might be difficult to find something faster than what is
implemented here. Some related reference:
https://cs.uwaterloo.ca/~vanbeek/Publications/ijcai03_TR.pdf 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentBoundsPropagator Member \_internalref classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator#abcd3b5d1133bde855025a642745ca3b6 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator.html#abcd3b5d1133bde855025a642745ca3b6">operations_research::sat::AllDifferentBoundsPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000916 (user): investigate the impact. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentConstraint Member \_internalref classoperations__research_1_1sat_1_1AllDifferentConstraint#a59e041a85cd31545fe5d7e0e3907d3a4 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html#a59e041a85cd31545fe5d7e0e3907d3a4">operations_research::sat::AllDifferentConstraint::AllDifferentConstraint</a>" (std::vector&lt; IntegerVariable &gt; variables, IntegerEncoder *encoder, Trail *trail, IntegerTrail *integer_trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000914 (user): Prune now, ignore these variables during solving. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentConstraint Member \_internalref classoperations__research_1_1sat_1_1AllDifferentConstraint#a1adb3a2f02ebc277b22879cd01e994b2 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html#a1adb3a2f02ebc277b22879cd01e994b2">operations_research::sat::AllDifferentConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000915 (user): If needed, there are several ways performance could be
improved.
If copying the variable state is too costly, it could be maintained instead.
If the propagator has too many fruitless calls (without failing/pruning),
we can remember the O(n) arcs used in the matching and the SCC decomposition,
and guard calls to Propagate() if these arcs are still valid. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afc1129274beafb17b41ac2fa278de60c "<a class="el" href="namespaceoperations__research_1_1sat.html#afc1129274beafb17b41ac2fa278de60c">operations_research::sat::AllValuesInDomain</a>" (const ProtoWithDomain &amp;proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001333 (user): work directly on the Domain class instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9dc02c27e1c588a0e3e7a0ebd60c386b "<a class="el" href="namespaceoperations__research_1_1sat.html#a9dc02c27e1c588a0e3e7a0ebd60c386b">operations_research::sat::AnalyzeIntervals</a>" (bool transpose, absl::Span&lt; const int &gt; local_boxes, const std::vector&lt; Rectangle &gt; &amp;rectangles, const std::vector&lt; IntegerValue &gt; &amp;rectangle_energies, IntegerValue *x_threshold, IntegerValue *y_threshold, Rectangle *conflict)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001392 (user): If the number of unique x_max is smaller than the number of
unique x_min, it is better to do it the other way around. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac506719ca656893d93a2a6c940999265 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac506719ca656893d93a2a6c940999265">operations_research::sat::AppendBoolAndRelaxation</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *activity_helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001676 (user): These constraints can be many, and if they are not regrouped
in big at most ones, then they should probably only added lazily as cuts.
Regroup this with future clique-cut separation logic.&lt;p&gt; \anchor _todo001677 (user): More generally, do not miss the same structure if the bool_and
was expanded into many clauses!&lt;p&gt; \anchor _todo001678 (user): It is not 100% clear that just not adding one constraint is
worse. Relaxation is worse, but then we have less constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a99c02b5f23ff755783f84c851f8dcbb2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a99c02b5f23ff755783f84c851f8dcbb2">operations_research::sat::AppendElementEncodingRelaxation</a>" (Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001690 (user): We can do something similar with just an at most one, however
it is harder to detect that if all literal are false then none of the implied
value can be taken. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a42d3ac4927f1adbca821091239fc06c7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a42d3ac4927f1adbca821091239fc06c7">operations_research::sat::AppendLinearConstraintRelaxation</a>" (const ConstraintProto &amp;ct, bool linearize_enforced_constraints, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *activity_helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001684 (user): process the "at most one" part of a == 1 separately? 
 &lt;p&gt; \anchor _todo001683 (user): In LoadLinearConstraint() we already created intermediate
Booleans for each disjoint interval, we should reuse them here if
possible.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a87160f650c0f35013f055fb81b3dfd30 "<a class="el" href="namespaceoperations__research_1_1sat.html#a87160f650c0f35013f055fb81b3dfd30">operations_research::sat::AppendLinMaxRelaxationPart1</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001695 (user): Support linear expression as target. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aab775ea3151335d5d07e4071e38a4687 "<a class="el" href="namespaceoperations__research_1_1sat.html#aab775ea3151335d5d07e4071e38a4687">operations_research::sat::AppendLinMaxRelaxationPart2</a>" (IntegerVariable target, const std::vector&lt; Literal &gt; &amp;alternative_literals, const std::vector&lt; LinearExpression &gt; &amp;exprs, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001682 (user): Remove hash_map ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9d126152f7618c43746d3f56577b803e "<a class="el" href="namespaceoperations__research_1_1sat.html#a9d126152f7618c43746d3f56577b803e">operations_research::sat::AppendMaxAffineRelaxation</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001681 (user): experiment with:
  1) remove this code
  2) keep this code
  3) remove this code and create the cut generator at level 1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af8a1aaff5bb36f1dfaf3daea8d5a076e "<a class="el" href="namespaceoperations__research_1_1sat.html#af8a1aaff5bb36f1dfaf3daea8d5a076e">operations_research::sat::AppendRelaxationForEqualityEncoding</a>" (IntegerVariable var, const Model &amp;model, LinearRelaxation *relaxation, int *num_tight, int *num_loose)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001675 (user): PartialDomainEncoding() filter pair corresponding to literal
set to false, however the initial variable Domain is not always updated. As
a result, these min/max can be larger than in reality. Try to fix this even
if in practice this is a rare occurrence, as the presolve should have
propagated most of what we can. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#abd42a035a99f910066d0a0356eff9ed6 "<a class="el" href="namespaceoperations__research_1_1sat.html#abd42a035a99f910066d0a0356eff9ed6">operations_research::sat::AppendSquareRelaxation</a>" (const ConstraintProto &amp;ct, Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001687 (user): We could add all or some below_hyperplans.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab3f18aece2e354382532b24b02e0ca81 "<a class="el" href="namespaceoperations__research_1_1sat.html#ab3f18aece2e354382532b24b02e0ca81">operations_research::sat::ApplyLiteralMappingToBooleanProblem</a>" (const absl::StrongVector&lt; LiteralIndex, LiteralIndex &gt; &amp;mapping, LinearBooleanProblem *problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000925 (user): The names is currently all scrambled. Do something about it
so that non-fixed variables keep their names. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AssignmentInfo Member \_internalref structoperations__research_1_1sat_1_1AssignmentInfo#a2c118b72a43ea721d8c724184e7c54f6 "<a class="el" href="structoperations__research_1_1sat_1_1AssignmentInfo.html#a2c118b72a43ea721d8c724184e7c54f6">operations_research::sat::AssignmentInfo::level</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001880 (user): We may be able to get rid of that for faster enqueues. Most of
the code only need to know if this is 0 or the highest level, and for the
LBD computation, the literal of the conflict are already ordered by level,
so we could do it fairly efficiently.&lt;p&gt; \anchor _todo001881 (user): We currently don't support more than 2^28 decision levels. That
should be enough for most practical problem, but we should fail properly if
this limit is reached. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BasicKnapsackSolver Member \_internalref classoperations__research_1_1sat_1_1BasicKnapsackSolver#abf8b154951fbb851e98a619ff969b0ef "<a class="el" href="classoperations__research_1_1sat_1_1BasicKnapsackSolver.html#abf8b154951fbb851e98a619ff969b0ef">operations_research::sat::BasicKnapsackSolver::Solve</a>" (const std::vector&lt; Domain &gt; &amp;domains, const std::vector&lt; int64_t &gt; &amp;coeffs, const std::vector&lt; int64_t &gt; &amp;costs, const Domain &amp;rhs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002084 (user): We can also solve efficiently if max_activity - rhs.Min() is
small. Implement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5ebd9f654e3e5e98112a61e92e5df9e9 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5ebd9f654e3e5e98112a61e92e5df9e9">operations_research::sat::BasicOrbitopeExtraction</a>" (const std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; &amp;generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002047 (user): Detect more than one orbitope? Note that once detected, the
structure can be exploited efficiently, but for now, a more "generic"
algorithm based on stabilizator should achieve the same preprocessing power,
so I don't know how hard we need to invest in orbitope detection.&lt;p&gt; \anchor _todo002046 (user): We could grow each and keep the real maximum. 
 &lt;p&gt; \anchor _todo002048 (user): The heuristic is quite limited for now, but this works on
graph20-20-1rand.mps.gz. I suspect the generators provided by the detection
code follow our preconditions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Class \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">operations_research::sat::BinaryImplicationGraph</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000961 (user): Most of the note below are done, but we currently only applies
the reduction before the solve. We should consider doing more in-processing.
The code could probably still be improved too.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ae18864358e7e3f0d4c9c7cf81e3757de "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ae18864358e7e3f0d4c9c7cf81e3757de">operations_research::sat::BinaryImplicationGraph::AddAtMostOne</a>" (absl::Span&lt; const Literal &gt; at_most_one)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000963 (user): Our algorithm could generalize easily to at_most_ones + a list
of literals that will be false if one of the literal in the amo is at one.
It is a way to merge common list of implications. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#afdf7cda61327a0ee3b07971ef7270e49 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#afdf7cda61327a0ee3b07971ef7270e49">operations_research::sat::BinaryImplicationGraph::AddBinaryClause</a>" (Literal a, Literal b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000941 (user): Not all of the solver knows about representative literal, do
use them here and in AddBinaryClauseDuringSearch() to maintains invariant?
Explore this when we start cleaning our clauses using equivalence during
search. We can easily do it for every conflict we learn instead of here. 
 &lt;p&gt; \anchor _todo000942 (user): Like this we will duplicate all binary clause from the
problem. However this leads to a simpler API (since we don't need to
special case the loading of the original clauses) and we mainly use drat
proof for testing anyway. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ac77e8fba04708d2b664eef31e13f9d22 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ac77e8fba04708d2b664eef31e13f9d22">operations_research::sat::BinaryImplicationGraph::CleanupAllRemovedVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000968 (user): consider at most ones.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a07e88e219614208bf02f4bed078504f9 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a07e88e219614208bf02f4bed078504f9">operations_research::sat::BinaryImplicationGraph::ComputeTransitiveReduction</a>" (bool log_info=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000954 (user): Can we exploit the fact that the implication graph is a
skew-symmetric graph (isomorphic to its transposed) so that we do less
work? Also it would be nice to keep the property that even if we abort
during the algorithm, if a =&gt; b, then not(b) =&gt; not(a) is also present in
the other direct implication list. 
 &lt;p&gt; \anchor _todo000953 (user): We should be able to reuse some propagation like it is done for
tree-look. Once a node is processed, we just need to process a node that
implies it. Test if we can make this faster. Alternatively, only clear
a part of is_marked_ (after the first child of root in reverse topo order).&lt;p&gt; \anchor _todo000952 (user): the situation with fixed variable is not really "clean".
Simplify the code so we are sure we don't run into issue or have to deal
with any of that here. 
 &lt;p&gt; \anchor _todo000951 (user): Track which literal have new implications, and only process
the antecedants of these. 
 &lt;p&gt; \anchor _todo000955 (user): Another optim we can do is that we never need to expand
any node with a reverse topo order smaller or equal to the min of the
ones in this list. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aa80bafd5aaf59cc6c7a67176c6304239 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">operations_research::sat::BinaryImplicationGraph::DetectEquivalences</a>" (bool log_info=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000964 (user): Completely get rid of such literal instead? it might not be
reasonable code-wise to remap our literals in all of our constraints
though. 
 &lt;p&gt; \anchor _todo000950 (user): We could just do it directly though.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ab589014979b15460c0cb295527097731 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab589014979b15460c0cb295527097731">operations_research::sat::BinaryImplicationGraph::DirectImplications</a>" (Literal literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000958 (user): lazy cleanup the lists on is_removed_?
 &lt;p&gt; &lt;p&gt;(user): Mark fixed variable as is_removed_ for faster iteration? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a2735353cc3b14a2ef6574ad9f52c06b7 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a2735353cc3b14a2ef6574ad9f52c06b7">operations_research::sat::BinaryImplicationGraph::ExtractAllBinaryClauses</a>" (Output *out) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000967 (user): Ideally we should just never have duplicate clauses in this
class. But it seems we do in some corner cases, so lets not output them
twice. 
 &lt;p&gt; \anchor _todo000966 (user): When extracting to cp_model.proto we could be more efficient
by extracting bool_and constraint with many lhs terms. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aba4f40564f3adae0c9b904663bf62637 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aba4f40564f3adae0c9b904663bf62637">operations_research::sat::BinaryImplicationGraph::GenerateAtMostOnesWithLargeWeight</a>" (const std::vector&lt; Literal &gt; &amp;literals, const std::vector&lt; double &gt; &amp;lp_values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000965 (user): Refine the heuristic and unit test! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aa37e2a622549d733c3bbb8b340f3c473 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa37e2a622549d733c3bbb8b340f3c473">operations_research::sat::BinaryImplicationGraph::MinimizeConflictExperimental</a>" (const Trail &amp;trail, std::vector&lt; Literal &gt; *c)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000947 (user): Also consider at most one?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a3cbe67b46860621bfa57c87f5247a385 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a3cbe67b46860621bfa57c87f5247a385">operations_research::sat::BinaryImplicationGraph::MinimizeConflictWithReachability</a>" (std::vector&lt; Literal &gt; *c)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000946 (user): This sounds like a good idea, but somehow it seems better not
to do that even though it is almost for free. Investigate more.&lt;p&gt; \anchor _todo000945 (user): Also consider at most one? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a7e4e6130c59dffa6ab52a1cff24400a2 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a7e4e6130c59dffa6ab52a1cff24400a2">operations_research::sat::BinaryImplicationGraph::RemoveFixedVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000949 (user): This might be a bit slow. Do not call all the time if needed,
this shouldn't change the correctness of the code. 
 &lt;p&gt; \anchor _todo000948 (user): This might not be true if we remove implication by
transitive reduction and the process was aborted due to the computation
limit. I think it will be good to maintain that invariant though,
otherwise fixed literals might never be removed from these lists... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a4a7ae378f427890ed11dfa8efb7c1db7 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a4a7ae378f427890ed11dfa8efb7c1db7">operations_research::sat::BinaryImplicationGraph::TransformIntoMaxCliques</a>" (std::vector&lt; std::vector&lt; Literal &gt; &gt; *at_most_ones, int64_t max_num_explored_nodes=1e8)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000956 (user): Shall we presolve it here? 
 &lt;p&gt; \anchor _todo000957 (user): Detect on the fly is superset already exist. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BlockedClauseSimplifier Class \_internalref classoperations__research_1_1sat_1_1BlockedClauseSimplifier "<a class="el" href="classoperations__research_1_1sat_1_1BlockedClauseSimplifier.html">operations_research::sat::BlockedClauseSimplifier</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001949 (user): This requires that l only appear in clauses and not in the
integer part of CP-SAT. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac341ac6090ff0bed8ad2231c94cd3bfc "<a class="el" href="namespaceoperations__research_1_1sat.html#ac341ac6090ff0bed8ad2231c94cd3bfc">operations_research::sat::BooleanLinearConstraint</a>" (int64_t lower_bound, int64_t upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001987 (user): move them in another file, and unit-test them.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#acd9e74903eb3b148ec50b729efc714b3 "<a class="el" href="namespaceoperations__research_1_1sat.html#acd9e74903eb3b148ec50b729efc714b3" title="Returns true iff the Boolean linear expression is in canonical form.">operations_research::sat::BooleanLinearExpressionIsCanonical</a>" (const std::vector&lt; LiteralWithCoeff &gt; &amp;cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001759 (user): Also check for no duplicates literals + unit tests.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BooleanOrIntegerVariable Class \_internalref structoperations__research_1_1sat_1_1BooleanOrIntegerVariable "<a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerVariable.html">operations_research::sat::BooleanOrIntegerVariable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001542 (user): This is currently quadratic as we scan all variables to find the
first unassigned one. Fix. Note that this is also the case in many other
heuristics and should be fixed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BooleanXorPropagator Class \_internalref classoperations__research_1_1sat_1_1BooleanXorPropagator "<a class="el" href="classoperations__research_1_1sat_1_1BooleanXorPropagator.html">operations_research::sat::BooleanXorPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000974 (user): By using a two watcher mechanism, we can propagate this a lot
faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BoundedVariableElimination Member \_internalref classoperations__research_1_1sat_1_1BoundedVariableElimination#a8d5a5e9f809d97c6dc3cbc5d948f4a51 "<a class="el" href="classoperations__research_1_1sat_1_1BoundedVariableElimination.html#a8d5a5e9f809d97c6dc3cbc5d948f4a51">operations_research::sat::BoundedVariableElimination::DoOneRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001936 (user): we might also find new equivalent variable l =&gt; var =&gt; l
here, but for now we ignore those. 
 &lt;p&gt; \anchor _todo001935 (user): add a local dtime limit for the corner case where this take too
much time. We can adapt the limit depending on how much we want to spend on
inprocessing. 
 &lt;p&gt; \anchor _todo001934 (user): but we shouldn't keep clauses containing removed literals.
It is still valid to do so, but it should be less efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CanonicalBooleanLinearProblem Class \_internalref classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem "<a class="el" href="classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem.html">operations_research::sat::CanonicalBooleanLinearProblem</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001773 (user): Simplify further the constraints.&lt;p&gt; \anchor _todo001775 (user): Remove duplicate constraints? some problems have them, and
this is not ideal for the symmetry computation since it leads to a lot of
symmetries of the associated graph that are not useful. 
 &lt;p&gt; \anchor _todo001774 (user): Remove the duplication between this and what the sat solver
is doing in AddLinearConstraint() which is basically the same.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CanonicalBooleanLinearProblem Member \_internalref classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem#ad91fdf3c0b3d6b5f52ab35e1ea1cfd31 "<a class="el" href="classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem.html#ad91fdf3c0b3d6b5f52ab35e1ea1cfd31">operations_research::sat::CanonicalBooleanLinearProblem::AddLinearConstraint</a>" (bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001777 (user): Use a return status to distinguish errors if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afadbda106c6b8673a235186582fafa3a "<a class="el" href="namespaceoperations__research_1_1sat.html#afadbda106c6b8673a235186582fafa3a">operations_research::sat::CanonicalizeConstraint</a>" (LinearConstraint *ct)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001576 (user): it would be better if LinearConstraint natively supported
term and not two separated vectors. Fix?&lt;p&gt; \anchor _todo001577 (user): This is really similar to CleanTermsAndFillConstraint(), maybe
we should just make the later switch negative variable to positive ones to
avoid an extra linear scan on each new cuts. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3f5064fe335d0bd2f67a8c9e3e132b4f "<a class="el" href="namespaceoperations__research_1_1sat.html#a3f5064fe335d0bd2f67a8c9e3e132b4f">operations_research::sat::CeilSquareRoot</a>" (int64_t a)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002083 (user): Find better implementation?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitCoveringPropagator Class \_internalref classoperations__research_1_1sat_1_1CircuitCoveringPropagator "<a class="el" href="classoperations__research_1_1sat_1_1CircuitCoveringPropagator.html">operations_research::sat::CircuitCoveringPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000934 (user): Make distinguished nodes an array of Boolean variables,
so this can be used for facility location problems. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitPropagator Member \_internalref classoperations__research_1_1sat_1_1CircuitPropagator#a54823f9c1557fcb9ee85d3c28c329bf0 "<a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html#a54823f9c1557fcb9ee85d3c28c329bf0">operations_research::sat::CircuitPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000929 (user): we can fail early in more case, like no more possible path
to any of the mandatory node. 
 &lt;p&gt; \anchor _todo000928 (user): both this and the loop on must_be_in_cycle_ might take some
time on large graph. Optimize if this become an issue. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitPropagator Member \_internalref classoperations__research_1_1sat_1_1CircuitPropagator#a05dbff53ce702fea3c1b8dbd913a3228 "<a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html#a05dbff53ce702fea3c1b8dbd913a3228">operations_research::sat::CircuitPropagator::RegisterWith</a>" (GenericLiteralWatcher *watcher)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000927 (user): come up with a test that fail when this is not here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a445ddafc05cd8e1a75db81c1c4426179 "<a class="el" href="namespaceoperations__research_1_1sat.html#a445ddafc05cd8e1a75db81c1c4426179">operations_research::sat::ClauseIsEnforcementImpliesLiteral</a>" (absl::Span&lt; const int &gt; clause, absl::Span&lt; const int &gt; enforcement, int literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001847 (user): For the same complexity, we do not need to specify literal and
can recover it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a6314c72e08e179c06ce3b76747499b8c "<a class="el" href="namespaceoperations__research_1_1sat.html#a6314c72e08e179c06ce3b76747499b8c">operations_research::sat::CleanTermsAndFillConstraint</a>" (std::vector&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; *terms, ClassWithVarsAndCoeffs *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001581 (user): This actually only sort the terms, we don't clean them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CombinedDisjunctive Member \_internalref classoperations__research_1_1sat_1_1CombinedDisjunctive#ac88bd295048bf30b8726c9f600587287 "<a class="el" href="classoperations__research_1_1sat_1_1CombinedDisjunctive.html#ac88bd295048bf30b8726c9f600587287">operations_research::sat::CombinedDisjunctive&lt; time_direction &gt;::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001398 (user): AddEntry() and ComputeEndMin() could be combined.
 &lt;p&gt; \anchor _todo001399 (user): Maybe factor out the code? It does require a function with a
lot of arguments though. 
 &lt;p&gt; \anchor _todo001400 (user): Refactor the code to use the same algo as in
DisjunctiveDetectablePrecedences, it is superior and do not need
this function. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a34cc8829256ea003a3f538b06d3a3a74 "<a class="el" href="namespaceoperations__research_1_1sat.html#a34cc8829256ea003a3f538b06d3a3a74" title="Builds the linear relaxation of a CpModelProto.">operations_research::sat::ComputeLinearRelaxation</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001691 (user): Should we add them to the LP anyway? this isn't clear as
we can sometimes create a lot of Booleans like this. 
 &lt;p&gt; \anchor _todo001692 (user): This is similar to AppendRelaxationForEqualityEncoding() above.
Investigate if we can merge the code. 
 &lt;p&gt; \anchor _todo001693 (user): I am not sure this is still needed. Investigate and explain why
or remove. 
 &lt;p&gt; \anchor _todo001694 (user): compute connected components of the original problem and
split these cuts accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac47959359a009b02531ab19f206cdd54 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac47959359a009b02531ab19f206cdd54">operations_research::sat::ComputeTrueObjectiveLowerBound</a>" (const CpModelProto &amp;model_proto_with_floating_point_objective, const CpObjectiveProto &amp;integer_objective, const int64_t inner_integer_objective_lower_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001709 (user): Code a custom algo with more precision guarantee? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a08ac4c44a4524b21806a1ae9839bc5bd "<a class="el" href="namespaceoperations__research_1_1sat.html#a08ac4c44a4524b21806a1ae9839bc5bd">operations_research::sat::ConfigureSearchHeuristics</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001529 (user): We might want to restart if external info is available.
Code a custom restart for this? 
 &lt;p&gt; \anchor _todo001530 (user): This is not used in any of our default config. remove?
It make also no sense to choose a value in the LP heuristic and then
override it with IntegerValueSelectionHeuristic(), clean that up. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a097ca8cb4e3e4c0b29c27846f578f23b "<a class="el" href="namespaceoperations__research_1_1sat.html#a097ca8cb4e3e4c0b29c27846f578f23b">operations_research::sat::ConstructSearchStrategyInternal</a>" (const std::vector&lt; DecisionStrategyProto &gt; &amp;strategies, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001228 (user): Improve the complexity if this becomes an issue which
may be the case if we do a fixed_search. 
 &lt;p&gt; \anchor _todo001229 (user): deal with integer overflow in case of wrongly specified
coeff? Note that if this is filled by the presolve it shouldn't
happen since any feasible value in the new variable domain should be
a feasible value of the original variable domain. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ContinuousProber Member \_internalref classoperations__research_1_1sat_1_1ContinuousProber#a1de4d4b22a2717e58b2444683a806d22 "<a class="el" href="classoperations__research_1_1sat_1_1ContinuousProber.html#a1de4d4b22a2717e58b2444683a806d22">operations_research::sat::ContinuousProber::Probe</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001540 (user):
  - sort variables before the iteration (statically or dynamically)
  - compress clause databases regularly (especially the implication graph)
  - better interleaving of the probing and shaving phases
  - move the shaving code directly in the probing class
  - probe all variables and not just the model ones 
 &lt;p&gt; \anchor _todo001541 (user): Probe optional variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac9c41d8a7687386839ef94182e3badb9 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac9c41d8a7687386839ef94182e3badb9">operations_research::sat::ConvertCpModelProtoToMPModelProto</a>" (const CpModelProto &amp;input, MPModelProto *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001708 (user): This first version do not even handle basic Boolean constraint.
Support more constraints as needed. 
 &lt;p&gt; \anchor _todo001701 (user): Support more constraints with enforcement.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2d32bfb7e130364f3dd94087b686b6f5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2d32bfb7e130364f3dd94087b686b6f5">operations_research::sat::ConvertMPModelProtoToCpModelProto</a>" (const SatParameters &amp;params, const MPModelProto &amp;mp_model, CpModelProto *cp_model, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001700 (user): We could avoid these cases by shifting the domain of
all variables to contain zero. This should also lead to a better scaling,
but it has some complications with integer variables and require some
post-solve. 
 &lt;p&gt; \anchor _todo001699 (user): This could be made larger if needed, so be smarter if we have
MIP problem that we cannot "convert" because of this. Note however than we
cannot go that much further because we need to make sure we will not run
into overflow if we add a big linear combination of such variables. It
should always be possible for a user to scale its problem so that all
relevant quantities are a couple of millions. A LP/MIP solver have a
similar condition in disguise because problem with a difference of more
than 6 magnitudes between the variable values will likely run into numeric
trouble. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoreBasedOptimizer Member \_internalref classoperations__research_1_1sat_1_1CoreBasedOptimizer#ab0a342f8fad2c4262b0ddec85b98bdf8 "<a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html#ab0a342f8fad2c4262b0ddec85b98bdf8">operations_research::sat::CoreBasedOptimizer::Optimize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001748 (user): Maybe the solver should do it right away. 
 &lt;p&gt; \anchor _todo001745 (user): we could keep an objective offset instead. 
 &lt;p&gt; \anchor _todo001746 (user): We can probably be smarter about the cost of the
assumptions though. 
 &lt;p&gt; \anchor _todo001744 (user): These can be simply removed from the list.
 &lt;p&gt; \anchor _todo001743 (user): If the search is aborted during this phase and we solve in
"chunk", we don't resume perfectly from where it was. Fix. 
 &lt;p&gt; \anchor _todo001742 (user): This always resets the solver to level zero.
Because of that we don't resume a solve in "chunk" perfectly. Fix. 
 &lt;p&gt; \anchor _todo001741 (user): The core is returned in the same order as the assumptions,
so we don't really need this map, we could just do a linear scan to
recover which node are part of the core. This however needs to be properly
unit tested before usage. 
 &lt;p&gt; \anchor _todo001740 (user): It might be interesting to redo this kind of presolving
once high cost booleans have been fixed as we might have more at most
one between literal in the objective by then.&lt;p&gt; \anchor _todo001739 (user): Try to understand exactly why and merge both code path. 
 &lt;p&gt; \anchor _todo001747 (user): If the "search" is interrupted while computing cores, we
currently do not resume it flawlessly. We however add any cores we found
before aborting. 
 &lt;p&gt; \anchor _todo001754 (user): Change the algo slighlty to allow resuming from the last
aborted position. Currently, the search is "resumable", but it will restart
some of the work already done, so it might just never find anything. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoreBasedOptimizer Member \_internalref classoperations__research_1_1sat_1_1CoreBasedOptimizer#a0484eb61f8e25adf3dbbcd05e39c7924 "<a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html#a0484eb61f8e25adf3dbbcd05e39c7924">operations_research::sat::CoreBasedOptimizer::OptimizeWithSatEncoding</a>" (const std::vector&lt; Literal &gt; &amp;literals, const std::vector&lt; IntegerVariable &gt; &amp;vars, const std::vector&lt; Coefficient &gt; &amp;coefficients, Coefficient offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001736 (user): Find multiple core like in the "main" algorithm.
this is just trying to solve with assumptions not involving the newly
found core. 
 &lt;p&gt; \anchor _todo001734 (user): This might not be idea if there are holes in the domain.
It should work by adding duplicates literal, but we should be able to
be more efficient. 
 &lt;p&gt; \anchor _todo001733 (user): It could still be beneficial to add one. Experiments. 
 &lt;p&gt; \anchor _todo001732 (user): We could create EncodingNode out of IntegerVariable.&lt;p&gt; \anchor _todo001755 (user):
- Support resuming for interleaved search.
- Implement all core heurisitics. 
 &lt;p&gt; \anchor _todo001735 (user): Take into account parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#a6b31e8bb53bcd9026727c8995d5a0a15 "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#a6b31e8bb53bcd9026727c8995d5a0a15">operations_research::sat::CoverCutHelper::MakeAllTermsPositive</a>" (CutData *cut)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001368 (user): maybe we should do it all at once to avoid some overflow
condition. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#a2709b33e2bff096a56f74aaad532bd13 "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#a2709b33e2bff096a56f74aaad532bd13">operations_research::sat::CoverCutHelper::TryWithLetchfordSouliLifting</a>" (const CutData &amp;input, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001371 (user): compute this in an overflow-safe way.
 &lt;p&gt; \anchor _todo001386 (user): Generalize to non-Boolean, or use a different cover heuristic
for this:
- We want a Boolean only cover currently.
- We can always use implied bound for this, since there is more chance
  for a Bool only cover.
- Also, f() should be super additive on the value &lt;= rhs, i.e. f(a + b) &gt;=
  f(a) + f(b), so it is always good to use implied bounds of the form X =
  bound * B + Slack. 
 &lt;p&gt; \anchor _todo001370 (user): we currently only deal with Boolean in the cover. Fix.
 &lt;p&gt; \anchor _todo001372 (user): For exact multiple of p/q we can increase the coeff by 1/2.
See section in the paper on getting maximal super additive function. 
 &lt;p&gt; \anchor _todo001369 (user): Merge Boolean terms that are complement of each other. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelMapping Member \_internalref classoperations__research_1_1sat_1_1CpModelMapping#a58809f5b0a739fa62cf923b2ed919df5 "<a class="el" href="classoperations__research_1_1sat_1_1CpModelMapping.html#a58809f5b0a739fa62cf923b2ed919df5">operations_research::sat::CpModelMapping::Affine</a>" (const LinearExpressionProto &amp;exp) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001052 (user): We could "easily" create an intermediate variable for more
complex linear expression. We could also identify duplicate expressions to
not create two identical integer variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Class \_internalref classoperations__research_1_1sat_1_1CpModelPresolver "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html">operations_research::sat::CpModelPresolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001224 (user): Identify disconnected components and returns a vector of
presolved model? If we go this route, it may be nicer to store the indices
inside the model. We can add a IntegerVariableProto::initial_index; 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Member \_internalref classoperations__research_1_1sat_1_1CpModelPresolver#a4eea655cfbd484263d86d3d89af42bf5 "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a4eea655cfbd484263d86d3d89af42bf5">operations_research::sat::CpModelPresolver::Presolve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001205 (user): move in the context.
 &lt;p&gt; \anchor _todo001206 (user): We should probably try to delay this even more. For that we
just need to isolate more the "dual" reduction that usually need to look at
the objective. 
 &lt;p&gt; \anchor _todo001207 (user): The presolve transformations we do after this is called might
result in even more presolve if we were to call this again! improve the
code. See for instance plusexample_6_sat.fzn were represolving the
presolved problem reduces it even more. 
 &lt;p&gt; \anchor _todo001209 (user): Decide where is the best place for this.&lt;p&gt; \anchor _todo001210 (user): try not to break symmetry in our clique extension or other
more advanced presolve rule? Ideally we could even exploit them. But in
this case, it is still good to compute them early. 
 &lt;p&gt; \anchor _todo001211 (user): more generally if we do some probing, the same relation will
be detected (and more). Also add an option to turn this off?&lt;p&gt; \anchor _todo001212 (user): instead of extracting at most one, extract pairwise conflicts
and add them to bool_and clauses? this is some sort of small scale
probing, but good for sat presolve and clique later? 
 &lt;p&gt; \anchor _todo001213 (user): revisit when different transformation appear.
&lt;p&gt; \anchor _todo001214 &lt;p&gt; \anchor _todo001215 (user): merge these code instead of doing many passes? 
 &lt;p&gt; \anchor _todo001216 (user): try to be smarter and avoid looping again if little changed. 
 &lt;p&gt; \anchor _todo001217 (user): this variable was removed entirely by the presolve (no
equivalent variable present). We simply ignore it entirely which
might result in a different search... 
 &lt;p&gt; \anchor _todo001218 (user): we could still remove unused constant even if
keep_all_feasible_solutions is true. 
 &lt;p&gt; \anchor _todo001208 (user): Make sure we can't have duplicate in these constraint.
These are due to ExpandCpModel() were we create such constraint with
duplicate. The problem is that some code assumes these are presolved
before being called. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelView Class \_internalref classoperations__research_1_1sat_1_1CpModelView "<a class="el" href="classoperations__research_1_1sat_1_1CpModelView.html">operations_research::sat::CpModelView</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001241 (user): For now it uses proto indices of the loaded model. We will need
to add a mapping to use proto indices of the non-presolved model to allow for
a client custom search with presolve. The main API shouldn't change though
and the change will be transparent. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af443c47f14a044d69553b02337b5dc52 "<a class="el" href="namespaceoperations__research_1_1sat.html#af443c47f14a044d69553b02337b5dc52">operations_research::sat::CpSolverResponseStats</a>" (const CpSolverResponse &amp;response, bool has_objective)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001242 (user): This is probably better named "binary_propagation", but we just
output "propagations" to be consistent with sat/analyze.sh. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae3fd4466b012022bab0c5c1839c77890 "<a class="el" href="namespaceoperations__research_1_1sat.html#ae3fd4466b012022bab0c5c1839c77890">operations_research::sat::CreateAlternativeLiteralsWithView</a>" (int num_literals, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001679 (user): We shouldn't need to create this view ideally. Even better,
we should be able to handle Literal natively in the linear relaxation,
but that is a lot of work. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a55cafa81679ac10c971927ca17ec7f2e "<a class="el" href="namespaceoperations__research_1_1sat.html#a55cafa81679ac10c971927ca17ec7f2e">operations_research::sat::CreateCumulativeEnergyCutGenerator</a>" (SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands_helper, const AffineExpression &amp;capacity, const std::optional&lt; AffineExpression &gt; &amp;makespan, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002004 (user): use level 0 bounds ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a88677d1180474733727feff2bbca0d31 "<a class="el" href="namespaceoperations__research_1_1sat.html#a88677d1180474733727feff2bbca0d31">operations_research::sat::CreateFlowCutGenerator</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; AffineExpression &gt; &amp;arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001877 (user): Support general linear expression for capacities.
 &lt;p&gt; &lt;p&gt;(user): Some model applies the same capacity to both an arc and its
reverse. Also support this case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a09a2bf4928145f3d7a20f7599a8ee7e7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a09a2bf4928145f3d7a20f7599a8ee7e7">operations_research::sat::CreateNoOverlap2dCompletionTimeCutGenerator</a>" (const std::vector&lt; IntervalVariable &gt; &amp;x_intervals, const std::vector&lt; IntervalVariable &gt; &amp;y_intervals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002011 (user): It might be possible/better to use some shifted value
here, but for now this code is not in the hot spot, so better be
defensive and only do connected components on really disjoint
rectangles. 
 &lt;p&gt; \anchor _todo002012 (user): Use improved energy from demands helper.
 &lt;p&gt; \anchor _todo002010 (user): Use demands_helper and decomposed energy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7476bb98ab0ea94ff683d75525fc1f27 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7476bb98ab0ea94ff683d75525fc1f27">operations_research::sat::CreateNoOverlap2dEnergyCutGenerator</a>" (const std::vector&lt; IntervalVariable &gt; &amp;x_intervals, const std::vector&lt; IntervalVariable &gt; &amp;y_intervals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002005 (user): It might be possible/better to use some shifted value
here, but for now this code is not in the hot spot, so better be
defensive and only do connected components on really disjoint
rectangles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a28abd2fe9199829f0c98ade48cfe459c "<a class="el" href="namespaceoperations__research_1_1sat.html#a28abd2fe9199829f0c98ade48cfe459c" title="A cut generator for z = x * y (x and y &gt;= 0).">operations_research::sat::CreatePositiveMultiplicationCutGenerator</a>" (AffineExpression z, AffineExpression x, AffineExpression y, int linearization_level, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001373 (user): As the bounds change monotonically, these cuts
dominate any previous one.  try to keep a reference to the cut and
replace it. Alternatively, add an API for a level-zero bound change
callback. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a692069c042245ee1df0d7e2631fe9a39 "<a class="el" href="namespaceoperations__research_1_1sat.html#a692069c042245ee1df0d7e2631fe9a39">operations_research::sat::Cumulative</a>" (const std::vector&lt; IntervalVariable &gt; &amp;vars, const std::vector&lt; AffineExpression &gt; &amp;demands, AffineExpression capacity, SchedulingConstraintHelper *helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001339 (user): Models that include the makespan as a special interval might
be better, but then not everyone does that. In particular this code
allows to have decent lower bound on the large cumulative minizinc
instances.&lt;p&gt; \anchor _todo001334 (user): Change that since we have optional interval
for this. 
 &lt;p&gt; \anchor _todo001335 (user): We need to exclude intervals that can be of size zero
because the disjunctive do not "ignore" them like the cumulative
does. That is, the interval [2,2) will be assumed to be in
disjunction with [1, 3) for instance. We need to uniformize the
handling of interval with size zero. 
 &lt;p&gt; \anchor _todo001336 (user): Do proper experiments to see how beneficial this is, the
disjunctive will propagate more but is also using slower algorithms.
That said, this is more a question of optimizing the disjunctive
propagation code.&lt;p&gt; \anchor _todo001337 (user): Another "known" idea is to detect pair of tasks that must
be in disjunction and to create a Boolean to indicate which one is
before the other. It shouldn't change the propagation, but may result
in a faster one with smaller explanations, and the solver can also take
decision on such Boolean.&lt;p&gt; \anchor _todo001338 (user): A better place for stuff like this could be in the
presolver so that it is easier to disable and play with alternatives. 
 &lt;p&gt; \anchor _todo001344 (user): If more than one variable are after the same set of
intervals, we should regroup them in a single constraint rather than
having two independent constraint doing the same propagation. 
 &lt;p&gt; \anchor _todo001340 (user): this require the precedence constraints to be already loaded,
and there is no guarantee of that currently. Find a more robust way.&lt;p&gt; \anchor _todo001341 (user): There is a bit of code duplication with the disjunctive
precedence propagator. Abstract more? 
 &lt;p&gt; \anchor _todo001342 (user): Handle generic affine relation?
 &lt;p&gt; \anchor _todo001343 (user): This can lead to many constraints. By analyzing a bit more
the precedences, we could restrict that. In particular for cases were
the cumulative is always (bunch of tasks B), T, (bunch of tasks A) and
task T always in the middle, we never need to explicit list the
precedence of a task in B with a task in A.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeEnergyConstraint Member \_internalref classoperations__research_1_1sat_1_1CumulativeEnergyConstraint#a1058cbb9c9572113e896f5c7c471eacc "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeEnergyConstraint.html#a1058cbb9c9572113e896f5c7c471eacc">operations_research::sat::CumulativeEnergyConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001351 (user): Improve window_end using envelope of critical event.
 &lt;p&gt; \anchor _todo001347 (user): We do not need the capacity max in the reason, but by using
a lower one, we could maybe have propagated more the minimum capacity.
investigate. 
 &lt;p&gt; \anchor _todo001350 (user): the same required task can have its energy pruned
several times, making this algorithm O(n^2 log n). Is there a way
to get the best pruning in one go? This looks like edge-finding not
being able to converge in one pass, so it might not be easy. 
 &lt;p&gt; \anchor _todo001346 (user): force capacity_max &gt;= 0, fail/remove optionals when 0.
 &lt;p&gt; \anchor _todo001348 (user): This could be done lazily.
&lt;p&gt; \anchor _todo001345 (user): just keep the current direction? 
 &lt;p&gt; \anchor _todo001349 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeIsAfterSubsetConstraint Class \_internalref classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint.html">operations_research::sat::CumulativeIsAfterSubsetConstraint</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001353 (user): I am not sure this is the best way, but it does at least push
the level zero bound on the large cumulative instances. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeIsAfterSubsetConstraint Member \_internalref classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint#a9d0445b319d93772786a042918c970c2 "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint.html#a9d0445b319d93772786a042918c970c2">operations_research::sat::CumulativeIsAfterSubsetConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001352 (user): actually, we will push using the
last task, and the reason will be non-optimal, fix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3423c28a2a00161e74d9c6e0174bcbf6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a3423c28a2a00161e74d9c6e0174bcbf6">operations_research::sat::DetectAndExploitSymmetriesInPresolve</a>" (PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001313 (user): for 2/ and 3/ we could add an at most one constraint on the
full orbit if it is not already there!&lt;p&gt; \anchor _todo001307 (user): The same effect could be achieved by adding symmetry breaking
constraints of the form "a &gt;= b " between Booleans and let the presolve do
the reduction. This might be less code, but it is also less efficient.
Similarly, when we cannot just fix variables to break symmetries, we could
add these constraints, but it is unclear if we should do it all the time or
not.&lt;p&gt; \anchor _todo001306 (user): Doing that is not always good, on cod105.mps, fixing variables
instead of letting the innner solver handle Boolean symmetries make the
problem unsolvable instead of easily solved. This is probably because this
fixing do not exploit the full structure of these symmeteries. Note
however that the fixing via propagation above close cod105 even more
efficiently. 
 &lt;p&gt; \anchor _todo001308 (user): code the generic approach with orbits and stabilizer. 
 &lt;p&gt; \anchor _todo001309 (user): generalize somehow. See if we can exploit this in
lb_tree_search directly. We also have a lot more structure than just the
objective can be ordered. Like if the objective is a max, we can still do
that.&lt;p&gt; \anchor _todo001315 (user): We could remove these rows from the orbitope. Note that
currently this never happen on the miplib (maybe in LNS though). 
 &lt;p&gt; \anchor _todo001310 (user): Actually the constraint we add is really just breaking the
orbitope symmetry on one line. But this line being the objective is key. We
can also explicitly look for a full permutation group of the objective
terms directly instead of finding the largest orbitope first. 
 &lt;p&gt; \anchor _todo001311 (user): Compute the stabilizer under the only non-fixed element and
iterate! 
 &lt;p&gt; \anchor _todo001316 (user): We don't have any at most one relation on this orbitope,
but we could still add symmetry breaking inequality by picking any matrix
entry and making it the largest/lowest value on its row. This also work
for non-Booleans. 
 &lt;p&gt; \anchor _todo001317 (user): All choices should be equivalent, but double check? 
 &lt;p&gt; \anchor _todo001312 (user): The code below requires that no variable appears twice in the
same at most one. In particular lit and not(lit) cannot appear in the same
at most one. 
 &lt;p&gt; \anchor _todo001314 (user): maybe we should simplify the constraint using the variable
we fix before choosing the next row to break symmetry on. If there are
multiple row involved, we could also take the intersection instead of
probably counting the same constraints more than once. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa4665a9cdbd059f7acf30060e2c2c4b1 "<a class="el" href="namespaceoperations__research_1_1sat.html#aa4665a9cdbd059f7acf30060e2c2c4b1">operations_research::sat::DetectDominanceRelations</a>" (const PresolveContext &amp;context, VarDomination *var_domination, DualBoundStrengthening *dual_bound_strengthening)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002105 (user): the way we process that is a bit restrictive. By
working on the implication graph we could detect more dominance
relations. Since if a =&gt; b we say that a++ can only be paired with
b&amp;ndash;, but it could actually be paired with any variables that when
dereased implies b = 0. This is a bit mitigated by the fact that
we regroup when we can such implications into big at most ones. 
 &lt;p&gt; \anchor _todo002108 (user): Handle enforcement better here. 
 &lt;p&gt; \anchor _todo002107 (user): Handle enforcement better here.
 &lt;p&gt; \anchor _todo002106 (user): Maybe we should avoid recomputing that here.
 &lt;p&gt; \anchor _todo002104 (user): Benchmark and experiment with 3 phases algo:
- Only ActivityShouldNotChange()/CanOnlyDominateEachOther().
- The other cases once.
- EndFirstPhase() and then the other cases a second time. 
 &lt;p&gt; \anchor _todo002109 (user): We might be able to detect that nothing can be done earlier
during the constraint scanning. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a753e3aea07903c667891eb57036d26de "<a class="el" href="namespaceoperations__research_1_1sat.html#a753e3aea07903c667891eb57036d26de">operations_research::sat::DetectImpliedIntegers</a>" (MPModelProto *mp_model, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001707 (user): Actually implement the offset part. This currently only happens
on the 3 neos-46470* miplib problems where we have a non-integer rhs. 
 &lt;p&gt; \anchor _todo001696 (user): be smarter! we should be able to handle these cases.
 &lt;p&gt; \anchor _todo001697 (user): If we scale more we migth be able to turn it into an
integer. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#add53f590e74a370605446d2ef465e5f4 "<a class="el" href="namespaceoperations__research_1_1sat.html#add53f590e74a370605446d2ef465e5f4">operations_research::sat::DetectLinearEncodingOfProducts</a>" (const AffineExpression &amp;left, const AffineExpression &amp;right, Model *model, LinearConstraintBuilder *builder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001434 (user): Experiment with x * x where constants = 0, x is
fully encoded, and the domain is small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a6f986d4796867adff24dc87248bc249d "<a class="el" href="namespaceoperations__research_1_1sat.html#a6f986d4796867adff24dc87248bc249d">operations_research::sat::DetectMakespan</a>" (const std::vector&lt; IntervalVariable &gt; &amp;intervals, const std::vector&lt; AffineExpression &gt; &amp;demands, const AffineExpression &amp;capacity, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001680 (user): Supports variable capacity.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3216f11aeb59c8cd63d2a1e8cdc6d47b "<a class="el" href="namespaceoperations__research_1_1sat.html#a3216f11aeb59c8cd63d2a1e8cdc6d47b" title="Automatically detect optional variables.">operations_research::sat::DetectOptionalVariables</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001045 (user): This deals with the simplest cases, but we could try to
detect literals that implies all the constraints in which a variable
appear to false. This can be done with a LCA computation in the tree of
Boolean implication (once the presolve remove cycles). Not sure if we can
properly exploit that afterwards though. Do some research! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a43828ad95ab254ebf9cd49702a861512 "<a class="el" href="namespaceoperations__research_1_1sat.html#a43828ad95ab254ebf9cd49702a861512">operations_research::sat::DeterministicLoop</a>" (const std::vector&lt; std::unique_ptr&lt; SubSolver &gt; &gt; &amp;subsolvers, int num_threads, int batch_size)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002040 (user): We could reuse the same ThreadPool as long as we wait for all
the task in a batch to finish before scheduling new ones. Not sure how
to easily do that, so for now we just recreate the pool for each to_run. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac098947e71d4b76a5e0491bf7aefa924 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac098947e71d4b76a5e0491bf7aefa924">operations_research::sat::Disjunctive</a>" (const std::vector&lt; IntervalVariable &gt; &amp;intervals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001412 (user): This is not completely true for empty intervals (start == end).
Make sure such intervals are ignored by the constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DisjunctiveWithTwoItems Member \_internalref classoperations__research_1_1sat_1_1DisjunctiveWithTwoItems#aded29605fb1b5e0a55697fabdc9797ae "<a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveWithTwoItems.html#aded29605fb1b5e0a55697fabdc9797ae">operations_research::sat::DisjunctiveWithTwoItems::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001397 (user): For optional interval whose presence in unknown and without
optional variable, the end-min may not be propagated to at least (start_min
+ size_min). Consider that into the computation so we may decide the
interval forced absence? Same for the start-max. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DivisionPropagator Class \_internalref classoperations__research_1_1sat_1_1DivisionPropagator "<a class="el" href="classoperations__research_1_1sat_1_1DivisionPropagator.html">operations_research::sat::DivisionPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001509 (user): Deal with overflow. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DomainDeductions Class \_internalref classoperations__research_1_1sat_1_1DomainDeductions "<a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html">operations_research::sat::DomainDeductions</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001845 (user): Also propagate implicit clauses (lit, not(lit)). Maybe merge
that with probing code? it might be costly to store all deduction done by
probing though, but I think this is what MIP solver do. 
 &lt;p&gt; \anchor _todo001844 (user): Also use these "deductions" in the solver directly. This is done
in good MIP solvers, and we should exploit them more.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DomainDeductions Member \_internalref classoperations__research_1_1sat_1_1DomainDeductions#a90eec97bf72d63f4c921156b3f31c5a4 "<a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html#a90eec97bf72d63f4c921156b3f31c5a4">operations_research::sat::DomainDeductions::ProcessClause</a>" (absl::Span&lt; const int &gt; clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001848 (user): We could probably be even more efficient. We could also
compute exactly what clauses need to be "waked up" as new deductions are
added. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DratProofHandler Member \_internalref classoperations__research_1_1sat_1_1DratProofHandler#a024232f8972a7dcb6cbf91ec8fe36fb0 "<a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html#a024232f8972a7dcb6cbf91ec8fe36fb0">operations_research::sat::DratProofHandler::ApplyMapping</a>" (const absl::StrongVector&lt; BooleanVariable, BooleanVariable &gt; &amp;mapping)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001415 (user): This is exactly the same mecanism as in the SatPostsolver
class. Factor out the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Class \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html">operations_research::sat::DualBoundStrengthening</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002116 (user): This is actually an important step to do before scaling as it can
usually reduce really large bounds! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Member \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening#aa3f78681f549714a6bcfabc007aa985d "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html#aa3f78681f549714a6bcfabc007aa985d" title="All constraints should be mapped to one of more call to these functions.">operations_research::sat::DualBoundStrengthening::CannotDecrease</a>" (absl::Span&lt; const int &gt; refs, int ct_index=-1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002096 (user): No need to set locking_ct_index_[var] if num_locks_[var] &gt; 1
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Member \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening#a162bcb064138a579ee8192ffb9c244cb "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html#a162bcb064138a579ee8192ffb9c244cb">operations_research::sat::DualBoundStrengthening::Strengthen</a>" (PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002103 (user): Make sure implication graph is transitively reduced to not
miss such reduction. More generally, this might only use the graph rather
than the encoding into bool_and / at_most_one ? Basically if a =&gt;
all_direct_deduction, we can transform it into a &lt;=&gt; all_direct_deduction
if that is interesting. This could always be done on a max-2sat problem
in one of the two direction. Also think about max-2sat specific presolve. 
 &lt;p&gt; \anchor _todo002102 (user): Because this can be in num_var ^ 2 in some bad cases where
each variable is only blocked by a long constraint, we impose a work
limit. Improve? 
 &lt;p&gt; \anchor _todo002101 (user): We can generalize to non-linear constraint.&lt;p&gt; \anchor _todo002100 (user): Generalize to non-Boolean. Also for Boolean, we might
miss some possible reduction if replacing X by 1 - X make a constraint
near-duplicate of another.&lt;p&gt; \anchor _todo002099 (user): We can also deal with more than one enforcement. 
 &lt;p&gt; \anchor _todo002098 (user): Fix variable right away rather than waiting for next call.
 &lt;p&gt; \anchor _todo002097 (user): Cover all the cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a495e710b871a849e93a96e645b793385 "<a class="el" href="namespaceoperations__research_1_1sat.html#a495e710b871a849e93a96e645b793385">operations_research::sat::EncodeObjectiveAsSingleVariable</a>" (CpModelProto *cp_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001054 (user): Add only a &gt;= constraint? Not sure it is useful to do that before
presolve, we can always do this optimization just before solving the model. 
 &lt;p&gt; \anchor _todo001053 (user): deal with this case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::EncodingNode Member \_internalref classoperations__research_1_1sat_1_1EncodingNode#a763a386768f8cf0eeb8d62ff28a620d3 "<a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html#a44db9a8d6f20311a92ba0999f6648d4b">operations_research::sat::EncodingNode::EncodingNode</a>" (int lb, int ub, std::function&lt; Literal(int x)&gt; create_lit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001417 (user): Not ideal, we should probably just provide index in the
original objective for sorting purpose. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a54c46edad1029536152f65856179ae10 "<a class="el" href="namespaceoperations__research_1_1sat.html#a54c46edad1029536152f65856179ae10">operations_research::sat::EqualMinOfSelectedVariables</a>" (Literal enforcement_literal, AffineExpression target, const std::vector&lt; AffineExpression &gt; &amp;exprs, const std::vector&lt; Literal &gt; &amp;selectors)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001999 (user): Change API to not use the enforcement literal.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac32fa78e911692fae246c73675cc3970 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac32fa78e911692fae246c73675cc3970">operations_research::sat::ExactlyOnePerRowAndPerColumn</a>" (const std::vector&lt; std::vector&lt; Literal &gt; &gt; &amp;graph)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000935 (user): Change to a sparse API like for the function above.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a265b8cf37f58fb2c78b247a6412ce519 "<a class="el" href="namespaceoperations__research_1_1sat.html#a265b8cf37f58fb2c78b247a6412ce519">operations_research::sat::ExploitDominanceRelations</a>" (const VarDomination &amp;var_domination, PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002114 (user): We always keep adding the same relations. Investigate?
it seems pure SAT presolve remove them. 
 &lt;p&gt; \anchor _todo002113 &lt;p&gt; \anchor _todo002112 (user): generalize to non Booleans?
&lt;p&gt; \anchor _todo002111 (user): if both variable are in a bool_or, this will allow us to remove
the dominated variable. Maybe we should exploit that to decide which
implication we add. Or just remove such variable and not add the
implications?&lt;p&gt; \anchor _todo002110 (user): More generally, combine with probing? if a dominated variable
implies one of its dominant to zero, then it can be set to zero. It seems
adding the implication below should have the same effect? but currently
it requires a lot of presolve rounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afa73e23a5cfae0eaf253c2e2518e05e7 "<a class="el" href="namespaceoperations__research_1_1sat.html#afa73e23a5cfae0eaf253c2e2518e05e7">operations_research::sat::ExtractEncoding</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001040 (user): Fully encode variable that are almost fully encoded? 
 &lt;p&gt; \anchor _todo001039 (user): In these cases, we could fix the enforcement literal right
away or ignore the constraint. Note that it will be done later anyway
though. 
 &lt;p&gt; \anchor _todo001038 (user): We will re-add the same implied bounds during probing, so
it might not be necessary to do that here. Also, it might be too early
if some of the literal view used in the LP are created later, but that
should be fixable via calls to implied_bounds-&gt;NotifyNewIntegerView(). 
 &lt;p&gt; \anchor _todo001037 (user): Debug what makes it unsat at this point.
 &lt;p&gt; \anchor _todo001036 (user): Regroup/presolve two encoding like b =&gt; x &gt; 2 and the same
Boolean b =&gt; x &gt; 5. These shouldn't happen if we merge linear constraints. 
 &lt;p&gt; \anchor _todo001041 (user): Try to remove it. Normally we caught UNSAT above, but
tests are very flaky (it only happens in parallel). Keeping it there for
the time being. 
 &lt;p&gt; \anchor _todo001042 (user): delay this after PropagateEncodingFromEquivalenceRelations()?
Otherwise we might create new Boolean variables for no reason. Note
however, that in the presolve, we should only use the "representative" in
linear constraints, so we should be fine. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac9d08e5135a1ae71b571b14fbff3381b "<a class="el" href="namespaceoperations__research_1_1sat.html#ac9d08e5135a1ae71b571b14fbff3381b">operations_research::sat::FailedLiteralProbingRound</a>" (ProbingOptions options, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001855 (user): Can we be smarter here? Maybe we can still fix the
literal without going back to level zero by simply enqueing it with
no reason? it will be bactracked over, but we will still lazily fix
it later. 
 &lt;p&gt; \anchor _todo001859 (user): We might just want to do that even more lazily by
checking for detached clause while propagating here? and do a big
cleanup at the end. 
 &lt;p&gt; \anchor _todo001858 (user): Similar to previous point, we could find the LCA
of all literals in the reason for this propagation. And use this
as a reason for later hyber binary resolution. Like we do when
this clause subsume the reason. 
 &lt;p&gt; \anchor _todo001857 (user): Think about trying to extract clause that will not
get removed by transitive reduction later. If we can both extract
a =&gt; c and b =&gt; c , ideally we don't want to extract a =&gt; c first
if we already know that a =&gt; b.&lt;p&gt; \anchor _todo001856 (user): We could be slightly more generic and subsume some
clauses that do not contains last_decision.Negated(). 
 &lt;p&gt; \anchor _todo001854 (user): Instead of minimizing index in topo order (which might be
nice for binary extraction), we could try to maximize reusability in
some way. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a300f624fabbec583376b6e87dcb6fbda "<a class="el" href="namespaceoperations__research_1_1sat.html#a300f624fabbec583376b6e87dcb6fbda">operations_research::sat::FillSolveStatsInResponse</a>" (Model *model, CpSolverResponse *response)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002051 (user): find a way to clear all stats fields that might be set by
one of the callback. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a76d6dd44958673bb83ac31e970539135 "<a class="el" href="namespaceoperations__research_1_1sat.html#a76d6dd44958673bb83ac31e970539135">operations_research::sat::FindBestScalingAndComputeErrors</a>" (const std::vector&lt; double &gt; &amp;coefficients, const std::vector&lt; double &gt; &amp;lower_bounds, const std::vector&lt; double &gt; &amp;upper_bounds, int64_t max_absolute_activity, double wanted_absolute_activity_precision, double *relative_coeff_error, double *scaled_sum_error)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001698 (user): Make this faster. 
 &lt;p&gt; \anchor _todo001705 (user): unit test this and move to fp_utils.
 &lt;p&gt; &lt;p&gt;(user): Ideally the lower/upper should be int64_t so that we can have
an exact definition for the max_absolute_activity allowed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae16bafcf3c5377ed905021a96f93bdcf "<a class="el" href="namespaceoperations__research_1_1sat.html#ae16bafcf3c5377ed905021a96f93bdcf">operations_research::sat::FindCpModelSymmetries</a>" (const SatParameters &amp;params, const CpModelProto &amp;problem, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators, double deterministic_limit, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001305 (user): Change the API to not return an error when the time limit is
reached. 
 &lt;p&gt; \anchor _todo001330 (user): On SAT problems it is more powerful to detect permutations also
involving the negation of the problem variables. So that we could find a
symmetry x &lt;-&gt; not(y) for instance.&lt;p&gt; \anchor _todo001331 (user): As long as we only exploit symmetry involving only Boolean
variables we can make this code more efficient by not detecting symmetries
involing integer variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2e4999dc16f55afa8c5d30a733a26e3d "<a class="el" href="namespaceoperations__research_1_1sat.html#a2e4999dc16f55afa8c5d30a733a26e3d">operations_research::sat::FindDuplicateConstraints</a>" (const CpModelProto &amp;model_proto, bool ignore_enforcement)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001220 (user): This is not particularly efficient. 
 &lt;p&gt; \anchor _todo001219 (user): we could delete duplicate identical interval, but we need
to make sure reference to them are updated. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a75271e8da6c6cb4c5c87226e150d47d7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a75271e8da6c6cb4c5c87226e150d47d7">operations_research::sat::FindLinearBooleanProblemSymmetries</a>" (const LinearBooleanProblem &amp;problem, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000924 (user): Remove them beforehand? 
 &lt;p&gt; \anchor _todo000923 (user): inject the appropriate time limit here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7492392221bdfcc832cce2d93c9b681c "<a class="el" href="namespaceoperations__research_1_1sat.html#a7492392221bdfcc832cce2d93c9b681c" title="Returns a stable fingerprint of a model.">operations_research::sat::FingerprintModel</a>" (const CpModelProto &amp;model, uint64_t seed=kDefaultFingerprintSeed)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001332 (user): Should we fingerprint decision strategies?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8c72a9619e1961d1434170437536cff6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8c72a9619e1961d1434170437536cff6">operations_research::sat::FirstUnassignedVarAtItsMinHeuristic</a>" (const std::vector&lt; IntegerVariable &gt; &amp;vars, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001521 (user): the complexity caused by the linear scan in this heuristic and
the one below is ok when search_branching is set to SAT_SEARCH because it is
not executed often, but otherwise it is done for each search decision,
which seems expensive. Improve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aad857ec34d719b9094b332f3fcdaf8c5 "<a class="el" href="namespaceoperations__research_1_1sat.html#aad857ec34d719b9094b332f3fcdaf8c5">operations_research::sat::FixedWeightedSumReif</a>" (Literal is_eq, const std::vector&lt; IntegerVariable &gt; &amp;vars, const VectorInt &amp;coefficients, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001515 (user): Simplify if the constant is at the edge of the possible values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a392d70cc768a13de271f87123513acf2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a392d70cc768a13de271f87123513acf2" title="The argument must be non-negative.">operations_research::sat::FloorSquareRoot</a>" (int64_t a)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002082 (user): Find better implementation? In pratice passing via double is
almost always correct, but the CapProd() might be a bit slow. However this
is only called when we do propagate something. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FlowCoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1FlowCoverCutHelper#af7fca0dc3ced6d077248ca695664ec7c "<a class="el" href="classoperations__research_1_1sat_1_1FlowCoverCutHelper.html#af7fca0dc3ced6d077248ca695664ec7c">operations_research::sat::FlowCoverCutHelper::GenerateCut</a>" (const SingleNodeFlow &amp;data)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001381 (user): Lift the cut.
 &lt;p&gt; \anchor _todo001380 (user): Also try to generate the extended generalized flow cover
inequality (EGFCI). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FlowInfo Class \_internalref structoperations__research_1_1sat_1_1FlowInfo "<a class="el" href="structoperations__research_1_1sat_1_1FlowInfo.html">operations_research::sat::FlowInfo</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001384 (user): Altough the cut should still be correct, we might use the same
Boolean more than once in the implied bound. Or this Boolean might already
appear in the constraint. Not sure if we can do something smarter here. 
 &lt;p&gt; \anchor _todo001383 (user): cover case 3/. We loose a lot of relaxation here, except if
the variable is at is upper/lower bound.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a36bf1351ffa74960b3040a96ddc37468 "<a class="el" href="namespaceoperations__research_1_1sat.html#a36bf1351ffa74960b3040a96ddc37468">operations_research::sat::FullyCompressTuples</a>" (absl::Span&lt; const int64_t &gt; domain_sizes, std::vector&lt; std::vector&lt; int64_t &gt; &gt; *tuples)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002088 (user): The final compression is depend on the order of the variables.
For instance the table (1,1)(1,2)(1,3),(1,4),(2,3) can either be compressed
as (1,*)(2,3) or (1,{1,2,4})({1,3},3). More experiment are needed to devise
a better heuristic. It might for example be good to call CompressTuples()
first. 
 &lt;p&gt; \anchor _todo002087 (user): To reduce memory, we could return some absl::Span in the last
layer instead of vector.&lt;p&gt; \anchor _todo002086 (user): We can probably reuse the tuples memory always and never create
new one. We should also be able to code an iterative version of this. Note
however that the recursion level is bounded by the number of coluns which
should be small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7c9974b58d1c81ed4c500a5882c0e6a4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7c9974b58d1c81ed4c500a5882c0e6a4">operations_research::sat::GenerateCompletionTimeCutsWithEnergy</a>" (const std::string &amp;cut_name, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; CtEvent &gt; events, bool use_lifting, bool skip_low_sizes, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002008 (user): Use dynamic programming to compute all possible values for
the sum of demands as long as the involved numbers are small or the
number of tasks are small. 
 &lt;p&gt; \anchor _todo002007 (user): merge with Packing cuts. 
 &lt;p&gt; \anchor _todo002009 (user): Check overflow and ignore if too big.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac0799b30b39ecd8a0fabdde1cc89a780 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac0799b30b39ecd8a0fabdde1cc89a780">operations_research::sat::GenerateCumulativeEnergeticCuts</a>" (const std::string &amp;cut_name, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; EnergyEvent &gt; events, const AffineExpression capacity, TimeLimit *time_limit, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002003 (user): We could reduce this set. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4253861ef501ff216f98da02e716bf90 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4253861ef501ff216f98da02e716bf90">operations_research::sat::GenerateCumulativeEnergeticCutsWithMakespanAndFixedCapacity</a>" (const std::string &amp;cut_name, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; EnergyEvent &gt; events, IntegerValue capacity, AffineExpression makespan, TimeLimit *time_limit, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002001 &lt;p&gt; \anchor _todo002000 (user): We could reduce this set.
&lt;p&gt; \anchor _todo002002 (user): we can compute the max usage between makespan_min and
   makespan_max. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af2a840612629fd37d42870c23e183609 "<a class="el" href="namespaceoperations__research_1_1sat.html#af2a840612629fd37d42870c23e183609">operations_research::sat::GenerateGraphForSymmetryDetection</a>" (const LinearBooleanProblem &amp;problem, std::vector&lt; int &gt; *initial_equivalence_classes)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000922 (user): reserve the memory for the graph? not sure it is worthwhile
since it would require some linear scan of the problem though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3601ed5c024b3b30339a2133888c1771 "<a class="el" href="namespaceoperations__research_1_1sat.html#a3601ed5c024b3b30339a2133888c1771">operations_research::sat::GenerateShortCompletionTimeCutsWithExactBound</a>" (const std::string &amp;cut_name, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; CtEvent &gt; events, IntegerValue capacity_max, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002006 (user): Improve performance
  - detect disjoint tasks (no need to crossover to the second part)
  - better caching of explored states 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Class \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">operations_research::sat::GenericLiteralWatcher</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001479 (user): Move this to its own file. Add unit tests! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#ad53c31fda5130ffda98dbb242faf3145 "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#ad53c31fda5130ffda98dbb242faf3145">operations_research::sat::GenericLiteralWatcher::GenericLiteralWatcher</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001473 (user): This propagator currently needs to be last because it is the
only one enforcing that a fix-point is reached on the integer variables.
Figure out a better interaction between the sat propagation loop and
this one. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#a23370d30fab5bc955f314d3ced9add4a "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#a23370d30fab5bc955f314d3ced9add4a">operations_research::sat::GenericLiteralWatcher::Propagate</a>" (Trail *trail) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001474 (user): The queue will not be emptied, but I am not sure the solver
will be left in an usable state. Fix if it become needed to resume
the solve from the last time it was interrupted. 
 &lt;p&gt; \anchor _todo001476 (user): However, on some problem, it seems to work better to not
do that. One possible reason is that the reason of a "natural"
propagation might be better than one we learned. 
 &lt;p&gt; \anchor _todo001475 (user): Maybe just provide one function Propagate(watch_indices) ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#ab3993b47fa18e5a83198e062ded08bb7 "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#ab3993b47fa18e5a83198e062ded08bb7" title="Registers a propagator and returns its unique ids.">operations_research::sat::GenericLiteralWatcher::Register</a>" (PropagatorInterface *propagator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001477 (user): This initial propagation does not respect any later priority
settings. Fix this. Maybe we should force users to pass the priority at
registration. For now I didn't want to change the interface because there
are plans to implement a kind of "dynamic" priority, and if it works we may
want to get rid of this altogether. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5da173a94bec567c831df465aae5c5e4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5da173a94bec567c831df465aae5c5e4">operations_research::sat::GetDiverseSetOfParameters</a>" (const SatParameters &amp;base_params, const CpModelProto &amp;cp_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001230 (user): Do more experiments, the LP with core could be useful, but we
probably need to incorporate the newly created integer variables from the
core algorithm into the LP. 
 &lt;p&gt; \anchor _todo001231 (user): For scheduling, this is important to find good first solution
but afterwards it is not really great and should probably be replaced by a
LNS worker.
 &lt;p&gt; \anchor _todo001232 (user): Avoid launching two strategies if they are the same,
like if there is no lp, or everything is already linearized at level 1.
 &lt;p&gt; \anchor _todo001233 (user): Check that at parameter validation and return nice error
instead.
 &lt;p&gt; \anchor _todo001234 (user): Enable probing_search in deterministic mode.
Currently it timeouts on small problems as the deterministic time limit
never hits the sharding limit.
 &lt;p&gt; \anchor _todo001235 (user): Enable lb_tree_search in deterministic mode.
 &lt;p&gt; \anchor _todo001236 (user): Find a better randomization for the seed so that changing
random_seed() has more impact?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac0a72a98abb5322b3bffcf53d3f9be09 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac0a72a98abb5322b3bffcf53d3f9be09">operations_research::sat::GetFirstSolutionParams</a>" (const SatParameters &amp;base_params, const CpModelProto &amp;cp_model, int num_params_to_generate)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001238 &lt;p&gt; \anchor _todo001237 (user): Maybe alternate between more search types.
&lt;p&gt; \anchor _todo001239 (user): Check the randomization tolerance.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab09ceee4516e94452251cbecb46d4d0b "<a class="el" href="namespaceoperations__research_1_1sat.html#ab09ceee4516e94452251cbecb46d4d0b">operations_research::sat::GetOrbits</a>" (int n, const std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; &amp;generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002049 (user): We could reuse the internal memory if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afa1020b89b12f653b1ea0dd0d595557e "<a class="el" href="namespaceoperations__research_1_1sat.html#afa1020b89b12f653b1ea0dd0d595557e">operations_research::sat::GetSuperAdditiveRoundingFunction</a>" (IntegerValue rhs_remainder, IntegerValue divisor, IntegerValue t, IntegerValue max_scaling)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001354 (user): Use everywhere a two step computation to avoid overflow?
First divide by divisor, then multiply by t. For now, we limit t so that
we never have an overflow instead. 
 &lt;p&gt; \anchor _todo001355 (user): This function is not always maximal when
size % (max_scaling - 1) == 0. Improve? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfPropagator Member \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator#a3b3ae77e1959c1da3c086669f8c28062 "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator.html#a3b3ae77e1959c1da3c086669f8c28062">operations_research::sat::GreaterThanAtLeastOneOfPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000972 (user): In case of a conflict, we could push one of them to false if
it is the only one. 
 &lt;p&gt; \anchor _todo000973 (user): This could be optimized by keeping more info from the last
Propagate() calls. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af6433b3a01c71cd754d3d710f345b4c0 "<a class="el" href="namespaceoperations__research_1_1sat.html#af6433b3a01c71cd754d3d710f345b4c0">operations_research::sat::GreedyFastDecreasingGcd</a>" (const absl::Span&lt; const int64_t &gt; coeffs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001394 (user): The following is a heuristic to make drop the GCD as fast
as possible. It might be suboptimal in general (as we could miss two
coprime coefficients for instance). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::HittingSetOptimizer Class \_internalref classoperations__research_1_1sat_1_1HittingSetOptimizer "<a class="el" href="classoperations__research_1_1sat_1_1HittingSetOptimizer.html">operations_research::sat::HittingSetOptimizer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001720 (user): This class requires linking with the SCIP MIP solver which is
quite big, maybe we should find a way not to do that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::HittingSetOptimizer Member \_internalref classoperations__research_1_1sat_1_1HittingSetOptimizer#a82f11613372a6a2909c2dc75bcd6216b "<a class="el" href="classoperations__research_1_1sat_1_1HittingSetOptimizer.html#a82f11613372a6a2909c2dc75bcd6216b">operations_research::sat::HittingSetOptimizer::Optimize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001714 (user): deal with time limit. 
 &lt;p&gt; \anchor _todo001715 (user): C^c is broken when using SCIP.
 &lt;p&gt; \anchor _todo001716 (user): It is actually easy to use a FEASIBLE result. If when
passing it to SAT it is no feasbile, we can still create cores. If it
is feasible, we have a solution, but we cannot increase the lower
bound. 
 &lt;p&gt; \anchor _todo001719 (user): If we extract more than the objective variables, we could
use the solution values from the MPModel as hints to the SAT model. 
 &lt;p&gt; \anchor _todo001718 &lt;p&gt; \anchor _todo001713 (user): Even though we keep the same solver, currently the solve is
not really done incrementally. It might be hard to improve though.&lt;p&gt; \anchor _todo001712 (user): remove code duplication with MinimizeWithCoreAndLazyEncoding(); 
 &lt;p&gt; \anchor _todo001717 (user): Use the real weights and exploit the extra cores.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a6e056f4efb99b080ae5bdb7267339f59 "<a class="el" href="namespaceoperations__research_1_1sat.html#a6e056f4efb99b080ae5bdb7267339f59">operations_research::sat::Implication</a>" (const std::vector&lt; Literal &gt; &amp;enforcement_literals, IntegerLiteral i)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001481 (user): Double check what happen when we associate a trivially
true or false literal. 
 &lt;p&gt; \anchor _todo001480 (user): This is one of the rare case where it is better to use Equality()
rather than two Implications(). Maybe we should modify our internal
implementation to use half-reified encoding? that is do not propagate the
direction integer-bound =&gt; literal, but just literal =&gt; integer-bound? This
is the same as using different underlying variable for an integer literal and
its negation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Class \_internalref classoperations__research_1_1sat_1_1ImpliedBounds "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html">operations_research::sat::ImpliedBounds</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001440 (user): Add an implied bound cut generator to add these simple
constraints to the LP when needed. 
 &lt;p&gt; \anchor _todo001437 (user): This can quickly use up too much memory. Add some limit in place.
In particular, each time we have literal =&gt; integer_literal we should avoid
storing the same integer_literal for all other_literal for which
other_literal =&gt; literal. For this we need to interact with the
BinaryImplicationGraph.&lt;p&gt; \anchor _todo001438 (user): This is a bit of a duplicate with the Literal &lt;=&gt; IntegerLiteral
stored in the IntegerEncoder class. However we only need one side here.&lt;p&gt; \anchor _todo001439 (user): Do like in the DomainDeductions class and allow to process
clauses (or store them) to perform more level zero deductions. Note that this
is again a slight duplicate with what we do there (except that we work at the
Domain level in that presolve class).&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Member \_internalref classoperations__research_1_1sat_1_1ImpliedBounds#a0de744155aa83ebfd9c04edd6d14ac33 "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html#a0de744155aa83ebfd9c04edd6d14ac33">operations_research::sat::ImpliedBounds::Add</a>" (Literal literal, IntegerLiteral integer_literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001427 (user): Check that this never happen? it shouldn't. 
 &lt;p&gt; \anchor _todo001428 (user): Like in probing, we can also create hole in the domain if there
is some implied bounds for (literal.NegatedIndex, NegagtionOf(var)) that
crosses integer_literal.bound. 
 &lt;p&gt; \anchor _todo001429 (user): support Enqueueing level zero fact at a positive level.
That is, do not loose the info on backtrack. This should be doable. It
is also why we return a bool in case of conflict when pushing
deduction. 
 &lt;p&gt; \anchor _todo001430 (user): Maybe we can handle this case somehow, as long as every
constraint using this bound is protected by the variable optional literal.
Alternativelly we could disable optional variable when we are at
linearization level 2. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Member \_internalref classoperations__research_1_1sat_1_1ImpliedBounds#ace9f6e200fff7933263a014bb9d62fb8 "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html#ace9f6e200fff7933263a014bb9d62fb8">operations_research::sat::ImpliedBounds::GetImpliedBounds</a>" (IntegerVariable var)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001431 (user): Check no duplicate and remove old entry if the enforcement
is tighter. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Member \_internalref classoperations__research_1_1sat_1_1ImpliedBounds#ada7615cca2d8b7063f4d99fd87ff0399 "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html#ada7615cca2d8b7063f4d99fd87ff0399">operations_research::sat::ImpliedBounds::NotifyNewIntegerView</a>" (Literal literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001441 (user): Implement and call when we create new views in the linear
relaxation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBoundsProcessor Member \_internalref classoperations__research_1_1sat_1_1ImpliedBoundsProcessor#ace0dba418106eaaeca69f6adac3fff3e "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html#ace0dba418106eaaeca69f6adac3fff3e" title="Important: The cut_builder_ must have been reset.">operations_research::sat::ImpliedBoundsProcessor::TryToExpandWithLowerImpliedbound</a>" (IntegerValue factor_t, int i, bool complement, CutData *cut, CutDataBuilder *builder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001377 (user): Because of merges, we might have entry with a coefficient of
zero than are not useful. Remove them. 
 &lt;p&gt; \anchor _todo001376 (user): Only do it if coeff_b &gt; 0 ? But again we could still merge
B with an existing Boolean for a better cut even if coeff_b == 0. 
 &lt;p&gt; \anchor _todo001375 (user): Ignore if bound_diff == 1 ? But we can still merge B with
another entry if it exists, so it can still be good in this case.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad715c4b2444c3b6fb162bc2382a2248e "<a class="el" href="namespaceoperations__research_1_1sat.html#ad715c4b2444c3b6fb162bc2382a2248e">operations_research::sat::IncreaseNodeSize</a>" (EncodingNode *node, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001418 (user): Experiment more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Class \_internalref classoperations__research_1_1sat_1_1Inprocessing "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html">operations_research::sat::Inprocessing</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001947 (user): Some algorithms here use the normal SAT propagation engine.
However we might want to temporarily disable activities/phase saving and so
on if we want to run them as in-processing steps so that they
do not "pollute" the normal SAT search.&lt;p&gt; \anchor _todo001948 (user): For the propagation, this depends on the SatSolver class, which
mean we cannot really use it without some refactoring as an in-processing
from the SatSolver::Solve() function. So we do need a special
InprocessingSolve() that lives outside SatSolver. Alternatively, we can
extract the propagation main loop and conflict analysis from SatSolver. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a3ab413def8a2242915ef31ff717baa17 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a3ab413def8a2242915ef31ff717baa17">operations_research::sat::Inprocessing::DetectEquivalencesAndStamp</a>" (bool use_transitive_reduction, bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001898 (user): consider doing the transitive reduction after each SCC.
It might be slow but we could try to make it more incremental to
compensate and it should allow further reduction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#aa0797dfc25a5c609254b61fe67828c11 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#aa0797dfc25a5c609254b61fe67828c11">operations_research::sat::Inprocessing::InprocessingRound</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001897 (user): Add a small wrapper function to time this.
 &lt;p&gt; \anchor _todo001896 (user): We should probably also disable the variable/clauses activity
updates. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a67d25dadf7669215ab5b27b4d8046e18 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a67d25dadf7669215ab5b27b4d8046e18">operations_research::sat::Inprocessing::PresolveLoop</a>" (SatPresolveOptions options)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001895 (user): Maintain the total number of literals in the watched clauses.
 &lt;p&gt; \anchor _todo001894 (user): Combine the two? this way we don't create a full literal &lt;-&gt;
clause graph twice. It might make sense to reach the BCE fix point which
is unique before each variable elimination. 
 &lt;p&gt; \anchor _todo001893 (user): This should/could be integrated with the stamping since it
seems better to do just one loop instead of two over all clauses. Because
of memory access. it isn't that clear though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a5e0f39f14f9c6d947181e7185d6ed865 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a5e0f39f14f9c6d947181e7185d6ed865">operations_research::sat::Inprocessing::RemoveFixedAndEquivalentVariables</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001902 (user): find a way to auto-tune that after a run on borg...
 &lt;p&gt; \anchor _todo001901 (user): we should output literal to the proof right away,
currently if we remove clauses before fixing literal the proof is
wrong. 
 &lt;p&gt; \anchor _todo001899 (user): The level zero is required because we remove fixed variables
but if we split this into two functions, we could rewrite clause at any
level. 
 &lt;p&gt; \anchor _todo001900 (user): If only new fixed variables are there, we can use a faster
function. We should also merge the code with the deletion code in
sat_solver_.cc, but that require some refactoring of the dependence between
files. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a2fbf49af4f2bef7419f9eff0fc4847b2 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a2fbf49af4f2bef7419f9eff0fc4847b2">operations_research::sat::Inprocessing::SubsumeAndStrenghtenRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001904 (user): Be more incremental, each time a clause is added/reduced track
which literal are impacted? Also try to do orthogonal reductions from one
round to the next. 
 &lt;p&gt; \anchor _todo001905 (user): We could do that only if we do some reduction, but this is
quite fast though. 
 &lt;p&gt; \anchor _todo001906 (user): probably faster without the size indirection. 
 &lt;p&gt; \anchor _todo001913 (user): We could also move the watched literal first so we always
skip it. 
 &lt;p&gt; \anchor _todo001912 (user): We could/should sort the literal in this clause by
using literals that appear in a small number of clauses first so that
we maximize the chance of early abort in the critical loops above.&lt;p&gt; \anchor _todo001911 (user): No need to add this clause if we know it cannot subsume
any new clause since last round. i.e. unchanged clause that do not
contains any literals of newly added clause do not need to be added
here. We can track two bitset in LiteralWatchers via a register
mechanism:
- literal of newly watched clauses since last clear.
- literal of reduced clauses since last clear.&lt;p&gt; \anchor _todo001910 (user): remove first and see if other still removable. Alternatively
use a "removed" marker and redo a check for each clause that simplifies
this one? Or just remove the first one, and wait for next round. 
 &lt;p&gt; \anchor _todo001909 (user): Do some reduction using binary clauses. Note that only clause
that never propagated since last round need to be checked for binary
subsumption. 
 &lt;p&gt; \anchor _todo001914 (user): tune the deterministic time.
 &lt;p&gt; \anchor _todo001903 (user): Use better work limits, see SAT09.CRAFTED.ramseycube.Q3inK12&lt;p&gt; \anchor _todo001907 (user): Storing signatures here might be faster? 
 &lt;p&gt; \anchor _todo001908 (user): Better abort limit. We could also limit the watcher sizes and
never look at really long clauses. Note that for an easier
incrementality, it is better to reach some kind of completion so we know
what new stuff need to be done. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Class \_internalref classoperations__research_1_1sat_1_1IntegerEncoder "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">operations_research::sat::IntegerEncoder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001478 (user): We could also lazily create precedences Booleans between two
arbitrary IntegerVariable. This is better done in the PrecedencesPropagator
though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a1a4e1df43e180231715e6fde6b4d0a8d "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1a4e1df43e180231715e6fde6b4d0a8d">operations_research::sat::IntegerEncoder::Canonicalize</a>" (IntegerLiteral i_lit) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001484 (user): This is linear in the domain "complexity", we can do better if
needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a44f7926d822f4f2f659be6f503090ac4 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a44f7926d822f4f2f659be6f503090ac4">operations_research::sat::IntegerEncoder::FullyEncodeVariable</a>" (IntegerVariable var)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001450 (user): Currently, in some corner cases,
GetOrCreateLiteralAssociatedToEquality() might trigger some propagation
that update the domain of var, so we need to cache the values to not read
garbage. Note that it is okay to call the function on values no longer
reachable, as this will just do nothing. 
 &lt;p&gt; \anchor _todo001483 (user): It is currently only possible to call that at the decision
level zero because we cannot add ternary clause in the middle of the
search (for now). This is Checked. 
 &lt;p&gt; \anchor _todo001449 (user): Maybe we can optimize the literal creation order and their
polarity as our default SAT heuristics initially depends on this.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a86897b73c47086f4bc261f9424b47de7 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a86897b73c47086f4bc261f9424b47de7">operations_research::sat::IntegerEncoder::GetOrCreateAssociatedLiteral</a>" (IntegerLiteral i_lit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001453 (user): on some problem this happens. We should probably make sure that
we don't create extra fixed Boolean variable for no reason. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#af0a2aeea649e70334c5b44dca14a5ae2 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#af0a2aeea649e70334c5b44dca14a5ae2">operations_research::sat::IntegerEncoder::GetOrCreateLiteralAssociatedToEquality</a>" (IntegerVariable var, IntegerValue value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001454 (user): this happens on some problem. We should probably
make sure that we don't create extra fixed Boolean variable for no reason.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a59abe9efe4246f146066483c1955e602 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a59abe9efe4246f146066483c1955e602">operations_research::sat::IntegerEncoder::VariableIsFullyEncoded</a>" (IntegerVariable var) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001451 (user): Cache result as long as equality_by_var_[index] is unchanged?
It might not be needed since if the variable is not fully encoded, then
PartialDomainEncoding() will filter unreachable values, and so the size
check will be false until further value have been encoded. 
 &lt;p&gt; \anchor _todo001452 (user): Comparing the size might be enough, but we want to be always
valid even if either (*domains_[var]) or PartialDomainEncoding(var) are
not properly synced because the propagation is not finished. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerRoundingCutHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerRoundingCutHelper#a55348bee0f2fe5505e28cc64ddfb1404 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerRoundingCutHelper.html#a55348bee0f2fe5505e28cc64ddfb1404" title="Returns true on success. The cut can be accessed via cut().">operations_research::sat::IntegerRoundingCutHelper::ComputeCut</a>" (RoundingOptions options, const CutData &amp;base_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001359 (user): This is slow, 50% of run time on a2c1s1.pb.gz. Optimize!
 &lt;p&gt; \anchor _todo001366 (user): It is still unclear if we have a * X + b * (1 - X) &lt;= rhs
for a Boolean X, what is the best way to apply f and if we should merge
the terms. If there is no other terms, best is probably
f(rhs - a) * X + f(rhs - b) * (1 - X). 
 &lt;p&gt; \anchor _todo001365 (user): If the slack is close to zero, then this transformation
will always increase the violation. So we could potentially do it in
Before our divisor selection heuristic. But the norm of the final cut
will increase too. 
 &lt;p&gt; \anchor _todo001364 (user): Note that while the violation might be higher, if the slack
becomes large this will result in a less powerfull cut. Shall we do
that? It is a bit the same problematic with complementing.&lt;p&gt; \anchor _todo001363 (user): Avoid quadratic algorithm? Note that we are quadratic in
relevant positions not the full cut size, but this is still too much on
some problems. 
 &lt;p&gt; \anchor _todo001362 (user): If the rhs is small and close to zero, we might want to
consider different way of complementing the variables. 
 &lt;p&gt; \anchor _todo001361 (user): Experiment for the best value of this initial violation
threshold. Note also that we use the l2 norm on the restricted position
here. Maybe we should change that? On that note, the L2 norm usage seems
a bit weird to me since it grows with the number of term in the cut. And
often, we already have a good cut, and we make it stronger by adding
extra terms that do not change its activity.&lt;p&gt; \anchor _todo001360 (user): We assume that this is called with and without the option
use_ib_before_heuristic, so that we can abort if no IB has been applied
since then we will redo the computation. This is not really clean. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#ac8f66768737022f2d24fa3b0c73dfcca "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#ac8f66768737022f2d24fa3b0c73dfcca">operations_research::sat::IntegerSearchHelper::GetDecision</a>" (const std::function&lt; BooleanOrIntegerLiteral()&gt; &amp;f)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001531 (user): Ideally it would be cool to delay the creation even more
until we have a conflict with these decisions, but it is currrently
hard to do so. 
 &lt;p&gt; \anchor _todo001532 (user): It would be nicer if this can never happen. For now, it
does because of the Propagate() not reaching the fixed point as
mentionned in a&lt;p&gt; \anchor _todo001533 &lt;p&gt; \anchor _todo001534 above. As a work-around, we display a message
but do not crash and recall the decision heuristic. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#aee604e664f5122db61cd4c73f437be2a "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#aee604e664f5122db61cd4c73f437be2a">operations_research::sat::IntegerSearchHelper::SolveIntegerProblem</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001539 (user): Avoid adding the same solution many time if the LP didn't
change. Avoid adding solution that are too deep in the tree (most
variable fixed). Also use a callback rather than having this here, we
don't want this file to depend on cp_model.proto. 
 &lt;p&gt; \anchor _todo001538 (user): Experiment more around dynamically changing the
threshold for storing LP solutions in the pool. Alternatively expose
this as parameter so this can be tuned later.&lt;p&gt; \anchor _todo001537 (user): Be smarter about what variables we probe, we can
also do more than one. 
 &lt;p&gt; \anchor _todo001536 (user): We have the issue that at level zero. calling the propagation
loop more than once can propagate more! This is because we call the LP
again and again on each level zero propagation. This is causing some
CHECKs() to fail in multithread (rarely) because when we associate new
literals to integer ones, Propagate() is indirectly called. Not sure yet
how to fix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#a2e2faa726399df6f91e4dc89d9ed5117 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#a2e2faa726399df6f91e4dc89d9ed5117">operations_research::sat::IntegerSearchHelper::TakeDecision</a>" (Literal decision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001535 (user): on some problems, this function can be quite long. Expand
so that we can check the time limit at each step? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSumLE Class \_internalref classoperations__research_1_1sat_1_1IntegerSumLE "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSumLE.html">operations_research::sat::IntegerSumLE</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001505 (user): If one has many such constraint, it will be more efficient to
propagate all of them at once rather than doing it one at the time.&lt;p&gt; \anchor _todo001506 (user): Explore tree structure to get a log(n) complexity.&lt;p&gt; \anchor _todo001507 (user): When the variables are Boolean, use directly the pseudo-Boolean
constraint implementation. But we do need support for enforcement literals
there. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSumLE Member \_internalref classoperations__research_1_1sat_1_1IntegerSumLE#abb2c0f7b0e805ca6350fe0b75d979fd8 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSumLE.html#abb2c0f7b0e805ca6350fe0b75d979fd8">operations_research::sat::IntegerSumLE::ConditionalLb</a>" (IntegerLiteral integer_literal, IntegerVariable target_var) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001496 (user): If there is a conflict (negative slack) we can be more
precise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSumLE Member \_internalref classoperations__research_1_1sat_1_1IntegerSumLE#ad5010fe548e30457685bdf8ff7b10d60 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSumLE.html#ad5010fe548e30457685bdf8ff7b10d60">operations_research::sat::IntegerSumLE::IntegerSumLE</a>" (const std::vector&lt; Literal &gt; &amp;enforcement_literals, const std::vector&lt; IntegerVariable &gt; &amp;vars, const std::vector&lt; IntegerValue &gt; &amp;coeffs, IntegerValue upper_bound, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001495 (user): deal with this corner case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSumLE Member \_internalref classoperations__research_1_1sat_1_1IntegerSumLE#a46c7869ce1d0dbea39e1f3eff1c05412 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSumLE.html#a46c7869ce1d0dbea39e1f3eff1c05412">operations_research::sat::IntegerSumLE::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001497 (user): If the new ub fall into an hole of the variable, we can
actually relax the reason more by computing a better slack. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSumLE Member \_internalref classoperations__research_1_1sat_1_1IntegerSumLE#a0751f50c92f3b09e17df7f1ed7c642f4 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSumLE.html#a0751f50c92f3b09e17df7f1ed7c642f4">operations_research::sat::IntegerSumLE::PropagateAtLevelZero</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001498 (user): Deal with enforcements. It is just a bit of code to read the
value of the literals at level zero. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSumLE Member \_internalref classoperations__research_1_1sat_1_1IntegerSumLE#a6bd8fa63a52c3539502e867177c378ce "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSumLE.html#a6bd8fa63a52c3539502e867177c378ce">operations_research::sat::IntegerSumLE::RegisterWith</a>" (GenericLiteralWatcher *watcher)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001499 (user): if there is more than one, maybe we should watch more to
propagate a "conflict" as soon as only one is unassigned? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#aebbb45a8a0ccb613694b2b739f904837 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#aebbb45a8a0ccb613694b2b739f904837">operations_research::sat::IntegerTrail::AddIntegerVariable</a>" (IntegerValue lower_bound, IntegerValue upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001458 (user): the is_ignored_literals_ Booleans are currently always the same
for a variable and its negation. So it may be better not to store it twice
so that we don't have to be careful when setting them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a838d2c31760b5b9f554ea080ad6cb74a "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a838d2c31760b5b9f554ea080ad6cb74a">operations_research::sat::IntegerTrail::AppendNewBounds</a>" (std::vector&lt; IntegerLiteral &gt; *output) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001472 (user): Implement a dense version if there is more trail entries
than variables! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a07f3c5bf9ad7390cb25efb3f6a0de3b3 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a07f3c5bf9ad7390cb25efb3f6a0de3b3">operations_research::sat::IntegerTrail::ConditionalEnqueue</a>" (Literal lit, IntegerLiteral i_lit, std::vector&lt; Literal &gt; *literal_reason, std::vector&lt; IntegerLiteral &gt; *integer_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001461 (user): we can also push lit.var if its presence implies lit. 
 &lt;p&gt; \anchor _todo001462 (user): We could even keep the reason and maybe do some reasoning using
at_least_one constraint on a set of the Boolean used here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#ae5d98735536061f5c38f91ddd6a0b073 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#aa5f3f24dfc832d45939478360f2a9ef1">operations_research::sat::IntegerTrail::Enqueue</a>" (IntegerLiteral i_lit, absl::Span&lt; const Literal &gt; literal_reason, absl::Span&lt; const IntegerLiteral &gt; integer_reason, int trail_index_with_same_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001491 (user): This currently cannot refer to a trail_index with a lazy
reason. Fix or at least check that this is the case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#aa5f3f24dfc832d45939478360f2a9ef1 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#aa5f3f24dfc832d45939478360f2a9ef1">operations_research::sat::IntegerTrail::Enqueue</a>" (IntegerLiteral i_lit, absl::Span&lt; const Literal &gt; literal_reason, absl::Span&lt; const IntegerLiteral &gt; integer_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001490 (user): If the given bound is equal to the current bound, maybe the new
reason is better? how to decide and what to do in this case? to think about
it. Currently we simply don't do anything. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#ae3ea8da78f7a6ec038887174bbad6ceb "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#ae3ea8da78f7a6ec038887174bbad6ceb">operations_research::sat::IntegerTrail::Propagate</a>" (Trail *trail) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001457 (user): refactor the interaction IntegerTrail &lt;-&gt; IntegerEncoder so
that we can just push right away such literal. Unfortunately, this is is
a big chunck of work. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a090881ffd3442b49e6e858dd6cc9f433 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a090881ffd3442b49e6e858dd6cc9f433">operations_research::sat::IntegerTrail::Reason</a>" (const Trail &amp;trail, int trail_index) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001471 (user): If this is called many time on the same variables, it could be
made faster by using some caching mecanism. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a3f82268fd6c91332511a3d8765d6d07f "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a3f82268fd6c91332511a3d8765d6d07f">operations_research::sat::IntegerTrail::RelaxLinearReason</a>" (IntegerValue slack, absl::Span&lt; const IntegerValue &gt; coeffs, std::vector&lt; IntegerLiteral &gt; *reason) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001460 (user): Get rid of this function and only keep the trail index one?
 &lt;p&gt; \anchor _todo001487 (user): Requiring all initial literal to be at their current bound is
not really clean. Maybe we can change the API to only take IntegerVariable
and produce the reason directly.&lt;p&gt; \anchor _todo001488 (user): change API so that this work is performed during the conflict
analysis where we can be smarter in how we relax the reason. Note however
that this function is mainly used when we have a conflict, so this is not
really high priority.&lt;p&gt; \anchor _todo001489 (user): Test that the code work in the presence of integer overflow. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a86dbd554c727e96c1ce6e33a54a73235 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a86dbd554c727e96c1ce6e33a54a73235">operations_research::sat::IntegerTrail::UpdateInitialDomain</a>" (IntegerVariable var, Domain domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001486 (user): There is some memory inefficiency if this is called many time
because of the underlying data structure we use. In practice, when used
with a presolve, this is not often used, so that is fine though. 
 &lt;p&gt; \anchor _todo001459 (user): That works, but it might be better to simply update the
bounds here directly. This is because these function might call again
UpdateInitialDomain(), and we will abort after realizing that the domain
didn't change this time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4f8e9410f7631560e2efea8f401e5aa1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4f8e9410f7631560e2efea8f401e5aa1">operations_research::sat::IntegerValueSelectionHeuristic</a>" (std::function&lt; BooleanOrIntegerLiteral()&gt; var_selection_heuristic, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001522 (user): Experiment more with value selection heuristics.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntervalsRepository Member \_internalref classoperations__research_1_1sat_1_1IntervalsRepository#a4b03c53df090c629b60810eb286708d0 "<a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html#a4b03c53df090c629b60810eb286708d0">operations_research::sat::IntervalsRepository::GetOrCreateHelper</a>" (const std::vector&lt; IntervalVariable &gt; &amp;variables)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001544 (user): Ideally we should sort the vector of variables, but right now
we cannot since we often use this with a parallel vector of demands. So this
"sorting" should happen in the presolver so we can share as much as possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad18474efb6207fd449bb3f452a2bbe5b "<a class="el" href="namespaceoperations__research_1_1sat.html#ad18474efb6207fd449bb3f452a2bbe5b" title="This requires that all the alternatives are optional tasks.">operations_research::sat::IntervalWithAlternatives</a>" (IntervalVariable parent, const std::vector&lt; IntervalVariable &gt; &amp;members)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001551 (user): IsOneOf() only work for members with fixed size.
Generalize to an "int_var_element" constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Class \_internalref classoperations__research_1_1sat_1_1LbTreeSearch "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html">operations_research::sat::LbTreeSearch</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001574 (user): What this is doing is really similar to asking a SAT solver if
the current objective lower bound is reachable by solving a SAT problem.
However, this code handle on the side all the "conflict" of the form
objective &gt; current_lb. As a result, when it is UNSAT, we can bump the lower
bound by a bigger amount than one. We also do not completely loose everything
learned so far for the next iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Member \_internalref classoperations__research_1_1sat_1_1LbTreeSearch#ab578e3dd57e9e2c0daff912371d19dc2 "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab578e3dd57e9e2c0daff912371d19dc2">operations_research::sat::LbTreeSearch::LbTreeSearch</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001558 (user): if we have many independent LP, this will find nothing. 
 &lt;p&gt; \anchor _todo001557 (user): Starts with an initial variable score for all variable in
the objective at their minimum value? this should emulate the first step of
the core approach and gives a similar bound. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Member \_internalref classoperations__research_1_1sat_1_1LbTreeSearch#ab5eed5bfd114852c086831f49823d8ba "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab5eed5bfd114852c086831f49823d8ba" title="Explores the search space.">operations_research::sat::LbTreeSearch::Search</a>" (const std::function&lt; void()&gt; &amp;feasible_solution_observer)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001559 (user): a strong branching initial start, or allowing a few decision
per nodes might be a better approach.&lt;p&gt; \anchor _todo001560 (user): It would also be cool to exploit the reason for the LB increase
even more. 
 &lt;p&gt; \anchor _todo001561 (user): No point checking that if the objective lb wasn't
assigned at this level.&lt;p&gt; \anchor _todo001562 (user): Exploit the reasons further. 
 &lt;p&gt; \anchor _todo001563 (user): This is slightly different than bumping each time we
push a decision that result in an LB increase. This is also called on
backjump for instance. 
 &lt;p&gt; \anchor _todo001570 (user): We could do all at once rather than in O(#decision * #size). 
 &lt;p&gt; \anchor _todo001569 (user): Uses old optimal constraint that we just potentially
backtracked over?&lt;p&gt; \anchor _todo001568 (user): Try to minimize the number of decisions? 
 &lt;p&gt; \anchor _todo001567 (user): We sometimes branch on the objective variable, this should
probably be avoided. 
 &lt;p&gt; \anchor _todo001566 (user): In multithread, this change the behavior a lot since we
dive until we beat the best shared bound. Maybe we shouldn't do that. 
 &lt;p&gt; \anchor _todo001565 (user): If we have new information and our current objective bound
is higher than any bound in a whole subtree, we might want to just
restart this subtree exploration? 
 &lt;p&gt; \anchor _todo001564 (user): If we remember how far we can backjump for both true/false
branch, we could be more efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LevelZeroEquality Member \_internalref classoperations__research_1_1sat_1_1LevelZeroEquality#a6f4c89def00ad8b950b31383f59ba094 "<a class="el" href="classoperations__research_1_1sat_1_1LevelZeroEquality.html#a6f4c89def00ad8b950b31383f59ba094">operations_research::sat::LevelZeroEquality::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001501 (user): Once the GCD is not 1, we could at any level make sure the
objective is of the correct form. For now, this only happen in a few
miplib problem that we close quickly, so I didn't add the extra code yet. 
 &lt;p&gt; \anchor _todo001500 (user): We could go even further than just the GCD, and do more
arithmetic to tighten the target bounds. See for instance a problem like
ej.mps.gz that we don't solve easily, but has just 3 variables! the goal is
to minimize X, given 31013 X - 41014 Y - 51015 Z = -31013 (all &gt;=0, Y and Z
bounded with high values). I know some MIP solvers have a basic linear
diophantine equation support. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a18679d8902d037df4ad5371ab25ad435 "<a class="el" href="namespaceoperations__research_1_1sat.html#a18679d8902d037df4ad5371ab25ad435">operations_research::sat::LinearBooleanProblemToCnfString</a>" (const LinearBooleanProblem &amp;problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000921 (user): implement this trick. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Class \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html">operations_research::sat::LinearConstraintBuilder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001580 (user): Rename to LinearExpressionBuilder? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a4a3f6799dadae4d157ae00fc941244d0 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a4a3f6799dadae4d157ae00fc941244d0">operations_research::sat::LinearConstraintBuilder::AddDecomposedProduct</a>" (const std::vector&lt; LiteralValueValue &gt; &amp;product)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001575 (user): Checks the value of literals.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a00685724ff7957bd0b8dbb337b2eacd6 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a00685724ff7957bd0b8dbb337b2eacd6">operations_research::sat::LinearConstraintBuilder::AddQuadraticLowerBound</a>" (AffineExpression left, AffineExpression right, IntegerTrail *integer_trail, bool *is_quadratic=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001583 (user): We could use (max - delta) instead of (min + delta) for each
expression instead. This would depend on the LP value of the left and
right. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a2b9598a931a588949a8b5f5af8304ead "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a2b9598a931a588949a8b5f5af8304ead">operations_research::sat::LinearConstraintBuilder::Build</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001584 (user): this doesn't invalidate the builder object, but if one wants
to do a lot of dynamic editing to the constraint, then then underlying
algorithm needs to be optimized for that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a029e8c7ac32054484a98093c2ad7629a "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a9c3eb68e76b59f3aae54a9d8cd4cf42e">operations_research::sat::LinearConstraintBuilder::LinearConstraintBuilder</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001582 (user): Have a subclass so we can enforce than caller using
AddLiteralTerm() must construct the Builder with an encoder. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintManager#a6702a060141780d0911391aa10c00be0 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html#a6702a060141780d0911391aa10c00be0">operations_research::sat::LinearConstraintManager::AddCut</a>" (const LinearConstraint &amp;ct, std::string type_name, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_solution, std::string extra_info="")&lt;/dt&gt;&lt;dd&gt; \anchor _todo001586 (user): Use better heuristic here for detecting good cuts and mark
them undeletable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintManager#ac438135905dc41a208cf3b6dab1c5347 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html#ac438135905dc41a208cf3b6dab1c5347">operations_research::sat::LinearConstraintManager::ChangeLp</a>" (const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_solution, glop::BasisState *solution_state, int *num_new_constraints=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001590 (user): Because we simplified this constraint, it is possible that
it is now a duplicate of another one. Merge them. 
 &lt;p&gt; \anchor _todo001591 (user): This blowup factor could be adaptative w.r.t. the constraint
limit. 
 &lt;p&gt; \anchor _todo001592 (user): Experiment with different weights or different
functions for computing score. 
 &lt;p&gt; \anchor _todo001593 (user): Instead of comparing num_deletable_constraints with cut
limit, compare number of deletable constraints not in lp against the limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager::ConstraintInfo Member \_internalref structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo#abdf73acb15ffe53b95a4131d9ba9aac9 "<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo.html#abdf73acb15ffe53b95a4131d9ba9aac9">operations_research::sat::LinearConstraintManager::ConstraintInfo::is_deletable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001596 (user): We can have a better heuristics. Some generated good cuts
can be marked undeletable and some unused problem specified constraints
can be marked deletable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a60a7841c41c906aac164828c54916470 "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a60a7841c41c906aac164828c54916470">operations_research::sat::LinearProgrammingConstraint::HeuristicLpMostInfeasibleBinary</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001651 (user): This fixes to 1, but for some problems fixing to 0
or to the std::round(support value) might work better. When this is the
case, change behaviour automatically? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#abf4522ba63d97a87183de380a0336eec "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#abf4522ba63d97a87183de380a0336eec">operations_research::sat::LinearProgrammingConstraint::HeuristicLpReducedCostAverageBranching</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001646 (user): Remove duplication with HeuristicLpReducedCostBinary().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a858aa1eed5858a7764f4ee02a05f1fce "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a858aa1eed5858a7764f4ee02a05f1fce">operations_research::sat::LinearProgrammingConstraint::HeuristicLpReducedCostBinary</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001652 (user): Try to get better pseudocosts than averaging every time
the heuristic is called. MIP solvers initialize this with strong branching,
then keep track of the pseudocosts when doing tree search. Also, this
version only branches on var &gt;= 1 and keeps track of reduced costs from var
= 1 to var = 0. This works better than the conventional MIP where the
chosen variable will be argmax_var min(pseudocost_var(0-&gt;1),
pseudocost_var(1-&gt;0)), probably because we are doing DFS search where MIP
does BFS. This might depend on the model, more trials are necessary. We
could also do exponential smoothing instead of decaying every N calls, i.e.
pseudo = a * pseudo + (1-a) reduced. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#ac0030221b056d71c560de62bd9d57a09 "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#ac0030221b056d71c560de62bd9d57a09">operations_research::sat::LinearProgrammingConstraint::IncrementalPropagate</a>" (const std::vector&lt; int &gt; &amp;watch_indices) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001608 (user): Propagate the last optimal_constraint? Note that we need
to be careful since the reversible int in IntegerSumLE are not registered.
However, because we delete "optimalconstraints" on backtrack, we might not
care. 
 &lt;p&gt; \anchor _todo001607 (user): The saved lp solution is still valid given the current variable
bounds, so the LP optimal didn't change. However we might still want to add
new cuts or new lazy constraints?&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#ac305ae4d90e003c68c190a412f9879de "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#ac305ae4d90e003c68c190a412f9879de">operations_research::sat::LinearProgrammingConstraint::LinearProgrammingConstraint</a>" (Model *model, absl::Span&lt; const IntegerVariable &gt; vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001598 (user): make SatParameters singleton too, otherwise changing them after
a constraint was added will have no effect on this class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a7ff29ebe58aca89b537dc833cc1c45de "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a7ff29ebe58aca89b537dc833cc1c45de" title="PropagatorInterface API.">operations_research::sat::LinearProgrammingConstraint::Propagate</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001632 (user): It seems the time we loose by not stopping early might be worth
it because we end up with a better explanation at optimality. 
 &lt;p&gt; \anchor _todo001634 (user): Is this the best place for this ?
 &lt;p&gt; \anchor _todo001633 (user): Refactor so that they are just normal cut generators? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a6f4001652e985a2165ad4d6602eae29b "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a6f4001652e985a2165ad4d6602eae29b" title="ReversibleInterface API.">operations_research::sat::LinearProgrammingConstraint::SetLevel</a>" (int level) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001605 &lt;p&gt; \anchor _todo001604 (user): Keep all optimal solution in the current branch?
&lt;p&gt; \anchor _todo001606 (user): Still try to add cuts/constraints though! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraintLpSolution Class \_internalref structoperations__research_1_1sat_1_1LinearProgrammingConstraintLpSolution "<a class="el" href="structoperations__research_1_1sat_1_1LinearProgrammingConstraintLpSolution.html">operations_research::sat::LinearProgrammingConstraintLpSolution</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001649 (user): find a better way? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Class \_internalref classoperations__research_1_1sat_1_1LinearPropagator "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html">operations_research::sat::LinearPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001672 (user): This is a work in progress and is currently incomplete:
- Lack more incremental support for faster propag.
- Lack detection and propagation of at least one of these linear is true
  which can be used to propagate more bound if a variable appear in all these
  constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a4e95cfcc375691350ee68c913978a6a4 "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a4e95cfcc375691350ee68c913978a6a4" title="Adds a new constraint to the propagator.">operations_research::sat::LinearPropagator::AddConstraint</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const IntegerValue &gt; coeffs, IntegerValue upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001656 (user): we still waste the space in coeffs_buffer_ so that the
start are aligned with the variables_buffer_. 
 &lt;p&gt; \anchor _todo001657 (user): With some care, when we cannot propagate or the
constraint is not enforced, we could live in_queue_[] at true but
not put the constraint in the queue. 
 &lt;p&gt; \anchor _todo001658 (user): Shall we decide on some ordering here? maybe big coeff first
so that we get the largest change in slack? the idea being to propagate
large change first in case of cycles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a615cc74a74066501e840dcc2343738ec "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a615cc74a74066501e840dcc2343738ec">operations_research::sat::LinearPropagator::LinearPropagator</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001654 (user): When we start to push too much (Cycle?) we should see what
other propagator says before repropagating this one, system for call
later? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a74432b1f2031ef1a7257cf98913c7390 "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a74432b1f2031ef1a7257cf98913c7390">operations_research::sat::LinearPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001655 (user): Abort this propagator as soon as a Boolean is propagated ? so
that we always finish the Boolean propagation first. This can happen when
we push a bound that has associated Booleans. The idea is to resume from
our current state when we are called again. Note however that we have to
clear the propagated_by_ info has other propagator might have pushed the
same variable further.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LiteralWatchers Class \_internalref classoperations__research_1_1sat_1_1LiteralWatchers "<a class="el" href="classoperations__research_1_1sat_1_1LiteralWatchers.html">operations_research::sat::LiteralWatchers</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000960 (user): Rename ClauseManager. This does more than just watching the
clauses and is the place where all the clauses are stored. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LiteralWatchers Member \_internalref classoperations__research_1_1sat_1_1LiteralWatchers#aacf44059a1112045e8e80230a828cb7a "<a class="el" href="classoperations__research_1_1sat_1_1LiteralWatchers.html#aacf44059a1112045e8e80230a828cb7a">operations_research::sat::LiteralWatchers::Detach</a>" (SatClause *clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000962 (user): It might be better to have a "slower" mode in
PropagateOnFalse() that deal with detached clauses in the watcher list and
is activated until the next CleanUpWatchers() calls. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LiteralWatchers Member \_internalref classoperations__research_1_1sat_1_1LiteralWatchers#ac9b1ba64d59bff4b3b59e84882fae780 "<a class="el" href="classoperations__research_1_1sat_1_1LiteralWatchers.html#ac9b1ba64d59bff4b3b59e84882fae780">operations_research::sat::LiteralWatchers::InprocessingAddClause</a>" (absl::Span&lt; const Literal &gt; new_clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000940 (user): We should return false...
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LiteralWatchers Member \_internalref classoperations__research_1_1sat_1_1LiteralWatchers#a73bed1fe790f708d6a9e230d851d56ef "<a class="el" href="classoperations__research_1_1sat_1_1LiteralWatchers.html#a73bed1fe790f708d6a9e230d851d56ef" title="This one do not need the clause to be detached.">operations_research::sat::LiteralWatchers::InprocessingFixLiteral</a>" (Literal true_literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000938 (user): remove the test when the DRAT issue with fixed literal is
resolved. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LiteralWatchers Member \_internalref classoperations__research_1_1sat_1_1LiteralWatchers#a9543e2a1f4eecbbd695038a51eb20beb "<a class="el" href="classoperations__research_1_1sat_1_1LiteralWatchers.html#a9543e2a1f4eecbbd695038a51eb20beb" title="These must only be called between [Detach/Attach]AllClauses() calls.">operations_research::sat::LiteralWatchers::InprocessingRemoveClause</a>" (SatClause *clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000939 (user): We could do something slower if the clauses are attached like
we do for InprocessingRewriteClause(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0df7b56e0026b783deeeff20487de7cf "<a class="el" href="namespaceoperations__research_1_1sat.html#a0df7b56e0026b783deeeff20487de7cf" title="Loads a BooleanProblem into a given SatSolver instance.">operations_research::sat::LoadBooleanProblem</a>" (const LinearBooleanProblem &amp;problem, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000920 (user): Currently, the sat solver can load without any issue
constraints with duplicate variables, so we just output a warning if the
problem is not "valid". Make this a strong check once we have some
preprocessing step to remove duplicates variable in the constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a64c230730625662a2a2032da620b6c6e "<a class="el" href="namespaceoperations__research_1_1sat.html#a64c230730625662a2a2032da620b6c6e">operations_research::sat::LoadBooleanSymmetries</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001050 (user): We currently only have the code for Booleans, it is why we
currently ignore symmetries involving integer variables. 
 &lt;p&gt; \anchor _todo001035 (user): We could add these extra Boolean during expansion/presolve so
that we have the symmetry involing them. Or maybe comes up with a different
solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4b4da650bfcb86c00bee1df0ab0cc953 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4b4da650bfcb86c00bee1df0ab0cc953">operations_research::sat::LoadConditionalLinearConstraint</a>" (const absl::Span&lt; const Literal &gt; enforcement_literals, const LinearConstraint &amp;cst, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001514 (user): Remove the conversion!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a899896953b6215b01cb0b85caa96bebe "<a class="el" href="namespaceoperations__research_1_1sat.html#ade08c3522dfce173ee1fd50fab3bd3c0">operations_research::sat::LoadLinearConstraint</a>" (const LinearConstraint &amp;cst, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001513 (user): Remove the conversion!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ade08c3522dfce173ee1fd50fab3bd3c0 "<a class="el" href="namespaceoperations__research_1_1sat.html#ade08c3522dfce173ee1fd50fab3bd3c0">operations_research::sat::LoadLinearConstraint</a>" (const ConstraintProto &amp;ct, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001048 (user): we should probably also implement an
half-reified version of this constraint. 
 &lt;p&gt; \anchor _todo001047 (user): Reuse ComputeLinearBounds()? but then we need another loop
to detect if we only have Booleans. 
 &lt;p&gt; \anchor _todo001046 (user): Actually this should never be called since we process
linear1 in ExtractEncoding(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a23861bab6341cfcfeeff90c2b3e3ab7e "<a class="el" href="namespaceoperations__research_1_1sat.html#a23861bab6341cfcfeeff90c2b3e3ab7e">operations_research::sat::LoadLinMaxConstraint</a>" (const ConstraintProto &amp;ct, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001049 (user): Consider replacing the min propagator by max.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0f015dd7f088e0a586993ec925a94ced "<a class="el" href="namespaceoperations__research_1_1sat.html#a0f015dd7f088e0a586993ec925a94ced">operations_research::sat::LoadModelForProbing</a>" (PresolveContext *context, Model *local_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001833 (user): remove code duplication with cp_model_solver. Here we also do
not run the heuristic to decide which variable to fully encode.&lt;p&gt; \anchor _todo001834 (user): Maybe do not load slow to propagate constraints? for instance
we do not use any linear relaxation here. 
 &lt;p&gt; \anchor _todo001832 (user): The model we load does not contain affine relations! But
ideally we should be able to remove all of them once we allow more complex
constraints to contains linear expression.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a47e5d5cb3e7eb43191d094fc4752b5c6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a47e5d5cb3e7eb43191d094fc4752b5c6">operations_research::sat::LoadVariables</a>" (const CpModelProto &amp;model_proto, bool view_all_booleans_as_integers, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001034 (user): Fix the constant variable situation. An optional interval
with constant start/end or size cannot share the same constant
variable if it is used in non-optional situation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af004193a12bf9ed78b295e7f7cb51e6f "<a class="el" href="namespaceoperations__research_1_1sat.html#af004193a12bf9ed78b295e7f7cb51e6f">operations_research::sat::MinimizeCore</a>" (SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001986 (user): One should use MinimizeCoreWithPropagation() instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4d6ba15542ec5d59958de53c92279b2a "<a class="el" href="namespaceoperations__research_1_1sat.html#a4d6ba15542ec5d59958de53c92279b2a">operations_research::sat::MinimizeCoreWithPropagation</a>" (TimeLimit *limit, SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001751 (user): Avoid spending too much time trying to minimize a core. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MinPropagator Class \_internalref classoperations__research_1_1sat_1_1MinPropagator "<a class="el" href="classoperations__research_1_1sat_1_1MinPropagator.html">operations_research::sat::MinPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001508 (user): Implement a more efficient algorithm when the need arise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MinPropagator Member \_internalref classoperations__research_1_1sat_1_1MinPropagator#aa5ab4a97c4fe03823494846846b5accd "<a class="el" href="classoperations__research_1_1sat_1_1MinPropagator.html#aa5ab4a97c4fe03823494846846b5accd">operations_research::sat::MinPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001502 (user): Not sure this code is useful since this will be detected
by the fact that the [lb, ub] of the min is empty. It depends on the
propagation order though, but probably the precedences propagator would
propagate before this one. So change this to a CHECK? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Model Member \_internalref classoperations__research_1_1sat_1_1Model#ad025b208280b29fc3cfe2b7d3d61c8f9 "<a class="el" href="classoperations__research_1_1sat_1_1Model.html#ad025b208280b29fc3cfe2b7d3d61c8f9">operations_research::sat::Model::GetOrCreate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001722 (user): directly store std::unique_ptr&lt;&gt; in singletons_? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ModelCopy Member \_internalref classoperations__research_1_1sat_1_1ModelCopy#ad5ffb10813c76e724acd11e0cfeb5ced "<a class="el" href="classoperations__research_1_1sat_1_1ModelCopy.html#ad5ffb10813c76e724acd11e0cfeb5ced">operations_research::sat::ModelCopy::ImportAndSimplifyConstraints</a>" (const CpModelProto &amp;in_model, const std::vector&lt; int &gt; &amp;ignored_constraints, bool first_copy=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001197 (user): Merge with the phase 1 of the presolve code.&lt;p&gt; \anchor _todo001200 (user): find a better way than copy then clear_name()?
 &lt;p&gt; \anchor _todo001199 (user): if ignore_names is false, we should make sure the
name are properly copied by all these functions. Or we should never copy
name and have a separate if (!ignore_name) copy the name... 
 &lt;p&gt; \anchor _todo001198 (user): It seems easy to forget to update this if any new constraint
contains an interval or if we add a field to an existing constraint. Find a
way to remind contributor to not forget this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ModelRandomGenerator Member \_internalref classoperations__research_1_1sat_1_1ModelRandomGenerator#a94be5f7295c63407b5efb55e55724391 "<a class="el" href="classoperations__research_1_1sat_1_1ModelRandomGenerator.html#a94be5f7295c63407b5efb55e55724391">operations_research::sat::ModelRandomGenerator::LogSalt</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002089 (user): I didn't find a cleaner way to log this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a4a9b63c72d02a80a8f76efbb0f020a3f "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a4a9b63c72d02a80a8f76efbb0f020a3f">operations_research::sat::MutableUpperBoundedLinearConstraint::ClearAll</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001762 (user): We could be more efficient and have only one loop here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a56db11b9d396d13e4cff87b74b086d81 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a56db11b9d396d13e4cff87b74b086d81">operations_research::sat::MutableUpperBoundedLinearConstraint::ComputeSlackForTrailPrefix</a>" (const Trail &amp;trail, int trail_index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001764 (user): Keep this for DCHECK(), but maintain the slack incrementally
instead of recomputing it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a467eaf21318efb233670a0035a2eae34 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a467eaf21318efb233670a0035a2eae34">operations_research::sat::MutableUpperBoundedLinearConstraint::ReduceCoefficients</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001763 (user): Also reduce the trivially false literal when coeff &gt; rhs_ ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a2d8ea04aaae8c892a39770e35eced029 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a2d8ea04aaae8c892a39770e35eced029">operations_research::sat::MutableUpperBoundedLinearConstraint::ReduceCoefficientsAndComputeSlackForTrailPrefix</a>" (const Trail &amp;trail, int trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001778 (user): Ideally the slack should be maitainable incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Neighborhood Member \_internalref structoperations__research_1_1sat_1_1Neighborhood#a9d77507f928ca9524da987bfbf75eee8 "<a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html#a9d77507f928ca9524da987bfbf75eee8">operations_research::sat::Neighborhood::id</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001029 (user): Make sure that the id is unique for each generated
neighborhood for each generator. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGenerator#a4855f651eceaa493b36eec2524b05794 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGenerator.html#a4855f651eceaa493b36eec2524b05794">operations_research::sat::NeighborhoodGenerator::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001018 (user): Weight more recent data.
degrade the current average to forget old learnings. 
 &lt;p&gt; \anchor _todo001019 (user): experiment with resetting the time limit if a solution is
found. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#a4853fe1b4ccd3d76f67706efd11a0698 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#a4853fe1b4ccd3d76f67706efd11a0698">operations_research::sat::NeighborhoodGeneratorHelper::FixGivenVariables</a>" (const CpSolverResponse &amp;base_solution, const absl::flat_hash_set&lt; int &gt; &amp;variables_to_fix) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001017 (user): force better objective? Note that this is already done when the
hint above is successfully loaded (i.e. if it passes the presolve
correctly) since the solver will try to find better solution than the
current one. 
 &lt;p&gt; \anchor _todo001016 (user): We could handle some complex domain (size &gt; 2). 
 &lt;p&gt; \anchor _todo001015 (user): If there is just one component, we can skip some computation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#aca0952c56878d9ecc6a8557bd42d170e "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#aca0952c56878d9ecc6a8557bd42d170e">operations_research::sat::NeighborhoodGeneratorHelper::GetSchedulingPrecedences</a>" (const absl::flat_hash_set&lt; int &gt; &amp;ignored_intervals, const CpSolverResponse &amp;initial_solution, absl::BitGenRef random) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001013 (user): We could scan for model precedences and add them to the list
of precedences. This could enable more simplifications in the transitive
reduction phase. 
 &lt;p&gt; \anchor _todo001014 (user): Reduce precedence graph
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#aebc02302feafecf7907a5fcc097b7486 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#aebc02302feafecf7907a5fcc097b7486">operations_research::sat::NeighborhoodGeneratorHelper::graph_mutex_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001030 (user): Refactor the class to be thread-safe instead, it should be
safer and more easily maintenable. Some complication with accessing the
variable&lt;-&gt;constraint graph efficiently though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#a83668c50ed54cfcd6b559374579eeca7 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#a83668c50ed54cfcd6b559374579eeca7">operations_research::sat::NeighborhoodGeneratorHelper::Synchronize</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001000 (user): We could set the optional literal to false directly in
the bound sharing manager. We do have to be careful that all the
different solvers have the same optionality definition though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4bd54ab16ebc1bd6fa80d1e23ab79adc "<a class="el" href="namespaceoperations__research_1_1sat.html#a10700832ca6bc420f2931eb707957b0b">operations_research::sat::NewSatParameters</a>" (const sat::SatParameters &amp;parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001244 (user): A notable exception to this is the TimeLimit which is
currently not initializing itself from the SatParameters in the model. It
will also starts counting from the time of its creation. It will be good
to find a solution that is less error prone. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a10700832ca6bc420f2931eb707957b0b "<a class="el" href="namespaceoperations__research_1_1sat.html#a10700832ca6bc420f2931eb707957b0b">operations_research::sat::NewSatParameters</a>" (const std::string &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001243 (user): Support it on android.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad8af8f787d40f2ccb96beb5306c913c5 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad8af8f787d40f2ccb96beb5306c913c5">operations_research::sat::NewWeightedSum</a>" (const VectorInt &amp;coefficients, const std::vector&lt; IntegerVariable &gt; &amp;vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001518 (user): deal with overflow here too! 
 &lt;p&gt; \anchor _todo001517 (user): invert the coefficients/vars arguments. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NoCyclePropagator Member \_internalref classoperations__research_1_1sat_1_1NoCyclePropagator#a8114b6f2c07e82698969a873461784ec "<a class="el" href="classoperations__research_1_1sat_1_1NoCyclePropagator.html#a8114b6f2c07e82698969a873461784ec">operations_research::sat::NoCyclePropagator::NoCyclePropagator</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; Literal &gt; &amp;literals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000930 (user): Uniformize this across propagator. Sometimes it is nice not
to register them, but most of them can be registered right away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NoCyclePropagator Member \_internalref classoperations__research_1_1sat_1_1NoCyclePropagator#a0751bd29114a60910d7626a21eb88b94 "<a class="el" href="classoperations__research_1_1sat_1_1NoCyclePropagator.html#a0751bd29114a60910d7626a21eb88b94">operations_research::sat::NoCyclePropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000931 (user): only explore node with newly added arcs.&lt;p&gt; \anchor _todo000932 (user): We could easily re-index the graph so that only nodes with arcs
are used. Because right now we are in O(num_nodes) even if the graph is
empty. 
 &lt;p&gt; \anchor _todo000933 (user): We could be more efficient here, but this is only executed on
conflicts. We should at least make sure we return a single cycle even
though if this is called often enough, we shouldn't have a lot more than
this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NonOverlappingRectanglesDisjunctivePropagator Member \_internalref classoperations__research_1_1sat_1_1NonOverlappingRectanglesDisjunctivePropagator#a8ecc25f62262a8731c6e8db417060656 "<a class="el" href="classoperations__research_1_1sat_1_1NonOverlappingRectanglesDisjunctivePropagator.html#a8ecc25f62262a8731c6e8db417060656">operations_research::sat::NonOverlappingRectanglesDisjunctivePropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001389 (user): Since we are at it, do more propagation even if no conflict?
This rarely propagate, so disabled for now. Investigate if it is worth
it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a09190309faf157e3b7187403cfcb514c "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a09190309faf157e3b7187403cfcb514c">operations_research::sat::PbConstraints::AddConstraint</a>" (const std::vector&lt; LiteralWithCoeff &gt; &amp;cst, Coefficient rhs, Trail *trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001771 (user): the index is needed to give the correct thresholds_ entry
to InitializeRhs() below, but this linear scan is not super
efficient. 
 &lt;p&gt; \anchor _todo001770 (user): This is relatively slow. Take the "transpose" all at once, and
maybe put small constraints first on the to_update_ lists. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a9474a3e975c9c26b00740c514d82c373 "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a9474a3e975c9c26b00740c514d82c373">operations_research::sat::PbConstraints::BumpActivity</a>" (UpperBoundedLinearConstraint *constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001783 (user): Remove duplication with other activity update functions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a38e94ac484dcbd409e942d4e6f51d585 "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a38e94ac484dcbd409e942d4e6f51d585">operations_research::sat::PbConstraints::ClearConflictingConstraint</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001782 (user): This is a hack to get the PB conflict, because the rest of
the solver API assume only clause conflict. Find a cleaner way? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PostsolveClauses Class \_internalref structoperations__research_1_1sat_1_1PostsolveClauses "<a class="el" href="structoperations__research_1_1sat_1_1PostsolveClauses.html">operations_research::sat::PostsolveClauses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001946 (user): Use a flat memory structure instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a1951d3606d9c0c92204c310b911bf0e7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a1951d3606d9c0c92204c310b911bf0e7">operations_research::sat::PostsolveLinear</a>" (const ConstraintProto &amp;ct, std::vector&lt; Domain &gt; *domains)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001055 (user): I am not 100% that the algo here might cover all the presolve
case, so if this fail, it might indicate an issue here and not in the
presolve/solver code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3e2be878d255ed853ce6a36d52c899dd "<a class="el" href="namespaceoperations__research_1_1sat.html#a3e2be878d255ed853ce6a36d52c899dd">operations_research::sat::PostsolveResponse</a>" (const int64_t num_variables_in_original_model, const CpModelProto &amp;mapping_proto, const std::vector&lt; int &gt; &amp;postsolve_mapping, std::vector&lt; int64_t &gt; *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001056 (user): We could use the search strategy to fix free variables to some
chosen values? The feature might never be needed though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Class \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html">operations_research::sat::PrecedencesPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001813 (user): We could easily generalize the code to support any relation of
the form a*X + b*Y + c*Z &gt;= rhs (or &lt;=). Do that since this class should be
a lot faster at propagating small linear inequality than the generic
propagator and the overhead of supporting coefficient should not be too bad. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a3a76b9c2a7fae816a7bf98ceb157c658 "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a3a76b9c2a7fae816a7bf98ceb157c658">operations_research::sat::PrecedencesPropagator::AddGreaterThanAtLeastOneOfConstraints</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001817 (user): This can be quite slow, add some kind of deterministic limit
so that we can use it all the time. 
 &lt;p&gt; \anchor _todo001812 (user): This does not take into account clause of size 2 since they
are stored in the BinaryImplicationGraph instead. Some ideas specific
to size 2:
- There can be a lot of such clauses, but it might be nice to consider
  them. we need to experiments.
- The automatic clause detection might be a better approach and it
  could be combined with probing. 
 &lt;p&gt; \anchor _todo001811 (user): Do more extensive experiment. Remove the second approach as
it is more time consuming? or identify when it make sense. Note that the
first approach also allows to use "incomplete" at least one between arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a27a8dbd7b031a764a1da7054101bd3cb "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a27a8dbd7b031a764a1da7054101bd3cb">operations_research::sat::PrecedencesPropagator::ComputeFullPrecedences</a>" (bool call_compute_precedences, const std::vector&lt; IntegerVariable &gt; &amp;vars, std::vector&lt; FullIntegerPrecedence &gt; *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001789 (user): Only explore the sub-graph reachable from "vars". 
 &lt;p&gt; \anchor _todo001790 (user): use vector of fixed size. 
 &lt;p&gt; \anchor _todo001791 (user): optimize when needed. 
 &lt;p&gt; \anchor _todo001792 (user): Release the memory right away. 
 &lt;p&gt; \anchor _todo001788 (user): This can fail if we don't have a DAG. We could just skip Bad
edges instead, and have a sub-DAG as an heuristic. Or analyze the arc
weight and make sure cycle are not an issue. We can also start with arcs
with strictly positive weight.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a21632ee0a6911bfee9b9cac2cc739584 "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a21632ee0a6911bfee9b9cac2cc739584">operations_research::sat::PrecedencesPropagator::ComputePrecedences</a>" (const std::vector&lt; IntegerVariable &gt; &amp;vars, std::vector&lt; IntegerPrecedences &gt; *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001786 (user): it seems better to ignore negative min offset as we will
often have relation of the form interval_start &gt;= interval_end -
offset, and such relation are usually not useful. Revisit this in case
we see problems where we can propagate more without this test. 
 &lt;p&gt; \anchor _todo001787 (user): use an order that is always topological? This is not clear
since it may be slower to compute and not worth it because the order below
is more natural and may work better. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator::FullIntegerPrecedence Class \_internalref structoperations__research_1_1sat_1_1PrecedencesPropagator_1_1FullIntegerPrecedence "<a class="el" href="structoperations__research_1_1sat_1_1PrecedencesPropagator_1_1FullIntegerPrecedence.html">operations_research::sat::PrecedencesPropagator::FullIntegerPrecedence</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001814 (user): Put some work limit in place, as this can be slow. Complexity
is in O(vars.size()) * num_arcs.&lt;p&gt; \anchor _todo001815 (user): Since we don't need ALL precedences, we could just work on a
sub-DAG of the full precedence graph instead of aborting.&lt;p&gt; \anchor _todo001816 (user): Many relations can be redundant. Filter them.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a68e6ed997752f220d4571c5faa136ce5 "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a68e6ed997752f220d4571c5faa136ce5">operations_research::sat::PrecedencesPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001785 (user): Because of our code to deal with InPropagationLoop(), this is
not always true. Find a cleaner way to DCHECK() while not failing in this
corner case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7a3e424a9963561cbd837b7a293b416e "<a class="el" href="namespaceoperations__research_1_1sat.html#a7a3e424a9963561cbd837b7a293b416e">operations_research::sat::PresolveBooleanLinearExpression</a>" (std::vector&lt; Literal &gt; *literals, std::vector&lt; Coefficient &gt; *coefficients, Coefficient *offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001753 (user): Merge this with similar code like
ComputeBooleanLinearExpressionCanonicalForm(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a5670894aad056fc4452807432b031858 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a5670894aad056fc4452807432b031858" title="b =&gt; x in [lb, ub].">operations_research::sat::PresolveContext::AddImplyInDomain</a>" (int b, int x, const Domain &amp;domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001821 (user): Find the best way to create such small proto. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a0e57a4d478e6619ec142e1c0e3da51a3 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a0e57a4d478e6619ec142e1c0e3da51a3">operations_research::sat::PresolveContext::CanonicalizeObjective</a>" (bool simplify_domain=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001830 (user): This is a bit duplicated with the presolve linear code.
We also do not propagate back any domain restriction from the objective to
the variables if any. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a2ccc5bf972c4cfe911eb430e97dd3c57 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a2ccc5bf972c4cfe911eb430e97dd3c57">operations_research::sat::PresolveContext::CanonicalizeVariable</a>" (int ref)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001838 (user): When we can always get rid of affine relation, it might be good
to do a final pass to canonicalize all domains in a model after presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#acfa9e96fd82123e73419f70c85690153 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#acfa9e96fd82123e73419f70c85690153">operations_research::sat::PresolveContext::ConstraintVariableUsageIsConsistent</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001823 (user): Also test var_to_constraints_ !!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a761798831fd1590e6462e835fe313953 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a761798831fd1590e6462e835fe313953">operations_research::sat::PresolveContext::GetAbsRelation</a>" (int target_ref, int *ref)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001828 (user): Incorporate this as part of SavedVariable/SavedLiteral so we
make sure we never forget about this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#ae773a841f916d3caf1eb74caf23aa43b "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#ae773a841f916d3caf1eb74caf23aa43b">operations_research::sat::PresolveContext::InsertVarValueEncoding</a>" (int literal, int ref, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001839 (user): This function is not always correct if
!context-&gt;DomainOf(ref).contains(value), we could make it correct but it
might be a bit expansive to do so. For now we just have a DCHECK(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a6e1524915705b3272bab45c634fb5a37 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a6e1524915705b3272bab45c634fb5a37">operations_research::sat::PresolveContext::IsFullyEncoded</a>" (int ref) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001840 (user): If the domain was shrunk, we can have a false positive.
Still it means that the number of values removed is greater than the number
of values not encoded. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a38e2f15d439243fcc447d48fe120624e "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a38e2f15d439243fcc447d48fe120624e">operations_research::sat::PresolveContext::NewIntVar</a>" (const Domain &amp;domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001836 (user): We should control more how this is called so we can update
a solution hint accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a4754e537659fee6e482af4c6d3e2f555 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a4754e537659fee6e482af4c6d3e2f555">operations_research::sat::PresolveContext::NotifyThatModelIsUnsat</a>" (const std::string &amp;message="")&lt;/dt&gt;&lt;dd&gt; \anchor _todo001837 (user): Report any explanation for the client in a nicer way?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a392085a404b28b5e5a405c4e115e5332 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a392085a404b28b5e5a405c4e115e5332">operations_research::sat::PresolveContext::ShiftCostInExactlyOne</a>" (absl::Span&lt; const int &gt; exactly_one, int64_t shift)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001831 (user): Be more precise with this objective_overflow_detection_ and
always keep it up to date on each offset / coeff change. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#aa087429f5cddf5be6c225890f614b4f1 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#aa087429f5cddf5be6c225890f614b4f1">operations_research::sat::PresolveContext::StoreAffineRelation</a>" (int ref_x, int ref_y, int64_t coeff, int64_t offset, bool debug_no_recursion=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001827 (user): I am not sure this is needed given the propagation above. 
 &lt;p&gt; \anchor _todo001824 (user): I am not 100% sure why, but sometimes the representative is
fixed but that is not propagated to ref_x or ref_y and this causes issues. 
 &lt;p&gt; \anchor _todo001825 (user): we can do better for overflow by not always choosing the
min at zero, do the best things if it becomes needed. 
 &lt;p&gt; \anchor _todo001826 (user): can we force the rep and remove GetAffineRelation()?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#ab43f7366b32b2ac40cc0f7f668040c49 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#ab43f7366b32b2ac40cc0f7f668040c49">operations_research::sat::PresolveContext::UpdateRuleStats</a>" (const std::string &amp;name, int num_times=1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001822 rules as this is used to decide if
we loop again. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab45b28a0d709ca9421320ec459d4c7ad "<a class="el" href="namespaceoperations__research_1_1sat.html#ab45b28a0d709ca9421320ec459d4c7ad">operations_research::sat::PreventOverflow</a>" (const IntegerTrail &amp;integer_trail, LinearConstraint *constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001636 (user): We could change the propag to detect a conflict without
computing the full activity, and thus avoid some overflow. Like precompute
a base lb and then compute the activity from there? Or we could have
a custom code here, actually we only propagate this with the current lb
instead of the LevelZeroUpperBound(). Or we could just propagate using
int128 arithmetic. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a741dec692e255a08e4fae5ce3a8dbe7d "<a class="el" href="namespaceoperations__research_1_1sat.html#a741dec692e255a08e4fae5ce3a8dbe7d">operations_research::sat::ProbeAndFindEquivalentLiteral</a>" (SatSolver *solver, SatPostsolver *postsolver, DratProofHandler *drat_proof_handler, absl::StrongVector&lt; LiteralIndex, LiteralIndex &gt; *mapping)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002028 (user): Fixing a variable might fix more of them by propagation, so
we might not fix everything possible with these loops. 
 &lt;p&gt; \anchor _todo002027 (user): check compatibility? if x ~ not(x) =&gt; unsat.
but probably, the solver would have found this too? not sure... 
 &lt;p&gt; \anchor _todo002026 (user): Add some constraint so that it does?&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a60a37142e38a0a290d70b030405db801 "<a class="el" href="namespaceoperations__research_1_1sat.html#a60a37142e38a0a290d70b030405db801">operations_research::sat::ProbeAndSimplifyProblem</a>" (SatPostsolver *postsolver, LinearBooleanProblem *problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000926 (user): expose the number of iterations as a parameter.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#a2127d7db0f3c791613c92c8177e02432 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a2127d7db0f3c791613c92c8177e02432">operations_research::sat::Prober::ProbeBooleanVariables</a>" (double deterministic_time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001863 (user): Rename to include Integer in the name and distinguish better
from FailedLiteralProbing() below. 
 &lt;p&gt; \anchor _todo001862 (user): More generally, we might want to register any literal =&gt; bound
in the IntegerEncoder. This would allow to remember them and use them in
other part of the solver (cuts, lifting, ...).&lt;p&gt; \anchor _todo001861 (user): This might generate a lot of new direct implications. We might
not want to add them directly to the BinaryImplicationGraph and could
instead use them directly to detect equivalent literal like in
ProbeAndFindEquivalentLiteral(). The situation is not clear.&lt;p&gt; \anchor _todo001860 (user): For now we process the Boolean in their natural order, this is
not the most efficient.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#ab1e9d80c7f62d666ad8a3ec5a14f3c13 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a2127d7db0f3c791613c92c8177e02432">operations_research::sat::Prober::ProbeBooleanVariables</a>" (double deterministic_time_limit, absl::Span&lt; const BooleanVariable &gt; bool_vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001853 (user): Instead of an hard deterministic limit, we should probably
use a lower one, but reset it each time we have found something useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#a0ad34d874b506bc2be329d5cc4f8e185 "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#a0ad34d874b506bc2be329d5cc4f8e185">operations_research::sat::ProbingOptions::deterministic_limit</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001865 (user): The fix point is not yet reached since we don't currently
simplify non-binary clauses with these equivalence, but we will. 
 &lt;p&gt; \anchor _todo001864 (user): We can also provide a middle ground and probe all failed
literal but do not extract all binary clauses.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#af5a82baa2dc19e7fe7e018b63c499042 "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#af5a82baa2dc19e7fe7e018b63c499042">operations_research::sat::ProbingOptions::extract_binary_clauses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001866 (user): Note that adding binary clause before/during the SAT presolve
is currently not always a good idea. This is because we don't simplify the
other clause as much as we could. Also, there can be up to a quadratic
number of clauses added this way, which might slow down things a lot. But
then because of the deterministic limit, we usually cannot add too much
clauses, even for huge problems, since we will reach the limit before that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#ab4df2ae2f59c5cb13fe680c9580fc64f "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#ab4df2ae2f59c5cb13fe680c9580fc64f">operations_research::sat::ProbingOptions::use_queue</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001867 (user): Decide which one is better, currently the difference seems
small but the queue seems slightly faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2248038ecf15b3faebf318df773ec8d8 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2248038ecf15b3faebf318df773ec8d8">operations_research::sat::ProcessCoreWithAlternativeEncoding</a>" (const std::vector&lt; Literal &gt; &amp;core, Coefficient min_weight, std::deque&lt; EncodingNode &gt; *repository, std::vector&lt; EncodingNode * &gt; *nodes, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001421 (user): The last time this was tested, it was however not as good as the
ProcessCore() version. That might change as we code/change more heuristic, so
we keep it around. 
 &lt;p&gt; \anchor _todo001420 (user): For node with same depth, the sorting order is not the same
if we create a new node or reuse one. Experiment what is the best order. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a3a17220935c42077613be222734fef7a "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a3a17220935c42077613be222734fef7a">operations_research::sat::ProductDetector::LinearizeProduct</a>" (IntegerVariable a, IntegerVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001447 (user): Implement!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#af7fe2b019ee2556cd2b2813b34877945 "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#af7fe2b019ee2556cd2b2813b34877945">operations_research::sat::ProductDetector::ProcessBinaryClause</a>" (absl::Span&lt; const Literal &gt; binary_clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001435 (user): As product are discovered, we could remove entries from our
hash maps! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a7473e11336cf79ccf7f4a54a890625fc "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a7473e11336cf79ccf7f4a54a890625fc">operations_research::sat::ProductDetector::ProcessConditionalEquality</a>" (Literal l, IntegerVariable x, IntegerVariable y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001436 (user): Linear scan can be bad if b =&gt; X = many other variables.
Hopefully this will not be common. 
 &lt;p&gt; \anchor _todo001446 (user): Generalize to a * X + b = l * (Y + c) since these are also
easy to linearize if we see l * Y. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a308ee96e864c4e4fac744ac329ecac39 "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a308ee96e864c4e4fac744ac329ecac39">operations_research::sat::ProductDetector::ProductLowerBound</a>" (IntegerVariable a, IntegerVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001448 (user): Implement! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductPropagator Member \_internalref classoperations__research_1_1sat_1_1ProductPropagator#a1a947c821f05a6e347602ffaa4162d1d "<a class="el" href="classoperations__research_1_1sat_1_1ProductPropagator.html#a1a947c821f05a6e347602ffaa4162d1d">operations_research::sat::ProductPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001504 (user): In the reasons, including all 4 bounds is always correct, but
we might be able to relax some of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad8873d5bb4db4affe6faa2da6553882a "<a class="el" href="namespaceoperations__research_1_1sat.html#ad8873d5bb4db4affe6faa2da6553882a" title="Fills and propagates the set of reachable states/labels.">operations_research::sat::PropagateAutomaton</a>" (const AutomatonConstraintProto &amp;proto, const PresolveContext &amp;context, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *states, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *labels)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000981 (user): Note that if we have duplicate variables controlling different
time point, this might not reach the fixed point. Fix? it is not that
important as the expansion take care of this case anyway. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad1ebf465eb7ccee4f79a5b8cfccfe7d9 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad1ebf465eb7ccee4f79a5b8cfccfe7d9">operations_research::sat::PropagateEncodingFromEquivalenceRelations</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001043 (user): This is not supposed to happen, but apparently it did on
once on routing_GCM_0001_sat.fzn. Investigate and fix. 
 &lt;p&gt; \anchor _todo001044 (user): This is similar to LoadEquivalenceAC() for unreified
constraints, but when the later is called, more encoding might have taken
place. 
 &lt;p&gt; \anchor _todo001051 (user): In an ideal world, all affine relations like this should be
removed in the presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7bb3adbf30215f4aafac3f24caf00f84 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7bb3adbf30215f4aafac3f24caf00f84">operations_research::sat::PseudoCost</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001524 (user): This will be overridden by the value decision heuristic in
almost all cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PseudoCosts Member \_internalref classoperations__research_1_1sat_1_1PseudoCosts#a78be0e06d6c1f84281b45b79cb946d92 "<a class="el" href="classoperations__research_1_1sat_1_1PseudoCosts.html#a78be0e06d6c1f84281b45b79cb946d92" title="Returns the variable with best reliable pseudo cost that is not fixed.">operations_research::sat::PseudoCosts::GetBestDecisionVar</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001868 (user): Experiment with different ways to merge the costs.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af7f519865479d23c58e76b1fe416a2f1 "<a class="el" href="namespaceoperations__research_1_1sat.html#af7f519865479d23c58e76b1fe416a2f1">operations_research::sat::RandomizeOnRestartHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001526 (user): Add other policy and perform more experiments.
 &lt;p&gt; \anchor _todo001527 (user): Do more experiments to find better distribution. 
 &lt;p&gt; \anchor _todo001528 (user): These distribution values are just guessed values. They need
to be tuned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#adca1dbc518cda34cea6dedda82f1577b "<a class="el" href="namespaceoperations__research_1_1sat.html#adca1dbc518cda34cea6dedda82f1577b">operations_research::sat::ReduceNodesAndExtractAssumptions</a>" (Coefficient upper_bound, Coefficient stratified_lower_bound, Coefficient *lower_bound, std::vector&lt; EncodingNode * &gt; *nodes, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001419 (user): with DEFAULT_ASSUMPTION_ORDER, this will lead to a somewhat
weird behavior, since we will reverse the nodes at each iteration... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxationInducedNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1RelaxationInducedNeighborhoodGenerator#aa4724e62d610d139a8ae7197f1004823 "<a class="el" href="classoperations__research_1_1sat_1_1RelaxationInducedNeighborhoodGenerator.html#aa4724e62d610d139a8ae7197f1004823" title="Both initial solution and difficulty values are ignored.">operations_research::sat::RelaxationInducedNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, double difficulty, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001021 (user): Instead of aborting, pick the closest point in the domain?
 &lt;p&gt; \anchor _todo001022 (user): Instead of aborting, pick the closest point in the
domain? 
 &lt;p&gt; \anchor _todo001020 (user): Tune the probability value for this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomConstraintsGenerator Class \_internalref classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator.html">operations_research::sat::RelaxRandomConstraintsGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001028 (user): In the presence of connected components, this should just work
on one of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomVariablesGenerator Class \_internalref classoperations__research_1_1sat_1_1RelaxRandomVariablesGenerator "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomVariablesGenerator.html">operations_research::sat::RelaxRandomVariablesGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001027 (user): In the presence of connected components, this should just work
on one of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a89dc2fa5d4896cd17270cf7d40099e08 "<a class="el" href="namespaceoperations__research_1_1sat.html#a89dc2fa5d4896cd17270cf7d40099e08">operations_research::sat::ReportEnergyConflict</a>" (Rectangle bounding_box, absl::Span&lt; const int &gt; boxes, SchedulingConstraintHelper *x, SchedulingConstraintHelper *y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001393 (user): relax the bounding box dimension to have a relaxed explanation.
We can also minimize the number of required intervals. 
 &lt;p&gt; \anchor _todo001391 (user): Also relax the box if possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RestartPolicy Member \_internalref classoperations__research_1_1sat_1_1RestartPolicy#a52594750ea119a9ac928e3f09b77f140 "<a class="el" href="classoperations__research_1_1sat_1_1RestartPolicy.html#a52594750ea119a9ac928e3f09b77f140" title="Resets the policy using the current model parameters.">operations_research::sat::RestartPolicy::Reset</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001869 (user): for some reason, strategies_.assign() does not work as the
returned type of the proto enum iterator is int ?! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RoundingOptions Class \_internalref structoperations__research_1_1sat_1_1RoundingOptions "<a class="el" href="structoperations__research_1_1sat_1_1RoundingOptions.html">operations_research::sat::RoundingOptions</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001385 (user): There is a bunch of heuristic involved here, and we could spend
more effort tuning them. In particular, one can try many heuristics and keep
the best looking cut (or more than one). This is not on the critical code
path, so we can spend more effort in finding good cuts. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#a39f12c518e1f163afda3ef357cc11f27 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#a39f12c518e1f163afda3ef357cc11f27" title="Returns the vector of the current assignment preferences.">operations_research::sat::SatDecisionPolicy::AllPreferences</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001887 (user): we currently assume that if the tie_breaker is zero then
no preference was set (which is not 100% correct). Fix that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#ad02a374fc46af7a8ed8112257438dbc1 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#ad02a374fc46af7a8ed8112257438dbc1">operations_research::sat::SatDecisionPolicy::NextBranch</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001888 (user): This may not be super efficient if almost all the
variables are assigned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#a9f05bb03afa86725c194d50e613f2593 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#a9f05bb03afa86725c194d50e613f2593" title="Called on Untrail() so that we can update the set of possible decisions.">operations_research::sat::SatDecisionPolicy::Untrail</a>" (int target_trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001889 (user): avoid looping twice over the trail?
 &lt;p&gt; \anchor _todo001890 (user): Expose parameters for these values. 
 &lt;p&gt; \anchor _todo001891 (user): This heuristic can make this code quite slow because
all the untrailed variable will cause a priority queue update. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPostsolver Member \_internalref classoperations__research_1_1sat_1_1SatPostsolver#a3336b2762049c2d81e2bd255e9c9ecc8 "<a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html#a3336b2762049c2d81e2bd255e9c9ecc8">operations_research::sat::SatPostsolver::Clause</a>" (int i) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002037 (user): we could avoid the copy here, but because clauses_literals_
is a deque, we do need a special return class and cannot juste use
absl::Span&lt;Literal&gt; for instance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPostsolver Member \_internalref classoperations__research_1_1sat_1_1SatPostsolver#ad351af493e5b70fc12534bc0806cc444 "<a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html#ad351af493e5b70fc12534bc0806cc444">operations_research::sat::SatPostsolver::FixVariable</a>" (Literal x)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002036 (user): this as almost the same effect as adding an unit clause, and we
should probably remove this to simplify the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolveOptions Member \_internalref structoperations__research_1_1sat_1_1SatPresolveOptions#a99051170412df0832ce84112ddd314c0 "<a class="el" href="structoperations__research_1_1sat_1_1SatPresolveOptions.html#a99051170412df0832ce84112ddd314c0">operations_research::sat::SatPresolveOptions::use_transitive_reduction</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001950 (user): Doing that before the current SAT presolve also change the
possible reduction. This shouldn't matter if we use the binary implication
graph and its reachability instead of just binary clause though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Class \_internalref classoperations__research_1_1sat_1_1SatPresolver "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html">operations_research::sat::SatPresolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002033 (user): Interact more with a SAT solver to reuse its propagation logic.&lt;p&gt; \anchor _todo002034 (user): Forbid the removal of some variables. This way we can presolve
only the clause part of a general Boolean problem by not removing variables
appearing in pseudo-Boolean constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a48d43c858e789a63bf76da7414b55a5f "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a48d43c858e789a63bf76da7414b55a5f">operations_research::sat::SatPresolver::ClauseIndex</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002038 (user): use IntType!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a4b58b71a43c02cbec8fefb126f0a61cb "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a4b58b71a43c02cbec8fefb126f0a61cb">operations_research::sat::SatPresolver::CrossProduct</a>" (Literal x)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002025 (user): At this point x.Variable() is added back to the priority queue.
Avoid doing that. 
 &lt;p&gt; \anchor _todo002024 (user): We could only update the priority queue once for each variable
instead of doing it many times. 
 &lt;p&gt; \anchor _todo002023 (user): Choose if we use x or x.Negated() depending on the list
sizes? The function achieve the same if x = x.Negated(), however the
loops are not done in the same order which may change this incomplete
"blocked" clause detection. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#adb7846ae7bbe4ca2e07a1dba94fe686e "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a32df98e6426d1e7a18247a18207717f1">operations_research::sat::SatPresolver::Presolve</a>" (const std::vector&lt; bool &gt; &amp;var_that_can_be_removed)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002013 (user): When a clause is strengthened, add it to a queue so it can
be processed again? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a32df98e6426d1e7a18247a18207717f1 "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a32df98e6426d1e7a18247a18207717f1">operations_research::sat::SatPresolver::Presolve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002039 (user): Add support for a time limit and some kind of iterations limit
so that this can never take too much time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a8d8418b2601e61829de5e7b3f4df122b "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a8d8418b2601e61829de5e7b3f4df122b">operations_research::sat::SatPresolver::ProcessClauseToSimplifyOthers</a>" (ClauseIndex clause_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002022 (user): remove the old clauses_[ci] afterwards.
 &lt;p&gt; \anchor _todo002021 (user): not super optimal since we could abort earlier if
opposite_literal is not the negation of shortest_list. Note that this
applies to the second call to
ProcessClauseToSimplifyOthersUsingLiteral() above too. 
 &lt;p&gt; \anchor _todo002020 (user): Binary clauses are really common, and we can probably do this
more efficiently for them. For instance, we could just take the intersection
of two sorted lists to get the simplified clauses. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPropagator Member \_internalref classoperations__research_1_1sat_1_1SatPropagator#a2bde4f8c3d7c6326050ac164391bf2a7 "<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a2bde4f8c3d7c6326050ac164391bf2a7">operations_research::sat::SatPropagator::PropagatePreconditionsAreSatisfied</a>" (const Trail &amp;trail) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001878 (user): A few of these method should be moved in a .cc
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPropagator Member \_internalref classoperations__research_1_1sat_1_1SatPropagator#a68acada7af835c9c6870ceb876dc2d9c "<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a68acada7af835c9c6870ceb876dc2d9c">operations_research::sat::SatPropagator::Untrail</a>" (const Trail &amp;trail, int trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001884 (user): It is not yet 100% the case, but this can be guaranteed to be
called with a trail index that will always be the start of a new decision
level. 
 &lt;p&gt; \anchor _todo001883 (user): Currently this is called at each Backtrack(), but we could
bundle the calls in case multiple conflict one after the other are detected
even before the Propagate() call of a SatPropagator is called.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a8b9ba983bd9f911d0605f7615ebf3725 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8b9ba983bd9f911d0605f7615ebf3725">operations_research::sat::SatSolver::AddClauseDuringSearch</a>" (absl::Span&lt; const Literal &gt; literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001955 (user): We generate in some corner cases clauses with
literals[0].Variable() == literals[1].Variable(). Avoid doing that and
adding such binary clauses to the graph? 
 &lt;p&gt; \anchor _todo001995 (user): Backjump and propagate on a falsified clause? this is currently
not needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a098038f8e0409a8243ff3f7eafb517f8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a098038f8e0409a8243ff3f7eafb517f8">operations_research::sat::SatSolver::AddLinearConstraint</a>" (bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001991 (user): Instead of failing, implement an error handling code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a2613df5393b4e2285789856150543b70 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a2613df5393b4e2285789856150543b70">operations_research::sat::SatSolver::AddProblemClause</a>" (absl::Span&lt; const Literal &gt; literals, bool is_safe=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001990 (user): Rename this to AddClause(), also get rid of the specialized
AddUnitClause(), AddBinaryClause() and AddTernaryClause() since they
just end up calling this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a7c0c2912da716e49c8b5d84108e463d7 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7c0c2912da716e49c8b5d84108e463d7">operations_research::sat::SatSolver::Backtrack</a>" (int target_level)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001963 (user): The backtrack method should not be called when the model is
             unsat. Add a DCHECK to prevent that, but before fix the
             bop::BopOptimizerBase architecture. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a1ac88207c0228d80d19751186955240f "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a1ac88207c0228d80d19751186955240f">operations_research::sat::SatSolver::deterministic_time</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001954 (user): Find a better procedure to fix the weight than just educated
guess. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a0174fd7221118d81a925d32aaed1cc79 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a0174fd7221118d81a925d32aaed1cc79">operations_research::sat::SatSolver::ExtractClauses</a>" (Output *out)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001994 (user): also copy the removable clauses? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a84e27e6cb848b3176ab5680292d116a8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a84e27e6cb848b3176ab5680292d116a8">operations_research::sat::SatSolver::IsModelUnsat</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001992 (user): remove this function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a5420a6d871314779beeac0c074241c1a "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a5420a6d871314779beeac0c074241c1a">operations_research::sat::SatSolver::model</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001988 (user): Remove. This is temporary for accessing the model deep within
some old code that didn't use the Model object. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a9188c70cc1096900a623a26319a1d4b8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">operations_research::sat::SatSolver::Propagate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001973 (user): This might not really be needed. 
 &lt;p&gt; \anchor _todo001972 (user): Support propagating only the "first" propagators. That can
be useful for probing/in-processing, so we can control if we do only the SAT
part or the full integer part... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#aac37795c9baf36781ceba43e454f9675 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#aac37795c9baf36781ceba43e454f9675">operations_research::sat::SatSolver::SetAssignmentPreference</a>" (Literal literal, double weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001993 (user): Clean this up by making clients directly talk to
SatDecisionPolicy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#ae8f40548efeb9f6bde6ff1cd872acc38 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ae8f40548efeb9f6bde6ff1cd872acc38">operations_research::sat::SatSolver::SetNumVariables</a>" (int num_variables)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001989 (user): Rename to IncreaseNumVariablesTo() until we support removing
variables... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SavedVariable Class \_internalref classoperations__research_1_1sat_1_1SavedVariable "<a class="el" href="classoperations__research_1_1sat_1_1SavedVariable.html">operations_research::sat::SavedVariable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001835 (user): get rid of this, we don't have the notion of equivalent variable
anymore, but the more general affine relation one. We just need to support
general affine for the linear1 involving an absolute value. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad6d384c7c56f3027894875278e4b9526 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad6d384c7c56f3027894875278e4b9526">operations_research::sat::ScaleContinuousVariables</a>" (double scaling, double max_bound, MPModelProto *mp_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001706 (user): Also scale the solution hint if any. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ScatteredIntegerVector Member \_internalref classoperations__research_1_1sat_1_1ScatteredIntegerVector#a30b27f80b570d6cd978843cf7fae74e4 "<a class="el" href="classoperations__research_1_1sat_1_1ScatteredIntegerVector.html#a30b27f80b570d6cd978843cf7fae74e4">operations_research::sat::ScatteredIntegerVector::ConvertToLinearConstraint</a>" (const std::vector&lt; IntegerVariable &gt; &amp;integer_variables, IntegerValue upper_bound, LinearConstraint *result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001650 (user): Ideally we should convert to IntegerVariable as late as
possible. Prefer to use GetTerms(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SccGraph Member \_internalref classoperations__research_1_1sat_1_1SccGraph#aee95126bcb16bb7a70ab00218a15fd7f "operations_research::sat::SccGraph::operator[]" (int32_t node) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000959 (user): avoid looping more than twice on the same at most one
constraints? Note that the second time we loop we have x =&gt; y =&gt;
not(x), so we can already detect that x must be false which we
detect below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a648ff007cfc81bd0a4369701a7048a27 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a648ff007cfc81bd0a4369701a7048a27">operations_research::sat::SchedulingConstraintHelper::GetEnergyProfile</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001547 (user): Avoid recomputing it if nothing changed.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a98e816cae622855fe8eae0766b4e0aaf "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a98e816cae622855fe8eae0766b4e0aaf">operations_research::sat::SchedulingConstraintHelper::InPropagationLoop</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001554 (user): Change the propagation loop code so that we don't stop
pushing in the middle of the propagation as more advanced propagator do
not handle this correctly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a230beffeb33f166d27bc233bed77237a "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a3e7ffb0e41b9e4bc01f0aa0c5c9bd373">operations_research::sat::SchedulingConstraintHelper::SchedulingConstraintHelper</a>" (int num_tasks, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001552 (user): Remove this. It is a hack because the disjunctive class needs
to fetch the maximum possible number of task at construction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#aac6715a4e5f01196e19399a749218d13 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#aac6715a4e5f01196e19399a749218d13">operations_research::sat::SchedulingConstraintHelper::SetLevel</a>" (int level) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001545 (user): We could be smarter here, but then this is not visible in our
cpu_profile since we call many times IncrementalPropagate() for each new
decision, but just call Propagate() once after each Untrail(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#aeb2242b9691ae16314d277fc7a59eeb7 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#aeb2242b9691ae16314d277fc7a59eeb7">operations_research::sat::SchedulingConstraintHelper::TaskByIncreasingStartMin</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001553 (user): we could merge the first loop of IncrementalSort() with the
loop that fill TaskTime.time at each call. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Class \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">operations_research::sat::SchedulingDemandHelper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001550 (user): Cache energy min and reason for the non O(1) cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#a8b7226d12b17723e0174250fd2024f46 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#a8b7226d12b17723e0174250fd2024f46">operations_research::sat::SchedulingDemandHelper::AddEnergyMinInWindowReason</a>" (int t, IntegerValue window_start, IntegerValue window_end)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001549 (user): only include the one we need?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#a9019a263126e78ddf332f696649fda87 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#a9019a263126e78ddf332f696649fda87">operations_research::sat::SchedulingDemandHelper::CacheAllEnergyValues</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001556 (user): Add more complex EnergyMinBefore(time) once we also support
expressing the interval as a set of alternatives.&lt;p&gt; \anchor _todo001555 (user): this is error prone, maybe we should revisit. But if
there is many alternatives, we don't want to rescan the list more than a
linear number of time per propagation.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#ad690f09e6894f8f9e9b01642fa1fc822 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#ad690f09e6894f8f9e9b01642fa1fc822">operations_research::sat::SchedulingDemandHelper::DecreaseEnergyMax</a>" (int t, IntegerValue value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001548 (user): Propagate if possible.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a85b41013bb2f7709a99765d5c491f381 "<a class="el" href="namespaceoperations__research_1_1sat.html#a85b41013bb2f7709a99765d5c491f381" title="A simple heuristic for scheduling models.">operations_research::sat::SchedulingSearchHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001525 (user): we should also precompute fixed precedences and only fix
interval that have all their predecessors fixed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SelectedMinPropagator Member \_internalref classoperations__research_1_1sat_1_1SelectedMinPropagator#a1f739725ed4cb2ddad3916a74438f0af "<a class="el" href="classoperations__research_1_1sat_1_1SelectedMinPropagator.html#a1f739725ed4cb2ddad3916a74438f0af">operations_research::sat::SelectedMinPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001998 (user): Move this to integer_trail, and remove from here and
from scheduling helper. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8a9624d210768499700918aa0c4eecf2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8a9624d210768499700918aa0c4eecf2">operations_research::sat::SeparateFlowInequalities</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; AffineExpression &gt; &amp;arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, LinearConstraintManager *manager, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001874 (user): Alternatively, try MIR heuristics if the coefficients in
the capacities are not all the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad114b3c6ee51d854d3715a8a3be50f99 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad114b3c6ee51d854d3715a8a3be50f99">operations_research::sat::SeparateSubtourInequalities</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; Literal &gt; &amp;literals, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, absl::Span&lt; const int64_t &gt; demands, int64_t capacity, LinearConstraintManager *manager, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001873 (user): For the symmetric case there is an even faster algo. See if
it can be generalized to the asymmetric one if become needed.
Reference is algo 6.4 of the "The Traveling Salesman Problem" book
mentionned above. 
 &lt;p&gt; \anchor _todo001872 (user): It could be very interesting to see if this "min outgoing flow" cannot be automatically infered from the constraint in the
precedence graph. This might work if we assume that any kind of path
cumul constraint is encoded with constraints:
  [edge =&gt; value_head &gt;= value_tail + edge_weight].
We could take the minimum incoming edge weight per node in the set, and
use the cumul variable domain to infer some capacity. 
 &lt;p&gt; \anchor _todo001871 (user): This lower bound assume all nodes in subset must be served.
If this is not the case, we are really defensive in AddOutgoingCut().
Improve depending on where the self-loop are.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedBoundsManager Member \_internalref classoperations__research_1_1sat_1_1SharedBoundsManager#aa52efbe166740ce4b1f22c820a64ffc6 "<a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html#aa52efbe166740ce4b1f22c820a64ffc6">operations_research::sat::SharedBoundsManager::FixVariablesFromPartialSolution</a>" (const std::vector&lt; int64_t &gt; &amp;solution, const std::vector&lt; int &gt; &amp;variables_to_fix)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002055 (user): Because we look at the non-synchronized and up to date bounds,
this break determinism if two solution for the same subpart comes at the same
time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedClausesManager Member \_internalref classoperations__research_1_1sat_1_1SharedClausesManager#a3ebbcf2be803ef7f2cbad87a044dc4ec "<a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html#a3ebbcf2be803ef7f2cbad87a044dc4ec" title="Unlocks waiting binary clauses for workers if always_synchronize is false.">operations_research::sat::SharedClausesManager::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002056 (user): We could cleanup added_binary_clauses_ periodically.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedResponseManager Member \_internalref classoperations__research_1_1sat_1_1SharedResponseManager#adbf9c545bd1e91d71d36638ca7c1acfd "<a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html#adbf9c545bd1e91d71d36638ca7c1acfd">operations_research::sat::SharedResponseManager::NewSolution</a>" (absl::Span&lt; const int64_t &gt; solution_values, const std::string &amp;solution_info, Model *model=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002054 (user): Remove this code and the need for model in this function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedResponseManager Member \_internalref classoperations__research_1_1sat_1_1SharedResponseManager#af4876e4857461716fabf61e3df652bd6 "<a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html#af4876e4857461716fabf61e3df652bd6" title="Updates the inner objective bounds.">operations_research::sat::SharedResponseManager::UpdateInnerObjectiveBounds</a>" (const std::string &amp;update_info, IntegerValue lb, IntegerValue ub)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002052 (user): A thread might not be notified right away that the new bounds
that it is pushing make the problem infeasible. Fix that. For now we just
abort early here to avoid logging the "#Done" message multiple times. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Class \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository "operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002057 (user): Maybe add some criteria to only keep solution with an objective
really close to the best solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Member \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository#a5c764f4976d30e6f103b76a929402c87 "<a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html#a5c764f4976d30e6f103b76a929402c87" title="Returns a random solution biased towards good solutions.">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::GetRandomBiasedSolution</a>" (absl::BitGenRef random) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002058 (user): Experiments on the best distribution.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository::Solution Member \_internalref structoperations__research_1_1sat_1_1SharedSolutionRepository_1_1Solution#a1e89b8e75d0f5d4196f9cc06abbfa689 "<a class="el" href="structoperations__research_1_1sat_1_1SharedSolutionRepository_1_1Solution.html#a1e89b8e75d0f5d4196f9cc06abbfa689">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::Solution::rank</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002060 (user): Some LNS code assume that for the SharedSolutionRepository
this rank is actually the unscaled internal minimization objective.
Remove this assumptions by simply recomputing this value since it is not
too costly to do so. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Member \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository#a902c7f2bb1e91b85d85bad84726bf89b "<a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html#a902c7f2bb1e91b85d85bad84726bf89b">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002059 (user): Introduce a notion of orthogonality to diversify the pool? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4bfc95b7fb811709c6763963bee970a4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4bfc95b7fb811709c6763963bee970a4">operations_research::sat::ShaveObjectiveLb</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001523 (user): Do we need a mechanism to reduce the range of possible gaps
when nothing gets proven? This could be a parameter or some adaptative code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0479a7ca6dd22cbabccdf623aea07315 "<a class="el" href="namespaceoperations__research_1_1sat.html#a0479a7ca6dd22cbabccdf623aea07315">operations_research::sat::SimplifyCanonicalBooleanLinearConstraint</a>" (std::vector&lt; LiteralWithCoeff &gt; *cst, Coefficient *rhs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001760 (user): Use more complex simplification like dividing by the gcd of
everyone and using less different coefficients if possible. 
 &lt;p&gt; \anchor _todo001761 (user): It is probably better to remove these literals and have other
constraint setting them to false from the symmetry finder perspective. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab649ca11fd81e049dc7a8c0dd1104b5b "<a class="el" href="namespaceoperations__research_1_1sat.html#ab649ca11fd81e049dc7a8c0dd1104b5b">operations_research::sat::SimplifyClause</a>" (const std::vector&lt; Literal &gt; &amp;a, std::vector&lt; Literal &gt; *b, LiteralIndex *opposite_literal, int64_t *num_inspected_literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002035 (user): when a.size() &lt;&lt; b.size(), we should use binary search instead
of scanning b linearly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a336d2faa10d80d646232f5e6d91891d4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a336d2faa10d80d646232f5e6d91891d4">operations_research::sat::SolutionIsFeasible</a>" (const CpModelProto &amp;model, absl::Span&lt; const int64_t &gt; variable_values, const CpModelProto *mapping_proto, const std::vector&lt; int &gt; *postsolve_mapping)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000977 (user): This is not really a "feasibility" question, but we should
probably check that the response objective matches with the one we can
compute here. This might better be done in another function though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9d67b9c66f1cb9c1dcc3415cd5af11bf "<a class="el" href="namespaceoperations__research_1_1sat.html#a9d67b9c66f1cb9c1dcc3415cd5af11bf">operations_research::sat::SolveCpModel</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001253 (user): At this point, the model is trivial, but we could exit
early. 
 &lt;p&gt; \anchor _todo001246 (user): provide an option to skip this step for speed? 
 &lt;p&gt; \anchor _todo001252 (user): All this duplication will go away when we are fast enough
on pure-sat model with the CpModel presolve... 
 &lt;p&gt; \anchor _todo001254 (user): Change status to IMPRECISE? 
 &lt;p&gt; \anchor _todo001255 (user): for now, we just use the domain infered during
presolve. 
 &lt;p&gt; \anchor _todo001256 (user): We could try to dump our linear relaxation too. 
 &lt;p&gt; \anchor _todo001257 (user): Even for an optimization, if we load the solution right away,
we might not have the same behavior as the initial search that follow the
hint will be infeasible, so the activities of the variables will be
different. 
 &lt;p&gt; \anchor _todo001251 will make it
automatic. 
 &lt;p&gt; \anchor _todo001249 (user): Support solution hint, but then the first&lt;p&gt; \anchor _todo001248 &lt;p&gt; \anchor _todo001245 (user): We currently reuse the MODEL_INVALID status even though it
is not the best name for this. Maybe we can add a PARAMETERS_INVALID
when it become needed. Or rename to INVALID_INPUT ? 
 &lt;p&gt; \anchor _todo001250 &lt;p&gt; \anchor _todo001247 (user): improve the normal presolver to do the same thing.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a43a3828d1897a92ece5fd4f6018fe3da "<a class="el" href="namespaceoperations__research_1_1sat.html#a43a3828d1897a92ece5fd4f6018fe3da">operations_research::sat::SolveDiophantine</a>" (absl::Span&lt; const int64_t &gt; coeffs, int64_t rhs, absl::Span&lt; const int64_t &gt; var_lbs, absl::Span&lt; const int64_t &gt; var_ubs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001395 (user): look if there is a natural improvement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa4dae45317363a09e5f5f5ac22394f74 "<a class="el" href="namespaceoperations__research_1_1sat.html#aa4dae45317363a09e5f5f5ac22394f74">operations_research::sat::SolveFzWithCpModelProto</a>" (const fz::Model &amp;fz_model, const fz::FlatzincSatParameters &amp;p, const std::string &amp;sat_params, SolverLogger *logger, SolverLogger *solution_logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000358 (user): Supports setting the number of workers to 0, which will
    then query the number of cores available. This is complex now as we
    need to still support the expected behabior (no flags -&gt; 1 thread
    fixed search, -f -&gt; 1 thread free search). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a15fb8ffa8e9a460cec5cc28295217897 "<a class="el" href="namespaceoperations__research_1_1sat.html#a15fb8ffa8e9a460cec5cc28295217897">operations_research::sat::SolveWithCardinalityEncodingAndCore</a>" (LogBehavior log, const LinearBooleanProblem &amp;problem, SatSolver *solver, std::vector&lt; bool &gt; *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001728 (user): We are suboptimal here because we use for upper bound the
current best objective, not best_obj - 1. This code is not really used
but we should still fix it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a50f6b2e15a22c84832d366f0007a4181 "<a class="el" href="namespaceoperations__research_1_1sat.html#a50f6b2e15a22c84832d366f0007a4181">operations_research::sat::SolveWithFuMalik</a>" (LogBehavior log, const LinearBooleanProblem &amp;problem, SatSolver *solver, std::vector&lt; bool &gt; *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001752 (user): double-check the correctness if the objective coefficients are
negative. 
 &lt;p&gt; \anchor _todo001724 (user): The algorithm does not really need the &gt;= 1 side of this
constraint. Initial investigation shows that it doesn't really help,
but investigate more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0b63b0a48f67ce229ee2dad04ac1251c "<a class="el" href="namespaceoperations__research_1_1sat.html#a0b63b0a48f67ce229ee2dad04ac1251c">operations_research::sat::SolveWithPresolve</a>" (std::unique_ptr&lt; SatSolver &gt; *solver, TimeLimit *time_limit, std::vector&lt; bool &gt; *solution, DratProofHandler *drat_proof_handler, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002032 (user): Revisit the situation when we simplify better all the clauses
using binary ones. Or if/when we support at most one better in pure SAT
solving and presolve. 
 &lt;p&gt; \anchor _todo002031 (user): Pass the time_limit to the presolver.
 &lt;p&gt; \anchor _todo002030 (user): Find a better place for this? 
 &lt;p&gt; \anchor _todo002029 (user): Use a derived time limit in the probing phase. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8abc4dbbf0f07254a3963bea650712b5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8abc4dbbf0f07254a3963bea650712b5">operations_research::sat::SolveWithWPM1</a>" (LogBehavior log, const LinearBooleanProblem &amp;problem, SatSolver *solver, std::vector&lt; bool &gt; *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001727 (user): Experiment more. 
 &lt;p&gt; \anchor _todo001726 (user): That was because of a bug before in the way
stratified_lower_bound was decremented, not sure it helps that much now. 
 &lt;p&gt; \anchor _todo001725 (user): Try more advanced variant where the bound is lowered by
more than this minimal amount. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5154a61154ff9b3522e0c0eba7ed0319 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5154a61154ff9b3522e0c0eba7ed0319">operations_research::sat::SplitAroundLpValue</a>" (IntegerVariable var, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001519 (user): Depending if we branch up or down, this might not exclude the
LP value, which is potentially a bad thing.&lt;p&gt; \anchor _todo001520 (user): Why is the reduced cost doing things differently? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SquarePropagator Class \_internalref classoperations__research_1_1sat_1_1SquarePropagator "<a class="el" href="classoperations__research_1_1sat_1_1SquarePropagator.html">operations_research::sat::SquarePropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001510 (user): Only works for x nonnegative. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#a2e92cf06868589083c5369b049fc5a26 "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#a2e92cf06868589083c5369b049fc5a26">operations_research::sat::StampingSimplifier::ComputeStampsForNextRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001916 (user): compute some dtime, it is always zero currently.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#abf4ca83561578670ef702769097d29fd "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#abf4ca83561578670ef702769097d29fd">operations_research::sat::StampingSimplifier::DoOneRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001915 (user): We could probably deal with it if needed so that we don't
need to do equivalence detection each time we want to run this. 
 &lt;p&gt; \anchor _todo001952 (user): To save one scan over all the clauses, we could do the fixed
and equivalence variable cleaning here too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#adeaa7bc64c667a667195ba5f6161f8c1 "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#adeaa7bc64c667a667195ba5f6161f8c1">operations_research::sat::StampingSimplifier::ProcessClauses</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001921 (user): Note that it is okay to still use top_entry, but we
might miss the removal of b if b =&gt; c. Also the paper do things
differently. Make sure we don't miss any simplification
opportunites by not changing top_entry. Same in the other
branches. 
 &lt;p&gt; \anchor _todo001920 below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#ab4ed798d7a5c1b5957e4f9605963174e "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#ab4ed798d7a5c1b5957e4f9605963174e" title="Visible for testing.">operations_research::sat::StampingSimplifier::SampleTreeAndFillParent</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001919 (user): More generally, we could sample a parent while probing so
that we consider all hyper binary implications (in the case we don't add
them to the implication graph already). 
 &lt;p&gt; \anchor _todo001918 (user): if parents_[x] = y, try not to have parents_[not(y)] = not(x)
because this is not as useful for the simplification power.&lt;p&gt; \anchor _todo001917 (user): Better algo to not select redundant parent.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a68765bc7ed07ce93ffeddbe61ad40d65 "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a68765bc7ed07ce93ffeddbe61ad40d65">operations_research::sat::SubSolver::GenerateTask</a>" (int64_t task_id)=0&lt;/dt&gt;&lt;dd&gt; \anchor _todo002041 (user): We could use a more complex selection logic and pass in the
deterministic time limit this subtask should run for. Unclear at this
stage. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a2ea7521a0af32b0d139bed747b4bb83e "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a2ea7521a0af32b0d139bed747b4bb83e">operations_research::sat::SubSolver::score</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002042 (user): This is unused for now. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SymmetryPropagator Class \_internalref classoperations__research_1_1sat_1_1SymmetryPropagator "<a class="el" href="classoperations__research_1_1sat_1_1SymmetryPropagator.html">operations_research::sat::SymmetryPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002044 (user): Implement the optimizations mentioned in the paper?
 &lt;p&gt; &lt;p&gt;(user): Instrument and see if the code can be optimized. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SymmetryPropagator Member \_internalref classoperations__research_1_1sat_1_1SymmetryPropagator#a020a35d3244af33a45a416f037529459 "<a class="el" href="classoperations__research_1_1sat_1_1SymmetryPropagator.html#a020a35d3244af33a45a416f037529459">operations_research::sat::SymmetryPropagator::AddSymmetry</a>" (std::unique_ptr&lt; SparsePermutation &gt; permutation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002045 (user): Currently this can only be called before PropagateNext() is
called (DCHECKed). Not sure if we need more incrementality though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TimeTablingPerTask Class \_internalref classoperations__research_1_1sat_1_1TimeTablingPerTask "<a class="el" href="classoperations__research_1_1sat_1_1TimeTablingPerTask.html">operations_research::sat::TimeTablingPerTask</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002071 (user): Use SchedulingDemandHelper. In particular, if we know the task
is from a set of fixed alternatives, we might be able to push it more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TimeTablingPerTask Member \_internalref classoperations__research_1_1sat_1_1TimeTablingPerTask#a3e048be6a5e38900071af4c347b0dff9 "<a class="el" href="classoperations__research_1_1sat_1_1TimeTablingPerTask.html#a3e048be6a5e38900071af4c347b0dff9">operations_research::sat::TimeTablingPerTask::TimeTablingPerTask</a>" (AffineExpression capacity, SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002066 (user): This usually correspond to a makespan interval.
We should just detect and propagate it separately as it would result
in a faster propagation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopN Class \_internalref classoperations__research_1_1sat_1_1TopN "operations_research::sat::TopN&lt; Element &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001594 (user): We could use gtl::TopN when/if it gets open sourced. Note that
we might be slighlty faster here since we use an indirection and don't move
the Element class around as much. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopN Member \_internalref classoperations__research_1_1sat_1_1TopN#a8fe7c08fd789ab0aafcd4878d6784e78 "<a class="el" href="classoperations__research_1_1sat_1_1TopN.html#a8fe7c08fd789ab0aafcd4878d6784e78">operations_research::sat::TopN&lt; Element &gt;::Add</a>" (Element e, double score)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001597 (user): We could delay that on the n + 1 push.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopNCuts Class \_internalref classoperations__research_1_1sat_1_1TopNCuts "<a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">operations_research::sat::TopNCuts</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001595 (user): Avoid computing efficacity twice.
 &lt;p&gt; &lt;p&gt;(user): We don't use any orthogonality consideration here.
 &lt;p&gt; &lt;p&gt;(user): Detect duplicate cuts? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Trail Member \_internalref classoperations__research_1_1sat_1_1Trail#af94a42301fbeb5da23fdfd2c914f2a01 "<a class="el" href="classoperations__research_1_1sat_1_1Trail.html#af94a42301fbeb5da23fdfd2c914f2a01">operations_research::sat::Trail::Resize</a>" (int num_variables)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001879 (user): these vectors are not always used. Initialize them
dynamically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8fc9e60de9ebec04b0d8e62c0bcd7aa1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8fc9e60de9ebec04b0d8e62c0bcd7aa1">operations_research::sat::TransformToGeneratorOfStabilizer</a>" (int to_stabilize, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002050 (user): Implement! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7e710c5266505c51982912036c840755 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7e710c5266505c51982912036c840755" title="Adds linearization of different types of constraints.">operations_research::sat::TryToLinearizeConstraint</a>" (const CpModelProto &amp;model_proto, const ConstraintProto &amp;ct, int linearization_level, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *helper=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001685 (user): In full generality, we could encode all the constraint as an LP.
 &lt;p&gt; &lt;p&gt;(user): Add unit tests for this method.
 &lt;p&gt; &lt;p&gt;(user): Remove and merge with model loading. 
 &lt;p&gt; \anchor _todo001686 (user): Use the same pattern as the other 2 scheduling methods:
  - single function
  - generate helpers once&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a825ac0e104b7cc8d0a02690bc26c9325 "<a class="el" href="namespaceoperations__research_1_1sat.html#a825ac0e104b7cc8d0a02690bc26c9325">operations_research::sat::TryToReconcileEncodings</a>" (const AffineExpression &amp;size2_affine, const AffineExpression &amp;affine, const std::vector&lt; ValueLiteralPair &gt; &amp;affine_var_encoding, bool put_affine_left_in_result, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001433 (user): I am not sure how this can happen since size2_affine is
supposed to be non-fixed. Maybe we miss some propag. Investigate. 
 &lt;p&gt; \anchor _todo001432 (user): Consider removing this once we are more complete in our implied
bounds repository. Because if we can reconcile an encoding, then any of the
literal in the at most one should imply a value on the boolean view use in
the size2 affine. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a67f3b45ddd9ba6330059295e6258e4e6 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a67f3b45ddd9ba6330059295e6258e4e6">operations_research::sat::UpperBoundedLinearConstraint::AddToConflict</a>" (MutableUpperBoundedLinearConstraint *conflict)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001780 (user): Provides instead an easy to use iterator over an
UpperBoundedLinearConstraint and move this function to
MutableUpperBoundedLinearConstraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a7e533d8923312b0d052abae98cab81b8 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a7e533d8923312b0d052abae98cab81b8">operations_research::sat::UpperBoundedLinearConstraint::FillReason</a>" (const Trail &amp;trail, int source_trail_index, BooleanVariable propagated_variable, std::vector&lt; Literal &gt; *reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001779 (user): Maybe it is possible to derive a better reason by using more
information. For instance one could use the mask of literals that are
better to use during conflict minimization (namely the one already in the
1-UIP conflict). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#ab83a887ed56694501b3e60f573db6d74 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#ab83a887ed56694501b3e60f573db6d74">operations_research::sat::UpperBoundedLinearConstraint::InitializeRhs</a>" (Coefficient rhs, int trail_index, Coefficient *threshold, Trail *trail, PbConstraintsEnqueueHelper *helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001765 (user): The source trail index for the propagation reason (i.e.
max_relevant_trail_index) may be higher than necessary (for some of the
propagated literals). Currently this works with FillReason(), but it was a
source of a really nasty bug (see CL 68906167) because of the (rhs == 1)
optim. Find a good way to test the logic. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a0d48dc8a24a03dea028d9f0e62ee257f "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a0d48dc8a24a03dea028d9f0e62ee257f">operations_research::sat::UpperBoundedLinearConstraint::ResolvePBConflict</a>" (const Trail &amp;trail, BooleanVariable var, MutableUpperBoundedLinearConstraint *conflict, Coefficient *conflict_slack)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001769 (user): track the cancelation here so we can update
*conflict_slack properly. 
 &lt;p&gt; \anchor _todo001768 (user): The best will be to relax as little as possible. 
 &lt;p&gt; \anchor _todo001767 (user): If there is more "cancelation" than the min_coeffs below when
we add the two constraints, the resulting slack may be even lower. Taking
that into account is probably good. 
 &lt;p&gt; \anchor _todo001766 (user): Investigate if this is a good idea. It doesn't happen often,
but does happened. Maybe we can detect this before in Propagate()? The
setup is:
- At a given trail_index, var is propagated and added on the trail.
- There is some constraint literals assigned to true with a trail index
  in (trail_index, var.trail_index).
- Their sum is high enough to cause a conflict.
- But individually, their coefficients are too small to be propagated, so
  the conflict is not yet detected. It will be when these variables are
  processed by PropagateNext(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2eec7d4958da587ee893e334ab7756cc "<a class="el" href="namespaceoperations__research_1_1sat.html#a2eec7d4958da587ee893e334ab7756cc">operations_research::sat::ValidateCpModel</a>" (const CpModelProto &amp;model, bool after_presolve)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000979 (user): Add any needed overflow validation because we are far from
exhaustive. We could also run a small presolve that tighten variable bounds
before the overflow check to facilitate the lives of our users, but it is a
some work to put in place. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2073b9c892ac56b197b31cb583e25f3d "<a class="el" href="namespaceoperations__research_1_1sat.html#a2073b9c892ac56b197b31cb583e25f3d">operations_research::sat::ValidateInputCpModel</a>" (const SatParameters &amp;params, const CpModelProto &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000980 (user): Ideally we would have just one ValidateCpModel() function but
this was introduced after many users already use ValidateCpModel() without
parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad582c9543b77917ac1084bbfda601f5e "<a class="el" href="namespaceoperations__research_1_1sat.html#ad582c9543b77917ac1084bbfda601f5e">operations_research::sat::ValidateLinearConstraintForOverflow</a>" (const LinearConstraint &amp;constraint, const IntegerTrail &amp;integer_trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001578 (user): Avoid duplication with PossibleIntegerOverflow() in the checker?
At least make sure the code is the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a80f1b6bbf960239725bec385f09a5b14 "<a class="el" href="namespaceoperations__research_1_1sat.html#a80f1b6bbf960239725bec385f09a5b14">operations_research::sat::ValidateParameters</a>" (const SatParameters &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001758 (user): Consider using annotations directly in the proto for these
validation. It is however not open sourced. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a007d129b4917935f84c9ae0823c2cb11 "<a class="el" href="namespaceoperations__research_1_1sat.html#a007d129b4917935f84c9ae0823c2cb11">operations_research::sat::VarDebugString</a>" (const CpModelProto &amp;proto, int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000976 (user): Use domain pretty print function.
 &lt;p&gt; \anchor _todo000975 (user): unfortunately, we need this indirection to get a DebugString()
in a const way from an index. Because building an IntVar is non-const. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VarDomination Class \_internalref classoperations__research_1_1sat_1_1VarDomination "<a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">operations_research::sat::VarDomination</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002115 (user): We have a lot of benchmarks and tests that shows that we don't
report wrong relations, but we lack unit test that make sure we don't miss
any. Try to improve the situation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VarDomination Member \_internalref classoperations__research_1_1sat_1_1VarDomination#ab03b7579b6f0728fd7c98fccae5196ed "<a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html#ab03b7579b6f0728fd7c98fccae5196ed">operations_research::sat::VarDomination::EndFirstPhase</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002095 (user): Maybe we should do that with all lists in case the
input function are called with duplicates too. 
 &lt;p&gt; \anchor _todo002090 (user): Use more heuristics to not miss as much dominance relation when
we crop initial lists. 
 &lt;p&gt; \anchor _todo002091 (user): Tune the initial size, 50 might be a bit large, since our
complexity is borned by this number times the number of entries in the
constraints. Still we should in most situation be a lot lower than that. 
 &lt;p&gt; \anchor _todo002092 (user): randomize? 
 &lt;p&gt; \anchor _todo002093 (user): This can be too long maybe? even if we have list of at
most 1000 at this point, see InitializeUsingTempRanks(). 
 &lt;p&gt; \anchor _todo002094 (user): randomize? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VariableWithSameReasonIdentifier Class \_internalref classoperations__research_1_1sat_1_1VariableWithSameReasonIdentifier "<a class="el" href="classoperations__research_1_1sat_1_1VariableWithSameReasonIdentifier.html">operations_research::sat::VariableWithSameReasonIdentifier</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001776 (user): With the new SAME_REASON_AS mechanism, this is more general so
move out of pb_constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2d7fdf5a1e3a1a9f3c4b893227f2f523 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2d7fdf5a1e3a1a9f3c4b893227f2f523" title="Weighted sum &lt;= constant.">operations_research::sat::WeightedSumLowerOrEqual</a>" (const std::vector&lt; IntegerVariable &gt; &amp;vars, const VectorInt &amp;coefficients, int64_t upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001512 (user): If the initial constraint was an equalilty we will create
the "intermediate" variable twice where we could have use the same for
both direction. Improve? 
 &lt;p&gt; \anchor _todo001511 (user): Alternatively, we could use a O(num_changes) propagation (a
bit tricky to implement), or a decomposition into a tree with more than
one level. Both requires experimentations.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a64577e0206830814a452b8e9903c050b "<a class="el" href="namespaceoperations__research_1_1sat.html#a64577e0206830814a452b8e9903c050b">operations_research::sat::WeightedSumNotEqual</a>" (const std::vector&lt; IntegerVariable &gt; &amp;vars, const VectorInt &amp;coefficients, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001516 (user): Simplify if the constant is at the edge of the possible values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#a12946ae3e255ff1c79833236ffb8aaff "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#a12946ae3e255ff1c79833236ffb8aaff">operations_research::sat::ZeroHalfCutHelper::AddOneConstraint</a>" (glop::RowIndex, const std::vector&lt; std::pair&lt; glop::ColIndex, IntegerValue &gt; &gt; &amp;terms, IntegerValue lb, IntegerValue ub)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002118 (user): Avoid adding duplicates and just randomly pick one. Note
that we should also remove duplicate in a generic way. 
 &lt;p&gt; \anchor _todo002117 (user): experiment with the best value. probably only tight rows are
best? and we could use the basis status rather than recomputing the
activity for that.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#afdfcb5fc07e17801df44b7eb133476a0 "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#afdfcb5fc07e17801df44b7eb133476a0">operations_research::sat::ZeroHalfCutHelper::ProcessVariables</a>" (const std::vector&lt; double &gt; &amp;lp_values, const std::vector&lt; IntegerValue &gt; &amp;lower_bounds, const std::vector&lt; IntegerValue &gt; &amp;upper_bounds)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002120 (user): This is a first implementation, both the heuristic and the
code performance can probably be improved uppon. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#ae324ccfd64cd5663fe8aaf6bfca125ef "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#ae324ccfd64cd5663fe8aaf6bfca125ef">operations_research::sat::ZeroHalfCutHelper::SymmetricDifference</a>" (std::function&lt; bool(int)&gt; extra_condition, const std::vector&lt; int &gt; &amp;a, std::vector&lt; int &gt; *b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002119 (user): optim by doing that at the end?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SatInterface Member \_internalref classoperations__research_1_1SatInterface#aa547bd3bd6144efef0c257ada432a5d7 "<a class="el" href="classoperations__research_1_1SatInterface.html#aa547bd3bd6144efef0c257ada432a5d7">operations_research::SatInterface::DirectlySolveProto</a>" (const MPModelRequest &amp;request, std::atomic&lt; bool &gt; *interrupt) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000736 (user): Move that conversion to SatSolveProto, which should always
return a MPSolutionResponse, even for errors. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SatInterface Member \_internalref classoperations__research_1_1SatInterface#aa26cae7629efd16954fcc84081c98410 "<a class="el" href="classoperations__research_1_1SatInterface.html#aa26cae7629efd16954fcc84081c98410">operations_research::SatInterface::SetPresolveMode</a>" (int value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000737 (user): Implement me.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a559cc338aef2e312801b914bc67370ba "<a class="el" href="namespaceoperations__research.html#a559cc338aef2e312801b914bc67370ba">operations_research::SatSolveProto</a>" (MPModelRequest request, std::atomic&lt; bool &gt; *interrupt_solve, std::function&lt; void(const std::string &amp;)&gt; logging_callback, std::function&lt; void(const MPSolution &amp;)&gt; solution_callback)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000731 (user): Remove the postsolve hack of copying to a response. 
 &lt;p&gt; \anchor _todo000730 (user): Implement the row and column status. 
 &lt;p&gt; \anchor _todo000728 (user): We do not support all the parameters here. In particular the
logs before the solver is called will not be appended to the response. Fix
that, and remove code duplication for the logger config. One way should be
to not touch/configure anything if the logger is already created while
calling SolveCpModel() and call a common config function from here or from
inside Solve()? 
 &lt;p&gt; \anchor _todo000729 (user): We put the INFEASIBLE_OR_UNBOUNBED case here since there
is no return status that exactly matches it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SavingsFilteredHeuristic::SavingsContainer Member \_internalref classoperations__research_1_1SavingsFilteredHeuristic_1_1SavingsContainer#a540b8ac71e4a7b1341ec7451e0a3df83 "<a class="el" href="classoperations__research_1_1SavingsFilteredHeuristic_1_1SavingsContainer.html#a540b8ac71e4a7b1341ec7451e0a3df83">operations_research::SavingsFilteredHeuristic::SavingsContainer&lt; Saving &gt;::Sort</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000330 (user): Also do this when reiterating on next_savings_. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScipConstraintHandlerContext Member \_internalref classoperations__research_1_1ScipConstraintHandlerContext#ae4b686d5d1040fcf4db709e98a2022af "<a class="el" href="classoperations__research_1_1ScipConstraintHandlerContext.html#ae4b686d5d1040fcf4db709e98a2022af">operations_research::ScipConstraintHandlerContext::is_pseudo_solution</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000743 (user): maybe this can be abstracted away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScipConstraintHandlerDescription Class \_internalref structoperations__research_1_1ScipConstraintHandlerDescription "<a class="el" href="structoperations__research_1_1ScipConstraintHandlerDescription.html">operations_research::ScipConstraintHandlerDescription</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000742 (user): no effort has been made to optimize the default values of
enforcement_priority, feasibility_check_priority, eager_frequency, or
separation_priority. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SCIPInterface Member \_internalref classoperations__research_1_1SCIPInterface#a8682d7f525de8a5c389cf5e1b495f1ac "<a class="el" href="classoperations__research_1_1SCIPInterface.html#a8682d7f525de8a5c389cf5e1b495f1ac">operations_research::SCIPInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000746 (user): We could introduce our own "infeasible or unbounded" status. 
 &lt;p&gt; \anchor _todo000745 (user): I more or less copied this from the SCIPreadSol() code that
reads a solution from a file. I am not sure what SCIPisTransformed() is
or what is the difference between the try and add version. In any case
this seems to always call SCIPaddSolFree() for now and it works. 
 &lt;p&gt; \anchor _todo000744 (user): Is that still true now (2018) ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScopedFloatingPointEnv Class \_internalref classoperations__research_1_1ScopedFloatingPointEnv "<a class="el" href="classoperations__research_1_1ScopedFloatingPointEnv.html">operations_research::ScopedFloatingPointEnv</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002129 (user): Make it work on 32 bits.
 &lt;p&gt; &lt;p&gt;(user): Make it work on msvc, currently calls to _controlfp crash. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SequenceVar Member \_internalref classoperations__research_1_1SequenceVar#ac8f9d8f2220c77dd4f79a652e6aa7b88 "<a class="el" href="classoperations__research_1_1SequenceVar.html#ac8f9d8f2220c77dd4f79a652e6aa7b88">operations_research::SequenceVar::ComputePossibleFirstsAndLasts</a>" (std::vector&lt; int &gt; *const possible_firsts, std::vector&lt; int &gt; *const possible_lasts)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000337 (user): use domain iterator.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SequenceVar Member \_internalref classoperations__research_1_1SequenceVar#a5cd7df5031e4b9e89532c03f542078aa "<a class="el" href="classoperations__research_1_1SequenceVar.html#a5cd7df5031e4b9e89532c03f542078aa" title="--‚Äî SequenceVar --‚Äî">operations_research::SequenceVar::SequenceVar</a>" (Solver *const s, const std::vector&lt; IntervalVar * &gt; &amp;intervals, const std::vector&lt; IntVar * &gt; &amp;nexts, const std::string &amp;name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000336 (user): Add better class invariants, in particular checks
that ranked_first, ranked_last, and unperformed are truly disjoint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleLinearSumAssignment Member \_internalref classoperations__research_1_1SimpleLinearSumAssignment#a613c560fdd07ae94350736adaf2dab56 "<a class="el" href="classoperations__research_1_1SimpleLinearSumAssignment.html#a613c560fdd07ae94350736adaf2dab56">operations_research::SimpleLinearSumAssignment::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000567 (user): Improve the LinearSumAssignment api to clearly define
the error cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Class \_internalref classoperations__research_1_1SimpleMaxFlow "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html">operations_research::SimpleMaxFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000614 (user): If the need arises, extend this interface to support warm start. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Member \_internalref classoperations__research_1_1SimpleMaxFlow#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700 "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700">operations_research::SimpleMaxFlow::POSSIBLE_OVERFLOW</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000617 (user): rename POSSIBLE_OVERFLOW to INT_OVERFLOW and modify our
    clients. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Member \_internalref classoperations__research_1_1SimpleMaxFlow#a57296b653813abdd8d711048e87d1212 "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a57296b653813abdd8d711048e87d1212">operations_research::SimpleMaxFlow::SetArcCapacity</a>" (ArcIndex arc, FlowQuantity capacity)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000616 (user): Support incrementality in the max flow implementation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMinCostFlow Class \_internalref classoperations__research_1_1SimpleMinCostFlow "<a class="el" href="classoperations__research_1_1SimpleMinCostFlow.html">operations_research::SimpleMinCostFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000628 (user): If the need arises, extend this interface to support warm start
and incrementality between solves. Note that this is already supported by the
GenericMinCostFlow&lt;&gt; interface. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a87ca0b6abf9c8724900387f5aa557c04 "<a class="el" href="classoperations__research_1_1Solver.html#a87ca0b6abf9c8724900387f5aa557c04">operations_research::Solver::Action</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000105 (user): wrap in swig.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a51c801ef84c5843e4b9a1ba489a15f0f "<a class="el" href="classoperations__research_1_1Solver.html#a51c801ef84c5843e4b9a1ba489a15f0f">operations_research::Solver::AddPropagationMonitor</a>" (PropagationMonitor *const monitor)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000100 (user): Check solver state?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a00ddb4cf5be5463ec6b494808bc8f192 "<a class="el" href="classoperations__research_1_1Solver.html#a00ddb4cf5be5463ec6b494808bc8f192" title="--‚Äî ConstraintSolverParameters --‚Äî">operations_research::Solver::DefaultSolverParameters</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000106 (user): Move to constraint_solver_parameters.h. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ae3b660d3dece402d0ca5448d127c0f6f "<a class="el" href="classoperations__research_1_1Solver.html#ae3b660d3dece402d0ca5448d127c0f6f">operations_research::Solver::GetOrCreateLocalSearchState</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000122 (user): Investigate if this should be moved to Search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aeb2e6947882d148bfaece200f5c6b131 "<a class="el" href="classoperations__research_1_1Solver.html#aeb2e6947882d148bfaece200f5c6b131" title="Returns whether we are instrumenting demons.">operations_research::Solver::InstrumentsDemons</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000095 (user): remove this complex logic.
We need the double test because parameters are set too late when using
python in the open source. This is the cheapest work-around. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ae63acd77b8c2ee40387795051298f659 "<a class="el" href="classoperations__research_1_1Solver.html#ae63acd77b8c2ee40387795051298f659">operations_research::Solver::IntValueStrategy</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000104 (user): add HIGHEST_MIN and LOWEST_MAX.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a64fd8adbc00c3bed16bf4b824dfd3e2b "<a class="el" href="classoperations__research_1_1Solver.html#a64fd8adbc00c3bed16bf4b824dfd3e2b">operations_research::Solver::LocalSearchProfile</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000120 (user): Merge demon and local search profiles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a579ddb4232150f04e17c0852fc8e1c60 "<a class="el" href="classoperations__research_1_1Solver.html#a579ddb4232150f04e17c0852fc8e1c60" title="Force the &quot;nexts&quot; variable to create a complete Hamiltonian path.">operations_research::Solver::MakeCircuit</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000176 (user): Merge NoCycle and Circuit.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa1b2edf76ef068b3d1cc8b56f7e7af23 "<a class="el" href="classoperations__research_1_1Solver.html#aa1b2edf76ef068b3d1cc8b56f7e7af23">operations_research::Solver::MakeDelayedPathCumul</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, const std::vector&lt; IntVar * &gt; &amp;cumuls, const std::vector&lt; IntVar * &gt; &amp;transits)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000111 (user): Merge with other path-cumuls constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0132207ac0371c18971693c8a6d9b29c "<a class="el" href="classoperations__research_1_1Solver.html#a0132207ac0371c18971693c8a6d9b29c" title="Aggregated version of count: |{i | v[i] == values[j]}| == cards[j].">operations_research::Solver::MakeDistribute</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; int64_t &gt; &amp;values, const std::vector&lt; IntVar * &gt; &amp;cards)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000137 (user) : we can sort values (and cards) before doing the test.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ac4d44e87bf1028b31eb5b9f7e13cfb0e "<a class="el" href="classoperations__research_1_1Solver.html#ac4d44e87bf1028b31eb5b9f7e13cfb0e" title="expr / value (integer division)">operations_research::Solver::MakeDiv</a>" (IntExpr *const expr, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000157 (user) : implement special case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a9d305482b4f8adbbac471fbe16f0fbd9 "<a class="el" href="classoperations__research_1_1Solver.html#a9d305482b4f8adbbac471fbe16f0fbd9" title="boolvar == (var == value)">operations_research::Solver::MakeIsEqualCstCt</a>" (IntExpr *const var, int64_t value, IntVar *const boolvar)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000152 (user) : what happens if the constraint is not posted?
The cache becomes tainted. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a10c9da29e0f571f2fac430761d133016 "<a class="el" href="classoperations__research_1_1Solver.html#a10c9da29e0f571f2fac430761d133016">operations_research::Solver::MakeLexicalLess</a>" (const std::vector&lt; IntVar * &gt; &amp;left, const std::vector&lt; IntVar * &gt; &amp;right)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000109 (user): Add void MakeSortedArray(
                            const std::vector&lt;IntVar*&gt;&amp; vars,
                            std::vector&lt;IntVar*&gt;* const sorted); 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a8b59e7e5baa7c33b6c2d9f69b610de9d "<a class="el" href="classoperations__research_1_1Solver.html#a8b59e7e5baa7c33b6c2d9f69b610de9d">operations_research::Solver::MakeLocalSearchPhase</a>" (Assignment *const assignment, LocalSearchPhaseParameters *const parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000119 (user): Make a variant which runs a local search after each
               solution found in a DFS. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa8c0e8504dd5125dd200e9e3d9ef1e75 "<a class="el" href="classoperations__research_1_1Solver.html#aa8c0e8504dd5125dd200e9e3d9ef1e75">operations_research::Solver::MakeNoCycle</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, IndexFilter1 sink_handler=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000110 (user): Implement MakeAllNullIntersect taking an array of
variable vectors. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#af20386dc6e5a03abad785ff29d3f1769 "<a class="el" href="classoperations__research_1_1Solver.html#af20386dc6e5a03abad785ff29d3f1769">operations_research::Solver::MakeNotBetweenCt</a>" (IntExpr *const expr, int64_t l, int64_t u)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000153 (user): Add back simplification code if expr is constant *
other_expr. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ac78afa51e3d5d28e84916a6fc47375de "<a class="el" href="classoperations__research_1_1Solver.html#a690d787d381fead53bcfd003d2fa34ac" title="Local Search Operators.">operations_research::Solver::MakeOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IndexEvaluator3 evaluator, EvaluatorLocalSearchOperators op)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000118 (user): Make the callback an IndexEvaluator2 when there are no
secondary variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0456a638eb3c86b7e3c6bbcc6f1a961c "<a class="el" href="classoperations__research_1_1Solver.html#a0456a638eb3c86b7e3c6bbcc6f1a961c">operations_research::Solver::MakePathConnected</a>" (std::vector&lt; IntVar * &gt; nexts, std::vector&lt; int64_t &gt; sources, std::vector&lt; int64_t &gt; sinks, std::vector&lt; IntVar * &gt; status)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000112 (user): Only does checking on WhenBound events on next variables.
Check whether more propagation is needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a793b6001916186ac1d7041a10fdd41d6 "<a class="el" href="classoperations__research_1_1Solver.html#a793b6001916186ac1d7041a10fdd41d6">operations_research::Solver::MakePathPrecedenceConstraint</a>" (std::vector&lt; IntVar * &gt; nexts, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;precedences)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000113 (user): This constraint does not make holes in variable domains;
the implementation can easily be modified to do that; evaluate the impact
on models solved with local search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a039ebfef32db8ee5641b25328954cce9 "<a class="el" href="classoperations__research_1_1Solver.html#a66461677e91be7682f36b8660889fd2f">operations_research::Solver::MakePhase</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IndexEvaluator2 eval, IndexEvaluator1 tie_breaker, EvaluatorStrategy str)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000341 (user): support tie breaker
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a66461677e91be7682f36b8660889fd2f "<a class="el" href="classoperations__research_1_1Solver.html#a66461677e91be7682f36b8660889fd2f">operations_research::Solver::MakePhase</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IntVarStrategy var_str, IntValueStrategy val_str)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000117 (user): name each of them differently, and document them (and do that
for all other functions that have several homonyms in this .h). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a84584b7705a787a70e09341e4a0e30f5 "<a class="el" href="classoperations__research_1_1Solver.html#a84584b7705a787a70e09341e4a0e30f5">operations_research::Solver::MakePiecewiseLinearExpr</a>" (IntExpr *expr, const PiecewiseLinearFunction &amp;f)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000107 (user): Investigate if we can merge all three piecewise linear
expressions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ac9865c3135d8b9b3f7de73c92dac53a4 "<a class="el" href="classoperations__research_1_1Solver.html#ac9865c3135d8b9b3f7de73c92dac53a4">operations_research::Solver::MakeSearchLog</a>" (int branch_period)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000115 (user): DEPRECATE API of MakeSearchLog(.., IntVar* var,..).
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a1df5ff14dc4a01cc9a3c83072583364f "<a class="el" href="classoperations__research_1_1Solver.html#a1df5ff14dc4a01cc9a3c83072583364f">operations_research::Solver::MakeSemiContinuousExpr</a>" (IntExpr *const expr, int64_t fixed_charge, int64_t step)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000158 (user) : benchmark with virtualization of
PosIntDivDown and PosIntDivUp - or function pointers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ad80c06a937a0eb2429dfce14bd03daf7 "<a class="el" href="classoperations__research_1_1Solver.html#ad80c06a937a0eb2429dfce14bd03daf7">operations_research::Solver::MakeSimulatedAnnealing</a>" (bool maximize, IntVar *const v, int64_t step, int64_t initial_temperature)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000114 (user): document behavior 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0d6603ccdf190d08e5eb55a383cb7f42 "<a class="el" href="classoperations__research_1_1Solver.html#a0d6603ccdf190d08e5eb55a383cb7f42">operations_research::Solver::MakeSortingConstraint</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;sorted)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000108 (user): Do we need a version with an array of escape values.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a67ed18b7174df0eb483834276f19ce73 "<a class="el" href="classoperations__research_1_1Solver.html#a67ed18b7174df0eb483834276f19ce73" title="Opens a new top level search.">operations_research::Solver::NewSearch</a>" (DecisionBuilder *const db, const std::vector&lt; SearchMonitor * &gt; &amp;monitors)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000097 (user) : reset statistics
 &lt;p&gt; \anchor _todo000099 (user): Check if these two lines are still necessary.
 &lt;p&gt; \anchor _todo000098 (user): delete top level search after EndSearch(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#afa66a85cec14980401bb16d4f4a84aa1 "<a class="el" href="classoperations__research_1_1Solver.html#afa66a85cec14980401bb16d4f4a84aa1">operations_research::Solver::SetUseFastLocalSearch</a>" (bool use_fast_local_search)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000121 (user): Get rid of the following methods once fast local search is
enabled for metaheuristics.
Disables/enables fast local search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a205c42a927f4d97f659bf4dcfcfd6ad6 "<a class="el" href="classoperations__research_1_1Solver.html#a205c42a927f4d97f659bf4dcfcfd6ad6">operations_research::Solver::Try</a>" (DecisionBuilder *const db1, DecisionBuilder *const db2)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000116 (user): The search tree can be balanced by using binary
"Try"-builders "recursively". For instance, Try(a,b,c,d) will give a tree
unbalanced to the right, whereas Try(Try(a,b), Try(b,c)) will give a
balanced tree. Investigate if we should only provide the binary version
and/or if we should balance automatically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Class \_internalref classoperations__research_1_1SortedDisjointIntervalList "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html">operations_research::SortedDisjointIntervalList</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002151 (user): Templatize the class on the type of the bounds.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#a53aa27777a48b981046ad09b97bded60 "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a53aa27777a48b981046ad09b97bded60">operations_research::SortedDisjointIntervalList::InsertInterval</a>" (int64_t start, int64_t end)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002148 (user): tune the algorithm below if it proves to be a bottleneck.
For example, one could try to avoid an insertion if it's not needed
(when the interval merges with a single existing interval or is fully
contained by one). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#ad937d5864aa7a209f5c565a49daad904 "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a012ebc58df4ae590e12e89509b69ee90">operations_research::SortedDisjointIntervalList::InsertIntervals</a>" (const std::vector&lt; int &gt; &amp;starts, const std::vector&lt; int &gt; &amp;ends)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002149 (user): treat kint32min and kint32max as their kint64 variants.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#a592c99d8ddbc2a357683903882c437ba "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a1d800ef9b7bcda7b2bd88941e63e9c0d">operations_research::SortedDisjointIntervalList::SortedDisjointIntervalList</a>" (const std::vector&lt; int64_t &gt; &amp;starts, const std::vector&lt; int64_t &gt; &amp;ends)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002153 (user): Explain why we favored this API to the more natural
input std::vector&lt;ClosedInterval&gt; or std::vector&lt;std::pair&lt;int, int&gt;&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#a9fc0ca5752b5ad6cc2a78ff7c512b22a "<a class="el" href="classoperations__research_1_1SparsePermutation.html#a9fc0ca5752b5ad6cc2a78ff7c512b22a">operations_research::SparsePermutation::LastElementInCycle</a>" (int i) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000035 (user): Provide a full iterator for this? Note that we have more
information with the loop above. Not sure it is needed though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#abca48ca404a02f35f06f295814407100 "<a class="el" href="classoperations__research_1_1SparsePermutation.html#abca48ca404a02f35f06f295814407100">operations_research::SparsePermutation::RemoveCycles</a>" (const std::vector&lt; int &gt; &amp;cycle_indices)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000033 (user): make this a class member to avoid allocation if the complexity
becomes an issue. In this case, also optimize the loop below by not copying
the first cycles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#aff385d18c768ffa364c5dccb5fb35c0a "<a class="el" href="classoperations__research_1_1SparsePermutation.html#aff385d18c768ffa364c5dccb5fb35c0a">operations_research::SparsePermutation::Size</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000034 (user): complete the reader API.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SwapActiveToShortestPathOperator Class \_internalref classoperations__research_1_1SwapActiveToShortestPathOperator "<a class="el" href="classoperations__research_1_1SwapActiveToShortestPathOperator.html" title="| / \ ^">operations_research::SwapActiveToShortestPathOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000305 (user): Support vehicle-class-dependent arc_evaluators. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SymmetryManager Member \_internalref classoperations__research_1_1SymmetryManager#a6f8f0310d17cfdf227de35d5eaeb6ec2 "<a class="el" href="classoperations__research_1_1SymmetryManager.html#a6f8f0310d17cfdf227de35d5eaeb6ec2">operations_research::SymmetryManager::CheckSymmetries</a>" (int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000347 (user) : Improve speed, cache previous min and build them
incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeDistribution Class \_internalref classoperations__research_1_1TimeDistribution "<a class="el" href="classoperations__research_1_1TimeDistribution.html">operations_research::TimeDistribution</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002154 (user): Since we inherit from DistributionStat, we currently store the
sum of CPU cycles as a double internally. A better option is to use int64_t
because with the 53 bits of precision of a double, we will run into an issue
if the sum of times reaches 52 days for a 2GHz processor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeLimit Class \_internalref classoperations__research_1_1TimeLimit "<a class="el" href="classoperations__research_1_1TimeLimit.html">operations_research::TimeLimit</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002156 (user): The expression "deterministic time" should be replaced with
                "number of operations" to avoid confusion with "real" time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeLimit Member \_internalref classoperations__research_1_1TimeLimit#a19c0015c87403828d83a1407db6b87d7 "<a class="el" href="classoperations__research_1_1TimeLimit.html#a19c0015c87403828d83a1407db6b87d7">operations_research::TimeLimit::FromParameters</a>" (const Parameters &amp;parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002157 (user): Support adding instruction count limit from parameters.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeLimit Member \_internalref classoperations__research_1_1TimeLimit#a154ee3d0f2140ac8bbdcc4f73e31d5ba "<a class="el" href="classoperations__research_1_1TimeLimit.html#a154ee3d0f2140ac8bbdcc4f73e31d5ba">operations_research::TimeLimit::ReadInstructionCounter</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002158 (user): Use an exact counter for counting instructions. The
PMU counter returns the instruction count value as double since there may
be sampling issues. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TspLibTourParser Member \_internalref classoperations__research_1_1TspLibTourParser#a35c4ff768d130b7f9303bc1a2f96a0d7 "<a class="el" href="classoperations__research_1_1TspLibTourParser.html#a35c4ff768d130b7f9303bc1a2f96a0d7" title="Loads and parses a given tour file.">operations_research::TspLibTourParser::LoadFile</a>" (const std::string &amp;file_name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000912 (user): Return false when issues were encountered while parsing the
file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::VectorMap Member \_internalref classoperations__research_1_1VectorMap#a24f817d6d46f0eb7d6257fa6815daa62 "<a class="el" href="classoperations__research_1_1VectorMap.html#a48341814004f03c9b44e9f23be024153">operations_research::VectorMap&lt; T &gt;::Add</a>" (const std::vector&lt; T &gt; &amp;elements)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002159 (user): Use ArraySlice.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::VectorMap Member \_internalref classoperations__research_1_1VectorMap#aac3f28205e9005e7fd9c11eb552277a0 "<a class="el" href="classoperations__research_1_1VectorMap.html#aac3f28205e9005e7fd9c11eb552277a0" title="Returns whether the element has already been added to the vector-map.">operations_research::VectorMap&lt; T &gt;::Contains</a>" (const T &amp;element) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002160 (user): explore a int-type version.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#af2da644538f7224a844aaa2fb9780094 "<a class="el" href="classoperations__research_1_1XpressInterface.html#af2da644538f7224a844aaa2fb9780094">operations_research::XpressInterface::ComputeExactConditionNumber</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000754 (user): Not yet working.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a2058aa56705670ecc412c8d0424ea6d4 "<a class="el" href="classoperations__research_1_1XpressInterface.html#a2058aa56705670ecc412c8d0424ea6d4" title="Extract all variables that have not yet been extracted.">operations_research::XpressInterface::ExtractNewVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000753 : Use a bitarray to flag the constraints that actually
      intersect new variables? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#abc310138f2c0d8d95e042434378ad77b "<a class="el" href="classoperations__research_1_1XpressInterface.html#abc310138f2c0d8d95e042434378ad77b" title="Modifies integrality of an extracted variable.">operations_research::XpressInterface::SetVariableInteger</a>" (int var_index, bool integer)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000752 : Should we check the current type and don't do anything
      in case the type does not change? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope RoundToNearestEven Class \_internalref structRoundToNearestEven "<a class="el" href="structRoundToNearestEven.html" title="Is this really necessary? g++ does not like it.">RoundToNearestEven</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002141 (user): make it work on ARM, RISC-V, and POWER.
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref scip__callback_8cc#a55103a9413973772f122a9c3dfef5030 "SCIP_DECL_CONSENFOPS" (EnforcePseudoSolutionC)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000738 (user): are we sure the pseudo solution is LP feasible? It seems like
it doesn't need to be.  The code in RunSeparation might assume this? 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref scip__callback_8cc#a2e5ec3c32f1a6cde27f8a3538ea801bd "SCIP_DECL_CONSLOCK" (VariableRoundingLockC)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000739 (user): this could be a little better, but we would need to add
another method to override on ScipConstraintHandler&lt;ConstraintData&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope StronglyConnectedComponentsFinder Class \_internalref classStronglyConnectedComponentsFinder "StronglyConnectedComponentsFinder&lt; NodeIndex, Graph, SccOutput &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000658 (user): Possible optimizations:
- Try to reserve the vectors which sizes are bounded by num_nodes.
- Use an index rather than doing push_back(), pop_back() on them. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref timer_8h#a430398fcce7a0820817d8dae9c226d00 "UserTimer" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000038 (user): implement it properly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a92ffd852b2ab2e5241f9832e71a2de71 "<a class="el" href="classutil_1_1BaseGraph.html#a92ffd852b2ab2e5241f9832e71a2de71" title="Capacity reserved for future arcs, always &gt;= num_arcs_.">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::arc_capacity</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000579 (user): Same questions as the ones in node_capacity().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#aa3bd051d1e141b09dda17aa9b5f24f69 "<a class="el" href="classutil_1_1BaseGraph.html#aa3bd051d1e141b09dda17aa9b5f24f69">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::FreezeCapacities</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000580 (user): Only define this in debug mode at the cost of having a lot
of ifndef NDEBUG all over the place? remove the function completely ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a07214b96597069d781e27b1dd17ef83e "<a class="el" href="classutil_1_1BaseGraph.html#a07214b96597069d781e27b1dd17ef83e">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::GroupForwardArcsByFunctor</a>" (const A &amp;a, B *b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000582 (user): remove the public functions below. They are just here during
the transition from the old ebert_graph api to this new graph api. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a463d57480c9563a7a707c5d0928c9946 "<a class="el" href="classutil_1_1BaseGraph.html#a463d57480c9563a7a707c5d0928c9946" title="Capacity reserved for future nodes, always &gt;= num_nodes_.">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::node_capacity</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000578 (user): Is it needed? remove completely? return the real capacities
at the cost of having a different implementation for each graphs? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a628255019800e5a053d08b1f0c5a05f2 "<a class="el" href="namespaceutil.html#a628255019800e5a053d08b1f0c5a05f2">util::EqualRange</a>" (MultiMap &amp;multi_map, const typename MultiMap::key_type &amp;key)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000601 (user): go further and expose only the values, not the pairs (key,
values) since the caller already knows the key. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::graph Member \_internalref namespaceutil_1_1graph#a440afdf238e5a752bbe4e1bcc8878fe7 "<a class="el" href="namespaceutil_1_1graph.html#a440afdf238e5a752bbe4e1bcc8878fe7">util::graph::FindCycleInGraph</a>" (const AdjacencyLists &amp;adj)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000659 (user): Caching adj[cur_state-&gt;node] in a local stack to improve
locality and so that the [] operator is called exactly once per node. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a9470623ca7db3c4a62ce3b326c6b07d8 "<a class="el" href="namespaceutil.html#a9470623ca7db3c4a62ce3b326c6b07d8">util::PermuteWithExplicitElementType</a>" (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000577 (user): consider slower but more memory efficient implementations that
follow the cycles of the permutation and use a bitmap to indicate what has
been permuted or to mark the beginning of each cycle. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a06fa201576c927d92657e090fa86bfdb "<a class="el" href="namespaceutil.html#a06fa201576c927d92657e090fa86bfdb">util::RemoveCyclesFromPath</a>" (const Graph &amp;graph, std::vector&lt; int &gt; *arc_path)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000660 (user): In some cases, there is more than one possible solution. We could
take some arc costs and return the cheapest path instead. Or return the
shortest path in term of number of arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcMixedGraph Member \_internalref classutil_1_1ReverseArcMixedGraph#a5ebe11f2abcd78ad1f5606e27d1688bb "<a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a5ebe11f2abcd78ad1f5606e27d1688bb">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>" (ArcIndexType arc) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000584 (user): support Head() and Tail() before Build(), like StaticGraph&lt;&gt;.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcMixedGraph::OutgoingArcIterator Member \_internalref classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator#ac265893b8e1a6db1380522442bf66c84 "<a class="el" href="classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator.html#ac265893b8e1a6db1380522442bf66c84">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>" (OutgoingArcIterator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000588 (user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this
iterator rather than a simple IntegerRange on the arc indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph Member \_internalref classutil_1_1ReverseArcStaticGraph#a590ee70b96ce87433ba89b067495aa5f "<a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a485803d141f9c80beaaae7094548d672">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Build</a>" (std::vector&lt; ArcIndexType &gt; *permutation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000581 (user): the 0 is wasted here, but minor optimisation.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph Member \_internalref classutil_1_1ReverseArcStaticGraph#a72e8ed03fe3f8ff27d156622a86900aa "<a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a72e8ed03fe3f8ff27d156622a86900aa">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>" (ArcIndexType arc) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000583 (user): support Head() and Tail() before Build(), like StaticGraph&lt;&gt;.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph::OutgoingArcIterator Member \_internalref classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator#a4f7501971b3fcc6ab34772a93c449ac6 "<a class="el" href="classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator.html#a4f7501971b3fcc6ab34772a93c449ac6">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>" (OutgoingArcIterator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000587 (user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this
iterator rather than a simple IntegerRange on the arc indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::SVector Member \_internalref classutil_1_1SVector#a287f9791ba2e68e137d53fc038bbe432 "<a class="el" href="classutil_1_1SVector.html#a287f9791ba2e68e137d53fc038bbe432">util::SVector&lt; T &gt;::reserve</a>" (int n)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000585 (user): in C++17 we could use std::uninitialized_move instead
of this loop. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref parser_8tab_8cc#ad3cdc959806aba1ada0fd7e5d4184f88 "yyparse" (<a class="el" href="structoperations__research_1_1fz_1_1ParserContext.html" title="This is the context used during parsing.">operations_research::fz::ParserContext</a> *context, <a class="el" href="classoperations__research_1_1fz_1_1Model.html">operations_research::fz::Model</a> *model, bool *ok, void *scanner) <a class="anchor" id="_todo000372"></a>(user): CHECK all values within domain. </p>
<p class="interdd"><a class="anchor" id="_todo000371"></a>(user): CHECK all values within domain. </p>
<p class="interdd"><a class="anchor" id="_todo000370"></a>(user): Check that the assignment is included in the domain. </p>
<p class="enddd"><a class="anchor" id="_todo000373"></a>(user): check that all assignments are included in the domain. </p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
