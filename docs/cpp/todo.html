<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.10</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('todo.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Todo List</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="lp__solver_8cc.html#aa3003ab2d06a8ff3b490c100232fc05c">ABSL_FLAG</a>  (bool, lp_dump_to_proto_file, false, "Tells whether do dump the problem to a protobuf file.")</dt>
<dd><a class="anchor" id="_todo000432"></a>(user): abstract this in some way to the port directory.  </dd>
<dt>Member <a class="el" href="min__cost__flow_8cc.html#ab29882272822b270edac48bc8b0ab14e">ABSL_FLAG</a>  (int64_t, min_cost_flow_alpha, 5, "Divide factor for epsilon at each refine step.")</dt>
<dd><a class="anchor" id="_todo000671"></a>(user): Remove these flags and expose the parameters in the API. New clients, please do not use these flags!  </dd>
<dt>Member <a class="el" href="solve__flow__model_8cc.html#a9ff01420564e565fbaef07a88a7e3d26">ABSL_FLAG</a>  (std::string, input, "", "Input file of the problem.")</dt>
<dd><a class="anchor" id="_todo000714"></a>(user): move this DIMACS parser to its own class, like the ones in routing/. This change would improve searchability of the parser.  </dd>
<dt>Member <a class="el" href="cp__model__search_8cc.html#a5254d8329101ce8f7213c759d6ad56b4">ABSL_FLAG</a>  (bool, cp_model_use_max_hs, false, "Use max_hs in search portfolio.")</dt>
<dd><a class="anchor" id="_todo001409"></a>(user): remove this when the code is stable and does not use SCIP anymore.  </dd>
<dt>Member <a class="el" href="max__hs_8cc.html#a1bcd4379e7db62efdf5ffc541a76255f">ABSL_FLAG</a>  (int, max_hs_strategy, 0, "MaxHsStrategy: 0 extract only objective variable, 1 extract all variables " "colocated with objective variables, 2 extract all variables in the " "linearization")</dt>
<dd><a class="anchor" id="_todo001971"></a>(user): Remove this flag when experiments are stable.  </dd>
<dt>Class <a class="el" href="classCycleTimer.html">CycleTimer</a>  </dt>
<dd><a class="anchor" id="_todo000063"></a>(user): implement it.  </dd>
<dt>Member <a class="el" href="revised__simplex_8cc.html#a8806083a7bf6a4ee4a4976c226b93788">DCHECK_ROW_BOUNDS</a>  (row)</dt>
<dd><a class="anchor" id="_todo000532"></a>(user): Remove this function.  </dd>
<dt>Namespace <a class="el" href="namespacegtl.html">gtl</a>  </dt>
<dd><a class="anchor" id="_todo000061"></a>(user): Broaden the scope and rename to "stream_util.h" </dd>
<dt>Member <a class="el" href="solve__flow__model_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>  (int argc, char **argv)</dt>
<dd><a class="anchor" id="_todo000715"></a>(user): improve code to convert many files.  </dd>
<dt>Class <a class="el" href="classMPSReaderTemplate.html">MPSReaderTemplate&lt; DataWrapper &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000856"></a>(b/284163180): The current behavior is that in free format header lines do not start with white space, and data lines must start with at least one white space.</p>
<p class="enddd"><a class="anchor" id="_todo000857"></a>(b/284163180): Fix handling of sections and data in <code>free_form</code>. / Returns true if the line defines a new section. bool IsNewSection() const { return line_[0] != '\0' &amp;&amp; line_[0] != ' '; } </p>
</dd>
<dt>Member <a class="el" href="classMPSReaderTemplate.html#a41dca56e2f203706f6b8eaeb13cadfea">MPSReaderTemplate&lt; DataWrapper &gt;::MPSReaderTemplate</a>  ()</dt>
<dd><a class="anchor" id="_todo000862"></a>(user): Support 'SI' (semi integer).  </dd>
<dt>Namespace <a class="el" href="namespaceoperations__research.html">operations_research</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000006"></a>(user): refine this toplevel comment when this file settles.</p>
<p class="interdd"><a class="anchor" id="_todo000028"></a>(user): base this code on <a class="el" href="classoperations__research_1_1LinearSumAssignment.html" title="This class does not take ownership of its underlying graph.">LinearSumAssignment</a>.</p>
<p class="interdd"><a class="anchor" id="_todo000033"></a>: it could be even faster than that when the values are in [0..N) for a known value N that's significantly lower than the max integer value. </p>
<p class="interdd"><a class="anchor" id="_todo000347"></a>(user): Move all existing routing search code here. </p>
<p class="interdd"><a class="anchor" id="_todo000362"></a>(user): Clean up to match other first solution strategies. </p>
<p class="interdd"><a class="anchor" id="_todo000375"></a>(user) : treat optional intervals </p>
<p class="interdd"></p>
<p class="interdd">(user) : Call <a class="el" href="classoperations__research_1_1DecisionVisitor.html">DecisionVisitor</a> and pass name of variable </p>
<p class="interdd"><a class="anchor" id="_todo000464"></a>(user): Determine whether any of these would bring any benefit:</p><ul>
<li>S.C. Eisenstat and J.W.H. Liu, "The theory of elimination trees for
  sparse unsymmetric matrices," SIAM J. Matrix Anal. Appl., 26:686-705, January 2005</li>
<li>S.C. Eisenstat and J.W.H. Liu. "Algorithmic aspects of elimination trees
  for sparse unsymmetric matrices," SIAM J. Matrix Anal. Appl., 29:1363-1381, January 2008.</li>
<li><a href="http://perso.ens-lyon.fr/~bucar/papers/kauc.pdf">http://perso.ens-lyon.fr/~bucar/papers/kauc.pdf</a> </li>
</ul>
<p class="interdd"><a class="anchor" id="_todo000617"></a>(user) although it is already possible, using the GroupForwardArcsByFunctor method, to group all the outgoing (resp. incoming) arcs of a node, the iterator logic could still be improved to allow traversing the outgoing (resp. incoming) arcs in O(out_degree(node)) (resp. O(in_degree(node))) instead of O(degree(node)).</p><ul>
<li></li>
</ul>
<p class="interdd"></p>
<p class="interdd">(user) it is possible to implement arc deletion and garbage collection in an efficient (relatively) manner. For the time being we haven't seen an application for this.</p>
<p class="interdd"><a class="anchor" id="_todo000633"></a>(user): implement pruning procedures on top of the Held-Karp algorithm.</p>
<p class="interdd"><a class="anchor" id="_todo000646"></a>(user): implement Lawler's modification: <a href="https://pubsonline.informs.org/doi/abs/10.1287/mnsc.18.7.401">https://pubsonline.informs.org/doi/abs/10.1287/mnsc.18.7.401</a></p>
<p class="interdd"><a class="anchor" id="_todo000663"></a>(user): implement the above active node choice rule.</p>
<p class="enddd"><a class="anchor" id="_todo000664"></a>(user): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow
Problem.” In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008.
http://www.springerlink.com/index/5535k2j1mt646338.pdf&lt;p&gt; \anchor _todo000679 (user): See whether the following can bring any improvements on real-life
problems.
R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost flows by double scaling," Mathematical Programming, (1992) 53:243-266.
http://www.springerlink.com/index/gu7404218u6kt166.pdf&lt;p&gt; \anchor _todo000702 (user): This is a work in progress. The algo is not fully implemented
yet. The initial version is closer to Blossom IV since we update the dual
values for all trees at once with the same delta. 
 &lt;p&gt; \anchor _todo000729 (user): either implement with SCIP constraint handlers or use a solver
independent implementation. 
 &lt;p&gt; \anchor _todo000763 (user): handle timeouts, compute row and column statuses. 
 &lt;p&gt; \anchor _todo000769 (user): post c++ 14, instead use
  std::pair&lt;MPSolver::OptimizationProblemType, const absl::string_view&gt;
once pair gets a constexpr constructor. 
 &lt;p&gt; \anchor _todo000902 (b/180617976): change this behavior.&lt;p&gt; \anchor _todo000928 (b/180024054): add tests for:
 * threads
 * heuristics
 * scaling
 * lp_algorithm, differentiate between primal and dual simplex. E.g. find a
   problem with LP relaxation that is both infeasible and dual infeasible,
   disable presolve, and solve. When using primal simplex, we should get
   termination reason kInfeasible, but dual simplex should give
   kInfeasibleOrUnbounded.
 *  &lt;p&gt; &lt;p&gt;(b/272268188): test the interaction between cutoff and primal + dual
   infeasibility.
 &lt;p&gt; \anchor _todo000933 (b/180024054): the following parameters are not tested:
 * time_limit
 * threads
 * scaling&lt;p&gt; \anchor _todo000937 (user): These tests are incomplete in a few ways; see mip_tests.cc
 &lt;p&gt; &lt;p&gt;(user): Expand tests so they check primal, dual and/or primal-dual
infeasible cases as appropriate. 
 &lt;p&gt; \anchor _todo002228 (user): for now it is mainly presolve, but the idea is to call these
function during the search so they should be as incremental as possible. That
is avoid doing work that is not useful because nothing changed or exploring
parts that were not done during the last round. 
 &lt;p&gt; \anchor _todo002271 (user): Expand. 
 &lt;p&gt; \anchor _todo002423 (user): make this implementation the default everywhere.
 &lt;p&gt; &lt;p&gt;(user): investigate the code generated by MSVC. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::@139 Namespace \_internalref namespaceoperations__research_1_1_0d139 "<a class="el" href="namespaceoperations__research.html" title="In SWIG mode, we don&#39;t want anything besides these top-level includes.">operations_research</a>::@139" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000197 (user): improve code when assume_paths is false (currently does an
expensive n^2 loop). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AdaptiveParameterValue Class \_internalref classoperations__research_1_1AdaptiveParameterValue "<a class="el" href="classoperations__research_1_1AdaptiveParameterValue.html">operations_research::AdaptiveParameterValue</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002402 (user): The current logic work well in practice, but has no strong
theoretical foundation. We should be able to come up with a better understood
formula that converge way faster. It will also be nice to generalize the 0.5
above to a target probability p. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a93bd93f028c18a4b55b30056ef60df44 "<a class="el" href="namespaceoperations__research.html#a93bd93f028c18a4b55b30056ef60df44">operations_research::AddOverflows</a>" (int64_t x, int64_t y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002424 (user): consider making some operations overflow-sticky, some others
not, but make an explicit choice throughout. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AffineRelation Class \_internalref classoperations__research_1_1AffineRelation "<a class="el" href="classoperations__research_1_1AffineRelation.html">operations_research::AffineRelation</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002403 (user): it might be possible to do something fancier and drop less
relations if all the affine relations are given before hand. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AffineRelation Member \_internalref classoperations__research_1_1AffineRelation#a42c79bfbcf36db0e14d942a6079a8564 "<a class="el" href="classoperations__research_1_1AffineRelation.html#a5c2556af84128ec02d7f72be8c51a43d">operations_research::AffineRelation::TryAdd</a>" (int x, int y, int64_t coeff, int64_t offset, bool allow_rep_x, bool allow_rep_y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002404 (user): It should be possible to optimize this code block a bit, for
instance depending on the magnitude of new_coeff vs coeff_x, we may already
know that one of the two merge is not possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a38cd9519fdea9ef6c87480955852a8c7 "<a class="el" href="namespaceoperations__research.html#a38cd9519fdea9ef6c87480955852a8c7">operations_research::ApplyMipPresolveSteps</a>" (const glop::GlopParameters &amp;glop_params, MPModelProto *model, std::vector&lt; std::unique_ptr&lt; glop::Preprocessor &gt; &gt; *for_postsolve, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000801 (user): General constraints are currently not supported.
 &lt;p&gt; \anchor _todo000802 (user): Remove this back and forth conversion. We could convert
the LinearProgram directly to a CpModelProto, or we could have a custom
implementation of these presolve steps. 
 &lt;p&gt; \anchor _todo000803 (user): transform the hint instead of disabling presolve. 
 &lt;p&gt; \anchor _todo000804 (user): Usually it is good to run the ImpliedFreePreprocessor before
this one. However this seems to cause problem on atm20-100.mps. Moreover,
for the conversion, it is better to have tight bounds even if the bound
propagator is supposed to undo what this presolve would have done. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ArcWithLength Struct \_internalref structoperations__research_1_1ArcWithLength "<a class="el" href="structoperations__research_1_1ArcWithLength.html">operations_research::ArcWithLength</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000614 (b/332475231): extend to non-floating lengths.
 &lt;p&gt; &lt;p&gt;(b/332476147): extend to allow for length functor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Assignment Member \_internalref classoperations__research_1_1Assignment#ad6ab5aff03cb66b05fcbdff43dde169a "<a class="el" href="classoperations__research_1_1Assignment.html#ad6ab5aff03cb66b05fcbdff43dde169a">operations_research::Assignment::CopyIntersection</a>" (const Assignment *assignment)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000118 (user): The current behavior is to copy the objective "prefix"
which fits the notion of lexicographic objectives well. Reconsider if
multiple objectives are used in another context. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Assignment Member \_internalref classoperations__research_1_1Assignment#aa4afa275944d2cc69a7a252bafc1e311 "<a class="el" href="classoperations__research_1_1Assignment.html#aa4afa275944d2cc69a7a252bafc1e311">operations_research::Assignment::IntVarContainer</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000147 (user): Add element iterators to avoid exposing container class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a270548116df8ad74e03d376c40025566 "<a class="el" href="namespaceoperations__research.html#a270548116df8ad74e03d376c40025566">operations_research::AutomaticFirstSolutionStrategy</a>" (bool has_pickup_deliveries, bool has_node_precedences, bool has_single_vehicle_node)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000348 (user): Make this smarter. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BaseInactiveNodeToPathOperator Member \_internalref classoperations__research_1_1BaseInactiveNodeToPathOperator#a609668ce9159e0233d2ea4a6c97f9569 "<a class="el" href="classoperations__research_1_1BaseInactiveNodeToPathOperator.html#a609668ce9159e0233d2ea4a6c97f9569">operations_research::BaseInactiveNodeToPathOperator::BaseInactiveNodeToPathOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;secondary_vars, int number_of_base_nodes, std::function&lt; int(int64_t)&gt; start_empty_path_class, std::function&lt; const std::vector&lt; int &gt; &amp;(int, int)&gt; get_neighbors=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000232 (user): Activate skipping optimal paths.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BinCapacities Member \_internalref classoperations__research_1_1BinCapacities#ad0a24566a2366a002297ce9fa809fb4b "<a class="el" href="classoperations__research_1_1BinCapacities.html#ad0a24566a2366a002297ce9fa809fb4b">operations_research::BinCapacities::CheckAdditionsFeasibility</a>" (const std::vector&lt; int &gt; &amp;items, int bin) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000371 (user): try to reorder on failure, so that tight dimensions are
checked first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Bitmap Member \_internalref classoperations__research_1_1Bitmap#a10079c77d15fd313c09b89b46756d4e3 "<a class="el" href="classoperations__research_1_1Bitmap.html#a10079c77d15fd313c09b89b46756d4e3">operations_research::Bitmap::Resize</a>" (uint32_t size, bool fill=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000060 (user) : optimize next loop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab7253ffd8b7aba4b7cb5f981c7627526 "<a class="el" href="namespaceoperations__research.html#ab7253ffd8b7aba4b7cb5f981c7627526" title="Bit operators used to manipulates bitsets.">operations_research::BitPos64</a>" (uint64_t pos)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002406 (user): rename BitPos and BitOffset to something more understandable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Bitset64 Member \_internalref classoperations__research_1_1Bitset64#adde7d1500621913ae1f3e71cda4fb502 "<a class="el" href="classoperations__research_1_1Bitset64.html#adde7d1500621913ae1f3e71cda4fb502" title="Changes the number of bits the Bitset64 can hold and set all of them to 0.">operations_research::Bitset64&lt; IndexType &gt;::ClearAndResize</a>" (IndexType size)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002407 (user): Ideally if a realloc happens, we don't need to copy the old
data... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Class \_internalref classoperations__research_1_1BlossomGraph "<a class="el" href="classoperations__research_1_1BlossomGraph.html">operations_research::BlossomGraph</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000703 (user): For now this class does not maintain a second graph of edges
between the trees nor does it maintains priority queue of edges.&lt;p&gt; \anchor _todo000704 (user): For now we use CHECKs in many places to facilitate development.
Switch them to DCHECKs for speed once the code is more stable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a1cc997de6330ea47db84ebfbc97c3855 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a1cc997de6330ea47db84ebfbc97c3855">operations_research::BlossomGraph::Augment</a>" (EdgeIndex e)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000696 (user): Check all dual/slack same after primal op?
 &lt;p&gt; \anchor _todo000697 (user): It seems that we may waste some computation since the part of
the tree not in the path between roots can lead to the same Grow()
operations later when one of its node is ratched to a new root.&lt;p&gt; \anchor _todo000698 (user): Reduce this O(num_nodes) complexity. We might be able to
even do O(num_node_in_path) with lazy updates. Note that this operation
will only be performed at most num_initial_unmatched_nodes / 2 times
though. 
 &lt;p&gt; \anchor _todo000699 (user): This could probably be optimized if needed. But we do usually
iterate a lot more over it than we update it. Note that as long as we use
the same delta for all trees, this is not even needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a2efd43d890e6d53cbab9f160b5ecd745 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a2efd43d890e6d53cbab9f160b5ecd745">operations_research::BlossomGraph::ComputeMaxCommonTreeDualDeltaAndResetPrimalEdgeQueue</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000693 (user): Avoid this linear loop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph::Edge Member \_internalref structoperations__research_1_1BlossomGraph_1_1Edge#a152f6be1dfb3d3057d875f9371da5a29 "<a class="el" href="structoperations__research_1_1BlossomGraph_1_1Edge.html#a152f6be1dfb3d3057d875f9371da5a29">operations_research::BlossomGraph::Edge::tail</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000710 (user): Consider using node_a/node_b instead to remove the "directed"
meaning. I do need to think a bit more about it though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a23c2ea31a1b81f23e929abdc839f9153 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a23c2ea31a1b81f23e929abdc839f9153" title="This must be called at the end of the algorithm to recover the matching.">operations_research::BlossomGraph::ExpandAllBlossoms</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000701 (user): remove duplication with expand?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#aea1e702f3161c4bd45d69ac7ef50d562 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#aea1e702f3161c4bd45d69ac7ef50d562">operations_research::BlossomGraph::Initialize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000688 (user): Code the more advanced "Fractional matching initialization"
heuristic.&lt;p&gt; \anchor _todo000689 (user): Add a preprocessing step that performs the 'forced' matches? 
 &lt;p&gt; \anchor _todo000690 (user): We might be able to do better for odd min_cost, but then
we might need to scale by 4? think about it. 
 &lt;p&gt; \anchor _todo000691 (user): Optimize by merging this loop with the one above? 
 &lt;p&gt; \anchor _todo000692 (user): Reduce the number of loops we do in the initialization. We
could likely just scale the edge cost as we fill them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a4e57765af9aa45f409d540937922cb15 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a4e57765af9aa45f409d540937922cb15">operations_research::BlossomGraph::PrimalUpdates</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000694 (user): avoid adding duplicates? 
 &lt;p&gt; \anchor _todo000695 (user): Avoid doing a O(num_nodes). Also expand all blossom
recursively? I am not sure it is a good heuristic to expand all possible
blossom before trying the other operations though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#af8800c5729866189248b48ea006f2787 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#af8800c5729866189248b48ea006f2787">operations_research::BlossomGraph::Shrink</a>" (EdgeIndex e)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000700 (user): It would be nicer to not to have to read the memory of
the other node at all. It might be possible once we store the
parent edge instead of the parent node since then we will only need
to know if this edges point to a new-internal node or not. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer Member \_internalref classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer#a74b09c69f37b7aee6c511622f13ff935 "<a class="el" href="classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer.html#a74b09c69f37b7aee6c511622f13ff935">operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer::DebugString</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000088 (user): show the backtrack levels.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer Member \_internalref classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer#ab9b52ed71802a8f4ae56d61b3e6f42ea "<a class="el" href="classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer.html#ab9b52ed71802a8f4ae56d61b3e6f42ea">operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer::PotentialOneFlipRepairs</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000087 (user): If this starts to show-up in a performance profile, we can
easily maintain this hash incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopOptimizerBase Member \_internalref classoperations__research_1_1bop_1_1BopOptimizerBase#a881ed93d8f98879bbbfddf21807fff63ab5cd6094ad1ef99cfb1c8e77da1f59b1 "<a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html#a881ed93d8f98879bbbfddf21807fff63ab5cd6094ad1ef99cfb1c8e77da1f59b1">operations_research::bop::BopOptimizerBase::INFORMATION_FOUND</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000067 (user): replace by learned_info-&gt;IsEmpty()? but we will need to clear
the BopSolution there first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopOptimizerBase Member \_internalref classoperations__research_1_1bop_1_1BopOptimizerBase#a881ed93d8f98879bbbfddf21807fff63 "<a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html#a881ed93d8f98879bbbfddf21807fff63">operations_research::bop::BopOptimizerBase::Status</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000066 (user): To redesign, some are not needed anymore thanks to the
             problem state, e.g. IsOptimal(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopRandomFirstSolutionGenerator Class \_internalref classoperations__research_1_1bop_1_1BopRandomFirstSolutionGenerator "<a class="el" href="classoperations__research_1_1bop_1_1BopRandomFirstSolutionGenerator.html">operations_research::bop::BopRandomFirstSolutionGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000074 (user): Coupled with some Local Search it might be used to diversify
             the solutions. To try. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop Member \_internalref namespaceoperations__research_1_1bop#aa5e7fc23cf65709ac2894d88db807c57 "<a class="el" href="namespaceoperations__research_1_1bop.html#ac596370dab965471b2aaf0acf94c3940">operations_research::bop::DEFINE_STRONG_INDEX_TYPE</a>" (SparseIndex)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000103 (user): Remove.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::IntegralSolver Member \_internalref classoperations__research_1_1bop_1_1IntegralSolver#ade95d98b233882c2b9004ec144ded32e "<a class="el" href="classoperations__research_1_1bop_1_1IntegralSolver.html#adb59bf670fd51c4fd701f34200bb371b" title="Solves the given linear program and returns the solve status.">operations_research::bop::IntegralSolver::Solve</a>" (const glop::LinearProgram &amp;linear_problem, const glop::DenseRow &amp;user_provided_initial_solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000115 (user): Change the API to accept a partial solution instead since the
underlying solver supports it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LinearRelaxation Member \_internalref classoperations__research_1_1bop_1_1LinearRelaxation#ae7b5dc2f2554218d68e6013b9a3c10d8 "<a class="el" href="classoperations__research_1_1bop_1_1LinearRelaxation.html#ae7b5dc2f2554218d68e6013b9a3c10d8">operations_research::bop::LinearRelaxation::ShouldBeRun</a>" (const ProblemState &amp;problem_state) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000070 (user): also deal with problem_already_solved_ 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LocalSearchAssignmentIterator Member \_internalref classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator#a8b33fbbde1b28b4f19eac558f3bcc968 "<a class="el" href="classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator.html#a8b33fbbde1b28b4f19eac558f3bcc968">operations_research::bop::LocalSearchAssignmentIterator::deterministic_time</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000090 (user): The 1.2 multiplier is an approximation only based on the time
             spent in the SAT wrapper. So far experiments show a good
             correlation with real time, but we might want to be more
             accurate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LocalSearchAssignmentIterator Member \_internalref classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator#abba388e3e639729c28998d52ecea6a19 "<a class="el" href="classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator.html#abba388e3e639729c28998d52ecea6a19" title="Move to the next assignment. Returns false when the search is finished.">operations_research::bop::LocalSearchAssignmentIterator::NextAssignment</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000089 (user): Perform more experiments with this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OneFlipConstraintRepairer Member \_internalref classoperations__research_1_1bop_1_1OneFlipConstraintRepairer#a07e60997ff23293fa7f3b9d21765fb32 "<a class="el" href="classoperations__research_1_1bop_1_1OneFlipConstraintRepairer.html#a07e60997ff23293fa7f3b9d21765fb32">operations_research::bop::OneFlipConstraintRepairer::OneFlipConstraintRepairer</a>" (const sat::LinearBooleanProblem &amp;problem, const AssignmentAndConstraintFeasibilityMaintainer &amp;maintainer, const sat::VariablesAssignment &amp;sat_assignment)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000094 (user): maybe merge the two classes? maintaining this implicit indices
convention between the two classes sounds like a bad idea. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OptimizerSelector Member \_internalref classoperations__research_1_1bop_1_1OptimizerSelector#a39afee83d9f173f951fd8bef5668d1cc "<a class="el" href="classoperations__research_1_1bop_1_1OptimizerSelector.html#a39afee83d9f173f951fd8bef5668d1cc">operations_research::bop::OptimizerSelector::SelectOptimizer</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000101 (user): Remove this recursive call, even if in practice it's
    safe because the max depth is the number of optimizers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OptimizerSelector Member \_internalref classoperations__research_1_1bop_1_1OptimizerSelector#a90899a835ba61dd5404514594bac26d1 "<a class="el" href="classoperations__research_1_1bop_1_1OptimizerSelector.html#a90899a835ba61dd5404514594bac26d1">operations_research::bop::OptimizerSelector::SetOptimizerRunnability</a>" (OptimizerIndex optimizer_index, bool runnable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000102 (user): Maybe we should simply have the notion of selectability here
and let the client handle the logic to decide what optimizer are selectable
or not. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::PortfolioOptimizer Member \_internalref classoperations__research_1_1bop_1_1PortfolioOptimizer#a80a6069365c385e427e6e5a1c08d1757 "<a class="el" href="classoperations__research_1_1bop_1_1PortfolioOptimizer.html#a80a6069365c385e427e6e5a1c08d1757">operations_research::bop::PortfolioOptimizer::Optimize</a>" (const BopParameters &amp;parameters, const ProblemState &amp;problem_state, LearnedInfo *learned_info, TimeLimit *time_limit) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000097 (user): Is 1 the right value? It might be better to use a percentage
             of the gap, or use the same gain as for the second solution. 
 &lt;p&gt; \anchor _todo000098 (user): don't penalize the SatCoreBasedOptimizer or the
LinearRelaxation when they improve the lower bound.
&lt;p&gt; \anchor _todo000099 &lt;p&gt; \anchor _todo000100 (user): Do we want to re-order the optimizers in the selector when
             the status is BopOptimizerBase::INFORMATION_FOUND? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::ProblemState Member \_internalref classoperations__research_1_1bop_1_1ProblemState#a559199c417440cd27d38fc73ce4eb3f0 "<a class="el" href="classoperations__research_1_1bop_1_1ProblemState.html#a559199c417440cd27d38fc73ce4eb3f0">operations_research::bop::ProblemState::GetLearnedInfo</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000068 (user): In the current implementation the learned information only
             contains binary clauses added since the last call to
             SynchronizationDone().
             Add an iterator on the sat::BinaryClauseManager. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::ProblemState Member \_internalref classoperations__research_1_1bop_1_1ProblemState#a66e1a0e14cfd6b3310237e4243df1295 "<a class="el" href="classoperations__research_1_1bop_1_1ProblemState.html#a66e1a0e14cfd6b3310237e4243df1295">operations_research::bop::ProblemState::MergeLearnedInfo</a>" (const LearnedInfo &amp;learned_info, BopOptimizerBase::Status optimization_status)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000065 (user): refactor this to not rely on the optimization status.
All the information can be encoded in the learned_info bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::RelationGraphBasedNeighborhood Member \_internalref classoperations__research_1_1bop_1_1RelationGraphBasedNeighborhood#a325429e8a64a26196122aa1b0e430cdb "<a class="el" href="classoperations__research_1_1bop_1_1RelationGraphBasedNeighborhood.html#a325429e8a64a26196122aa1b0e430cdb">operations_research::bop::RelationGraphBasedNeighborhood::RelationGraphBasedNeighborhood</a>" (const sat::LinearBooleanProblem &amp;problem, absl::BitGenRef random)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000079 (user): Factor this out with the similar factor in
ConstraintBasedNeighborhood? also maybe a better approach is to order the
constraint, and stop the neighborhood extension without considering all of
them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatCoreBasedOptimizer Class \_internalref classoperations__research_1_1bop_1_1SatCoreBasedOptimizer "<a class="el" href="classoperations__research_1_1bop_1_1SatCoreBasedOptimizer.html">operations_research::bop::SatCoreBasedOptimizer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000105 (user): Merge this with the code in sat/optimization.cc
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatCoreBasedOptimizer Member \_internalref classoperations__research_1_1bop_1_1SatCoreBasedOptimizer#aa4bc0effba94384800ed5500479d4e6a "<a class="el" href="classoperations__research_1_1bop_1_1SatCoreBasedOptimizer.html#aa4bc0effba94384800ed5500479d4e6a">operations_research::bop::SatCoreBasedOptimizer::Optimize</a>" (const BopParameters &amp;parameters, const ProblemState &amp;problem_state, LearnedInfo *learned_info, TimeLimit *time_limit) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000104 (user): Check that this cannot fail because of the conflict limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatWrapper Class \_internalref classoperations__research_1_1bop_1_1SatWrapper "<a class="el" href="classoperations__research_1_1bop_1_1SatWrapper.html">operations_research::bop::SatWrapper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000093 (user): remove? the meat of the logic is used in just one place, so I am
not sure having this extra layer improve the readability. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#ada6578145939501210ef6b92ca38158d "<a class="el" href="classoperations__research_1_1BopInterface.html#ada6578145939501210ef6b92ca38158d">operations_research::BopInterface::ExtractNewConstraints</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000735 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a7aaa64ff52a59fb3e02dde9e52897ace "<a class="el" href="classoperations__research_1_1BopInterface.html#a7aaa64ff52a59fb3e02dde9e52897ace">operations_research::BopInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000734 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a9bd4d93025988cd4a244584d930b8ff8 "<a class="el" href="classoperations__research_1_1BopInterface.html#a9bd4d93025988cd4a244584d930b8ff8">operations_research::BopInterface::ExtractObjective</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000736 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#ac52f933217a15933ccc9d816712e85f7 "<a class="el" href="classoperations__research_1_1BopInterface.html#ac52f933217a15933ccc9d816712e85f7">operations_research::BopInterface::SetPresolveMode</a>" (int value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000737 (user): add this to BopParameters.
 &lt;p&gt; \anchor _todo000738 (user): add this to BopParameters.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#afd586dcfbf76c853a9331113cea5ad2f "<a class="el" href="classoperations__research_1_1BopInterface.html#afd586dcfbf76c853a9331113cea5ad2f" title="--— Solve --—">operations_research::BopInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000731 (user): Implement the column status.
 &lt;p&gt; \anchor _todo000732 (user): Implement the row status.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a8055a5ae37344bb12601db78c75336ca "<a class="el" href="classoperations__research_1_1BopInterface.html#a8055a5ae37344bb12601db78c75336ca" title="Returns a string describing the underlying solver and its version.">operations_research::BopInterface::SolverVersion</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000733 (user): Decide how to version bop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aacf1f78a82fb54975d703e8f079cafa2 "<a class="el" href="namespaceoperations__research.html#aacf1f78a82fb54975d703e8f079cafa2">operations_research::BuildKruskalMinimumSpanningTreeFromSortedArcs</a>" (const Graph &amp;graph, absl::Span&lt; const typename Graph::ArcIndex &gt; sorted_arcs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000683 (user): Add a global Minimum Spanning Tree API automatically switching
between Prim and Kruskal depending on problem size. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#adfcad7c607afe2de123ac91fcd2b87c0 "<a class="el" href="namespaceoperations__research.html#adfcad7c607afe2de123ac91fcd2b87c0">operations_research::CapProdGeneric</a>" (int64_t x, int64_t y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002425 (user): avoid this by writing function Log2(a) with Log2(0) == -1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#af820a38fd9b79c6bccdf806ff44df433 "<a class="el" href="classoperations__research_1_1CBCInterface.html#af820a38fd9b79c6bccdf806ff44df433">operations_research::CBCInterface::ExtractModel</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000740 (user): separate the solve from the model extraction.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#abe31f5b2faa04f2e7d0a82b2f7c56eba "<a class="el" href="classoperations__research_1_1CBCInterface.html#abe31f5b2faa04f2e7d0a82b2f7c56eba" title="Modifies integrality of an extracted variable.">operations_research::CBCInterface::SetVariableInteger</a>" (int var_index, bool integer) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000739 (user) : Check if this is actually a change.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#aff8df81038ade1c6d8ff118dbcf92ff2 "<a class="el" href="classoperations__research_1_1CBCInterface.html#aff8df81038ade1c6d8ff118dbcf92ff2">operations_research::CBCInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000741 (user): Maybe we should expose the CbcModel build from osi_
instead, but a new CbcModel is built every time Solve is called,
so it is not possible right now. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a6a5db12c8eb55529c5717db21d40f856 "<a class="el" href="namespaceoperations__research.html#a6a5db12c8eb55529c5717db21d40f856">operations_research::CeilRatio</a>" (int64_t value, int64_t positive_coeff)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002426 (user): Use MathUtil::CeilOfRatio / FloorOfRatio instead.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1CheapestInsertionFilteredHeuristic#aabcdb4b93d8aed00bc35f8f04a3c5f0a "<a class="el" href="classoperations__research_1_1CheapestInsertionFilteredHeuristic.html#aabcdb4b93d8aed00bc35f8f04a3c5f0a">operations_research::CheapestInsertionFilteredHeuristic::ComputeStartEndDistanceForVehicles</a>" (const std::vector&lt; int &gt; &amp;vehicles)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000350 (user): consider checking search limits.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1CheapestInsertionFilteredHeuristic#a1a109ae320b663d295dfdfc68f608810 "<a class="el" href="classoperations__research_1_1CheapestInsertionFilteredHeuristic.html#a1a109ae320b663d295dfdfc68f608810">operations_research::CheapestInsertionFilteredHeuristic::GetInsertionCostForNodeAtPosition</a>" (int64_t node_to_insert, int64_t insert_after, int64_t insert_before, int vehicle) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000367 (user): Replace 'insert_before' and 'insert_after' by 'predecessor'
and 'successor' in the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesFilteredHeuristic Member \_internalref classoperations__research_1_1ChristofidesFilteredHeuristic#a30f60a5304f5bd801ece16fb0868b0fb "<a class="el" href="classoperations__research_1_1ChristofidesFilteredHeuristic.html#a30f60a5304f5bd801ece16fb0868b0fb">operations_research::ChristofidesFilteredHeuristic::BuildSolutionInternal</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000358 (user): Support pickup &amp; delivery.
 &lt;p&gt; \anchor _todo000359 (user): Add robustness to fixed arcs by collapsing them into meta-
nodes. 
 &lt;p&gt; \anchor _todo000360 (user): Investigate if ChristofidesPathSolver should not
return a status to bail out fast in case of problem. 
 &lt;p&gt; \anchor _todo000361 (user): Investigate if sorting paths per cost improves solutions.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesPathSolver Member \_internalref classoperations__research_1_1ChristofidesPathSolver#a76c636e1d48da64087686dd06bc45519 "<a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a76c636e1d48da64087686dd06bc45519">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::SetMatchingAlgorithm</a>" (MatchingAlgorithm matching)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000612 (user): Change the default when minimum matching gets faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesPathSolver Member \_internalref classoperations__research_1_1ChristofidesPathSolver#a0fd40e5b4dd3c4d2eec044aafc9cdc7a "<a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a0fd40e5b4dd3c4d2eec044aafc9cdc7a">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000610 (user): Make this code available as an independent algorithm. 
 &lt;p&gt; \anchor _todo000611 (user): Cost caching was added and can gain up to 20% but
increases memory usage; see if we can avoid caching. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a784189c728d17f91325cd8dfd86f324e "<a class="el" href="namespaceoperations__research.html#a0e64fedd79537cb2057845d5bccd1363">operations_research::ClearMostCoveredElements</a>" (absl::Span&lt; const SubsetIndex &gt; focus, std::size_t num_subsets, SetCoverInvariant *inv)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000041 (user):find another algorithm if
necessary. 
 &lt;p&gt; \anchor _todo000042 (user): find another algorithm if necessary. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CLPInterface Member \_internalref classoperations__research_1_1CLPInterface#adbecc3c53101ed075d7078a7ea8f3e19 "<a class="el" href="classoperations__research_1_1CLPInterface.html#adbecc3c53101ed075d7078a7ea8f3e19" title="Define new variables and add them to existing constraints.">operations_research::CLPInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000743 (user): This could perhaps be made slightly faster by
iterating through old constraints, constructing by hand the
column-major representation of the addition to them and call
clp_-&gt;addColumns. But this is good enough for now.
Create new variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a53bf12f941f978cc1b1b985816c1fbdf "<a class="el" href="namespaceoperations__research.html#a53bf12f941f978cc1b1b985816c1fbdf">operations_research::ComputeMinimumWeightMatchingWithMIP</a>" (const GraphType &amp;graph, const WeightFunctionType &amp;weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000609 (user): Handle infeasible cases if this algorithm is used outside of
Christofides. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a25f46b686d6f253f53dc77ac9f52b4b6 "<a class="el" href="namespaceoperations__research.html#a25f46b686d6f253f53dc77ac9f52b4b6">operations_research::ConvertFlowModelToDimacs</a>" (const FlowModelProto &amp;flow_model, std::string *dimacs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000716 (user): This currently only works for min cost flow problem. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad3af7b57bcf2344c6378fbec1b59b96e "<a class="el" href="namespaceoperations__research.html#ad3af7b57bcf2344c6378fbec1b59b96e">operations_research::ConvertStatusOrMPSolutionResponse</a>" (bool log_error, absl::StatusOr&lt; MPSolutionResponse &gt; response)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000796 (user): All SolveWithProto() should just fill the appropriate response
instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#acb9df89a57d7e6c160136db67b224b88 "<a class="el" href="namespaceoperations__research.html#acb9df89a57d7e6c160136db67b224b88">operations_research::ConvexMinimum</a>" (absl::Span&lt; const Point &gt; sorted_points, std::function&lt; Value(Point)&gt; f)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000001 (user): Some relevant optimizations:
- Abort early if we know a lower bound on the min.
- Seed with a starting point if we know one.
- We technically do not need the points to be sorted and can use
  linear-time median computation to speed this up.&lt;p&gt; \anchor _todo000002 (user): replace std::function by absl::FunctionRef here and in
BinarySearch(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#a6dfd72260599acdb0d30d0eb612a9b2c "<a class="el" href="classoperations__research_1_1CplexInterface.html#a6dfd72260599acdb0d30d0eb612a9b2c" title="Extract all variables that have not yet been extracted.">operations_research::CplexInterface::ExtractNewVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000745 : Use a bitarray to flag the constraints that actually
intersect new variables? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#ade9838d567be0055711f0d0246878123 "<a class="el" href="classoperations__research_1_1CplexInterface.html#ade9838d567be0055711f0d0246878123" title="Sets the scaling mode.">operations_research::CplexInterface::SetScalingMode</a>" (int value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000746 : 0 is equilibrium scaling (the default), CPLEX also supports
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#a6f29640b71cf1b2be18d08c4888d654f "<a class="el" href="classoperations__research_1_1CplexInterface.html#a6f29640b71cf1b2be18d08c4888d654f" title="Modifies integrality of an extracted variable.">operations_research::CplexInterface::SetVariableInteger</a>" (int var_index, bool integer)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000744 : Should we check the current type and don't do anything
      in case the type does not change? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Cross Member \_internalref classoperations__research_1_1Cross#aebc322e8525f142b40271ce61f2db26f "<a class="el" href="classoperations__research_1_1Cross.html#aebc322e8525f142b40271ce61f2db26f">operations_research::Cross::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000213 (user): When neighbors are considered, explore if having two
versions of Cross makes sense, one exchanging path starts, the other
path ends. Rationale: neighborhoods might not be symmetric. In practice,
in particular when used through RoutingModel, neighborhoods are
actually symmetric. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CVRPToursParser Member \_internalref classoperations__research_1_1CVRPToursParser#aa36bf9878697f417c237563de888fe97 "<a class="el" href="classoperations__research_1_1CVRPToursParser.html#aa36bf9878697f417c237563de888fe97" title="Loads and parses a given tours file.">operations_research::CVRPToursParser::LoadFile</a>" (const std::string &amp;file_name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001047 (user): Return false when issues were encountered while parsing the
file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DemonProfiler Member \_internalref classoperations__research_1_1DemonProfiler#a7b7c6355eb1daf5a3db8f0d575947ed2 "<a class="el" href="classoperations__research_1_1DemonProfiler.html#a7b7c6355eb1daf5a3db8f0d575947ed2">operations_research::DemonProfiler::CurrentTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000160 (user): rename and return nanoseconds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionChecker Member \_internalref classoperations__research_1_1DimensionChecker#a0f3d75f9157801c9a32ab3e5d9bdc23e "<a class="el" href="classoperations__research_1_1DimensionChecker.html#a0f3d75f9157801c9a32ab3e5d9bdc23e">operations_research::DimensionChecker::DimensionChecker</a>" (const PathState *path_state, std::vector&lt; Interval &gt; path_capacity, std::vector&lt; int &gt; path_class, std::vector&lt; std::function&lt; Interval(int64_t, int64_t)&gt; &gt; demand_per_path_class, std::vector&lt; Interval &gt; node_capacity, int min_range_size_for_riq=kOptimalMinRangeSizeForRIQ)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000156 (user): the addition of kMinRangeSizeForRIQ slowed down Check().
See if using a template parameter makes it faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#a124f8416552eec51fea7c3f0f47d722b "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#a124f8416552eec51fea7c3f0f47d722b">operations_research::DimensionCumulOptimizerCore::Optimize</a>" (const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const std::vector&lt; RouteDimensionTravelInfo &gt; &amp;dimension_travel_info_per_route, RoutingLinearSolverWrapper *solver, std::vector&lt; int64_t &gt; *cumul_values, std::vector&lt; int64_t &gt; *break_values, std::vector&lt; std::vector&lt; int &gt; &gt; *resource_indices_per_group, int64_t *cost_without_transits, int64_t *transit_cost, bool clear_lp=true, bool optimize_resource_assignment=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000323 (user): In case the status is RELAXED_OPTIMAL_ONLY, check we can
safely avoid filling variable and cost values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#a5a239314a69e35f6411905cd4bebb6d8 "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#a5a239314a69e35f6411905cd4bebb6d8">operations_research::DimensionCumulOptimizerCore::OptimizeAndPack</a>" (const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const std::vector&lt; RouteDimensionTravelInfo &gt; &amp;dimension_travel_info_per_route, RoutingLinearSolverWrapper *solver, std::vector&lt; int64_t &gt; *cumul_values, std::vector&lt; int64_t &gt; *break_values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000324 (user): In case the status is RELAXED_OPTIMAL_ONLY, check we can
safely avoid filling variable values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad0b44ed99c3501d7a797dfa6ac52714f "<a class="el" href="namespaceoperations__research.html#af223cfc20a19613cbf63b9b9f08795cb">operations_research::DisplayPlan</a>" (const operations_research::RoutingIndexManager &amp;manager, const operations_research::RoutingModel &amp;routing, const operations_research::Assignment &amp;plan, bool use_same_vehicle_costs, int64_t max_nodes_per_group, int64_t same_vehicle_cost, const operations_research::RoutingDimension &amp;capacity_dimension, const operations_research::RoutingDimension &amp;time_dimension)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001042 (user): Move the display code to the routing library. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DistributionStat Member \_internalref classoperations__research_1_1DistributionStat#a68349bcba1db1a5a68ebd1d855bdd078 "<a class="el" href="classoperations__research_1_1DistributionStat.html#a68349bcba1db1a5a68ebd1d855bdd078">operations_research::DistributionStat::StdDeviation</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002436 (user): We could also use on top the Kahan summation algorithm to be
even more precise but a bit slower too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#a714a1473bb78dab3195bd5cd5e90af42 "<a class="el" href="classoperations__research_1_1Domain.html#a714a1473bb78dab3195bd5cd5e90af42">operations_research::Domain::AdditionWith</a>" (const Domain &amp;domain) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002429 (user): Use a better algorithm.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#afea26857db7d2e50a267c9d9d5ceb661 "<a class="el" href="classoperations__research_1_1Domain.html#afea26857db7d2e50a267c9d9d5ceb661">operations_research::Domain::ClosestValue</a>" (int64_t wanted) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002427 (user): Use std::upper_bound() like in ValueAtOrBefore() ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#a8de91c6ec98c4eaa9ec6c7e1f5e26d71 "<a class="el" href="classoperations__research_1_1Domain.html#a8de91c6ec98c4eaa9ec6c7e1f5e26d71">operations_research::Domain::Distance</a>" (int64_t value) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002428 (user): Deal with overflow.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Class \_internalref classoperations__research_1_1DynamicPartition "<a class="el" href="classoperations__research_1_1DynamicPartition.html">operations_research::DynamicPartition</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000007 (user): rename this to BacktrackableSplittingPartition. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Member \_internalref classoperations__research_1_1DynamicPartition#ae0789ce355b93a5161e63666b4467e67 "<a class="el" href="classoperations__research_1_1DynamicPartition.html#afe6f90b99c0b1d646b00ad2d1bb0a09d">operations_research::DynamicPartition::DynamicPartition</a>" (const std::vector&lt; int &gt; &amp;initial_part_of_element)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000003 (user): either remove this or factor it out if it can be used
elsewhere. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Member \_internalref classoperations__research_1_1DynamicPartition#ab82a2915429e5c6626c9187ed85e7064 "<a class="el" href="classoperations__research_1_1DynamicPartition.html#ab82a2915429e5c6626c9187ed85e7064">operations_research::DynamicPartition::Refine</a>" (absl::Span&lt; const int &gt; distinguished_subset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000004 (user): optimize the common singleton case.
 &lt;p&gt; \anchor _todo000005 (user): automatically switch to an O(N) sort when it's faster
than this one, which is O(K log K) with K = tmp_affected_parts_.size(). 
 &lt;p&gt; \anchor _todo000008 (user): the graph symmetry finder could probably benefit a lot from
keeping track of one additional bit of information for each part that
remains unchanged by a Refine() operation: was that part entirely &lt;em&gt;in&lt;/em&gt;
the distinguished subset or entirely &lt;em&gt;out&lt;/em&gt;? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPermutation Member \_internalref classoperations__research_1_1DynamicPermutation#a529b7a5b760666c049da283212991a5b "<a class="el" href="classoperations__research_1_1DynamicPermutation.html#a529b7a5b760666c049da283212991a5b">operations_research::DynamicPermutation::LooseEnds</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000009 (user): use a faster underlying container like SparseBitSet, and
tweak this API accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::EbertGraphBase Member \_internalref classoperations__research_1_1EbertGraphBase#a7adcbbf1af098a96abf7a3397246304d "<a class="el" href="classoperations__research_1_1EbertGraphBase.html#a7adcbbf1af098a96abf7a3397246304d">operations_research::EbertGraphBase&lt; NodeIndexType, ArcIndexType, DerivedGraph &gt;::GroupForwardArcsByFunctor</a>" (const ArcIndexTypeStrictWeakOrderingFunctor &amp;compare, PermutationCycleHandler&lt; ArcIndexType &gt; *annotation_handler)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000620 (user): Configure SWIG to handle the GroupForwardArcsByFunctor
member template and the CycleHandlerForAnnotatedArcs class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ElementDegreeSolutionGenerator Member \_internalref classoperations__research_1_1ElementDegreeSolutionGenerator#abbe235864c43f519c5ac9c0de3d870f4 "<a class="el" href="classoperations__research_1_1ElementDegreeSolutionGenerator.html#abbe235864c43f519c5ac9c0de3d870f4">operations_research::ElementDegreeSolutionGenerator::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000049 (user): Add time-outs and exit with a partial solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ElementIterator Class \_internalref classoperations__research_1_1ElementIterator "operations_research::ElementIterator&lt; Set &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000634 (user): Move the Set-related classbelow to util/bitset.h
Iterates over the elements of a set represented as an unsigned integer,
starting from the smallest element.  (See the class Set&lt;Integer&gt; below.) 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab0da8bffc5e8eafc798d8b3b1750f05b "<a class="el" href="namespaceoperations__research.html#ab0da8bffc5e8eafc798d8b3b1750f05b">operations_research::FillPathEvaluation</a>" (const std::vector&lt; int64_t &gt; &amp;path, const RoutingModel::TransitCallback2 &amp;evaluator, std::vector&lt; int64_t &gt; *values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000279 (user): Apply -pointer-following.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FilteredHeuristicLocalSearchOperator Class \_internalref classoperations__research_1_1FilteredHeuristicLocalSearchOperator "<a class="el" href="classoperations__research_1_1FilteredHeuristicLocalSearchOperator.html">operations_research::FilteredHeuristicLocalSearchOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000320 (user): Put these methods in an object with helper methods instead
of adding a layer to the class hierarchy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FilteredHeuristicLocalSearchOperator Member \_internalref classoperations__research_1_1FilteredHeuristicLocalSearchOperator#a27a42fcdb24320190aa6760ab0aa2c7a "<a class="el" href="classoperations__research_1_1FilteredHeuristicLocalSearchOperator.html#a27a42fcdb24320190aa6760ab0aa2c7a">operations_research::FilteredHeuristicLocalSearchOperator::model_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000321 (user): Remove the dependency from RoutingModel by storing an
IntVarFilteredHeuristic here instead and storing information on path
start/ends like PathOperator does (instead of relying on the model). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ae4ee4d82cf625670cdc1f52197454654 "<a class="el" href="namespaceoperations__research.html#ae4ee4d82cf625670cdc1f52197454654">operations_research::FindFeasibilityErrorInSolutionHint</a>" (const MPModelProto &amp;model, double tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000783 (user): Add a general FindFeasibilityErrorInSolution() and factor out the
common code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FindOneNeighbor Member \_internalref classoperations__research_1_1FindOneNeighbor#ae778e45052fc69775bc50b2d12294a4c "<a class="el" href="classoperations__research_1_1FindOneNeighbor.html#ae778e45052fc69775bc50b2d12294a4c">operations_research::FindOneNeighbor::FindOneNeighbor</a>" (Assignment *assignment, IntVar *objective, SolutionPool *pool, LocalSearchOperator *ls_operator, DecisionBuilder *sub_decision_builder, const RegularLimit *limit, LocalSearchFilterManager *filter_manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000223 (user): Support skipping neighborhood checks for limits accepting
more than one solution (e.g. best accept). For now re-enabling systematic
checks. 
 &lt;p&gt; \anchor _todo000224 (user): Support skipping neighborhood checks with LNS (at least on
the non-LNS operators). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FindOneNeighbor Member \_internalref classoperations__research_1_1FindOneNeighbor#a25667f46f98b5158a6d89bcf93a07b46 "<a class="el" href="classoperations__research_1_1FindOneNeighbor.html#a25667f46f98b5158a6d89bcf93a07b46">operations_research::FindOneNeighbor::Next</a>" (Solver *solver) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000225 (user) : SyncNeed(assignment_) ?
 &lt;p&gt; \anchor _todo000226 (user): Don't call both if no filter is incremental and one
of them returned false. 
 &lt;p&gt; \anchor _todo000227 (user): support the case were limit_ accepts more than
one solution (e.g. best accept). 
 &lt;p&gt; \anchor _todo000228 (user): Restore state of local search operators to
make sure we are exploring neighbors in the same order. This can
affect the local optimum found. 
 &lt;p&gt; \anchor _todo000229 (user): Compare assignments in addition to their cost. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a108e0d0f765ed56abc079b49c521915b "<a class="el" href="namespaceoperations__research.html#a108e0d0f765ed56abc079b49c521915b" title="Formats a solution or solver statistic according to the given format.">operations_research::FormatStatistic</a>" (absl::string_view name, T value, RoutingOutputFormat format)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001045 (user): think about using an enum instead of names (or even a
full-fledged struct/class) for the various types of fields. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ForwardStaticGraph::CycleHandlerForAnnotatedArcs Class \_internalref classoperations__research_1_1ForwardStaticGraph_1_1CycleHandlerForAnnotatedArcs "operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::CycleHandlerForAnnotatedArcs" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000618 (user): Configure SWIG to handle the
CycleHandlerForAnnotatedArcs class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ForwardStaticGraph Member \_internalref classoperations__research_1_1ForwardStaticGraph#a299d30373ebbfcb70fc84ecc66d95b92 "<a class="el" href="classoperations__research_1_1ForwardStaticGraph.html#a299d30373ebbfcb70fc84ecc66d95b92">operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::ForwardStaticGraph</a>" (const NodeIndexType num_nodes, const ArcIndexType num_arcs, const bool sort_arcs_by_head, std::vector&lt; std::pair&lt; NodeIndexType, NodeIndexType &gt; &gt; *client_input_arcs, operations_research::PermutationCycleHandler&lt; ArcIndexType &gt; *const client_cycle_handler)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000619 (user): For some reason, SWIG breaks if the
  operations_research namespace is not explicit in the
  following argument declaration.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Constraint Member \_internalref structoperations__research_1_1fz_1_1Constraint#a4d53b3107ef0dbfb3e99a52a2f4c0d42 "<a class="el" href="structoperations__research_1_1fz_1_1Constraint.html#a4d53b3107ef0dbfb3e99a52a2f4c0d42" title="Helpers to be used during presolve.">operations_research::fz::Constraint::MarkAsInactive</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000404 (user): Reclaim arguments and memory.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Struct \_internalref structoperations__research_1_1fz_1_1Domain "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html">operations_research::fz::Domain</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000406 (user): Rework domains, all int64_t should be kintmin..kint64max.
               It is a bit tricky though as we must take care of overflows.
If is_a_set is true, then this domain has a set semantics. For a set
variable, any subset of the initial set of values is a valid assignment,
instead of exactly one value. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ac4d428774d29f823cc82a1e9094f1926 "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ac4d428774d29f823cc82a1e9094f1926">operations_research::fz::Domain::HasOneValue</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000408 (user): Do we need SetOfFloats() ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ae0c523fec5cdb2c506835d037c78557c "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ae0c523fec5cdb2c506835d037c78557c">operations_research::fz::Domain::IntersectWithListOfIntegers</a>" (absl::Span&lt; const int64_t &gt; integers)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000402 (user): Investigate faster code for small arrays.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ae4c771e4304fd0443a538c84d3c62870 "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ae4c771e4304fd0443a538c84d3c62870">operations_research::fz::Domain::OverlapsIntList</a>" (const std::vector&lt; int64_t &gt; &amp;vec) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000403 (user): Better algorithm, sort and compare increasingly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::LexerInfo Struct \_internalref structoperations__research_1_1fz_1_1LexerInfo "<a class="el" href="structoperations__research_1_1fz_1_1LexerInfo.html">operations_research::fz::LexerInfo</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000416 (user): Use std::unique_ptr&lt;vector&lt; &gt;&gt; to ease memory management. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz Member \_internalref namespaceoperations__research_1_1fz#a0d0d1d18eea7879af81671f8395b8b1d "<a class="el" href="namespaceoperations__research_1_1fz.html#a0d0d1d18eea7879af81671f8395b8b1d">operations_research::fz::Lookup</a>" (const std::vector&lt; T &gt; &amp;v, int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000415 (user): replace this by a macro for better logging.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Model Member \_internalref classoperations__research_1_1fz_1_1Model#affdfad9a0c88744ef4cfe7c80adc4fb1 "<a class="el" href="classoperations__research_1_1fz_1_1Model.html#affdfad9a0c88744ef4cfe7c80adc4fb1">operations_research::fz::Model::AddConstant</a>" (int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000405 (user): Create only once constant per value.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::ModelStatistics Class \_internalref classoperations__research_1_1fz_1_1ModelStatistics "<a class="el" href="classoperations__research_1_1fz_1_1ModelStatistics.html">operations_research::fz::ModelStatistics</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000407 (user): Clean up API to pass a Model* in argument. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Presolver Class \_internalref classoperations__research_1_1fz_1_1Presolver "<a class="el" href="classoperations__research_1_1fz_1_1Presolver.html">operations_research::fz::Presolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000420 (user): Error reporting of unfeasible models. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a92fbc9576b457ceddeb21395181b3273 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a92fbc9576b457ceddeb21395181b3273">operations_research::GenericMaxFlow&lt; Graph &gt;::check_result_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000670 (user): Make the check more exhaustive by checking the optimality? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#ad7892ad5aa8338015f320267fb7f298f "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ad7892ad5aa8338015f320267fb7f298f">operations_research::GenericMaxFlow&lt; Graph &gt;::GetSinkSideMinCut</a>" (std::vector&lt; NodeIndex &gt; *result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000669 (user): In the two-phases algorithm, we can get this minimum cut
without doing the second phase. Add an option for this if there is a need
to, note that the second phase is pretty fast so the gain will be small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#ad3925f2137b18b1555563ed149ada740 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ad3925f2137b18b1555563ed149ada740">operations_research::GenericMaxFlow&lt; Graph &gt;::GlobalUpdate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000655 (user): By using more memory we can speed this up quite a bit by
avoiding to take the opposite arc here, too options:
- if (residual_arc_capacity_[arc] != arc_capacity_[arc])
- if (opposite_arc_is_admissible_[arc])  ///&lt; need updates.
Experiment with the first option shows more than 10% gain on this
function running time, which is the bottleneck on many instances. 
 &lt;p&gt; \anchor _todo000656 (user): Investigate more and maybe write a publication :) 
 &lt;p&gt; \anchor _todo000657 (user): This is another argument for another anti-overflow algorithm. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a20139b839cd5764939afc8df968a2484 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a20139b839cd5764939afc8df968a2484" title="Initializes the preflow to a state that enables to run Refine.">operations_research::GenericMaxFlow&lt; Graph &gt;::InitializePreflow</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000654 (user): find a way to make the re-solving incremental (not an obvious
task, and there has not been a lot of literature on the subject.) 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#aa96647a33c0a0898055642bd6d039f83 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ac4278804a3c23b3a7f340930a81ff15f" title="Maximum manageable flow.">operations_research::GenericMaxFlow&lt; Graph &gt;::kMaxFlowQuantity</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000662 (user): moves this code out of a .cc file and include it at the end of
the header so it can work with any graph implementation ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a1c31c96effb1f91f800895be2339045b "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a1c31c96effb1f91f800895be2339045b">operations_research::GenericMaxFlow&lt; Graph &gt;::PushFlow</a>" (FlowQuantity flow, ArcIndex arc)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000658 (user): Do not allow a zero flow after fixing the UniformMaxFlow code.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a1061c1ce94ccc0d379390b8542bfaa23 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a1061c1ce94ccc0d379390b8542bfaa23" title="Performs optimization step.">operations_research::GenericMaxFlow&lt; Graph &gt;::Refine</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000659 (user): This may not be the most efficient algorithm if we need to loop
many times. An alternative may be to handle the source like the other nodes
in the algorithm, initially putting an excess of kMaxFlowQuantity on it,
and making the source active like any other node with positive excess. To
investigate.&lt;p&gt; \anchor _todo000660 (user): The code below is buggy when more than kMaxFlowQuantity can be
pushed out of the source (i.e. when we loop more than once in the while()).
This is not critical, since this code is not used in the default algorithm
computation. The issue is twofold:
- InitializeActiveNodeContainer() doesn't push the nodes in
  the correct order.
- PushFlowExcessBackToSource() may break the node potential properties, and
  we will need a call to GlobalUpdate() to fix that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a91d754521a7d43dd215e5d6200ec1062 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a91d754521a7d43dd215e5d6200ec1062">operations_research::GenericMaxFlow&lt; Graph &gt;::RefineWithGlobalUpdate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000661 (user): This should be graph_-&gt;num_nodes(), but ebert graph does not
have a correct size if the highest index nodes have no arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a05f2661c573eb445212f4eddd694fc2f "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a05f2661c573eb445212f4eddd694fc2f" title="Sets the capacity for arc to new_capacity.">operations_research::GenericMaxFlow&lt; Graph &gt;::SetArcCapacity</a>" (ArcIndex arc, FlowQuantity new_capacity)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000653 (user): The easiest is probably to allow negative node excess in
other places than the source, but the current implementation does not
deal with this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMinCostFlow Class \_internalref classoperations__research_1_1GenericMinCostFlow "operations_research::GenericMinCostFlow&lt; Graph, ArcFlowType, ArcScaledCostType &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000681 (user): Avoid using the globally defined type CostValue and FlowQuantity.
Also uses the Arc*Type where there is no risk of overflow in more places. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMinCostFlow Member \_internalref classoperations__research_1_1GenericMinCostFlow#a342b29b5fe3d4a96bfc0c7d850e05d46 "<a class="el" href="classoperations__research_1_1GenericMinCostFlow.html#a342b29b5fe3d4a96bfc0c7d850e05d46">operations_research::GenericMinCostFlow&lt; Graph, ArcFlowType, ArcScaledCostType &gt;::CheckFeasibility</a>" (std::vector&lt; NodeIndex &gt; *infeasible_supply_node, std::vector&lt; NodeIndex &gt; *infeasible_demand_node)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000672 (user): make it possible to share a graph by MaxFlow and MinCostFlow.
For this it is necessary to make StarGraph resizable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a838df3808f198b2cbc781e426a601b29 "<a class="el" href="namespaceoperations__research.html#a20f1b86022ab6b187d9e205fc308eb39">operations_research::GetBestScalingOfDoublesToInt64</a>" (const std::vector&lt; double &gt; &amp;input, int64_t max_absolute_sum, double *scaling_factor, double *max_relative_coeff_error)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002411 (user): incorporate the gcd computation here? The issue is that I am
not sure if I just do factor /= gcd that round(x * factor) will be the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GlobalCheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1GlobalCheapestInsertionFilteredHeuristic#abe76b53e07ae6db10cda5c6fd70d0001 "<a class="el" href="classoperations__research_1_1GlobalCheapestInsertionFilteredHeuristic.html#abe76b53e07ae6db10cda5c6fd70d0001" title="Virtual method to redefine how to build a solution.">operations_research::GlobalCheapestInsertionFilteredHeuristic::BuildSolutionInternal</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000351 (user): Adapt the pair insertions to also support seed and
sequential insertion. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aeacc29c42c7fddda875937d3bdfc7e08 "<a class="el" href="namespaceoperations__research_1_1glop.html#aeacc29c42c7fddda875937d3bdfc7e08">operations_research::glop::ABSL_DEPRECATED</a>" ("Use the direct methods instead") MPSReader&lt;/dt&gt;&lt;dd&gt; \anchor _todo000855 (user): Remove the MPSReader class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::AddSlackVariablesPreprocessor Class \_internalref classoperations__research_1_1glop_1_1AddSlackVariablesPreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1AddSlackVariablesPreprocessor.html">operations_research::glop::AddSlackVariablesPreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000510 (user): Do not require this step to talk to the revised simplex. On large
LPs like supportcase11.mps, this step alone can add 1.5 GB to the solver peak
memory for no good reason. The internal matrix representation used in glop is
a lot more efficient, and there is no point keeping the slacks in
LinearProgram. It is also bad for incrementaly modifying the LP. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#acf14406acccf01da7c2dd2fa1c66425e "<a class="el" href="namespaceoperations__research_1_1glop.html#acf14406acccf01da7c2dd2fa1c66425e">operations_research::glop::ApplyPermutation</a>" (const Permutation&lt; IndexType &gt; &amp;perm, const ITIVectorType &amp;b, ITIVectorType *result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000863 (user): Try to restrict this method to using the same integer type in
the permutation and for the vector indices, i.e.
IndexType == ITIVectorType::IndexType. Some client code will need to be
refactored. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aac6525bf47674e01c5d51e956ce13a63 "<a class="el" href="namespaceoperations__research_1_1glop.html#aac6525bf47674e01c5d51e956ce13a63">operations_research::glop::AreFirstColumnsAndRowsExactlyEquals</a>" (RowIndex num_rows, ColIndex num_cols, const SparseMatrix &amp;matrix_a, const CompactSparseMatrix &amp;matrix_b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000852 (user): Also DCHECK() that matrix_b is ordered by rows.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#a370b080a5be3e81960457e53261e7cd5 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#a370b080a5be3e81960457e53261e7cd5">operations_research::glop::BasisFactorization::ComputeInitialBasis</a>" (const std::vector&lt; ColIndex &gt; &amp;candidates)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000425 (user): This "double" factorization is a bit inefficient, and we should
probably Initialize() right away the factorization with the new basis, but
more code is needed for that. It is also not that easy also because we want
to permute all the added slack first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#af2eba683b05901eb982dcade3fda53d3 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#af2eba683b05901eb982dcade3fda53d3">operations_research::glop::BasisFactorization::ComputeInverseOneNorm</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000423 (user): try to merge the computation of the norm of inverses
with that of MatrixView. Maybe use a wrapper class for InverseMatrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#a90e327f8ea7f4594bab0686230735287 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#a90e327f8ea7f4594bab0686230735287">operations_research::glop::BasisFactorization::RightSolveForProblemColumn</a>" (ColIndex col, ScatteredColumn *d) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000422 (user): if right_pool_mapping_[col] != kInvalidCol, we can reuse it and
just apply the last rank one update since it was computed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisState Struct \_internalref structoperations__research_1_1glop_1_1BasisState "<a class="el" href="structoperations__research_1_1glop_1_1BasisState.html">operations_research::glop::BasisState</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000604 (user): Introduce another state class to store a complete state of the
solver. Using this state and the original linear program, the solver can be
restarted with as little time overhead as possible. This is especially useful
for strong branching in a MIP context. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisState Member \_internalref structoperations__research_1_1glop_1_1BasisState#a8403627807a2ba65e69b8fb58061293f "<a class="el" href="structoperations__research_1_1glop_1_1BasisState.html#a8403627807a2ba65e69b8fb58061293f">operations_research::glop::BasisState::statuses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000605 (user): A MIP solver will potentially store a lot of BasisStates so
memory usage is important. It is possible to use only 2 bits for one
VariableStatus enum. To achieve this, the FIXED_VALUE status can be
converted to either AT_LOWER_BOUND or AT_UPPER_BOUND and decoded properly
later since this will be used with a given linear program. This way we can
even encode more information by using the reduced cost sign to choose to
which bound the fixed status correspond. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ColumnView Member \_internalref classoperations__research_1_1glop_1_1ColumnView#a37aadf4689cf83d4e92724df18788c26 "<a class="el" href="classoperations__research_1_1glop_1_1ColumnView.html#a37aadf4689cf83d4e92724df18788c26">operations_research::glop::ColumnView::LookUpCoefficient</a>" (RowIndex index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000878 (user): investigate whether an optimized version of
LookUpCoefficient for "clean" columns yields speed-ups. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::CompactSparseMatrix Member \_internalref classoperations__research_1_1glop_1_1CompactSparseMatrix#aa5613aefbe167b3a7060c47adbc18257 "<a class="el" href="classoperations__research_1_1glop_1_1CompactSparseMatrix.html#a28d29a8481b6e9b5fc41eedc1fc60e84">operations_research::glop::CompactSparseMatrix::CompactSparseMatrix</a>" (const SparseMatrix &amp;matrix)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000873 (user): If this is needed in production code, it can be done faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DataWrapper&lt; MPModelProto &gt; Member \_internalref classoperations__research_1_1glop_1_1DataWrapper_3_01MPModelProto_01_4#ae847ea2baa71fe069259a785a2f793ba "<a class="el" href="classoperations__research_1_1glop_1_1DataWrapper_3_01MPModelProto_01_4.html#ae847ea2baa71fe069259a785a2f793ba">operations_research::glop::DataWrapper&lt; MPModelProto &gt;::CleanUp</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000854 (user): Experiment with the switch constant.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a02a36a3bb1bee8ca88e9d07f4e914ad2 "<a class="el" href="namespaceoperations__research_1_1glop.html#a02a36a3bb1bee8ca88e9d07f4e914ad2">operations_research::glop::Density</a>" (const DenseRow &amp;row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000849 (user): Take a Scattered row/col instead. This is only used to report
stats, but we should still have a sparse version to do it faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonEqualityRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor#a417519507dabcad60034e4b158755bf5 "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor.html#a417519507dabcad60034e4b158755bf5">operations_research::glop::DoubletonEqualityRowPreprocessor::RecoverSolution</a>" (ProblemSolution *solution) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000499 (user): We can probably use something better than a vector of set,
but the number of entry is really sparse though. And the size of a set&lt;int&gt;
is 24 bytes, same as a std::vector&lt;int&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonEqualityRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor#aee8ab3fb7503d6267c9a09854ecd7a2d "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor.html#aee8ab3fb7503d6267c9a09854ecd7a2d">operations_research::glop::DoubletonEqualityRowPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000494 (user): Get rid of the FIXED status instead to avoid spending
time/memory for no good reason here. 
 &lt;p&gt; \anchor _todo000495 (user): There is probably some more robust ways. 
 &lt;p&gt; \anchor _todo000496 (user): make a smarter choice of which column to delete, and
swap col[] and coeff[] accordingly. 
 &lt;p&gt; \anchor _todo000497 (user): consider skipping the problematic rows in this preprocessor,
or trying harder to avoid the under/overflow. 
 &lt;p&gt; \anchor _todo000498 (user): rename that method to reflect the fact that it also updates
the objective offset, in the other direction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonFreeColumnPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonFreeColumnPreprocessor#ab64cfa1fb6ff03f45291fcb60f506963 "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonFreeColumnPreprocessor.html#ab64cfa1fb6ff03f45291fcb60f506963">operations_research::glop::DoubletonFreeColumnPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000478 (user): Impact? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DualEdgeNorms Member \_internalref classoperations__research_1_1glop_1_1DualEdgeNorms#ab9c06f7b3b7e0337da531ca86c3fd43c "<a class="el" href="classoperations__research_1_1glop_1_1DualEdgeNorms.html#ab9c06f7b3b7e0337da531ca86c3fd43c">operations_research::glop::DualEdgeNorms::UpdateBeforeBasisPivot</a>" (ColIndex entering_col, RowIndex leaving_row, const ScatteredColumn &amp;direction, const ScatteredRow &amp;unit_row_left_inverse)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000426 (user): use a more precise lower bound depending on the column norm?
We can do that with Cauchy-Swartz inequality:
  (edge . leaving_column)^2 = 1.0 &lt; |&lt;tt&gt;edge&lt;/tt&gt;|^2 * |&lt;tt&gt;leaving_column&lt;/tt&gt;|^2 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DualizerPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DualizerPreprocessor#afb190878213f1da31a0daa0f03b9e017 "<a class="el" href="classoperations__research_1_1glop_1_1DualizerPreprocessor.html#afb190878213f1da31a0daa0f03b9e017">operations_research::glop::DualizerPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000500 (user): This effect can be lowered if we use some of the extra
variables as slack variable which we are not doing at this point. 
 &lt;p&gt; \anchor _todo000501 (user): This will break if PopulateFromDual() is changed. so document
the convention or make the function fill these vectors? 
 &lt;p&gt; \anchor _todo000502 (user): There are two different ways to deal with ranged rows when
taking the dual. The default way is to duplicate such rows, see
PopulateFromDual() for details. Another way is to call
lp-&gt;AddSlackVariablesForFreeAndBoxedRows() before calling
PopulateFromDual(). Adds an option to switch between the two as this may
change the running time?&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DynamicMaximum Member \_internalref classoperations__research_1_1glop_1_1DynamicMaximum#a5a1cf0bc9507c1dfcef22b8d89d2d9f0 "<a class="el" href="classoperations__research_1_1glop_1_1DynamicMaximum.html#a5a1cf0bc9507c1dfcef22b8d89d2d9f0">operations_research::glop::DynamicMaximum&lt; Index &gt;::GetMaximum</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000517 (user): Add a mode when we do not maintain the TopK for small sizes
(like n &lt; 1000) ? The gain might not be worth the extra code though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#a3c3a0b006ecdc59714cd1c66f50e7cff "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#a3c3a0b006ecdc59714cd1c66f50e7cff">operations_research::glop::EnteringVariable::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000430 (user): Be exhausitive and more precise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#a863b59030d198656afffb23fcd533948 "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#a863b59030d198656afffb23fcd533948">operations_research::glop::EnteringVariable::DualChooseEnteringColumn</a>" (bool nothing_to_recompute, const UpdateRow &amp;update_row, Fractional cost_variation, std::vector&lt; ColIndex &gt; *bound_flip_candidates, ColIndex *entering_col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000427 (user): It is unclear if this is a good idea, but the primal simplex
have pretty good/stable behavior with a similar logic. Experiment seems
to show that this works well with the dual too. 
 &lt;p&gt; \anchor _todo000428 (user): We want to maximize both the ratio (objective improvement)
and the coeff_magnitude (stable pivot), so we have to make some
trade-offs. Investigate alternative strategies. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#ad20764201d083354bdf18a8def790e4a "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#ad20764201d083354bdf18a8def790e4a">operations_research::glop::EnteringVariable::DualPhaseIChooseEnteringColumn</a>" (bool nothing_to_recompute, const UpdateRow &amp;update_row, Fractional cost_variation, ColIndex *entering_col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000429 (user): This is the same in DualChooseEnteringColumn(), remove
duplication? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aed75af61dbbe6d3c628c274f271f9000 "<a class="el" href="namespaceoperations__research_1_1glop.html#aed75af61dbbe6d3c628c274f271f9000">operations_research::glop::FindProportionalColumns</a>" (const SparseMatrix &amp;matrix, Fractional tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000851 (user): Derive precise bounds on what this tolerance should be so
that no proportional columns are missed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#ac55fddbd6cdae02b8a88e2c845f0d4d7 "<a class="el" href="namespaceoperations__research_1_1glop.html#ac55fddbd6cdae02b8a88e2c845f0d4d7">operations_research::glop::FixConstraintWithFixedStatuses</a>" (const DenseColumn &amp;row_lower_bounds, const DenseColumn &amp;row_upper_bounds, ProblemSolution *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000508 (user): A better solution would simply be to get rid of the FIXED status
altogether, it is better to simply use AT_LOWER_BOUND/AT_UPPER_BOUND
depending on the constraining bound in the optimal solution. Note that we can
always at the end transform any variable/constraint with a fixed domain to
FIXED_VALUE if needed to keep the same external API. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ImpliedFreePreprocessor Class \_internalref classoperations__research_1_1glop_1_1ImpliedFreePreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1ImpliedFreePreprocessor.html">operations_research::glop::ImpliedFreePreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000507 (user): Only process doubleton columns so we have more chance in the
later passes to create more doubleton columns? Such columns lead to a smaller
problem thanks to the DoubletonFreeColumnPreprocessor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ImpliedFreePreprocessor Member \_internalref classoperations__research_1_1glop_1_1ImpliedFreePreprocessor#a22a4d717e6ac86260356defc467e980e "<a class="el" href="classoperations__research_1_1glop_1_1ImpliedFreePreprocessor.html#a22a4d717e6ac86260356defc467e980e">operations_research::glop::ImpliedFreePreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000473 (user) : Replace SumWithNegativeInfiniteAndOneMissing and
SumWithPositiveInfiniteAndOneMissing with IntervalSumWithOneMissing. 
 &lt;p&gt; \anchor _todo000474 (user): Only process degree-two so in subsequent passes more degree-two
columns could be made free. And only when no other reduction can be
applied, process the higher degree column?&lt;p&gt; \anchor _todo000475 (user): Be smarter about the order that maximizes the number of free
column. For instance if we have 3 doubleton columns that use the rows (1,2)
(2,3) and (3,4) then it is better not to make (2,3) free so the two other
two can be made free. 
 &lt;p&gt; \anchor _todo000476 (user): As of July 2013, with our preprocessors this case is never
triggered on the Netlib. Note however that if it appears it can have a
big impact since by fixing the variable, the two involved constraints
are forcing and can be removed too (with all the variables they touch).
The postsolve step is quite involved though. 
 &lt;p&gt; \anchor _todo000477 (user): This trick is already used in the DualizerPreprocessor,
maybe we should just have a preprocessor that shifts all the variables
bounds to have at least one of them at 0.0, will that improve precision
and speed of the simplex? One advantage is that we can compute the
new constraint bounds with better precision using AccurateSum. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a451faba66f544c02438a3ce062b69900 "<a class="el" href="namespaceoperations__research_1_1glop.html#a451faba66f544c02438a3ce062b69900">operations_research::glop::KahanSum</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000847 (user): For some Fractional types, it may not gain much (or even nothing
if we are in infinite precision) to use this sum. A solution is to templatize
this class and specialize it to a normal sum for the Fractional type we want
so in this case the PreciseXXX() functions below will become equivalent to
their normal version. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#abbaca14cc7f5a0f3aaeb027fef37e0ca "<a class="el" href="namespaceoperations__research_1_1glop.html#abbaca14cc7f5a0f3aaeb027fef37e0ca">operations_research::glop::kNonPivotal</a>" (-1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000877 (user): Consider using kInvalidRow for this?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a65b22be15b4caa784b8d7c690e2418ae "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a65b22be15b4caa784b8d7c690e2418ae">operations_research::glop::LinearProgram::AddSlackVariablesWhereNecessary</a>" (bool detect_integer_constraints)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000842 (user): investigate the impact on the running time. It seems low
because we almost never iterate on fixed variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#ab7e81c6d3e23deb4d58662661bf07f70 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#ab7e81c6d3e23deb4d58662661bf07f70">operations_research::glop::LinearProgram::Dump</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000837 (user): if needed provide similar output for binary variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8eb71b2feea025093caf9ee0ecaa1bc5 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8eb71b2feea025093caf9ee0ecaa1bc5">operations_research::glop::LinearProgram::FindOrCreateVariable</a>" (absl::string_view variable_id)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000839 (user): Move these and the two corresponding hash_table into a new
LinearProgramBuilder class to simplify the code of some functions like
DeleteColumns() here and make the behavior on copy clear? or simply remove
them as it is almost as easy to maintain a hash_table on the client side. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#abdf54cae5dbc76354d86e34108dcb3f3 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#abdf54cae5dbc76354d86e34108dcb3f3">operations_research::glop::LinearProgram::GetNonZeroStats</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000841 (user): Theses are statistics about the underlying matrix and should be
moved to SparseMatrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8c6c53f53e930c90d42930e648946ec6 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8c6c53f53e930c90d42930e648946ec6" title="Returns whether the variable at column col must take binary values or not.">operations_research::glop::LinearProgram::IsVariableBinary</a>" (ColIndex col) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000836 (user): bounds of binary variables (and of integer ones) should
be integer. Add a preprocessor for that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#afdef8d3fad551379c138ea96f9b695d3 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#afdef8d3fad551379c138ea96f9b695d3">operations_research::glop::LinearProgram::PopulateFromDual</a>" (const LinearProgram &amp;dual, RowToColMapping *duplicated_rows)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000843 (user): Do not interpret as a minimization problem? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8c83436c29274ad2930e716a0032d708 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8c83436c29274ad2930e716a0032d708">operations_research::glop::LinearProgram::ScaleObjective</a>" (GlopParameters::CostScalingAlgorithm method)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000844 (user): Another more aggressive idea is to set the median/mean/geomean
of the magnitudes to one. Investigate if this leads to better results. It
does look more robust.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#aafd3e53a18570f0757a0a58f666b88c8 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#aafd3e53a18570f0757a0a58f666b88c8">operations_research::glop::LinearProgram::SetVariableName</a>" (ColIndex col, absl::string_view name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000840 (user): Add PopulateIdsFromNames() so names added via
Set{Variable|Constraint}Name() can be found. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#a9546370ee7138da64e3fb67577230bad "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#a9546370ee7138da64e3fb67577230bad">operations_research::glop::LPSolver::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000448 (user): Currently, this is only modified when the simplex code is
executed.&lt;p&gt; \anchor _todo000449 (user): Improve the correlation with the running time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#ae525d5598b932514635be5f0329610a4 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#ae525d5598b932514635be5f0329610a4">operations_research::glop::LPSolver::LoadAndVerifySolution</a>" (const LinearProgram &amp;lp, const ProblemSolution &amp;solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000435 (user): Try to also check the precision of an INFEASIBLE or UNBOUNDED
return status. 
 &lt;p&gt; \anchor _todo000436 (user): the name is not really consistent since in practice those are
the "residual" since the primal/dual infeasibility are zero when
parameters_.provide_strong_optimal_guarantee() is true. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#adb7f0e515ab9d9503a454e05904c0376 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#adb7f0e515ab9d9503a454e05904c0376">operations_research::glop::LPSolver::MayHaveMultipleOptimalSolutions</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000447 (user): Test this behavior extensively if a client relies on it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#ac1d303dc79dae9cefd6185fda6c60e33 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#ac1d303dc79dae9cefd6185fda6c60e33">operations_research::glop::LPSolver::SolveWithTimeLimit</a>" (const LinearProgram &amp;lp, TimeLimit *time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000433 (user): Unfortunately we are not really helpful with the error message
here. We could do a better job. However most client should talk to glop via
an input protocol buffer which should have better validation messages. 
 &lt;p&gt; \anchor _todo000434 (user): If speed matter, we could do that as we copy the program. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LuFactorization Member \_internalref classoperations__research_1_1glop_1_1LuFactorization#ab7b32a56a250336b4f954ad707f24b90 "<a class="el" href="classoperations__research_1_1glop_1_1LuFactorization.html#ab7b32a56a250336b4f954ad707f24b90">operations_research::glop::LuFactorization::ComputeLowerTimesUpper</a>" (SparseMatrix *product) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000452 (user): avoid the matrix conversion by multiplying TriangularMatrix
directly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LuFactorization Member \_internalref classoperations__research_1_1glop_1_1LuFactorization#a9af5d602c804b0b6b64ace6d1b61f169 "<a class="el" href="classoperations__research_1_1glop_1_1LuFactorization.html#a9af5d602c804b0b6b64ace6d1b61f169">operations_research::glop::LuFactorization::ComputeOneNormConditionNumber</a>" (const CompactSparseMatrixView &amp;matrix) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000451 (user): separate this from LuFactorization. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MainLpPreprocessor Member \_internalref classoperations__research_1_1glop_1_1MainLpPreprocessor#a2d3237c0758f6628b102fcbe5b2002c8 "<a class="el" href="classoperations__research_1_1glop_1_1MainLpPreprocessor.html#a2d3237c0758f6628b102fcbe5b2002c8">operations_research::glop::MainLpPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000467 (user): Run them in the loop above if the effect on the running time
is good. This needs more investigation. 
 &lt;p&gt; \anchor _todo000468 (user): We probably want to scale the costs before and after this
preprocessor so that the rhs/objective of the dual are with a good
magnitude. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Markowitz Member \_internalref classoperations__research_1_1glop_1_1Markowitz#a57adb2bec33795ce391f871a1acbf761 "<a class="el" href="classoperations__research_1_1glop_1_1Markowitz.html#a57adb2bec33795ce391f871a1acbf761">operations_research::glop::Markowitz::ComputeRowAndColumnPermutation</a>" (const CompactSparseMatrixView &amp;basis_matrix, RowPermutation *row_perm, ColumnPermutation *col_perm)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000453 (user): If we don't need L and U, we can abort when the residual
matrix becomes dense (i.e. when its density factor is above a certain
threshold). The residual size is 'end_index - index' and the
density can either be computed exactly or estimated from min_markowitz. 
 &lt;p&gt; \anchor _todo000454 (user): This step can be skipped, once a fully dense matrix is
obtained. But note that permuted_lower_column_needs_solve_ needs to be
updated. 
 &lt;p&gt; \anchor _todo000455 (user): Note that in some rare cases, because of numerical
cancellation, the column degree may actually be smaller than
pivot_col_degree. Exploit that better? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MatrixEntry Struct \_internalref structoperations__research_1_1glop_1_1MatrixEntry "<a class="el" href="structoperations__research_1_1glop_1_1MatrixEntry.html" title="Holds a triplet (row, col, coefficient).">operations_research::glop::MatrixEntry</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000506 (user): Generalize the design used in this preprocessor to a general
"propagation" framework in order to apply as many reductions as possible in
an efficient manner. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MatrixNonZeroPattern Member \_internalref classoperations__research_1_1glop_1_1MatrixNonZeroPattern#acba2eb03de47fb8c7cabe51848d04612 "<a class="el" href="classoperations__research_1_1glop_1_1MatrixNonZeroPattern.html#acba2eb03de47fb8c7cabe51848d04612">operations_research::glop::MatrixNonZeroPattern::Update</a>" (RowIndex pivot_row, ColIndex pivot_col, const SparseColumn &amp;column)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000462 (user): Special case if row_non_zero_[pivot_row].size() == 1?
 &lt;p&gt; \anchor _todo000463 (user): Add unit tests before using this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#af8a64136c69a6dfc1b38c22c754cbe65 "<a class="el" href="namespaceoperations__research_1_1glop.html#af8a64136c69a6dfc1b38c22c754cbe65" title="Converts a MPModelProto to a LinearProgram.">operations_research::glop::MPModelProtoToLinearProgram</a>" (const MPModelProto &amp;input, LinearProgram *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000864 (user): clean up loops to use natural range iteration.
 &lt;p&gt; \anchor _todo000865 (user): implement strong proto validation in the
linear solver server and re-use it here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Preprocessor Class \_internalref classoperations__research_1_1glop_1_1Preprocessor "<a class="el" href="classoperations__research_1_1glop_1_1Preprocessor.html">operations_research::glop::Preprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000505 (user): On most preprocessors, calling Run() more than once will not work
as expected. Fix? or document and crash in debug if this happens. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Preprocessor Member \_internalref classoperations__research_1_1glop_1_1Preprocessor#ab755069ed133ea14ffec0bba56930559 "<a class="el" href="classoperations__research_1_1glop_1_1Preprocessor.html#ab755069ed133ea14ffec0bba56930559">operations_research::glop::Preprocessor::IsSmallerWithinPreprocessorZeroTolerance</a>" (Fractional a, Fractional b) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000511 (user): use an absolute tolerance here to be even more defensive?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::PrimalPrices Class \_internalref classoperations__research_1_1glop_1_1PrimalPrices "<a class="el" href="classoperations__research_1_1glop_1_1PrimalPrices.html">operations_research::glop::PrimalPrices</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000529 (user): Not high priority but should probably be moved to its own file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::PrimalPrices Member \_internalref classoperations__research_1_1glop_1_1PrimalPrices#ab2a479cbb008b8ae4b9ec2d294f79c07 "<a class="el" href="classoperations__research_1_1glop_1_1PrimalPrices.html#ab2a479cbb008b8ae4b9ec2d294f79c07">operations_research::glop::PrimalPrices::PrimalPrices</a>" (absl::BitGenRef random, const VariablesInfo &amp;variables_info, PrimalEdgeNorms *primal_edge_norms, ReducedCosts *reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000531 (user): Switch to a model based API like in CP-SAT. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ProportionalColumnPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ProportionalColumnPreprocessor#afdfcacb0413c8aefe02ff1b9eae0ac68 "<a class="el" href="classoperations__research_1_1glop_1_1ProportionalColumnPreprocessor.html#afdfcacb0413c8aefe02ff1b9eae0ac68">operations_research::glop::ProportionalColumnPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000470 (user): Change FindProportionalColumns for this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ProportionalRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ProportionalRowPreprocessor#adddaa59a5bbb8b300795e6f2b9287d3c "<a class="el" href="classoperations__research_1_1glop_1_1ProportionalRowPreprocessor.html#adddaa59a5bbb8b300795e6f2b9287d3c">operations_research::glop::ProportionalRowPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000471 (user): Already return such a mapping from
FindProportionalColumns()? 
 &lt;p&gt; \anchor _todo000472 (user): if the bounds are equal, use the largest row in magnitude?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RandomAccessSparseColumn Member \_internalref classoperations__research_1_1glop_1_1RandomAccessSparseColumn#a59461735207f0d09b1175d3522762f2a "<a class="el" href="classoperations__research_1_1glop_1_1RandomAccessSparseColumn.html#a59461735207f0d09b1175d3522762f2a">operations_research::glop::RandomAccessSparseColumn::PopulateSparseColumn</a>" (SparseColumn *sparse_column) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000876 (user): Do that only if (value != 0.0) ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RankOneUpdateFactorization Member \_internalref classoperations__research_1_1glop_1_1RankOneUpdateFactorization#a3b877b20ffaa0ba743da5c3cb7fa7744 "<a class="el" href="classoperations__research_1_1glop_1_1RankOneUpdateFactorization.html#a3b877b20ffaa0ba743da5c3cb7fa7744">operations_research::glop::RankOneUpdateFactorization::DeterministicTimeSinceLastReset</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000526 (user): This is quite precise. However we overcount a bit, because in
each elementary solves, if the scalar product involved is zero, we skip
some of the operations counted here. Is it worth spending a bit more time
to be more precise here? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RankOneUpdateFactorization Member \_internalref classoperations__research_1_1glop_1_1RankOneUpdateFactorization#af68318310cfb9859c6d98a3e31ccafac "<a class="el" href="classoperations__research_1_1glop_1_1RankOneUpdateFactorization.html#af68318310cfb9859c6d98a3e31ccafac">operations_research::glop::RankOneUpdateFactorization::RankOneUpdateFactorization</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000525 (user): make the 5% a parameter and share it between all the places
that switch between a sparse/dense version. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#ac81a24729018987c4d0668b7dc92b7c7 "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#ac81a24729018987c4d0668b7dc92b7c7">operations_research::glop::RevisedSimplex::ComputeDictionary</a>" (const DenseRow *column_scales)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000586 (user): Use row scales as well. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#ada2f59f7b385068f27d172f1f9bff72a "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#ada2f59f7b385068f27d172f1f9bff72a">operations_research::glop::RevisedSimplex::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000541 (user): Count what is missing.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#ac08f8edb988e06b034fa6f9516913368 "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#ac08f8edb988e06b034fa6f9516913368">operations_research::glop::RevisedSimplex::Solve</a>" (const LinearProgram &amp;lp, TimeLimit *time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000533 (user): Avoid doing the first phase checks when we know from the
incremental solve that the solution is already dual or primal feasible. 
 &lt;p&gt; \anchor _todo000534 (user): Not ideal in an incremental setting. 
 &lt;p&gt; \anchor _todo000535 (user): Note that if there was cost shifts, we just keep them
until the end of the optim.&lt;p&gt; \anchor _todo000536 (user): What if slightly infeasible? we shouldn't really stop.
Call primal ? use higher tolerance ? It seems we can always kind of
continue and deal with the issue later. Find a way other than this +
1e-6 hack. 
 &lt;p&gt; \anchor _todo000537 (user): We should also confirm the PRIMAL_UNBOUNDED or DUAL_UNBOUNDED
status by checking with the other phase I that the problem is really
DUAL_INFEASIBLE or PRIMAL_INFEASIBLE. For instance we currently report
PRIMAL_UNBOUNDED with the primal on the problem l30.mps instead of
OPTIMAL and the dual does not have issues on this problem.&lt;p&gt; \anchor _todo000538 (user): There is another issue on infeas/qual.mps. I think we should
just check the dual ray, not really the current solution dual
feasibility. 
 &lt;p&gt; \anchor _todo000539 (user): we currently skip the DUAL_INFEASIBLE status because the
quantities are not up to date in this case. 
 &lt;p&gt; \anchor _todo000540 (user): We should re-check for feasibility at this point and
apply clean-up as needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplexDictionary Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplexDictionary#a23359894a725f27972fc3a3b6b919db9 "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplexDictionary.html#a23359894a725f27972fc3a3b6b919db9">operations_research::glop::RevisedSimplexDictionary::GetBasicColumnForRow</a>" (RowIndex r) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000590 (user): This function is a better fit for the future custom iterator.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplexDictionary Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplexDictionary#a79cca8bd83c2bde1691dd782335d767e "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplexDictionary.html#a79cca8bd83c2bde1691dd782335d767e">operations_research::glop::RevisedSimplexDictionary::RevisedSimplexDictionary</a>" (const DenseRow *col_scales, RevisedSimplex *revised_simplex)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000589 (user): Overload this to take RevisedSimplex* alone when the
caller would normally pass a nullptr for col_scales so this and
ComputeDictionary can take a const&amp; argument. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a46935a48ea28abfec1c2569fe4aea70f "<a class="el" href="namespaceoperations__research_1_1glop.html#a3d9874910f9632900fe8677463b1c0be">operations_research::glop::ScalarProduct</a>" (const DenseRowOrColumn &amp;u, const SparseColumn &amp;v)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000848 (user): Optimize this more (SSE or unroll with two sums). Another
option is to skip the u[col] that are 0.0 rather than fetching the coeff
and doing a Fractional multiplication. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ScatteredVector Struct \_internalref structoperations__research_1_1glop_1_1ScatteredVector "operations_research::glop::ScatteredVector&lt; Index, Iterator &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000866 (user): This should be changed from struct to class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ScatteredVector Member \_internalref structoperations__research_1_1glop_1_1ScatteredVector#a1863a881c8165a5b4217f58e70dcbc97 "<a class="el" href="structoperations__research_1_1glop_1_1ScatteredVector.html#a1863a881c8165a5b4217f58e70dcbc97">operations_research::glop::ScatteredVector&lt; Index, Iterator &gt;::kDefaultRatioForUsingDenseIteration</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000867 (user): The constant should depend on what algorithm is used. Clearing
a dense vector is a lot more efficient than doing more complex stuff. Clean
this up by extracting all the currently used constants in one place with
meaningful names. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ShiftVariableBoundsPreprocessor Class \_internalref classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor.html">operations_research::glop::ShiftVariableBoundsPreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000509 (user): Having for each variable one of their bounds at zero is a
requirement for the DualizerPreprocessor and for the implied free column in
the ImpliedFreePreprocessor. However, shifting a variable with a domain like
[-1e10, 1e10] may introduce numerical issues. Relax the definition of
a free variable so that only having a domain containing 0.0 is enough? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ShiftVariableBoundsPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor#aaa5aa6fd0a5ab4229ab8b8f1ca6f638c "<a class="el" href="classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor.html#aaa5aa6fd0a5ab4229ab8b8f1ca6f638c">operations_research::glop::ShiftVariableBoundsPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000503 (user): This would not be needed, if we always make the bound
of an integer variable integer before applying this preprocessor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SingletonPreprocessor Member \_internalref classoperations__research_1_1glop_1_1SingletonPreprocessor#ad57922a716f7058c76b5f524950b8953 "<a class="el" href="classoperations__research_1_1glop_1_1SingletonPreprocessor.html#ad57922a716f7058c76b5f524950b8953">operations_research::glop::SingletonPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000492 (user): It seems better to process all the singleton columns with
a cost of zero first. 
 &lt;p&gt; \anchor _todo000493 (user): We should be able to restrict the variable bounds with the
ones of the constraint all the time. However, some situation currently
break the presolve, and it seems hard to fix in a 100% safe way. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseMatrixScaler Member \_internalref classoperations__research_1_1glop_1_1SparseMatrixScaler#abe05dd74a745d50bce6f9b6f14ab0bbc "<a class="el" href="classoperations__research_1_1glop_1_1SparseMatrixScaler.html#abe05dd74a745d50bce6f9b6f14ab0bbc" title="Scales the matrix.">operations_research::glop::SparseMatrixScaler::Scale</a>" (GlopParameters::ScalingAlgorithm method)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000850 (user): Decide precisely for which value of dynamic range we should cut
off geometric scaling. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseRow Class \_internalref classoperations__research_1_1glop_1_1SparseRow "<a class="el" href="classoperations__research_1_1glop_1_1SparseRow.html">operations_research::glop::SparseRow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000879 (user): Use this class where appropriate, i.e. when a SparseColumn is
used to store a row vector (by means of RowIndex to ColIndex casting). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Class \_internalref classoperations__research_1_1glop_1_1SparseVector "operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000880 (user): un-expose this type to client; by getting rid of the
index-based APIs and leveraging iterator-based APIs; if possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#a281b1ceefbefc14e321958f139dd8ea3 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a281b1ceefbefc14e321958f139dd8ea3">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::AllEntryIndices</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000885 (user): consider removing this, in favor of the natural range
iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#afb0952c189b9c921d79526b96295a2c8 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afb0952c189b9c921d79526b96295a2c8">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::CleanUp</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000881 (user): Implement in-place sorting of the entries and cleanup. The
current version converts the data to an array-of-pairs representation that
can be sorted easily with std::stable_sort, and the converts the sorted
data back to the struct-of-arrays implementation.
The current version is ~20% slower than the in-place sort on the
array-of-struct representation. It is not visible on GLOP benchmarks, but
it increases peak memory usage by ~8%.
Implementing in-place search will require either implementing a custom
sorting code, or custom iterators that abstract away the internal
representation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#afbae873b1b6a1f33cac11606834b6d0e "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afbae873b1b6a1f33cac11606834b6d0e">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::LookUpCoefficient</a>" (Index index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000884 (user): investigate whether an optimized version of
LookUpCoefficient for "clean" columns yields speed-ups. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#ac8066cbc5d5b7f8e794677b027cd96a2 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac8066cbc5d5b7f8e794677b027cd96a2">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::MoveTaggedEntriesTo</a>" (const IndexPermutation &amp;index_perm, SparseVector *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000883 (user): In the way we use this function, we know that will not
happen, but it is better to be careful so we can check that properly in
debug mode. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::StrictITISpan Member \_internalref classoperations__research_1_1glop_1_1StrictITISpan#a567f91a908d6143535f19afba8b2066b "<a class="el" href="classoperations__research_1_1glop_1_1StrictITISpan.html#a567f91a908d6143535f19afba8b2066b">operations_research::glop::StrictITISpan&lt; IntType, T &gt;::begin</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000846 (user): This should probably be a strictly typed iterator too, but
&lt;tt&gt;StrongVector::begin()&lt;/tt&gt; already suffers from this problem. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::StrictITIVector Class \_internalref classoperations__research_1_1glop_1_1StrictITIVector "operations_research::glop::StrictITIVector&lt; IntType, T &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000845 (user): This should probably move into ITIVector, but note that this
version is more strict and does not allow any other size types. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#ad5f38322fa7495d265b8a9d165e04661 "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#ad5f38322fa7495d265b8a9d165e04661">operations_research::glop::TriangularMatrix::AddAndNormalizeTriangularColumn</a>" (const SparseColumn &amp;column, RowIndex diagonal_row, Fractional diagonal_coefficient)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000869 (user): use division by a constant using multiplication.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#a73b763db84bea0b037a221f4f0a8b341 "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#a73b763db84bea0b037a221f4f0a8b341">operations_research::glop::TriangularMatrix::ComputeRowsToConsiderInSortedOrder</a>" (RowIndexVector *non_zero_rows) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000872 (user): Investigate the best thresholds.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#adbf1ad02396e91500821d368dcd2ed4a "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#adbf1ad02396e91500821d368dcd2ed4a">operations_research::glop::TriangularMatrix::ComputeRowsToConsiderWithDfs</a>" (RowIndexVector *non_zero_rows) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000871 (user): Investigate the best thresholds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#accd27fcf09dbc70b99c5ff3420df68ab "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#accd27fcf09dbc70b99c5ff3420df68ab">operations_research::glop::TriangularMatrix::PermutedLowerSparseSolve</a>" (const ColumnView &amp;rhs, const RowPermutation &amp;row_perm, SparseColumn *lower, SparseColumn *upper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000870 (user): The size of lower is exact, so we could be slighly faster here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#a85bc81777e98efdcf8e96566dc7b34b5 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#a85bc81777e98efdcf8e96566dc7b34b5">operations_research::glop::UnconstrainedVariablePreprocessor::RecoverSolution</a>" (ProblemSolution *solution) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000485 (user): In presence of free row, we must move them to 0.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#ab9d32efc837e15a7512083c4e450d459 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#ab9d32efc837e15a7512083c4e450d459">operations_research::glop::UnconstrainedVariablePreprocessor::RemoveZeroCostUnconstrainedVariable</a>" (ColIndex col, Fractional target_bound, LinearProgram *lp)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000479 (user): Here, we may render the row free, so subsequent columns
processed by the columns loop in Run() have more chance to be removed.
However, we need to be more careful during the postsolve() if we do that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#a59fa9c1508a94256ea5cb1d79597d170 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#a59fa9c1508a94256ea5cb1d79597d170">operations_research::glop::UnconstrainedVariablePreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000480 (user): Expose it as a parameter. We could rename both to
preprocessor_low_tolerance and preprocessor_high_tolerance. 
 &lt;p&gt; \anchor _todo000481 (user): expose this as a parameter? IMO it isn't really needed as we
shouldn't reach this limit except in corner cases. 
 &lt;p&gt; \anchor _todo000482 (user): deal with the more generic case. 
 &lt;p&gt; \anchor _todo000483 (user): this also works if the variable is integer, but we must
choose an integer value during the post-solve. Implement this. 
 &lt;p&gt; \anchor _todo000484 (user): It should probably
work with only small modification, investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a83458aab35755e7f4e0f1a2b38c912c2 "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a83458aab35755e7f4e0f1a2b38c912c2">operations_research::glop::UpdateRow::ComputeUnitRowLeftInverse</a>" (RowIndex leaving_row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000591 (user): Refactorize if the estimated accuracy is above a threshold.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a87bff95c808ef1850684ba48f3bf044f "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a87bff95c808ef1850684ba48f3bf044f">operations_research::glop::UpdateRow::ComputeUpdateRow</a>" (RowIndex leaving_row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000592 (user): So far we didn't generalize the use of drop tolerances
everywhere in the solver, so we make sure to not modify
unit_row_left_inverse_ that is also used elsewhere. However, because of
that, we will not get the exact same result depending on the algortihm
used below because the ComputeUpdatesColumnWise() will still use these
small entries (no complexity changes). 
 &lt;p&gt; \anchor _todo000593 (user): The impact is not as high as I hopped though, so not too
important. 
 &lt;p&gt; \anchor _todo000594 (user): automate the computation of these constants at run-time? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a0574601e3d61bdd8bafbd8996c78516b "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a0574601e3d61bdd8bafbd8996c78516b">operations_research::glop::UpdateRow::GetCoefficients</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000596 (user): Consider returning a packed vector of coefficient parallel to
GetNonZeroPositions() instead. It should be fast to compute and iteration
later should be quicker. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#ad86973493f57542e9a1e926b2e1f5198 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#ad86973493f57542e9a1e926b2e1f5198">operations_research::glop::VariablesInfo::EndDualPhaseI</a>" (Fractional dual_feasibility_tolerance, DenseRow::ConstView reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000603 (user): When there is a choice, use the previous status that might
have been warm-started ? but then this is not high priority since
warm-starting with a non-dual feasible basis seems unfrequent. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#a2b7789e59bf13941d89cc6accd874fe1 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#a2b7789e59bf13941d89cc6accd874fe1">operations_research::glop::VariablesInfo::TransformToDualPhaseIProblem</a>" (Fractional dual_feasibility_tolerance, DenseRow::ConstView reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000606 (user): Shall we re-add the bound when the variable is moved out of
the base? it is not needed, but might allow for more bound flips? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#aa6ae2139d9427d7dc458a93e2f8b5588 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#aa6ae2139d9427d7dc458a93e2f8b5588">operations_research::glop::VariablesInfo::UpdateToBasicStatus</a>" (ColIndex col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000599 (user): A bit annoying that we need to test this even if we
don't use the dual. But the cost is minimal. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariableValues Member \_internalref classoperations__research_1_1glop_1_1VariableValues#ab0a189867045312e53d3f0c88974e81e "<a class="el" href="classoperations__research_1_1glop_1_1VariableValues.html#ab0a189867045312e53d3f0c88974e81e">operations_research::glop::VariableValues::RecomputeDualPrices</a>" (bool put_more_importance_on_norm=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000597 (user): On some problem like stp3d.mps or pds-100.mps, using different
price like abs(infeasibility) / squared_norms give better result. Some
solver switch according to a criteria like all entry are +1/-1, the column
have no more than 24 non-zero and the average column size is no more than
6! Understand and implement some variant of this? I think the gain is
mainly because of using sparser vectors? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLOPInterface Member \_internalref classoperations__research_1_1GLOPInterface#ac495bd550d8588e457e6998d9af89b53 "<a class="el" href="classoperations__research_1_1GLOPInterface.html#ac495bd550d8588e457e6998d9af89b53">operations_research::GLOPInterface::SetDualTolerance</a>" (double value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000748 (user): Modify parameters_ with the correct value.
The problem is that this is set by default by the wrapper to 1e-7 and for
now we want to use higher default tolerances in Glop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLOPInterface Member \_internalref classoperations__research_1_1GLOPInterface#a5e4f4b2a7b1140077d676a179a349dc3 "<a class="el" href="classoperations__research_1_1GLOPInterface.html#a5e4f4b2a7b1140077d676a179a349dc3">operations_research::GLOPInterface::SetPrimalTolerance</a>" (double value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000747 (user): Modify parameters_ with the correct value.
The problem is that this is set by default by the wrapper to 1e-7 and for
now we want to use higher default tolerances in Glop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a8244072bcb5c3ae1038d9c3f7be4bb8b "<a class="el" href="namespaceoperations__research.html#a8244072bcb5c3ae1038d9c3f7be4bb8b">operations_research::GlopSolveProto</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request, std::atomic&lt; bool &gt; *interrupt_solve, std::function&lt; void(const std::string &amp;)&gt; logging_callback)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000788 (user): We do not support all the parameters here. In particular the
logs before the solver is called will not be appended to the response. Fix
that, and remove code duplication for the logger config. One way should be
to not touch/configure anything if the logger is already created while
calling SolveCpModel() and call a common config function from here or from
inside Solve()? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a09ec441521b625aa6d45620f6b26d781 "<a class="el" href="namespaceoperations__research.html#a09ec441521b625aa6d45620f6b26d781">operations_research::GlopToMPSolverResultStatus</a>" (glop::ProblemStatus s)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000749 (user): We could argue that it is infeasible to find the optimal of
an unbounded problem. So it might just be simpler to completely get rid
of the MpSolver::UNBOUNDED status that seems to never be used
programmatically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLPKInterface Member \_internalref classoperations__research_1_1GLPKInterface#a2a1e883d9de9f8d855a561dea457c8a4 "<a class="el" href="classoperations__research_1_1GLPKInterface.html#a2a1e883d9de9f8d855a561dea457c8a4">operations_research::GLPKInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000750 (user): support MIP.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#a42c71ed3bac0344dfe9964839806566b "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#a42c71ed3bac0344dfe9964839806566b">operations_research::GraphSymmetryFinder::FindSymmetries</a>" (std::vector&lt; int &gt; *node_equivalence_classes_io, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators, std::vector&lt; int &gt; *factorized_automorphism_group_size, TimeLimit *time_limit=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000011 (user): experiment with, and briefly describe the results of various
algorithms for picking the invariant node:
- random selection
- highest/lowest degree first
- enumerate by part index; or by part size
- etc. 
 &lt;p&gt; \anchor _todo000012 (user): better elect the representative of each equivalence class
in order to reduce the permutation support down the line
&lt;p&gt; \anchor _todo000013 &lt;p&gt; \anchor _todo000014 (user): Don't build a list; but instead use direct, inline iteration
on the representatives in the while() loop below, to benefit from the
incremental merging of the equivalence classes. 
 &lt;p&gt; \anchor _todo000015 (user): better, more complete explanation. 
 &lt;p&gt; \anchor _todo000026 (user): verify the minimality in unit tests.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#af670a8f7f325e3a7431f2723c52ec25d "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#af670a8f7f325e3a7431f2723c52ec25d">operations_research::GraphSymmetryFinder::GraphSymmetryFinder</a>" (const Graph &amp;graph, bool is_undirected)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000025 (user): support multi-arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#a70544105d8f21edcbed63fdd7f6d34ab "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#a70544105d8f21edcbed63fdd7f6d34ab">operations_research::GraphSymmetryFinder::RecursivelyRefinePartitionByAdjacency</a>" (int first_unrefined_part_index, DynamicPartition *partition)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000010 (user): We are really imprecise in our counting, but it is fine. We
just need a way to enforce a deterministic limit on the computation effort. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GreedySolutionGenerator Member \_internalref classoperations__research_1_1GreedySolutionGenerator#a0317564caf6b4d3d860bb635ff02c56e "<a class="el" href="classoperations__research_1_1GreedySolutionGenerator.html#ab50373b232711b27f49e7802c206d581" title="GreedySolutionGenerator.">operations_research::GreedySolutionGenerator::NextSolution</a>" (const std::vector&lt; SubsetIndex &gt; &amp;focus, const SubsetCostVector &amp;costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000039 (user): research more about the best value for Arity. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GreedySolutionGenerator Member \_internalref classoperations__research_1_1GreedySolutionGenerator#ab50373b232711b27f49e7802c206d581 "<a class="el" href="classoperations__research_1_1GreedySolutionGenerator.html#ab50373b232711b27f49e7802c206d581" title="GreedySolutionGenerator.">operations_research::GreedySolutionGenerator::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000048 (user): Add time-outs and exit with a partial solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipConstraintHandlerContext Class \_internalref classoperations__research_1_1GScipConstraintHandlerContext "<a class="el" href="classoperations__research_1_1GScipConstraintHandlerContext.html">operations_research::GScipConstraintHandlerContext</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000724 (user): Add support for branching. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a8fbf8182ca5ad94ee75198ac1885d798 "<a class="el" href="namespaceoperations__research.html#a8fbf8182ca5ad94ee75198ac1885d798">operations_research::GScipCreateMaximum</a>" (GScip *gscip, const GScipLinearExpr &amp;resultant, const std::vector&lt; GScipLinearExpr &gt; &amp;terms, absl::string_view name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000728 (user): it may be better to write this in terms of the disjuntive
constraint, we need to support disjunctions in gscip.h to do this.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipEventHandler Member \_internalref classoperations__research_1_1GScipEventHandler#a55733bd35aafd3ae06df04760d7fe05d "<a class="el" href="classoperations__research_1_1GScipEventHandler.html#a55733bd35aafd3ae06df04760d7fe05d">operations_research::GScipEventHandler::CatchEvent</a>" (SCIP_EVENTTYPE event_type)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000726 (user): Support Var and Row events.&lt;p&gt; \anchor _todo000727 (user): Support registering events in the EVENTINITSOL
callback, which would cause them to be trapped only after presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipLinearExpr Struct \_internalref structoperations__research_1_1GScipLinearExpr "<a class="el" href="structoperations__research_1_1GScipLinearExpr.html">operations_research::GScipLinearExpr</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000730 (user): delete this type and the methods below, use a generic version
templated on the variable type that supports operator overloads. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GuidedTabuSearch Member \_internalref classoperations__research_1_1GuidedTabuSearch#a3b432dccc848e7c957cfe8e4ebb3919a "<a class="el" href="classoperations__research_1_1GuidedTabuSearch.html#ae9e079ba191daebeff738fa832239443">operations_research::GuidedTabuSearch::NextSolution</a>" (const std::vector&lt; SubsetIndex &gt; &amp;focus, int num_iterations)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000040 (user): make the cost computation incremental.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GuidedTabuSearch Member \_internalref classoperations__research_1_1GuidedTabuSearch#a276460a461462ece00e2b69a4ba0cc75 "<a class="el" href="classoperations__research_1_1GuidedTabuSearch.html#a276460a461462ece00e2b69a4ba0cc75">operations_research::GuidedTabuSearch::SetLagrangianFactor</a>" (double factor)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000051 (user): re-introduce this is the code. It was used to favor
subsets with the same marginal costs but that would cover more elements.
But first, see if it makes sense to compute it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a47ea0f16d10d18c841917b6ab3695094 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a47ea0f16d10d18c841917b6ab3695094" title="Clears a constraint from all its terms.">operations_research::GurobiInterface::ClearConstraint</a>" (MPConstraint *constraint) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000755 (user): this is difficult to make incremental, like
SetConstraintBounds(), because of the auxiliary Gurobi variables that
range constraints introduce. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a80f01ad50450397a74e29c3db67ff69c "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a80f01ad50450397a74e29c3db67ff69c">operations_research::GurobiInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000758 (user): Not yet working.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#abdc377748278a3c5c35a847bfd146a31 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#abdc377748278a3c5c35a847bfd146a31" title="Iterates through the solutions in Gurobi&#39;s solution pool.">operations_research::GurobiInterface::NextSolution</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000757 (user): This reset may not be necessary, investigate.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a7862478121ae29647bf0a12ff9ef5ed7 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a7862478121ae29647bf0a12ff9ef5ed7" title="---— Model modifications and extraction --—">operations_research::GurobiInterface::Reset</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000752 - b/328604189: Fix logging issue upstream, switch to a different API
for copying parameters, or avoid calling Reset() in more places. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a3151b55e2c525025b89ce0c01cdf52be "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a3151b55e2c525025b89ce0c01cdf52be" title="Changes a coefficient in a constraint.">operations_research::GurobiInterface::SetCoefficient</a>" (MPConstraint *constraint, const MPVariable *variable, double new_value, double old_value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000754 (user): investigate if this has bad performance.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a937c9e7503e0bc746f8fa40c7591f16a "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a937c9e7503e0bc746f8fa40c7591f16a" title="Modify bounds of an extracted variable.">operations_research::GurobiInterface::SetConstraintBounds</a>" (int row_index, double lb, double ub) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000753 (user): this is nontrivial to make incremental:
1. Make sure it is a linear constraint (not an indicator or indicator
   range constraint).
2. Check if the sense of the constraint changes. If it was previously a
   range constraint, we can do nothing, and if it becomes a range
   constraint, we can do nothing. We could support range constraints if
   we tracked the auxiliary variable that is added with range
   constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a3fdaaef4033cbc2f6e0ef07ade784682 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a3fdaaef4033cbc2f6e0ef07ade784682">operations_research::GurobiInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000756 (user): We could introduce our own "infeasible or unbounded" status. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HamiltonianPathSolver Member \_internalref classoperations__research_1_1HamiltonianPathSolver#a3f13afbdf8f0e7c748ba80de7859e803 "<a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html#a3f13afbdf8f0e7c748ba80de7859e803">operations_research::HamiltonianPathSolver&lt; CostType, CostFunction &gt;::Integer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000641 (user): remove this limitation by using pruning techniques. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aee1401375b23909949cce272a3b787db "<a class="el" href="namespaceoperations__research.html#aee1401375b23909949cce272a3b787db">operations_research::Hash1</a>" (uint64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000148 (user): use murmurhash. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HighsInterface Member \_internalref classoperations__research_1_1HighsInterface#aa0445eec4920c34b74fb03b837ff15b0 "<a class="el" href="classoperations__research_1_1HighsInterface.html#aa0445eec4920c34b74fb03b837ff15b0" title="Returns the basis status of a constraint.">operations_research::HighsInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000761 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HighsInterface Member \_internalref classoperations__research_1_1HighsInterface#a0b4fdd0d963276c0deca473d6b4b36a5 "<a class="el" href="classoperations__research_1_1HighsInterface.html#a0b4fdd0d963276c0deca473d6b4b36a5" title="Returns the basis status of a row.">operations_research::HighsInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000760 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HighsInterface Member \_internalref classoperations__research_1_1HighsInterface#a9423aab732ca4e92e3640bd534e92023 "<a class="el" href="classoperations__research_1_1HighsInterface.html#a9423aab732ca4e92e3640bd534e92023">operations_research::HighsInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000762 (user): Consider returning the SolveLog here, as it could be essential
for interpreting the PDLP solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a977d36998909629c22521663e46a33ce "<a class="el" href="namespaceoperations__research.html#a977d36998909629c22521663e46a33ce" title="Solve the input MIP model with the HIGHS solver.">operations_research::HighsSolveProto</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000790 (user): Set model name.
 &lt;p&gt; \anchor _todo000791 (user): Support variable names.
&lt;p&gt; \anchor _todo000792 &lt;p&gt; \anchor _todo000793 (user): Support hints. 
 &lt;p&gt; \anchor _todo000794 (user): Support constraint names.
 &lt;p&gt; \anchor _todo000795 (user): report feasible status.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::InsertionSequenceContainer Member \_internalref classoperations__research_1_1InsertionSequenceContainer#a2d8c1748584bee64a6e1963605863c6b "<a class="el" href="classoperations__research_1_1InsertionSequenceContainer.html#a2d8c1748584bee64a6e1963605863c6b">operations_research::InsertionSequenceContainer::RemoveIf</a>" (const std::function&lt; bool(const InsertionSequence &amp;)&gt; &amp;p)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000368 (user): Benchmark this against std::swap().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::InsertionSequenceContainer Member \_internalref classoperations__research_1_1InsertionSequenceContainer#a7d4b83eb22546e3c1079283001dfe0d3 "<a class="el" href="classoperations__research_1_1InsertionSequenceContainer.html#a7d4b83eb22546e3c1079283001dfe0d3">operations_research::InsertionSequenceContainer::Sort</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000369 (user): benchmark this against other ways to get insertion
sequence in order, for instance sorting by index, separating {cost, index},
making a heap. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntegerPriorityQueue Member \_internalref classoperations__research_1_1IntegerPriorityQueue#a660816e2b5398fc18dd92a58327f630c "<a class="el" href="classoperations__research_1_1IntegerPriorityQueue.html#a660816e2b5398fc18dd92a58327f630c">operations_research::IntegerPriorityQueue&lt; Element, Compare &gt;::Clear</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002412 (user): we could make this sparse if it is needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::internal Namespace \_internalref namespaceoperations__research_1_1internal "<a class="el" href="namespaceoperations__research_1_1internal.html" title="End of the interface. Below is the implementation.">operations_research::internal</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000034 (user): Support arbitrary types with an int() or other numerical getter.
 &lt;p&gt; &lt;p&gt;(user): Support the user providing already-allocated memory buffers
             for the radix counts and/or for the temporary vector&lt;T&gt; copy. 
 &lt;p&gt; \anchor _todo000648 (user): introduce an enum to choose the algorithm. It's useless as
long as this file only provides Yen. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVar Member \_internalref classoperations__research_1_1IntVar#af3c6b509b9279db09301192b57dfb3cd "<a class="el" href="classoperations__research_1_1IntVar.html#af3c6b509b9279db09301192b57dfb3cd" title="This method remove the values from the domain of the variable.">operations_research::IntVar::RemoveValues</a>" (const std::vector&lt; int64_t &gt; &amp;values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000181 (user): Check and maybe inline this code.
 &lt;p&gt; \anchor _todo000182 (user) : Sort values! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVar Member \_internalref classoperations__research_1_1IntVar#a3b3b2ee0dc78430a3008c0894531196f "<a class="el" href="classoperations__research_1_1IntVar.html#a3b3b2ee0dc78430a3008c0894531196f" title="This method intersects the current domain with the values in the array.">operations_research::IntVar::SetValues</a>" (const std::vector&lt; int64_t &gt; &amp;values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000183 (user): use a clean and safe SortedUniqueCopy() class
that uses a global, static shared (and locked) storage.
&lt;p&gt; \anchor _todo000184 &lt;p&gt; \anchor _todo000185 (user): [optional] consider porting
STLSortAndRemoveDuplicates from ortools/base/stl_util.h to the
existing base/stl_util.h and using it here.
&lt;p&gt; \anchor _todo000186 &lt;p&gt; \anchor _todo000187 (user): We could filter out values not in the var. 
 &lt;p&gt; \anchor _todo000188 (user) : We could find the first position &gt;= vmin by dichotomy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVarFilteredDecisionBuilder Class \_internalref classoperations__research_1_1IntVarFilteredDecisionBuilder "<a class="el" href="classoperations__research_1_1IntVarFilteredDecisionBuilder.html">operations_research::IntVarFilteredDecisionBuilder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000366 (user): Eventually move this to the core CP solver library
when the code is mature enough. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVarLocalSearchOperator Member \_internalref classoperations__research_1_1IntVarLocalSearchOperator#ac8bc688def85b27b6aa66e1f099050a4 "<a class="el" href="classoperations__research_1_1IntVarLocalSearchOperator.html#ac8bc688def85b27b6aa66e1f099050a4">operations_research::IntVarLocalSearchOperator::MakeOneNeighbor</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000150 (user): make it pure virtual, implies porting all apps overriding
MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator. 
 &lt;p&gt; \anchor _todo000211 (user): Make this a pure virtual.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackAssignment Struct \_internalref structoperations__research_1_1KnapsackAssignment "<a class="el" href="structoperations__research_1_1KnapsackAssignment.html">operations_research::KnapsackAssignment</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000031 (user): Add a new propagator class for conflict constraint.
 &lt;p&gt; &lt;p&gt;(user): Add a new propagator class used as a guide when the problem has
several dimensions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackBruteForceSolver Member \_internalref classoperations__research_1_1KnapsackBruteForceSolver#a0b4c315873262155800b2645fdab0535 "<a class="el" href="classoperations__research_1_1KnapsackBruteForceSolver.html#a0b4c315873262155800b2645fdab0535" title="Initializes the solver and enters the problem to be solved.">operations_research::KnapsackBruteForceSolver::Init</a>" (const std::vector&lt; int64_t &gt; &amp;profits, const std::vector&lt; std::vector&lt; int64_t &gt; &gt; &amp;weights, const std::vector&lt; int64_t &gt; &amp;capacities) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000030 (user): Implement multi-dimensional brute force solver.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackCapacityPropagator Member \_internalref classoperations__research_1_1KnapsackCapacityPropagator#af1d7d1e175e652c64962af490ab42247 "<a class="el" href="classoperations__research_1_1KnapsackCapacityPropagator.html#af1d7d1e175e652c64962af490ab42247">operations_research::KnapsackCapacityPropagator::ComputeProfitBounds</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000029 (user): Make it more incremental, by saving the break item in a
search node for instance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackGenericSolver Class \_internalref classoperations__research_1_1KnapsackGenericSolver "<a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html">operations_research::KnapsackGenericSolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000032 (user): In the case of a multi-dimensional knapsack problem, implement
an aggregated propagator to combine all dimensions and give a better guide
to select the next item (see, for instance, Dobson's aggregated efficiency). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#ac5b423c249b7d295b22cd367d60a915a "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#ac5b423c249b7d295b22cd367d60a915a" title="Returns the basis status of a constraint.">operations_research::KnapsackInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000766 (user): set properly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#a91cb6e2a4e0c037e5ce12887e13d5a11 "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#a91cb6e2a4e0c037e5ce12887e13d5a11" title="Returns the basis status of a row.">operations_research::KnapsackInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000765 (user): set properly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#ad8e2065e33ed1870e473b6f296a93cba "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#ad8e2065e33ed1870e473b6f296a93cba" title="--— Solve --—">operations_research::KnapsackInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000764 (user): Refine Analysis of the model to choose better solvers.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KShortestPaths Member \_internalref structoperations__research_1_1KShortestPaths#a48077b0ff26a88c2df6d985eb2a8b6f7 "<a class="el" href="structoperations__research_1_1KShortestPaths.html#a48077b0ff26a88c2df6d985eb2a8b6f7">operations_research::KShortestPaths::paths</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000652 (user): what about vectors of arcs? That might be faster
(potentially, add a function to transform it into a vector of nodes if the
user really needs it). It would also have the nice benefit of removing the
need for &lt;tt&gt;distances&lt;/tt&gt; (compute it on the fly), with a reference to the graph
and the costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KShortestPathsOnDagWrapper Member \_internalref classoperations__research_1_1KShortestPathsOnDagWrapper#a2ceb0df92d0ba23cb3496ef96475dfa3 "<a class="el" href="classoperations__research_1_1KShortestPathsOnDagWrapper.html#a2ceb0df92d0ba23cb3496ef96475dfa3">operations_research::KShortestPathsOnDagWrapper&lt; GraphType &gt;::KShortestPathsOnDagWrapper</a>" (const GraphType *graph, const std::vector&lt; double &gt; *arc_lengths, absl::Span&lt; const NodeIndex &gt; topological_order, int path_count)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000616 (b/332475713): Optimize if reverse graph is already provided in
&lt;tt&gt;GraphType&lt;/tt&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LatticeMemoryManager Member \_internalref classoperations__research_1_1LatticeMemoryManager#af1eb6109d2fbc58a4f9709fc12472100 "<a class="el" href="classoperations__research_1_1LatticeMemoryManager.html#af1eb6109d2fbc58a4f9709fc12472100">operations_research::LatticeMemoryManager&lt; Set, CostType &gt;::BaseOffset</a>" (int card, Set s) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000635 (user): Evaluate the interest of the above.
There are 'card' f(set, j) to store. That is why we need to multiply
local_offset by card before adding it to the corresponding base_offset_. 
 &lt;p&gt; \anchor _todo000640 (user): Investigate how to compute BaseOffset(card - 1, s \ { n })
from BaseOffset(card, n) to speed up the DP iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LightPairRelocateOperator Class \_internalref classoperations__research_1_1LightPairRelocateOperator "<a class="el" href="classoperations__research_1_1LightPairRelocateOperator.html">operations_research::LightPairRelocateOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000339 (user): Add a version which inserts the first node before the other
pair's first node; there are many redundant neighbors if done blindly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LightPairRelocateOperator Member \_internalref classoperations__research_1_1LightPairRelocateOperator#ab5a8f9eadcc60ebb142f301ad0206f45 "<a class="el" href="classoperations__research_1_1LightPairRelocateOperator.html#ab5a8f9eadcc60ebb142f301ad0206f45">operations_research::LightPairRelocateOperator::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000332 (user): extend to relocating before the start of sub-tours (when
all pairs have been matched). 
 &lt;p&gt; \anchor _todo000333 (user): Add support for lifo for neighbor-based move.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LinearExpr Member \_internalref classoperations__research_1_1LinearExpr#ac387e7f248b39ad0c52ad355fa646696 "<a class="el" href="classoperations__research_1_1LinearExpr.html#ac387e7f248b39ad0c52ad355fa646696">operations_research::LinearExpr::ToString</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000767 (user): support optionally cropping long strings.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalCheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1LocalCheapestInsertionFilteredHeuristic#a17ef6d7c3d54257ff4089b5d131a65e3 "<a class="el" href="classoperations__research_1_1LocalCheapestInsertionFilteredHeuristic.html#a17ef6d7c3d54257ff4089b5d131a65e3" title="Takes ownership of evaluator.">operations_research::LocalCheapestInsertionFilteredHeuristic::LocalCheapestInsertionFilteredHeuristic</a>" (RoutingModel *model, std::function&lt; bool()&gt; stop_search, std::function&lt; int64_t(int64_t, int64_t, int64_t)&gt; evaluator, RoutingSearchParameters::PairInsertionStrategy pair_insertion_strategy, LocalSearchFilterManager *filter_manager, BinCapacities *bin_capacities=nullptr, std::function&lt; bool(const std::vector&lt; RoutingModel::VariableValuePair &gt; &amp;, std::vector&lt; RoutingModel::VariableValuePair &gt; *)&gt; optimize_on_insertion=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000355 (user): Add support for penalty costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalDimensionCumulOptimizer Member \_internalref classoperations__research_1_1LocalDimensionCumulOptimizer#a30f6536c9b12eb7d0c6bcba75c50b158 "<a class="el" href="classoperations__research_1_1LocalDimensionCumulOptimizer.html#a30f6536c9b12eb7d0c6bcba75c50b158" title="LocalDimensionCumulOptimizer.">operations_research::LocalDimensionCumulOptimizer::LocalDimensionCumulOptimizer</a>" (const RoutingDimension *dimension, RoutingSearchParameters::SchedulingSolver solver_type)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000322 (user): Instead of passing false, detect if the relaxation
will always violate the MIPL constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearch Member \_internalref classoperations__research_1_1LocalSearch#a60a6c0d04aae31557a3f80a43e578c1d "<a class="el" href="classoperations__research_1_1LocalSearch.html#a5e713c214f20050381b848770f5fc7a4">operations_research::LocalSearch::LocalSearch</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IntVar *objective, SolutionPool *pool, DecisionBuilder *first_solution, LocalSearchOperator *ls_operator, DecisionBuilder *sub_decision_builder, RegularLimit *limit, LocalSearchFilterManager *filter_manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000235 (user): find a way to not have to pass vars here: redundant with
variables in operators 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearch Member \_internalref classoperations__research_1_1LocalSearch#aad8272c1b2ace102d8ee023e3dbbc92e "<a class="el" href="classoperations__research_1_1LocalSearch.html#aad8272c1b2ace102d8ee023e3dbbc92e">operations_research::LocalSearch::Next</a>" (Solver *solver) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000230 (user): abstract this from the local search part
 &lt;p&gt; &lt;p&gt;(user): handle the case where the tree depth is not enough to hold
               all solutions. 
 &lt;p&gt; \anchor _todo000231 (user): Find a way to make this balancing invisible to the
user (no increase in branch or fail counts for instance). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchFilter Member \_internalref classoperations__research_1_1LocalSearchFilter#a7ba0d3a0fab70da68c44fcc603b29bc9 "<a class="el" href="classoperations__research_1_1LocalSearchFilter.html#a7ba0d3a0fab70da68c44fcc603b29bc9">operations_research::LocalSearchFilter::Accept</a>" (const Assignment *delta, const Assignment *deltadelta, int64_t objective_min, int64_t objective_max)=0&lt;/dt&gt;&lt;dd&gt; \anchor _todo000154 (user): Remove arguments when there are no more need for those. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchFilterManager Member \_internalref classoperations__research_1_1LocalSearchFilterManager#af14f814b5f03c25c7a5c34ea2e850931 "<a class="el" href="classoperations__research_1_1LocalSearchFilterManager.html#af14f814b5f03c25c7a5c34ea2e850931">operations_research::LocalSearchFilterManager::Accept</a>" (LocalSearchMonitor *monitor, const Assignment *delta, const Assignment *deltadelta, int64_t objective_min, int64_t objective_max)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000221 (user): the behaviour of Accept relies on the initial order of
filters having at most one filter with negative objective values,
this could be fixed by having filters return their general bounds. 
 &lt;p&gt; \anchor _todo000222 (user): handle objective min.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchMonitor Member \_internalref classoperations__research_1_1LocalSearchMonitor#a0c4974eabff96027f2732bd11aa6acb8 "<a class="el" href="classoperations__research_1_1LocalSearchMonitor.html#a0c4974eabff96027f2732bd11aa6acb8" title="-------— Local Search Monitor --------—">operations_research::LocalSearchMonitor::LocalSearchMonitor</a>" (Solver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000155 (user): Add monitoring of local search filters.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchOperator Class \_internalref classoperations__research_1_1LocalSearchOperator "<a class="el" href="classoperations__research_1_1LocalSearchOperator.html">operations_research::LocalSearchOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000149 (user): rename Start to Synchronize ?
 &lt;p&gt; &lt;p&gt;(user): decouple the iterating from the defining of a neighbor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchState Member \_internalref classoperations__research_1_1LocalSearchState#ab21fa79fdab637a71137bfb392c3bc42 "<a class="el" href="classoperations__research_1_1LocalSearchState.html#ab21fa79fdab637a71137bfb392c3bc42">operations_research::LocalSearchState::Commit</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000220 (user): When the class has more users, find a threshold ratio of
saved/total domains under which a sparse clear would be more efficient
for both Commit() and Revert(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocationContainer Member \_internalref classoperations__research_1_1LocationContainer#ad936b94007fe596c6ac61668da043262 "<a class="el" href="classoperations__research_1_1LocationContainer.html#ad936b94007fe596c6ac61668da043262">operations_research::LocationContainer::SameLocationFromIndex</a>" (int64_t node1, int64_t node2) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001041 (user): Fetch proper indices from routing model. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakeActiveOperator Member \_internalref classoperations__research_1_1MakeActiveOperator#a7600694afcf25f72395f32bfea5b0b6d "<a class="el" href="classoperations__research_1_1MakeActiveOperator.html#a7600694afcf25f72395f32bfea5b0b6d">operations_research::MakeActiveOperator::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000214 (user): Add support for neighbors of inactive nodes; would require
having a version without base nodes (probably not a PathOperator). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakePairActiveOperator Class \_internalref classoperations__research_1_1MakePairActiveOperator "<a class="el" href="classoperations__research_1_1MakePairActiveOperator.html">operations_research::MakePairActiveOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000338 (user): Add option to prune neighbords where the order of node pairs
               is violated (ie precedence between pickup and delivery nodes).
 &lt;p&gt; &lt;p&gt;(user): Move this to local_search.cc if it's generic enough.
 &lt;p&gt; &lt;p&gt;(user): Detect pairs automatically by parsing the constraint model;
               we could then get rid of the pair API in the RoutingModel
               class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakeRelocateNeighborsOperator Class \_internalref classoperations__research_1_1MakeRelocateNeighborsOperator "<a class="el" href="classoperations__research_1_1MakeRelocateNeighborsOperator.html">operations_research::MakeRelocateNeighborsOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000336 (user): Consider merging with standard Relocate in local_search.cc. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakeRelocateNeighborsOperator Member \_internalref classoperations__research_1_1MakeRelocateNeighborsOperator#a68fcef23cc239d8bc9f7864595a05d5e "<a class="el" href="classoperations__research_1_1MakeRelocateNeighborsOperator.html#a68fcef23cc239d8bc9f7864595a05d5e">operations_research::MakeRelocateNeighborsOperator::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000331 (user): Add a parameter to either return false or break here,
depending if we want to permutate nodes within the same chain. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Namespace \_internalref namespaceoperations__research_1_1math__opt "<a class="el" href="namespaceoperations__research_1_1math__opt.html" title="An object oriented wrapper for quadratic constraints in ModelStorage.">operations_research::math_opt</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000940 (b/178702980): this should not be needed
IWYU pragma: no_include &lt;type_traits&gt; 
 &lt;p&gt; \anchor _todo000977 (b/272767311): initial basis, more precise returned basis.
 * Starting solution
 *  &lt;p&gt; &lt;p&gt;(b/271104776): Returning rays 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ab2cf3d362a53b88af5478096e7b70534 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ab2cf3d362a53b88af5478096e7b70534" title="The entire model is an IIS.">operations_research::math_opt::≤</a>" (variable bounds) TEST_P(InfeasibleSubsystemTest&lt;/dt&gt;&lt;dd&gt; \anchor _todo000926 (b/227217735): Test ranged quadratic constraints when supported.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ae492beecf00c5bcfab49f0eb64bd5467 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ae492beecf00c5bcfab49f0eb64bd5467">operations_research::math_opt::ApplyAllFilters</a>" (const ModelSolveParametersProto &amp;model_solve_params, SolutionProto &amp;solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000894 (b/261603235): this function is not very efficient, decide if this
matters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#abd2e26542d0c64cb9bdb653e943cd892 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#abd2e26542d0c64cb9bdb653e943cd892">operations_research::math_opt::CheckIdsSubset</a>" (absl::Span&lt; const int64_t &gt; ids, const IdNameBiMap &amp;universe, std::optional&lt; int64_t &gt; upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001010 (b/232526223): try merge this with the CheckIdsSubset overload below, or
at least have one call the other. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a614c1a306a138f7593f4ae84dbf034c9 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a614c1a306a138f7593f4ae84dbf034c9">operations_research::math_opt::FeasibleTerminationProto</a>" (const bool is_maximize, const LimitProto limit, const double primal_objective, const std::optional&lt; double &gt; optional_dual_objective, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000897 (b/290359402): Consider improving to require a finite dual bound when
dual feasible solutions are returned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ad41bc1edd376b9ab7c3182d9a7b35e87 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ad41bc1edd376b9ab7c3182d9a7b35e87">operations_research::math_opt::FilterSparseVector</a>" (const SparseDoubleVectorProto &amp;input, const SparseVectorFilterProto &amp;filter)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000893 (b/261603235): this function is not very efficient, decide if this
matters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a635b90e2d284268536fc4bd2a4ce2ac4 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a635b90e2d284268536fc4bd2a4ce2ac4">operations_research::math_opt::GetObjectiveBounds</a>" (const SolveResultProto &amp;solve_result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000891 (b/290091715): Remove once solve_stats.best_primal/dual_bound is removed
and we know termination.objective_bounds will always be present. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a5e3e49ddac3e4cb09a02f02e4fe83019 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a5e3e49ddac3e4cb09a02f02e4fe83019">operations_research::math_opt::GetProblemStatus</a>" (const SolveResultProto &amp;solve_result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000892 (b/290091715): Remove once solve_stats.problem_status is removed and we
know termination.problem_status will always be present. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GlpkSolver Member \_internalref classoperations__research_1_1math__opt_1_1GlpkSolver#a862eb62a5ed02916d9ae0ddabe46ac08 "<a class="el" href="classoperations__research_1_1math__opt_1_1GlpkSolver.html#a862eb62a5ed02916d9ae0ddabe46ac08">operations_research::math_opt::GlpkSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000946 (b/187027049): glp_intopt with presolve off requires an optional
solution of the relaxed problem. Here we simply always enable pre-solve
but we should support disabling the presolve and call glp_simplex() in
that case. 
 &lt;p&gt; \anchor _todo000947 (b/259557110): the emptiness is tested by glp_interior() &lt;em&gt;after&lt;/em&gt;
some pre-processing (including removing fixed variables). The current
IsEmpty() is thus not good enough to deal with all cases. 
 &lt;p&gt; \anchor _todo000948 (b/187027049): add solver specific parameters for
glp_iptcp.ord_alg. 
 &lt;p&gt; \anchor _todo000949 (b/187027049): add option to use glp_exact().
 &lt;p&gt; \anchor _todo000950 (b/187027049): compute the dual value when the dual is feasible (or
problem optimal for interior point) based on the bounds and the dual values
for LPs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GScipSolver Member \_internalref classoperations__research_1_1math__opt_1_1GScipSolver#a91f57e875b852057eeaf6eeb837d1613 "<a class="el" href="classoperations__research_1_1math__opt_1_1GScipSolver.html#a91f57e875b852057eeaf6eeb837d1613">operations_research::math_opt::GScipSolver::Update</a>" (const ModelUpdateProto &amp;model_update) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000958 (b/215722113): maybe we could use SCIPaddCoefLinear() for sub-matrix 1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GurobiSolver Member \_internalref classoperations__research_1_1math__opt_1_1GurobiSolver#af25c8f69567b57e9e04f737af5937e84 "<a class="el" href="classoperations__research_1_1math__opt_1_1GurobiSolver.html#af25c8f69567b57e9e04f737af5937e84">operations_research::math_opt::GurobiSolver::ComputeInfeasibleSubsystem</a>" (const SolveParametersProto &amp;parameters, MessageCallback message_cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000974 (b/277339044): Remove code duplication with GurobiSolver::Solve().
 &lt;p&gt; \anchor _todo000975 (b/277246682): ensure that resetting parameters does not degrade
incrementalism performance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GurobiSolver Member \_internalref classoperations__research_1_1math__opt_1_1GurobiSolver#aa521c1122a7faae79b63abea4a039cd2 "<a class="el" href="classoperations__research_1_1math__opt_1_1GurobiSolver.html#aa521c1122a7faae79b63abea4a039cd2">operations_research::math_opt::GurobiSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000973 (b/277246682): ensure that resetting parameters does not degrade
incrementalism performance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::HighsSolver Member \_internalref classoperations__research_1_1math__opt_1_1HighsSolver#a2ae5ff0de74ce55a8dc383175021d11b "<a class="el" href="classoperations__research_1_1math__opt_1_1HighsSolver.html#a2ae5ff0de74ce55a8dc383175021d11b">operations_research::math_opt::HighsSolver::New</a>" (const ModelProto &amp;model, const InitArgs &amp;init_args)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000980 (b/271595607): once HiGHS is updated, check if the unrounded bounds
cross instead. 
 &lt;p&gt; \anchor _todo000981 (b/271595607): once HiGHS is updated, pass the original bound, not
the rounded bound. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::HighsSolver Member \_internalref classoperations__research_1_1math__opt_1_1HighsSolver#a379b28def41c16cfc6c404dac890ddbe "<a class="el" href="classoperations__research_1_1math__opt_1_1HighsSolver.html#a379b28def41c16cfc6c404dac890ddbe">operations_research::math_opt::HighsSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000982 (b/271595607): delete this code once we upgrade HiGHS, if HiGHS does
return a proper infeasibility status for models with empty integer bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal Member \_internalref namespaceoperations__research_1_1math__opt_1_1internal#aa5b5865fba481a062135fc78e632b85c "<a class="el" href="namespaceoperations__research_1_1math__opt_1_1internal.html#aa5b5865fba481a062135fc78e632b85c">operations_research::math_opt::internal::CheckIdsRangeAndStrictlyIncreasing2</a>" (absl::Span&lt; const int64_t &gt; ids)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000899 (b/232526223): this is an exact copy of
CheckIdsRangeAndStrictlyIncreasing from ids_validator.h, find a way to share
the code.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::InvalidInputTest Class \_internalref classoperations__research_1_1math__opt_1_1InvalidInputTest "<a class="el" href="classoperations__research_1_1math__opt_1_1InvalidInputTest.html">operations_research::math_opt::InvalidInputTest</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000927 (b/172553545): this test should not be repeated for each solver since it
  tests that the Solver class validates the model before calling the
  interface. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af9843a1d7731647c94c6a7ae14cdd2da "<a class="el" href="namespaceoperations__research_1_1math__opt.html#af9843a1d7731647c94c6a7ae14cdd2da">operations_research::math_opt::IsOptimal</a>" (const std::optional&lt; double &gt; expected_primal_objective, const double tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000904 (b/309658404): Note the bounds should be at least finite once we validate
this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ac307abe62a9d26ff0eac456704d950b6 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a4c0703c4f33214bf68365dee80418ca3">operations_research::math_opt::LimitTerminationProto</a>" (LimitProto limit, const double primal_objective, const double dual_objective, const bool claim_dual_feasible_solution_exists, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000898 (b/290359402): Consider improving to require a finite dual bound when
dual feasible solutions are returned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::LinearExpression Class \_internalref classoperations__research_1_1math__opt_1_1LinearExpression "<a class="el" href="classoperations__research_1_1math__opt_1_1LinearExpression.html">operations_research::math_opt::LinearExpression</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000919 (b/169415098): add a function to remove zero terms.
 &lt;p&gt; &lt;p&gt;(b/169415834): study if exact zeros should be automatically removed.
 &lt;p&gt; &lt;p&gt;(b/169415103): add tests that some expressions don't compile. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::LpIncompleteSolveTestParams Struct \_internalref structoperations__research_1_1math__opt_1_1LpIncompleteSolveTestParams "<a class="el" href="structoperations__research_1_1math__opt_1_1LpIncompleteSolveTestParams.html" title="Parameters for the LpIncompleteSolveTest suite below.">operations_research::math_opt::LpIncompleteSolveTestParams</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000932 (b/195295177): Consider splitting LpIncompleteSolveTest into simplex and
non-simplex tests to avoid repetition and need to input irrelevant bools from
LpIncompleteSolveTestParams when instantiating tests. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a5d8c9048c51c1bc6685751a7cb8514fe "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a5d8c9048c51c1bc6685751a7cb8514fe">operations_research::math_opt::MathOptModelToMPModelProto</a>" (const ::operations_research::math_opt::ModelProto &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000921 (user): use the constraint iterator from scip_solver.cc here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#a06cd12d3df5d04b34fde1050692bc46a "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#a06cd12d3df5d04b34fde1050692bc46a">operations_research::math_opt::Model::storage</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000908 (user): expose a way to efficiently iterate through the nonzeros of
the linear constraint matrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#a737b42a14db864ac3afa891ecb212688 "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#a737b42a14db864ac3afa891ecb212688">operations_research::math_opt::Model::ValidateExistingLinearConstraintOfThisModel</a>" (LinearConstraint linear_constraint) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000907 (b/239810718): use &lt;&lt; for LinearConstraint once it does not CHECK.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#ae3a2f02a80238331fcdb90fc410682df "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#ae3a2f02a80238331fcdb90fc410682df" title="-----------------------— Linear constraints ----------------------------—">operations_research::math_opt::Model::ValidateExistingVariableOfThisModel</a>" (Variable variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000906 (b/239810718): use &lt;&lt; for Variable once it does not CHECK.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::ModelSolveParameters Member \_internalref structoperations__research_1_1math__opt_1_1ModelSolveParameters#a7f2865236a76bb6d14d3ac4accae433c "<a class="el" href="structoperations__research_1_1math__opt_1_1ModelSolveParameters.html#a7f2865236a76bb6d14d3ac4accae433c">operations_research::math_opt::ModelSolveParameters::Proto</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000909 : b/315974557 - Return an error if a RepeatedField is too long.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#afa94d25b431c19de213fd01276bda3bf "<a class="el" href="namespaceoperations__research_1_1math__opt.html#afa94d25b431c19de213fd01276bda3bf">operations_research::math_opt::MoveVariablesToTheirBestFeasibleValue</a>" (const Model &amp;model, const VariableMap&lt; double &gt; &amp;input_solution, absl::Span&lt; const Variable &gt; variables, const MoveVariablesToTheirBestFeasibleValueOptions &amp;options)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000922 (b/193121090): here we build the proto as the APIs of MathOpt only
works with the proto and can't use the C++ Model (or ModelStorage). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a647b24c008c0cab90f59e848a507c244 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a647b24c008c0cab90f59e848a507c244">operations_research::math_opt::NoSolutionFoundTerminationProto</a>" (const bool is_maximize, const LimitProto limit, const std::optional&lt; double &gt; optional_dual_objective, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000896 (b/290359402): Consider improving to require a finite dual bound when
dual feasible solutions are returned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::ObjectiveStorage::Diff Member \_internalref structoperations__research_1_1math__opt_1_1ObjectiveStorage_1_1Diff#a269e380e623c1a8a281290585bb0c24f "<a class="el" href="structoperations__research_1_1math__opt_1_1ObjectiveStorage_1_1Diff.html#a269e380e623c1a8a281290585bb0c24f">operations_research::math_opt::ObjectiveStorage::Diff::objective_diffs</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000995 (b/259109678): Consider storing primary objective separately (like in
&lt;tt&gt;ObjectiveStorage&lt;/tt&gt;) if hashing is a noticeable bottleneck. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a529b5def5ea854858d5e3a6c094a0988 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const IndicatorConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000886 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af7ba8f15f41011f5b8109d7bef66511f "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const QuadraticConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000887 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a96a74dc7a0e6aa81c2279481c4c1e678 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const SecondOrderConeConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000888 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a1a9e610368627bfdb61a92bc85274327 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Sos1Constraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000889 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af810f3a175629e517744c9f265470b61 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Sos2Constraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000890 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a99d303a9027f99623639c132198aa097 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const LinearConstraint &amp;linear_constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000903 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a5db056654e1d14286315339c41c1bff0 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Objective &amp;objective)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000910 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ab1d61842701172037b05e011df664d90 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const LinearExpression &amp;expression)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000917 (b/169415597): improve linear expression format:
- make sure to quote the variable name so that we support: 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a9019e3ceb6908ea58dee5e0ea0e627f9 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const QuadraticExpression &amp;expr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000918 (b/169415597): improve quadratic expression formatting. See b/170991498
for desired improvements for LinearExpression streaming which are also
applicable here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ae8f450a61d6f3613fa723a717c3cbca3 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Variable &amp;variable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000920 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a3f1deb6f9bb763a7c2635992bec9dcf9 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a3f1deb6f9bb763a7c2635992bec9dcf9">operations_research::math_opt::OptimalTerminationProto</a>" (const double finite_primal_objective, const double dual_objective, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000895 (b/290359402): additionally require dual_objective to be finite. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::PdlpBridge Member \_internalref classoperations__research_1_1math__opt_1_1PdlpBridge#a5be3dbbc95b4b889956096613a822e40 "<a class="el" href="classoperations__research_1_1math__opt_1_1PdlpBridge.html#a5be3dbbc95b4b889956096613a822e40">operations_research::math_opt::PdlpBridge::PrimalVariablesToProto</a>" (const Eigen::VectorXd &amp;primal_values, const SparseVectorFilterProto &amp;variable_filter) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000991 (b/183616124): we need to support the inverse of these methods for
warm start. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SimpleMipTestParameters Member \_internalref structoperations__research_1_1math__opt_1_1SimpleMipTestParameters#ac01adb283c3825d2dc482c74306d2766 "<a class="el" href="structoperations__research_1_1math__opt_1_1SimpleMipTestParameters.html#ac01adb283c3825d2dc482c74306d2766">operations_research::math_opt::SimpleMipTestParameters::report_unboundness_correctly</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000938 (b/202159173): remove this when we start using the direct CP-SAT API
and thus will be able to get proper details. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Solver Member \_internalref classoperations__research_1_1math__opt_1_1Solver#aa9c5136714d04b0c012116a57d64585f "<a class="el" href="classoperations__research_1_1math__opt_1_1Solver.html#aa9c5136714d04b0c012116a57d64585f" title="Solves the current model (included all updates).">operations_research::math_opt::Solver::Solve</a>" (const SolveArgs &amp;arguments)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000900 (b/168037341): we should validate the result maths. Since the result
can be filtered, this should be included in the solver_interface
implementations. 
 &lt;p&gt; \anchor _todo000901 (b/290091715): Remove once language specific structs can use new
messages. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SolveResultMatcherOptions Member \_internalref structoperations__research_1_1math__opt_1_1SolveResultMatcherOptions#ae41b54030c8d6d4345348e188263eb7b "<a class="el" href="structoperations__research_1_1math__opt_1_1SolveResultMatcherOptions.html#ae41b54030c8d6d4345348e188263eb7b">operations_research::math_opt::SolveResultMatcherOptions::check_solutions_if_inf_or_unbounded</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000905 (b/201099290): this is perhaps not a good default. Gurobi as
 implemented is returning primal solutions for both unbounded and
 infeasible problems. We need to add unit tests that inspect this value
 and turn them on one solver at a time with a new parameter on
 SimpleLpTestParameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a1ef6c0a7d0962256e329df83b34a3668 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a1ef6c0a7d0962256e329df83b34a3668">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::column</a>" (ColumnId column_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001006 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a5b93353672b48d531e16f26eeb6c1238 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a5b93353672b48d531e16f26eeb6c1238">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::ColumnTerms</a>" (ColumnId col_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001008 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a35c2edd872d547e250e828a62e65ce71 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a35c2edd872d547e250e828a62e65ce71">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::row</a>" (RowId row_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001005 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#af45684890602a0abd734552aef5b53eb "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#af45684890602a0abd734552aef5b53eb">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::RowTerms</a>" (RowId row_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001007 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a6aca40055cfa8c9e5767ce467f5c89ae "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a6aca40055cfa8c9e5767ce467f5c89ae">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::Terms</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001009 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a346f0dd1bc945b8a3f6acce2f868b0f3 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a346f0dd1bc945b8a3f6acce2f868b0f3">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::Update</a>" (const absl::flat_hash_set&lt; RowId &gt; &amp;deleted_rows, absl::Span&lt; const RowId &gt; new_rows, const absl::flat_hash_set&lt; ColumnId &gt; &amp;deleted_columns, absl::Span&lt; const ColumnId &gt; new_columns, const absl::flat_hash_set&lt; std::pair&lt; RowId, ColumnId &gt; &gt; &amp;dirty) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000998 (b/233630053): use iterator API.
 &lt;p&gt; \anchor _todo000999 (b/233630053) use iterator API.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#ae7fd3ba62ed1002264117fa864e7144f "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#ae7fd3ba62ed1002264117fa864e7144f">operations_research::math_opt::SparseSymmetricMatrix::Proto</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000996 (b/233630053): reuse the allocation once an iterator API is
supported. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a43ee2fbaa504f90f7690b0bf87861c97 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a43ee2fbaa504f90f7690b0bf87861c97">operations_research::math_opt::SparseSymmetricMatrix::RelatedVariables</a>" (VariableId variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001001 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a5daadc06a91ff1edeb4871b1801b84f9 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a5daadc06a91ff1edeb4871b1801b84f9">operations_research::math_opt::SparseSymmetricMatrix::Terms</a>" (VariableId variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001002 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a4568f0449320e9203ed9969bad5d26dd "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a5daadc06a91ff1edeb4871b1801b84f9">operations_research::math_opt::SparseSymmetricMatrix::Terms</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001003 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a007fc8188b348177988fb88dffe12f3f "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a007fc8188b348177988fb88dffe12f3f">operations_research::math_opt::SparseSymmetricMatrix::Update</a>" (const absl::flat_hash_set&lt; VariableId &gt; &amp;deleted_variables, absl::Span&lt; const VariableId &gt; new_variables, const absl::flat_hash_set&lt; std::pair&lt; VariableId, VariableId &gt; &gt; &amp;dirty) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000997 (b/233630053): do not allocate here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a6297413386fb1ed24d1a6087c3f900cb "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a6297413386fb1ed24d1a6087c3f900cb">operations_research::math_opt::SparseSymmetricMatrix::values</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001004 (b/233630053): do not expose values_ directly, instead offer a way to
iterate over all the nonzero entries.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a89e72a700578de83bbd4eb42102bdc7a "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a89e72a700578de83bbd4eb42102bdc7a">operations_research::math_opt::SparseSymmetricMatrix::Variables</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001000 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Termination Member \_internalref structoperations__research_1_1math__opt_1_1Termination#a09bb061e1a745c607004cbd2de7500fb "<a class="el" href="structoperations__research_1_1math__opt_1_1Termination.html#a09bb061e1a745c607004cbd2de7500fb">operations_research::math_opt::Termination::best_primal_solution</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000914 (b/290359402): Consider improving to require a finite dual bound when
/ dual feasible solutions are returned.
  static Termination NoSolutionFound(
      bool is_maximize, Limit limit,
      std::optional&lt;double&gt; optional_dual_objective = std::nullopt,
      std::string detail = {});&lt;p&gt; \anchor _todo000915 (b/290359402): Consider improving to require a finite dual bound when
/ dual feasible solutions are returned.
  static Termination Feasible(
      bool is_maximize, Limit limit, double finite_primal_objective,
      std::optional&lt;double&gt; optional_dual_objective = std::nullopt,
      std::string detail = {});&lt;p&gt; \anchor _todo000916 (b/231134639): investigate removing the oneof from the proto.
  absl::StatusOr&lt;SolveResultProto&gt; Proto() const;&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ac51b998f0ab120a1855bd589f2553fad "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ac51b998f0ab120a1855bd589f2553fad" title="Validates the input result.">operations_research::math_opt::ValidateResult</a>" (const SolveResultProto &amp;result, const ModelSolveParametersProto &amp;parameters, const ModelSummary &amp;model_summary)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001012 (b/290091715): Remove once problem_status and objective bounds are
removed from solve_stats and their presence is guaranteed in termination. 
 &lt;p&gt; \anchor _todo001013 (b/290091715): Replace by
TerminationProto termination = result.termination();
once problem_status and objective bounds are removed from solve_stats and
their presence is guaranteed in termination. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#aa782b35203234b683975688b30f3110f "<a class="el" href="namespaceoperations__research_1_1math__opt.html#aa782b35203234b683975688b30f3110f">operations_research::math_opt::ValidateSolution</a>" (const SolutionProto &amp;solution, const ModelSolveParametersProto &amp;parameters, const ModelSummary &amp;model_summary)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001015 (b/204457524): consider checking equality of statuses for single-sided
LPs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#add23cecedb126522044aca6764532ce3 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#add23cecedb126522044aca6764532ce3">operations_research::math_opt::ValidateSolutions</a>" (const google::protobuf::RepeatedPtrField&lt; SolutionProto &gt; &amp;solutions, const ModelSolveParametersProto &amp;parameters, const ModelSummary &amp;model_summary)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001011 (b/204457524): check objective ordering when possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af099801286ce760f79dda3ce9b7be78d "<a class="el" href="namespaceoperations__research_1_1math__opt.html#af099801286ce760f79dda3ce9b7be78d">operations_research::math_opt::ValidateSolveParameters</a>" (const SolveParametersProto &amp;parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001017 (b/213697045): some parameters are still not validated.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MaxFlow Class \_internalref classoperations__research_1_1MaxFlow "<a class="el" href="classoperations__research_1_1MaxFlow.html">operations_research::MaxFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000666 (user): Modify this code and remove it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostFlowBase Member \_internalref classoperations__research_1_1MinCostFlowBase#ae5cad0c7d9c3eddbc7c3aefbee060457a41523b94852c3cb55c86ce0e291e3719 "<a class="el" href="classoperations__research_1_1MinCostFlowBase.html#ae5cad0c7d9c3eddbc7c3aefbee060457a41523b94852c3cb55c86ce0e291e3719">operations_research::MinCostFlowBase::BAD_COST_RANGE</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000682 (user): this is not always properly checked and probably
  deserve a different return status.
- Since we scale cost, each arc unit cost times (num_nodes + 1) should
  not overflow. We detect that at the beginning of the Solve().
- This is however not sufficient as the node potential depends on the
  minimum cost of sending 1 unit of flow through the residual graph. If
  the maximum arc unit cost is smaller than kint64max / (2 * n ^ 2) then
  one shouldn't run into any overflow. But in pratice this bound is quite
  loose. So it is possible to try with higher cost, and the algorithm
  will detect if an overflow actually happen and return BAD_COST_RANGE,
  so we can retry with smaller cost.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a6f94ee8ea8298d25de3607ed56d2d94e "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a6f94ee8ea8298d25de3607ed56d2d94e">operations_research::MinCostPerfectMatching::AddEdgeWithCost</a>" (int tail, int head, int64_t cost)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000707 (user): We can easily shift all costs if negative costs are needed.&lt;p&gt; \anchor _todo000708 (user): We could just presolve them away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a4d798c6f197b745924e4e0ca184c3642 "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a4d798c6f197b745924e4e0ca184c3642">operations_research::MinCostPerfectMatching::MinCostPerfectMatching</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000705 (user): For now we ask the number of nodes at construction, but we
could automatically infer it from the added edges if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a5f89c8890f72a582d15baf027b9cfeb9 "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a5f89c8890f72a582d15baf027b9cfeb9">operations_research::MinCostPerfectMatching::Reset</a>" (int num_nodes)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000706 (user): Eventually, we may support incremental Solves(). Or at least
memory reuse if one wants to solve many problems in a row. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#acce484fd341b33e5c371f0a1046821ed "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#acce484fd341b33e5c371f0a1046821ed">operations_research::MinCostPerfectMatching::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000686 (user): Improve the overflow detection if needed. The current one seems
ok though. 
 &lt;p&gt; \anchor _todo000687 (user): Maybe there is a faster/better way to recover the mapping
in the presence of blossoms. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ModelSolverHelper Member \_internalref classoperations__research_1_1ModelSolverHelper#a0a3942146394eec75729ef0d79319237 "<a class="el" href="classoperations__research_1_1ModelSolverHelper.html#a0a3942146394eec75729ef0d79319237">operations_research::ModelSolverHelper::Solve</a>" (const ModelBuilderHelper &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000818 (user): Enable log_callback support.
&lt;p&gt; \anchor _todo000819 &lt;p&gt; \anchor _todo000820 (user): Enable interrupt_solve. 
 &lt;p&gt; \anchor _todo000821 (user): Enable log_callback support.
&lt;p&gt; \anchor _todo000822 &lt;p&gt; \anchor _todo000823 (user): Enable interrupt_solve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a84aec4c6ee3b17edc9979b12ecdb5f63 "<a class="el" href="classoperations__research_1_1MPSolver.html#a84aec4c6ee3b17edc9979b12ecdb5f63">operations_research::MPSolver::ComputeConstraintActivities</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000774 (user): test this failure case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a9c8cc8b3c36fe9c08d8e0eefbc98b774 "<a class="el" href="classoperations__research_1_1MPSolver.html#a9c8cc8b3c36fe9c08d8e0eefbc98b774" title="Exports model to protocol buffer.">operations_research::MPSolver::ExportModelToProto</a>" (MPModelProto *output_model) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000770 (user): Add option to avoid filling the var name to avoid overly
large protocol buffers. 
 &lt;p&gt; \anchor _todo000771 (user): remove this step. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#aae2800c3df9ebf5f1e3c21cd5af3c9a9 "<a class="el" href="classoperations__research_1_1MPSolver.html#aae2800c3df9ebf5f1e3c21cd5af3c9a9">operations_research::MPSolver::LoadSolutionFromProto</a>" (const MPSolutionResponse &amp;response, double tolerance=std::numeric_limits&lt; double &gt;::infinity())&lt;/dt&gt;&lt;dd&gt; \anchor _todo000772 (user): Use parameter when they become available in this class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a9f2efb3304b325430e46e848574d63e5 "<a class="el" href="classoperations__research_1_1MPSolver.html#a18aef4e4cdea4ee15ce472d3b5f57962" title="Solves the problem using the default parameter values.">operations_research::MPSolver::Solve</a>" (const MPSolverParameters &amp;param)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000773 (user): replace this by model extraction to proto + proto validation
(the proto has very low overhead compared to the wrapper, both in
performance and memory, so it's ok). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a2a4a0234b5830d4ea82d549b3b6b5baf "<a class="el" href="classoperations__research_1_1MPSolver.html#a2a4a0234b5830d4ea82d549b3b6b5baf">operations_research::MPSolver::VerifySolution</a>" (double tolerance, bool log_errors) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000775 (user): split.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#ac11b5863b3866e251564de9a5dcfb92e "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#ac11b5863b3866e251564de9a5dcfb92e">operations_research::MPSolverInterface::MPSolverInterface</a>" (MPSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000776 (user): Initialize objective value and bound to +/- inf (depending on
optimization direction). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#a3fd73560f782eaf5093a435c61783d09 "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#a3fd73560f782eaf5093a435c61783d09" title="Resets the extraction information.">operations_research::MPSolverInterface::ResetExtractionInformation</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000777 (user): remove this method.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#ad237855fa79fc36fbf9baedce589384c "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#ad237855fa79fc36fbf9baedce589384c" title="Sets parameters common to LP and MIP in the underlying solver.">operations_research::MPSolverInterface::SetCommonParameters</a>" (const MPSolverParameters &amp;param)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000778 (user): Overhaul the code that sets parameters to enable changing
GLOP parameters without issuing warnings.
By default, we let GLOP keep its own default tolerance, much more accurate
than for the rest of the solvers.
 &lt;p&gt; \anchor _todo000779 (user): In the future, we could distinguish between the
algorithm to solve the root LP and the algorithm to solve node
LPs. Not sure if underlying solvers support it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::NearestNeighbors Member \_internalref classoperations__research_1_1NearestNeighbors#af61cd5ece87302a1054745def342cf71 "<a class="el" href="classoperations__research_1_1NearestNeighbors.html#af61cd5ece87302a1054745def342cf71">operations_research::NearestNeighbors::Initialize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000216 (user): recompute if node changes path ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a9618712e8edff7ae775417c7e2763062 "<a class="el" href="namespaceoperations__research.html#a9618712e8edff7ae775417c7e2763062">operations_research::NodePathImpliedBy</a>" (absl::Span&lt; const typename GraphType::ArcIndex &gt; arc_path, const GraphType &amp;graph)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000615 (b/332475804): If &lt;tt&gt;ArcPathTo&lt;/tt&gt; and/or &lt;tt&gt;NodePathTo&lt;/tt&gt; functions become
bottlenecks:
   (1) have the class preallocate a buffer of size &lt;tt&gt;num_nodes&lt;/tt&gt;
   (2) assign into an index rather than with push_back
   (3) return by absl::Span (or return a copy) with known size. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ObjectiveMonitor Member \_internalref classoperations__research_1_1ObjectiveMonitor#abfce94c7e8c5e81991ad9d744ecf7f3e "<a class="el" href="classoperations__research_1_1ObjectiveMonitor.html#abfce94c7e8c5e81991ad9d744ecf7f3e" title="-------— Objective Management -------—">operations_research::ObjectiveMonitor::ObjectiveMonitor</a>" (Solver *solver, const std::vector&lt; bool &gt; &amp;maximize, std::vector&lt; IntVar * &gt; vars, std::vector&lt; int64_t &gt; steps)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000379 (user): Remove optimization direction from solver or expose it for
each OptimizeVar variable. Note that Solver::optimization_direction() is
not used anywhere, only passed as information for the user. Direction set
based on highest level as of 02/2023. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Pack Member \_internalref classoperations__research_1_1Pack#af13898c8553d217fa3d52c6e2b504f8d "<a class="el" href="classoperations__research_1_1Pack.html#af13898c8553d217fa3d52c6e2b504f8d">operations_research::Pack::OneDomain</a>" (int var_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000236 (user): We know var ranges from 0 to bins_. There are lots
of simplifications possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PairExchangeOperator Member \_internalref classoperations__research_1_1PairExchangeOperator#abe5bdb5b47972a06326d2e9ab802faf4 "<a class="el" href="classoperations__research_1_1PairExchangeOperator.html#abe5bdb5b47972a06326d2e9ab802faf4">operations_research::PairExchangeOperator::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000334 (user): Support alternatives with neighbors.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad269bb3141acc83c2ebe88b1f57b1f95 "<a class="el" href="namespaceoperations__research.html#ad269bb3141acc83c2ebe88b1f57b1f95">operations_research::ParseAndSolve</a>" (const std::string &amp;filename, absl::string_view solver, const std::string &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001020 (user): Move naming code to parser.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathContainerImpl Class \_internalref classoperations__research_1_1PathContainerImpl "<a class="el" href="classoperations__research_1_1PathContainerImpl.html">operations_research::PathContainerImpl</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000711 (user): Currently using StarGraph::kNilNode until the new Ebert
graphs appear; switch to kNilNode on the base Ebert graph class when
available. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathLns Member \_internalref classoperations__research_1_1PathLns#a869e1cdf41f26c362721696997202bf7 "<a class="el" href="classoperations__research_1_1PathLns.html#a869e1cdf41f26c362721696997202bf7">operations_research::PathLns::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000217 (user): make this more efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#adbd9065c5b91dde20b8f4c0759233971 "<a class="el" href="classoperations__research_1_1PathOperator.html#adbd9065c5b91dde20b8f4c0759233971">operations_research::PathOperator::OnSamePathAsPreviousBase</a>" (int64_t base_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000153 (user): ideally this should be OnSamePath(int64_t node1, int64_t
node2);
it's currently way more complicated to implement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#a6580d6cdf003656019a25f7e9f2d8496 "<a class="el" href="classoperations__research_1_1PathOperator.html#a6580d6cdf003656019a25f7e9f2d8496">operations_research::PathOperator::RestartAtPathStartOnSynchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000152 (user): remove this when automatic detection of such cases in done. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#a13fc3f3cb8f8de7198d1b16338df06ad "<a class="el" href="classoperations__research_1_1PathOperator.html#a13fc3f3cb8f8de7198d1b16338df06ad">operations_research::PathOperator::SkipUnchanged</a>" (int index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000151 (user): Make the following methods protected.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a7bd16384c5572b001a57e9987bf5b0e9 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a7bd16384c5572b001a57e9987bf5b0e9">operations_research::pdlp::FindScalingFactor</a>" (const DiagonalTrustRegionProblem &amp;problem, const Sharder &amp;sharder, const double target_radius, const double solve_tol)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001039 (user): figure out what accuracy is useful to callers and redo the
stopping criterion accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp::internal Member \_internalref namespaceoperations__research_1_1pdlp_1_1internal#a0d1a488cd88b2db320196184c8a60713 "<a class="el" href="namespaceoperations__research_1_1pdlp_1_1internal.html#a0d1a488cd88b2db320196184c8a60713">operations_research::pdlp::internal::ComputeInitialUndecidedComponents</a>" (const TrustRegionProblem &amp;problem, int64_t start_index, int64_t end_index, std::vector&lt; int64_t &gt; &amp;undecided_components)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001040 (user): Evaluate dropping this &lt;tt&gt;reserve()&lt;/tt&gt;, since it wastes space
if many components are decided. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a898c0c776a5736cf1931036d0d370724 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a898c0c776a5736cf1931036d0d370724">operations_research::pdlp::ProjectToDualVariableBounds</a>" (const ShardedQuadraticProgram &amp;sharded_qp, VectorXd &amp;dual)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001036 (user): Investigate whether it is more efficient to
use .cwiseMax() + .cwiseMin() with unaryExpr(s) that map
upper_bound_shard and lower_bound_shard to appropriate values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a80b7dc41ed788020cbaf942674f623d9 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a80b7dc41ed788020cbaf942674f623d9">operations_research::pdlp::ReadQuadraticProgramOrDie</a>" (const std::string &amp;filename, bool include_names)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001034 (user): Update internal helper functions to use references instead of
pointers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp::ShardedWeightedAverage Member \_internalref classoperations__research_1_1pdlp_1_1ShardedWeightedAverage#a832ecd48fecace426aeb1c32f0322fbb "<a class="el" href="classoperations__research_1_1pdlp_1_1ShardedWeightedAverage.html#a832ecd48fecace426aeb1c32f0322fbb">operations_research::pdlp::ShardedWeightedAverage::ComputeAverage</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001035 (user): consider returning a reference to avoid this copy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#aeba91f0ed5437b1264431fc6562ff094 "<a class="el" href="classoperations__research_1_1PdlpInterface.html#aeba91f0ed5437b1264431fc6562ff094" title="Returns the basis status of a constraint.">operations_research::PdlpInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000786 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#aecba606519ca8ae9dfb6493a4653cbfc "<a class="el" href="classoperations__research_1_1PdlpInterface.html#aecba606519ca8ae9dfb6493a4653cbfc" title="Returns the basis status of a row.">operations_research::PdlpInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000785 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#a22fcf7b9b53475d97d46e1eb057d1b87 "<a class="el" href="classoperations__research_1_1PdlpInterface.html#a22fcf7b9b53475d97d46e1eb057d1b87">operations_research::PdlpInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000787 (user): Consider returning the SolveLog here, as it could be essential
for interpreting the PDLP solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PiecewiseLinearExpr Member \_internalref classoperations__research_1_1PiecewiseLinearExpr#a29f2fd207e34ba398b1b772d21852f33 "<a class="el" href="classoperations__research_1_1PiecewiseLinearExpr.html#a29f2fd207e34ba398b1b772d21852f33" title="Accepts the given visitor.">operations_research::PiecewiseLinearExpr::Accept</a>" (ModelVisitor *const visitor) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000196 (user): Implement visitor.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PiecewiseLinearFunction Member \_internalref classoperations__research_1_1PiecewiseLinearFunction#adb77fb211d172324d3d02e974af56c5b "<a class="el" href="classoperations__research_1_1PiecewiseLinearFunction.html#adb77fb211d172324d3d02e974af56c5b" title="Returns the value of the piecewise linear function for x.">operations_research::PiecewiseLinearFunction::Value</a>" (int64_t x) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002415 (user): Allow the user to specify the
undefined value and use kint64max as the default. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Preprocessor Class \_internalref classoperations__research_1_1Preprocessor "<a class="el" href="classoperations__research_1_1Preprocessor.html">operations_research::Preprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000044 (user): make the different algorithms concurrent, solving independent
subproblems in different threads.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Preprocessor Member \_internalref classoperations__research_1_1Preprocessor#a1d2eb2c3fd278870a969507c76636844 "<a class="el" href="classoperations__research_1_1Preprocessor.html#a1d2eb2c3fd278870a969507c76636844" title="Preprocessor.">operations_research::Preprocessor::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000046 (user): Add time-outs and exit with a partial solution. This seems
unlikely, though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PruningHamiltonianSolver Member \_internalref classoperations__research_1_1PruningHamiltonianSolver#a1400c5c64142a6b8faa3c6c0c235ff93 "<a class="el" href="classoperations__research_1_1PruningHamiltonianSolver.html#a1400c5c64142a6b8faa3c6c0c235ff93">operations_research::PruningHamiltonianSolver&lt; CostType, CostFunction &gt;::Integer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000643 (user): Use generic map-based cache instead of lattice-based one.
 &lt;p&gt; &lt;p&gt;(user): Use SaturatedArithmetic for better precision. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Queue Member \_internalref classoperations__research_1_1Queue#a014c7261e4c1b40cd8d81d22e22c3e94 "<a class="el" href="classoperations__research_1_1Queue.html#a014c7261e4c1b40cd8d81d22e22c3e94">operations_research::Queue::ProcessConstraints</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000125 (user): Make to_add_ a queue to make the behavior more obvious. 
 &lt;p&gt; \anchor _todo000126 (user): Add profiling to initial propagation
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad9e6cb141794cea6160e283e70c283c7 "<a class="el" href="namespaceoperations__research.html#ad9e6cb141794cea6160e283e70c283c7">operations_research::RadixSort</a>" (absl::Span&lt; T &gt; values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000038 (user): Expose an API that takes the "max value" as argument, for
users who want to take advantage of that knowledge to reduce the number of
passes. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab5ef2e157c0cb5fad29b2b6db644f8a0 "<a class="el" href="namespaceoperations__research.html#ab5ef2e157c0cb5fad29b2b6db644f8a0" title="The internal template that does all the work.">operations_research::RadixSortTpl</a>" (absl::Span&lt; T &gt; values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000035 : remove the if constexpr so that compilation catches the bad cases.
 &lt;p&gt; \anchor _todo000036 (user): See if this is faster than memcpy + std::reverse().
 &lt;p&gt; \anchor _todo000037 (user): See if memcpy everything + memcpy here is faster than
memmove(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RandomSolutionGenerator Class \_internalref classoperations__research_1_1RandomSolutionGenerator "<a class="el" href="classoperations__research_1_1RandomSolutionGenerator.html">operations_research::RandomSolutionGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000045 (user): make it possible to use other random generators. Idea: bias the
generator towards the columns with the least marginal costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RangeIntToIntFunction Member \_internalref classoperations__research_1_1RangeIntToIntFunction#a95dc968eea4874e0099cc74f38bd4aca "<a class="el" href="classoperations__research_1_1RangeIntToIntFunction.html#a95dc968eea4874e0099cc74f38bd4aca">operations_research::RangeIntToIntFunction::Query</a>" (int64_t argument) const =0&lt;/dt&gt;&lt;dd&gt; \anchor _todo002417 (user): Rename to Run 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a9dc92cf61d5051e6ec16fa5dc7e371ae "<a class="el" href="namespaceoperations__research.html#a9dc92cf61d5051e6ec16fa5dc7e371ae">operations_research::RationalApproximation</a>" (const double x, const double precision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002418 (user): make a parameterized template with integer and floating-point
type parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a02563c6a9501a9306b8a52fd459b7e8c "<a class="el" href="namespaceoperations__research.html#a02563c6a9501a9306b8a52fd459b7e8c">operations_research::ReadBeasleySetCoverProblem</a>" (absl::string_view filename)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000056 (user): add proper error handling. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a1bd9bbb304a58211dee6405bc7fc4056 "<a class="el" href="namespaceoperations__research.html#a1bd9bbb304a58211dee6405bc7fc4056">operations_research::ReadQapProblemOrDie</a>" (absl::string_view filepath)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002416 (user): Unit test cases when the function dies, or return
(and test) a status instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RelocateAndMakeActiveOperator Class \_internalref classoperations__research_1_1RelocateAndMakeActiveOperator "<a class="el" href="classoperations__research_1_1RelocateAndMakeActiveOperator.html" title="-— RelocateAndMakeActiveOperator --—">operations_research::RelocateAndMakeActiveOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000215 (user): Naming is close to MakeActiveAndRelocate but this one is
correct; rename MakeActiveAndRelocate if it is actually used. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RevBitMatrix Member \_internalref classoperations__research_1_1RevBitMatrix#ae2bcb32bc27553f598733168bbc46fd2 "<a class="el" href="classoperations__research_1_1RevBitMatrix.html#ae2bcb32bc27553f598733168bbc46fd2" title="Does the &#39;row&#39; bitset contains only one bit set?">operations_research::RevBitMatrix::IsCardinalityOne</a>" (int row) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000394 (user) : Optimize this one.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RevVector Member \_internalref classoperations__research_1_1RevVector#a576b88e9d92029753f73f012e2b57599 "<a class="el" href="classoperations__research_1_1RevVector.html#a576b88e9d92029753f73f012e2b57599">operations_research::RevVector&lt; IndexType, T &gt;::MutableRef</a>" (IndexType index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002420 (user): Maybe we could have also used the [] operator, but it is harder
to be 100% sure that the mutable version is only called when we modify
the vector. And I had performance bug because of that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingFilteredHeuristic Member \_internalref classoperations__research_1_1RoutingFilteredHeuristic#a7bb79a29267b7b9153447234897a7949 "<a class="el" href="classoperations__research_1_1RoutingFilteredHeuristic.html#a7bb79a29267b7b9153447234897a7949" title="Make all unassigned nodes unperformed, always returns true.">operations_research::RoutingFilteredHeuristic::MakeUnassignedNodesUnperformed</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000349 (user): check that delta_ is empty.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingGlopWrapper Member \_internalref classoperations__research_1_1RoutingGlopWrapper#a6e9afdf1ffb0dba256ae65a29dcc3e64 "<a class="el" href="classoperations__research_1_1RoutingGlopWrapper.html#a6e9afdf1ffb0dba256ae65a29dcc3e64">operations_research::RoutingGlopWrapper::PrintModel</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000330 (user): Improve output readability. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingGlopWrapper Member \_internalref classoperations__research_1_1RoutingGlopWrapper#ae230124d932c4d9f0da5d5b9538b88ba "<a class="el" href="classoperations__research_1_1RoutingGlopWrapper.html#ae230124d932c4d9f0da5d5b9538b88ba">operations_research::RoutingGlopWrapper::SetVariableDisjointBounds</a>" (int index, const std::vector&lt; int64_t &gt; &amp;starts, const std::vector&lt; int64_t &gt; &amp;ends) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000329 (user): Investigate if we can avoid rebuilding the interval list
each time (we could keep a reference to the forbidden interval list in
RoutingDimension but we would need to store cumul offsets and use them
when checking intervals). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingIndexManager Member \_internalref classoperations__research_1_1RoutingIndexManager#a148a071cb5a92fe73501c7c299ed5eb1 "<a class="el" href="classoperations__research_1_1RoutingIndexManager.html#a148a071cb5a92fe73501c7c299ed5eb1">operations_research::RoutingIndexManager::num_unique_depots</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000319 (user) Add unit tests for NodesToIndices and IndicesToNodes.
 &lt;p&gt; &lt;p&gt;(user): Remove when removal of NodeIndex from RoutingModel is
complete. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingModelInspector Member \_internalref classoperations__research_1_1RoutingModelInspector#a84dbe032f5cce5e2e3acc042382b1f85 "<a class="el" href="classoperations__research_1_1RoutingModelInspector.html#a84dbe032f5cce5e2e3acc042382b1f85">operations_research::RoutingModelInspector::EndVisitModel</a>" (const std::string &amp;) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000285 (user): Perform transitive closure of dimension precedence graphs.
&lt;p&gt; \anchor _todo000286 &lt;p&gt; \anchor _todo000287 (user): Have a single annotated precedence graph. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aac65f6cb5816150efa463314f16ee1cd "<a class="el" href="namespaceoperations__research.html#aac65f6cb5816150efa463314f16ee1cd">operations_research::RunSeparation</a>" (internal::ScipCallbackRunner *runner, const ScipConstraintHandlerContext &amp;context, absl::Span&lt; SCIP_CONS * &gt; constraints, bool is_integral)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000808 (user): when infeasible is true, it better to have the scip
return status be cutoff instead of cutting plane added (e.g. see
cs/scip/src/scip/cons_knapsack.c). However, as we use
SCIPaddRow(), it isn't clear this will even happen. 
 &lt;p&gt; \anchor _todo000809 (user): Maybe it is better to expose more of these options,
potentially through user_suggested_constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Class \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">operations_research::sat::ActivityBoundHelper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002118 (user): Use better algorithm. The problem is the same as finding upper
bound to the classic problem: maximum-independent set in a graph. We also
only use at most ones, but we could use the more general binary implication
graph. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#a0597d8e2ff729931de6b9e1e7df34298 "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#a0597d8e2ff729931de6b9e1e7df34298">operations_research::sat::ActivityBoundHelper::AddAllAtMostOnes</a>" (const CpModelProto &amp;proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002113 (user): Add long ones first, or at least the ones of size 2 after.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#a7569741972c7325665407db889dc36af "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#a7569741972c7325665407db889dc36af">operations_research::sat::ActivityBoundHelper::ComputeMaxActivity</a>" (absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; terms, std::vector&lt; std::array&lt; int64_t, 2 &gt; &gt; *conditional=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002121 (user): Indicate when the bounds are trivial (i.e. not intersection
with any amo) so that we don't waste more time processing the result? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#ad71179e60a9659f4899d68ad8472b679 "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#ad71179e60a9659f4899d68ad8472b679">operations_research::sat::ActivityBoundHelper::PresolveEnforcement</a>" (absl::Span&lt; const int &gt; refs, ConstraintProto *ct, absl::flat_hash_set&lt; int &gt; *literals_at_true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002115 (user): Ideally these amo should not be added to this class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af6541cdba8310f4fcbc8d8737cd29afa "<a class="el" href="namespaceoperations__research_1_1sat.html#af6541cdba8310f4fcbc8d8737cd29afa" title="l =&gt; (a + b &lt;= ub).">operations_research::sat::AddConditionalSum2LowerOrEqual</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, IntegerVariable a, IntegerVariable b, int64_t ub, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002079 (user): Refactor to be sure we do not miss any level zero relations.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad3913e8754c767cf5b0be9282bd4c6fe "<a class="el" href="namespaceoperations__research_1_1sat.html#ad3913e8754c767cf5b0be9282bd4c6fe">operations_research::sat::AddConditionalSum3LowerOrEqual</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, IntegerVariable a, IntegerVariable b, IntegerVariable c, int64_t ub, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002080 (user): Use level zero bounds to infer binary precedence relations? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a799cf49d8b3bb7f3ede756a639e6662c "<a class="el" href="namespaceoperations__research_1_1sat.html#a799cf49d8b3bb7f3ede756a639e6662c" title="Scheduling relaxations and cut generators.">operations_research::sat::AddCumulativeRelaxation</a>" (const AffineExpression &amp;capacity, SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands, const std::optional&lt; AffineExpression &gt; &amp;makespan, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001935 (user): We could use (capacity / demands_gcd) * demands_gcd. 
 &lt;p&gt; \anchor _todo001936 (user): Implement demands_gcd != 1 &amp;&amp; capacity is fixed.
 &lt;p&gt; \anchor _todo001937 (user): In some cases, we could have only one task that can be
first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9ab304db27f5c4170f35583c69269394 "<a class="el" href="namespaceoperations__research_1_1sat.html#a9ab304db27f5c4170f35583c69269394">operations_research::sat::AddDisjunctive</a>" (const std::vector&lt; IntervalVariable &gt; &amp;intervals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001611 (user): create them dynamically instead? 
 &lt;p&gt; \anchor _todo001630 (user): This is not completely true for empty intervals (start == end).
Make sure such intervals are ignored by the constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#abf0e8ef0b1ad01ad3a9aae0a009e5f13 "<a class="el" href="namespaceoperations__research_1_1sat.html#abf0e8ef0b1ad01ad3a9aae0a009e5f13">operations_research::sat::AddLinMaxCutGenerator</a>" (const ConstraintProto &amp;ct, Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001946 (user): Support linearization of general target expression.
 &lt;p&gt; \anchor _todo001947 (user): Move this out of here.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a919cb1a74305a95883f51e95343ac474 "<a class="el" href="namespaceoperations__research_1_1sat.html#a919cb1a74305a95883f51e95343ac474" title="enforcement_literals =&gt; sum &lt;= upper_bound">operations_research::sat::AddWeightedSumLowerOrEqual</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const int64_t &gt; coefficients, int64_t upper_bound, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001745 (user): Deal with the case with no enforcement literal, in case the
presolve was turned off? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AffineExpression Member \_internalref structoperations__research_1_1sat_1_1AffineExpression#ae2df741604041f566520f58d28482eef "<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html#ae2df741604041f566520f58d28482eef">operations_research::sat::AffineExpression::var</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001710 (user): Make this private to enforce the invariant that coeff cannot be
negative. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentBoundsPropagator Class \_internalref classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator.html">operations_research::sat::AllDifferentBoundsPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001052 (user): It might be difficult to find something faster than what is
implemented here. Some related reference:
https://cs.uwaterloo.ca/~vanbeek/Publications/ijcai03_TR.pdf 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentBoundsPropagator Member \_internalref classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator#abcd3b5d1133bde855025a642745ca3b6 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator.html#abcd3b5d1133bde855025a642745ca3b6">operations_research::sat::AllDifferentBoundsPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001051 (user): investigate the impact. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentConstraint Member \_internalref classoperations__research_1_1sat_1_1AllDifferentConstraint#a59e041a85cd31545fe5d7e0e3907d3a4 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html#a59e041a85cd31545fe5d7e0e3907d3a4">operations_research::sat::AllDifferentConstraint::AllDifferentConstraint</a>" (std::vector&lt; IntegerVariable &gt; variables, IntegerEncoder *encoder, Trail *trail, IntegerTrail *integer_trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001049 (user): Prune now, ignore these variables during solving. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentConstraint Member \_internalref classoperations__research_1_1sat_1_1AllDifferentConstraint#a1adb3a2f02ebc277b22879cd01e994b2 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html#a1adb3a2f02ebc277b22879cd01e994b2">operations_research::sat::AllDifferentConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001050 (user): If needed, there are several ways performance could be
improved.
If copying the variable state is too costly, it could be maintained instead.
If the propagator has too many fruitless calls (without failing/pruning),
we can remember the O(n) arcs used in the matching and the SCC decomposition,
and guard calls to Propagate() if these arcs are still valid. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afc1129274beafb17b41ac2fa278de60c "<a class="el" href="namespaceoperations__research_1_1sat.html#afc1129274beafb17b41ac2fa278de60c">operations_research::sat::AllValuesInDomain</a>" (const ProtoWithDomain &amp;proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001516 (user): work directly on the Domain class instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a43f4e0c653d01e67ff65ec40eb96e2e5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a43f4e0c653d01e67ff65ec40eb96e2e5">operations_research::sat::AnalyzeIntervals</a>" (bool transpose, absl::Span&lt; const int &gt; local_boxes, absl::Span&lt; const Rectangle &gt; rectangles, absl::Span&lt; const IntegerValue &gt; rectangle_energies, IntegerValue *x_threshold, IntegerValue *y_threshold, Rectangle *conflict)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001607 (user): If the number of unique x_max is smaller than the number of
unique x_min, it is better to do it the other way around. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac506719ca656893d93a2a6c940999265 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac506719ca656893d93a2a6c940999265">operations_research::sat::AppendBoolAndRelaxation</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *activity_helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001930 (user): These constraints can be many, and if they are not regrouped
in big at most ones, then they should probably only added lazily as cuts.
Regroup this with future clique-cut separation logic.&lt;p&gt; \anchor _todo001931 (user): More generally, do not miss the same structure if the bool_and
was expanded into many clauses!&lt;p&gt; \anchor _todo001932 (user): It is not 100% clear that just not adding one constraint is
worse. Relaxation is worse, but then we have less constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a99c02b5f23ff755783f84c851f8dcbb2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a99c02b5f23ff755783f84c851f8dcbb2">operations_research::sat::AppendElementEncodingRelaxation</a>" (Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001948 (user): We can do something similar with just an at most one, however
it is harder to detect that if all literal are false then none of the implied
value can be taken. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a42d3ac4927f1adbca821091239fc06c7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a42d3ac4927f1adbca821091239fc06c7">operations_research::sat::AppendLinearConstraintRelaxation</a>" (const ConstraintProto &amp;ct, bool linearize_enforced_constraints, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *activity_helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001940 (user): In LoadLinearConstraint() we already created intermediate
Booleans for each disjoint interval, we should reuse them here if
possible.&lt;p&gt; \anchor _todo001941 (user): process the "at most one" part of a == 1 separately? 
 &lt;p&gt; \anchor _todo001942 (user): Use cleaner "already loaded" logic, and mark as such constraint
already encoded by code like AppendRelaxationForEqualityEncoding(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a87160f650c0f35013f055fb81b3dfd30 "<a class="el" href="namespaceoperations__research_1_1sat.html#a87160f650c0f35013f055fb81b3dfd30">operations_research::sat::AppendLinMaxRelaxationPart1</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001956 (user): Support linear expression as target. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aab775ea3151335d5d07e4071e38a4687 "<a class="el" href="namespaceoperations__research_1_1sat.html#aab775ea3151335d5d07e4071e38a4687">operations_research::sat::AppendLinMaxRelaxationPart2</a>" (IntegerVariable target, const std::vector&lt; Literal &gt; &amp;alternative_literals, const std::vector&lt; LinearExpression &gt; &amp;exprs, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001939 (user): Remove hash_map ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9d126152f7618c43746d3f56577b803e "<a class="el" href="namespaceoperations__research_1_1sat.html#a9d126152f7618c43746d3f56577b803e">operations_research::sat::AppendMaxAffineRelaxation</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001938 (user): experiment with:
  1) remove this code
  2) keep this code
  3) remove this code and create the cut generator at level 1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af8a1aaff5bb36f1dfaf3daea8d5a076e "<a class="el" href="namespaceoperations__research_1_1sat.html#af8a1aaff5bb36f1dfaf3daea8d5a076e">operations_research::sat::AppendRelaxationForEqualityEncoding</a>" (IntegerVariable var, const Model &amp;model, LinearRelaxation *relaxation, int *num_tight, int *num_loose)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001929 (user): PartialDomainEncoding() filter pair corresponding to literal
set to false, however the initial variable Domain is not always updated. As
a result, these min/max can be larger than in reality. Try to fix this even
if in practice this is a rare occurrence, as the presolve should have
propagated most of what we can. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#abd42a035a99f910066d0a0356eff9ed6 "<a class="el" href="namespaceoperations__research_1_1sat.html#abd42a035a99f910066d0a0356eff9ed6">operations_research::sat::AppendSquareRelaxation</a>" (const ConstraintProto &amp;ct, Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001945 (user): We could add all or some below_hyperplans.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab3f18aece2e354382532b24b02e0ca81 "<a class="el" href="namespaceoperations__research_1_1sat.html#ab3f18aece2e354382532b24b02e0ca81">operations_research::sat::ApplyLiteralMappingToBooleanProblem</a>" (const absl::StrongVector&lt; LiteralIndex, LiteralIndex &gt; &amp;mapping, LinearBooleanProblem *problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001060 (user): The names is currently all scrambled. Do something about it
so that non-fixed variables keep their names. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ArcGraphNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1ArcGraphNeighborhoodGenerator#a23331202e80d1f0b6439fac92b7e2e92 "<a class="el" href="classoperations__research_1_1sat_1_1ArcGraphNeighborhoodGenerator.html#a23331202e80d1f0b6439fac92b7e2e92">operations_research::sat::ArcGraphNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, double difficulty, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001173 (user): should we compress it or use a different representation ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AssignmentInfo Member \_internalref structoperations__research_1_1sat_1_1AssignmentInfo#a2c118b72a43ea721d8c724184e7c54f6 "<a class="el" href="structoperations__research_1_1sat_1_1AssignmentInfo.html#a2c118b72a43ea721d8c724184e7c54f6">operations_research::sat::AssignmentInfo::level</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002162 (user): We may be able to get rid of that for faster enqueues. Most of
the code only need to know if this is 0 or the highest level, and for the
LBD computation, the literal of the conflict are already ordered by level,
so we could do it fairly efficiently.&lt;p&gt; \anchor _todo002163 (user): We currently don't support more than 2^28 decision levels. That
should be enough for most practical problem, but we should fail properly if
this limit is reached. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BasicKnapsackSolver Member \_internalref classoperations__research_1_1sat_1_1BasicKnapsackSolver#abf8b154951fbb851e98a619ff969b0ef "<a class="el" href="classoperations__research_1_1sat_1_1BasicKnapsackSolver.html#abf8b154951fbb851e98a619ff969b0ef">operations_research::sat::BasicKnapsackSolver::Solve</a>" (const std::vector&lt; Domain &gt; &amp;domains, const std::vector&lt; int64_t &gt; &amp;coeffs, const std::vector&lt; int64_t &gt; &amp;costs, const Domain &amp;rhs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002361 (user): We can also solve efficiently if max_activity - rhs.Min() is
small. Implement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae35ceb34b6366add1981140f6a173339 "<a class="el" href="namespaceoperations__research_1_1sat.html#ae35ceb34b6366add1981140f6a173339">operations_research::sat::BasicOrbitopeExtraction</a>" (absl::Span&lt; const std::unique_ptr&lt; SparsePermutation &gt; &gt; generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002323 (user): We could grow each and keep the real maximum. 
 &lt;p&gt; \anchor _todo002324 (user): Detect more than one orbitope? Note that once detected, the
structure can be exploited efficiently, but for now, a more "generic"
algorithm based on stabilizator should achieve the same preprocessing power,
so I don't know how hard we need to invest in orbitope detection.&lt;p&gt; \anchor _todo002325 (user): The heuristic is quite limited for now, but this works on
graph20-20-1rand.mps.gz. I suspect the generators provided by the detection
code follow our preconditions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Class \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">operations_research::sat::BinaryImplicationGraph</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001100 (user): Most of the note below are done, but we currently only applies
the reduction before the solve. We should consider doing more in-processing.
The code could probably still be improved too.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ae18864358e7e3f0d4c9c7cf81e3757de "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ae18864358e7e3f0d4c9c7cf81e3757de">operations_research::sat::BinaryImplicationGraph::AddAtMostOne</a>" (absl::Span&lt; const Literal &gt; at_most_one)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001104 (user): Our algorithm could generalize easily to at_most_ones + a list
of literals that will be false if one of the literal in the amo is at one.
It is a way to merge common list of implications.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a76cf257e080c0b1fa5fd4b76f908e51c "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a76cf257e080c0b1fa5fd4b76f908e51c">operations_research::sat::BinaryImplicationGraph::AddBinaryClause</a>" (Literal a, Literal b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001077 (user): Not all of the solver knows about representative literal, do
use them here to maintains invariant? Explore this when we start cleaning our
clauses using equivalence during search. We can easily do it for every
conflict we learn instead of here. 
 &lt;p&gt; \anchor _todo001078 (user): Like this we will duplicate all binary clause from the
problem. However this leads to a simpler API (since we don't need to
special case the loading of the original clauses) and we mainly use drat
proof for testing anyway. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a07e88e219614208bf02f4bed078504f9 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a07e88e219614208bf02f4bed078504f9">operations_research::sat::BinaryImplicationGraph::ComputeTransitiveReduction</a>" (bool log_info=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001088 (user): Track which literal have new implications, and only process
the antecedants of these. 
 &lt;p&gt; \anchor _todo001089 (user): the situation with fixed variable is not really "clean".
Simplify the code so we are sure we don't run into issue or have to deal
with any of that here. 
 &lt;p&gt; \anchor _todo001090 (user): We should be able to reuse some propagation like it is done for
tree-look. Once a node is processed, we just need to process a node that
implies it. Test if we can make this faster. Alternatively, only clear
a part of is_marked_ (after the first child of root in reverse topo order).&lt;p&gt; \anchor _todo001091 (user): Can we exploit the fact that the implication graph is a
skew-symmetric graph (isomorphic to its transposed) so that we do less
work? 
 &lt;p&gt; \anchor _todo001092 (user): Another optim we can do is that we never need to expand
any node with a reverse topo order smaller or equal to the min of the
ones in this list. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aa80bafd5aaf59cc6c7a67176c6304239 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">operations_research::sat::BinaryImplicationGraph::DetectEquivalences</a>" (bool log_info=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001087 (user): We could just do it directly though.
 &lt;p&gt; \anchor _todo001105 (user): Completely get rid of such literal instead? it might not be
reasonable code-wise to remap our literals in all of our constraints
though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ab589014979b15460c0cb295527097731 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab589014979b15460c0cb295527097731">operations_research::sat::BinaryImplicationGraph::DirectImplications</a>" (Literal literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001098 (user): lazy cleanup the lists on is_removed_?
 &lt;p&gt; &lt;p&gt;(user): Mark fixed variable as is_removed_ for faster iteration? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#af82f4ac499358536858b414345c0b13e "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#af82f4ac499358536858b414345c0b13e">operations_research::sat::BinaryImplicationGraph::EnableSharing</a>" (bool enable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001103 (user): this is meant to share clause between workers, hopefully the
contention will not be too high. Double check and maybe add a batch version
were we keep new implication and add them in batches. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a2735353cc3b14a2ef6574ad9f52c06b7 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a2735353cc3b14a2ef6574ad9f52c06b7">operations_research::sat::BinaryImplicationGraph::ExtractAllBinaryClauses</a>" (Output *out) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001108 (user): When extracting to cp_model.proto we could be more efficient
by extracting bool_and constraint with many lhs terms. 
 &lt;p&gt; \anchor _todo001109 (user): Ideally we should just never have duplicate clauses in this
class. But it seems we do in some corner cases, so lets not output them
twice. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aba4f40564f3adae0c9b904663bf62637 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aba4f40564f3adae0c9b904663bf62637">operations_research::sat::BinaryImplicationGraph::GenerateAtMostOnesWithLargeWeight</a>" (const std::vector&lt; Literal &gt; &amp;literals, const std::vector&lt; double &gt; &amp;lp_values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001106 (user): Refine the heuristic and unit test! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#af1d6fe0884e39f01edd6512ea6a7ce1c "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#af1d6fe0884e39f01edd6512ea6a7ce1c">operations_research::sat::BinaryImplicationGraph::HeuristicAmoPartition</a>" (std::vector&lt; Literal &gt; *literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001095 (user): Use deterministic limit.
 &lt;p&gt; &lt;p&gt;(user): Explore the graph instead of just looking at full amo, especially
since we expand small ones. 
 &lt;p&gt; \anchor _todo001107 (user): Add a limit to make sure this do not take too much time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aa37e2a622549d733c3bbb8b340f3c473 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa37e2a622549d733c3bbb8b340f3c473">operations_research::sat::BinaryImplicationGraph::MinimizeConflictExperimental</a>" (const Trail &amp;trail, std::vector&lt; Literal &gt; *c)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001084 (user): Also consider at most one?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ab5846564f39bf6ba28ecdced8429d492 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab5846564f39bf6ba28ecdced8429d492">operations_research::sat::BinaryImplicationGraph::MinimizeConflictFirst</a>" (const Trail &amp;trail, std::vector&lt; Literal &gt; *c, SparseBitset&lt; BooleanVariable &gt; *marked)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001083 (user): if this is false, then we actually have a conflict of size 2.
This can only happen if the binary clause was not propagated properly
if for instance we do chronological bactracking without re-enqueing the
consequence of a binary clause. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a3cbe67b46860621bfa57c87f5247a385 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a3cbe67b46860621bfa57c87f5247a385">operations_research::sat::BinaryImplicationGraph::MinimizeConflictWithReachability</a>" (std::vector&lt; Literal &gt; *c)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001081 (user): Also consider at most one? 
 &lt;p&gt; \anchor _todo001082 (user): This sounds like a good idea, but somehow it seems better not
to do that even though it is almost for free. Investigate more.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a7e4e6130c59dffa6ab52a1cff24400a2 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a7e4e6130c59dffa6ab52a1cff24400a2">operations_research::sat::BinaryImplicationGraph::RemoveFixedVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001085 (user): This might not be true if we remove implication by
transitive reduction and the process was aborted due to the computation
limit. I think it will be good to maintain that invariant though,
otherwise fixed literals might never be removed from these lists... 
 &lt;p&gt; \anchor _todo001086 (user): This might be a bit slow. Do not call all the time if needed,
this shouldn't change the correctness of the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a4a7ae378f427890ed11dfa8efb7c1db7 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a4a7ae378f427890ed11dfa8efb7c1db7">operations_research::sat::BinaryImplicationGraph::TransformIntoMaxCliques</a>" (std::vector&lt; std::vector&lt; Literal &gt; &gt; *at_most_ones, int64_t max_num_explored_nodes=1e8)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001093 (user): Shall we presolve it here? 
 &lt;p&gt; \anchor _todo001094 (user): Detect on the fly is superset already exist. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BlockedClauseSimplifier Class \_internalref classoperations__research_1_1sat_1_1BlockedClauseSimplifier "<a class="el" href="classoperations__research_1_1sat_1_1BlockedClauseSimplifier.html">operations_research::sat::BlockedClauseSimplifier</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002232 (user): This requires that l only appear in clauses and not in the
integer part of CP-SAT. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac341ac6090ff0bed8ad2231c94cd3bfc "<a class="el" href="namespaceoperations__research_1_1sat.html#ac341ac6090ff0bed8ad2231c94cd3bfc">operations_research::sat::BooleanLinearConstraint</a>" (int64_t lower_bound, int64_t upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002273 (user): move them in another file, and unit-test them.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a937ae99fd6f6c445a8aad34f04222a1a "<a class="el" href="namespaceoperations__research_1_1sat.html#a937ae99fd6f6c445a8aad34f04222a1a" title="Returns true iff the Boolean linear expression is in canonical form.">operations_research::sat::BooleanLinearExpressionIsCanonical</a>" (absl::Span&lt; const LiteralWithCoeff &gt; cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002017 (user): Also check for no duplicates literals + unit tests.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BooleanOrIntegerVariable Struct \_internalref structoperations__research_1_1sat_1_1BooleanOrIntegerVariable "<a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerVariable.html">operations_research::sat::BooleanOrIntegerVariable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001789 (user): This is currently quadratic as we scan all variables to find the
first unassigned one. Fix. Note that this is also the case in many other
heuristics and should be fixed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BooleanXorPropagator Class \_internalref classoperations__research_1_1sat_1_1BooleanXorPropagator "<a class="el" href="classoperations__research_1_1sat_1_1BooleanXorPropagator.html">operations_research::sat::BooleanXorPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001123 (user): By using a two watcher mechanism, we can propagate this a lot
faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BoolRLTCutHelper Member \_internalref classoperations__research_1_1sat_1_1BoolRLTCutHelper#a06106288eec90bbe9cf46ac3712de757 "<a class="el" href="classoperations__research_1_1sat_1_1BoolRLTCutHelper.html#a06106288eec90bbe9cf46ac3712de757" title="Tries RLT separation of the input constraint. Returns true on success.">operations_research::sat::BoolRLTCutHelper::TrySimpleSeparation</a>" (const CutData &amp;input_ct)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001565 (user): do less work, add more stats.
 &lt;p&gt; \anchor _todo001566 (user): detect earlier that a factor is not worth checking because
we already loose too much with the DROP/MC_CORMICK cases ? Filter more ?
I think we can probably evaluate the factor efficiency during the first
loop which usually have a small complexity compared to num_factor_to_try
times num filtered terms. 
 &lt;p&gt; \anchor _todo001567 (user): we never use factor with lp value &lt; 1e-4, but we could use a
factor equal to 1.0 I think. Double check. 
 &lt;p&gt; \anchor _todo001568 (user): We could keep for each factor the max gain, so that we
can decided if it is not even worth trying a factor. 
 &lt;p&gt; \anchor _todo001569 (user): Avoid constructing the cut just to evaluate its efficacy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BoundedVariableElimination Member \_internalref classoperations__research_1_1sat_1_1BoundedVariableElimination#a8d5a5e9f809d97c6dc3cbc5d948f4a51 "<a class="el" href="classoperations__research_1_1sat_1_1BoundedVariableElimination.html#a8d5a5e9f809d97c6dc3cbc5d948f4a51">operations_research::sat::BoundedVariableElimination::DoOneRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002218 (user): but we shouldn't keep clauses containing removed literals.
It is still valid to do so, but it should be less efficient. 
 &lt;p&gt; \anchor _todo002219 (user): add a local dtime limit for the corner case where this take too
much time. We can adapt the limit depending on how much we want to spend on
inprocessing. 
 &lt;p&gt; \anchor _todo002220 (user): we might also find new equivalent variable l =&gt; var =&gt; l
here, but for now we ignore those. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CanonicalBooleanLinearProblem Class \_internalref classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem "<a class="el" href="classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem.html">operations_research::sat::CanonicalBooleanLinearProblem</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002031 (user): Simplify further the constraints.&lt;p&gt; \anchor _todo002032 (user): Remove the duplication between this and what the sat solver
is doing in AddLinearConstraint() which is basically the same.&lt;p&gt; \anchor _todo002033 (user): Remove duplicate constraints? some problems have them, and
this is not ideal for the symmetry computation since it leads to a lot of
symmetries of the associated graph that are not useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CanonicalBooleanLinearProblem Member \_internalref classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem#ad91fdf3c0b3d6b5f52ab35e1ea1cfd31 "<a class="el" href="classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem.html#ad91fdf3c0b3d6b5f52ab35e1ea1cfd31">operations_research::sat::CanonicalBooleanLinearProblem::AddLinearConstraint</a>" (bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002035 (user): Use a return status to distinguish errors if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#acf2e86d1933cd807c30272b12a81848e "<a class="el" href="namespaceoperations__research_1_1sat.html#acf2e86d1933cd807c30272b12a81848e">operations_research::sat::CanonicalizeLinearExpressionInternal</a>" (absl::Span&lt; const int &gt; enforcements, ProtoWithVarsAndCoeffs *proto, int64_t *offset, std::vector&lt; std::pair&lt; int, int64_t &gt; &gt; *tmp_terms, PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002105 (user): Add a quick pass to skip most of the work below if the
constraint is already in canonical form? 
 &lt;p&gt; \anchor _todo002106 (user): Avoid the quadratic loop for the corner case of many
enforcement literal (this should be pretty rare though). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3f5064fe335d0bd2f67a8c9e3e132b4f "<a class="el" href="namespaceoperations__research_1_1sat.html#a3f5064fe335d0bd2f67a8c9e3e132b4f">operations_research::sat::CeilSquareRoot</a>" (int64_t a)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002360 (user): Find better implementation?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitCoveringPropagator Class \_internalref classoperations__research_1_1sat_1_1CircuitCoveringPropagator "<a class="el" href="classoperations__research_1_1sat_1_1CircuitCoveringPropagator.html">operations_research::sat::CircuitCoveringPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001069 (user): Make distinguished nodes an array of Boolean variables,
so this can be used for facility location problems. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitPropagator Member \_internalref classoperations__research_1_1sat_1_1CircuitPropagator#a54823f9c1557fcb9ee85d3c28c329bf0 "<a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html#a54823f9c1557fcb9ee85d3c28c329bf0">operations_research::sat::CircuitPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001063 (user): both this and the loop on must_be_in_cycle_ might take some
time on large graph. Optimize if this become an issue. 
 &lt;p&gt; \anchor _todo001064 (user): we can fail early in more case, like no more possible path
to any of the mandatory node. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitPropagator Member \_internalref classoperations__research_1_1sat_1_1CircuitPropagator#a05dbff53ce702fea3c1b8dbd913a3228 "<a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html#a05dbff53ce702fea3c1b8dbd913a3228">operations_research::sat::CircuitPropagator::RegisterWith</a>" (GenericLiteralWatcher *watcher)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001062 (user): come up with a test that fail when this is not here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a445ddafc05cd8e1a75db81c1c4426179 "<a class="el" href="namespaceoperations__research_1_1sat.html#a445ddafc05cd8e1a75db81c1c4426179">operations_research::sat::ClauseIsEnforcementImpliesLiteral</a>" (absl::Span&lt; const int &gt; clause, absl::Span&lt; const int &gt; enforcement, int literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002119 (user): For the same complexity, we do not need to specify literal and
can recover it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a65d15a1a1d08387cb9f9e58e0e153540 "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a65d15a1a1d08387cb9f9e58e0e153540">operations_research::sat::ClauseManager::DeleteRemovedClauses</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001076 (user): If more indices are needed, generalize the code to a vector of
indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a4bb2615bf56f39aa7a070d8f4b2b8d03 "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a4bb2615bf56f39aa7a070d8f4b2b8d03">operations_research::sat::ClauseManager::Detach</a>" (SatClause *clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001101 (user): It might be better to have a "slower" mode in
PropagateOnFalse() that deal with detached clauses in the watcher list and
is activated until the next CleanUpWatchers() calls. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a00f87aaf6e3bf62d2de2f2c21f3f9d0b "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a00f87aaf6e3bf62d2de2f2c21f3f9d0b">operations_research::sat::ClauseManager::InprocessingAddClause</a>" (absl::Span&lt; const Literal &gt; new_clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001075 (user): We should return false...
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#ad50ac50e7697b1f7dbbaa750fd94cffa "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#ad50ac50e7697b1f7dbbaa750fd94cffa" title="This one do not need the clause to be detached.">operations_research::sat::ClauseManager::InprocessingFixLiteral</a>" (Literal true_literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001073 (user): remove the test when the DRAT issue with fixed literal is
resolved. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a19e5abfaaedf626fcfd0d44dd827fc24 "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a19e5abfaaedf626fcfd0d44dd827fc24" title="These must only be called between [Detach/Attach]AllClauses() calls.">operations_research::sat::ClauseManager::InprocessingRemoveClause</a>" (SatClause *clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001074 (user): We could do something slower if the clauses are attached like
we do for InprocessingRewriteClause(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a2615c732b9c2b3c898f353fd68892c38 "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a2615c732b9c2b3c898f353fd68892c38">operations_research::sat::ClauseManager::NextClauseToMinimize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001102 (user): If more indices are needed, switch to a generic API. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CombinedDisjunctive Member \_internalref classoperations__research_1_1sat_1_1CombinedDisjunctive#ac88bd295048bf30b8726c9f600587287 "<a class="el" href="classoperations__research_1_1sat_1_1CombinedDisjunctive.html#ac88bd295048bf30b8726c9f600587287">operations_research::sat::CombinedDisjunctive&lt; time_direction &gt;::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001613 (user): AddEntry() and ComputeEndMin() could be combined.
 &lt;p&gt; \anchor _todo001614 (user): Maybe factor out the code? It does require a function with a
lot of arguments though. 
 &lt;p&gt; \anchor _todo001615 (user): Refactor the code to use the same algo as in
DisjunctiveDetectablePrecedences, it is superior and do not need
this function. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CompiledConstraint Class \_internalref classoperations__research_1_1sat_1_1CompiledConstraint "<a class="el" href="classoperations__research_1_1sat_1_1CompiledConstraint.html">operations_research::sat::CompiledConstraint</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001118 (user): Do we add a Update(solution, var, new_value) method ?
 &lt;p&gt; &lt;p&gt;(user): Do we want to support Update(solutions, vars, new_values) ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a34cc8829256ea003a3f538b06d3a3a74 "<a class="el" href="namespaceoperations__research_1_1sat.html#a34cc8829256ea003a3f538b06d3a3a74" title="Builds the linear relaxation of a CpModelProto.">operations_research::sat::ComputeLinearRelaxation</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001949 (user): Should we add them to the LP anyway? this isn't clear as
we can sometimes create a lot of Booleans like this. 
 &lt;p&gt; \anchor _todo001950 (user): This is similar to AppendRelaxationForEqualityEncoding() above.
Investigate if we can merge the code. 
 &lt;p&gt; \anchor _todo001951 (user): I am not sure this is still needed. Investigate and explain why
or remove. 
 &lt;p&gt; \anchor _todo001952 (user): compute connected components of the original problem and
split these cuts accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac47959359a009b02531ab19f206cdd54 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac47959359a009b02531ab19f206cdd54">operations_research::sat::ComputeTrueObjectiveLowerBound</a>" (const CpModelProto &amp;model_proto_with_floating_point_objective, const CpObjectiveProto &amp;integer_objective, const int64_t inner_integer_objective_lower_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001970 (user): Code a custom algo with more precision guarantee? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa56689b779202c61f0f782b3e6545e73 "<a class="el" href="namespaceoperations__research_1_1sat.html#aa56689b779202c61f0f782b3e6545e73">operations_research::sat::ConditionalWeightedSumLowerOrEqual</a>" (const std::vector&lt; Literal &gt; &amp;enforcement_literals, const std::vector&lt; IntegerVariable &gt; &amp;vars, const std::vector&lt; int64_t &gt; &amp;coefficients, int64_t upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001746 (user): Delete once Telamon use new function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a08ac4c44a4524b21806a1ae9839bc5bd "<a class="el" href="namespaceoperations__research_1_1sat.html#a08ac4c44a4524b21806a1ae9839bc5bd">operations_research::sat::ConfigureSearchHeuristics</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001776 (user): We might want to restart if external info is available.
Code a custom restart for this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ConstraintPropagationOrder Member \_internalref classoperations__research_1_1sat_1_1ConstraintPropagationOrder#a71728e275e36bbedaaa8007d56131730 "<a class="el" href="classoperations__research_1_1sat_1_1ConstraintPropagationOrder.html#a71728e275e36bbedaaa8007d56131730">operations_research::sat::ConstraintPropagationOrder::NextId</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001927 (user): fix quadratic algo? We can use var_to_ids_func_() to maintain
the degree. But note that with the start_ optim and because we expect
mainly degree zero, this seems to be faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a807f0da8a99a471e809213176132588f "<a class="el" href="namespaceoperations__research_1_1sat.html#a807f0da8a99a471e809213176132588f" title="Constructs a search strategy tailored for the current model.">operations_research::sat::ConstructHeuristicSearchStrategy</a>" (const CpModelProto &amp;cp_model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001411 (user): Implement a routing search.
 &lt;p&gt; \anchor _todo001412 (user): Alternatively, support creation of SatPropagator at positive
level. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a92a908deada7d4dc2b1d0dbfb427e040 "<a class="el" href="namespaceoperations__research_1_1sat.html#a92a908deada7d4dc2b1d0dbfb427e040" title="Constructs an integer completion search strategy.">operations_research::sat::ConstructIntegerCompletionSearchStrategy</a>" (const std::vector&lt; IntegerVariable &gt; &amp;variable_mapping, IntegerVariable objective_var, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001413 (user): we could also fix terms of the objective in the right
direction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab621abdbab919d365ca747aebdd2ff74 "<a class="el" href="namespaceoperations__research_1_1sat.html#ab621abdbab919d365ca747aebdd2ff74" title="Constructs the search strategy specified in the given CpModelProto.">operations_research::sat::ConstructUserSearchStrategy</a>" (const CpModelProto &amp;cp_model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001410 (user): Improve the complexity if this becomes an issue which
may be the case if we do a fixed_search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ContinuousProber Member \_internalref classoperations__research_1_1sat_1_1ContinuousProber#a1e83f97c78745b456678edb911c2147c "<a class="el" href="classoperations__research_1_1sat_1_1ContinuousProber.html#a1e83f97c78745b456678edb911c2147c" title="The model_proto is just used to construct the lists of variable to probe.">operations_research::sat::ContinuousProber::ContinuousProber</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001785 (user): Ideally, we should scan the internal model. But there can be
a large blowup of variables during loading, which slows down the probing
part. Using model variables is a good heuristic to select 'impactful'
Boolean variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ContinuousProber Member \_internalref classoperations__research_1_1sat_1_1ContinuousProber#a1de4d4b22a2717e58b2444683a806d22 "<a class="el" href="classoperations__research_1_1sat_1_1ContinuousProber.html#a1de4d4b22a2717e58b2444683a806d22">operations_research::sat::ContinuousProber::Probe</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001786 (user):
  - sort variables before the iteration (statically or dynamically)
  - compress clause databases regularly (especially the implication graph)
  - better interleaving of the probing and shaving phases
  - move the shaving code directly in the probing class
  - probe all variables and not just the model ones 
 &lt;p&gt; \anchor _todo001787 (user): Probe optional variables. 
 &lt;p&gt; \anchor _todo001788 (user): Currently, the heuristics is that we alternate shaving and
not shaving, unless use_shaving_in_probing_search is false. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac9c41d8a7687386839ef94182e3badb9 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac9c41d8a7687386839ef94182e3badb9">operations_research::sat::ConvertCpModelProtoToMPModelProto</a>" (const CpModelProto &amp;input, MPModelProto *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001962 (user): Support more constraints with enforcement.
 &lt;p&gt; \anchor _todo001969 (user): This first version do not even handle basic Boolean constraint.
Support more constraints as needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2d32bfb7e130364f3dd94087b686b6f5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2d32bfb7e130364f3dd94087b686b6f5">operations_research::sat::ConvertMPModelProtoToCpModelProto</a>" (const SatParameters &amp;params, const MPModelProto &amp;mp_model, CpModelProto *cp_model, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001960 (user): This could be made larger if needed, so be smarter if we have
MIP problem that we cannot "convert" because of this. Note however than we
cannot go that much further because we need to make sure we will not run
into overflow if we add a big linear combination of such variables. It
should always be possible for a user to scale its problem so that all
relevant quantities are a couple of millions. A LP/MIP solver have a
similar condition in disguise because problem with a difference of more
than 6 magnitudes between the variable values will likely run into numeric
trouble. 
 &lt;p&gt; \anchor _todo001961 (user): We could avoid these cases by shifting the domain of
all variables to contain zero. This should also lead to a better scaling,
but it has some complications with integer variables and require some
post-solve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoreBasedOptimizer Member \_internalref classoperations__research_1_1sat_1_1CoreBasedOptimizer#ab0a342f8fad2c4262b0ddec85b98bdf8 "<a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html#ab0a342f8fad2c4262b0ddec85b98bdf8">operations_research::sat::CoreBasedOptimizer::Optimize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001998 (user): Try to understand exactly why and merge both code path. 
 &lt;p&gt; \anchor _todo001999 (user): It might be interesting to redo this kind of presolving
once high cost booleans have been fixed as we might have more at most
one between literal in the objective by then.&lt;p&gt; \anchor _todo002000 (user): The core is returned in the same order as the assumptions,
so we don't really need this map, we could just do a linear scan to
recover which node are part of the core. This however needs to be properly
unit tested before usage. 
 &lt;p&gt; \anchor _todo002001 (user): This always resets the solver to level zero.
Because of that we don't resume a solve in "chunk" perfectly. Fix. 
 &lt;p&gt; \anchor _todo002002 (user): If the search is aborted during this phase and we solve in
"chunk", we don't resume perfectly from where it was. Fix. 
 &lt;p&gt; \anchor _todo002003 (user): These can be simply removed from the list.
 &lt;p&gt; \anchor _todo002004 (user): we could keep an objective offset instead. 
 &lt;p&gt; \anchor _todo002005 (user): We can probably be smarter about the cost of the
assumptions though. 
 &lt;p&gt; \anchor _todo002006 (user): If the "search" is interrupted while computing cores, we
currently do not resume it flawlessly. We however add any cores we found
before aborting. 
 &lt;p&gt; \anchor _todo002007 (user): Maybe the solver should do it right away. 
 &lt;p&gt; \anchor _todo002012 (user): Change the algo slighlty to allow resuming from the last
aborted position. Currently, the search is "resumable", but it will restart
some of the work already done, so it might just never find anything. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoreBasedOptimizer Member \_internalref classoperations__research_1_1sat_1_1CoreBasedOptimizer#a5a4a53c17d32408e49285f11171673fa "<a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html#a5a4a53c17d32408e49285f11171673fa">operations_research::sat::CoreBasedOptimizer::OptimizeWithSatEncoding</a>" (absl::Span&lt; const Literal &gt; literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const Coefficient &gt; coefficients, Coefficient offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001991 (user): We could create EncodingNode out of IntegerVariable.&lt;p&gt; \anchor _todo001992 (user): It could still be beneficial to add one. Experiments. 
 &lt;p&gt; \anchor _todo001993 (user): This might not be ideal if there are holes in the domain.
It should work by adding duplicates literal, but we should be able to
be more efficient. 
 &lt;p&gt; \anchor _todo001994 (user): Find multiple core like in the "main" algorithm. This is just
trying to solve with assumptions not involving the newly found core.&lt;p&gt; \anchor _todo001995 (user): With stratification, sometime we just spend too much time
trying to find a feasible solution/prove infeasibility and we could
instead just use stratification=0 to find easty core and improve lower
bound. 
 &lt;p&gt; \anchor _todo002013 (user):
- Support resuming for interleaved search.
- Implement all core heurisitics. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#a29be1489d397a5d646a838946a85a225 "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#a29be1489d397a5d646a838946a85a225">operations_research::sat::CoverCutHelper::TrySimpleKnapsack</a>" (const CutData &amp;input_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001553 (user): we don't have to pick max_coeff_in_cover and could use the
coefficient of the most fractional variable. Or like in the MIR code try
a few of them. Currently, the cut in the test is worse if we don't take
the max_coeff_in_cover though, so we need more understanding.&lt;p&gt; \anchor _todo001554 (user): It seems we could use a more advanced lifting function
described later in the paper. Investigate. 
 &lt;p&gt; \anchor _todo001555 (user): Experiment without this line that basically disable scoring.
 &lt;p&gt; \anchor _todo001556 (user): experiment with different value of scaling and param t.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#abf54256e1bd003c568c2efd55d75fdd6 "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#abf54256e1bd003c568c2efd55d75fdd6">operations_research::sat::CoverCutHelper::TrySingleNodeFlow</a>" (const CutData &amp;input_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001557 (user): Change the heuristic to depends on the lp_value of the implied
bounds. This way we can exactly match what happen in FlowCoverCutHelper and
remove the code there. 
 &lt;p&gt; \anchor _todo001558 (user): Shouldn't we just use rounding f() with maximum coeff to allows
lift of all other terms? but then except for the heuristic the cut is
really similar to the cover cut. 
 &lt;p&gt; \anchor _todo001559 (user): If the Mir*() function is used, we don't need to extend that
much the period. Fix. 
 &lt;p&gt; \anchor _todo001560 (user): do exact binary search to find highest x in
[-max_neg_magnitude, 0] such that f(x) == f(-max_neg_magnitude) ? not
really needed though since we know that we have this equality: 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#a82f509c2f8c4ea40561f572f6a612ebd "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#a82f509c2f8c4ea40561f572f6a612ebd">operations_research::sat::CoverCutHelper::TryWithLetchfordSouliLifting</a>" (const CutData &amp;input_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001561 (user): Merge Boolean terms that are complement of each other. 
 &lt;p&gt; \anchor _todo001562 (user): we currently only deal with Boolean in the cover. Fix.
 &lt;p&gt; \anchor _todo001563 (user): compute this in an overflow-safe way.
 &lt;p&gt; \anchor _todo001564 (user): For exact multiple of p/q we can increase the coeff by 1/2.
See section in the paper on getting maximal super additive function. 
 &lt;p&gt; \anchor _todo001592 (user): Generalize to non-Boolean, or use a different cover heuristic
for this:
- We want a Boolean only cover currently.
- We can always use implied bound for this, since there is more chance
  for a Bool only cover.
- Also, f() should be super additive on the value &lt;= rhs, i.e. f(a + b) &gt;=
  f(a) + f(b), so it is always good to use implied bounds of the form X =
  bound * B + Slack. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelMapping Member \_internalref classoperations__research_1_1sat_1_1CpModelMapping#a58809f5b0a739fa62cf923b2ed919df5 "<a class="el" href="classoperations__research_1_1sat_1_1CpModelMapping.html#a58809f5b0a739fa62cf923b2ed919df5">operations_research::sat::CpModelMapping::Affine</a>" (const LinearExpressionProto &amp;exp) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001213 (user): We could "easily" create an intermediate variable for more
complex linear expression. We could also identify duplicate expressions to
not create two identical integer variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Class \_internalref classoperations__research_1_1sat_1_1CpModelPresolver "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html">operations_research::sat::CpModelPresolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001403 (user): Identify disconnected components and returns a vector of
presolved model? If we go this route, it may be nicer to store the indices
inside the model. We can add a IntegerVariableProto::initial_index; 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Member \_internalref classoperations__research_1_1sat_1_1CpModelPresolver#a4eea655cfbd484263d86d3d89af42bf5 "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a4eea655cfbd484263d86d3d89af42bf5">operations_research::sat::CpModelPresolver::Presolve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001386 (user): move in the context.
 &lt;p&gt; \anchor _todo001387 (user): We should probably try to delay this even more. For that we
just need to isolate more the "dual" reduction that usually need to look at
the objective. 
 &lt;p&gt; \anchor _todo001388 (user): The presolve transformations we do after this is called might
result in even more presolve if we were to call this again! improve the
code. See for instance plusexample_6_sat.fzn were represolving the
presolved problem reduces it even more. 
 &lt;p&gt; \anchor _todo001389 (user): Make sure we can't have duplicate in these constraint.
These are due to ExpandCpModel() were we create such constraint with
duplicate. The problem is that some code assumes these are presolved
before being called. 
 &lt;p&gt; \anchor _todo001390 (user): Decide where is the best place for this.&lt;p&gt; \anchor _todo001391 (user): try not to break symmetry in our clique extension or other
more advanced presolve rule? Ideally we could even exploit them. But in
this case, it is still good to compute them early. 
 &lt;p&gt; \anchor _todo001392 (user): more generally if we do some probing, the same relation will
be detected (and more). Also add an option to turn this off?&lt;p&gt; \anchor _todo001393 (user): instead of extracting at most one, extract pairwise conflicts
and add them to bool_and clauses? this is some sort of small scale
probing, but good for sat presolve and clique later? 
 &lt;p&gt; \anchor _todo001394 (user): revisit when different transformation appear.
&lt;p&gt; \anchor _todo001395 &lt;p&gt; \anchor _todo001396 (user): merge these code instead of doing many passes? 
 &lt;p&gt; \anchor _todo001397 (user): try to be smarter and avoid looping again if little changed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelView Class \_internalref classoperations__research_1_1sat_1_1CpModelView "<a class="el" href="classoperations__research_1_1sat_1_1CpModelView.html">operations_research::sat::CpModelView</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001425 (user): For now it uses proto indices of the loaded model. We will need
to add a mapping to use proto indices of the non-presolved model to allow for
a client custom search with presolve. The main API shouldn't change though
and the change will be transparent. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af443c47f14a044d69553b02337b5dc52 "<a class="el" href="namespaceoperations__research_1_1sat.html#af443c47f14a044d69553b02337b5dc52">operations_research::sat::CpSolverResponseStats</a>" (const CpSolverResponse &amp;response, bool has_objective)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001426 (user): This is probably better named "binary_propagation", but we just
output "propagations" to be consistent with sat/analyze.sh. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae3fd4466b012022bab0c5c1839c77890 "<a class="el" href="namespaceoperations__research_1_1sat.html#ae3fd4466b012022bab0c5c1839c77890">operations_research::sat::CreateAlternativeLiteralsWithView</a>" (int num_literals, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001933 (user): We shouldn't need to create this view ideally. Even better,
we should be able to handle Literal natively in the linear relaxation,
but that is a lot of work. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a55cafa81679ac10c971927ca17ec7f2e "<a class="el" href="namespaceoperations__research_1_1sat.html#a55cafa81679ac10c971927ca17ec7f2e">operations_research::sat::CreateCumulativeEnergyCutGenerator</a>" (SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands_helper, const AffineExpression &amp;capacity, const std::optional&lt; AffineExpression &gt; &amp;makespan, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002288 (user): use level 0 bounds ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a88677d1180474733727feff2bbca0d31 "<a class="el" href="namespaceoperations__research_1_1sat.html#a88677d1180474733727feff2bbca0d31">operations_research::sat::CreateFlowCutGenerator</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; AffineExpression &gt; &amp;arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002158 (user): Support general linear expression for capacities.
 &lt;p&gt; &lt;p&gt;(user): Some model applies the same capacity to both an arc and its
reverse. Also support this case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5453ae22e516e4fb4216ea56bab9d860 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5453ae22e516e4fb4216ea56bab9d860">operations_research::sat::CreateNoOverlap2dCompletionTimeCutGenerator</a>" (SchedulingConstraintHelper *x_helper, SchedulingConstraintHelper *y_helper, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001603 (user): Use demands_helper and decomposed energy.
 &lt;p&gt; \anchor _todo001604 (user): It might be possible/better to use some shifted value
here, but for now this code is not in the hot spot, so better be
defensive and only do connected components on really disjoint
rectangles. 
 &lt;p&gt; \anchor _todo001605 (user): Use improved energy from demands helper.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae19357ee0ddd4752e39f7bbf6cb3ae05 "<a class="el" href="namespaceoperations__research_1_1sat.html#ae19357ee0ddd4752e39f7bbf6cb3ae05">operations_research::sat::CreateNoOverlap2dEnergyCutGenerator</a>" (SchedulingConstraintHelper *x_helper, SchedulingConstraintHelper *y_helper, SchedulingDemandHelper *x_demands_helper, SchedulingDemandHelper *y_demands_helper, const std::vector&lt; std::vector&lt; LiteralValueValue &gt; &gt; &amp;energies, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001599 (user): It might be possible/better to use some shifted value
here, but for now this code is not in the hot spot, so better be
defensive and only do connected components on really disjoint
rectangles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a28abd2fe9199829f0c98ade48cfe459c "<a class="el" href="namespaceoperations__research_1_1sat.html#a28abd2fe9199829f0c98ade48cfe459c" title="A cut generator for z = x * y (x and y &gt;= 0).">operations_research::sat::CreatePositiveMultiplicationCutGenerator</a>" (AffineExpression z, AffineExpression x, AffineExpression y, int linearization_level, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001573 (user): As the bounds change monotonically, these cuts
dominate any previous one.  try to keep a reference to the cut and
replace it. Alternatively, add an API for a level-zero bound change
callback. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a692069c042245ee1df0d7e2631fe9a39 "<a class="el" href="namespaceoperations__research_1_1sat.html#a692069c042245ee1df0d7e2631fe9a39">operations_research::sat::Cumulative</a>" (const std::vector&lt; IntervalVariable &gt; &amp;vars, const std::vector&lt; AffineExpression &gt; &amp;demands, AffineExpression capacity, SchedulingConstraintHelper *helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001517 (user): Change that since we have optional interval
for this. 
 &lt;p&gt; \anchor _todo001518 (user): We need to exclude intervals that can be of size zero
because the disjunctive do not "ignore" them like the cumulative
does. That is, the interval [2,2) will be assumed to be in
disjunction with [1, 3) for instance. We need to uniformize the
handling of interval with size zero. 
 &lt;p&gt; \anchor _todo001519 (user): Do proper experiments to see how beneficial this is, the
disjunctive will propagate more but is also using slower algorithms.
That said, this is more a question of optimizing the disjunctive
propagation code.&lt;p&gt; \anchor _todo001520 (user): Another "known" idea is to detect pair of tasks that must
be in disjunction and to create a Boolean to indicate which one is
before the other. It shouldn't change the propagation, but may result
in a faster one with smaller explanations, and the solver can also take
decision on such Boolean.&lt;p&gt; \anchor _todo001521 (user): A better place for stuff like this could be in the
presolver so that it is easier to disable and play with alternatives. 
 &lt;p&gt; \anchor _todo001522 (user): Models that include the makespan as a special interval might
be better, but then not everyone does that. In particular this code
allows to have decent lower bound on the large cumulative minizinc
instances.&lt;p&gt; \anchor _todo001523 (user): this require the precedence constraints to be already loaded,
and there is no guarantee of that currently. Find a more robust way.&lt;p&gt; \anchor _todo001524 (user): There is a bit of code duplication with the disjunctive
precedence propagator. Abstract more? 
 &lt;p&gt; \anchor _todo001525 (user): Handle generic affine relation?
 &lt;p&gt; \anchor _todo001526 (user): This can lead to many constraints. By analyzing a bit more
the precedences, we could restrict that. In particular for cases were
the cumulative is always (bunch of tasks B), T, (bunch of tasks A) and
task T always in the middle, we never need to explicit list the
precedence of a task in B with a task in A.&lt;p&gt; \anchor _todo001527 (user): If more than one variable are after the same set of
intervals, we should regroup them in a single constraint rather than
having two independent constraint doing the same propagation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeEnergyConstraint Member \_internalref classoperations__research_1_1sat_1_1CumulativeEnergyConstraint#a1058cbb9c9572113e896f5c7c471eacc "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeEnergyConstraint.html#a1058cbb9c9572113e896f5c7c471eacc">operations_research::sat::CumulativeEnergyConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001528 (user): just keep the current direction? 
 &lt;p&gt; \anchor _todo001529 (user): force capacity_max &gt;= 0, fail/remove optionals when 0.
 &lt;p&gt; \anchor _todo001530 (user): We do not need the capacity max in the reason, but by using
a lower one, we could maybe have propagated more the minimum capacity.
investigate. 
 &lt;p&gt; \anchor _todo001531 (user): This could be done lazily.
&lt;p&gt; \anchor _todo001532 &lt;p&gt; \anchor _todo001533 (user): the same required task can have its energy pruned
several times, making this algorithm O(n^2 log n). Is there a way
to get the best pruning in one go? This looks like edge-finding not
being able to converge in one pass, so it might not be easy. 
 &lt;p&gt; \anchor _todo001534 (user): Improve window_end using envelope of critical event.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeIsAfterSubsetConstraint Class \_internalref classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint.html">operations_research::sat::CumulativeIsAfterSubsetConstraint</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001536 (user): I am not sure this is the best way, but it does at least push
the level zero bound on the large cumulative instances. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeIsAfterSubsetConstraint Member \_internalref classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint#a9d0445b319d93772786a042918c970c2 "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint.html#a9d0445b319d93772786a042918c970c2">operations_research::sat::CumulativeIsAfterSubsetConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001535 (user): actually, we will push using the
last task, and the reason will be non-optimal, fix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af421daf12e0e45a0bb3cc7655cd443cc "<a class="el" href="namespaceoperations__research_1_1sat.html#af421daf12e0e45a0bb3cc7655cd443cc">operations_research::sat::CumulativePrecedenceSearchHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001765 (user): tie-break tasks not fitting in the profile smartly. 
 &lt;p&gt; \anchor _todo001766 (user): If the two box cannot overlap because of high demand, use
repo.CreateDisjunctivePrecedenceLiteral() instead.&lt;p&gt; \anchor _todo001767 (user): Add heuristic ordering for creating interesting precedence
first. 
 &lt;p&gt; \anchor _todo001768 (user): We need to add the reason for demand_min and capacity_max.
&lt;p&gt; \anchor _todo001769 &lt;p&gt; \anchor _todo001770 (user): unfortunately we can't report it from here. 
 &lt;p&gt; \anchor _todo001771 (user): add heuristic criteria, right now we stop at first
one. See above. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CutDataBuilder Member \_internalref classoperations__research_1_1sat_1_1CutDataBuilder#a6c27f24f411983fa4e7333dcadb9fd55 "<a class="el" href="classoperations__research_1_1sat_1_1CutDataBuilder.html#a6c27f24f411983fa4e7333dcadb9fd55" title="Returns false if we encounter an integer overflow.">operations_research::sat::CutDataBuilder::ConvertToLinearConstraint</a>" (const CutData &amp;cut, LinearConstraint *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001537 (user): Divide by gcd first to avoid possible overflow in the
conversion? it is however unlikely given that our coeffs should be small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DebugSolution Member \_internalref structoperations__research_1_1sat_1_1DebugSolution#a75a5eb5425c964642cf9be0cfb6b6c7b "<a class="el" href="structoperations__research_1_1sat_1_1DebugSolution.html#a75a5eb5425c964642cf9be0cfb6b6c7b">operations_research::sat::DebugSolution::ivar_has_value</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001711 (user): When this happen we should be able to infer the value of these
derived variable in the solution. For now, we only do that for the
objective variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DecompositionGraphNeighborhoodGenerator Class \_internalref classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator "<a class="el" href="classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator.html">operations_research::sat::DecompositionGraphNeighborhoodGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001184 (user): Doing the full heuristic treewidth decomposition is probably
better because when we grow the current neighborhood, just using local
connection to the current candidate is probably not enough to orient the
search towards a good final neighborhood. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DecompositionGraphNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator#af329eaefae094534e41a135a9b6443af "<a class="el" href="classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator.html#af329eaefae094534e41a135a9b6443af">operations_research::sat::DecompositionGraphNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, double difficulty, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001174 (user): Does starting by a constraint make sense too? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DelayedRootLevelDeduction Struct \_internalref structoperations__research_1_1sat_1_1DelayedRootLevelDeduction "<a class="el" href="structoperations__research_1_1sat_1_1DelayedRootLevelDeduction.html">operations_research::sat::DelayedRootLevelDeduction</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001705 (user): If we change the logic to not restart right away, we probably
need to remove duplicates bounds for the same variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3423c28a2a00161e74d9c6e0174bcbf6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a3423c28a2a00161e74d9c6e0174bcbf6">operations_research::sat::DetectAndExploitSymmetriesInPresolve</a>" (PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001488 (user): Doing that is not always good, on cod105.mps, fixing variables
instead of letting the innner solver handle Boolean symmetries make the
problem unsolvable instead of easily solved. This is probably because this
fixing do not exploit the full structure of these symmeteries. Note
however that the fixing via propagation above close cod105 even more
efficiently. 
 &lt;p&gt; \anchor _todo001489 (user): The same effect could be achieved by adding symmetry breaking
constraints of the form "a &gt;= b " between Booleans and let the presolve do
the reduction. This might be less code, but it is also less efficient.
Similarly, when we cannot just fix variables to break symmetries, we could
add these constraints, but it is unclear if we should do it all the time or
not.&lt;p&gt; \anchor _todo001490 (user): code the generic approach with orbits and stabilizer. 
 &lt;p&gt; \anchor _todo001491 (user): generalize somehow. See if we can exploit this in
lb_tree_search directly. We also have a lot more structure than just the
objective can be ordered. Like if the objective is a max, we can still do
that.&lt;p&gt; \anchor _todo001492 (user): Actually the constraint we add is really just breaking the
orbitope symmetry on one line. But this line being the objective is key. We
can also explicitly look for a full permutation group of the objective
terms directly instead of finding the largest orbitope first. 
 &lt;p&gt; \anchor _todo001493 (user): Compute the stabilizer under the only non-fixed element and
iterate! 
 &lt;p&gt; \anchor _todo001494 (user): The code below requires that no variable appears twice in the
same at most one. In particular lit and not(lit) cannot appear in the same
at most one. 
 &lt;p&gt; \anchor _todo001495 (user): for 2/ and 3/ we could add an at most one constraint on the
full orbit if it is not already there!&lt;p&gt; \anchor _todo001496 (user): maybe we should simplify the constraint using the variable
we fix before choosing the next row to break symmetry on. If there are
multiple row involved, we could also take the intersection instead of
probably counting the same constraints more than once. 
 &lt;p&gt; \anchor _todo001497 (user): We could remove these rows from the orbitope. Note that
currently this never happen on the miplib (maybe in LNS though). 
 &lt;p&gt; \anchor _todo001498 (user): We don't have any at most one relation on this orbitope,
but we could still add symmetry breaking inequality by picking any matrix
entry and making it the largest/lowest value on its row. This also work
for non-Booleans. 
 &lt;p&gt; \anchor _todo001499 (user): All choices should be equivalent, but double check? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a753e3aea07903c667891eb57036d26de "<a class="el" href="namespaceoperations__research_1_1sat.html#a753e3aea07903c667891eb57036d26de">operations_research::sat::DetectImpliedIntegers</a>" (MPModelProto *mp_model, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001957 (user): be smarter! we should be able to handle these cases.
 &lt;p&gt; \anchor _todo001958 (user): If we scale more we migth be able to turn it into an
integer. 
 &lt;p&gt; \anchor _todo001968 (user): Actually implement the offset part. This currently only happens
on the 3 neos-46470* miplib problems where we have a non-integer rhs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a825c5b32096a00edc3e2e3fd78c7d541 "<a class="el" href="namespaceoperations__research_1_1sat.html#a825c5b32096a00edc3e2e3fd78c7d541">operations_research::sat::DetectMakespan</a>" (const std::vector&lt; IntervalVariable &gt; &amp;intervals, const std::vector&lt; AffineExpression &gt; &amp;demands, const AffineExpression &amp;capacity, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001934 (user): Supports variable capacity.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3216f11aeb59c8cd63d2a1e8cdc6d47b "<a class="el" href="namespaceoperations__research_1_1sat.html#a3216f11aeb59c8cd63d2a1e8cdc6d47b" title="Automatically detect optional variables.">operations_research::sat::DetectOptionalVariables</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001204 (user): This deals with the simplest cases, but we could try to
detect literals that implies all the constraints in which a variable
appear to false. This can be done with a LCA computation in the tree of
Boolean implication (once the presolve remove cycles). Not sure if we can
properly exploit that afterwards though. Do some research! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a33798fe85208035f149a5c124b89b7b4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a33798fe85208035f149a5c124b89b7b4">operations_research::sat::DisjunctivePrecedenceSearchHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001761 (user): tie break by size/start-max
&lt;p&gt; \anchor _todo001762 &lt;p&gt; \anchor _todo001763 (user): Use conditional lower bounds? note that in automatic search
all precedence will be fixed before this is called though. In fixed
search maybe we should use the other SchedulingSearchHeuristic(). 
 &lt;p&gt; \anchor _todo001764 (Fdid): Also compare the second part of the precedence in
PrecedenceIsBetter() and not just the interval before? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DisjunctiveWithTwoItems Member \_internalref classoperations__research_1_1sat_1_1DisjunctiveWithTwoItems#aded29605fb1b5e0a55697fabdc9797ae "<a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveWithTwoItems.html#aded29605fb1b5e0a55697fabdc9797ae">operations_research::sat::DisjunctiveWithTwoItems::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001612 (user): For optional interval whose presence in unknown and without
optional variable, the end-min may not be propagated to at least (start_min
+ size_min). Consider that into the computation so we may decide the
interval forced absence? Same for the start-max. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DivisionPropagator Class \_internalref classoperations__research_1_1sat_1_1DivisionPropagator "<a class="el" href="classoperations__research_1_1sat_1_1DivisionPropagator.html">operations_research::sat::DivisionPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001743 (user): Deal with overflow. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DivisionPropagator Member \_internalref classoperations__research_1_1sat_1_1DivisionPropagator#ac89f35a696a3d291bfafae382a1332ca "<a class="el" href="classoperations__research_1_1sat_1_1DivisionPropagator.html#ac89f35a696a3d291bfafae382a1332ca">operations_research::sat::DivisionPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001737 (user): We can propagate more, especially in the case where denom
spans across 0.
 &lt;p&gt; &lt;p&gt;(user): We can propagate a bit more if min_div = 0:
    (min_num &gt; -min_denom). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DomainDeductions Class \_internalref classoperations__research_1_1sat_1_1DomainDeductions "<a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html">operations_research::sat::DomainDeductions</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002116 (user): Also use these "deductions" in the solver directly. This is done
in good MIP solvers, and we should exploit them more.&lt;p&gt; \anchor _todo002117 (user): Also propagate implicit clauses (lit, not(lit)). Maybe merge
that with probing code? it might be costly to store all deduction done by
probing though, but I think this is what MIP solver do. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DomainDeductions Member \_internalref classoperations__research_1_1sat_1_1DomainDeductions#a90eec97bf72d63f4c921156b3f31c5a4 "<a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html#a90eec97bf72d63f4c921156b3f31c5a4">operations_research::sat::DomainDeductions::ProcessClause</a>" (absl::Span&lt; const int &gt; clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002120 (user): We could probably be even more efficient. We could also
compute exactly what clauses need to be "waked up" as new deductions are
added. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DratProofHandler Member \_internalref classoperations__research_1_1sat_1_1DratProofHandler#a024232f8972a7dcb6cbf91ec8fe36fb0 "<a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html#a024232f8972a7dcb6cbf91ec8fe36fb0">operations_research::sat::DratProofHandler::ApplyMapping</a>" (const absl::StrongVector&lt; BooleanVariable, BooleanVariable &gt; &amp;mapping)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001633 (user): This is exactly the same mecanism as in the SatPostsolver
class. Factor out the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Class \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html">operations_research::sat::DualBoundStrengthening</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002394 (user): This is actually an important step to do before scaling as it can
usually reduce really large bounds! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Member \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening#aa3f78681f549714a6bcfabc007aa985d "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html#aa3f78681f549714a6bcfabc007aa985d" title="All constraints should be mapped to one of more call to these functions.">operations_research::sat::DualBoundStrengthening::CannotDecrease</a>" (absl::Span&lt; const int &gt; refs, int ct_index=-1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002377 (user): No need to set locking_ct_index_[var] if num_locks_[var] &gt; 1
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Member \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening#a162bcb064138a579ee8192ffb9c244cb "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html#a162bcb064138a579ee8192ffb9c244cb">operations_research::sat::DualBoundStrengthening::Strengthen</a>" (PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002378 (user): Cover all the cases. 
 &lt;p&gt; \anchor _todo002379 (user): Fix variable right away rather than waiting for next call.
 &lt;p&gt; \anchor _todo002380 (user): We can also deal with more than one enforcement. 
 &lt;p&gt; \anchor _todo002381 (user): Generalize to non-Boolean. Also for Boolean, we might
miss some possible reduction if replacing X by 1 - X make a constraint
near-duplicate of another.&lt;p&gt; \anchor _todo002382 (user): We can generalize to non-linear constraint.&lt;p&gt; \anchor _todo002383 (user): Make sure implication graph is transitively reduced to not
miss such reduction. More generally, this might only use the graph rather
than the encoding into bool_and / at_most_one ? Basically if a =&gt;
all_direct_deduction, we can transform it into a &lt;=&gt; all_direct_deduction
if that is interesting. This could always be done on a max-2sat problem
in one of the two direction. Also think about max-2sat specific presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::EncodingNode Member \_internalref classoperations__research_1_1sat_1_1EncodingNode#a4db8bdd99cd1c21623273512082cd8a6 "<a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html#a4db8bdd99cd1c21623273512082cd8a6">operations_research::sat::EncodingNode::GenericNode</a>" (int lb, int ub, std::function&lt; Literal(int x)&gt; create_lit, Coefficient weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001635 (user): Not ideal, we should probably just provide index in the
original objective for sorting purpose. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::EncodingNode Member \_internalref classoperations__research_1_1sat_1_1EncodingNode#a93fd5b911e64c63ed4b1b32dc42a571d "<a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html#a93fd5b911e64c63ed4b1b32dc42a571d" title="Indicate that the node cannot grow further than its current assumption.">operations_research::sat::EncodingNode::TransformToBoolean</a>" (SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001636 (user): Avoid creating a Boolean just to fix it!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac32fa78e911692fae246c73675cc3970 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac32fa78e911692fae246c73675cc3970">operations_research::sat::ExactlyOnePerRowAndPerColumn</a>" (const std::vector&lt; std::vector&lt; Literal &gt; &gt; &amp;graph)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001070 (user): Change to a sparse API like for the function above.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a265b8cf37f58fb2c78b247a6412ce519 "<a class="el" href="namespaceoperations__research_1_1sat.html#a265b8cf37f58fb2c78b247a6412ce519">operations_research::sat::ExploitDominanceRelations</a>" (const VarDomination &amp;var_domination, PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002390 (user): More generally, combine with probing? if a dominated
variable implies one of its dominant to zero, then it can be set to
zero. It seems adding the implication below should have the same
effect? but currently it requires a lot of presolve rounds. 
 &lt;p&gt; \anchor _todo002391 (user): if both variable are in a bool_or, this will allow us to
remove the dominated variable. Maybe we should exploit that to decide
which implication we add. Or just remove such variable and not add the
implications?&lt;p&gt; \anchor _todo002392 (user): generalize to non Booleans? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a97b2ab4ecaa7da4d40522982c3e221e4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a97b2ab4ecaa7da4d40522982c3e221e4">operations_research::sat::ExtractAllSubsetsFromForest</a>" (const std::vector&lt; int &gt; &amp;parent, std::vector&lt; int &gt; *subset_data, std::vector&lt; absl::Span&lt; const int &gt; &gt; *subsets, int node_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002157 (user): This also allocate O(n) memory internally, we could reuse it from
call to call if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a89efb582832622f508e29d0c32f56ca9 "<a class="el" href="namespaceoperations__research_1_1sat.html#a89efb582832622f508e29d0c32f56ca9">operations_research::sat::ExtractElementEncoding</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001201 (user): It should be safe otherwise the exactly_one will have
duplicate literal, but I am not sure that if presolve is off we can
assume that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afa73e23a5cfae0eaf253c2e2518e05e7 "<a class="el" href="namespaceoperations__research_1_1sat.html#afa73e23a5cfae0eaf253c2e2518e05e7">operations_research::sat::ExtractEncoding</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001193 (user): Regroup/presolve two encoding like b =&gt; x &gt; 2 and the same
Boolean b =&gt; x &gt; 5. These shouldn't happen if we merge linear constraints. 
 &lt;p&gt; \anchor _todo001194 (user): Debug what makes it unsat at this point.
 &lt;p&gt; \anchor _todo001195 (user): We will re-add the same implied bounds during probing, so
it might not be necessary to do that here. Also, it might be too early
if some of the literal view used in the LP are created later, but that
should be fixable via calls to implied_bounds-&gt;NotifyNewIntegerView(). 
 &lt;p&gt; \anchor _todo001196 (user): In these cases, we could fix the enforcement literal right
away or ignore the constraint. Note that it will be done later anyway
though. 
 &lt;p&gt; \anchor _todo001197 (user): Fully encode variable that are almost fully encoded? 
 &lt;p&gt; \anchor _todo001198 (user): Try to remove it. Normally we caught UNSAT above, but
tests are very flaky (it only happens in parallel). Keeping it there for
the time being. 
 &lt;p&gt; \anchor _todo001199 (user): delay this after PropagateEncodingFromEquivalenceRelations()?
Otherwise we might create new Boolean variables for no reason. Note
however, that in the presolve, we should only use the "representative" in
linear constraints, so we should be fine. 
 &lt;p&gt; \anchor _todo001200 (user): It is not 100% clear what is the best encoding and if
we should create equivalent literal or rely on propagator instead
to push bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac9d08e5135a1ae71b571b14fbff3381b "<a class="el" href="namespaceoperations__research_1_1sat.html#ac9d08e5135a1ae71b571b14fbff3381b">operations_research::sat::FailedLiteralProbingRound</a>" (ProbingOptions options, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002127 (user): Instead of minimizing index in topo order (which might be
nice for binary extraction), we could try to maximize reusability in
some way. 
 &lt;p&gt; \anchor _todo002128 (user): Can we be smarter here? Maybe we can still fix the
literal without going back to level zero by simply enqueuing it with
no reason? it will be backtracked over, but we will still lazily fix
it later. 
 &lt;p&gt; \anchor _todo002129 (user): We could be slightly more generic and subsume some
clauses that do not contains last_decision.Negated(). 
 &lt;p&gt; \anchor _todo002130 (user): Think about trying to extract clause that will not
get removed by transitive reduction later. If we can both extract
a =&gt; c and b =&gt; c , ideally we don't want to extract a =&gt; c first
if we already know that a =&gt; b.&lt;p&gt; \anchor _todo002131 (user): Similar to previous point, we could find the LCA
of all literals in the reason for this propagation. And use this
as a reason for later hyber binary resolution. Like we do when
this clause subsume the reason. 
 &lt;p&gt; \anchor _todo002132 (user): We might just want to do that even more lazily by
checking for detached clause while propagating here? and do a big
cleanup at the end. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FeasibilityJumpSolver Class \_internalref classoperations__research_1_1sat_1_1FeasibilityJumpSolver "<a class="el" href="classoperations__research_1_1sat_1_1FeasibilityJumpSolver.html">operations_research::sat::FeasibilityJumpSolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001654 (user): If we have more than one of these solver, we might want to share
the evaluator memory between them. Right now we basically keep a copy of the
model and its transpose for each FeasibilityJumpSolver. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FeasibilityJumpSolver Member \_internalref classoperations__research_1_1sat_1_1FeasibilityJumpSolver#adc255845d619b5cf9077d19faecb8762 "<a class="el" href="classoperations__research_1_1sat_1_1FeasibilityJumpSolver.html#adc255845d619b5cf9077d19faecb8762">operations_research::sat::FeasibilityJumpSolver::GenerateTask</a>" (int64_t) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001645 (user): Tune the improvement constant, maybe use luby.
 &lt;p&gt; \anchor _todo001646 (user): Ideally batch should use deterministic time too so we
can just use number of batch for the luby restart.
&lt;p&gt; \anchor _todo001647 &lt;p&gt; \anchor _todo001648 (user): Maybe have one worker with very low restart
rate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a300f624fabbec583376b6e87dcb6fbda "<a class="el" href="namespaceoperations__research_1_1sat.html#a300f624fabbec583376b6e87dcb6fbda">operations_research::sat::FillSolveStatsInResponse</a>" (Model *model, CpSolverResponse *response)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002328 (user): find a way to clear all stats fields that might be set by
one of the callback. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a76d6dd44958673bb83ac31e970539135 "<a class="el" href="namespaceoperations__research_1_1sat.html#a76d6dd44958673bb83ac31e970539135">operations_research::sat::FindBestScalingAndComputeErrors</a>" (const std::vector&lt; double &gt; &amp;coefficients, const std::vector&lt; double &gt; &amp;lower_bounds, const std::vector&lt; double &gt; &amp;upper_bounds, int64_t max_absolute_activity, double wanted_absolute_activity_precision, double *relative_coeff_error, double *scaled_sum_error)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001959 (user): Make this faster. 
 &lt;p&gt; \anchor _todo001966 (user): unit test this and move to fp_utils.
 &lt;p&gt; &lt;p&gt;(user): Ideally the lower/upper should be int64_t so that we can have
an exact definition for the max_absolute_activity allowed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae16bafcf3c5377ed905021a96f93bdcf "<a class="el" href="namespaceoperations__research_1_1sat.html#ae16bafcf3c5377ed905021a96f93bdcf">operations_research::sat::FindCpModelSymmetries</a>" (const SatParameters &amp;params, const CpModelProto &amp;problem, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators, double deterministic_limit, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001487 (user): Change the API to not return an error when the time limit is
reached. 
 &lt;p&gt; \anchor _todo001513 (user): On SAT problems it is more powerful to detect permutations also
involving the negation of the problem variables. So that we could find a
symmetry x &lt;-&gt; not(y) for instance.&lt;p&gt; \anchor _todo001514 (user): As long as we only exploit symmetry involving only Boolean
variables we can make this code more efficient by not detecting symmetries
involing integer variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2e4999dc16f55afa8c5d30a733a26e3d "<a class="el" href="namespaceoperations__research_1_1sat.html#a2e4999dc16f55afa8c5d30a733a26e3d">operations_research::sat::FindDuplicateConstraints</a>" (const CpModelProto &amp;model_proto, bool ignore_enforcement)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001398 (user): we could delete duplicate identical interval, but we need
to make sure reference to them are updated. 
 &lt;p&gt; \anchor _todo001399 (user): This is not particularly efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a75271e8da6c6cb4c5c87226e150d47d7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a75271e8da6c6cb4c5c87226e150d47d7">operations_research::sat::FindLinearBooleanProblemSymmetries</a>" (const LinearBooleanProblem &amp;problem, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001058 (user): inject the appropriate time limit here.
 &lt;p&gt; \anchor _todo001059 (user): Remove them beforehand? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7492392221bdfcc832cce2d93c9b681c "<a class="el" href="namespaceoperations__research_1_1sat.html#a7492392221bdfcc832cce2d93c9b681c" title="Returns a stable fingerprint of a model.">operations_research::sat::FingerprintModel</a>" (const CpModelProto &amp;model, uint64_t seed=kDefaultFingerprintSeed)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001515 (user): Should we fingerprint decision strategies?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FirstFewValues Class \_internalref classoperations__research_1_1sat_1_1FirstFewValues "operations_research::sat::FirstFewValues&lt; n &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002367 (user): Maybe modulo some prime number we can keep more info.
 &lt;p&gt; &lt;p&gt;(user): Another common case is a bunch of really small values and larger
ones, so we could bound the sum of the small values and keep the first few
reachable by the big ones. This is similar to some presolve transformations. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FirstFewValues Member \_internalref classoperations__research_1_1sat_1_1FirstFewValues#afb10d079fe78aa99d7256c85f6d24bde "<a class="el" href="classoperations__research_1_1sat_1_1FirstFewValues.html#afb10d079fe78aa99d7256c85f6d24bde">operations_research::sat::FirstFewValues&lt; n &gt;::Add</a>" (const int64_t positive_value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002372 (user): Implement Add() with an upper bound on the multiplicity. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8c72a9619e1961d1434170437536cff6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8c72a9619e1961d1434170437536cff6">operations_research::sat::FirstUnassignedVarAtItsMinHeuristic</a>" (const std::vector&lt; IntegerVariable &gt; &amp;vars, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001752 (user): the complexity caused by the linear scan in this heuristic and
the one below is ok when search_branching is set to SAT_SEARCH because it is
not executed often, but otherwise it is done for each search decision,
which seems expensive. Improve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a392d70cc768a13de271f87123513acf2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a392d70cc768a13de271f87123513acf2" title="The argument must be non-negative.">operations_research::sat::FloorSquareRoot</a>" (int64_t a)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002359 (user): Find better implementation? In pratice passing via double is
almost always correct, but the CapProd() might be a bit slow. However this
is only called when we do propagate something. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FlowCoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1FlowCoverCutHelper#af7fca0dc3ced6d077248ca695664ec7c "<a class="el" href="classoperations__research_1_1sat_1_1FlowCoverCutHelper.html#af7fca0dc3ced6d077248ca695664ec7c">operations_research::sat::FlowCoverCutHelper::GenerateCut</a>" (const SingleNodeFlow &amp;data)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001581 (user): Support int128 demand.
 &lt;p&gt; \anchor _todo001582 (user): Also try to generate the extended generalized flow cover
inequality (EGFCI). 
 &lt;p&gt; \anchor _todo001583 (user): Lift the cut.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FlowInfo Struct \_internalref structoperations__research_1_1sat_1_1FlowInfo "<a class="el" href="structoperations__research_1_1sat_1_1FlowInfo.html">operations_research::sat::FlowInfo</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001587 (user): cover case 3/. We loose a lot of relaxation here, except if
the variable is at is upper/lower bound.&lt;p&gt; \anchor _todo001588 (user): Altough the cut should still be correct, we might use the same
Boolean more than once in the implied bound. Or this Boolean might already
appear in the constraint. Not sure if we can do something smarter here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FlowInfo Member \_internalref structoperations__research_1_1sat_1_1FlowInfo#aa410b7d167f57e67a443c0adc2c6db20 "<a class="el" href="structoperations__research_1_1sat_1_1FlowInfo.html#aa410b7d167f57e67a443c0adc2c6db20">operations_research::sat::FlowInfo::flow_lp_value</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001591 (user): We don't use this in the heuristic currently.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a36bf1351ffa74960b3040a96ddc37468 "<a class="el" href="namespaceoperations__research_1_1sat.html#a36bf1351ffa74960b3040a96ddc37468">operations_research::sat::FullyCompressTuples</a>" (absl::Span&lt; const int64_t &gt; domain_sizes, std::vector&lt; std::vector&lt; int64_t &gt; &gt; *tuples)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002363 (user): We can probably reuse the tuples memory always and never create
new one. We should also be able to code an iterative version of this. Note
however that the recursion level is bounded by the number of coluns which
should be small. 
 &lt;p&gt; \anchor _todo002368 (user): To reduce memory, we could return some absl::Span in the last
layer instead of vector.&lt;p&gt; \anchor _todo002369 (user): The final compression is depend on the order of the variables.
For instance the table (1,1)(1,2)(1,3),(1,4),(2,3) can either be compressed
as (1,*)(2,3) or (1,{1,2,4})({1,3},3). More experiment are needed to devise
a better heuristic. It might for example be good to call CompressTuples()
first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a40a7dc0d395ce5d73a04705001e71627 "<a class="el" href="namespaceoperations__research_1_1sat.html#a40a7dc0d395ce5d73a04705001e71627">operations_research::sat::GenerateCompletionTimeCutsWithEnergy</a>" (const std::string &amp;cut_name, std::vector&lt; CtEvent &gt; events, IntegerValue capacity_max, bool skip_low_sizes, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002290 (user): merge with Packing cuts. 
 &lt;p&gt; \anchor _todo002291 (user): Check overflow and ignore if too big.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5639ced88667030a20e68a36dc849a43 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5639ced88667030a20e68a36dc849a43">operations_research::sat::GenerateCumulativeEnergeticCuts</a>" (const std::string &amp;cut_name, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; EnergyEvent &gt; events, const AffineExpression &amp;capacity, TimeLimit *time_limit, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002287 (user): We could reduce this set. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a6517c71e66173c1ac5c27bad82353081 "<a class="el" href="namespaceoperations__research_1_1sat.html#a6517c71e66173c1ac5c27bad82353081">operations_research::sat::GenerateCumulativeEnergeticCutsWithMakespanAndFixedCapacity</a>" (absl::string_view cut_name, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; EnergyEvent &gt; events, IntegerValue capacity, AffineExpression makespan, TimeLimit *time_limit, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002284 (user): We could reduce this set.
&lt;p&gt; \anchor _todo002285 &lt;p&gt; \anchor _todo002286 (user): we can compute the max usage between makespan_min and
   makespan_max. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af2a840612629fd37d42870c23e183609 "<a class="el" href="namespaceoperations__research_1_1sat.html#af2a840612629fd37d42870c23e183609">operations_research::sat::GenerateGraphForSymmetryDetection</a>" (const LinearBooleanProblem &amp;problem, std::vector&lt; int &gt; *initial_equivalence_classes)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001057 (user): reserve the memory for the graph? not sure it is worthwhile
since it would require some linear scan of the problem though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aef4b159d28945ac73ef965c2db5c18d5 "<a class="el" href="namespaceoperations__research_1_1sat.html#aef4b159d28945ac73ef965c2db5c18d5">operations_research::sat::GenerateNoOvelap2dCompletionTimeCutsWithEnergy</a>" (absl::string_view cut_name, std::vector&lt; DiffnCtEvent &gt; events, bool use_lifting, bool skip_low_sizes, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001600 (user): merge with Packing cuts. 
 &lt;p&gt; \anchor _todo001601 (user): Use dynamic programming to compute all possible values for
the sum of demands as long as the involved numbers are small or the
number of tasks are small. 
 &lt;p&gt; \anchor _todo001602 (user): Check overflow and ignore if too big.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a53c4d8406e1afd37e5a99ed333207f32 "<a class="el" href="namespaceoperations__research_1_1sat.html#a53c4d8406e1afd37e5a99ed333207f32">operations_research::sat::GenerateShortCompletionTimeCutsWithExactBound</a>" (const std::string &amp;cut_name, std::vector&lt; CtEvent &gt; events, IntegerValue capacity_max, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002289 (user): Improve performance
  - detect disjoint tasks (no need to crossover to the second part)
  - better caching of explored states 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Class \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">operations_research::sat::GenericLiteralWatcher</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001707 (user): Move this to its own file. Add unit tests! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#ad53c31fda5130ffda98dbb242faf3145 "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#ad53c31fda5130ffda98dbb242faf3145">operations_research::sat::GenericLiteralWatcher::GenericLiteralWatcher</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001700 (user): This propagator currently needs to be last because it is the
only one enforcing that a fix-point is reached on the integer variables.
Figure out a better interaction between the sat propagation loop and
this one. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#a23370d30fab5bc955f314d3ced9add4a "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#a23370d30fab5bc955f314d3ced9add4a">operations_research::sat::GenericLiteralWatcher::Propagate</a>" (Trail *trail) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001701 (user): The queue will not be emptied, but I am not sure the solver
will be left in an usable state. Fix if it become needed to resume
the solve from the last time it was interrupted. In particular, we might
want to call UpdateCallingNeeds()? 
 &lt;p&gt; \anchor _todo001702 (user): Maybe just provide one function Propagate(watch_indices) ?
 &lt;p&gt; \anchor _todo001703 (user): However, on some problem, it seems to work better to not
do that. One possible reason is that the reason of a "natural"
propagation might be better than one we learned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#ab3993b47fa18e5a83198e062ded08bb7 "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#ab3993b47fa18e5a83198e062ded08bb7" title="Registers a propagator and returns its unique ids.">operations_research::sat::GenericLiteralWatcher::Register</a>" (PropagatorInterface *propagator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001704 (user): This initial propagation does not respect any later priority
settings. Fix this. Maybe we should force users to pass the priority at
registration. For now I didn't want to change the interface because there
are plans to implement a kind of "dynamic" priority, and if it works we may
want to get rid of this altogether. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5da173a94bec567c831df465aae5c5e4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5da173a94bec567c831df465aae5c5e4">operations_research::sat::GetDiverseSetOfParameters</a>" (const SatParameters &amp;base_params, const CpModelProto &amp;cp_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001416 (user): For scheduling, this is important to find good first solution
but afterwards it is not really great and should probably be replaced by a
LNS worker. 
 &lt;p&gt; \anchor _todo001417 (user): Avoid launching two strategies if they are the same,
like if there is no lp, or everything is already linearized at level 1. 
 &lt;p&gt; \anchor _todo001418 (user): Enable probing_search in deterministic mode.
Currently it timeouts on small problems as the deterministic time limit
never hits the sharding limit. 
 &lt;p&gt; \anchor _todo001419 (user): Enable shaving search in interleave mode.
Currently it do not respect ^C, and has no per chunk time limit. 
 &lt;p&gt; \anchor _todo001420 (user): Enable lb_tree_search in deterministic mode. 
 &lt;p&gt; \anchor _todo001421 (user): Find a better randomization for the seed so that changing
random_seed() has more impact? 
 &lt;p&gt; \anchor _todo001422 (user): Actually make sure the gap num_workers &lt;-&gt; num_heuristics is
contained. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aac3a6347c9f942af0cdca5180a9da297 "<a class="el" href="namespaceoperations__research_1_1sat.html#aac3a6347c9f942af0cdca5180a9da297">operations_research::sat::GetNamedParameters</a>" (const SatParameters &amp;base_params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001414 (user): Do more experiments, the LP with core could be useful, but we
probably need to incorporate the newly created integer variables from the
core algorithm into the LP. 
 &lt;p&gt; \anchor _todo001415 (user): Experiment with search_random_variable_pool_size.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa8cc7ff53b39b6a28e821bc428dcb331 "<a class="el" href="namespaceoperations__research_1_1sat.html#aa8cc7ff53b39b6a28e821bc428dcb331">operations_research::sat::GetOrbits</a>" (int n, absl::Span&lt; const std::unique_ptr&lt; SparsePermutation &gt; &gt; generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002326 (user): We could reuse the internal memory if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afa1020b89b12f653b1ea0dd0d595557e "<a class="el" href="namespaceoperations__research_1_1sat.html#afa1020b89b12f653b1ea0dd0d595557e">operations_research::sat::GetSuperAdditiveRoundingFunction</a>" (IntegerValue rhs_remainder, IntegerValue divisor, IntegerValue t, IntegerValue max_scaling)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001538 (user): Use everywhere a two step computation to avoid overflow?
First divide by divisor, then multiply by t. For now, we limit t so that
we never have an overflow instead. 
 &lt;p&gt; \anchor _todo001539 (user): This function is not always maximal when
size % (max_scaling - 1) == 0. Improve? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7876cef7b031a084f24b5c5898c9710c "<a class="el" href="namespaceoperations__research_1_1sat.html#a7876cef7b031a084f24b5c5898c9710c">operations_research::sat::GetSuperAdditiveStrengtheningFunction</a>" (IntegerValue positive_rhs, IntegerValue min_magnitude)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001540 (user): Limit the number of value used with scaling like above. 
 &lt;p&gt; \anchor _todo001541 (user): we might want to intoduce some step to reduce the final
magnitude of the cut. 
 &lt;p&gt; \anchor _todo001589 (user): Extend it for ci &gt;= max_magnitude, we can probaly "lift" such
coefficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a20a09de9399643ba3302d007c4663ea2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a20a09de9399643ba3302d007c4663ea2">operations_research::sat::GetWorkSharingParams</a>" (const SatParameters &amp;base_params, const CpModelProto &amp;cp_model, int num_params_to_generate)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001423 (user): We could support assumptions, it's just not implemented.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfDetector Class \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector.html">operations_research::sat::GreaterThanAtLeastOneOfDetector</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002078 (user): Shall we do that on the main thread before the workers are
spawned? note that the probing version need the model to be loaded though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfDetector Member \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector#a54971ccb8359a6ce699b946840ac5b0a "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector.html#a54971ccb8359a6ce699b946840ac5b0a">operations_research::sat::GreaterThanAtLeastOneOfDetector::AddGreaterThanAtLeastOneOfConstraints</a>" (Model *model, bool auto_detect_clauses=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002074 (user): Do more extensive experiment. Remove the second approach as
it is more time consuming? or identify when it make sense. Note that the
first approach also allows to use "incomplete" at least one between arcs. 
 &lt;p&gt; \anchor _todo002075 (user): This does not take into account clause of size 2 since they
are stored in the BinaryImplicationGraph instead. Some ideas specific
to size 2:
- There can be a lot of such clauses, but it might be nice to consider
  them. we need to experiments.
- The automatic clause detection might be a better approach and it
  could be combined with probing. 
 &lt;p&gt; \anchor _todo002090 (user): This can be quite slow, add some kind of deterministic limit
so that we can use it all the time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfPropagator Member \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator#a3b3ae77e1959c1da3c086669f8c28062 "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator.html#a3b3ae77e1959c1da3c086669f8c28062">operations_research::sat::GreaterThanAtLeastOneOfPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001121 (user): In case of a conflict, we could push one of them to false if
it is the only one. 
 &lt;p&gt; \anchor _todo001122 (user): This could be optimized by keeping more info from the last
Propagate() calls. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af6433b3a01c71cd754d3d710f345b4c0 "<a class="el" href="namespaceoperations__research_1_1sat.html#af6433b3a01c71cd754d3d710f345b4c0">operations_research::sat::GreedyFastDecreasingGcd</a>" (const absl::Span&lt; const int64_t &gt; coeffs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001609 (user): The following is a heuristic to make drop the GCD as fast
as possible. It might be suboptimal in general (as we could miss two
coprime coefficients for instance). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::HittingSetOptimizer Class \_internalref classoperations__research_1_1sat_1_1HittingSetOptimizer "<a class="el" href="classoperations__research_1_1sat_1_1HittingSetOptimizer.html">operations_research::sat::HittingSetOptimizer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001981 (user): This class requires linking with the SCIP MIP solver which is
quite big, maybe we should find a way not to do that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::HittingSetOptimizer Member \_internalref classoperations__research_1_1sat_1_1HittingSetOptimizer#a82f11613372a6a2909c2dc75bcd6216b "<a class="el" href="classoperations__research_1_1sat_1_1HittingSetOptimizer.html#a82f11613372a6a2909c2dc75bcd6216b">operations_research::sat::HittingSetOptimizer::Optimize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001973 (user): remove code duplication with MinimizeWithCoreAndLazyEncoding(); 
 &lt;p&gt; \anchor _todo001974 (user): Even though we keep the same solver, currently the solve is
not really done incrementally. It might be hard to improve though.&lt;p&gt; \anchor _todo001975 (user): deal with time limit. 
 &lt;p&gt; \anchor _todo001976 (user): C^c is broken when using SCIP.
 &lt;p&gt; \anchor _todo001977 (user): It is actually easy to use a FEASIBLE result. If when
passing it to SAT it is no feasbile, we can still create cores. If it
is feasible, we have a solution, but we cannot increase the lower
bound. 
 &lt;p&gt; \anchor _todo001978 (user): Use the real weights and exploit the extra cores.
&lt;p&gt; \anchor _todo001979 &lt;p&gt; \anchor _todo001980 (user): If we extract more than the objective variables, we could
use the solution values from the MPModel as hints to the SAT model. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5ca12ac764578209e7eaa692a9029635 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5ca12ac764578209e7eaa692a9029635">operations_research::sat::Implication</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, IntegerLiteral i)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001708 (user): This is one of the rare case where it is better to use Equality()
rather than two Implications(). Maybe we should modify our internal
implementation to use half-reified encoding? that is do not propagate the
direction integer-bound =&gt; literal, but just literal =&gt; integer-bound? This
is the same as using different underlying variable for an integer literal and
its negation. 
 &lt;p&gt; \anchor _todo001709 (user): Double check what happen when we associate a trivially
true or false literal. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Class \_internalref classoperations__research_1_1sat_1_1ImpliedBounds "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html">operations_research::sat::ImpliedBounds</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001670 (user): This can quickly use up too much memory. Add some limit in place.
In particular, each time we have literal =&gt; integer_literal we should avoid
storing the same integer_literal for all other_literal for which
other_literal =&gt; literal. For this we need to interact with the
BinaryImplicationGraph.&lt;p&gt; \anchor _todo001671 (user): This is a bit of a duplicate with the Literal &lt;=&gt; IntegerLiteral
stored in the IntegerEncoder class. However we only need one side here.&lt;p&gt; \anchor _todo001672 (user): Do like in the DomainDeductions class and allow to process
clauses (or store them) to perform more level zero deductions. Note that this
is again a slight duplicate with what we do there (except that we work at the
Domain level in that presolve class).&lt;p&gt; \anchor _todo001673 (user): Add an implied bound cut generator to add these simple
constraints to the LP when needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Member \_internalref classoperations__research_1_1sat_1_1ImpliedBounds#accac5e129274770ef3d646e15aa13b1c "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html#accac5e129274770ef3d646e15aa13b1c">operations_research::sat::ImpliedBounds::Add</a>" (Literal literal, IntegerLiteral integer_literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001660 (user): Check that this never happen? it shouldn't. 
 &lt;p&gt; \anchor _todo001661 (user): Like in probing, we can also create hole in the domain if there
is some implied bounds for (literal.NegatedIndex, NegagtionOf(var)) that
crosses integer_literal.bound. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Member \_internalref classoperations__research_1_1sat_1_1ImpliedBounds#ace9f6e200fff7933263a014bb9d62fb8 "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html#ace9f6e200fff7933263a014bb9d62fb8">operations_research::sat::ImpliedBounds::GetImpliedBounds</a>" (IntegerVariable var)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001662 (user): Check no duplicate and remove old entry if the enforcement
is tighter. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBoundsProcessor Member \_internalref classoperations__research_1_1sat_1_1ImpliedBoundsProcessor#aa292900f68528b54007deb7cdb6f4aec "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html#aa292900f68528b54007deb7cdb6f4aec">operations_research::sat::ImpliedBoundsProcessor::DecomposeWithImpliedLowerBound</a>" (const CutTerm &amp;term, IntegerValue factor_t, CutTerm &amp;bool_term, CutTerm &amp;slack_term)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001575 (user): Ignore if bound_diff == 1 ? But we can still merge B with
another entry if it exists, so it can still be good in this case.&lt;p&gt; \anchor _todo001576 (user): Only do it if coeff_b &gt; 0 ? But again we could still merge
B with an existing Boolean for a better cut even if coeff_b == 0. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBoundsProcessor Member \_internalref classoperations__research_1_1sat_1_1ImpliedBoundsProcessor#ad649c6a32bb8aeec245204ebd3c6fe15 "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html#ad649c6a32bb8aeec245204ebd3c6fe15">operations_research::sat::ImpliedBoundsProcessor::PostprocessWithImpliedBound</a>" (const std::function&lt; IntegerValue(IntegerValue)&gt; &amp;f, IntegerValue factor_t, CutData *cut, CutDataBuilder *builder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001577 (user): Note that while the violation might be higher, if the slack
becomes large this will result in a less powerfull cut. Shall we do
that? It is a bit the same problematic with complementing.&lt;p&gt; \anchor _todo001578 (user): If the slack is close to zero, then this transformation
will always increase the violation. So we could potentially do it in
Before our divisor selection heuristic. But the norm of the final cut
will increase too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBoundsProcessor Member \_internalref classoperations__research_1_1sat_1_1ImpliedBoundsProcessor#ace0dba418106eaaeca69f6adac3fff3e "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html#ace0dba418106eaaeca69f6adac3fff3e" title="Important: The cut_builder_ must have been reset.">operations_research::sat::ImpliedBoundsProcessor::TryToExpandWithLowerImpliedbound</a>" (IntegerValue factor_t, int i, bool complement, CutData *cut, CutDataBuilder *builder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001579 (user): Because of merges, we might have entry with a coefficient of
zero than are not useful. Remove them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::InclusionDetector Member \_internalref classoperations__research_1_1sat_1_1InclusionDetector#ac5767e6b32e020c4e95dd254ab768620 "<a class="el" href="classoperations__research_1_1sat_1_1InclusionDetector.html#ac5767e6b32e020c4e95dd254ab768620">operations_research::sat::InclusionDetector&lt; Storage &gt;::DetectInclusions</a>" (const std::function&lt; void(int subset, int superset)&gt; &amp;process)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001680 (user): Alternatively, we could clean is_in_superset_ in the
call to StopProcessingCurrentSuperset() and force client to call it
before altering the superset content. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad715c4b2444c3b6fb162bc2382a2248e "<a class="el" href="namespaceoperations__research_1_1sat.html#ad715c4b2444c3b6fb162bc2382a2248e">operations_research::sat::IncreaseNodeSize</a>" (EncodingNode *node, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001637 (user): Experiment more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Class \_internalref classoperations__research_1_1sat_1_1Inprocessing "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html">operations_research::sat::Inprocessing</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002230 (user): Some algorithms here use the normal SAT propagation engine.
However we might want to temporarily disable activities/phase saving and so
on if we want to run them as in-processing steps so that they
do not "pollute" the normal SAT search.&lt;p&gt; \anchor _todo002231 (user): For the propagation, this depends on the SatSolver class, which
mean we cannot really use it without some refactoring as an in-processing
from the SatSolver::Solve() function. So we do need a special
InprocessingSolve() that lives outside SatSolver. Alternatively, we can
extract the propagation main loop and conflict analysis from SatSolver. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a3ab413def8a2242915ef31ff717baa17 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a3ab413def8a2242915ef31ff717baa17">operations_research::sat::Inprocessing::DetectEquivalencesAndStamp</a>" (bool use_transitive_reduction, bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002182 (user): consider doing the transitive reduction after each SCC.
It might be slow but we could try to make it more incremental to
compensate and it should allow further reduction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#aa0797dfc25a5c609254b61fe67828c11 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#aa0797dfc25a5c609254b61fe67828c11">operations_research::sat::Inprocessing::InprocessingRound</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002178 (user): The LP and incremental structure will still be called though,
which can take some time, try to disable it more cleanly. 
 &lt;p&gt; \anchor _todo002179 (user): We should probably also disable the variable/clauses activity
updates. 
 &lt;p&gt; \anchor _todo002180 (user): Add a small wrapper function to time this.
 &lt;p&gt; \anchor _todo002181 (user): try to enable these? The problem is that we can only remove
variables not used the non-pure SAT part of a model. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a67d25dadf7669215ab5b27b4d8046e18 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a67d25dadf7669215ab5b27b4d8046e18">operations_research::sat::Inprocessing::PresolveLoop</a>" (SatPresolveOptions options)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002174 (user): This should/could be integrated with the stamping since it
seems better to do just one loop instead of two over all clauses. Because
of memory access. it isn't that clear though. 
 &lt;p&gt; \anchor _todo002175 (user): Combine the two? this way we don't create a full literal &lt;-&gt;
clause graph twice. It might make sense to reach the BCE fix point which
is unique before each variable elimination. 
 &lt;p&gt; \anchor _todo002176 (user): this break some binary graph invariant. Fix!
 &lt;p&gt; \anchor _todo002177 (user): Maintain the total number of literals in the watched clauses.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a5e0f39f14f9c6d947181e7185d6ed865 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a5e0f39f14f9c6d947181e7185d6ed865">operations_research::sat::Inprocessing::RemoveFixedAndEquivalentVariables</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002183 (user): The level zero is required because we remove fixed variables
but if we split this into two functions, we could rewrite clause at any
level. 
 &lt;p&gt; \anchor _todo002184 (user): If only new fixed variables are there, we can use a faster
function. We should also merge the code with the deletion code in
sat_solver_.cc, but that require some refactoring of the dependence between
files. 
 &lt;p&gt; \anchor _todo002185 (user): we should output literal to the proof right away,
currently if we remove clauses before fixing literal the proof is
wrong. 
 &lt;p&gt; \anchor _todo002186 (user): find a way to auto-tune that after a run on borg...
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a2fbf49af4f2bef7419f9eff0fc4847b2 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a2fbf49af4f2bef7419f9eff0fc4847b2">operations_research::sat::Inprocessing::SubsumeAndStrenghtenRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002187 (user): Use better work limits, see SAT09.CRAFTED.ramseycube.Q3inK12&lt;p&gt; \anchor _todo002188 (user): Be more incremental, each time a clause is added/reduced track
which literal are impacted? Also try to do orthogonal reductions from one
round to the next. 
 &lt;p&gt; \anchor _todo002189 (user): We could do that only if we do some reduction, but this is
quite fast though. 
 &lt;p&gt; \anchor _todo002190 (user): probably faster without the size indirection. 
 &lt;p&gt; \anchor _todo002191 (user): Storing signatures here might be faster? 
 &lt;p&gt; \anchor _todo002192 (user): Better abort limit. We could also limit the watcher sizes and
never look at really long clauses. Note that for an easier
incrementality, it is better to reach some kind of completion so we know
what new stuff need to be done. 
 &lt;p&gt; \anchor _todo002193 (user): Do some reduction using binary clauses. Note that only clause
that never propagated since last round need to be checked for binary
subsumption. 
 &lt;p&gt; \anchor _todo002194 (user): remove first and see if other still removable. Alternatively
use a "removed" marker and redo a check for each clause that simplifies
this one? Or just remove the first one, and wait for next round. 
 &lt;p&gt; \anchor _todo002195 (user): No need to add this clause if we know it cannot subsume
any new clause since last round. i.e. unchanged clause that do not
contains any literals of newly added clause do not need to be added
here. We can track two bitset in LiteralWatchers via a register
mechanism:
- literal of newly watched clauses since last clear.
- literal of reduced clauses since last clear.&lt;p&gt; \anchor _todo002196 (user): We could/should sort the literal in this clause by
using literals that appear in a small number of clauses first so that
we maximize the chance of early abort in the critical loops above.&lt;p&gt; \anchor _todo002197 (user): We could also move the watched literal first so we always
skip it. 
 &lt;p&gt; \anchor _todo002198 (user): tune the deterministic time.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Class \_internalref classoperations__research_1_1sat_1_1IntegerEncoder "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">operations_research::sat::IntegerEncoder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001706 (user): We could also lazily create precedences Booleans between two
arbitrary IntegerVariable. This is better done in the PrecedencesPropagator
though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a1a4e1df43e180231715e6fde6b4d0a8d "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1a4e1df43e180231715e6fde6b4d0a8d">operations_research::sat::IntegerEncoder::Canonicalize</a>" (IntegerLiteral i_lit) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001713 (user): This is linear in the domain "complexity", we can do better if
needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a44f7926d822f4f2f659be6f503090ac4 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a44f7926d822f4f2f659be6f503090ac4">operations_research::sat::IntegerEncoder::FullyEncodeVariable</a>" (IntegerVariable var)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001682 (user): Maybe we can optimize the literal creation order and their
polarity as our default SAT heuristics initially depends on this.&lt;p&gt; \anchor _todo001683 (user): Currently, in some corner cases,
GetOrCreateLiteralAssociatedToEquality() might trigger some propagation
that update the domain of var, so we need to cache the values to not read
garbage. Note that it is okay to call the function on values no longer
reachable, as this will just do nothing. 
 &lt;p&gt; \anchor _todo001712 (user): It is currently only possible to call that at the decision
level zero because we cannot add ternary clause in the middle of the
search (for now). This is Checked. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#acb0b1234e31f51f99e14860cd628cde2 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#acb0b1234e31f51f99e14860cd628cde2">operations_research::sat::IntegerEncoder::GetAssociatedLiteral</a>" (IntegerLiteral i_lit) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001688 (user): Canonicalization might be slow.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a86897b73c47086f4bc261f9424b47de7 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a86897b73c47086f4bc261f9424b47de7">operations_research::sat::IntegerEncoder::GetOrCreateAssociatedLiteral</a>" (IntegerLiteral i_lit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001686 (user): on some problem this happens. We should probably make sure that
we don't create extra fixed Boolean variable for no reason. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#af0a2aeea649e70334c5b44dca14a5ae2 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#af0a2aeea649e70334c5b44dca14a5ae2">operations_research::sat::IntegerEncoder::GetOrCreateLiteralAssociatedToEquality</a>" (IntegerVariable var, IntegerValue value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001687 (user): this happens on some problem. We should probably
make sure that we don't create extra fixed Boolean variable for no reason.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a575c98a8e638de20b5a3a5861263c732 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a575c98a8e638de20b5a3a5861263c732" title="Gets the literal always set to true, make it if it does not exist.">operations_research::sat::IntegerEncoder::GetTrueLiteral</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001714 (user): Make sure we abort right away on unsat! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a7c648e8ec1bcd260e3d4ed64b293bb28 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a7c648e8ec1bcd260e3d4ed64b293bb28" title="Memory optimization: you can call this before encoding variables.">operations_research::sat::IntegerEncoder::ReserveSpaceForNumVariables</a>" (int num_vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001681 (user): Reserve vector index by literals? It is trickier, as we might not
know beforehand how many we will need. Consider alternatives to not waste
space like using dequeue. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a59abe9efe4246f146066483c1955e602 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a59abe9efe4246f146066483c1955e602">operations_research::sat::IntegerEncoder::VariableIsFullyEncoded</a>" (IntegerVariable var) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001684 (user): Cache result as long as equality_by_var_[index] is unchanged?
It might not be needed since if the variable is not fully encoded, then
PartialDomainEncoding() will filter unreachable values, and so the size
check will be false until further value have been encoded. 
 &lt;p&gt; \anchor _todo001685 (user): Comparing the size might be enough, but we want to be always
valid even if either (*domains_[var]) or PartialDomainEncoding(var) are
not properly synced because the propagation is not finished. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerRoundingCutHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerRoundingCutHelper#a55348bee0f2fe5505e28cc64ddfb1404 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerRoundingCutHelper.html#a55348bee0f2fe5505e28cc64ddfb1404" title="Returns true on success. The cut can be accessed via cut().">operations_research::sat::IntegerRoundingCutHelper::ComputeCut</a>" (RoundingOptions options, const CutData &amp;base_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001545 (user): This is slow, 50% of run time on a2c1s1.pb.gz. Optimize!
 &lt;p&gt; \anchor _todo001546 (user): We assume that this is called with and without the option
use_ib_before_heuristic, so that we can abort if no IB has been applied
since then we will redo the computation. This is not really clean. 
 &lt;p&gt; \anchor _todo001547 (user): Experiment for the best value of this initial violation
threshold. Note also that we use the l2 norm on the restricted position
here. Maybe we should change that? On that note, the L2 norm usage seems
a bit weird to me since it grows with the number of term in the cut. And
often, we already have a good cut, and we make it stronger by adding
extra terms that do not change its activity.&lt;p&gt; \anchor _todo001548 (user): If the rhs is small and close to zero, we might want to
consider different way of complementing the variables. 
 &lt;p&gt; \anchor _todo001549 (user): Avoid quadratic algorithm? Note that we are quadratic in
relevant positions not the full cut size, but this is still too much on
some problems. 
 &lt;p&gt; \anchor _todo001550 (user): It is still unclear if we have a * X + b * (1 - X) &lt;= rhs
for a Boolean X, what is the best way to apply f and if we should merge
the terms. If there is no other terms, best is probably
f(rhs - a) * X + f(rhs - b) * (1 - X). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#a48a2360caaae5ab4fb4d19f88a769fb6 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#a48a2360caaae5ab4fb4d19f88a769fb6">operations_research::sat::IntegerSearchHelper::GetDecisionLiteral</a>" (const BooleanOrIntegerLiteral &amp;decision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001777 (user): Ideally it would be cool to delay the creation even more
until we have a conflict with these decisions, but it is currently
hard to do so. 
 &lt;p&gt; \anchor _todo001778 (user): It would be nicer if this can never happen. For now, it
does because of the Propagate() not reaching the fixed point as
mentioned in a&lt;p&gt; \anchor _todo001779 &lt;p&gt; \anchor _todo001780 above. As a work-around, we display a message
but do not crash and recall the decision heuristic. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#aee604e664f5122db61cd4c73f437be2a "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#aee604e664f5122db61cd4c73f437be2a">operations_research::sat::IntegerSearchHelper::SolveIntegerProblem</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001782 (user): We have the issue that at level zero. calling the propagation
loop more than once can propagate more! This is because we call the LP
again and again on each level zero propagation. This is causing some
CHECKs() to fail in multithread (rarely) because when we associate new
literals to integer ones, Propagate() is indirectly called. Not sure yet
how to fix. 
 &lt;p&gt; \anchor _todo001783 (user): Experiment more around dynamically changing the
threshold for storing LP solutions in the pool. Alternatively expose
this as parameter so this can be tuned later.&lt;p&gt; \anchor _todo001784 (user): Avoid adding the same solution many time if the LP didn't
change. Avoid adding solution that are too deep in the tree (most
variable fixed). Also use a callback rather than having this here, we
don't want this file to depend on cp_model.proto. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#a2e2faa726399df6f91e4dc89d9ed5117 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#a2e2faa726399df6f91e4dc89d9ed5117">operations_research::sat::IntegerSearchHelper::TakeDecision</a>" (Literal decision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001781 (user): on some problems, this function can be quite long. Expand
so that we can check the time limit at each step? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a528e39b17cbbdccc58f61b4db9fd4141 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a528e39b17cbbdccc58f61b4db9fd4141">operations_research::sat::IntegerTrail::AppendNewBoundsFrom</a>" (int base_index, std::vector&lt; IntegerLiteral &gt; *output) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001699 (user): Implement a dense version if there is more trail entries
than variables! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a07f3c5bf9ad7390cb25efb3f6a0de3b3 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a07f3c5bf9ad7390cb25efb3f6a0de3b3">operations_research::sat::IntegerTrail::ConditionalEnqueue</a>" (Literal lit, IntegerLiteral i_lit, std::vector&lt; Literal &gt; *literal_reason, std::vector&lt; IntegerLiteral &gt; *integer_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001691 (user): We could even keep the reason and maybe do some reasoning using
at_least_one constraint on a set of the Boolean used here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#aa5f3f24dfc832d45939478360f2a9ef1 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#aa5f3f24dfc832d45939478360f2a9ef1">operations_research::sat::IntegerTrail::Enqueue</a>" (IntegerLiteral i_lit, absl::Span&lt; const Literal &gt; literal_reason, absl::Span&lt; const IntegerLiteral &gt; integer_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001720 (user): If the given bound is equal to the current bound, maybe the new
reason is better? how to decide and what to do in this case? to think about
it. Currently we simply don't do anything. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#ae5d98735536061f5c38f91ddd6a0b073 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#aa5f3f24dfc832d45939478360f2a9ef1">operations_research::sat::IntegerTrail::Enqueue</a>" (IntegerLiteral i_lit, absl::Span&lt; const Literal &gt; literal_reason, absl::Span&lt; const IntegerLiteral &gt; integer_reason, int trail_index_with_same_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001721 (user): This currently cannot refer to a trail_index with a lazy
reason. Fix or at least check that this is the case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#ae3ea8da78f7a6ec038887174bbad6ceb "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#ae3ea8da78f7a6ec038887174bbad6ceb">operations_research::sat::IntegerTrail::Propagate</a>" (Trail *trail) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001689 (user): refactor the interaction IntegerTrail &lt;-&gt; IntegerEncoder so
that we can just push right away such literal. Unfortunately, this is is
a big chunk of work. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a090881ffd3442b49e6e858dd6cc9f433 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a090881ffd3442b49e6e858dd6cc9f433">operations_research::sat::IntegerTrail::Reason</a>" (const Trail &amp;trail, int trail_index) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001698 (user): If this is called many time on the same variables, it could be
made faster by using some caching mechanism. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a3f82268fd6c91332511a3d8765d6d07f "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a3f82268fd6c91332511a3d8765d6d07f">operations_research::sat::IntegerTrail::RelaxLinearReason</a>" (IntegerValue slack, absl::Span&lt; const IntegerValue &gt; coeffs, std::vector&lt; IntegerLiteral &gt; *reason) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001690 (user): Get rid of this function and only keep the trail index one?
 &lt;p&gt; \anchor _todo001717 (user): Requiring all initial literal to be at their current bound is
not really clean. Maybe we can change the API to only take IntegerVariable
and produce the reason directly.&lt;p&gt; \anchor _todo001718 (user): change API so that this work is performed during the conflict
analysis where we can be smarter in how we relax the reason. Note however
that this function is mainly used when we have a conflict, so this is not
really high priority.&lt;p&gt; \anchor _todo001719 (user): Test that the code work in the presence of integer overflow. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a86dbd554c727e96c1ce6e33a54a73235 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a86dbd554c727e96c1ce6e33a54a73235">operations_research::sat::IntegerTrail::UpdateInitialDomain</a>" (IntegerVariable var, Domain domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001716 (user): There is some memory inefficiency if this is called many time
because of the underlying data structure we use. In practice, when used
with a presolve, this is not often used, so that is fine though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4f8e9410f7631560e2efea8f401e5aa1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4f8e9410f7631560e2efea8f401e5aa1">operations_research::sat::IntegerValueSelectionHeuristic</a>" (std::function&lt; BooleanOrIntegerLiteral()&gt; var_selection_heuristic, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001758 (user): Experiment more with value selection heuristics. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntervalsRepository Member \_internalref classoperations__research_1_1sat_1_1IntervalsRepository#a62f30977af214764af573b8a9da295d6 "<a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html#a62f30977af214764af573b8a9da295d6">operations_research::sat::IntervalsRepository::CreateDisjunctivePrecedenceLiteral</a>" (IntervalVariable a, IntervalVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001791 (user): also add the reverse like start_b + 1 &lt;= end_a if negated? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntervalsRepository Member \_internalref classoperations__research_1_1sat_1_1IntervalsRepository#a89d4a8a4b1575bb7a0d793402c82e099 "<a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html#a89d4a8a4b1575bb7a0d793402c82e099">operations_research::sat::IntervalsRepository::CreatePrecedenceLiteral</a>" (IntervalVariable a, IntervalVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001792 (user): Also add {{y_plus_one, x}, x_before_y.Negated()} ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntervalsRepository Member \_internalref classoperations__research_1_1sat_1_1IntervalsRepository#ae9f8653f78ec2416053ba12305b3b2a7 "<a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html#ae9f8653f78ec2416053ba12305b3b2a7">operations_research::sat::IntervalsRepository::GetOrCreateHelper</a>" (const std::vector&lt; IntervalVariable &gt; &amp;variables, bool register_as_disjunctive_helper=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001793 (user): Ideally we should sort the vector of variables, but right now
we cannot since we often use this with a parallel vector of demands. So this
"sorting" should happen in the presolver so we can share as much as possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Class \_internalref classoperations__research_1_1sat_1_1LbTreeSearch "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html">operations_research::sat::LbTreeSearch</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001826 (user): What this is doing is really similar to asking a SAT solver if
the current objective lower bound is reachable by solving a SAT problem.
However, this code handle on the side all the "conflict" of the form
objective &gt; current_lb. As a result, when it is UNSAT, we can bump the lower
bound by a bigger amount than one. We also do not completely loose everything
learned so far for the next iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Member \_internalref classoperations__research_1_1sat_1_1LbTreeSearch#ab578e3dd57e9e2c0daff912371d19dc2 "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab578e3dd57e9e2c0daff912371d19dc2">operations_research::sat::LbTreeSearch::LbTreeSearch</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001808 (user): Starts with an initial variable score for all variable in
the objective at their minimum value? this should emulate the first step of
the core approach and gives a similar bound. 
 &lt;p&gt; \anchor _todo001809 (user): if we have many independent LP, this will find nothing. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Member \_internalref classoperations__research_1_1sat_1_1LbTreeSearch#ab5eed5bfd114852c086831f49823d8ba "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab5eed5bfd114852c086831f49823d8ba" title="Explores the search space.">operations_research::sat::LbTreeSearch::Search</a>" (const std::function&lt; void()&gt; &amp;feasible_solution_observer)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001810 (user): a strong branching initial start, or allowing a few decision
per nodes might be a better approach.&lt;p&gt; \anchor _todo001811 (user): It would also be cool to exploit the reason for the LB increase
even more. 
 &lt;p&gt; \anchor _todo001812 (user): No point checking that if the objective lb wasn't
assigned at this level.&lt;p&gt; \anchor _todo001813 (user): Exploit the reasons further. 
 &lt;p&gt; \anchor _todo001814 (user): This is slightly different than bumping each time we
push a decision that result in an LB increase. This is also called on
backjump for instance. 
 &lt;p&gt; \anchor _todo001815 (user): We also need to update pseudo cost on conflict.
 &lt;p&gt; \anchor _todo001816 (user): If we remember how far we can backjump for both true/false
branch, we could be more efficient. 
 &lt;p&gt; \anchor _todo001817 (user): If we have new information and our current objective bound
is higher than any bound in a whole subtree, we might want to just
restart this subtree exploration? 
 &lt;p&gt; \anchor _todo001818 (user): In multithread, this change the behavior a lot since we
dive until we beat the best shared bound. Maybe we shouldn't do that. 
 &lt;p&gt; \anchor _todo001819 (user): We sometimes branch on the objective variable, this should
probably be avoided. 
 &lt;p&gt; \anchor _todo001820 (user): Try to minimize the number of decisions? 
 &lt;p&gt; \anchor _todo001821 (user): Uses old optimal constraint that we just potentially
backtracked over?&lt;p&gt; \anchor _todo001822 (user): We could do all at once rather than in O(#decision * #size). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LevelZeroEquality Member \_internalref classoperations__research_1_1sat_1_1LevelZeroEquality#a6f4c89def00ad8b950b31383f59ba094 "<a class="el" href="classoperations__research_1_1sat_1_1LevelZeroEquality.html#a6f4c89def00ad8b950b31383f59ba094">operations_research::sat::LevelZeroEquality::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001732 (user): We could go even further than just the GCD, and do more
arithmetic to tighten the target bounds. See for instance a problem like
ej.mps.gz that we don't solve easily, but has just 3 variables! the goal is
to minimize X, given 31013 X - 41014 Y - 51015 Z = -31013 (all &gt;=0, Y and Z
bounded with high values). I know some MIP solvers have a basic linear
diophantine equation support. 
 &lt;p&gt; \anchor _todo001733 (user): Once the GCD is not 1, we could at any level make sure the
objective is of the correct form. For now, this only happen in a few
miplib problem that we close quickly, so I didn't add the extra code yet. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a18679d8902d037df4ad5371ab25ad435 "<a class="el" href="namespaceoperations__research_1_1sat.html#a18679d8902d037df4ad5371ab25ad435">operations_research::sat::LinearBooleanProblemToCnfString</a>" (const LinearBooleanProblem &amp;problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001056 (user): implement this trick. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Class \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html">operations_research::sat::LinearConstraintBuilder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001830 (user): Rename to LinearExpressionBuilder? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#ae7f3237b747cd3a0ae75daf2f77e19d8 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#ae7f3237b747cd3a0ae75daf2f77e19d8">operations_research::sat::LinearConstraintBuilder::AddDecomposedProduct</a>" (absl::Span&lt; const LiteralValueValue &gt; product)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001827 (user): Checks the value of literals.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a00685724ff7957bd0b8dbb337b2eacd6 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a00685724ff7957bd0b8dbb337b2eacd6">operations_research::sat::LinearConstraintBuilder::AddQuadraticLowerBound</a>" (AffineExpression left, AffineExpression right, IntegerTrail *integer_trail, bool *is_quadratic=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001832 (user): We could use (max - delta) instead of (min + delta) for each
expression instead. This would depend on the LP value of the left and
right. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a2b9598a931a588949a8b5f5af8304ead "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a2b9598a931a588949a8b5f5af8304ead">operations_research::sat::LinearConstraintBuilder::Build</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001833 (user): this doesn't invalidate the builder object, but if one wants
to do a lot of dynamic editing to the constraint, then then underlying
algorithm needs to be optimized for that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a029e8c7ac32054484a98093c2ad7629a "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a9c3eb68e76b59f3aae54a9d8cd4cf42e">operations_research::sat::LinearConstraintBuilder::LinearConstraintBuilder</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001831 (user): Have a subclass so we can enforce that a caller using
AddLiteralTerm() must construct the Builder with an encoder. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintManager#a7ed5d2e7a9f57fe18d3962de8ee08815 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html#a7ed5d2e7a9f57fe18d3962de8ee08815">operations_research::sat::LinearConstraintManager::AddCut</a>" (LinearConstraint ct, std::string type_name, std::string extra_info="")&lt;/dt&gt;&lt;dd&gt; \anchor _todo001835 (user): We could prevent overflow by dividing more. Note that mainly
happen with super large variable domain since we usually restrict the size
of the generated coefficients in our cuts. So it shouldn't be that
important. 
 &lt;p&gt; \anchor _todo001836 (user): Use better heuristic here for detecting good cuts and mark
them undeletable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintManager#a6736aa5d3e7f0a44c29023b2bc85a453 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html#a6736aa5d3e7f0a44c29023b2bc85a453">operations_research::sat::LinearConstraintManager::ChangeLp</a>" (glop::BasisState *solution_state, int *num_new_constraints=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001840 (user): Because we simplified this constraint, it is possible that
it is now a duplicate of another one. Merge them. 
 &lt;p&gt; \anchor _todo001841 (user): This blowup factor could be adaptative w.r.t. the constraint
limit. 
 &lt;p&gt; \anchor _todo001842 (user): find better algo, this does 1000 * 4000 scalar product! 
 &lt;p&gt; \anchor _todo001843 (user): Experiment with different weights or different
functions for computing score. 
 &lt;p&gt; \anchor _todo001844 (user): Instead of comparing num_deletable_constraints with cut
limit, compare number of deletable constraints not in lp against the limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager::ConstraintInfo Member \_internalref structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo#a466661f3078984c94567ad58040edb6e "<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo.html#a466661f3078984c94567ad58040edb6e">operations_research::sat::LinearConstraintManager::ConstraintInfo::inactive_count</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001846 (user): This is the number of time the constraint was consecutively
inactive, and go up to 100 with the default param, so we could optimize
the space used more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager::ConstraintInfo Member \_internalref structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo#abdf73acb15ffe53b95a4131d9ba9aac9 "<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo.html#abdf73acb15ffe53b95a4131d9ba9aac9">operations_research::sat::LinearConstraintManager::ConstraintInfo::is_deletable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001848 (user): We can have a better heuristics. Some generated good cuts
can be marked undeletable and some unused problem specified constraints
can be marked deletable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager::ConstraintInfo Member \_internalref structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo#af933df23d6da0e5b34f2f92696b70800 "<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo.html#af933df23d6da0e5b34f2f92696b70800">operations_research::sat::LinearConstraintManager::ConstraintInfo::objective_parallelism_computed</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001847 (user): Pack bool and in general optimize the memory of this class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Class \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator "operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001738 (user): Technically we could still have an int128 overflow since we
sum n terms that cannot overflow but can still be pretty close to the limit.
Make sure this never happens! For most problem though, because the variable
bounds will be smaller than 10^9, we are pretty safe.&lt;p&gt; \anchor _todo001739 (user): If one has many such constraint, it will be more efficient to
propagate all of them at once rather than doing it one at the time.&lt;p&gt; \anchor _todo001740 (user): Explore tree structure to get a log(n) complexity.&lt;p&gt; \anchor _todo001741 (user): When the variables are Boolean, use directly the pseudo-Boolean
constraint implementation. But we do need support for enforcement literals
there. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#a53f0cc28cdfafb5721ce374d3c16a973 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#a53f0cc28cdfafb5721ce374d3c16a973" title="NOTE(user): This is only used with int128, so we code only a single version.">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::ConditionalLb</a>" (IntegerLiteral integer_literal, IntegerVariable target_var) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001727 (user): If there is a conflict (negative slack) we can be more
precise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#ace49b8f6c8907a190c3aee7d359791fd "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#ace49b8f6c8907a190c3aee7d359791fd">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::LinearConstraintPropagator</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const IntegerValue &gt; coeffs, IntegerValue upper_bound, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001724 (user): deal with this corner case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#abd5b6d0682d0018f82fdce4233f6f576 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#ace49b8f6c8907a190c3aee7d359791fd">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::LinearConstraintPropagator</a>" (LinearConstraint ct, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001725 (user): Avoid duplication with other constructor.
 &lt;p&gt; \anchor _todo001726 (user): deal with this corner case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#ae4ae154271da65071742b6a7dbe2d460 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#ae4ae154271da65071742b6a7dbe2d460">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001728 (user): If the new ub fall into an hole of the variable, we can
actually relax the reason more by computing a better slack. 
 &lt;p&gt; \anchor _todo001729 (user): this is never supposed to happen since if we didn't have a
conflict above, we should be able to reduce the upper bound. It might
indicate an issue with our Boolean &lt;-&gt; integer encoding. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#afb899d80eaee9952f8076176b345ee15 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#afb899d80eaee9952f8076176b345ee15">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::PropagateAtLevelZero</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001730 (user): Deal with enforcements. It is just a bit of code to read the
value of the literals at level zero. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#acb9913bc77648b9229d90f8ebc306939 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#acb9913bc77648b9229d90f8ebc306939">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::RegisterWith</a>" (GenericLiteralWatcher *watcher)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001731 (user): if there is more than one, maybe we should watch more to
propagate a "conflict" as soon as only one is unassigned? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearIncrementalEvaluator Member \_internalref classoperations__research_1_1sat_1_1LinearIncrementalEvaluator#ad15e855847e8e9fd85eb17774c2fe277 "<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html#ad15e855847e8e9fd85eb17774c2fe277">operations_research::sat::LinearIncrementalEvaluator::PrecomputeCompactView</a>" (absl::Span&lt; const int64_t &gt; var_max_variation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001117 (user): We could delete them before. But at the time of this
optimization, I didn't want to change the behavior of the algorithm at all. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearIncrementalEvaluator Member \_internalref classoperations__research_1_1sat_1_1LinearIncrementalEvaluator#aed1038acba7b405fb9c01417e3a1f05f "<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html#aed1038acba7b405fb9c01417e3a1f05f">operations_research::sat::LinearIncrementalEvaluator::SlopeBreakpoints</a>" (int var, int64_t current_value, const Domain &amp;var_domain) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001116 (user): Deal with holes? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearIncrementalEvaluator Member \_internalref classoperations__research_1_1sat_1_1LinearIncrementalEvaluator#a201fdc143b0a225b578f5a5d123ef53a "<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html#a201fdc143b0a225b578f5a5d123ef53a">operations_research::sat::LinearIncrementalEvaluator::WeightedViolationDelta</a>" (absl::Span&lt; const double &gt; weights, int var, int64_t delta) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001115 (user): We can safely abort early if we know that delta will be &gt;= 0.
 &lt;p&gt; &lt;p&gt;(user): Maybe we can compute an absolute value instead of removing
old_distance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearModel Member \_internalref classoperations__research_1_1sat_1_1LinearModel#a8c594ce81043440f547bf1320674a829 "<a class="el" href="classoperations__research_1_1sat_1_1LinearModel.html#a8c594ce81043440f547bf1320674a829">operations_research::sat::LinearModel::LinearModel</a>" (const CpModelProto &amp;model_proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001849 (user): Do we use the loader code to detect full encodings and
element encodings. 
 &lt;p&gt; \anchor _todo001850 (user): Deal with/Check double insertion.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#ac0030221b056d71c560de62bd9d57a09 "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#ac0030221b056d71c560de62bd9d57a09">operations_research::sat::LinearProgrammingConstraint::IncrementalPropagate</a>" (const std::vector&lt; int &gt; &amp;watch_indices) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001861 (user): The saved lp solution is still valid given the current variable
bounds, so the LP optimal didn't change. However we might still want to add
new cuts or new lazy constraints?&lt;p&gt; \anchor _todo001862 (user): Propagate the last optimal_constraint? Note that we need
to be careful since the reversible int in IntegerSumLE are not registered.
However, because we delete "optimalconstraints" on backtrack, we might not
care. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#ac305ae4d90e003c68c190a412f9879de "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#ac305ae4d90e003c68c190a412f9879de">operations_research::sat::LinearProgrammingConstraint::LinearProgrammingConstraint</a>" (Model *model, absl::Span&lt; const IntegerVariable &gt; vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001851 (user): make SatParameters singleton too, otherwise changing them after
a constraint was added will have no effect on this class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a7ff29ebe58aca89b537dc833cc1c45de "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a7ff29ebe58aca89b537dc833cc1c45de" title="PropagatorInterface API.">operations_research::sat::LinearProgrammingConstraint::Propagate</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001890 (user): It seems the time we loose by not stopping early might be worth
it because we end up with a better explanation at optimality. 
 &lt;p&gt; \anchor _todo001891 (user): Refactor so that they are just normal cut generators? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a6f4001652e985a2165ad4d6602eae29b "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a6f4001652e985a2165ad4d6602eae29b" title="ReversibleInterface API.">operations_research::sat::LinearProgrammingConstraint::SetLevel</a>" (int level) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001858 (user): Keep all optimal solution in the current branch?
&lt;p&gt; \anchor _todo001859 &lt;p&gt; \anchor _todo001860 (user): Still try to add cuts/constraints though! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Class \_internalref classoperations__research_1_1sat_1_1LinearPropagator "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html">operations_research::sat::LinearPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001926 (user): This is a work in progress and is currently incomplete:
- Lack more incremental support for faster propag.
- Lack detection and propagation of at least one of these linear is true
  which can be used to propagate more bound if a variable appear in all these
  constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a6b4adf9e4a241637f5dee4cc9ea43adc "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a6b4adf9e4a241637f5dee4cc9ea43adc" title="Adds a new constraint to the propagator.">operations_research::sat::LinearPropagator::AddConstraint</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const IntegerValue &gt; coeffs, IntegerValue upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001908 (user): we still waste the space in coeffs_buffer_ so that the
start are aligned with the variables_buffer_. 
 &lt;p&gt; \anchor _todo001909 (user): With some care, when we cannot propagate or the
constraint is not enforced, we could leave in_queue_[] at true but
not put the constraint in the queue. 
 &lt;p&gt; \anchor _todo001910 (user): Shall we register root level precedence from here rather than
separately? 
 &lt;p&gt; \anchor _todo001911 (user): Shall we decide on some ordering here? maybe big coeff first
so that we get the largest change in slack? the idea being to propagate
large change first in case of cycles. 
 &lt;p&gt; \anchor _todo001912 (user): Do we want to do that? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a615cc74a74066501e840dcc2343738ec "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a615cc74a74066501e840dcc2343738ec">operations_research::sat::LinearPropagator::LinearPropagator</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001903 (user): When we start to push too much (Cycle?) we should see what
other propagator says before repropagating this one, system for call
later? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a74432b1f2031ef1a7257cf98913c7390 "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a74432b1f2031ef1a7257cf98913c7390">operations_research::sat::LinearPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001904 (user): More than the propagation speed, I think it is important to
have proper explanation, so if A pushes B, but later on the queue we have C
that push A that push B again, that might be bad? We can try to avoid this
even further, by organizing the queue in passes:
 - Scan all relevant constraints, remember who pushes but DO NOT push yet!
 - If no cycle, do not pushes constraint whose slack will changes due to
   other pushes.
 - consider the new constraint that need to be scanned and repeat.
I think it is okay to scan twice the constraints that push something in
order to get better explanation. We tend to diverge from the class shortest
path algo in this regard.&lt;p&gt; \anchor _todo001905 (user): If we push the idea further, can we first compute the fix point
without pushing anything, then compute a good order of constraints for the
explanations? what is tricky is that we might need to "scan" more than once
a constraint I think. ex: Y, Z, T &gt;=0
 - 2 * Y + Z + T &lt;= 11   ==&gt;   Y &lt;= 5, Z &lt;= 11, T &lt;= 11  (1)
 - Z + Y &gt;= 6            ==&gt;   Z &gt;= 1
 - (1) again to push T &lt;= 10  and reach the propagation fixed point. 
 &lt;p&gt; \anchor _todo001906 (user): Maybe we should "update" explanation if we have a shorter
one to be less reliant on the propagation order. 
 &lt;p&gt; \anchor _todo001907 (user): This do not seems always good, especially since we pushed
Boolean with a really small explanation, maybe we want to push more of
these rather than go back to pure-binary propagation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Literal Member \_internalref classoperations__research_1_1sat_1_1Literal#a3b27485970070e73266f5530d2a7f55c "operations_research::sat::Literal::operator LiteralIndex" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002161 (user): LiteralIndex might not even be needed, but because of the
signed value business, it is still safer with it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a277ebf478f1fa693dd01867071080203 "<a class="el" href="namespaceoperations__research_1_1sat.html#a277ebf478f1fa693dd01867071080203">operations_research::sat::LoadAndSolveCpModelForTest</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001486 (user): Clean this up.
Solves a CpModelProto without any processing. Only used for unit tests. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0df7b56e0026b783deeeff20487de7cf "<a class="el" href="namespaceoperations__research_1_1sat.html#a0df7b56e0026b783deeeff20487de7cf" title="Loads a BooleanProblem into a given SatSolver instance.">operations_research::sat::LoadBooleanProblem</a>" (const LinearBooleanProblem &amp;problem, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001055 (user): Currently, the sat solver can load without any issue
constraints with duplicate variables, so we just output a warning if the
problem is not "valid". Make this a strong check once we have some
preprocessing step to remove duplicates variable in the constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a64c230730625662a2a2032da620b6c6e "<a class="el" href="namespaceoperations__research_1_1sat.html#a64c230730625662a2a2032da620b6c6e">operations_research::sat::LoadBooleanSymmetries</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001192 (user): We could add these extra Boolean during expansion/presolve so
that we have the symmetry involing them. Or maybe comes up with a different
solution. 
 &lt;p&gt; \anchor _todo001210 (user): We currently only have the code for Booleans, it is why we
currently ignore symmetries involving integer variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4b4da650bfcb86c00bee1df0ab0cc953 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4b4da650bfcb86c00bee1df0ab0cc953" title="LinearConstraint version.">operations_research::sat::LoadConditionalLinearConstraint</a>" (const absl::Span&lt; const Literal &gt; enforcement_literals, const LinearConstraint &amp;cst, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001747 (user): Remove the conversion!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ade08c3522dfce173ee1fd50fab3bd3c0 "<a class="el" href="namespaceoperations__research_1_1sat.html#ade08c3522dfce173ee1fd50fab3bd3c0">operations_research::sat::LoadLinearConstraint</a>" (const ConstraintProto &amp;ct, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001206 (user): Actually this should never be called since we process
linear1 in ExtractEncoding(). 
 &lt;p&gt; \anchor _todo001207 (user): Reuse ComputeLinearBounds()? but then we need another loop
to detect if we only have Booleans. 
 &lt;p&gt; \anchor _todo001208 (user): we should probably also implement an
half-reified version of this constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a23861bab6341cfcfeeff90c2b3e3ab7e "<a class="el" href="namespaceoperations__research_1_1sat.html#a23861bab6341cfcfeeff90c2b3e3ab7e">operations_research::sat::LoadLinMaxConstraint</a>" (const ConstraintProto &amp;ct, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001209 (user): Consider replacing the min propagator by max.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0f015dd7f088e0a586993ec925a94ced "<a class="el" href="namespaceoperations__research_1_1sat.html#a0f015dd7f088e0a586993ec925a94ced">operations_research::sat::LoadModelForProbing</a>" (PresolveContext *context, Model *local_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002102 (user): The model we load does not contain affine relations! But
ideally we should be able to remove all of them once we allow more complex
constraints to contains linear expression.&lt;p&gt; \anchor _todo002103 (user): remove code duplication with cp_model_solver. Here we also do
not run the heuristic to decide which variable to fully encode.&lt;p&gt; \anchor _todo002104 (user): Maybe do not load slow to propagate constraints? for instance
we do not use any linear relaxation here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a47e5d5cb3e7eb43191d094fc4752b5c6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a47e5d5cb3e7eb43191d094fc4752b5c6">operations_research::sat::LoadVariables</a>" (const CpModelProto &amp;model_proto, bool view_all_booleans_as_integers, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001191 (user): Fix the constant variable situation. An optional interval
with constant start/end or size cannot share the same constant
variable if it is used in non-optional situation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LocalBranchingLpBasedNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1LocalBranchingLpBasedNeighborhoodGenerator#aa12eefb1663a627e6519658d87dc3f19 "<a class="el" href="classoperations__research_1_1sat_1_1LocalBranchingLpBasedNeighborhoodGenerator.html#aa12eefb1663a627e6519658d87dc3f19">operations_research::sat::LocalBranchingLpBasedNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, double difficulty, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001175 (user): Extend to integer variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LocalBranchingLpBasedNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1LocalBranchingLpBasedNeighborhoodGenerator#a965d1a7c6cd024de0b2e7a9bf8642f30 "<a class="el" href="classoperations__research_1_1sat_1_1LocalBranchingLpBasedNeighborhoodGenerator.html#a965d1a7c6cd024de0b2e7a9bf8642f30">operations_research::sat::LocalBranchingLpBasedNeighborhoodGenerator::LocalBranchingLpBasedNeighborhoodGenerator</a>" (NeighborhoodGeneratorHelper const *helper, absl::string_view name, std::function&lt; void(CpModelProto, Model *)&gt; solve_callback, ModelSharedTimeLimit *const global_time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001190 (user): Restructure code so that we avoid circular dependency with
solving functions. For now, we use solve_callback. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae9ec04c047ef7bfe5cfa06c17ff0c76d "<a class="el" href="namespaceoperations__research_1_1sat.html#ae9ec04c047ef7bfe5cfa06c17ff0c76d">operations_research::sat::LpPseudoCostHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001753 (user): Use strong branching when not reliable.
&lt;p&gt; \anchor _todo001754 &lt;p&gt; \anchor _todo001755 (user): do not branch on integer lp? however it seems better to
do that !? Maybe this is because if it has a high pseudo cost
average, it is good anyway? 
 &lt;p&gt; \anchor _todo001756 (user): investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LsEvaluator Class \_internalref classoperations__research_1_1sat_1_1LsEvaluator "<a class="el" href="classoperations__research_1_1sat_1_1LsEvaluator.html">operations_research::sat::LsEvaluator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001119 (user): Ideas for constraint generated moves or sequences of moves? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LsEvaluator Member \_internalref classoperations__research_1_1sat_1_1LsEvaluator#a55666b5aee7e751b4bc51f963c2fbaa3 "<a class="el" href="classoperations__research_1_1sat_1_1LsEvaluator.html#a55666b5aee7e751b4bc51f963c2fbaa3">operations_research::sat::LsEvaluator::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001120 (user): Properly account all big time consumers.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af004193a12bf9ed78b295e7f7cb51e6f "<a class="el" href="namespaceoperations__research_1_1sat.html#af004193a12bf9ed78b295e7f7cb51e6f">operations_research::sat::MinimizeCore</a>" (SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002272 (user): One should use MinimizeCoreWithPropagation() instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4d6ba15542ec5d59958de53c92279b2a "<a class="el" href="namespaceoperations__research_1_1sat.html#a4d6ba15542ec5d59958de53c92279b2a">operations_research::sat::MinimizeCoreWithPropagation</a>" (TimeLimit *limit, SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002010 (user): Avoid spending too much time trying to minimize a core. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a56ad40efdac4d337987b0ca306aa7bd6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a56ad40efdac4d337987b0ca306aa7bd6">operations_research::sat::MinimizeCoreWithSearch</a>" (TimeLimit *limit, SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001985 (user): tune.
 &lt;p&gt; \anchor _todo001986 (user): Properly use the node depth instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MinPropagator Class \_internalref classoperations__research_1_1sat_1_1MinPropagator "<a class="el" href="classoperations__research_1_1sat_1_1MinPropagator.html">operations_research::sat::MinPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001742 (user): Implement a more efficient algorithm when the need arise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MinPropagator Member \_internalref classoperations__research_1_1sat_1_1MinPropagator#aa5ab4a97c4fe03823494846846b5accd "<a class="el" href="classoperations__research_1_1sat_1_1MinPropagator.html#aa5ab4a97c4fe03823494846846b5accd">operations_research::sat::MinPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001734 (user): Not sure this code is useful since this will be detected
by the fact that the [lb, ub] of the min is empty. It depends on the
propagation order though, but probably the precedences propagator would
propagate before this one. So change this to a CHECK? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Model Member \_internalref classoperations__research_1_1sat_1_1Model#ad025b208280b29fc3cfe2b7d3d61c8f9 "<a class="el" href="classoperations__research_1_1sat_1_1Model.html#ad025b208280b29fc3cfe2b7d3d61c8f9">operations_research::sat::Model::GetOrCreate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001983 (user): directly store std::unique_ptr&lt;&gt; in singletons_? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ModelCopy Member \_internalref classoperations__research_1_1sat_1_1ModelCopy#aa71276685b3bdc30f73c319014c8ce26 "<a class="el" href="classoperations__research_1_1sat_1_1ModelCopy.html#aa71276685b3bdc30f73c319014c8ce26">operations_research::sat::ModelCopy::ImportAndSimplifyConstraints</a>" (const CpModelProto &amp;in_model, bool first_copy=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001377 (user): Merge with the phase 1 of the presolve code.&lt;p&gt; \anchor _todo001378 (user): It seems easy to forget to update this if any new constraint
contains an interval or if we add a field to an existing constraint. Find a
way to remind contributor to not forget this. 
 &lt;p&gt; \anchor _todo001379 (user): if ignore_names is false, we should make sure the
name are properly copied by all these functions. Or we should never copy
name and have a separate if (!ignore_name) copy the name... 
 &lt;p&gt; \anchor _todo001380 (user): find a better way than copy then clear_name()?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ModelRandomGenerator Member \_internalref classoperations__research_1_1sat_1_1ModelRandomGenerator#a94be5f7295c63407b5efb55e55724391 "<a class="el" href="classoperations__research_1_1sat_1_1ModelRandomGenerator.html#a94be5f7295c63407b5efb55e55724391">operations_research::sat::ModelRandomGenerator::LogSalt</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002371 (user): I didn't find a cleaner way to log this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a4a9b63c72d02a80a8f76efbb0f020a3f "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a4a9b63c72d02a80a8f76efbb0f020a3f">operations_research::sat::MutableUpperBoundedLinearConstraint::ClearAll</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002020 (user): We could be more efficient and have only one loop here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a56db11b9d396d13e4cff87b74b086d81 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a56db11b9d396d13e4cff87b74b086d81">operations_research::sat::MutableUpperBoundedLinearConstraint::ComputeSlackForTrailPrefix</a>" (const Trail &amp;trail, int trail_index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002022 (user): Keep this for DCHECK(), but maintain the slack incrementally
instead of recomputing it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a467eaf21318efb233670a0035a2eae34 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a467eaf21318efb233670a0035a2eae34">operations_research::sat::MutableUpperBoundedLinearConstraint::ReduceCoefficients</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002021 (user): Also reduce the trivially false literal when coeff &gt; rhs_ ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a2d8ea04aaae8c892a39770e35eced029 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a2d8ea04aaae8c892a39770e35eced029">operations_research::sat::MutableUpperBoundedLinearConstraint::ReduceCoefficientsAndComputeSlackForTrailPrefix</a>" (const Trail &amp;trail, int trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002036 (user): Ideally the slack should be maitainable incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Neighborhood Member \_internalref structoperations__research_1_1sat_1_1Neighborhood#a9d77507f928ca9524da987bfbf75eee8 "<a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html#a9d77507f928ca9524da987bfbf75eee8">operations_research::sat::Neighborhood::id</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001185 (user): Make sure that the id is unique for each generated
neighborhood for each generator. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGenerator#ac8a7ed70ccae23b555deecf09756273f "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGenerator.html#ac8a7ed70ccae23b555deecf09756273f">operations_research::sat::NeighborhoodGenerator::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001169 (user): Weight more recent data.
degrade the current average to forget old learnings. 
 &lt;p&gt; \anchor _todo001170 (user): experiment with resetting the time limit if a solution is
found. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#a4853fe1b4ccd3d76f67706efd11a0698 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#a4853fe1b4ccd3d76f67706efd11a0698">operations_research::sat::NeighborhoodGeneratorHelper::FixGivenVariables</a>" (const CpSolverResponse &amp;base_solution, const absl::flat_hash_set&lt; int &gt; &amp;variables_to_fix) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001165 (user): Maybe relax all variables in the objective when the number
is small or negligible compared to the number of variables. 
 &lt;p&gt; \anchor _todo001166 (user): If there is just one component, we can skip some computation. 
 &lt;p&gt; \anchor _todo001167 (user): We could handle some complex domain (size &gt; 2). 
 &lt;p&gt; \anchor _todo001168 (user): force better objective? Note that this is already done when the
hint above is successfully loaded (i.e. if it passes the presolve
correctly) since the solver will try to find better solution than the
current one. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#aca0952c56878d9ecc6a8557bd42d170e "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#aca0952c56878d9ecc6a8557bd42d170e">operations_research::sat::NeighborhoodGeneratorHelper::GetSchedulingPrecedences</a>" (const absl::flat_hash_set&lt; int &gt; &amp;ignored_intervals, const CpSolverResponse &amp;initial_solution, absl::BitGenRef random) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001163 (user): We could scan for model precedences and add them to the list
of precedences. This could enable more simplifications in the transitive
reduction phase. 
 &lt;p&gt; \anchor _todo001164 (user): Reduce precedence graph
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#aebc02302feafecf7907a5fcc097b7486 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#aebc02302feafecf7907a5fcc097b7486">operations_research::sat::NeighborhoodGeneratorHelper::graph_mutex_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001186 (user): Refactor the class to be thread-safe instead, it should be
safer and more easily maintainable. Some complication with accessing the
variable&lt;-&gt;constraint graph efficiently though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#a83668c50ed54cfcd6b559374579eeca7 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#a83668c50ed54cfcd6b559374579eeca7">operations_research::sat::NeighborhoodGeneratorHelper::Synchronize</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001150 (user): We could set the optional literal to false directly in
the bound sharing manager. We do have to be careful that all the
different solvers have the same optionality definition though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a10700832ca6bc420f2931eb707957b0b "<a class="el" href="namespaceoperations__research_1_1sat.html#a10700832ca6bc420f2931eb707957b0b">operations_research::sat::NewSatParameters</a>" (const std::string &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001427 (user): Support it on android.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4bd54ab16ebc1bd6fa80d1e23ab79adc "<a class="el" href="namespaceoperations__research_1_1sat.html#a10700832ca6bc420f2931eb707957b0b">operations_research::sat::NewSatParameters</a>" (const sat::SatParameters &amp;parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001428 (user): A notable exception to this is the TimeLimit which is
currently not initializing itself from the SatParameters in the model. It
will also starts counting from the time of its creation. It will be good
to find a solution that is less error prone. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad8af8f787d40f2ccb96beb5306c913c5 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad8af8f787d40f2ccb96beb5306c913c5">operations_research::sat::NewWeightedSum</a>" (const VectorInt &amp;coefficients, const std::vector&lt; IntegerVariable &gt; &amp;vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001748 (user): invert the coefficients/vars arguments. 
 &lt;p&gt; \anchor _todo001749 (user): deal with overflow here too! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NoCyclePropagator Member \_internalref classoperations__research_1_1sat_1_1NoCyclePropagator#a8114b6f2c07e82698969a873461784ec "<a class="el" href="classoperations__research_1_1sat_1_1NoCyclePropagator.html#a8114b6f2c07e82698969a873461784ec">operations_research::sat::NoCyclePropagator::NoCyclePropagator</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; Literal &gt; &amp;literals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001065 (user): Uniformize this across propagator. Sometimes it is nice not
to register them, but most of them can be registered right away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NoCyclePropagator Member \_internalref classoperations__research_1_1sat_1_1NoCyclePropagator#a0751bd29114a60910d7626a21eb88b94 "<a class="el" href="classoperations__research_1_1sat_1_1NoCyclePropagator.html#a0751bd29114a60910d7626a21eb88b94">operations_research::sat::NoCyclePropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001066 (user): only explore node with newly added arcs.&lt;p&gt; \anchor _todo001067 (user): We could easily re-index the graph so that only nodes with arcs
are used. Because right now we are in O(num_nodes) even if the graph is
empty. 
 &lt;p&gt; \anchor _todo001068 (user): We could be more efficient here, but this is only executed on
conflicts. We should at least make sure we return a single cycle even
though if this is called often enough, we shouldn't have a lot more than
this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7ab66b40d6b1168f1a5a47fcf16636ac "<a class="el" href="namespaceoperations__research_1_1sat.html#a7ab66b40d6b1168f1a5a47fcf16636ac">operations_research::sat::NonDeterministicLoop</a>" (std::vector&lt; std::unique_ptr&lt; SubSolver &gt; &gt; &amp;subsolvers, const int num_threads)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002316 (user): We could also directly register callback to set stopping
Boolean to false in a few places. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NonOverlappingRectanglesEnergyPropagator Member \_internalref classoperations__research_1_1sat_1_1NonOverlappingRectanglesEnergyPropagator#a62a25736327376f2887d657c9885ee4b "<a class="el" href="classoperations__research_1_1sat_1_1NonOverlappingRectanglesEnergyPropagator.html#a62a25736327376f2887d657c9885ee4b">operations_research::sat::NonOverlappingRectanglesEnergyPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001593 (user): double-check/revisit the algo for box of variable sizes.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ObjectiveEncoder Member \_internalref classoperations__research_1_1sat_1_1ObjectiveEncoder#aba8bf46b2a10fabd82ffd3dbf2f0e174 "<a class="el" href="classoperations__research_1_1sat_1_1ObjectiveEncoder.html#aba8bf46b2a10fabd82ffd3dbf2f0e174">operations_research::sat::ObjectiveEncoder::nodes</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001643 (user): Remove mutable version once refactoring is done.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ObjectiveEncoder Member \_internalref classoperations__research_1_1sat_1_1ObjectiveEncoder#aea57787b48ca659a4962d5b674a72762 "<a class="el" href="classoperations__research_1_1sat_1_1ObjectiveEncoder.html#aea57787b48ca659a4962d5b674a72762">operations_research::sat::ObjectiveEncoder::ProcessCore</a>" (absl::Span&lt; const Literal &gt; core, Coefficient min_weight, Coefficient gap, std::string *info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001639 (user): propagate proper ub first.
 &lt;p&gt; \anchor _todo001640 (user): this node is closed and can be removed from the core.
 &lt;p&gt; \anchor _todo001641 (user): If assignment.LiteralIsTrue(bool_nodes[j]) We can
minimize the core here by removing bool_nodes[i] from it. Note
however that since we already minimized the core, this is
unlikely to happen. 
 &lt;p&gt; \anchor _todo001642 (user): If we infered the exactly one from the binary implication
graph, there is no need to add the amo since it is already there. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a09190309faf157e3b7187403cfcb514c "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a09190309faf157e3b7187403cfcb514c">operations_research::sat::PbConstraints::AddConstraint</a>" (const std::vector&lt; LiteralWithCoeff &gt; &amp;cst, Coefficient rhs, Trail *trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002028 (user): This is relatively slow. Take the "transpose" all at once, and
maybe put small constraints first on the to_update_ lists. 
 &lt;p&gt; \anchor _todo002029 (user): the index is needed to give the correct thresholds_ entry
to InitializeRhs() below, but this linear scan is not super
efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a9474a3e975c9c26b00740c514d82c373 "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a9474a3e975c9c26b00740c514d82c373">operations_research::sat::PbConstraints::BumpActivity</a>" (UpperBoundedLinearConstraint *constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002041 (user): Remove duplication with other activity update functions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a38e94ac484dcbd409e942d4e6f51d585 "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a38e94ac484dcbd409e942d4e6f51d585">operations_research::sat::PbConstraints::ClearConflictingConstraint</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002040 (user): This is a hack to get the PB conflict, because the rest of
the solver API assume only clause conflict. Find a cleaner way? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PostsolveClauses Struct \_internalref structoperations__research_1_1sat_1_1PostsolveClauses "<a class="el" href="structoperations__research_1_1sat_1_1PostsolveClauses.html">operations_research::sat::PostsolveClauses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002229 (user): Use a flat memory structure instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a1951d3606d9c0c92204c310b911bf0e7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a1951d3606d9c0c92204c310b911bf0e7">operations_research::sat::PostsolveLinear</a>" (const ConstraintProto &amp;ct, std::vector&lt; Domain &gt; *domains)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001214 (user): I am not 100% that the algo here might cover all the presolve
case, so if this fail, it might indicate an issue here and not in the
presolve/solver code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3e2be878d255ed853ce6a36d52c899dd "<a class="el" href="namespaceoperations__research_1_1sat.html#a3e2be878d255ed853ce6a36d52c899dd">operations_research::sat::PostsolveResponse</a>" (const int64_t num_variables_in_original_model, const CpModelProto &amp;mapping_proto, const std::vector&lt; int &gt; &amp;postsolve_mapping, std::vector&lt; int64_t &gt; *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001215 (user): We could use the search strategy to fix free variables to some
chosen values? The feature might never be needed though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Class \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html">operations_research::sat::PrecedenceRelations</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002076 (user): Support conditional relation.
 &lt;p&gt; &lt;p&gt;(user): Support non-DAG like graph.
 &lt;p&gt; &lt;p&gt;(user): Support variable offset that can be updated as search progress. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Member \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations#a4ca1b54209b1598460d8ef4eee99221b "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html#a4ca1b54209b1598460d8ef4eee99221b">operations_research::sat::PrecedenceRelations::Add</a>" (IntegerVariable tail, IntegerVariable head, IntegerValue offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002043 (user): Return infeasible if tail == head and offset &gt; 0.
&lt;p&gt; \anchor _todo002044 &lt;p&gt; \anchor _todo002045 (user): if tail = Negation(head) also update Domain. 
 &lt;p&gt; \anchor _todo002046 (user): AddInternal() only returns true if this is the first relation
between head and tail. But we can still avoid an extra lookup. 
 &lt;p&gt; \anchor _todo002047 (user): Alternatively, force caller to do a Resize(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Member \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations#a95dab1b3432098f1e966ec42fb3a26f3 "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html#a95dab1b3432098f1e966ec42fb3a26f3">operations_research::sat::PrecedenceRelations::Build</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002048 (user): Support negative offset?&lt;p&gt; \anchor _todo002049 (user): This can fail if we don't have a DAG. We could just skip Bad
edges instead, and have a sub-DAG as an heuristic. Or analyze the arc
weight and make sure cycle are not an issue. We can also start with arcs
with strictly positive weight.&lt;p&gt; \anchor _todo002050 (user): Only explore the sub-graph reachable from "vars". 
 &lt;p&gt; \anchor _todo002051 (user): Also do that if we don't have a DAG? 
 &lt;p&gt; \anchor _todo002085 (user): Be more dynamic as we start to add relations during search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Member \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations#af1bbb310cdf18b3d7faad6e15f99bbca "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html#af1bbb310cdf18b3d7faad6e15f99bbca">operations_research::sat::PrecedenceRelations::ComputeFullPrecedences</a>" (const std::vector&lt; IntegerVariable &gt; &amp;vars, std::vector&lt; FullIntegerPrecedence &gt; *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002052 (user): use vector of fixed size. 
 &lt;p&gt; \anchor _todo002053 (user): optimize when needed. 
 &lt;p&gt; \anchor _todo002054 (user): Release the memory right away. 
 &lt;p&gt; \anchor _todo002081 (user): generalize.&lt;p&gt; \anchor _todo002082 (user): Put some work limit in place, as this can be slow. Complexity
is in O(vars.size()) * num_arcs.&lt;p&gt; \anchor _todo002083 (user): Since we don't need ALL precedences, we could just work on a
sub-DAG of the full precedence graph instead of aborting. Or we can just
support the general non-DAG cases.&lt;p&gt; \anchor _todo002084 (user): Many relations can be redundant. Filter them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Class \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html">operations_research::sat::PrecedencesPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002077 (user): We could easily generalize the code to support any relation of
the form a*X + b*Y + c*Z &gt;= rhs (or &lt;=). Do that since this class should be
a lot faster at propagating small linear inequality than the generic
propagator and the overhead of supporting coefficient should not be too bad. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a15a72ea359f6b0297496d690fb35d81a "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a15a72ea359f6b0297496d690fb35d81a" title="This version check current precedence. It is however &quot;slow&quot;.">operations_research::sat::PrecedencesPropagator::AddPrecedenceWithOffsetIfNew</a>" (IntegerVariable i1, IntegerVariable i2, IntegerValue offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002062 (user): Modify arc in place!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a68e6ed997752f220d4571c5faa136ce5 "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a68e6ed997752f220d4571c5faa136ce5">operations_research::sat::PrecedencesPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo002055 (user): Because of our code to deal with InPropagationLoop(), this is
not always true. Find a cleaner way to DCHECK() while not failing in this
corner case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7a3e424a9963561cbd837b7a293b416e "<a class="el" href="namespaceoperations__research_1_1sat.html#a7a3e424a9963561cbd837b7a293b416e">operations_research::sat::PresolveBooleanLinearExpression</a>" (std::vector&lt; Literal &gt; *literals, std::vector&lt; Coefficient &gt; *coefficients, Coefficient *offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002011 (user): Merge this with similar code like
ComputeBooleanLinearExpressionCanonicalForm(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a5670894aad056fc4452807432b031858 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a5670894aad056fc4452807432b031858" title="b =&gt; x in [lb, ub].">operations_research::sat::PresolveContext::AddImplyInDomain</a>" (int b, int x, const Domain &amp;domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002091 (user): Find the best way to create such small proto. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a0e57a4d478e6619ec142e1c0e3da51a3 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a0e57a4d478e6619ec142e1c0e3da51a3">operations_research::sat::PresolveContext::CanonicalizeObjective</a>" (bool simplify_domain=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002099 (user): This is a bit duplicated with the presolve linear code.
We also do not propagate back any domain restriction from the objective to
the variables if any. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a2ccc5bf972c4cfe911eb430e97dd3c57 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a2ccc5bf972c4cfe911eb430e97dd3c57">operations_research::sat::PresolveContext::CanonicalizeVariable</a>" (int ref)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002110 (user): When we can always get rid of affine relation, it might be good
to do a final pass to canonicalize all domains in a model after presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#acfa9e96fd82123e73419f70c85690153 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#acfa9e96fd82123e73419f70c85690153">operations_research::sat::PresolveContext::ConstraintVariableUsageIsConsistent</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002093 (user): Also test var_to_constraints_ !!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#ac5377b5320ad26e469e680b7d3bab02b "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#ac5377b5320ad26e469e680b7d3bab02b">operations_research::sat::PresolveContext::InsertVarValueEncoding</a>" (int literal, int var, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002111 (user): This function is not always correct if
!context-&gt;DomainOf(var).contains(value), we could make it correct but it
might be a bit expansive to do so. For now we just have a DCHECK(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a6e1524915705b3272bab45c634fb5a37 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a6e1524915705b3272bab45c634fb5a37">operations_research::sat::PresolveContext::IsFullyEncoded</a>" (int ref) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002112 (user): If the domain was shrunk, we can have a false positive.
Still it means that the number of values removed is greater than the number
of values not encoded. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a38e2f15d439243fcc447d48fe120624e "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a38e2f15d439243fcc447d48fe120624e">operations_research::sat::PresolveContext::NewIntVar</a>" (const Domain &amp;domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002108 (user): We should control more how this is called so we can update
a solution hint accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a3ee008e9272dbcc3132a667eefc41923 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a3ee008e9272dbcc3132a667eefc41923">operations_research::sat::PresolveContext::NotifyThatModelIsUnsat</a>" (absl::string_view message="")&lt;/dt&gt;&lt;dd&gt; \anchor _todo002109 (user): Report any explanation for the client in a nicer way?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a392085a404b28b5e5a405c4e115e5332 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a392085a404b28b5e5a405c4e115e5332">operations_research::sat::PresolveContext::ShiftCostInExactlyOne</a>" (absl::Span&lt; const int &gt; exactly_one, int64_t shift)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002100 (user): Be more precise with this objective_overflow_detection_ and
always keep it up to date on each offset / coeff change. 
 &lt;p&gt; \anchor _todo002101 (user): This is a bit hacky, find a nicer way. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#aa087429f5cddf5be6c225890f614b4f1 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#aa087429f5cddf5be6c225890f614b4f1">operations_research::sat::PresolveContext::StoreAffineRelation</a>" (int ref_x, int ref_y, int64_t coeff, int64_t offset, bool debug_no_recursion=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002094 (user): I am not 100% sure why, but sometimes the representative is
fixed but that is not propagated to ref_x or ref_y and this causes issues. 
 &lt;p&gt; \anchor _todo002095 (user): we can do better for overflow by not always choosing the
min at zero, do the best things if it becomes needed. 
 &lt;p&gt; \anchor _todo002096 (user): can we force the rep and remove GetAffineRelation()?
 &lt;p&gt; \anchor _todo002097 (user): I am not sure this is needed given the propagation above. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#ab43f7366b32b2ac40cc0f7f668040c49 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#ab43f7366b32b2ac40cc0f7f668040c49">operations_research::sat::PresolveContext::UpdateRuleStats</a>" (const std::string &amp;name, int num_times=1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002092 rules as this is used to decide if
we loop again. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa9cd7652ef26e6d69565e1e7e1db3f07 "<a class="el" href="namespaceoperations__research_1_1sat.html#aa9cd7652ef26e6d69565e1e7e1db3f07">operations_research::sat::ProbeAndFindEquivalentLiteral</a>" (SatSolver *solver, SatPostsolver *postsolver, DratProofHandler *drat_proof_handler, absl::StrongVector&lt; LiteralIndex, LiteralIndex &gt; *mapping, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002306 (user): Add some constraint so that it does?&lt;p&gt; \anchor _todo002307 (user): check compatibility? if x ~ not(x) =&gt; unsat.
but probably, the solver would have found this too? not sure... 
 &lt;p&gt; \anchor _todo002308 (user): Fixing a variable might fix more of them by propagation, so
we might not fix everything possible with these loops. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a60a37142e38a0a290d70b030405db801 "<a class="el" href="namespaceoperations__research_1_1sat.html#a60a37142e38a0a290d70b030405db801">operations_research::sat::ProbeAndSimplifyProblem</a>" (SatPostsolver *postsolver, LinearBooleanProblem *problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001061 (user): expose the number of iterations as a parameter.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a98f7eb19b1030f3da667a3914c7ba666 "<a class="el" href="namespaceoperations__research_1_1sat.html#a98f7eb19b1030f3da667a3914c7ba666">operations_research::sat::ProbeLiteral</a>" (Literal assumption, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001987 (user): Still use it if the problem is Boolean only. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#ab1e9d80c7f62d666ad8a3ec5a14f3c13 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a2127d7db0f3c791613c92c8177e02432">operations_research::sat::Prober::ProbeBooleanVariables</a>" (double deterministic_time_limit, absl::Span&lt; const BooleanVariable &gt; bool_vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002125 (user): Instead of an hard deterministic limit, we should probably
use a lower one, but reset it each time we have found something useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#a2127d7db0f3c791613c92c8177e02432 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a2127d7db0f3c791613c92c8177e02432">operations_research::sat::Prober::ProbeBooleanVariables</a>" (double deterministic_time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002133 (user): For now we process the Boolean in their natural order, this is
not the most efficient.&lt;p&gt; \anchor _todo002134 (user): This might generate a lot of new direct implications. We might
not want to add them directly to the BinaryImplicationGraph and could
instead use them directly to detect equivalent literal like in
ProbeAndFindEquivalentLiteral(). The situation is not clear.&lt;p&gt; \anchor _todo002135 (user): More generally, we might want to register any literal =&gt; bound
in the IntegerEncoder. This would allow to remember them and use them in
other part of the solver (cuts, lifting, ...).&lt;p&gt; \anchor _todo002136 (user): Rename to include Integer in the name and distinguish better
from FailedLiteralProbing() below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#a530c77d3421958a676e67d4463b2c1a1 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a530c77d3421958a676e67d4463b2c1a1">operations_research::sat::Prober::ProbeDnf</a>" (absl::string_view name, absl::Span&lt; const std::vector&lt; Literal &gt; &gt; dnf)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002126 (user): Can we use the callback_?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#a0ad34d874b506bc2be329d5cc4f8e185 "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#a0ad34d874b506bc2be329d5cc4f8e185">operations_research::sat::ProbingOptions::deterministic_limit</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002137 (user): We can also provide a middle ground and probe all failed
literal but do not extract all binary clauses.&lt;p&gt; \anchor _todo002138 (user): The fix point is not yet reached since we don't currently
simplify non-binary clauses with these equivalence, but we will. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#af5a82baa2dc19e7fe7e018b63c499042 "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#af5a82baa2dc19e7fe7e018b63c499042">operations_research::sat::ProbingOptions::extract_binary_clauses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002139 (user): Note that adding binary clause before/during the SAT presolve
is currently not always a good idea. This is because we don't simplify the
other clause as much as we could. Also, there can be up to a quadratic
number of clauses added this way, which might slow down things a lot. But
then because of the deterministic limit, we usually cannot add too much
clauses, even for huge problems, since we will reach the limit before that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#ab4df2ae2f59c5cb13fe680c9580fc64f "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#ab4df2ae2f59c5cb13fe680c9580fc64f">operations_research::sat::ProbingOptions::use_queue</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002140 (user): Decide which one is better, currently the difference seems
small but the queue seems slightly faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDecomposer Member \_internalref classoperations__research_1_1sat_1_1ProductDecomposer#a45c18f04782c89b35181121f284b5ceb "<a class="el" href="classoperations__research_1_1sat_1_1ProductDecomposer.html#a45c18f04782c89b35181121f284b5ceb">operations_research::sat::ProductDecomposer::TryToLinearize</a>" (const AffineExpression &amp;left, const AffineExpression &amp;right, LinearConstraintBuilder *builder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001665 (user): Experiment with x * x where constants = 0, x is
fully encoded, and the domain is small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a93e9dea2213cbcd19a3261b4ab6ad7fd "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a93e9dea2213cbcd19a3261b4ab6ad7fd">operations_research::sat::ProductDetector::InitializeBooleanRLTCuts</a>" (const absl::flat_hash_map&lt; IntegerVariable, glop::ColIndex &gt; &amp;lp_vars, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001668 (user): limit work if too many ternary.
 &lt;p&gt; \anchor _todo001669 (user): Maybe we shouldn't reconstruct this every time, but it is hard
in case of multiple lps to make sure we don't use variables not in the lp
otherwise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a3a17220935c42077613be222734fef7a "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a3a17220935c42077613be222734fef7a">operations_research::sat::ProductDetector::LinearizeProduct</a>" (IntegerVariable a, IntegerVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001678 (user): Implement!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#af7fe2b019ee2556cd2b2813b34877945 "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#af7fe2b019ee2556cd2b2813b34877945">operations_research::sat::ProductDetector::ProcessBinaryClause</a>" (absl::Span&lt; const Literal &gt; binary_clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001666 (user): As product are discovered, we could remove entries from our
hash maps! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a7473e11336cf79ccf7f4a54a890625fc "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a7473e11336cf79ccf7f4a54a890625fc">operations_research::sat::ProductDetector::ProcessConditionalEquality</a>" (Literal l, IntegerVariable x, IntegerVariable y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001667 (user): Linear scan can be bad if b =&gt; X = many other variables.
Hopefully this will not be common. 
 &lt;p&gt; \anchor _todo001677 (user): Generalize to a * X + b = l * (Y + c) since these are also
easy to linearize if we see l * Y. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a308ee96e864c4e4fac744ac329ecac39 "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a308ee96e864c4e4fac744ac329ecac39">operations_research::sat::ProductDetector::ProductLowerBound</a>" (IntegerVariable a, IntegerVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001679 (user): Implement! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductPropagator Member \_internalref classoperations__research_1_1sat_1_1ProductPropagator#a1a947c821f05a6e347602ffaa4162d1d "<a class="el" href="classoperations__research_1_1sat_1_1ProductPropagator.html#a1a947c821f05a6e347602ffaa4162d1d">operations_research::sat::ProductPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001736 (user): In the reasons, including all 4 bounds is always correct, but
we might be able to relax some of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad8873d5bb4db4affe6faa2da6553882a "<a class="el" href="namespaceoperations__research_1_1sat.html#ad8873d5bb4db4affe6faa2da6553882a" title="Fills and propagates the set of reachable states/labels.">operations_research::sat::PropagateAutomaton</a>" (const AutomatonConstraintProto &amp;proto, const PresolveContext &amp;context, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *states, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *labels)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001129 (user): Note that if we have duplicate variables controlling different
time point, this might not reach the fixed point. Fix? it is not that
important as the expansion take care of this case anyway. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad1ebf465eb7ccee4f79a5b8cfccfe7d9 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad1ebf465eb7ccee4f79a5b8cfccfe7d9">operations_research::sat::PropagateEncodingFromEquivalenceRelations</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001202 (user): This is not supposed to happen, but apparently it did on
once on routing_GCM_0001_sat.fzn. Investigate and fix. 
 &lt;p&gt; \anchor _todo001203 (user): This is similar to LoadEquivalenceAC() for unreified
constraints, but when the later is called, more encoding might have taken
place. 
 &lt;p&gt; \anchor _todo001211 (user): In an ideal world, all affine relations like this should be
removed in the presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProtoTrail Class \_internalref classoperations__research_1_1sat_1_1ProtoTrail "<a class="el" href="classoperations__research_1_1sat_1_1ProtoTrail.html">operations_research::sat::ProtoTrail</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002397 (user): It'd be good to store an earlier level at which
implications may be propagated. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7bb3adbf30215f4aafac3f24caf00f84 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7bb3adbf30215f4aafac3f24caf00f84">operations_research::sat::PseudoCost</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001759 (user): This will be overridden by the value decision heuristic in
almost all cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PseudoCosts Member \_internalref classoperations__research_1_1sat_1_1PseudoCosts#a21a08a0f912507d4cdcb1b9fea5e1297 "<a class="el" href="classoperations__research_1_1sat_1_1PseudoCosts.html#a21a08a0f912507d4cdcb1b9fea5e1297">operations_research::sat::PseudoCosts::AfterTakingDecision</a>" (bool conflict=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002141 (user): tune that.&lt;p&gt; \anchor _todo002142 (user): Handle this case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PseudoCosts Member \_internalref classoperations__research_1_1sat_1_1PseudoCosts#a78be0e06d6c1f84281b45b79cb946d92 "<a class="el" href="classoperations__research_1_1sat_1_1PseudoCosts.html#a78be0e06d6c1f84281b45b79cb946d92" title="Returns the variable with best reliable pseudo cost that is not fixed.">operations_research::sat::PseudoCosts::GetBestDecisionVar</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002143 (user): Supports search randomization tolerance.
 &lt;p&gt; &lt;p&gt;(user): Implement generic class to choose the randomized
solution, and supports sub-linear variable selection. 
 &lt;p&gt; \anchor _todo002144 (user): Avoid the O(num_relevant_variable) loop.
In practice since a variable only become relevant after 100 records, this
list might be small compared to the number of variable though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac2b9ed2c9fd55af7cfd4effe1ad5a5d6 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac2b9ed2c9fd55af7cfd4effe1ad5a5d6">operations_research::sat::RandomizeOnRestartHeuristic</a>" (bool lns_mode, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001772 (user): Add other policies and perform more experiments.
 &lt;p&gt; \anchor _todo001773 (user): Do more experiments to find better distribution. 
 &lt;p&gt; \anchor _todo001774 (user): These distribution values are just guessed values. They
need to be tuned. 
 &lt;p&gt; \anchor _todo001775 (user): Also use LP value as assignment like in Bop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a774bb7b95d0309e6e4448b044b88c456 "<a class="el" href="namespaceoperations__research_1_1sat.html#a774bb7b95d0309e6e4448b044b88c456" title="Adds the current LP solution to the pool.">operations_research::sat::RecordLPRelaxationValues</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002146 (user): The default of ::infinity() for variable for which we do not
have any LP solution is weird and inconsistent with ModelLpValues default
which is zero. Fix. Note that in practice, at linearization level 2, all
variable will eventually have an lp relaxation value, so it shoulnd't
matter much to just use zero in RINS/RENS. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4c7c0126948e1cf811fc9fe8519915e5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4c7c0126948e1cf811fc9fe8519915e5">operations_research::sat::ReduceNodes</a>" (Coefficient upper_bound, Coefficient *lower_bound, std::vector&lt; EncodingNode * &gt; *nodes, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001638 (user): with DEFAULT_ASSUMPTION_ORDER, this will lead to a somewhat
weird behavior, since we will reverse the nodes at each iteration... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxationInducedNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1RelaxationInducedNeighborhoodGenerator#aa4724e62d610d139a8ae7197f1004823 "<a class="el" href="classoperations__research_1_1sat_1_1RelaxationInducedNeighborhoodGenerator.html#aa4724e62d610d139a8ae7197f1004823" title="Both initial solution and difficulty values are ignored.">operations_research::sat::RelaxationInducedNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, double difficulty, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001176 (user): Instead of aborting, pick the closest point in the domain?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomConstraintsGenerator Class \_internalref classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator.html">operations_research::sat::RelaxRandomConstraintsGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001183 (user): In the presence of connected components, this should just work
on one of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomConstraintsGenerator Member \_internalref classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator#a3e22fc48cf6041968e6f6119e642cf64 "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator.html#a3e22fc48cf6041968e6f6119e642cf64">operations_research::sat::RelaxRandomConstraintsGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, double difficulty, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001171 (user): Clean-up when target_size == 0.
 &lt;p&gt; \anchor _todo001172 (user): randomize order of variable addition when close to the
limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomVariablesGenerator Class \_internalref classoperations__research_1_1sat_1_1RelaxRandomVariablesGenerator "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomVariablesGenerator.html">operations_research::sat::RelaxRandomVariablesGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001182 (user): In the presence of connected components, this should just work
on one of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a89dc2fa5d4896cd17270cf7d40099e08 "<a class="el" href="namespaceoperations__research_1_1sat.html#a89dc2fa5d4896cd17270cf7d40099e08">operations_research::sat::ReportEnergyConflict</a>" (Rectangle bounding_box, absl::Span&lt; const int &gt; boxes, SchedulingConstraintHelper *x, SchedulingConstraintHelper *y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001606 (user): Also relax the box if possible. 
 &lt;p&gt; \anchor _todo001608 (user): relax the bounding box dimension to have a relaxed explanation.
We can also minimize the number of required intervals. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RestartPolicy Member \_internalref classoperations__research_1_1sat_1_1RestartPolicy#a52594750ea119a9ac928e3f09b77f140 "<a class="el" href="classoperations__research_1_1sat_1_1RestartPolicy.html#a52594750ea119a9ac928e3f09b77f140" title="Resets the policy using the current model parameters.">operations_research::sat::RestartPolicy::Reset</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002145 (user): for some reason, strategies_.assign() does not work as the
returned type of the proto enum iterator is int ?! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RoundingOptions Struct \_internalref structoperations__research_1_1sat_1_1RoundingOptions "<a class="el" href="structoperations__research_1_1sat_1_1RoundingOptions.html">operations_research::sat::RoundingOptions</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001590 (user): There is a bunch of heuristic involved here, and we could spend
more effort tuning them. In particular, one can try many heuristics and keep
the best looking cut (or more than one). This is not on the critical code
path, so we can spend more effort in finding good cuts. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#a118a1b216d1e79a4b9c250f3030adda7 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#a118a1b216d1e79a4b9c250f3030adda7" title="Returns the vector of the current assignment preferences.">operations_research::sat::SatDecisionPolicy::AllPreferences</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002168 (user): we currently assume that if the tie_breaker is zero then
no preference was set (which is not 100% correct). Fix that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#ad02a374fc46af7a8ed8112257438dbc1 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#ad02a374fc46af7a8ed8112257438dbc1">operations_research::sat::SatDecisionPolicy::NextBranch</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002169 (user): This may not be super efficient if almost all the
variables are assigned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#a9f05bb03afa86725c194d50e613f2593 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#a9f05bb03afa86725c194d50e613f2593" title="Called on Untrail() so that we can update the set of possible decisions.">operations_research::sat::SatDecisionPolicy::Untrail</a>" (int target_trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002170 (user): avoid looping twice over the trail?
 &lt;p&gt; \anchor _todo002171 (user): Expose parameters for these values. 
 &lt;p&gt; \anchor _todo002172 (user): This heuristic can make this code quite slow because
all the untrailed variable will cause a priority queue update. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPostsolver Member \_internalref classoperations__research_1_1sat_1_1SatPostsolver#a3336b2762049c2d81e2bd255e9c9ecc8 "<a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html#a3336b2762049c2d81e2bd255e9c9ecc8">operations_research::sat::SatPostsolver::Clause</a>" (int i) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002313 (user): we could avoid the copy here, but because clauses_literals_
is a deque, we do need a special return class and cannot juste use
absl::Span&lt;Literal&gt; for instance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPostsolver Member \_internalref classoperations__research_1_1sat_1_1SatPostsolver#ad351af493e5b70fc12534bc0806cc444 "<a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html#ad351af493e5b70fc12534bc0806cc444">operations_research::sat::SatPostsolver::FixVariable</a>" (Literal x)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002312 (user): this as almost the same effect as adding an unit clause, and we
should probably remove this to simplify the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolveOptions Member \_internalref structoperations__research_1_1sat_1_1SatPresolveOptions#a99051170412df0832ce84112ddd314c0 "<a class="el" href="structoperations__research_1_1sat_1_1SatPresolveOptions.html#a99051170412df0832ce84112ddd314c0">operations_research::sat::SatPresolveOptions::use_transitive_reduction</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002233 (user): Doing that before the current SAT presolve also change the
possible reduction. This shouldn't matter if we use the binary implication
graph and its reachability instead of just binary clause though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Class \_internalref classoperations__research_1_1sat_1_1SatPresolver "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html">operations_research::sat::SatPresolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002309 (user): Interact more with a SAT solver to reuse its propagation logic.&lt;p&gt; \anchor _todo002310 (user): Forbid the removal of some variables. This way we can presolve
only the clause part of a general Boolean problem by not removing variables
appearing in pseudo-Boolean constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a670988de72965600bed15b192faa433a "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a670988de72965600bed15b192faa433a">operations_research::sat::SatPresolver::ClauseIndex</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002314 (user): use IntType!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a4b58b71a43c02cbec8fefb126f0a61cb "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a4b58b71a43c02cbec8fefb126f0a61cb">operations_research::sat::SatPresolver::CrossProduct</a>" (Literal x)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002303 (user): Choose if we use x or x.Negated() depending on the list
sizes? The function achieve the same if x = x.Negated(), however the
loops are not done in the same order which may change this incomplete
"blocked" clause detection. 
 &lt;p&gt; \anchor _todo002304 (user): We could only update the priority queue once for each variable
instead of doing it many times. 
 &lt;p&gt; \anchor _todo002305 (user): At this point x.Variable() is added back to the priority queue.
Avoid doing that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#adb7846ae7bbe4ca2e07a1dba94fe686e "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a32df98e6426d1e7a18247a18207717f1">operations_research::sat::SatPresolver::Presolve</a>" (const std::vector&lt; bool &gt; &amp;var_that_can_be_removed)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002292 (user): When a clause is strengthened, add it to a queue so it can
be processed again? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a32df98e6426d1e7a18247a18207717f1 "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a32df98e6426d1e7a18247a18207717f1">operations_research::sat::SatPresolver::Presolve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002315 (user): Add support for a time limit and some kind of iterations limit
so that this can never take too much time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#af7e0881274e8e8cec31c85429900b42a "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#af7e0881274e8e8cec31c85429900b42a" title="Visible for testing. Just applies the BVA step of the presolve.">operations_research::sat::SatPresolver::PresolveWithBva</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002293 (user): Put work limit in place !
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a8d8418b2601e61829de5e7b3f4df122b "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a8d8418b2601e61829de5e7b3f4df122b">operations_research::sat::SatPresolver::ProcessClauseToSimplifyOthers</a>" (ClauseIndex clause_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002300 (user): Binary clauses are really common, and we can probably do this
more efficiently for them. For instance, we could just take the intersection
of two sorted lists to get the simplified clauses. 
 &lt;p&gt; \anchor _todo002301 (user): not super optimal since we could abort earlier if
opposite_literal is not the negation of shortest_list. Note that this
applies to the second call to
ProcessClauseToSimplifyOthersUsingLiteral() above too. 
 &lt;p&gt; \anchor _todo002302 (user): remove the old clauses_[ci] afterwards.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPropagator Member \_internalref classoperations__research_1_1sat_1_1SatPropagator#a2bde4f8c3d7c6326050ac164391bf2a7 "<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a2bde4f8c3d7c6326050ac164391bf2a7" title="######################## Implementations below ########################">operations_research::sat::SatPropagator::PropagatePreconditionsAreSatisfied</a>" (const Trail &amp;trail) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002159 (user): A few of these method should be moved in a .cc
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPropagator Member \_internalref classoperations__research_1_1sat_1_1SatPropagator#a68acada7af835c9c6870ceb876dc2d9c "<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a68acada7af835c9c6870ceb876dc2d9c">operations_research::sat::SatPropagator::Untrail</a>" (const Trail &amp;trail, int trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002165 (user): Currently this is called at each Backtrack(), but we could
bundle the calls in case multiple conflict one after the other are detected
even before the Propagate() call of a SatPropagator is called.&lt;p&gt; \anchor _todo002166 (user): It is not yet 100% the case, but this can be guaranteed to be
called with a trail index that will always be the start of a new decision
level. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a8b9ba983bd9f911d0605f7615ebf3725 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8b9ba983bd9f911d0605f7615ebf3725">operations_research::sat::SatSolver::AddClauseDuringSearch</a>" (absl::Span&lt; const Literal &gt; literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002238 (user): We generate in some corner cases clauses with
literals[0].Variable() == literals[1].Variable(). Avoid doing that and
adding such binary clauses to the graph? 
 &lt;p&gt; \anchor _todo002281 (user): Backjump and propagate on a falsified clause? this is currently
not needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a098038f8e0409a8243ff3f7eafb517f8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a098038f8e0409a8243ff3f7eafb517f8">operations_research::sat::SatSolver::AddLinearConstraint</a>" (bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002277 (user): Instead of failing, implement an error handling code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a2613df5393b4e2285789856150543b70 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a2613df5393b4e2285789856150543b70">operations_research::sat::SatSolver::AddProblemClause</a>" (absl::Span&lt; const Literal &gt; literals, bool is_safe=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002276 (user): Rename this to AddClause(), also get rid of the specialized
AddUnitClause(), AddBinaryClause() and AddTernaryClause() since they
just end up calling this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a7c0c2912da716e49c8b5d84108e463d7 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7c0c2912da716e49c8b5d84108e463d7">operations_research::sat::SatSolver::Backtrack</a>" (int target_level)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002248 (user): The backtrack method should not be called when the model is
        unsat. Add a DCHECK to prevent that, but before fix the
        bop::BopOptimizerBase architecture. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a1ac88207c0228d80d19751186955240f "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a1ac88207c0228d80d19751186955240f">operations_research::sat::SatSolver::deterministic_time</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002237 (user): Find a better procedure to fix the weight than just educated
guess. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a0174fd7221118d81a925d32aaed1cc79 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a0174fd7221118d81a925d32aaed1cc79">operations_research::sat::SatSolver::ExtractClauses</a>" (Output *out)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002280 (user): also copy the removable clauses? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#ad4458486171153c1793c28e2091140d9 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ad4458486171153c1793c28e2091140d9">operations_research::sat::SatSolver::FinishPropagation</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002242 (user): Exiting like this might cause issue since the propagation
is not "finished" but some code might assume it is. However since we
already might repropagate in the LP constraint, most of the code
should support "not finished propagation". 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a84e27e6cb848b3176ab5680292d116a8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a84e27e6cb848b3176ab5680292d116a8">operations_research::sat::SatSolver::IsModelUnsat</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002278 (user): remove this function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a5420a6d871314779beeac0c074241c1a "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a5420a6d871314779beeac0c074241c1a">operations_research::sat::SatSolver::model</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002274 (user): Remove. This is temporary for accessing the model deep within
some old code that didn't use the Model object. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a3afed23ec8289b170f0a25ec4b10dd84 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a3afed23ec8289b170f0a25ec4b10dd84">operations_research::sat::SatSolver::ProcessCurrentConflict</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002243 (user): We might still want to "learn" the clause, especially if
it reduces to only one literal in which case we can just fix it. 
 &lt;p&gt; \anchor _todo002244 (user): Note that we use the clause above to update the variable
activities and not the pb conflict. Experiment. 
 &lt;p&gt; \anchor _todo002245 (user): This is error prone, find a better way? 
 &lt;p&gt; \anchor _todo002246 (user): It is unclear what the best heuristic is here. Both the current
trail index or the trail before the current decision perform well, but
using the full trail seems slightly better even though it will contain the
current conflicting literal. 
 &lt;p&gt; \anchor _todo002247 (user): Either remove that algorithm or support subsumption by just
checking if it is okay to do so, or doing it on the fly while computing the
first UIP. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a9188c70cc1096900a623a26319a1d4b8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">operations_research::sat::SatSolver::Propagate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002258 (user): Support propagating only the "first" propagators. That can
be useful for probing/in-processing, so we can control if we do only the SAT
part or the full integer part... 
 &lt;p&gt; \anchor _todo002259 (user): This might not really be needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a50484f243bcc0ec12ed3919d84dc38ad "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a50484f243bcc0ec12ed3919d84dc38ad">operations_research::sat::SatSolver::SetAssignmentPreference</a>" (Literal literal, float weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002279 (user): Clean this up by making clients directly talk to
SatDecisionPolicy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#ae8f40548efeb9f6bde6ff1cd872acc38 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ae8f40548efeb9f6bde6ff1cd872acc38">operations_research::sat::SatSolver::SetNumVariables</a>" (int num_variables)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002275 (user): Rename to IncreaseNumVariablesTo() until we support removing
variables... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SavedVariable Class \_internalref classoperations__research_1_1sat_1_1SavedVariable "<a class="el" href="classoperations__research_1_1sat_1_1SavedVariable.html">operations_research::sat::SavedVariable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002107 (user): get rid of this, we don't have the notion of equivalent variable
anymore, but the more general affine relation one. We just need to support
general affine for the linear1 involving an absolute value. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad6d384c7c56f3027894875278e4b9526 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad6d384c7c56f3027894875278e4b9526">operations_research::sat::ScaleContinuousVariables</a>" (double scaling, double max_bound, MPModelProto *mp_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001967 (user): Also scale the solution hint if any. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab5275984bb2d64275b69e881316b7f34 "<a class="el" href="namespaceoperations__research_1_1sat.html#ab5275984bb2d64275b69e881316b7f34">operations_research::sat::ScanModelForDominanceDetection</a>" (PresolveContext &amp;context, VarDomination *var_domination)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002384 (user): Maybe we should avoid recomputing that here.
 &lt;p&gt; \anchor _todo002385 (user): Handle enforcement better here. 
 &lt;p&gt; \anchor _todo002386 (user): the way we process that is a bit restrictive. By
working on the implication graph we could detect more dominance
relations. Since if a =&gt; b we say that a++ can only be paired with
b&amp;ndash;, but it could actually be paired with any variables that when
dereased implies b = 0. This is a bit mitigated by the fact that
we regroup when we can such implications into big at most ones. 
 &lt;p&gt; \anchor _todo002387 (user): We might be able to detect that nothing can be done earlier
during the constraint scanning. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7b440ecab00a601d5643f21df87c7cc6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7b440ecab00a601d5643f21df87c7cc6" title="Scan the model so that dual_bound_strengthening.Strenghten() works.">operations_research::sat::ScanModelForDualBoundStrengthening</a>" (const PresolveContext &amp;context, DualBoundStrengthening *dual_bound_strengthening)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002388 (user): Maybe we should avoid recomputing that here.
 &lt;p&gt; \anchor _todo002389 (user): Handle enforcement better here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ScatteredIntegerVector Member \_internalref classoperations__research_1_1sat_1_1ScatteredIntegerVector#a5d028844e2ffb568bbc68185f7cb6260 "<a class="el" href="classoperations__research_1_1sat_1_1ScatteredIntegerVector.html#a5d028844e2ffb568bbc68185f7cb6260">operations_research::sat::ScatteredIntegerVector::ConvertToLinearConstraint</a>" (absl::Span&lt; const IntegerVariable &gt; integer_variables, IntegerValue upper_bound, std::optional&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; extra_term=std::nullopt)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001900 (user): Ideally we should convert to IntegerVariable as late as
possible. Prefer to use GetTerms(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SccGraph Member \_internalref classoperations__research_1_1sat_1_1SccGraph#aee95126bcb16bb7a70ab00218a15fd7f "operations_research::sat::SccGraph::operator[]" (int32_t node) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001099 (user): avoid looping more than twice on the same at most one
constraints? Note that the second time we loop we have x =&gt; y =&gt;
not(x), so we can already detect that x must be false which we
detect below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#acbf45814a5a4f7554173a02e61970fa8 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#acbf45814a5a4f7554173a02e61970fa8">operations_research::sat::SchedulingConstraintHelper::GetCurrentMinDistanceBetweenTasks</a>" (int a, int b, bool add_reason_if_after=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001796 (user): be more precise when we know a and b are in disjunction.
we really just need start_b &gt; start_a, or even &gt;= if duration is non-zero. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a648ff007cfc81bd0a4369701a7048a27 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a648ff007cfc81bd0a4369701a7048a27">operations_research::sat::SchedulingConstraintHelper::GetEnergyProfile</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001798 (user): Avoid recomputing it if nothing changed.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a98e816cae622855fe8eae0766b4e0aaf "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a98e816cae622855fe8eae0766b4e0aaf">operations_research::sat::SchedulingConstraintHelper::InPropagationLoop</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001804 (user): Change the propagation loop code so that we don't stop
pushing in the middle of the propagation as more advanced propagator do
not handle this correctly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a4f2023a21c5e1475e6468be2147b6e14 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a4f2023a21c5e1475e6468be2147b6e14">operations_research::sat::SchedulingConstraintHelper::PropagatePrecedence</a>" (int a, int b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001797 (user): Adding new constraint during propagation might not be the
best idea as it can create some complication. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a230beffeb33f166d27bc233bed77237a "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a3e7ffb0e41b9e4bc01f0aa0c5c9bd373">operations_research::sat::SchedulingConstraintHelper::SchedulingConstraintHelper</a>" (int num_tasks, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001802 (user): Remove this. It is a hack because the disjunctive class needs
to fetch the maximum possible number of task at construction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#aac6715a4e5f01196e19399a749218d13 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#aac6715a4e5f01196e19399a749218d13">operations_research::sat::SchedulingConstraintHelper::SetLevel</a>" (int level) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001794 (user): We could be smarter here, but then this is not visible in our
cpu_profile since we call many times IncrementalPropagate() for each new
decision, but just call Propagate() once after each Untrail(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a0829ed1b078db163e11c4114f71758c3 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a0829ed1b078db163e11c4114f71758c3">operations_research::sat::SchedulingConstraintHelper::TaskByIncreasingStartMin</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001803 (user): we could merge the first loop of IncrementalSort() with the
loop that fill TaskTime.time at each call. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Class \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">operations_research::sat::SchedulingDemandHelper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001801 (user): Cache energy min and reason for the non O(1) cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#a8b7226d12b17723e0174250fd2024f46 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#a8b7226d12b17723e0174250fd2024f46">operations_research::sat::SchedulingDemandHelper::AddEnergyMinInWindowReason</a>" (int t, IntegerValue window_start, IntegerValue window_end)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001800 (user): only include the one we need?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#a9019a263126e78ddf332f696649fda87 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#a9019a263126e78ddf332f696649fda87">operations_research::sat::SchedulingDemandHelper::CacheAllEnergyValues</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001806 (user): this is error prone, maybe we should revisit. But if
there is many alternatives, we don't want to rescan the list more than a
linear number of time per propagation.&lt;p&gt; \anchor _todo001807 (user): Add more complex EnergyMinBefore(time) once we also support
expressing the interval as a set of alternatives.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#ad690f09e6894f8f9e9b01642fa1fc822 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#ad690f09e6894f8f9e9b01642fa1fc822">operations_research::sat::SchedulingDemandHelper::DecreaseEnergyMax</a>" (int t, IntegerValue value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001799 (user): Propagate if possible.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a85b41013bb2f7709a99765d5c491f381 "<a class="el" href="namespaceoperations__research_1_1sat.html#a85b41013bb2f7709a99765d5c491f381" title="A simple heuristic for scheduling models.">operations_research::sat::SchedulingSearchHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001760 (user): we should also precompute fixed precedences and only fix
interval that have all their predecessors fixed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a27627e1dbc84d49b68294ac92e9bc72c "<a class="el" href="namespaceoperations__research_1_1sat.html#a27627e1dbc84d49b68294ac92e9bc72c">operations_research::sat::SeparateFlowInequalities</a>" (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const AffineExpression &gt; arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, const absl::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, LinearConstraintManager *manager, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002150 (user): Alternatively, try MIR heuristics if the coefficients in
the capacities are not all the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2b655336dd6b108cddff7ff5e87360d3 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2b655336dd6b108cddff7ff5e87360d3">operations_research::sat::SeparateSubtourInequalities</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; Literal &gt; &amp;literals, absl::Span&lt; const int64_t &gt; demands, int64_t capacity, LinearConstraintManager *manager, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002148 (user): Currently if we add too many not so relevant cuts, our generic
MIP cut heuritic are way too slow on TSP/VRP problems. 
 &lt;p&gt; \anchor _todo002149 (user): I had an older version that tried the n-cuts generated during
the course of the algorithm. This could also be interesting. But it is
hard to tell with our current benchmark setup. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4accab74442b986ddcc870636b232756 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4accab74442b986ddcc870636b232756">operations_research::sat::SequentialValueSelection</a>" (std::vector&lt; std::function&lt; IntegerLiteral(IntegerVariable)&gt; &gt; value_selection_heuristics, std::function&lt; BooleanOrIntegerLiteral()&gt; var_selection_heuristic, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001757 (user): we will likely stop at the first non-fixed variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedBoundsManager Member \_internalref classoperations__research_1_1sat_1_1SharedBoundsManager#aa52efbe166740ce4b1f22c820a64ffc6 "<a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html#aa52efbe166740ce4b1f22c820a64ffc6">operations_research::sat::SharedBoundsManager::FixVariablesFromPartialSolution</a>" (const std::vector&lt; int64_t &gt; &amp;solution, const std::vector&lt; int &gt; &amp;variables_to_fix)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002332 (user): Because we look at the non-synchronized and up to date bounds,
this break determinism if two solution for the same subpart comes at the same
time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedClausesManager Member \_internalref classoperations__research_1_1sat_1_1SharedClausesManager#a3ebbcf2be803ef7f2cbad87a044dc4ec "<a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html#a3ebbcf2be803ef7f2cbad87a044dc4ec" title="Unlocks waiting binary clauses for workers if always_synchronize is false.">operations_research::sat::SharedClausesManager::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002333 (user): We could cleanup added_binary_clauses_ periodically.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedResponseManager Member \_internalref classoperations__research_1_1sat_1_1SharedResponseManager#adbf9c545bd1e91d71d36638ca7c1acfd "<a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html#adbf9c545bd1e91d71d36638ca7c1acfd">operations_research::sat::SharedResponseManager::NewSolution</a>" (absl::Span&lt; const int64_t &gt; solution_values, const std::string &amp;solution_info, Model *model=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002331 (user): Remove this code and the need for model in this function.
Use search log callbacks instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedResponseManager Member \_internalref classoperations__research_1_1sat_1_1SharedResponseManager#af4876e4857461716fabf61e3df652bd6 "<a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html#af4876e4857461716fabf61e3df652bd6" title="Updates the inner objective bounds.">operations_research::sat::SharedResponseManager::UpdateInnerObjectiveBounds</a>" (const std::string &amp;update_info, IntegerValue lb, IntegerValue ub)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002329 (user): A thread might not be notified right away that the new bounds
that it is pushing make the problem infeasible. Fix that. For now we just
abort early here to avoid logging the "#Done" message multiple times. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Class \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository "operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002334 (user): Maybe add some criteria to only keep solution with an objective
really close to the best solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Member \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository#a5c764f4976d30e6f103b76a929402c87 "<a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html#a5c764f4976d30e6f103b76a929402c87" title="Returns a random solution biased towards good solutions.">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::GetRandomBiasedSolution</a>" (absl::BitGenRef random) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002335 (user): Experiments on the best distribution.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository::Solution Member \_internalref structoperations__research_1_1sat_1_1SharedSolutionRepository_1_1Solution#a1e89b8e75d0f5d4196f9cc06abbfa689 "<a class="el" href="structoperations__research_1_1sat_1_1SharedSolutionRepository_1_1Solution.html#a1e89b8e75d0f5d4196f9cc06abbfa689">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::Solution::rank</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002337 (user): Some LNS code assume that for the SharedSolutionRepository
this rank is actually the unscaled internal minimization objective.
Remove this assumptions by simply recomputing this value since it is not
too costly to do so. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Member \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository#a902c7f2bb1e91b85d85bad84726bf89b "<a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html#a902c7f2bb1e91b85d85bad84726bf89b">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002336 (user): Introduce a notion of orthogonality to diversify the pool? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedTreeManager Member \_internalref classoperations__research_1_1sat_1_1SharedTreeManager#a98c561c89b5bc43b4aa0debbcef4200e "<a class="el" href="classoperations__research_1_1sat_1_1SharedTreeManager.html#a98c561c89b5bc43b4aa0debbcef4200e">operations_research::sat::SharedTreeManager::ProposeSplit</a>" (ProtoTrail &amp;path, ProtoLiteral decision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002395 (user): Need to write up the shape this creates.
This rule will allow twice as many leaves in the preferred subtree. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedTreeManager Member \_internalref classoperations__research_1_1sat_1_1SharedTreeManager#aa6d71bb864a47eaeb3edb91b97819686 "<a class="el" href="classoperations__research_1_1sat_1_1SharedTreeManager.html#aa6d71bb864a47eaeb3edb91b97819686" title="Assigns a path prefix that the worker should explore.">operations_research::sat::SharedTreeManager::ReplaceTree</a>" (ProtoTrail &amp;path)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002396 (user): Investigate assigning a random leaf so workers can still
improve shared tree bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0479a7ca6dd22cbabccdf623aea07315 "<a class="el" href="namespaceoperations__research_1_1sat.html#a0479a7ca6dd22cbabccdf623aea07315">operations_research::sat::SimplifyCanonicalBooleanLinearConstraint</a>" (std::vector&lt; LiteralWithCoeff &gt; *cst, Coefficient *rhs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002018 (user): Use more complex simplification like dividing by the gcd of
everyone and using less different coefficients if possible. 
 &lt;p&gt; \anchor _todo002019 (user): It is probably better to remove these literals and have other
constraint setting them to false from the symmetry finder perspective. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab649ca11fd81e049dc7a8c0dd1104b5b "<a class="el" href="namespaceoperations__research_1_1sat.html#ab649ca11fd81e049dc7a8c0dd1104b5b">operations_research::sat::SimplifyClause</a>" (const std::vector&lt; Literal &gt; &amp;a, std::vector&lt; Literal &gt; *b, LiteralIndex *opposite_literal, int64_t *num_inspected_literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002311 (user): when a.size() &lt;&lt; b.size(), we should use binary search instead
of scanning b linearly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a336d2faa10d80d646232f5e6d91891d4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a336d2faa10d80d646232f5e6d91891d4">operations_research::sat::SolutionIsFeasible</a>" (const CpModelProto &amp;model, absl::Span&lt; const int64_t &gt; variable_values, const CpModelProto *mapping_proto, const std::vector&lt; int &gt; *postsolve_mapping)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001126 (user): This is not really a "feasibility" question, but we should
probably check that the response objective matches with the one we can
compute here. This might better be done in another function though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9d67b9c66f1cb9c1dcc3415cd5af11bf "<a class="el" href="namespaceoperations__research_1_1sat.html#a9d67b9c66f1cb9c1dcc3415cd5af11bf">operations_research::sat::SolveCpModel</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001429 (user): We currently reuse the MODEL_INVALID status even though it
is not the best name for this. Maybe we can add a PARAMETERS_INVALID
when it become needed. Or rename to INVALID_INPUT ? 
 &lt;p&gt; \anchor _todo001430 (user): provide an option to skip this step for speed? 
 &lt;p&gt; \anchor _todo001431 (user): Change status to IMPRECISE? 
 &lt;p&gt; \anchor _todo001432 (user): for now, we just use the domain inferred during
presolve. 
 &lt;p&gt; \anchor _todo001433 (user): We could try to dump our linear relaxation too. 
 &lt;p&gt; \anchor _todo001434 (user): Even for an optimization, if we load the solution right away,
we might not have the same behavior as the initial search that follow the
hint will be infeasible, so the activities of the variables will be
different. 
 &lt;p&gt; \anchor _todo001435 (user): Reuse a Subsolver to get the same display as for the
parallel case. Right now we don't have as much stats for single thread! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a43a3828d1897a92ece5fd4f6018fe3da "<a class="el" href="namespaceoperations__research_1_1sat.html#a43a3828d1897a92ece5fd4f6018fe3da">operations_research::sat::SolveDiophantine</a>" (absl::Span&lt; const int64_t &gt; coeffs, int64_t rhs, absl::Span&lt; const int64_t &gt; var_lbs, absl::Span&lt; const int64_t &gt; var_ubs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001610 (user): look if there is a natural improvement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa4dae45317363a09e5f5f5ac22394f74 "<a class="el" href="namespaceoperations__research_1_1sat.html#aa4dae45317363a09e5f5f5ac22394f74">operations_research::sat::SolveFzWithCpModelProto</a>" (const fz::Model &amp;fz_model, const fz::FlatzincSatParameters &amp;p, const std::string &amp;sat_params, SolverLogger *logger, SolverLogger *solution_logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000399 (user): Supports setting the number of workers to 0, which will
then query the number of cores available. This is complex now as we
need to still support the expected behabior (no flags -&gt; 1 thread
fixed search, -f -&gt; 1 thread free search). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2af162f5376a8d8234b9287b5c8163c1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2af162f5376a8d8234b9287b5c8163c1">operations_research::sat::SplitAndLoadIntermediateConstraints</a>" (bool lb_required, bool ub_required, std::vector&lt; IntegerVariable &gt; *vars, std::vector&lt; int64_t &gt; *coeffs, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001205 (user): We could use a smarter way to determine buckets, like putting
everyone with the same coeff together if possible and the split is ok. 
 &lt;p&gt; \anchor _todo001212 (user): Alternatively, we could use a O(num_changes) propagation (a
bit tricky to implement), or a decomposition into a tree with more than
one level. Both requires experimentations. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5154a61154ff9b3522e0c0eba7ed0319 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5154a61154ff9b3522e0c0eba7ed0319">operations_research::sat::SplitAroundLpValue</a>" (IntegerVariable var, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001750 (user): Depending if we branch up or down, this might not exclude the
LP value, which is potentially a bad thing.&lt;p&gt; \anchor _todo001751 (user): Why is the reduced cost doing things differently? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SquarePropagator Class \_internalref classoperations__research_1_1sat_1_1SquarePropagator "<a class="el" href="classoperations__research_1_1sat_1_1SquarePropagator.html">operations_research::sat::SquarePropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001744 (user): Only works for x nonnegative. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#a2e92cf06868589083c5369b049fc5a26 "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#a2e92cf06868589083c5369b049fc5a26">operations_research::sat::StampingSimplifier::ComputeStampsForNextRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002200 (user): compute some dtime, it is always zero currently.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#abf4ca83561578670ef702769097d29fd "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#abf4ca83561578670ef702769097d29fd">operations_research::sat::StampingSimplifier::DoOneRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002199 (user): We could probably deal with it if needed so that we don't
need to do equivalence detection each time we want to run this. 
 &lt;p&gt; \anchor _todo002235 (user): To save one scan over all the clauses, we could do the fixed
and equivalence variable cleaning here too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#adeaa7bc64c667a667195ba5f6161f8c1 "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#adeaa7bc64c667a667195ba5f6161f8c1">operations_research::sat::StampingSimplifier::ProcessClauses</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002204 below. 
 &lt;p&gt; \anchor _todo002205 (user): Note that it is okay to still use top_entry, but we
might miss the removal of b if b =&gt; c. Also the paper do things
differently. Make sure we don't miss any simplification
opportunites by not changing top_entry. Same in the other
branches. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#ab4ed798d7a5c1b5957e4f9605963174e "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#ab4ed798d7a5c1b5957e4f9605963174e" title="Visible for testing.">operations_research::sat::StampingSimplifier::SampleTreeAndFillParent</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002201 (user): Better algo to not select redundant parent.&lt;p&gt; \anchor _todo002202 (user): if parents_[x] = y, try not to have parents_[not(y)] = not(x)
because this is not as useful for the simplification power.&lt;p&gt; \anchor _todo002203 (user): More generally, we could sample a parent while probing so
that we consider all hyper binary implications (in the case we don't add
them to the implication graph already). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a4edf090e6f497b612dab8bfc4b53cd4c "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a4edf090e6f497b612dab8bfc4b53cd4c">operations_research::sat::SubSolver::DeterministicTimingInfo</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002319 (user): remove trailing "<br  />
" from ValueAsString().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a68765bc7ed07ce93ffeddbe61ad40d65 "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a68765bc7ed07ce93ffeddbe61ad40d65">operations_research::sat::SubSolver::GenerateTask</a>" (int64_t task_id)=0&lt;/dt&gt;&lt;dd&gt; \anchor _todo002317 (user): We could use a more complex selection logic and pass in the
deterministic time limit this subtask should run for. Unclear at this
stage.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a03147f5723fa17d3ce80ace93578af57 "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a03147f5723fa17d3ce80ace93578af57">operations_research::sat::SubSolver::TimingInfo</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002318 (user): remove trailing "<br  />
" from ValueAsString() or just build the
table line directly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SymmetryPropagator Class \_internalref classoperations__research_1_1sat_1_1SymmetryPropagator "<a class="el" href="classoperations__research_1_1sat_1_1SymmetryPropagator.html">operations_research::sat::SymmetryPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002321 (user): Implement the optimizations mentioned in the paper?
 &lt;p&gt; &lt;p&gt;(user): Instrument and see if the code can be optimized. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SymmetryPropagator Member \_internalref classoperations__research_1_1sat_1_1SymmetryPropagator#a020a35d3244af33a45a416f037529459 "<a class="el" href="classoperations__research_1_1sat_1_1SymmetryPropagator.html#a020a35d3244af33a45a416f037529459">operations_research::sat::SymmetryPropagator::AddSymmetry</a>" (std::unique_ptr&lt; SparsePermutation &gt; permutation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002322 (user): Currently this can only be called before PropagateNext() is
called (DCHECKed). Not sure if we need more incrementality though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TimeTablingPerTask Class \_internalref classoperations__research_1_1sat_1_1TimeTablingPerTask "<a class="el" href="classoperations__research_1_1sat_1_1TimeTablingPerTask.html">operations_research::sat::TimeTablingPerTask</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002348 (user): Use SchedulingDemandHelper. In particular, if we know the task
is from a set of fixed alternatives, we might be able to push it more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TimeTablingPerTask Member \_internalref classoperations__research_1_1sat_1_1TimeTablingPerTask#a3e048be6a5e38900071af4c347b0dff9 "<a class="el" href="classoperations__research_1_1sat_1_1TimeTablingPerTask.html#a3e048be6a5e38900071af4c347b0dff9">operations_research::sat::TimeTablingPerTask::TimeTablingPerTask</a>" (AffineExpression capacity, SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002343 (user): This usually correspond to a makespan interval.
We should just detect and propagate it separately as it would result
in a faster propagation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopN Class \_internalref classoperations__research_1_1sat_1_1TopN "operations_research::sat::TopN&lt; Element, Score &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002370 (user): We could use gtl::TopN when/if it gets open sourced. Note that
we might be slighlty faster here since we use an indirection and don't move
the Element class around as much. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopN Member \_internalref classoperations__research_1_1sat_1_1TopN#aab2091998d8295f6ecc5fd5f2beeebbb "<a class="el" href="classoperations__research_1_1sat_1_1TopN.html#aab2091998d8295f6ecc5fd5f2beeebbb">operations_research::sat::TopN&lt; Element, Score &gt;::Add</a>" (Element e, Score score)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002373 (user): We could delay that on the n + 1 push.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopNCuts Class \_internalref classoperations__research_1_1sat_1_1TopNCuts "<a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">operations_research::sat::TopNCuts</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001845 (user): Avoid computing efficacity twice.
 &lt;p&gt; &lt;p&gt;(user): We don't use any orthogonality consideration here.
 &lt;p&gt; &lt;p&gt;(user): Detect duplicate cuts? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Trail Member \_internalref classoperations__research_1_1sat_1_1Trail#af94a42301fbeb5da23fdfd2c914f2a01 "<a class="el" href="classoperations__research_1_1sat_1_1Trail.html#af94a42301fbeb5da23fdfd2c914f2a01">operations_research::sat::Trail::Resize</a>" (int num_variables)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002160 (user): these vectors are not always used. Initialize them
dynamically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8fc9e60de9ebec04b0d8e62c0bcd7aa1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8fc9e60de9ebec04b0d8e62c0bcd7aa1">operations_research::sat::TransformToGeneratorOfStabilizer</a>" (int to_stabilize, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002327 (user): Implement! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7e710c5266505c51982912036c840755 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7e710c5266505c51982912036c840755" title="Adds linearization of different types of constraints.">operations_research::sat::TryToLinearizeConstraint</a>" (const CpModelProto &amp;model_proto, const ConstraintProto &amp;ct, int linearization_level, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *helper=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001943 (user): In full generality, we could encode all the constraint as an LP.
 &lt;p&gt; &lt;p&gt;(user): Add unit tests for this method.
 &lt;p&gt; &lt;p&gt;(user): Remove and merge with model loading. 
 &lt;p&gt; \anchor _todo001944 (user): Use the same pattern as the other 2 scheduling methods:
  - single function
  - generate helpers once&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa5783ecb0b6b7f12fc2ea70339ec7acd "<a class="el" href="namespaceoperations__research_1_1sat.html#aa5783ecb0b6b7f12fc2ea70339ec7acd">operations_research::sat::TryToReconcileEncodings</a>" (const AffineExpression &amp;size2_affine, const AffineExpression &amp;affine, absl::Span&lt; const ValueLiteralPair &gt; affine_var_encoding, bool put_affine_left_in_result, IntegerEncoder *integer_encoder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001663 (user): Consider removing this once we are more complete in our implied
bounds repository. Because if we can reconcile an encoding, then any of the
literal in the at most one should imply a value on the boolean view use in
the size2 affine. 
 &lt;p&gt; \anchor _todo001664 (user): I am not sure how this can happen since size2_affine is
supposed to be non-fixed. Maybe we miss some propag. Investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a67f3b45ddd9ba6330059295e6258e4e6 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a67f3b45ddd9ba6330059295e6258e4e6">operations_research::sat::UpperBoundedLinearConstraint::AddToConflict</a>" (MutableUpperBoundedLinearConstraint *conflict)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002038 (user): Provides instead an easy to use iterator over an
UpperBoundedLinearConstraint and move this function to
MutableUpperBoundedLinearConstraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a7e533d8923312b0d052abae98cab81b8 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a7e533d8923312b0d052abae98cab81b8">operations_research::sat::UpperBoundedLinearConstraint::FillReason</a>" (const Trail &amp;trail, int source_trail_index, BooleanVariable propagated_variable, std::vector&lt; Literal &gt; *reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002037 (user): Maybe it is possible to derive a better reason by using more
information. For instance one could use the mask of literals that are
better to use during conflict minimization (namely the one already in the
1-UIP conflict). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#ab83a887ed56694501b3e60f573db6d74 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#ab83a887ed56694501b3e60f573db6d74">operations_research::sat::UpperBoundedLinearConstraint::InitializeRhs</a>" (Coefficient rhs, int trail_index, Coefficient *threshold, Trail *trail, PbConstraintsEnqueueHelper *helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002023 (user): The source trail index for the propagation reason (i.e.
max_relevant_trail_index) may be higher than necessary (for some of the
propagated literals). Currently this works with FillReason(), but it was a
source of a really nasty bug (see CL 68906167) because of the (rhs == 1)
optim. Find a good way to test the logic. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a0d48dc8a24a03dea028d9f0e62ee257f "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a0d48dc8a24a03dea028d9f0e62ee257f">operations_research::sat::UpperBoundedLinearConstraint::ResolvePBConflict</a>" (const Trail &amp;trail, BooleanVariable var, MutableUpperBoundedLinearConstraint *conflict, Coefficient *conflict_slack)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002024 (user): Investigate if this is a good idea. It doesn't happen often,
but does happened. Maybe we can detect this before in Propagate()? The
setup is:
- At a given trail_index, var is propagated and added on the trail.
- There is some constraint literals assigned to true with a trail index
  in (trail_index, var.trail_index).
- Their sum is high enough to cause a conflict.
- But individually, their coefficients are too small to be propagated, so
  the conflict is not yet detected. It will be when these variables are
  processed by PropagateNext(). 
 &lt;p&gt; \anchor _todo002025 (user): If there is more "cancelation" than the min_coeffs below when
we add the two constraints, the resulting slack may be even lower. Taking
that into account is probably good. 
 &lt;p&gt; \anchor _todo002026 (user): The best will be to relax as little as possible. 
 &lt;p&gt; \anchor _todo002027 (user): track the cancelation here so we can update
*conflict_slack properly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2eec7d4958da587ee893e334ab7756cc "<a class="el" href="namespaceoperations__research_1_1sat.html#a2eec7d4958da587ee893e334ab7756cc">operations_research::sat::ValidateCpModel</a>" (const CpModelProto &amp;model, bool after_presolve)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001127 (user): Add any needed overflow validation because we are far from
exhaustive. We could also run a small presolve that tighten variable bounds
before the overflow check to facilitate the lives of our users, but it is a
some work to put in place. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2073b9c892ac56b197b31cb583e25f3d "<a class="el" href="namespaceoperations__research_1_1sat.html#a2073b9c892ac56b197b31cb583e25f3d">operations_research::sat::ValidateInputCpModel</a>" (const SatParameters &amp;params, const CpModelProto &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001128 (user): Ideally we would have just one ValidateCpModel() function but
this was introduced after many users already use ValidateCpModel() without
parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad582c9543b77917ac1084bbfda601f5e "<a class="el" href="namespaceoperations__research_1_1sat.html#ad582c9543b77917ac1084bbfda601f5e">operations_research::sat::ValidateLinearConstraintForOverflow</a>" (const LinearConstraint &amp;constraint, const IntegerTrail &amp;integer_trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001828 (user): Avoid duplication with PossibleIntegerOverflow() in the checker?
At least make sure the code is the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a80f1b6bbf960239725bec385f09a5b14 "<a class="el" href="namespaceoperations__research_1_1sat.html#a80f1b6bbf960239725bec385f09a5b14">operations_research::sat::ValidateParameters</a>" (const SatParameters &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002016 (user): Consider using annotations directly in the proto for these
validation. It is however not open sourced. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a007d129b4917935f84c9ae0823c2cb11 "<a class="el" href="namespaceoperations__research_1_1sat.html#a007d129b4917935f84c9ae0823c2cb11">operations_research::sat::VarDebugString</a>" (const CpModelProto &amp;proto, int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001124 (user): unfortunately, we need this indirection to get a DebugString()
in a const way from an index. Because building an IntVar is non-const. 
 &lt;p&gt; \anchor _todo001125 (user): Use domain pretty print function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VarDomination Class \_internalref classoperations__research_1_1sat_1_1VarDomination "<a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">operations_research::sat::VarDomination</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002393 (user): We have a lot of benchmarks and tests that shows that we don't
report wrong relations, but we lack unit test that make sure we don't miss
any. Try to improve the situation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VarDomination Member \_internalref classoperations__research_1_1sat_1_1VarDomination#ab03b7579b6f0728fd7c98fccae5196ed "<a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html#ab03b7579b6f0728fd7c98fccae5196ed">operations_research::sat::VarDomination::EndFirstPhase</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002374 (user): Use more heuristics to not miss as much dominance relation when
we crop initial lists. 
 &lt;p&gt; \anchor _todo002375 (user): Tune the initial size, 50 might be a bit large, since our
complexity is borned by this number times the number of entries in the
constraints. Still we should in most situation be a lot lower than that. 
 &lt;p&gt; \anchor _todo002376 (user): Maybe we should do that with all lists in case the
input function are called with duplicates too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VariableWithSameReasonIdentifier Class \_internalref classoperations__research_1_1sat_1_1VariableWithSameReasonIdentifier "<a class="el" href="classoperations__research_1_1sat_1_1VariableWithSameReasonIdentifier.html">operations_research::sat::VariableWithSameReasonIdentifier</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002034 (user): With the new SAME_REASON_AS mechanism, this is more general so
move out of pb_constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#a58a0ce20218c3abd705302dd4de5474f "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#a58a0ce20218c3abd705302dd4de5474f">operations_research::sat::ZeroHalfCutHelper::AddOneConstraint</a>" (glop::RowIndex, absl::Span&lt; const glop::ColIndex &gt; cols, absl::Span&lt; const IntegerValue &gt; coeffs, IntegerValue lb, IntegerValue ub)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002398 (user): experiment with the best value. probably only tight rows are
best? and we could use the basis status rather than recomputing the
activity for that.&lt;p&gt; \anchor _todo002399 (user): Avoid adding duplicates and just randomly pick one. Note
that we should also remove duplicate in a generic way. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#a67c63ecc26af5761893b5b5e93e7c5dd "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#a67c63ecc26af5761893b5b5e93e7c5dd">operations_research::sat::ZeroHalfCutHelper::ProcessVariables</a>" (const std::vector&lt; double &gt; &amp;lp_values, absl::Span&lt; const IntegerValue &gt; lower_bounds, absl::Span&lt; const IntegerValue &gt; upper_bounds)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002401 (user): This is a first implementation, both the heuristic and the
code performance can probably be improved uppon. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#a33f87ee16f3556183d93b891e7f21fe1 "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#a33f87ee16f3556183d93b891e7f21fe1">operations_research::sat::ZeroHalfCutHelper::SymmetricDifference</a>" (const std::vector&lt; int &gt; &amp;a, std::vector&lt; int &gt; *b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002400 (user): optim by doing that at the end?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SatInterface Member \_internalref classoperations__research_1_1SatInterface#aa26cae7629efd16954fcc84081c98410 "<a class="el" href="classoperations__research_1_1SatInterface.html#aa26cae7629efd16954fcc84081c98410">operations_research::SatInterface::SetPresolveMode</a>" (int value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000805 (user): Implement me.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a01d1829b304f98e931c8bd5f3ccdcc42 "<a class="el" href="namespaceoperations__research.html#a01d1829b304f98e931c8bd5f3ccdcc42">operations_research::SatSolveProto</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request, std::atomic&lt; bool &gt; *interrupt_solve, std::function&lt; void(const std::string &amp;)&gt; logging_callback, std::function&lt; void(const MPSolution &amp;)&gt; solution_callback)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000797 (user): We do not support all the parameters here. In particular the
logs before the solver is called will not be appended to the response. Fix
that, and remove code duplication for the logger config. One way should be
to not touch/configure anything if the logger is already created while
calling SolveCpModel() and call a common config function from here or from
inside Solve()? 
 &lt;p&gt; \anchor _todo000798 (user): We put the INFEASIBLE_OR_UNBOUNBED case here since there
is no return status that exactly matches it. 
 &lt;p&gt; \anchor _todo000799 (user): Implement the row and column status. 
 &lt;p&gt; \anchor _todo000800 (user): Remove the postsolve hack of copying to a response. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SavingsFilteredHeuristic::SavingsContainer Member \_internalref classoperations__research_1_1SavingsFilteredHeuristic_1_1SavingsContainer#aaaec4a18edcb597c52f8084e47e7f206 "<a class="el" href="classoperations__research_1_1SavingsFilteredHeuristic_1_1SavingsContainer.html#aaaec4a18edcb597c52f8084e47e7f206">operations_research::SavingsFilteredHeuristic::SavingsContainer&lt; S &gt;::Sort</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000363 (user): Also do this when reiterating on next_savings_. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScipConstraintHandlerContext Member \_internalref classoperations__research_1_1ScipConstraintHandlerContext#ae4b686d5d1040fcf4db709e98a2022af "<a class="el" href="classoperations__research_1_1ScipConstraintHandlerContext.html#ae4b686d5d1040fcf4db709e98a2022af">operations_research::ScipConstraintHandlerContext::is_pseudo_solution</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000811 (user): maybe this can be abstracted away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScipConstraintHandlerDescription Struct \_internalref structoperations__research_1_1ScipConstraintHandlerDescription "<a class="el" href="structoperations__research_1_1ScipConstraintHandlerDescription.html">operations_research::ScipConstraintHandlerDescription</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000810 (user): no effort has been made to optimize the default values of
enforcement_priority, feasibility_check_priority, eager_frequency, or
separation_priority. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SCIPInterface Member \_internalref classoperations__research_1_1SCIPInterface#a8682d7f525de8a5c389cf5e1b495f1ac "<a class="el" href="classoperations__research_1_1SCIPInterface.html#a8682d7f525de8a5c389cf5e1b495f1ac">operations_research::SCIPInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000812 (user): Is that still true now (2018) ? 
 &lt;p&gt; \anchor _todo000813 (user): I more or less copied this from the SCIPreadSol() code that
reads a solution from a file. I am not sure what SCIPisTransformed() is
or what is the difference between the try and add version. In any case
this seems to always call SCIPaddSolFree() for now and it works. 
 &lt;p&gt; \anchor _todo000814 (user): We could introduce our own "infeasible or unbounded" status. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScopedFloatingPointEnv Class \_internalref classoperations__research_1_1ScopedFloatingPointEnv "<a class="el" href="classoperations__research_1_1ScopedFloatingPointEnv.html">operations_research::ScopedFloatingPointEnv</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002410 (user): Make it work on 32 bits.
 &lt;p&gt; &lt;p&gt;(user): Make it work on msvc, currently calls to _controlfp crash. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SequenceVar Member \_internalref classoperations__research_1_1SequenceVar#a9858103573f2d43dda6714eacfc2b76b "<a class="el" href="classoperations__research_1_1SequenceVar.html#a9858103573f2d43dda6714eacfc2b76b">operations_research::SequenceVar::ComputePossibleFirstsAndLasts</a>" (std::vector&lt; int &gt; *possible_firsts, std::vector&lt; int &gt; *possible_lasts)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000374 (user): use domain iterator.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SequenceVar Member \_internalref classoperations__research_1_1SequenceVar#ac6537f9c14b5450c8e44ec475bce71c7 "<a class="el" href="classoperations__research_1_1SequenceVar.html#ac6537f9c14b5450c8e44ec475bce71c7" title="--— SequenceVar --—">operations_research::SequenceVar::SequenceVar</a>" (Solver *s, const std::vector&lt; IntervalVar * &gt; &amp;intervals, const std::vector&lt; IntVar * &gt; &amp;nexts, const std::string &amp;name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000373 (user): Add better class invariants, in particular checks
that ranked_first, ranked_last, and unperformed are truly disjoint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverMip Member \_internalref classoperations__research_1_1SetCoverMip#a67b99346dad8d9963a7e511760401bcb "<a class="el" href="classoperations__research_1_1SetCoverMip.html#a67b99346dad8d9963a7e511760401bcb">operations_research::SetCoverMip::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000053 (user): Add time-outs and exit with a partial solution. This seems
unlikely, though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a759cbf01a64672ed6d944df33e681bc7 "<a class="el" href="namespaceoperations__research.html#a759cbf01a64672ed6d944df33e681bc7">operations_research::setobjoffset</a>" (const XPRSprob &amp;mLp, double value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000825 detect xpress version
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleLinearSumAssignment Member \_internalref classoperations__research_1_1SimpleLinearSumAssignment#a613c560fdd07ae94350736adaf2dab56 "<a class="el" href="classoperations__research_1_1SimpleLinearSumAssignment.html#a613c560fdd07ae94350736adaf2dab56">operations_research::SimpleLinearSumAssignment::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000607 (user): Improve the LinearSumAssignment api to clearly define
the error cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Class \_internalref classoperations__research_1_1SimpleMaxFlow "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html">operations_research::SimpleMaxFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000665 (user): If the need arises, extend this interface to support warm start. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Member \_internalref classoperations__research_1_1SimpleMaxFlow#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700 "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700">operations_research::SimpleMaxFlow::POSSIBLE_OVERFLOW</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000668 (user): rename POSSIBLE_OVERFLOW to INT_OVERFLOW and modify our
clients. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Member \_internalref classoperations__research_1_1SimpleMaxFlow#a57296b653813abdd8d711048e87d1212 "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a57296b653813abdd8d711048e87d1212">operations_research::SimpleMaxFlow::SetArcCapacity</a>" (ArcIndex arc, FlowQuantity capacity)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000667 (user): Support incrementality in the max flow implementation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMinCostFlow Class \_internalref classoperations__research_1_1SimpleMinCostFlow "<a class="el" href="classoperations__research_1_1SimpleMinCostFlow.html">operations_research::SimpleMinCostFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000680 (user): If the need arises, extend this interface to support warm start
and incrementality between solves. Note that this is already supported by the
GenericMinCostFlow&lt;&gt; interface. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ae1b6e8c0d3d27218470118e9182605ed "<a class="el" href="namespaceoperations__research.html#ae1b6e8c0d3d27218470118e9182605ed">operations_research::SolveModelWithSat</a>" (RoutingModel *model, const RoutingSearchParameters &amp;search_parameters, const Assignment *initial_solution, Assignment *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000340 (user): Check that performance is acceptable.
 &lt;p&gt; \anchor _todo000341 (user): Check that performance is acceptable.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a1874495370d2fab28ba9487e2f845b81 "<a class="el" href="namespaceoperations__research.html#a1874495370d2fab28ba9487e2f845b81">operations_research::SolveMPModel</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request, const SolveInterrupter *interrupter)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000817 (b/311704821): this function should not delegate to MPSolver, also true
for the functions below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a4b71e8c5bbd90a2bcee8b0570328f91a "<a class="el" href="classoperations__research_1_1Solver.html#a4b71e8c5bbd90a2bcee8b0570328f91a">operations_research::Solver::Action</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000128 (user): wrap in swig.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a38d14a90db2f0ae3bc1563d453e4f93e "<a class="el" href="classoperations__research_1_1Solver.html#a38d14a90db2f0ae3bc1563d453e4f93e">operations_research::Solver::AddPropagationMonitor</a>" (PropagationMonitor *monitor)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000124 (user): Check solver state?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa290140ba6c4d6ef672c792a63bad57c "<a class="el" href="classoperations__research_1_1Solver.html#aa290140ba6c4d6ef672c792a63bad57c">operations_research::Solver::ClearNeighbors</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000130 (user): Find a workaround to avoid exposing this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a00ddb4cf5be5463ec6b494808bc8f192 "<a class="el" href="classoperations__research_1_1Solver.html#a00ddb4cf5be5463ec6b494808bc8f192" title="--— ConstraintSolverParameters --—">operations_research::Solver::DefaultSolverParameters</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000129 (user): Move to constraint_solver_parameters.h. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ae3b660d3dece402d0ca5448d127c0f6f "<a class="el" href="classoperations__research_1_1Solver.html#ae3b660d3dece402d0ca5448d127c0f6f">operations_research::Solver::GetOrCreateLocalSearchState</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000146 (user): Investigate if this should be moved to Search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aeb2e6947882d148bfaece200f5c6b131 "<a class="el" href="classoperations__research_1_1Solver.html#aeb2e6947882d148bfaece200f5c6b131" title="Returns whether we are instrumenting demons.">operations_research::Solver::InstrumentsDemons</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000119 (user): remove this complex logic.
We need the double test because parameters are set too late when using
python in the open source. This is the cheapest work-around. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ae63acd77b8c2ee40387795051298f659 "<a class="el" href="classoperations__research_1_1Solver.html#ae63acd77b8c2ee40387795051298f659">operations_research::Solver::IntValueStrategy</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000127 (user): add HIGHEST_MIN and LOWEST_MAX.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a64fd8adbc00c3bed16bf4b824dfd3e2b "<a class="el" href="classoperations__research_1_1Solver.html#a64fd8adbc00c3bed16bf4b824dfd3e2b">operations_research::Solver::LocalSearchProfile</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000144 (user): Merge demon and local search profiles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a579ddb4232150f04e17c0852fc8e1c60 "<a class="el" href="classoperations__research_1_1Solver.html#a579ddb4232150f04e17c0852fc8e1c60" title="Force the &quot;nexts&quot; variable to create a complete Hamiltonian path.">operations_research::Solver::MakeCircuit</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000198 (user): Merge NoCycle and Circuit.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa1b2edf76ef068b3d1cc8b56f7e7af23 "<a class="el" href="classoperations__research_1_1Solver.html#aa1b2edf76ef068b3d1cc8b56f7e7af23">operations_research::Solver::MakeDelayedPathCumul</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, const std::vector&lt; IntVar * &gt; &amp;cumuls, const std::vector&lt; IntVar * &gt; &amp;transits)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000135 (user): Merge with other path-cumuls constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0132207ac0371c18971693c8a6d9b29c "<a class="el" href="classoperations__research_1_1Solver.html#a0132207ac0371c18971693c8a6d9b29c" title="Aggregated version of count: |{i | v[i] == values[j]}| == cards[j].">operations_research::Solver::MakeDistribute</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; int64_t &gt; &amp;values, const std::vector&lt; IntVar * &gt; &amp;cards)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000159 (user) : we can sort values (and cards) before doing the test.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0ceffed2d421a344403f5a8366baa136 "<a class="el" href="classoperations__research_1_1Solver.html#a0ceffed2d421a344403f5a8366baa136" title="expr / value (integer division)">operations_research::Solver::MakeDiv</a>" (IntExpr *expr, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000179 (user) : implement special case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0ab2b02352f4ab51aeb392314d7b60a5 "<a class="el" href="classoperations__research_1_1Solver.html#a0ab2b02352f4ab51aeb392314d7b60a5" title="boolvar == (var == value)">operations_research::Solver::MakeIsEqualCstCt</a>" (IntExpr *var, int64_t value, IntVar *boolvar)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000174 (user) : what happens if the constraint is not posted?
The cache becomes tainted. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a10c9da29e0f571f2fac430761d133016 "<a class="el" href="classoperations__research_1_1Solver.html#a10c9da29e0f571f2fac430761d133016">operations_research::Solver::MakeLexicalLess</a>" (const std::vector&lt; IntVar * &gt; &amp;left, const std::vector&lt; IntVar * &gt; &amp;right)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000133 (user): Add void MakeSortedArray(
                            const std::vector&lt;IntVar*&gt;&amp; vars,
                            std::vector&lt;IntVar*&gt;* const sorted); 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a79d9441a76ca41dce4b28ff9be616363 "<a class="el" href="classoperations__research_1_1Solver.html#a79d9441a76ca41dce4b28ff9be616363">operations_research::Solver::MakeLocalSearchPhase</a>" (Assignment *assignment, LocalSearchPhaseParameters *parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000143 (user): Make a variant which runs a local search after each
               solution found in a DFS. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa8c0e8504dd5125dd200e9e3d9ef1e75 "<a class="el" href="classoperations__research_1_1Solver.html#aa8c0e8504dd5125dd200e9e3d9ef1e75">operations_research::Solver::MakeNoCycle</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, IndexFilter1 sink_handler=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000134 (user): Implement MakeAllNullIntersect taking an array of
variable vectors. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#af6c9a69ab6f3bf11e703e91812d34223 "<a class="el" href="classoperations__research_1_1Solver.html#af6c9a69ab6f3bf11e703e91812d34223">operations_research::Solver::MakeNotBetweenCt</a>" (IntExpr *expr, int64_t l, int64_t u)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000175 (user): Add back simplification code if expr is constant *
other_expr. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ac78afa51e3d5d28e84916a6fc47375de "<a class="el" href="classoperations__research_1_1Solver.html#abe4d40de1cffbeed5d0bbd8a875a83b1" title="Local Search Operators.">operations_research::Solver::MakeOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IndexEvaluator3 evaluator, EvaluatorLocalSearchOperators op)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000142 (user): Make the callback an IndexEvaluator2 when there are no
secondary variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#abe4d40de1cffbeed5d0bbd8a875a83b1 "<a class="el" href="classoperations__research_1_1Solver.html#abe4d40de1cffbeed5d0bbd8a875a83b1" title="Local Search Operators.">operations_research::Solver::MakeOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, LocalSearchOperators op, std::function&lt; const std::vector&lt; int &gt; &amp;(int, int)&gt; get_neighbors=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000218 (user): Remove (parts of) the following methods as they are mostly
redundant with the MakeLocalSearchOperatorWithNeighbors and
MakeLocalSearchOperator functions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0456a638eb3c86b7e3c6bbcc6f1a961c "<a class="el" href="classoperations__research_1_1Solver.html#a0456a638eb3c86b7e3c6bbcc6f1a961c">operations_research::Solver::MakePathConnected</a>" (std::vector&lt; IntVar * &gt; nexts, std::vector&lt; int64_t &gt; sources, std::vector&lt; int64_t &gt; sinks, std::vector&lt; IntVar * &gt; status)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000136 (user): Only does checking on WhenBound events on next variables.
Check whether more propagation is needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a793b6001916186ac1d7041a10fdd41d6 "<a class="el" href="classoperations__research_1_1Solver.html#a793b6001916186ac1d7041a10fdd41d6">operations_research::Solver::MakePathPrecedenceConstraint</a>" (std::vector&lt; IntVar * &gt; nexts, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;precedences)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000137 (user): This constraint does not make holes in variable domains;
the implementation can easily be modified to do that; evaluate the impact
on models solved with local search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a66461677e91be7682f36b8660889fd2f "<a class="el" href="classoperations__research_1_1Solver.html#a66461677e91be7682f36b8660889fd2f">operations_research::Solver::MakePhase</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IntVarStrategy var_str, IntValueStrategy val_str)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000141 (user): name each of them differently, and document them (and do that
for all other functions that have several homonyms in this .h). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a039ebfef32db8ee5641b25328954cce9 "<a class="el" href="classoperations__research_1_1Solver.html#a66461677e91be7682f36b8660889fd2f">operations_research::Solver::MakePhase</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IndexEvaluator2 eval, IndexEvaluator1 tie_breaker, EvaluatorStrategy str)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000378 (user): support tie breaker
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a84584b7705a787a70e09341e4a0e30f5 "<a class="el" href="classoperations__research_1_1Solver.html#a84584b7705a787a70e09341e4a0e30f5">operations_research::Solver::MakePiecewiseLinearExpr</a>" (IntExpr *expr, const PiecewiseLinearFunction &amp;f)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000131 (user): Investigate if we can merge all three piecewise linear
expressions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ac9865c3135d8b9b3f7de73c92dac53a4 "<a class="el" href="classoperations__research_1_1Solver.html#ac9865c3135d8b9b3f7de73c92dac53a4">operations_research::Solver::MakeSearchLog</a>" (int branch_period)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000139 (user): DEPRECATE API of MakeSearchLog(.., IntVar* var,..).
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#afbef3a751ed2de0600ef603df8dbc16f "<a class="el" href="classoperations__research_1_1Solver.html#afbef3a751ed2de0600ef603df8dbc16f">operations_research::Solver::MakeSemiContinuousExpr</a>" (IntExpr *expr, int64_t fixed_charge, int64_t step)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000180 (user) : benchmark with virtualization of
PosIntDivDown and PosIntDivUp - or function pointers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#acdd432e2ef445bb100f999ebb36e8d9c "<a class="el" href="classoperations__research_1_1Solver.html#acdd432e2ef445bb100f999ebb36e8d9c">operations_research::Solver::MakeSimulatedAnnealing</a>" (bool maximize, IntVar *v, int64_t step, int64_t initial_temperature)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000138 (user): document behavior 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0d6603ccdf190d08e5eb55a383cb7f42 "<a class="el" href="classoperations__research_1_1Solver.html#a0d6603ccdf190d08e5eb55a383cb7f42">operations_research::Solver::MakeSortingConstraint</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;sorted)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000132 (user): Do we need a version with an array of escape values.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a4c57adb4aa21bbbb303282a2fb12a546 "<a class="el" href="classoperations__research_1_1Solver.html#a4c57adb4aa21bbbb303282a2fb12a546" title="Opens a new top level search.">operations_research::Solver::NewSearch</a>" (DecisionBuilder *db, const std::vector&lt; SearchMonitor * &gt; &amp;monitors)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000121 (user) : reset statistics
 &lt;p&gt; \anchor _todo000122 (user): delete top level search after EndSearch(). 
 &lt;p&gt; \anchor _todo000123 (user): Check if these two lines are still necessary.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#afa66a85cec14980401bb16d4f4a84aa1 "<a class="el" href="classoperations__research_1_1Solver.html#afa66a85cec14980401bb16d4f4a84aa1">operations_research::Solver::SetUseFastLocalSearch</a>" (bool use_fast_local_search)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000145 (user): Get rid of the following methods once fast local search is
enabled for metaheuristics.
Disables/enables fast local search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a904f4c25cf6302fc577889db54b240cc "<a class="el" href="classoperations__research_1_1Solver.html#a904f4c25cf6302fc577889db54b240cc">operations_research::Solver::Try</a>" (DecisionBuilder *db1, DecisionBuilder *db2)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000140 (user): The search tree can be balanced by using binary
"Try"-builders "recursively". For instance, Try(a,b,c,d) will give a tree
unbalanced to the right, whereas Try(Try(a,b), Try(b,c)) will give a
balanced tree. Investigate if we should only provide the binary version
and/or if we should balance automatically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SolverLogger Member \_internalref classoperations__research_1_1SolverLogger#a596c5e6e999145f99d9afdb60ef52c84 "<a class="el" href="classoperations__research_1_1SolverLogger.html#a596c5e6e999145f99d9afdb60ef52c84">operations_research::SolverLogger::FlushPendingThrottledLogs</a>" (bool ignore_rates=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002413 (user): If this is called too often, we could optimize it and do
nothing if there are no skipped logs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Class \_internalref classoperations__research_1_1SortedDisjointIntervalList "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html">operations_research::SortedDisjointIntervalList</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002433 (user): Templatize the class on the type of the bounds.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#a53aa27777a48b981046ad09b97bded60 "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a53aa27777a48b981046ad09b97bded60">operations_research::SortedDisjointIntervalList::InsertInterval</a>" (int64_t start, int64_t end)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002430 (user): tune the algorithm below if it proves to be a bottleneck.
For example, one could try to avoid an insertion if it's not needed
(when the interval merges with a single existing interval or is fully
contained by one). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#ad937d5864aa7a209f5c565a49daad904 "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a012ebc58df4ae590e12e89509b69ee90">operations_research::SortedDisjointIntervalList::InsertIntervals</a>" (const std::vector&lt; int &gt; &amp;starts, const std::vector&lt; int &gt; &amp;ends)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002431 (user): treat kint32min and kint32max as their kint64 variants.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#a592c99d8ddbc2a357683903882c437ba "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a1d800ef9b7bcda7b2bd88941e63e9c0d">operations_research::SortedDisjointIntervalList::SortedDisjointIntervalList</a>" (const std::vector&lt; int64_t &gt; &amp;starts, const std::vector&lt; int64_t &gt; &amp;ends)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002434 (user): Explain why we favored this API to the more natural
input std::vector&lt;ClosedInterval&gt; or std::vector&lt;std::pair&lt;int, int&gt;&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#a9fc0ca5752b5ad6cc2a78ff7c512b22a "<a class="el" href="classoperations__research_1_1SparsePermutation.html#a9fc0ca5752b5ad6cc2a78ff7c512b22a">operations_research::SparsePermutation::LastElementInCycle</a>" (int i) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000059 (user): Provide a full iterator for this? Note that we have more
information with the loop above. Not sure it is needed though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#a1190fc1695811df74812b7fb1051f3bc "<a class="el" href="classoperations__research_1_1SparsePermutation.html#a1190fc1695811df74812b7fb1051f3bc">operations_research::SparsePermutation::RemoveCycles</a>" (absl::Span&lt; const int &gt; cycle_indices)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000057 (user): make this a class member to avoid allocation if the complexity
becomes an issue. In this case, also optimize the loop below by not copying
the first cycles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#aff385d18c768ffa364c5dccb5fb35c0a "<a class="el" href="classoperations__research_1_1SparsePermutation.html#aff385d18c768ffa364c5dccb5fb35c0a">operations_research::SparsePermutation::Size</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000058 (user): complete the reader API.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a93f8f72c3931f60faed67abfe9b85f3e "<a class="el" href="namespaceoperations__research.html#a93f8f72c3931f60faed67abfe9b85f3e">operations_research::splitMyString</a>" (const std::string &amp;str, Container &amp;cont, char delim=' ')&lt;/dt&gt;&lt;dd&gt; \anchor _todo000832 useless ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SteepestSearch Member \_internalref classoperations__research_1_1SteepestSearch#a7b76a69a07f9abf4e7cd0ff88925208d "<a class="el" href="classoperations__research_1_1SteepestSearch.html#a7b76a69a07f9abf4e7cd0ff88925208d">operations_research::SteepestSearch::NextSolution</a>" (int num_iterations)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000050 (user): Add time-outs and exit with a partial solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a4f740c94953f253d0a3b27ae3996e001 "<a class="el" href="namespaceoperations__research.html#a4f740c94953f253d0a3b27ae3996e001">operations_research::SubsetCostVector</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000054 (user): consider replacing with StrongVectors, which behave differently.
The return type for size() is a simple size_t and not an Index as in
StrictITIVector, which makes the code less elegant. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SwapActiveToShortestPathOperator Class \_internalref classoperations__research_1_1SwapActiveToShortestPathOperator "<a class="el" href="classoperations__research_1_1SwapActiveToShortestPathOperator.html" title="| / \ ^">operations_research::SwapActiveToShortestPathOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000337 (user): Support vehicle-class-dependent arc_evaluators. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SymmetryManager Member \_internalref classoperations__research_1_1SymmetryManager#a6f8f0310d17cfdf227de35d5eaeb6ec2 "<a class="el" href="classoperations__research_1_1SymmetryManager.html#a6f8f0310d17cfdf227de35d5eaeb6ec2">operations_research::SymmetryManager::CheckSymmetries</a>" (int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000387 (user) : Improve speed, cache previous min and build them
incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeDistribution Class \_internalref classoperations__research_1_1TimeDistribution "<a class="el" href="classoperations__research_1_1TimeDistribution.html">operations_research::TimeDistribution</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002435 (user): Since we inherit from DistributionStat, we currently store the
sum of CPU cycles as a double internally. A better option is to use int64_t
because with the 53 bits of precision of a double, we will run into an issue
if the sum of times reaches 52 days for a 2GHz processor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeLimit Class \_internalref classoperations__research_1_1TimeLimit "<a class="el" href="classoperations__research_1_1TimeLimit.html">operations_research::TimeLimit</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002437 (user): The expression "deterministic time" should be replaced with
                "number of operations" to avoid confusion with "real" time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TrivialSolutionGenerator Member \_internalref classoperations__research_1_1TrivialSolutionGenerator#a72b5cae65519e7893e32e217ef056384 "<a class="el" href="classoperations__research_1_1TrivialSolutionGenerator.html#a72b5cae65519e7893e32e217ef056384" title="TrivialSolutionGenerator.">operations_research::TrivialSolutionGenerator::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000047 (user): Add time-outs and exit with a partial solution. This seems
unlikely, though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TspLibTourParser Member \_internalref classoperations__research_1_1TspLibTourParser#a35c4ff768d130b7f9303bc1a2f96a0d7 "<a class="el" href="classoperations__research_1_1TspLibTourParser.html#a35c4ff768d130b7f9303bc1a2f96a0d7" title="Loads and parses a given tour file.">operations_research::TspLibTourParser::LoadFile</a>" (const std::string &amp;file_name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001046 (user): Return false when issues were encountered while parsing the
file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a16607e74836faff69fe760ced72898ce "<a class="el" href="classoperations__research_1_1XpressInterface.html#a16607e74836faff69fe760ced72898ce" title="Adds a linear constraint.">operations_research::XpressInterface::AddRowConstraint</a>" (MPConstraint *ct) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000828 
Make new constraints basic (rowstat[jrow]=1)
Try not to delete basic variables, or non-basic constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#aa8856606b3e293087775ce7725e1dd99 "<a class="el" href="classoperations__research_1_1XpressInterface.html#aa8856606b3e293087775ce7725e1dd99" title="Add a variable.">operations_research::XpressInterface::AddVariable</a>" (MPVariable *var) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000829 
Make new variables non-basic at their lower bound (colstat[icol]=0), unless
a variable has an infinite lower bound and a finite upper bound, in which
case make the variable non-basic at its upper bound (colstat[icol]=2) Try
not to delete basic variables, or non-basic constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a19631de62b2acb1c83d926ebea3c8e09 "<a class="el" href="classoperations__research_1_1XpressInterface.html#a19631de62b2acb1c83d926ebea3c8e09">operations_research::XpressInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000834 (user): Not yet working.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a99b8c52ba056e774c77c291506de3da1 "<a class="el" href="classoperations__research_1_1XpressInterface.html#a99b8c52ba056e774c77c291506de3da1" title="Extract all variables that have not yet been extracted.">operations_research::XpressInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000830 : Use a bitarray to flag the constraints that actually
intersect new variables? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#ada4d7eb4cf0ff57af8f2585fe4dfbdf6 "<a class="el" href="classoperations__research_1_1XpressInterface.html#ada4d7eb4cf0ff57af8f2585fe4dfbdf6" title="Modifies integrality of an extracted variable.">operations_research::XpressInterface::SetVariableInteger</a>" (int var_index, bool integer) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000826 : Should we check the current type and don't do anything
      in case the type does not change? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a6d7d562bf9d60d8006799f9f14d89afd "<a class="el" href="classoperations__research_1_1XpressInterface.html#a6d7d562bf9d60d8006799f9f14d89afd">operations_research::XpressInterface::Solve</a>" (MPSolverParameters const &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000831 : check number of variables / constraints 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressMPCallbackContext Member \_internalref classoperations__research_1_1XpressMPCallbackContext#a7aa4754c5d84c3a8eb47a8f1384bc29f "<a class="el" href="classoperations__research_1_1XpressMPCallbackContext.html#a7aa4754c5d84c3a8eb47a8f1384bc29f">operations_research::XpressMPCallbackContext::SuggestSolution</a>" (const absl::flat_hash_map&lt; const MPVariable *, double &gt; &amp;solution) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000833 : remove this workaround when it is handled in XPRESS 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aab95dca44c4ffd09a71ba4f9293dad44 "<a class="el" href="namespaceoperations__research.html#aab95dca44c4ffd09a71ba4f9293dad44">operations_research::YenKShortestPaths</a>" (const GraphType &amp;graph, const std::vector&lt; PathDistance &gt; &amp;arc_lengths, NodeIndex source, NodeIndex destination, unsigned k)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000647 (user): relax to "no negative-weight cycles" (no Dijkstra).
- The graphs might have loops.&lt;p&gt; \anchor _todo000649 (user): Yen's algorithm can work with negative weights, but
Dijkstra cannot.&lt;p&gt; \anchor _todo000650 (user): think about adding parallelism for this loop to improve
running times. 
 &lt;p&gt; \anchor _todo000651 (user): would it be faster to fingerprint the paths and
filter by fingerprints? Due to the probability of error with
fingerprints, still use this slow-but-exact code, but after
filtering. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref scip__callback_8cc#a55103a9413973772f122a9c3dfef5030 "SCIP_DECL_CONSENFOPS" (EnforcePseudoSolutionC)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000806 (user): are we sure the pseudo solution is LP feasible? It seems like
it doesn't need to be.  The code in RunSeparation might assume this? 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref scip__callback_8cc#a2e5ec3c32f1a6cde27f8a3538ea801bd "SCIP_DECL_CONSLOCK" (VariableRoundingLockC)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000807 (user): this could be a little better, but we would need to add
another method to override on ScipConstraintHandler&lt;ConstraintData&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref routing_8cc#a9f7fbf98fe796946fe0be2ca5c8b4e50 "start_equivalence_class" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000284 (user): Find equivalent start/end nodes wrt dimensions and
callbacks. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope StronglyConnectedComponentsFinder Class \_internalref classStronglyConnectedComponentsFinder "StronglyConnectedComponentsFinder&lt; NodeIndex, Graph, SccOutput &gt;" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000717 (user): Possible optimizations:
- Try to reserve the vectors which sizes are bounded by num_nodes.
- Use an index rather than doing push_back(), pop_back() on them. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref timer_8h#a430398fcce7a0820817d8dae9c226d00 "UserTimer" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000062 (user): implement it properly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a92ffd852b2ab2e5241f9832e71a2de71 "<a class="el" href="classutil_1_1BaseGraph.html#a92ffd852b2ab2e5241f9832e71a2de71" title="Capacity reserved for future arcs, always &gt;= num_arcs_.">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::arc_capacity</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000623 (user): Same questions as the ones in node_capacity().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#aa3bd051d1e141b09dda17aa9b5f24f69 "<a class="el" href="classutil_1_1BaseGraph.html#aa3bd051d1e141b09dda17aa9b5f24f69">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::FreezeCapacities</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000624 (user): Only define this in debug mode at the cost of having a lot
of ifndef NDEBUG all over the place? remove the function completely ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a07214b96597069d781e27b1dd17ef83e "<a class="el" href="classutil_1_1BaseGraph.html#a07214b96597069d781e27b1dd17ef83e">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::GroupForwardArcsByFunctor</a>" (const A &amp;a, B *b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000626 (user): remove the public functions below. They are just here during
the transition from the old ebert_graph api to this new graph api. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a463d57480c9563a7a707c5d0928c9946 "<a class="el" href="classutil_1_1BaseGraph.html#a463d57480c9563a7a707c5d0928c9946" title="Capacity reserved for future nodes, always &gt;= num_nodes_.">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::node_capacity</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000622 (user): Is it needed? remove completely? return the real capacities
at the cost of having a different implementation for each graphs? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a628255019800e5a053d08b1f0c5a05f2 "<a class="el" href="namespaceutil.html#a628255019800e5a053d08b1f0c5a05f2">util::EqualRange</a>" (MultiMap &amp;multi_map, const typename MultiMap::key_type &amp;key)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000645 (user): go further and expose only the values, not the pairs (key,
values) since the caller already knows the key. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::graph Member \_internalref namespaceutil_1_1graph#a440afdf238e5a752bbe4e1bcc8878fe7 "<a class="el" href="namespaceutil_1_1graph.html#a440afdf238e5a752bbe4e1bcc8878fe7">util::graph::FindCycleInGraph</a>" (const AdjacencyLists &amp;adj)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000718 (user): Caching adj[cur_state-&gt;node] in a local stack to improve
locality and so that the [] operator is called exactly once per node. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a9470623ca7db3c4a62ce3b326c6b07d8 "<a class="el" href="namespaceutil.html#a9470623ca7db3c4a62ce3b326c6b07d8">util::PermuteWithExplicitElementType</a>" (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000621 (user): consider slower but more memory efficient implementations that
follow the cycles of the permutation and use a bitmap to indicate what has
been permuted or to mark the beginning of each cycle. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a06fa201576c927d92657e090fa86bfdb "<a class="el" href="namespaceutil.html#a06fa201576c927d92657e090fa86bfdb">util::RemoveCyclesFromPath</a>" (const Graph &amp;graph, std::vector&lt; int &gt; *arc_path)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000719 (user): In some cases, there is more than one possible solution. We could
take some arc costs and return the cheapest path instead. Or return the
shortest path in term of number of arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcMixedGraph Member \_internalref classutil_1_1ReverseArcMixedGraph#a5ebe11f2abcd78ad1f5606e27d1688bb "<a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a5ebe11f2abcd78ad1f5606e27d1688bb">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>" (ArcIndexType arc) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000628 (user): support Head() and Tail() before Build(), like StaticGraph&lt;&gt;.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcMixedGraph::OutgoingArcIterator Member \_internalref classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator#ac265893b8e1a6db1380522442bf66c84 "<a class="el" href="classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator.html#ac265893b8e1a6db1380522442bf66c84">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>" (OutgoingArcIterator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000632 (user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this
iterator rather than a simple IntegerRange on the arc indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph Member \_internalref classutil_1_1ReverseArcStaticGraph#a590ee70b96ce87433ba89b067495aa5f "<a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a485803d141f9c80beaaae7094548d672">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Build</a>" (std::vector&lt; ArcIndexType &gt; *permutation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000625 (user): the 0 is wasted here, but minor optimisation.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph Member \_internalref classutil_1_1ReverseArcStaticGraph#a72e8ed03fe3f8ff27d156622a86900aa "<a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a72e8ed03fe3f8ff27d156622a86900aa">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>" (ArcIndexType arc) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000627 (user): support Head() and Tail() before Build(), like StaticGraph&lt;&gt;.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph::OutgoingArcIterator Member \_internalref classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator#a4f7501971b3fcc6ab34772a93c449ac6 "<a class="el" href="classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator.html#a4f7501971b3fcc6ab34772a93c449ac6">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>" (OutgoingArcIterator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000631 (user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this
iterator rather than a simple IntegerRange on the arc indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::SVector Member \_internalref classutil_1_1SVector#a287f9791ba2e68e137d53fc038bbe432 "<a class="el" href="classutil_1_1SVector.html#a287f9791ba2e68e137d53fc038bbe432">util::SVector&lt; T &gt;::reserve</a>" (int n)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000629 (user): in C++17 we could use std::uninitialized_move instead
of this loop. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref parser_8tab_8cc#ad3cdc959806aba1ada0fd7e5d4184f88 "yyparse" (<a class="el" href="structoperations__research_1_1fz_1_1ParserContext.html" title="This is the context used during parsing.">operations_research::fz::ParserContext</a> *context, <a class="el" href="classoperations__research_1_1fz_1_1Model.html">operations_research::fz::Model</a> *model, bool *ok, void *scanner)</p>
</dd>
<dd><p class="startdd"><a class="anchor" id="_todo000411"></a>(user): Check that the assignment is included in the domain. </p>
<p class="interdd"><a class="anchor" id="_todo000412"></a>(user): CHECK all values within domain. </p>
<p class="interdd"><a class="anchor" id="_todo000413"></a>(user): CHECK all values within domain. </p>
<p class="enddd"><a class="anchor" id="_todo000414"></a>(user): check that all assignments are included in the domain. </p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
