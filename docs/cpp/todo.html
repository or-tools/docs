<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('todo.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Todo List</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="lp__solver_8cc.html#aa3003ab2d06a8ff3b490c100232fc05c">ABSL_FLAG</a>  (bool, lp_dump_to_proto_file, false, "Tells whether do dump the problem to a protobuf file.")</dt>
<dd><a class="anchor" id="_todo000485"></a>(user): abstract this in some way to the port directory.  </dd>
<dt>Member <a class="el" href="min__cost__flow_8cc.html#ab29882272822b270edac48bc8b0ab14e">ABSL_FLAG</a>  (int64_t, min_cost_flow_alpha, 5, "Divide factor for epsilon at each refine step.")</dt>
<dd><a class="anchor" id="_todo000722"></a>(user): Remove these flags and expose the parameters in the API. New clients, please do not use these flags!  </dd>
<dt>Member <a class="el" href="solve__flow__model_8cc.html#a9ff01420564e565fbaef07a88a7e3d26">ABSL_FLAG</a>  (std::string, input, "", "Input file of the problem.")</dt>
<dd><a class="anchor" id="_todo000765"></a>(user): move this DIMACS parser to its own class, like the ones in routing/. This change would improve searchability of the parser.  </dd>
<dt>Member <a class="el" href="max__hs_8cc.html#a1bcd4379e7db62efdf5ffc541a76255f">ABSL_FLAG</a>  (int, max_hs_strategy, 0, "MaxHsStrategy: 0 extract only objective variable, 1 extract all variables " "colocated with objective variables, 2 extract all variables in the " "linearization")</dt>
<dd><a class="anchor" id="_todo002081"></a>(user): Remove this flag when experiments are stable.  </dd>
<dt>Class <a class="el" href="classCycleTimer.html">CycleTimer</a>  </dt>
<dd><a class="anchor" id="_todo000083"></a>(user): implement it.  </dd>
<dt>Member <a class="el" href="revised__simplex_8cc.html#a8806083a7bf6a4ee4a4976c226b93788">DCHECK_ROW_BOUNDS</a>  (row)</dt>
<dd><a class="anchor" id="_todo000585"></a>(user): Remove this function.  </dd>
<dt>Namespace <a class="el" href="namespacegtl.html">gtl</a>  </dt>
<dd><a class="anchor" id="_todo000081"></a>(user): Broaden the scope and rename to "stream_util.h" </dd>
<dt>Member <a class="el" href="solve__flow__model_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>  (int argc, char **argv)</dt>
<dd><a class="anchor" id="_todo000766"></a>(user): improve code to convert many files.  </dd>
<dt>Class <a class="el" href="classMPSReaderTemplate.html">MPSReaderTemplate&lt; DataWrapper &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000902"></a>(b/284163180): The current behavior is that in free format header lines do not start with white space, and data lines must start with at least one white space.</p>
<p class="enddd"><a class="anchor" id="_todo000903"></a>(b/284163180): Fix handling of sections and data in <code>free_form</code>. / Returns true if the line defines a new section. bool IsNewSection() const { return line_[0] != '\0' &amp;&amp; line_[0] != ' '; } </p>
</dd>
<dt>Member <a class="el" href="classMPSReaderTemplate.html#a41dca56e2f203706f6b8eaeb13cadfea">MPSReaderTemplate&lt; DataWrapper &gt;::MPSReaderTemplate</a>  ()</dt>
<dd><a class="anchor" id="_todo000908"></a>(user): Support 'SI' (semi integer).  </dd>
<dt>Namespace <a class="el" href="namespaceoperations__research.html">operations_research</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000006"></a>(user): refine this toplevel comment when this file settles.</p>
<p class="interdd"><a class="anchor" id="_todo000028"></a>(user): base this code on <a class="el" href="classoperations__research_1_1LinearSumAssignment.html" title="This class does not take ownership of its underlying graph.">LinearSumAssignment</a>.</p>
<p class="enddd"><a class="anchor" id="_todo000033"></a>: it could be even faster than that when the values are in [0..N) for a known value N that's significantly lower than the max integer value.  </p>
</dd>
<dt>Namespace <a class="el" href="namespaceoperations__research_1_1_0d351355163110162071212124045010373231170176234334.html">operations_research</a>  </dt>
<dd><a class="anchor" id="_todo000220"></a>(user): improve code when assume_paths is false (currently does an expensive n^2 loop).  </dd>
<dt>Namespace <a class="el" href="namespaceoperations__research.html">operations_research</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000397"></a>(user): Move all existing routing search code here. </p>
<p class="interdd"><a class="anchor" id="_todo000416"></a>(user): Clean up to match other first solution strategies. </p>
<p class="interdd"><a class="anchor" id="_todo000434"></a>(user) : treat optional intervals </p>
<p class="interdd"></p>
<p class="interdd">(user) : Call <a class="el" href="classoperations__research_1_1DecisionVisitor.html">DecisionVisitor</a> and pass name of variable </p>
<p class="interdd"><a class="anchor" id="_todo000517"></a>(user): Determine whether any of these would bring any benefit:</p><ul>
<li>S.C. Eisenstat and J.W.H. Liu, "The theory of elimination trees for
  sparse unsymmetric matrices," SIAM J. Matrix Anal. Appl., 26:686-705, January 2005</li>
<li>S.C. Eisenstat and J.W.H. Liu. "Algorithmic aspects of elimination trees
  for sparse unsymmetric matrices," SIAM J. Matrix Anal. Appl., 29:1363-1381, January 2008.</li>
<li><a href="http://perso.ens-lyon.fr/~bucar/papers/kauc.pdf">http://perso.ens-lyon.fr/~bucar/papers/kauc.pdf</a> </li>
</ul>
<p class="interdd"><a class="anchor" id="_todo000674"></a>(user): implement the above active node choice rule.</p>
<p class="enddd"><a class="anchor" id="_todo000675"></a>(user): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow
Problem.” In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008.
http://www.springerlink.com/index/5535k2j1mt646338.pdf&lt;p&gt; \anchor _todo000699 (user): implement pruning procedures on top of the Held-Karp algorithm.&lt;p&gt; \anchor _todo000712 (user): implement Lawler's modification:
https://pubsonline.informs.org/doi/abs/10.1287/mnsc.18.7.401&lt;p&gt; \anchor _todo000730 (user): See whether the following can bring any improvements on real-life
problems.
R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost flows by double scaling," Mathematical Programming, (1992) 53:243-266.
http://www.springerlink.com/index/gu7404218u6kt166.pdf&lt;p&gt; \anchor _todo000753 (user): This is a work in progress. The algo is not fully implemented
yet. The initial version is closer to Blossom IV since we update the dual
values for all trees at once with the same delta. 
 &lt;p&gt; \anchor _todo000780 (user): either implement with SCIP constraint handlers or use a solver
independent implementation. 
 &lt;p&gt; \anchor _todo000814 (user): handle timeouts, compute row and column statuses. 
 &lt;p&gt; \anchor _todo000820 (user): post c++ 14, instead use
  std::pair&lt;MPSolver::OptimizationProblemType, const absl::string_view&gt;
once pair gets a constexpr constructor. 
 &lt;p&gt; \anchor _todo000949 (b/180617976): change this behavior.&lt;p&gt; \anchor _todo000979 (b/180024054): add tests for:
 * threads
 * heuristics
 * scaling
 * lp_algorithm, differentiate between primal and dual simplex. E.g. find a
   problem with LP relaxation that is both infeasible and dual infeasible,
   disable presolve, and solve. When using primal simplex, we should get
   termination reason kInfeasible, but dual simplex should give
   kInfeasibleOrUnbounded.
 *  &lt;p&gt; &lt;p&gt;(b/272268188): test the interaction between cutoff and primal + dual
   infeasibility.
 &lt;p&gt; \anchor _todo000984 (b/180024054): the following parameters are not tested:
 * time_limit
 * threads
 * scaling&lt;p&gt; \anchor _todo000988 (user): These tests are incomplete in a few ways; see mip_tests.cc
 &lt;p&gt; &lt;p&gt;(user): Expand tests so they check primal, dual and/or primal-dual
infeasible cases as appropriate. 
 &lt;p&gt; \anchor _todo002347 (user): for now it is mainly presolve, but the idea is to call these
function during the search so they should be as incremental as possible. That
is avoid doing work that is not useful because nothing changed or exploring
parts that were not done during the last round. 
 &lt;p&gt; \anchor _todo002391 (user): Expand. 
 &lt;p&gt; \anchor _todo002562 (user): make this implementation the default everywhere.
 &lt;p&gt; &lt;p&gt;(user): investigate the code generated by MSVC. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AdaptiveParameterValue Class \_internalref classoperations__research_1_1AdaptiveParameterValue "<a class="el" href="classoperations__research_1_1AdaptiveParameterValue.html">operations_research::AdaptiveParameterValue</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002540 (user): The current logic work well in practice, but has no strong
theoretical foundation. We should be able to come up with a better understood
formula that converge way faster. It will also be nice to generalize the 0.5
above to a target probability p. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a93bd93f028c18a4b55b30056ef60df44 "<a class="el" href="namespaceoperations__research.html#a93bd93f028c18a4b55b30056ef60df44">operations_research::AddOverflows</a>" (int64_t x, int64_t y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002563 (user): consider making some operations overflow-sticky, some others
not, but make an explicit choice throughout. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AffineRelation Class \_internalref classoperations__research_1_1AffineRelation "<a class="el" href="classoperations__research_1_1AffineRelation.html">operations_research::AffineRelation</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002541 (user): it might be possible to do something fancier and drop less
relations if all the affine relations are given before hand. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::AffineRelation Member \_internalref classoperations__research_1_1AffineRelation#a42c79bfbcf36db0e14d942a6079a8564 "<a class="el" href="classoperations__research_1_1AffineRelation.html#a5c2556af84128ec02d7f72be8c51a43d">operations_research::AffineRelation::TryAdd</a>" (int x, int y, int64_t coeff, int64_t offset, bool allow_rep_x, bool allow_rep_y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002542 (user): It should be possible to optimize this code block a bit, for
instance depending on the magnitude of new_coeff vs coeff_x, we may already
know that one of the two merge is not possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a38cd9519fdea9ef6c87480955852a8c7 "<a class="el" href="namespaceoperations__research.html#a38cd9519fdea9ef6c87480955852a8c7">operations_research::ApplyMipPresolveSteps</a>" (const glop::GlopParameters &amp;glop_params, MPModelProto *model, std::vector&lt; std::unique_ptr&lt; glop::Preprocessor &gt; &gt; *for_postsolve, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000847 (user): General constraints are currently not supported.
 &lt;p&gt; \anchor _todo000848 (user): Remove this back and forth conversion. We could convert
the LinearProgram directly to a CpModelProto, or we could have a custom
implementation of these presolve steps. 
 &lt;p&gt; \anchor _todo000849 (user): transform the hint instead of disabling presolve. 
 &lt;p&gt; \anchor _todo000850 (user): Usually it is good to run the ImpliedFreePreprocessor before
this one. However this seems to cause problem on atm20-100.mps. Moreover,
for the conversion, it is better to have tight bounds even if the bound
propagator is supposed to undo what this presolve would have done. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ArcWithLength Struct \_internalref structoperations__research_1_1ArcWithLength "<a class="el" href="structoperations__research_1_1ArcWithLength.html">operations_research::ArcWithLength</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000669 (b/332475231): extend to non-floating lengths.
 &lt;p&gt; &lt;p&gt;(b/332476147): extend to allow for length functor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Assignment Member \_internalref classoperations__research_1_1Assignment#ad6ab5aff03cb66b05fcbdff43dde169a "<a class="el" href="classoperations__research_1_1Assignment.html#ad6ab5aff03cb66b05fcbdff43dde169a">operations_research::Assignment::CopyIntersection</a>" (const Assignment *assignment)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000138 (user): The current behavior is to copy the objective "prefix"
which fits the notion of lexicographic objectives well. Reconsider if
multiple objectives are used in another context. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Assignment Member \_internalref classoperations__research_1_1Assignment#aa4afa275944d2cc69a7a252bafc1e311 "<a class="el" href="classoperations__research_1_1Assignment.html#aa4afa275944d2cc69a7a252bafc1e311">operations_research::Assignment::IntVarContainer</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000167 (user): Add element iterators to avoid exposing container class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a270548116df8ad74e03d376c40025566 "<a class="el" href="namespaceoperations__research.html#a270548116df8ad74e03d376c40025566">operations_research::AutomaticFirstSolutionStrategy</a>" (bool has_pickup_deliveries, bool has_node_precedences, bool has_single_vehicle_node)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000399 (user): Make this smarter. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BaseInactiveNodeToPathOperator Member \_internalref classoperations__research_1_1BaseInactiveNodeToPathOperator#a09991032846835af48e3d7e767e1b336 "<a class="el" href="classoperations__research_1_1BaseInactiveNodeToPathOperator.html#a09991032846835af48e3d7e767e1b336">operations_research::BaseInactiveNodeToPathOperator&lt; ignore_path_vars &gt;::BaseInactiveNodeToPathOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;secondary_vars, int number_of_base_nodes, std::function&lt; int(int64_t)&gt; start_empty_path_class, NeighborAccessor get_incoming_neighbors=nullptr, NeighborAccessor get_outgoing_neighbors=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000250 (user): Activate skipping optimal paths.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BaseNodeIterators Member \_internalref classoperations__research_1_1BaseNodeIterators#adbc1e66d9b78eea909247a97e0a0f7cb "<a class="el" href="classoperations__research_1_1BaseNodeIterators.html#adbc1e66d9b78eea909247a97e0a0f7cb">operations_research::BaseNodeIterators&lt; PathOperator &gt;::HasReachedEnd</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000173 (user): Extend to other iterators.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BinCapacities Member \_internalref classoperations__research_1_1BinCapacities#afc048722dcaad2d350ccc7a8202372d8 "<a class="el" href="classoperations__research_1_1BinCapacities.html#afc048722dcaad2d350ccc7a8202372d8">operations_research::BinCapacities::CheckAdditionsFeasibility</a>" (absl::Span&lt; const int &gt; items, int bin) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000430 (user): try to reorder on failure, so that tight dimensions are
checked first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Bitmap Member \_internalref classoperations__research_1_1Bitmap#a10079c77d15fd313c09b89b46756d4e3 "<a class="el" href="classoperations__research_1_1Bitmap.html#a10079c77d15fd313c09b89b46756d4e3">operations_research::Bitmap::Resize</a>" (uint32_t size, bool fill=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000080 (user) : optimize next loop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab7253ffd8b7aba4b7cb5f981c7627526 "<a class="el" href="namespaceoperations__research.html#ab7253ffd8b7aba4b7cb5f981c7627526" title="Bit operators used to manipulates bitsets.">operations_research::BitPos64</a>" (uint64_t pos)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002544 (user): rename BitPos and BitOffset to something more understandable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Bitset64 Member \_internalref classoperations__research_1_1Bitset64#adde7d1500621913ae1f3e71cda4fb502 "<a class="el" href="classoperations__research_1_1Bitset64.html#adde7d1500621913ae1f3e71cda4fb502" title="Changes the number of bits the Bitset64 can hold and set all of them to 0.">operations_research::Bitset64&lt; IndexType &gt;::ClearAndResize</a>" (IndexType size)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002545 (user): Ideally if a realloc happens, we don't need to copy the old
data... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Class \_internalref classoperations__research_1_1BlossomGraph "<a class="el" href="classoperations__research_1_1BlossomGraph.html">operations_research::BlossomGraph</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000754 (user): For now this class does not maintain a second graph of edges
between the trees nor does it maintains priority queue of edges.&lt;p&gt; \anchor _todo000755 (user): For now we use CHECKs in many places to facilitate development.
Switch them to DCHECKs for speed once the code is more stable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a1cc997de6330ea47db84ebfbc97c3855 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a1cc997de6330ea47db84ebfbc97c3855">operations_research::BlossomGraph::Augment</a>" (EdgeIndex e)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000747 (user): Check all dual/slack same after primal op?
 &lt;p&gt; \anchor _todo000748 (user): It seems that we may waste some computation since the part of
the tree not in the path between roots can lead to the same Grow()
operations later when one of its node is ratched to a new root.&lt;p&gt; \anchor _todo000749 (user): Reduce this O(num_nodes) complexity. We might be able to
even do O(num_node_in_path) with lazy updates. Note that this operation
will only be performed at most num_initial_unmatched_nodes / 2 times
though. 
 &lt;p&gt; \anchor _todo000750 (user): This could probably be optimized if needed. But we do usually
iterate a lot more over it than we update it. Note that as long as we use
the same delta for all trees, this is not even needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a2efd43d890e6d53cbab9f160b5ecd745 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a2efd43d890e6d53cbab9f160b5ecd745">operations_research::BlossomGraph::ComputeMaxCommonTreeDualDeltaAndResetPrimalEdgeQueue</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000744 (user): Avoid this linear loop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph::Edge Member \_internalref structoperations__research_1_1BlossomGraph_1_1Edge#a152f6be1dfb3d3057d875f9371da5a29 "<a class="el" href="structoperations__research_1_1BlossomGraph_1_1Edge.html#a152f6be1dfb3d3057d875f9371da5a29">operations_research::BlossomGraph::Edge::tail</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000761 (user): Consider using node_a/node_b instead to remove the "directed"
meaning. I do need to think a bit more about it though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a23c2ea31a1b81f23e929abdc839f9153 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a23c2ea31a1b81f23e929abdc839f9153" title="This must be called at the end of the algorithm to recover the matching.">operations_research::BlossomGraph::ExpandAllBlossoms</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000752 (user): remove duplication with expand?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#aea1e702f3161c4bd45d69ac7ef50d562 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#aea1e702f3161c4bd45d69ac7ef50d562">operations_research::BlossomGraph::Initialize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000739 (user): Code the more advanced "Fractional matching initialization"
heuristic.&lt;p&gt; \anchor _todo000740 (user): Add a preprocessing step that performs the 'forced' matches? 
 &lt;p&gt; \anchor _todo000741 (user): We might be able to do better for odd min_cost, but then
we might need to scale by 4? think about it. 
 &lt;p&gt; \anchor _todo000742 (user): Optimize by merging this loop with the one above? 
 &lt;p&gt; \anchor _todo000743 (user): Reduce the number of loops we do in the initialization. We
could likely just scale the edge cost as we fill them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#a4e57765af9aa45f409d540937922cb15 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#a4e57765af9aa45f409d540937922cb15">operations_research::BlossomGraph::PrimalUpdates</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000745 (user): avoid adding duplicates? 
 &lt;p&gt; \anchor _todo000746 (user): Avoid doing a O(num_nodes). Also expand all blossom
recursively? I am not sure it is a good heuristic to expand all possible
blossom before trying the other operations though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BlossomGraph Member \_internalref classoperations__research_1_1BlossomGraph#af8800c5729866189248b48ea006f2787 "<a class="el" href="classoperations__research_1_1BlossomGraph.html#af8800c5729866189248b48ea006f2787">operations_research::BlossomGraph::Shrink</a>" (EdgeIndex e)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000751 (user): It would be nicer to not to have to read the memory of
the other node at all. It might be possible once we store the
parent edge instead of the parent node since then we will only need
to know if this edges point to a new-internal node or not. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer Member \_internalref classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer#a74b09c69f37b7aee6c511622f13ff935 "<a class="el" href="classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer.html#a74b09c69f37b7aee6c511622f13ff935">operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer::DebugString</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000108 (user): show the backtrack levels.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer Member \_internalref classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer#ab9b52ed71802a8f4ae56d61b3e6f42ea "<a class="el" href="classoperations__research_1_1bop_1_1AssignmentAndConstraintFeasibilityMaintainer.html#ab9b52ed71802a8f4ae56d61b3e6f42ea">operations_research::bop::AssignmentAndConstraintFeasibilityMaintainer::PotentialOneFlipRepairs</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000107 (user): If this starts to show-up in a performance profile, we can
easily maintain this hash incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopOptimizerBase Member \_internalref classoperations__research_1_1bop_1_1BopOptimizerBase#a881ed93d8f98879bbbfddf21807fff63ab5cd6094ad1ef99cfb1c8e77da1f59b1 "<a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html#a881ed93d8f98879bbbfddf21807fff63ab5cd6094ad1ef99cfb1c8e77da1f59b1">operations_research::bop::BopOptimizerBase::INFORMATION_FOUND</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000087 (user): replace by learned_info-&gt;IsEmpty()? but we will need to clear
the BopSolution there first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopOptimizerBase Member \_internalref classoperations__research_1_1bop_1_1BopOptimizerBase#a881ed93d8f98879bbbfddf21807fff63 "<a class="el" href="classoperations__research_1_1bop_1_1BopOptimizerBase.html#a881ed93d8f98879bbbfddf21807fff63">operations_research::bop::BopOptimizerBase::Status</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000086 (user): To redesign, some are not needed anymore thanks to the
             problem state, e.g. IsOptimal(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::BopRandomFirstSolutionGenerator Class \_internalref classoperations__research_1_1bop_1_1BopRandomFirstSolutionGenerator "<a class="el" href="classoperations__research_1_1bop_1_1BopRandomFirstSolutionGenerator.html">operations_research::bop::BopRandomFirstSolutionGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000094 (user): Coupled with some Local Search it might be used to diversify
             the solutions. To try. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop Member \_internalref namespaceoperations__research_1_1bop#aa5e7fc23cf65709ac2894d88db807c57 "<a class="el" href="namespaceoperations__research_1_1bop.html#ac596370dab965471b2aaf0acf94c3940">operations_research::bop::DEFINE_STRONG_INDEX_TYPE</a>" (SparseIndex)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000123 (user): Remove.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::IntegralSolver Member \_internalref classoperations__research_1_1bop_1_1IntegralSolver#a23ff330a4dd1b9066e1f23078323ef9b "<a class="el" href="classoperations__research_1_1bop_1_1IntegralSolver.html#ae9cac08f1ac99542b75ac0a3237f55f4" title="Solves the given linear program and returns the solve status.">operations_research::bop::IntegralSolver::Solve</a>" (const glop::LinearProgram &amp;linear_problem, const glop::DenseRow &amp;user_provided_initial_solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000135 (user): Change the API to accept a partial solution instead since the
underlying solver supports it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LinearRelaxation Member \_internalref classoperations__research_1_1bop_1_1LinearRelaxation#ae7b5dc2f2554218d68e6013b9a3c10d8 "<a class="el" href="classoperations__research_1_1bop_1_1LinearRelaxation.html#ae7b5dc2f2554218d68e6013b9a3c10d8">operations_research::bop::LinearRelaxation::ShouldBeRun</a>" (const ProblemState &amp;problem_state) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000090 (user): also deal with problem_already_solved_ 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LocalSearchAssignmentIterator Member \_internalref classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator#a8b33fbbde1b28b4f19eac558f3bcc968 "<a class="el" href="classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator.html#a8b33fbbde1b28b4f19eac558f3bcc968">operations_research::bop::LocalSearchAssignmentIterator::deterministic_time</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000110 (user): The 1.2 multiplier is an approximation only based on the time
             spent in the SAT wrapper. So far experiments show a good
             correlation with real time, but we might want to be more
             accurate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::LocalSearchAssignmentIterator Member \_internalref classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator#abba388e3e639729c28998d52ecea6a19 "<a class="el" href="classoperations__research_1_1bop_1_1LocalSearchAssignmentIterator.html#abba388e3e639729c28998d52ecea6a19" title="Move to the next assignment. Returns false when the search is finished.">operations_research::bop::LocalSearchAssignmentIterator::NextAssignment</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000109 (user): Perform more experiments with this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OneFlipConstraintRepairer Member \_internalref classoperations__research_1_1bop_1_1OneFlipConstraintRepairer#a07e60997ff23293fa7f3b9d21765fb32 "<a class="el" href="classoperations__research_1_1bop_1_1OneFlipConstraintRepairer.html#a07e60997ff23293fa7f3b9d21765fb32">operations_research::bop::OneFlipConstraintRepairer::OneFlipConstraintRepairer</a>" (const sat::LinearBooleanProblem &amp;problem, const AssignmentAndConstraintFeasibilityMaintainer &amp;maintainer, const sat::VariablesAssignment &amp;sat_assignment)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000114 (user): maybe merge the two classes? maintaining this implicit indices
convention between the two classes sounds like a bad idea. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OptimizerSelector Member \_internalref classoperations__research_1_1bop_1_1OptimizerSelector#a39afee83d9f173f951fd8bef5668d1cc "<a class="el" href="classoperations__research_1_1bop_1_1OptimizerSelector.html#a39afee83d9f173f951fd8bef5668d1cc">operations_research::bop::OptimizerSelector::SelectOptimizer</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000121 (user): Remove this recursive call, even if in practice it's
    safe because the max depth is the number of optimizers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::OptimizerSelector Member \_internalref classoperations__research_1_1bop_1_1OptimizerSelector#a90899a835ba61dd5404514594bac26d1 "<a class="el" href="classoperations__research_1_1bop_1_1OptimizerSelector.html#a90899a835ba61dd5404514594bac26d1">operations_research::bop::OptimizerSelector::SetOptimizerRunnability</a>" (OptimizerIndex optimizer_index, bool runnable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000122 (user): Maybe we should simply have the notion of selectability here
and let the client handle the logic to decide what optimizer are selectable
or not. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::PortfolioOptimizer Member \_internalref classoperations__research_1_1bop_1_1PortfolioOptimizer#a80a6069365c385e427e6e5a1c08d1757 "<a class="el" href="classoperations__research_1_1bop_1_1PortfolioOptimizer.html#a80a6069365c385e427e6e5a1c08d1757">operations_research::bop::PortfolioOptimizer::Optimize</a>" (const BopParameters &amp;parameters, const ProblemState &amp;problem_state, LearnedInfo *learned_info, TimeLimit *time_limit) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000117 (user): Is 1 the right value? It might be better to use a percentage
             of the gap, or use the same gain as for the second solution. 
 &lt;p&gt; \anchor _todo000118 (user): don't penalize the SatCoreBasedOptimizer or the
LinearRelaxation when they improve the lower bound.
&lt;p&gt; \anchor _todo000119 &lt;p&gt; \anchor _todo000120 (user): Do we want to re-order the optimizers in the selector when
             the status is BopOptimizerBase::INFORMATION_FOUND? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::ProblemState Member \_internalref classoperations__research_1_1bop_1_1ProblemState#a559199c417440cd27d38fc73ce4eb3f0 "<a class="el" href="classoperations__research_1_1bop_1_1ProblemState.html#a559199c417440cd27d38fc73ce4eb3f0">operations_research::bop::ProblemState::GetLearnedInfo</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000088 (user): In the current implementation the learned information only
             contains binary clauses added since the last call to
             SynchronizationDone().
             Add an iterator on the sat::BinaryClauseManager. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::ProblemState Member \_internalref classoperations__research_1_1bop_1_1ProblemState#a66e1a0e14cfd6b3310237e4243df1295 "<a class="el" href="classoperations__research_1_1bop_1_1ProblemState.html#a66e1a0e14cfd6b3310237e4243df1295">operations_research::bop::ProblemState::MergeLearnedInfo</a>" (const LearnedInfo &amp;learned_info, BopOptimizerBase::Status optimization_status)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000085 (user): refactor this to not rely on the optimization status.
All the information can be encoded in the learned_info bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::RelationGraphBasedNeighborhood Member \_internalref classoperations__research_1_1bop_1_1RelationGraphBasedNeighborhood#a325429e8a64a26196122aa1b0e430cdb "<a class="el" href="classoperations__research_1_1bop_1_1RelationGraphBasedNeighborhood.html#a325429e8a64a26196122aa1b0e430cdb">operations_research::bop::RelationGraphBasedNeighborhood::RelationGraphBasedNeighborhood</a>" (const sat::LinearBooleanProblem &amp;problem, absl::BitGenRef random)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000099 (user): Factor this out with the similar factor in
ConstraintBasedNeighborhood? also maybe a better approach is to order the
constraint, and stop the neighborhood extension without considering all of
them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatCoreBasedOptimizer Class \_internalref classoperations__research_1_1bop_1_1SatCoreBasedOptimizer "<a class="el" href="classoperations__research_1_1bop_1_1SatCoreBasedOptimizer.html">operations_research::bop::SatCoreBasedOptimizer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000125 (user): Merge this with the code in sat/optimization.cc
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatCoreBasedOptimizer Member \_internalref classoperations__research_1_1bop_1_1SatCoreBasedOptimizer#aa4bc0effba94384800ed5500479d4e6a "<a class="el" href="classoperations__research_1_1bop_1_1SatCoreBasedOptimizer.html#aa4bc0effba94384800ed5500479d4e6a">operations_research::bop::SatCoreBasedOptimizer::Optimize</a>" (const BopParameters &amp;parameters, const ProblemState &amp;problem_state, LearnedInfo *learned_info, TimeLimit *time_limit) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000124 (user): Check that this cannot fail because of the conflict limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::bop::SatWrapper Class \_internalref classoperations__research_1_1bop_1_1SatWrapper "<a class="el" href="classoperations__research_1_1bop_1_1SatWrapper.html">operations_research::bop::SatWrapper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000113 (user): remove? the meat of the logic is used in just one place, so I am
not sure having this extra layer improve the readability. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#ada6578145939501210ef6b92ca38158d "<a class="el" href="classoperations__research_1_1BopInterface.html#ada6578145939501210ef6b92ca38158d">operations_research::BopInterface::ExtractNewConstraints</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000786 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a7aaa64ff52a59fb3e02dde9e52897ace "<a class="el" href="classoperations__research_1_1BopInterface.html#a7aaa64ff52a59fb3e02dde9e52897ace">operations_research::BopInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000785 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a9bd4d93025988cd4a244584d930b8ff8 "<a class="el" href="classoperations__research_1_1BopInterface.html#a9bd4d93025988cd4a244584d930b8ff8">operations_research::BopInterface::ExtractObjective</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000787 (user): remove duplication with GlopInterface.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#ac52f933217a15933ccc9d816712e85f7 "<a class="el" href="classoperations__research_1_1BopInterface.html#ac52f933217a15933ccc9d816712e85f7">operations_research::BopInterface::SetPresolveMode</a>" (int value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000788 (user): add this to BopParameters.
 &lt;p&gt; \anchor _todo000789 (user): add this to BopParameters.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#afd586dcfbf76c853a9331113cea5ad2f "<a class="el" href="classoperations__research_1_1BopInterface.html#afd586dcfbf76c853a9331113cea5ad2f" title="--— Solve --—">operations_research::BopInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000782 (user): Implement the column status.
 &lt;p&gt; \anchor _todo000783 (user): Implement the row status.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::BopInterface Member \_internalref classoperations__research_1_1BopInterface#a8055a5ae37344bb12601db78c75336ca "<a class="el" href="classoperations__research_1_1BopInterface.html#a8055a5ae37344bb12601db78c75336ca" title="Returns a string describing the underlying solver and its version.">operations_research::BopInterface::SolverVersion</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000784 (user): Decide how to version bop.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aacf1f78a82fb54975d703e8f079cafa2 "<a class="el" href="namespaceoperations__research.html#aacf1f78a82fb54975d703e8f079cafa2">operations_research::BuildKruskalMinimumSpanningTreeFromSortedArcs</a>" (const Graph &amp;graph, absl::Span&lt; const typename Graph::ArcIndex &gt; sorted_arcs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000734 (user): Add a global Minimum Spanning Tree API automatically switching
between Prim and Kruskal depending on problem size. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#adfcad7c607afe2de123ac91fcd2b87c0 "<a class="el" href="namespaceoperations__research.html#adfcad7c607afe2de123ac91fcd2b87c0">operations_research::CapProdGeneric</a>" (int64_t x, int64_t y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002564 (user): avoid this by writing function Log2(a) with Log2(0) == -1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#af820a38fd9b79c6bccdf806ff44df433 "<a class="el" href="classoperations__research_1_1CBCInterface.html#af820a38fd9b79c6bccdf806ff44df433">operations_research::CBCInterface::ExtractModel</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000791 (user): separate the solve from the model extraction.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#abe31f5b2faa04f2e7d0a82b2f7c56eba "<a class="el" href="classoperations__research_1_1CBCInterface.html#abe31f5b2faa04f2e7d0a82b2f7c56eba" title="Modifies integrality of an extracted variable.">operations_research::CBCInterface::SetVariableInteger</a>" (int var_index, bool integer) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000790 (user) : Check if this is actually a change.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CBCInterface Member \_internalref classoperations__research_1_1CBCInterface#aff8df81038ade1c6d8ff118dbcf92ff2 "<a class="el" href="classoperations__research_1_1CBCInterface.html#aff8df81038ade1c6d8ff118dbcf92ff2">operations_research::CBCInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000792 (user): Maybe we should expose the CbcModel build from osi_
instead, but a new CbcModel is built every time Solve is called,
so it is not possible right now. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a6a5db12c8eb55529c5717db21d40f856 "<a class="el" href="namespaceoperations__research.html#a6a5db12c8eb55529c5717db21d40f856">operations_research::CeilRatio</a>" (int64_t value, int64_t positive_coeff)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002565 (user): Use MathUtil::CeilOfRatio / FloorOfRatio instead.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1CheapestInsertionFilteredHeuristic#a2cbaa7c6b0ef91b6f3a6b69225547a88 "<a class="el" href="classoperations__research_1_1CheapestInsertionFilteredHeuristic.html#a2cbaa7c6b0ef91b6f3a6b69225547a88">operations_research::CheapestInsertionFilteredHeuristic::ComputeStartEndDistanceForVehicles</a>" (absl::Span&lt; const int &gt; vehicles)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000402 (user): consider checking search limits.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1CheapestInsertionFilteredHeuristic#a1a109ae320b663d295dfdfc68f608810 "<a class="el" href="classoperations__research_1_1CheapestInsertionFilteredHeuristic.html#a1a109ae320b663d295dfdfc68f608810">operations_research::CheapestInsertionFilteredHeuristic::GetInsertionCostForNodeAtPosition</a>" (int64_t node_to_insert, int64_t insert_after, int64_t insert_before, int vehicle) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000426 (user): Replace 'insert_before' and 'insert_after' by 'predecessor'
and 'successor' in the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesFilteredHeuristic Member \_internalref classoperations__research_1_1ChristofidesFilteredHeuristic#a30f60a5304f5bd801ece16fb0868b0fb "<a class="el" href="classoperations__research_1_1ChristofidesFilteredHeuristic.html#a30f60a5304f5bd801ece16fb0868b0fb">operations_research::ChristofidesFilteredHeuristic::BuildSolutionInternal</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000412 (user): Support pickup &amp; delivery.
 &lt;p&gt; \anchor _todo000413 (user): Add robustness to fixed arcs by collapsing them into meta-
nodes. 
 &lt;p&gt; \anchor _todo000414 (user): Investigate if ChristofidesPathSolver should not
return a status to bail out fast in case of problem. 
 &lt;p&gt; \anchor _todo000415 (user): Investigate if sorting paths per cost improves solutions.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesPathSolver Member \_internalref classoperations__research_1_1ChristofidesPathSolver#a76c636e1d48da64087686dd06bc45519 "<a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a76c636e1d48da64087686dd06bc45519">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::SetMatchingAlgorithm</a>" (MatchingAlgorithm matching)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000666 (user): Change the default when minimum matching gets faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ChristofidesPathSolver Member \_internalref classoperations__research_1_1ChristofidesPathSolver#a0fd40e5b4dd3c4d2eec044aafc9cdc7a "<a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a0fd40e5b4dd3c4d2eec044aafc9cdc7a">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000664 (user): Make this code available as an independent algorithm. 
 &lt;p&gt; \anchor _todo000665 (user): Cost caching was added and can gain up to 20% but
increases memory usage; see if we can avoid caching. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a847f0d17543462778951c488a176ea7e "<a class="el" href="namespaceoperations__research.html#a83bba640c0d87bf715b181f315052c30" title="The consistency level is maintained up to kCostAndCoverage.">operations_research::ClearMostCoveredElements</a>" (absl::Span&lt; const SubsetIndex &gt; focus, BaseInt num_subsets, SetCoverInvariant *inv)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000044 (user):find another algorithm if
necessary. 
 &lt;p&gt; \anchor _todo000045 (user): find another algorithm if necessary. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CLPInterface Member \_internalref classoperations__research_1_1CLPInterface#adbecc3c53101ed075d7078a7ea8f3e19 "<a class="el" href="classoperations__research_1_1CLPInterface.html#adbecc3c53101ed075d7078a7ea8f3e19" title="Define new variables and add them to existing constraints.">operations_research::CLPInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000794 (user): This could perhaps be made slightly faster by
iterating through old constraints, constructing by hand the
column-major representation of the addition to them and call
clp_-&gt;addColumns. But this is good enough for now.
Create new variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a53bf12f941f978cc1b1b985816c1fbdf "<a class="el" href="namespaceoperations__research.html#a53bf12f941f978cc1b1b985816c1fbdf">operations_research::ComputeMinimumWeightMatchingWithMIP</a>" (const GraphType &amp;graph, const WeightFunctionType &amp;weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000663 (user): Handle infeasible cases if this algorithm is used outside of
Christofides. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a17bc3ce4791bdaf8e8f5f7315b4050e1 "<a class="el" href="namespaceoperations__research.html#a17bc3ce4791bdaf8e8f5f7315b4050e1">operations_research::ComputeOneToManyOnGraph</a>" (const GraphType *const graph, const std::vector&lt; PathDistance &gt; *const arc_lengths, typename GraphType::NodeIndex source, const std::vector&lt; typename GraphType::NodeIndex &gt; *const destinations, typename GenericPathContainer&lt; GraphType &gt;::Impl *const paths)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000762 (user): Investigate alternate implementation which wouldn't use
AdjustablePriorityQueue. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a25f46b686d6f253f53dc77ac9f52b4b6 "<a class="el" href="namespaceoperations__research.html#a25f46b686d6f253f53dc77ac9f52b4b6">operations_research::ConvertFlowModelToDimacs</a>" (const FlowModelProto &amp;flow_model, std::string *dimacs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000767 (user): This currently only works for min cost flow problem. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad3af7b57bcf2344c6378fbec1b59b96e "<a class="el" href="namespaceoperations__research.html#ad3af7b57bcf2344c6378fbec1b59b96e">operations_research::ConvertStatusOrMPSolutionResponse</a>" (bool log_error, absl::StatusOr&lt; MPSolutionResponse &gt; response)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000842 (user): All SolveWithProto() should just fill the appropriate response
instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#acb9df89a57d7e6c160136db67b224b88 "<a class="el" href="namespaceoperations__research.html#acb9df89a57d7e6c160136db67b224b88">operations_research::ConvexMinimum</a>" (absl::Span&lt; const Point &gt; sorted_points, std::function&lt; Value(Point)&gt; f)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000001 (user): Some relevant optimizations:
- Abort early if we know a lower bound on the min.
- Seed with a starting point if we know one.
- We technically do not need the points to be sorted and can use
  linear-time median computation to speed this up.&lt;p&gt; \anchor _todo000002 (user): replace std::function by absl::FunctionRef here and in
BinarySearch(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#a6dfd72260599acdb0d30d0eb612a9b2c "<a class="el" href="classoperations__research_1_1CplexInterface.html#a6dfd72260599acdb0d30d0eb612a9b2c" title="Extract all variables that have not yet been extracted.">operations_research::CplexInterface::ExtractNewVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000796 : Use a bitarray to flag the constraints that actually
intersect new variables? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#ade9838d567be0055711f0d0246878123 "<a class="el" href="classoperations__research_1_1CplexInterface.html#ade9838d567be0055711f0d0246878123" title="Sets the scaling mode.">operations_research::CplexInterface::SetScalingMode</a>" (int value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000797 : 0 is equilibrium scaling (the default), CPLEX also supports
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::CplexInterface Member \_internalref classoperations__research_1_1CplexInterface#a6f29640b71cf1b2be18d08c4888d654f "<a class="el" href="classoperations__research_1_1CplexInterface.html#a6f29640b71cf1b2be18d08c4888d654f" title="Modifies integrality of an extracted variable.">operations_research::CplexInterface::SetVariableInteger</a>" (int var_index, bool integer)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000795 : Should we check the current type and don't do anything
      in case the type does not change? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DemonProfiler Member \_internalref classoperations__research_1_1DemonProfiler#a7b7c6355eb1daf5a3db8f0d575947ed2 "<a class="el" href="classoperations__research_1_1DemonProfiler.html#a7b7c6355eb1daf5a3db8f0d575947ed2">operations_research::DemonProfiler::CurrentTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000183 (user): rename and return nanoseconds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionChecker Member \_internalref classoperations__research_1_1DimensionChecker#a0f3d75f9157801c9a32ab3e5d9bdc23e "<a class="el" href="classoperations__research_1_1DimensionChecker.html#a0f3d75f9157801c9a32ab3e5d9bdc23e">operations_research::DimensionChecker::DimensionChecker</a>" (const PathState *path_state, std::vector&lt; Interval &gt; path_capacity, std::vector&lt; int &gt; path_class, std::vector&lt; std::function&lt; Interval(int64_t, int64_t)&gt; &gt; demand_per_path_class, std::vector&lt; Interval &gt; node_capacity, int min_range_size_for_riq=kOptimalMinRangeSizeForRIQ)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000345 (user): the addition of kMinRangeSizeForRIQ slowed down Check().
See if using a template parameter makes it faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#a124f8416552eec51fea7c3f0f47d722b "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#a124f8416552eec51fea7c3f0f47d722b">operations_research::DimensionCumulOptimizerCore::Optimize</a>" (const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const std::vector&lt; RouteDimensionTravelInfo &gt; &amp;dimension_travel_info_per_route, RoutingLinearSolverWrapper *solver, std::vector&lt; int64_t &gt; *cumul_values, std::vector&lt; int64_t &gt; *break_values, std::vector&lt; std::vector&lt; int &gt; &gt; *resource_indices_per_group, int64_t *cost_without_transits, int64_t *transit_cost, bool clear_lp=true, bool optimize_resource_assignment=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000364 (user): In case the status is RELAXED_OPTIMAL_ONLY, check we can
safely avoid filling variable and cost values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#a5a239314a69e35f6411905cd4bebb6d8 "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#a5a239314a69e35f6411905cd4bebb6d8">operations_research::DimensionCumulOptimizerCore::OptimizeAndPack</a>" (const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const std::vector&lt; RouteDimensionTravelInfo &gt; &amp;dimension_travel_info_per_route, RoutingLinearSolverWrapper *solver, std::vector&lt; int64_t &gt; *cumul_values, std::vector&lt; int64_t &gt; *break_values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000365 (user): In case the status is RELAXED_OPTIMAL_ONLY, check we can
safely avoid filling variable values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#ac8ab6f2b9ebe23674ffbecf0217efd10 "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#ac8ab6f2b9ebe23674ffbecf0217efd10">operations_research::DimensionCumulOptimizerCore::OptimizeAndPackSingleRoute</a>" (int vehicle, double solve_duration_ratio, const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const RouteDimensionTravelInfo *dimension_travel_info, const Resource *resource, RoutingLinearSolverWrapper *solver, std::vector&lt; int64_t &gt; *cumul_values, std::vector&lt; int64_t &gt; *break_values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000366 (user): Since there are 3 separate solves for packing, divide the
input solve_duration_ratio by 3 before passing to the below functions? Or
maybe divide by 2 and let PackRoutes() divide by 2 itself (since the 2
solves in PackRoutes() should start with a very good first solution hint). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DimensionCumulOptimizerCore Member \_internalref classoperations__research_1_1DimensionCumulOptimizerCore#afa4a474ddb87fac497b2efb77b27f4d2 "<a class="el" href="classoperations__research_1_1DimensionCumulOptimizerCore.html#afa4a474ddb87fac497b2efb77b27f4d2">operations_research::DimensionCumulOptimizerCore::OptimizeSingleRouteWithResources</a>" (int vehicle, double solve_duration_ratio, const std::function&lt; int64_t(int64_t)&gt; &amp;next_accessor, const std::function&lt; int64_t(int64_t, int64_t)&gt; &amp;transit_accessor, const RouteDimensionTravelInfo *dimension_travel_info, absl::Span&lt; const Resource &gt; resources, absl::Span&lt; const int &gt; resource_indices, bool optimize_vehicle_costs, RoutingLinearSolverWrapper *solver, std::vector&lt; std::vector&lt; int64_t &gt; &gt; *cumul_values, std::vector&lt; std::vector&lt; int64_t &gt; &gt; *break_values, std::vector&lt; int64_t &gt; *costs_without_transits, int64_t *transit_cost, bool clear_lp=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000363 (user): Consider taking 'num_solves' into account to re-adjust the
solve_duration_ratio to make sure all sub-problems are given enough time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad0b44ed99c3501d7a797dfa6ac52714f "<a class="el" href="namespaceoperations__research.html#af223cfc20a19613cbf63b9b9f08795cb">operations_research::DisplayPlan</a>" (const operations_research::RoutingIndexManager &amp;manager, const operations_research::RoutingModel &amp;routing, const operations_research::Assignment &amp;plan, bool use_same_vehicle_costs, int64_t max_nodes_per_group, int64_t same_vehicle_cost, const operations_research::RoutingDimension &amp;capacity_dimension, const operations_research::RoutingDimension &amp;time_dimension)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001098 (user): Move the display code to the routing library. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DistributionStat Member \_internalref classoperations__research_1_1DistributionStat#a68349bcba1db1a5a68ebd1d855bdd078 "<a class="el" href="classoperations__research_1_1DistributionStat.html#a68349bcba1db1a5a68ebd1d855bdd078">operations_research::DistributionStat::StdDeviation</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002575 (user): We could also use on top the Kahan summation algorithm to be
even more precise but a bit slower too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#a714a1473bb78dab3195bd5cd5e90af42 "<a class="el" href="classoperations__research_1_1Domain.html#a714a1473bb78dab3195bd5cd5e90af42">operations_research::Domain::AdditionWith</a>" (const Domain &amp;domain) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002568 (user): Use a better algorithm.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#afea26857db7d2e50a267c9d9d5ceb661 "<a class="el" href="classoperations__research_1_1Domain.html#afea26857db7d2e50a267c9d9d5ceb661">operations_research::Domain::ClosestValue</a>" (int64_t wanted) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002566 (user): Use std::upper_bound() like in ValueAtOrBefore() ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Domain Member \_internalref classoperations__research_1_1Domain#a8de91c6ec98c4eaa9ec6c7e1f5e26d71 "<a class="el" href="classoperations__research_1_1Domain.html#a8de91c6ec98c4eaa9ec6c7e1f5e26d71">operations_research::Domain::Distance</a>" (int64_t value) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002567 (user): Deal with overflow.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Class \_internalref classoperations__research_1_1DynamicPartition "<a class="el" href="classoperations__research_1_1DynamicPartition.html">operations_research::DynamicPartition</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000007 (user): rename this to BacktrackableSplittingPartition. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Member \_internalref classoperations__research_1_1DynamicPartition#ae0789ce355b93a5161e63666b4467e67 "<a class="el" href="classoperations__research_1_1DynamicPartition.html#afe6f90b99c0b1d646b00ad2d1bb0a09d">operations_research::DynamicPartition::DynamicPartition</a>" (const std::vector&lt; int &gt; &amp;initial_part_of_element)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000003 (user): either remove this or factor it out if it can be used
elsewhere. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPartition Member \_internalref classoperations__research_1_1DynamicPartition#ab82a2915429e5c6626c9187ed85e7064 "<a class="el" href="classoperations__research_1_1DynamicPartition.html#ab82a2915429e5c6626c9187ed85e7064">operations_research::DynamicPartition::Refine</a>" (absl::Span&lt; const int &gt; distinguished_subset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000004 (user): optimize the common singleton case.
 &lt;p&gt; \anchor _todo000005 (user): automatically switch to an O(N) sort when it's faster
than this one, which is O(K log K) with K = tmp_affected_parts_.size(). 
 &lt;p&gt; \anchor _todo000008 (user): the graph symmetry finder could probably benefit a lot from
keeping track of one additional bit of information for each part that
remains unchanged by a Refine() operation: was that part entirely &lt;em&gt;in&lt;/em&gt;
the distinguished subset or entirely &lt;em&gt;out&lt;/em&gt;? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::DynamicPermutation Member \_internalref classoperations__research_1_1DynamicPermutation#a529b7a5b760666c049da283212991a5b "<a class="el" href="classoperations__research_1_1DynamicPermutation.html#a529b7a5b760666c049da283212991a5b">operations_research::DynamicPermutation::LooseEnds</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000009 (user): use a faster underlying container like SparseBitSet, and
tweak this API accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ElementDegreeSolutionGenerator Member \_internalref classoperations__research_1_1ElementDegreeSolutionGenerator#abbe235864c43f519c5ac9c0de3d870f4 "<a class="el" href="classoperations__research_1_1ElementDegreeSolutionGenerator.html#abbe235864c43f519c5ac9c0de3d870f4">operations_research::ElementDegreeSolutionGenerator::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000052 (user): Add time-outs and exit with a partial solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ElementIterator Class \_internalref classoperations__research_1_1ElementIterator "<a class="el" href="classoperations__research_1_1ElementIterator.html">operations_research::ElementIterator&lt; Set &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000700 (user): Move the Set-related classbelow to util/bitset.h
Iterates over the elements of a set represented as an unsigned integer,
starting from the smallest element.  (See the class Set&lt;Integer&gt; below.) 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a37a741d996d47dd7663171f73749fd7b "<a class="el" href="namespaceoperations__research.html#a37a741d996d47dd7663171f73749fd7b" title="--— ExchangeAndMakeActive --—">operations_research::ExchangeAndMakeActive</a>" (Solver *solver, const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;secondary_vars, std::function&lt; int(int64_t)&gt; start_empty_path_class)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000171 (user): Add support for neighbors which would make this operator more
usable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aec4acaffc116729d427b2abfbde0cd82 "<a class="el" href="namespaceoperations__research.html#aec4acaffc116729d427b2abfbde0cd82">operations_research::FillPathEvaluation</a>" (absl::Span&lt; const int64_t &gt; path, const RoutingModel::TransitCallback2 &amp;evaluator, std::vector&lt; int64_t &gt; *values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000301 (user): Apply -pointer-following.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FilteredHeuristicLocalSearchOperator Class \_internalref classoperations__research_1_1FilteredHeuristicLocalSearchOperator "<a class="el" href="classoperations__research_1_1FilteredHeuristicLocalSearchOperator.html">operations_research::FilteredHeuristicLocalSearchOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000360 (user): Put these methods in an object with helper methods instead
of adding a layer to the class hierarchy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FilteredHeuristicLocalSearchOperator Member \_internalref classoperations__research_1_1FilteredHeuristicLocalSearchOperator#a27a42fcdb24320190aa6760ab0aa2c7a "<a class="el" href="classoperations__research_1_1FilteredHeuristicLocalSearchOperator.html#a27a42fcdb24320190aa6760ab0aa2c7a">operations_research::FilteredHeuristicLocalSearchOperator::model_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000361 (user): Remove the dependency from RoutingModel by storing an
IntVarFilteredHeuristic here instead and storing information on path
start/ends like PathOperator does (instead of relying on the model). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ae4ee4d82cf625670cdc1f52197454654 "<a class="el" href="namespaceoperations__research.html#ae4ee4d82cf625670cdc1f52197454654">operations_research::FindFeasibilityErrorInSolutionHint</a>" (const MPModelProto &amp;model, double tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000834 (user): Add a general FindFeasibilityErrorInSolution() and factor out the
common code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FindOneNeighbor Member \_internalref classoperations__research_1_1FindOneNeighbor#ae778e45052fc69775bc50b2d12294a4c "<a class="el" href="classoperations__research_1_1FindOneNeighbor.html#ae778e45052fc69775bc50b2d12294a4c">operations_research::FindOneNeighbor::FindOneNeighbor</a>" (Assignment *assignment, IntVar *objective, SolutionPool *pool, LocalSearchOperator *ls_operator, DecisionBuilder *sub_decision_builder, const RegularLimit *limit, LocalSearchFilterManager *filter_manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000241 (user): Support skipping neighborhood checks for limits accepting
more than one solution (e.g. best accept). For now re-enabling systematic
checks. 
 &lt;p&gt; \anchor _todo000242 (user): Support skipping neighborhood checks with LNS (at least on
the non-LNS operators). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FindOneNeighbor Member \_internalref classoperations__research_1_1FindOneNeighbor#a25667f46f98b5158a6d89bcf93a07b46 "<a class="el" href="classoperations__research_1_1FindOneNeighbor.html#a25667f46f98b5158a6d89bcf93a07b46">operations_research::FindOneNeighbor::Next</a>" (Solver *solver) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000243 (user) : SyncNeed(assignment_) ?
 &lt;p&gt; \anchor _todo000244 (user): Don't call both if no filter is incremental and one
of them returned false. 
 &lt;p&gt; \anchor _todo000245 (user): support the case were limit_ accepts more than
one solution (e.g. best accept). 
 &lt;p&gt; \anchor _todo000246 (user): Restore state of local search operators to
make sure we are exploring neighbors in the same order. This can
affect the local optimum found. 
 &lt;p&gt; \anchor _todo000247 (user): Compare assignments in addition to their cost. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::FloatSlopePiecewiseLinearFunction Class \_internalref classoperations__research_1_1FloatSlopePiecewiseLinearFunction "<a class="el" href="classoperations__research_1_1FloatSlopePiecewiseLinearFunction.html">operations_research::FloatSlopePiecewiseLinearFunction</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002554 (user): Adjust the inlined vector sizes based on experiments. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Constraint Member \_internalref structoperations__research_1_1fz_1_1Constraint#a4d53b3107ef0dbfb3e99a52a2f4c0d42 "<a class="el" href="structoperations__research_1_1fz_1_1Constraint.html#a4d53b3107ef0dbfb3e99a52a2f4c0d42" title="Helpers to be used during presolve.">operations_research::fz::Constraint::MarkAsInactive</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000461 (user): Reclaim arguments and memory.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Struct \_internalref structoperations__research_1_1fz_1_1Domain "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html">operations_research::fz::Domain</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000463 (user): Rework domains, all int64_t should be kintmin..kint64max.
               It is a bit tricky though as we must take care of overflows.
If is_a_set is true, then this domain has a set semantics. For a set
variable, any subset of the initial set of values is a valid assignment,
instead of exactly one value. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ac4d428774d29f823cc82a1e9094f1926 "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ac4d428774d29f823cc82a1e9094f1926">operations_research::fz::Domain::HasOneValue</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000465 (user): Do we need SetOfFloats() ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ae0c523fec5cdb2c506835d037c78557c "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ae0c523fec5cdb2c506835d037c78557c">operations_research::fz::Domain::IntersectWithListOfIntegers</a>" (absl::Span&lt; const int64_t &gt; integers)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000459 (user): Investigate faster code for small arrays.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Domain Member \_internalref structoperations__research_1_1fz_1_1Domain#ae4c771e4304fd0443a538c84d3c62870 "<a class="el" href="structoperations__research_1_1fz_1_1Domain.html#ae4c771e4304fd0443a538c84d3c62870">operations_research::fz::Domain::OverlapsIntList</a>" (const std::vector&lt; int64_t &gt; &amp;vec) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000460 (user): Better algorithm, sort and compare increasingly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::LexerInfo Struct \_internalref structoperations__research_1_1fz_1_1LexerInfo "<a class="el" href="structoperations__research_1_1fz_1_1LexerInfo.html">operations_research::fz::LexerInfo</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000473 (user): Use std::unique_ptr&lt;vector&lt; &gt;&gt; to ease memory management. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz Member \_internalref namespaceoperations__research_1_1fz#a0d0d1d18eea7879af81671f8395b8b1d "<a class="el" href="namespaceoperations__research_1_1fz.html#a0d0d1d18eea7879af81671f8395b8b1d">operations_research::fz::Lookup</a>" (const std::vector&lt; T &gt; &amp;v, int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000472 (user): replace this by a macro for better logging.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::Model Member \_internalref classoperations__research_1_1fz_1_1Model#affdfad9a0c88744ef4cfe7c80adc4fb1 "<a class="el" href="classoperations__research_1_1fz_1_1Model.html#affdfad9a0c88744ef4cfe7c80adc4fb1">operations_research::fz::Model::AddConstant</a>" (int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000462 (user): Create only once constant per value.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::fz::ModelStatistics Class \_internalref classoperations__research_1_1fz_1_1ModelStatistics "<a class="el" href="classoperations__research_1_1fz_1_1ModelStatistics.html">operations_research::fz::ModelStatistics</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000464 (user): Clean up API to pass a Model* in argument. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a70b4af19b383f997f2567986ae3d2ba1 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a70b4af19b383f997f2567986ae3d2ba1">operations_research::GenericMaxFlow&lt; Graph, ArcFlowT, FlowSumT &gt;::Flow</a>" (ArcIndex arc) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000684 (user): We could change the API to avoid that if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#ab99402a4c7128d4298153c7c8b627642 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ab99402a4c7128d4298153c7c8b627642">operations_research::GenericMaxFlow&lt; Graph, ArcFlowT, FlowSumT &gt;::GenericMaxFlow</a>" (const Graph *graph, NodeIndex source, NodeIndex sink)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000676 (user): Unfortunately std/absl::make_unique_for_overwrite is not
yet available in open-source. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a9f5af7b1fe783ff9485a368543a9cae9 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a9f5af7b1fe783ff9485a368543a9cae9">operations_research::GenericMaxFlow&lt; Graph, ArcFlowT, FlowSumT &gt;::GetSinkSideMinCut</a>" (std::vector&lt; NodeIndex &gt; *result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000685 (user): In the two-phases algorithm, we can get this minimum cut
without doing the second phase. Add an option for this if there is a need
to, note that the second phase is pretty fast so the gain will be small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#aeeba70cd83cf1e59f15a3ad0ae9608ab "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#aeeba70cd83cf1e59f15a3ad0ae9608ab">operations_research::GenericMaxFlow&lt; Graph, ArcFlowT, FlowSumT &gt;::GlobalUpdate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000679 (user): By using more memory we can speed this up quite a bit by
avoiding to take the opposite arc here, too options:
- if (residual_arc_capacity_[arc] != arc_capacity_[arc])
- if (opposite_arc_is_admissible_[arc])  ///&lt; need updates.
Experiment with the first option shows more than 10% gain on this
function running time, which is the bottleneck on many instances. 
 &lt;p&gt; \anchor _todo000680 (user): Investigate more and maybe write a publication :) 
 &lt;p&gt; \anchor _todo000681 (user): This is another argument for another anti-overflow algorithm. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a01ceb6e57fe26b851115a2facdaf6569 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a01ceb6e57fe26b851115a2facdaf6569" title="Initializes the preflow to a state that enables to run Refine.">operations_research::GenericMaxFlow&lt; Graph, ArcFlowT, FlowSumT &gt;::InitializePreflow</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000677 (user): Ebert graph has an issue with nodes with no arcs, so we
use max_num_nodes here to resize vectors. 
 &lt;p&gt; \anchor _todo000678 (user): find a way to make the re-solving incremental (not an obvious
task, and there has not been a lot of literature on the subject.) 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a843969d2149a1c2f6e83358d5e61e036 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a843969d2149a1c2f6e83358d5e61e036">operations_research::GenericMaxFlow&lt; Graph, ArcFlowT, FlowSumT &gt;::node_excess_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000686 (user): If needed we could tweak that to allow unsigned FlowSumType. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericMaxFlow Member \_internalref classoperations__research_1_1GenericMaxFlow#a10b063de13aba3f9ec7b2d8560e1aa32 "<a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a10b063de13aba3f9ec7b2d8560e1aa32">operations_research::GenericMaxFlow&lt; Graph, ArcFlowT, FlowSumT &gt;::RefineWithGlobalUpdate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000682 (user): This may not be the most efficient algorithm if we need to loop
many times. An alternative may be to handle the source like the other nodes
in the algorithm, initially putting an excess of kMaxFlowSum on it,
and making the source active like any other node with positive excess. To
investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GenericPathContainer Member \_internalref classoperations__research_1_1GenericPathContainer#ad5864394b17d07fee5b5f67750a53155 "<a class="el" href="classoperations__research_1_1GenericPathContainer.html#ad5864394b17d07fee5b5f67750a53155">operations_research::GenericPathContainer&lt; GraphType &gt;::GetPenultimateNodeInPath</a>" (NodeIndex from, NodeIndex to) const =0&lt;/dt&gt;&lt;dd&gt; \anchor _todo000763 (user): Add save-to-disk container.
/ &lt;p&gt; &lt;p&gt;(user): Add &lt;tt&gt;BuildInMemoryFastPathContainer()&lt;/tt&gt;, which does
/ &lt;tt&gt;GetPenultimateNodeInPath()&lt;/tt&gt; in &lt;tt&gt;O(1)&lt;/tt&gt;.&lt;p&gt; \anchor _todo000764 (b/385094969): Remove second template parameter when all clients are
/ migrated.
template &lt;class GraphType&gt;
void ComputeOneToManyShortestPaths(
    const GraphType&amp; graph, const std::vector&lt;PathDistance&gt;&amp; arc_lengths,
    typename GraphType::NodeIndex source,
    const std::vector&lt;typename GraphType::NodeIndex&gt;&amp; destinations,
    GenericPathContainer&lt;GraphType&gt;* const path_container) {
  std::vector&lt;typename GraphType::NodeIndex&gt; sources(1, source);
  ComputeManyToManyShortestPathsWithMultipleThreads(
      graph, arc_lengths, sources, destinations, 1, path_container);
}&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#af8b64e33d94a43d071d6faeedf8a9305 "<a class="el" href="namespaceoperations__research.html#a20f1b86022ab6b187d9e205fc308eb39">operations_research::GetBestScalingOfDoublesToInt64</a>" (absl::Span&lt; const double &gt; input, int64_t max_absolute_sum, double *scaling_factor, double *max_relative_coeff_error)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002549 (user): incorporate the gcd computation here? The issue is that I am
not sure if I just do factor /= gcd that round(x * factor) will be the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GlobalCheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1GlobalCheapestInsertionFilteredHeuristic#abe76b53e07ae6db10cda5c6fd70d0001 "<a class="el" href="classoperations__research_1_1GlobalCheapestInsertionFilteredHeuristic.html#abe76b53e07ae6db10cda5c6fd70d0001" title="Virtual method to redefine how to build a solution.">operations_research::GlobalCheapestInsertionFilteredHeuristic::BuildSolutionInternal</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000403 (user): Adapt the pair insertions to also support seed and
sequential insertion. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aeacc29c42c7fddda875937d3bdfc7e08 "<a class="el" href="namespaceoperations__research_1_1glop.html#aeacc29c42c7fddda875937d3bdfc7e08">operations_research::glop::ABSL_DEPRECATED</a>" ("Use the direct methods instead") MPSReader&lt;/dt&gt;&lt;dd&gt; \anchor _todo000901 (user): Remove the MPSReader class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::AddSlackVariablesPreprocessor Class \_internalref classoperations__research_1_1glop_1_1AddSlackVariablesPreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1AddSlackVariablesPreprocessor.html">operations_research::glop::AddSlackVariablesPreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000563 (user): Do not require this step to talk to the revised simplex. On large
LPs like supportcase11.mps, this step alone can add 1.5 GB to the solver peak
memory for no good reason. The internal matrix representation used in glop is
a lot more efficient, and there is no point keeping the slacks in
LinearProgram. It is also bad for incrementaly modifying the LP. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#acf14406acccf01da7c2dd2fa1c66425e "<a class="el" href="namespaceoperations__research_1_1glop.html#acf14406acccf01da7c2dd2fa1c66425e">operations_research::glop::ApplyPermutation</a>" (const Permutation&lt; IndexType &gt; &amp;perm, const ITIVectorType &amp;b, ITIVectorType *result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000909 (user): Try to restrict this method to using the same integer type in
the permutation and for the vector indices, i.e.
IndexType == ITIVectorType::IndexType. Some client code will need to be
refactored. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aac6525bf47674e01c5d51e956ce13a63 "<a class="el" href="namespaceoperations__research_1_1glop.html#aac6525bf47674e01c5d51e956ce13a63">operations_research::glop::AreFirstColumnsAndRowsExactlyEquals</a>" (RowIndex num_rows, ColIndex num_cols, const SparseMatrix &amp;matrix_a, const CompactSparseMatrix &amp;matrix_b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000898 (user): Also DCHECK() that matrix_b is ordered by rows.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#a370b080a5be3e81960457e53261e7cd5 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#a370b080a5be3e81960457e53261e7cd5">operations_research::glop::BasisFactorization::ComputeInitialBasis</a>" (const std::vector&lt; ColIndex &gt; &amp;candidates)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000478 (user): This "double" factorization is a bit inefficient, and we should
probably Initialize() right away the factorization with the new basis, but
more code is needed for that. It is also not that easy also because we want
to permute all the added slack first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#af2eba683b05901eb982dcade3fda53d3 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#af2eba683b05901eb982dcade3fda53d3">operations_research::glop::BasisFactorization::ComputeInverseOneNorm</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000476 (user): try to merge the computation of the norm of inverses
with that of MatrixView. Maybe use a wrapper class for InverseMatrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisFactorization Member \_internalref classoperations__research_1_1glop_1_1BasisFactorization#a90e327f8ea7f4594bab0686230735287 "<a class="el" href="classoperations__research_1_1glop_1_1BasisFactorization.html#a90e327f8ea7f4594bab0686230735287">operations_research::glop::BasisFactorization::RightSolveForProblemColumn</a>" (ColIndex col, ScatteredColumn *d) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000475 (user): if right_pool_mapping_[col] != kInvalidCol, we can reuse it and
just apply the last rank one update since it was computed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisState Struct \_internalref structoperations__research_1_1glop_1_1BasisState "<a class="el" href="structoperations__research_1_1glop_1_1BasisState.html">operations_research::glop::BasisState</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000658 (user): Introduce another state class to store a complete state of the
solver. Using this state and the original linear program, the solver can be
restarted with as little time overhead as possible. This is especially useful
for strong branching in a MIP context. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::BasisState Member \_internalref structoperations__research_1_1glop_1_1BasisState#a8403627807a2ba65e69b8fb58061293f "<a class="el" href="structoperations__research_1_1glop_1_1BasisState.html#a8403627807a2ba65e69b8fb58061293f">operations_research::glop::BasisState::statuses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000659 (user): A MIP solver will potentially store a lot of BasisStates so
memory usage is important. It is possible to use only 2 bits for one
VariableStatus enum. To achieve this, the FIXED_VALUE status can be
converted to either AT_LOWER_BOUND or AT_UPPER_BOUND and decoded properly
later since this will be used with a given linear program. This way we can
even encode more information by using the reduced cost sign to choose to
which bound the fixed status correspond. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ColumnView Member \_internalref classoperations__research_1_1glop_1_1ColumnView#a37aadf4689cf83d4e92724df18788c26 "<a class="el" href="classoperations__research_1_1glop_1_1ColumnView.html#a37aadf4689cf83d4e92724df18788c26">operations_research::glop::ColumnView::LookUpCoefficient</a>" (RowIndex index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000924 (user): investigate whether an optimized version of
LookUpCoefficient for "clean" columns yields speed-ups. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::CompactSparseMatrix Member \_internalref classoperations__research_1_1glop_1_1CompactSparseMatrix#aa5613aefbe167b3a7060c47adbc18257 "<a class="el" href="classoperations__research_1_1glop_1_1CompactSparseMatrix.html#a28d29a8481b6e9b5fc41eedc1fc60e84">operations_research::glop::CompactSparseMatrix::CompactSparseMatrix</a>" (const SparseMatrix &amp;matrix)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000919 (user): If this is needed in production code, it can be done faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DataWrapper&lt; MPModelProto &gt; Member \_internalref classoperations__research_1_1glop_1_1DataWrapper_3_01MPModelProto_01_4#ae847ea2baa71fe069259a785a2f793ba "<a class="el" href="classoperations__research_1_1glop_1_1DataWrapper_3_01MPModelProto_01_4.html#ae847ea2baa71fe069259a785a2f793ba">operations_research::glop::DataWrapper&lt; MPModelProto &gt;::CleanUp</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000900 (user): Experiment with the switch constant.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a02a36a3bb1bee8ca88e9d07f4e914ad2 "<a class="el" href="namespaceoperations__research_1_1glop.html#a02a36a3bb1bee8ca88e9d07f4e914ad2">operations_research::glop::Density</a>" (const DenseRow &amp;row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000895 (user): Take a Scattered row/col instead. This is only used to report
stats, but we should still have a sparse version to do it faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonEqualityRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor#a417519507dabcad60034e4b158755bf5 "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor.html#a417519507dabcad60034e4b158755bf5">operations_research::glop::DoubletonEqualityRowPreprocessor::RecoverSolution</a>" (ProblemSolution *solution) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000552 (user): We can probably use something better than a vector of set,
but the number of entry is really sparse though. And the size of a set&lt;int&gt;
is 24 bytes, same as a std::vector&lt;int&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonEqualityRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor#aee8ab3fb7503d6267c9a09854ecd7a2d "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonEqualityRowPreprocessor.html#aee8ab3fb7503d6267c9a09854ecd7a2d">operations_research::glop::DoubletonEqualityRowPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000547 (user): Get rid of the FIXED status instead to avoid spending
time/memory for no good reason here. 
 &lt;p&gt; \anchor _todo000548 (user): There is probably some more robust ways. 
 &lt;p&gt; \anchor _todo000549 (user): make a smarter choice of which column to delete, and
swap col[] and coeff[] accordingly. 
 &lt;p&gt; \anchor _todo000550 (user): consider skipping the problematic rows in this preprocessor,
or trying harder to avoid the under/overflow. 
 &lt;p&gt; \anchor _todo000551 (user): rename that method to reflect the fact that it also updates
the objective offset, in the other direction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DoubletonFreeColumnPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DoubletonFreeColumnPreprocessor#ab64cfa1fb6ff03f45291fcb60f506963 "<a class="el" href="classoperations__research_1_1glop_1_1DoubletonFreeColumnPreprocessor.html#ab64cfa1fb6ff03f45291fcb60f506963">operations_research::glop::DoubletonFreeColumnPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000531 (user): Impact? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DualEdgeNorms Member \_internalref classoperations__research_1_1glop_1_1DualEdgeNorms#ab9c06f7b3b7e0337da531ca86c3fd43c "<a class="el" href="classoperations__research_1_1glop_1_1DualEdgeNorms.html#ab9c06f7b3b7e0337da531ca86c3fd43c">operations_research::glop::DualEdgeNorms::UpdateBeforeBasisPivot</a>" (ColIndex entering_col, RowIndex leaving_row, const ScatteredColumn &amp;direction, const ScatteredRow &amp;unit_row_left_inverse)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000479 (user): use a more precise lower bound depending on the column norm?
We can do that with Cauchy-Schwarz inequality:
  (edge . leaving_column)^2 = 1.0 &lt; |&lt;tt&gt;edge&lt;/tt&gt;|^2 * |&lt;tt&gt;leaving_column&lt;/tt&gt;|^2 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DualizerPreprocessor Member \_internalref classoperations__research_1_1glop_1_1DualizerPreprocessor#afb190878213f1da31a0daa0f03b9e017 "<a class="el" href="classoperations__research_1_1glop_1_1DualizerPreprocessor.html#afb190878213f1da31a0daa0f03b9e017">operations_research::glop::DualizerPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000553 (user): This effect can be lowered if we use some of the extra
variables as slack variable which we are not doing at this point. 
 &lt;p&gt; \anchor _todo000554 (user): This will break if PopulateFromDual() is changed. so document
the convention or make the function fill these vectors? 
 &lt;p&gt; \anchor _todo000555 (user): There are two different ways to deal with ranged rows when
taking the dual. The default way is to duplicate such rows, see
PopulateFromDual() for details. Another way is to call
lp-&gt;AddSlackVariablesForFreeAndBoxedRows() before calling
PopulateFromDual(). Adds an option to switch between the two as this may
change the running time?&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::DynamicMaximum Member \_internalref classoperations__research_1_1glop_1_1DynamicMaximum#a5a1cf0bc9507c1dfcef22b8d89d2d9f0 "<a class="el" href="classoperations__research_1_1glop_1_1DynamicMaximum.html#a5a1cf0bc9507c1dfcef22b8d89d2d9f0">operations_research::glop::DynamicMaximum&lt; Index &gt;::GetMaximum</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000570 (user): Add a mode when we do not maintain the TopK for small sizes
(like n &lt; 1000) ? The gain might not be worth the extra code though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#a3c3a0b006ecdc59714cd1c66f50e7cff "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#a3c3a0b006ecdc59714cd1c66f50e7cff">operations_research::glop::EnteringVariable::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000483 (user): Be exhausitive and more precise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#a863b59030d198656afffb23fcd533948 "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#a863b59030d198656afffb23fcd533948">operations_research::glop::EnteringVariable::DualChooseEnteringColumn</a>" (bool nothing_to_recompute, const UpdateRow &amp;update_row, Fractional cost_variation, std::vector&lt; ColIndex &gt; *bound_flip_candidates, ColIndex *entering_col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000480 (user): It is unclear if this is a good idea, but the primal simplex
have pretty good/stable behavior with a similar logic. Experiment seems
to show that this works well with the dual too. 
 &lt;p&gt; \anchor _todo000481 (user): We want to maximize both the ratio (objective improvement)
and the coeff_magnitude (stable pivot), so we have to make some
trade-offs. Investigate alternative strategies. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::EnteringVariable Member \_internalref classoperations__research_1_1glop_1_1EnteringVariable#ad20764201d083354bdf18a8def790e4a "<a class="el" href="classoperations__research_1_1glop_1_1EnteringVariable.html#ad20764201d083354bdf18a8def790e4a">operations_research::glop::EnteringVariable::DualPhaseIChooseEnteringColumn</a>" (bool nothing_to_recompute, const UpdateRow &amp;update_row, Fractional cost_variation, ColIndex *entering_col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000482 (user): This is the same in DualChooseEnteringColumn(), remove
duplication? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#aed75af61dbbe6d3c628c274f271f9000 "<a class="el" href="namespaceoperations__research_1_1glop.html#aed75af61dbbe6d3c628c274f271f9000">operations_research::glop::FindProportionalColumns</a>" (const SparseMatrix &amp;matrix, Fractional tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000897 (user): Derive precise bounds on what this tolerance should be so
that no proportional columns are missed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#ac55fddbd6cdae02b8a88e2c845f0d4d7 "<a class="el" href="namespaceoperations__research_1_1glop.html#ac55fddbd6cdae02b8a88e2c845f0d4d7">operations_research::glop::FixConstraintWithFixedStatuses</a>" (const DenseColumn &amp;row_lower_bounds, const DenseColumn &amp;row_upper_bounds, ProblemSolution *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000561 (user): A better solution would simply be to get rid of the FIXED status
altogether, it is better to simply use AT_LOWER_BOUND/AT_UPPER_BOUND
depending on the constraining bound in the optimal solution. Note that we can
always at the end transform any variable/constraint with a fixed domain to
FIXED_VALUE if needed to keep the same external API. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ImpliedFreePreprocessor Class \_internalref classoperations__research_1_1glop_1_1ImpliedFreePreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1ImpliedFreePreprocessor.html">operations_research::glop::ImpliedFreePreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000560 (user): Only process doubleton columns so we have more chance in the
later passes to create more doubleton columns? Such columns lead to a smaller
problem thanks to the DoubletonFreeColumnPreprocessor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ImpliedFreePreprocessor Member \_internalref classoperations__research_1_1glop_1_1ImpliedFreePreprocessor#a22a4d717e6ac86260356defc467e980e "<a class="el" href="classoperations__research_1_1glop_1_1ImpliedFreePreprocessor.html#a22a4d717e6ac86260356defc467e980e">operations_research::glop::ImpliedFreePreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000526 (user) : Replace SumWithNegativeInfiniteAndOneMissing and
SumWithPositiveInfiniteAndOneMissing with IntervalSumWithOneMissing. 
 &lt;p&gt; \anchor _todo000527 (user): Only process degree-two so in subsequent passes more degree-two
columns could be made free. And only when no other reduction can be
applied, process the higher degree column?&lt;p&gt; \anchor _todo000528 (user): Be smarter about the order that maximizes the number of free
column. For instance if we have 3 doubleton columns that use the rows (1,2)
(2,3) and (3,4) then it is better not to make (2,3) free so the two other
two can be made free. 
 &lt;p&gt; \anchor _todo000529 (user): As of July 2013, with our preprocessors this case is never
triggered on the Netlib. Note however that if it appears it can have a
big impact since by fixing the variable, the two involved constraints
are forcing and can be removed too (with all the variables they touch).
The postsolve step is quite involved though. 
 &lt;p&gt; \anchor _todo000530 (user): This trick is already used in the DualizerPreprocessor,
maybe we should just have a preprocessor that shifts all the variables
bounds to have at least one of them at 0.0, will that improve precision
and speed of the simplex? One advantage is that we can compute the
new constraint bounds with better precision using AccurateSum. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a451faba66f544c02438a3ce062b69900 "<a class="el" href="namespaceoperations__research_1_1glop.html#a451faba66f544c02438a3ce062b69900">operations_research::glop::KahanSum</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000893 (user): For some Fractional types, it may not gain much (or even nothing
if we are in infinite precision) to use this sum. A solution is to templatize
this class and specialize it to a normal sum for the Fractional type we want
so in this case the PreciseXXX() functions below will become equivalent to
their normal version. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#abbaca14cc7f5a0f3aaeb027fef37e0ca "<a class="el" href="namespaceoperations__research_1_1glop.html#abbaca14cc7f5a0f3aaeb027fef37e0ca">operations_research::glop::kNonPivotal</a>" (-1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000923 (user): Consider using kInvalidRow for this?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a65b22be15b4caa784b8d7c690e2418ae "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a65b22be15b4caa784b8d7c690e2418ae">operations_research::glop::LinearProgram::AddSlackVariablesWhereNecessary</a>" (bool detect_integer_constraints)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000888 (user): investigate the impact on the running time. It seems low
because we almost never iterate on fixed variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#ab7e81c6d3e23deb4d58662661bf07f70 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#ab7e81c6d3e23deb4d58662661bf07f70">operations_research::glop::LinearProgram::Dump</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000883 (user): if needed provide similar output for binary variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8eb71b2feea025093caf9ee0ecaa1bc5 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8eb71b2feea025093caf9ee0ecaa1bc5">operations_research::glop::LinearProgram::FindOrCreateVariable</a>" (absl::string_view variable_id)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000885 (user): Move these and the two corresponding hash_table into a new
LinearProgramBuilder class to simplify the code of some functions like
DeleteColumns() here and make the behavior on copy clear? or simply remove
them as it is almost as easy to maintain a hash_table on the client side. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#abdf54cae5dbc76354d86e34108dcb3f3 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#abdf54cae5dbc76354d86e34108dcb3f3">operations_research::glop::LinearProgram::GetNonZeroStats</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000887 (user): Theses are statistics about the underlying matrix and should be
moved to SparseMatrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8c6c53f53e930c90d42930e648946ec6 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8c6c53f53e930c90d42930e648946ec6" title="Returns whether the variable at column col must take binary values or not.">operations_research::glop::LinearProgram::IsVariableBinary</a>" (ColIndex col) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000882 (user): bounds of binary variables (and of integer ones) should
be integer. Add a preprocessor for that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#afdef8d3fad551379c138ea96f9b695d3 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#afdef8d3fad551379c138ea96f9b695d3">operations_research::glop::LinearProgram::PopulateFromDual</a>" (const LinearProgram &amp;dual, RowToColMapping *duplicated_rows)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000889 (user): Do not interpret as a minimization problem? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#a8c83436c29274ad2930e716a0032d708 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#a8c83436c29274ad2930e716a0032d708">operations_research::glop::LinearProgram::ScaleObjective</a>" (GlopParameters::CostScalingAlgorithm method)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000890 (user): Another more aggressive idea is to set the median/mean/geomean
of the magnitudes to one. Investigate if this leads to better results. It
does look more robust.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LinearProgram Member \_internalref classoperations__research_1_1glop_1_1LinearProgram#aafd3e53a18570f0757a0a58f666b88c8 "<a class="el" href="classoperations__research_1_1glop_1_1LinearProgram.html#aafd3e53a18570f0757a0a58f666b88c8">operations_research::glop::LinearProgram::SetVariableName</a>" (ColIndex col, absl::string_view name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000886 (user): Add PopulateIdsFromNames() so names added via
Set{Variable|Constraint}Name() can be found. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#a9546370ee7138da64e3fb67577230bad "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#a9546370ee7138da64e3fb67577230bad">operations_research::glop::LPSolver::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000501 (user): Currently, this is only modified when the simplex code is
executed.&lt;p&gt; \anchor _todo000502 (user): Improve the correlation with the running time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#ae525d5598b932514635be5f0329610a4 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#ae525d5598b932514635be5f0329610a4">operations_research::glop::LPSolver::LoadAndVerifySolution</a>" (const LinearProgram &amp;lp, const ProblemSolution &amp;solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000488 (user): Try to also check the precision of an INFEASIBLE or UNBOUNDED
return status. 
 &lt;p&gt; \anchor _todo000489 (user): the name is not really consistent since in practice those are
the "residual" since the primal/dual infeasibility are zero when
parameters_.provide_strong_optimal_guarantee() is true. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#adb7f0e515ab9d9503a454e05904c0376 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#adb7f0e515ab9d9503a454e05904c0376">operations_research::glop::LPSolver::MayHaveMultipleOptimalSolutions</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000500 (user): Test this behavior extensively if a client relies on it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LPSolver Member \_internalref classoperations__research_1_1glop_1_1LPSolver#ac1d303dc79dae9cefd6185fda6c60e33 "<a class="el" href="classoperations__research_1_1glop_1_1LPSolver.html#ac1d303dc79dae9cefd6185fda6c60e33">operations_research::glop::LPSolver::SolveWithTimeLimit</a>" (const LinearProgram &amp;lp, TimeLimit *time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000486 (user): Unfortunately we are not really helpful with the error message
here. We could do a better job. However most client should talk to glop via
an input protocol buffer which should have better validation messages. 
 &lt;p&gt; \anchor _todo000487 (user): If speed matter, we could do that as we copy the program. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LuFactorization Member \_internalref classoperations__research_1_1glop_1_1LuFactorization#ab7b32a56a250336b4f954ad707f24b90 "<a class="el" href="classoperations__research_1_1glop_1_1LuFactorization.html#ab7b32a56a250336b4f954ad707f24b90">operations_research::glop::LuFactorization::ComputeLowerTimesUpper</a>" (SparseMatrix *product) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000505 (user): avoid the matrix conversion by multiplying TriangularMatrix
directly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::LuFactorization Member \_internalref classoperations__research_1_1glop_1_1LuFactorization#a9af5d602c804b0b6b64ace6d1b61f169 "<a class="el" href="classoperations__research_1_1glop_1_1LuFactorization.html#a9af5d602c804b0b6b64ace6d1b61f169">operations_research::glop::LuFactorization::ComputeOneNormConditionNumber</a>" (const CompactSparseMatrixView &amp;matrix) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000504 (user): separate this from LuFactorization. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MainLpPreprocessor Member \_internalref classoperations__research_1_1glop_1_1MainLpPreprocessor#a2d3237c0758f6628b102fcbe5b2002c8 "<a class="el" href="classoperations__research_1_1glop_1_1MainLpPreprocessor.html#a2d3237c0758f6628b102fcbe5b2002c8">operations_research::glop::MainLpPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000520 (user): Run them in the loop above if the effect on the running time
is good. This needs more investigation. 
 &lt;p&gt; \anchor _todo000521 (user): We probably want to scale the costs before and after this
preprocessor so that the rhs/objective of the dual are with a good
magnitude. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Markowitz Member \_internalref classoperations__research_1_1glop_1_1Markowitz#a57adb2bec33795ce391f871a1acbf761 "<a class="el" href="classoperations__research_1_1glop_1_1Markowitz.html#a57adb2bec33795ce391f871a1acbf761">operations_research::glop::Markowitz::ComputeRowAndColumnPermutation</a>" (const CompactSparseMatrixView &amp;basis_matrix, RowPermutation *row_perm, ColumnPermutation *col_perm)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000506 (user): If we don't need L and U, we can abort when the residual
matrix becomes dense (i.e. when its density factor is above a certain
threshold). The residual size is 'end_index - index' and the
density can either be computed exactly or estimated from min_markowitz. 
 &lt;p&gt; \anchor _todo000507 (user): This step can be skipped, once a fully dense matrix is
obtained. But note that permuted_lower_column_needs_solve_ needs to be
updated. 
 &lt;p&gt; \anchor _todo000508 (user): Note that in some rare cases, because of numerical
cancellation, the column degree may actually be smaller than
pivot_col_degree. Exploit that better? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MatrixEntry Struct \_internalref structoperations__research_1_1glop_1_1MatrixEntry "<a class="el" href="structoperations__research_1_1glop_1_1MatrixEntry.html" title="Holds a triplet (row, col, coefficient).">operations_research::glop::MatrixEntry</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000559 (user): Generalize the design used in this preprocessor to a general
"propagation" framework in order to apply as many reductions as possible in
an efficient manner. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::MatrixNonZeroPattern Member \_internalref classoperations__research_1_1glop_1_1MatrixNonZeroPattern#acba2eb03de47fb8c7cabe51848d04612 "<a class="el" href="classoperations__research_1_1glop_1_1MatrixNonZeroPattern.html#acba2eb03de47fb8c7cabe51848d04612">operations_research::glop::MatrixNonZeroPattern::Update</a>" (RowIndex pivot_row, ColIndex pivot_col, const SparseColumn &amp;column)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000515 (user): Special case if row_non_zero_[pivot_row].size() == 1?
 &lt;p&gt; \anchor _todo000516 (user): Add unit tests before using this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#af8a64136c69a6dfc1b38c22c754cbe65 "<a class="el" href="namespaceoperations__research_1_1glop.html#af8a64136c69a6dfc1b38c22c754cbe65" title="Converts a MPModelProto to a LinearProgram.">operations_research::glop::MPModelProtoToLinearProgram</a>" (const MPModelProto &amp;input, LinearProgram *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000910 (user): clean up loops to use natural range iteration.
 &lt;p&gt; \anchor _todo000911 (user): implement strong proto validation in the
linear solver server and re-use it here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Preprocessor Class \_internalref classoperations__research_1_1glop_1_1Preprocessor "<a class="el" href="classoperations__research_1_1glop_1_1Preprocessor.html">operations_research::glop::Preprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000558 (user): On most preprocessors, calling Run() more than once will not work
as expected. Fix? or document and crash in debug if this happens. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::Preprocessor Member \_internalref classoperations__research_1_1glop_1_1Preprocessor#ab755069ed133ea14ffec0bba56930559 "<a class="el" href="classoperations__research_1_1glop_1_1Preprocessor.html#ab755069ed133ea14ffec0bba56930559">operations_research::glop::Preprocessor::IsSmallerWithinPreprocessorZeroTolerance</a>" (Fractional a, Fractional b) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000564 (user): use an absolute tolerance here to be even more defensive?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::PrimalPrices Class \_internalref classoperations__research_1_1glop_1_1PrimalPrices "<a class="el" href="classoperations__research_1_1glop_1_1PrimalPrices.html">operations_research::glop::PrimalPrices</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000582 (user): Not high priority but should probably be moved to its own file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::PrimalPrices Member \_internalref classoperations__research_1_1glop_1_1PrimalPrices#ab2a479cbb008b8ae4b9ec2d294f79c07 "<a class="el" href="classoperations__research_1_1glop_1_1PrimalPrices.html#ab2a479cbb008b8ae4b9ec2d294f79c07">operations_research::glop::PrimalPrices::PrimalPrices</a>" (absl::BitGenRef random, const VariablesInfo &amp;variables_info, PrimalEdgeNorms *primal_edge_norms, ReducedCosts *reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000584 (user): Switch to a model based API like in CP-SAT. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ProportionalColumnPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ProportionalColumnPreprocessor#afdfcacb0413c8aefe02ff1b9eae0ac68 "<a class="el" href="classoperations__research_1_1glop_1_1ProportionalColumnPreprocessor.html#afdfcacb0413c8aefe02ff1b9eae0ac68">operations_research::glop::ProportionalColumnPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000523 (user): Change FindProportionalColumns for this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ProportionalRowPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ProportionalRowPreprocessor#adddaa59a5bbb8b300795e6f2b9287d3c "<a class="el" href="classoperations__research_1_1glop_1_1ProportionalRowPreprocessor.html#adddaa59a5bbb8b300795e6f2b9287d3c">operations_research::glop::ProportionalRowPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000524 (user): Already return such a mapping from
FindProportionalColumns()? 
 &lt;p&gt; \anchor _todo000525 (user): if the bounds are equal, use the largest row in magnitude?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RandomAccessSparseColumn Member \_internalref classoperations__research_1_1glop_1_1RandomAccessSparseColumn#a59461735207f0d09b1175d3522762f2a "<a class="el" href="classoperations__research_1_1glop_1_1RandomAccessSparseColumn.html#a59461735207f0d09b1175d3522762f2a">operations_research::glop::RandomAccessSparseColumn::PopulateSparseColumn</a>" (SparseColumn *sparse_column) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000922 (user): Do that only if (value != 0.0) ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RankOneUpdateFactorization Member \_internalref classoperations__research_1_1glop_1_1RankOneUpdateFactorization#a3b877b20ffaa0ba743da5c3cb7fa7744 "<a class="el" href="classoperations__research_1_1glop_1_1RankOneUpdateFactorization.html#a3b877b20ffaa0ba743da5c3cb7fa7744">operations_research::glop::RankOneUpdateFactorization::DeterministicTimeSinceLastReset</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000579 (user): This is quite precise. However we overcount a bit, because in
each elementary solves, if the scalar product involved is zero, we skip
some of the operations counted here. Is it worth spending a bit more time
to be more precise here? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RankOneUpdateFactorization Member \_internalref classoperations__research_1_1glop_1_1RankOneUpdateFactorization#af68318310cfb9859c6d98a3e31ccafac "<a class="el" href="classoperations__research_1_1glop_1_1RankOneUpdateFactorization.html#af68318310cfb9859c6d98a3e31ccafac">operations_research::glop::RankOneUpdateFactorization::RankOneUpdateFactorization</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000578 (user): make the 5% a parameter and share it between all the places
that switch between a sparse/dense version. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#a642656ecb53b31a499007ad1d033652a "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#a642656ecb53b31a499007ad1d033652a">operations_research::glop::RevisedSimplex::ComputeDictionary</a>" (const DenseRow *column_scales)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000640 (user): Use row scales as well. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#ada2f59f7b385068f27d172f1f9bff72a "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#ada2f59f7b385068f27d172f1f9bff72a">operations_research::glop::RevisedSimplex::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000595 (user): Count what is missing.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplex Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplex#a4a7567f5c243a6e56d0e48d6ed70e0de "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplex.html#a4a7567f5c243a6e56d0e48d6ed70e0de" title="Uses the given state as a warm-start for the next Solve() call.">operations_research::glop::RevisedSimplex::LoadStateForNextSolve</a>" (const BasisState &amp;state)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000586 (user): Add comparison operator. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplexDictionary Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplexDictionary#a23359894a725f27972fc3a3b6b919db9 "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplexDictionary.html#a23359894a725f27972fc3a3b6b919db9">operations_research::glop::RevisedSimplexDictionary::GetBasicColumnForRow</a>" (RowIndex r) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000644 (user): This function is a better fit for the future custom iterator.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::RevisedSimplexDictionary Member \_internalref classoperations__research_1_1glop_1_1RevisedSimplexDictionary#a79cca8bd83c2bde1691dd782335d767e "<a class="el" href="classoperations__research_1_1glop_1_1RevisedSimplexDictionary.html#a79cca8bd83c2bde1691dd782335d767e">operations_research::glop::RevisedSimplexDictionary::RevisedSimplexDictionary</a>" (const DenseRow *col_scales, RevisedSimplex *revised_simplex)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000643 (user): Overload this to take RevisedSimplex* alone when the
caller would normally pass a nullptr for col_scales so this and
ComputeDictionary can take a const&amp; argument. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop Member \_internalref namespaceoperations__research_1_1glop#a46935a48ea28abfec1c2569fe4aea70f "<a class="el" href="namespaceoperations__research_1_1glop.html#a3d9874910f9632900fe8677463b1c0be">operations_research::glop::ScalarProduct</a>" (const DenseRowOrColumn &amp;u, const SparseColumn &amp;v)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000894 (user): Optimize this more (SSE or unroll with two sums). Another
option is to skip the u[col] that are 0.0 rather than fetching the coeff
and doing a Fractional multiplication. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ScatteredVector Struct \_internalref structoperations__research_1_1glop_1_1ScatteredVector "<a class="el" href="structoperations__research_1_1glop_1_1ScatteredVector.html">operations_research::glop::ScatteredVector&lt; Index, Iterator &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000912 (user): This should be changed from struct to class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ScatteredVector Member \_internalref structoperations__research_1_1glop_1_1ScatteredVector#a1863a881c8165a5b4217f58e70dcbc97 "<a class="el" href="structoperations__research_1_1glop_1_1ScatteredVector.html#a1863a881c8165a5b4217f58e70dcbc97">operations_research::glop::ScatteredVector&lt; Index, Iterator &gt;::kDefaultRatioForUsingDenseIteration</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000913 (user): The constant should depend on what algorithm is used. Clearing
a dense vector is a lot more efficient than doing more complex stuff. Clean
this up by extracting all the currently used constants in one place with
meaningful names. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ShiftVariableBoundsPreprocessor Class \_internalref classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor "<a class="el" href="classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor.html">operations_research::glop::ShiftVariableBoundsPreprocessor</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000562 (user): Having for each variable one of their bounds at zero is a
requirement for the DualizerPreprocessor and for the implied free column in
the ImpliedFreePreprocessor. However, shifting a variable with a domain like
[-1e10, 1e10] may introduce numerical issues. Relax the definition of
a free variable so that only having a domain containing 0.0 is enough? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::ShiftVariableBoundsPreprocessor Member \_internalref classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor#aaa5aa6fd0a5ab4229ab8b8f1ca6f638c "<a class="el" href="classoperations__research_1_1glop_1_1ShiftVariableBoundsPreprocessor.html#aaa5aa6fd0a5ab4229ab8b8f1ca6f638c">operations_research::glop::ShiftVariableBoundsPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000556 (user): This would not be needed, if we always make the bound
of an integer variable integer before applying this preprocessor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SingletonPreprocessor Member \_internalref classoperations__research_1_1glop_1_1SingletonPreprocessor#ad57922a716f7058c76b5f524950b8953 "<a class="el" href="classoperations__research_1_1glop_1_1SingletonPreprocessor.html#ad57922a716f7058c76b5f524950b8953">operations_research::glop::SingletonPreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000545 (user): It seems better to process all the singleton columns with
a cost of zero first. 
 &lt;p&gt; \anchor _todo000546 (user): We should be able to restrict the variable bounds with the
ones of the constraint all the time. However, some situation currently
break the presolve, and it seems hard to fix in a 100% safe way. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseMatrixScaler Member \_internalref classoperations__research_1_1glop_1_1SparseMatrixScaler#abe05dd74a745d50bce6f9b6f14ab0bbc "<a class="el" href="classoperations__research_1_1glop_1_1SparseMatrixScaler.html#abe05dd74a745d50bce6f9b6f14ab0bbc" title="Scales the matrix.">operations_research::glop::SparseMatrixScaler::Scale</a>" (GlopParameters::ScalingAlgorithm method)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000896 (user): Decide precisely for which value of dynamic range we should cut
off geometric scaling. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseRow Class \_internalref classoperations__research_1_1glop_1_1SparseRow "<a class="el" href="classoperations__research_1_1glop_1_1SparseRow.html">operations_research::glop::SparseRow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000925 (user): Use this class where appropriate, i.e. when a SparseColumn is
used to store a row vector (by means of RowIndex to ColIndex casting). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Class \_internalref classoperations__research_1_1glop_1_1SparseVector "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000926 (user): un-expose this type to client; by getting rid of the
index-based APIs and leveraging iterator-based APIs; if possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#a281b1ceefbefc14e321958f139dd8ea3 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a281b1ceefbefc14e321958f139dd8ea3">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::AllEntryIndices</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000931 (user): consider removing this, in favor of the natural range
iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#afb0952c189b9c921d79526b96295a2c8 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afb0952c189b9c921d79526b96295a2c8">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::CleanUp</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000927 (user): Implement in-place sorting of the entries and cleanup. The
current version converts the data to an array-of-pairs representation that
can be sorted easily with std::stable_sort, and the converts the sorted
data back to the struct-of-arrays implementation.
The current version is ~20% slower than the in-place sort on the
array-of-struct representation. It is not visible on GLOP benchmarks, but
it increases peak memory usage by ~8%.
Implementing in-place search will require either implementing a custom
sorting code, or custom iterators that abstract away the internal
representation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#afbae873b1b6a1f33cac11606834b6d0e "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afbae873b1b6a1f33cac11606834b6d0e">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::LookUpCoefficient</a>" (Index index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000930 (user): investigate whether an optimized version of
LookUpCoefficient for "clean" columns yields speed-ups. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::SparseVector Member \_internalref classoperations__research_1_1glop_1_1SparseVector#ac8066cbc5d5b7f8e794677b027cd96a2 "<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac8066cbc5d5b7f8e794677b027cd96a2">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;::MoveTaggedEntriesTo</a>" (const IndexPermutation &amp;index_perm, SparseVector *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000929 (user): In the way we use this function, we know that will not
happen, but it is better to be careful so we can check that properly in
debug mode. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::StrictITISpan Member \_internalref classoperations__research_1_1glop_1_1StrictITISpan#a567f91a908d6143535f19afba8b2066b "<a class="el" href="classoperations__research_1_1glop_1_1StrictITISpan.html#a567f91a908d6143535f19afba8b2066b">operations_research::glop::StrictITISpan&lt; IntType, T &gt;::begin</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000892 (user): This should probably be a strictly typed iterator too, but
&lt;tt&gt;StrongVector::begin()&lt;/tt&gt; already suffers from this problem. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::StrictITIVector Class \_internalref classoperations__research_1_1glop_1_1StrictITIVector "<a class="el" href="classoperations__research_1_1glop_1_1StrictITIVector.html">operations_research::glop::StrictITIVector&lt; IntType, T, Alloc &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000891 (user): This should probably move to StrongVector, but note that this
version is stricter and does not allow any other size types. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#ad5f38322fa7495d265b8a9d165e04661 "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#ad5f38322fa7495d265b8a9d165e04661">operations_research::glop::TriangularMatrix::AddAndNormalizeTriangularColumn</a>" (const SparseColumn &amp;column, RowIndex diagonal_row, Fractional diagonal_coefficient)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000915 (user): use division by a constant using multiplication.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#a73b763db84bea0b037a221f4f0a8b341 "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#a73b763db84bea0b037a221f4f0a8b341">operations_research::glop::TriangularMatrix::ComputeRowsToConsiderInSortedOrder</a>" (RowIndexVector *non_zero_rows) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000918 (user): Investigate the best thresholds.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#adbf1ad02396e91500821d368dcd2ed4a "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#adbf1ad02396e91500821d368dcd2ed4a">operations_research::glop::TriangularMatrix::ComputeRowsToConsiderWithDfs</a>" (RowIndexVector *non_zero_rows) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000917 (user): Investigate the best thresholds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::TriangularMatrix Member \_internalref classoperations__research_1_1glop_1_1TriangularMatrix#accd27fcf09dbc70b99c5ff3420df68ab "<a class="el" href="classoperations__research_1_1glop_1_1TriangularMatrix.html#accd27fcf09dbc70b99c5ff3420df68ab">operations_research::glop::TriangularMatrix::PermutedLowerSparseSolve</a>" (const ColumnView &amp;rhs, const RowPermutation &amp;row_perm, SparseColumn *lower, SparseColumn *upper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000916 (user): The size of lower is exact, so we could be slighly faster here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#a85bc81777e98efdcf8e96566dc7b34b5 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#a85bc81777e98efdcf8e96566dc7b34b5">operations_research::glop::UnconstrainedVariablePreprocessor::RecoverSolution</a>" (ProblemSolution *solution) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000538 (user): In presence of free row, we must move them to 0.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#ab9d32efc837e15a7512083c4e450d459 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#ab9d32efc837e15a7512083c4e450d459">operations_research::glop::UnconstrainedVariablePreprocessor::RemoveZeroCostUnconstrainedVariable</a>" (ColIndex col, Fractional target_bound, LinearProgram *lp)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000532 (user): Here, we may render the row free, so subsequent columns
processed by the columns loop in Run() have more chance to be removed.
However, we need to be more careful during the postsolve() if we do that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UnconstrainedVariablePreprocessor Member \_internalref classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor#a59fa9c1508a94256ea5cb1d79597d170 "<a class="el" href="classoperations__research_1_1glop_1_1UnconstrainedVariablePreprocessor.html#a59fa9c1508a94256ea5cb1d79597d170">operations_research::glop::UnconstrainedVariablePreprocessor::Run</a>" (LinearProgram *lp) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo000533 (user): Expose it as a parameter. We could rename both to
preprocessor_low_tolerance and preprocessor_high_tolerance. 
 &lt;p&gt; \anchor _todo000534 (user): expose this as a parameter? IMO it isn't really needed as we
shouldn't reach this limit except in corner cases. 
 &lt;p&gt; \anchor _todo000535 (user): deal with the more generic case. 
 &lt;p&gt; \anchor _todo000536 (user): this also works if the variable is integer, but we must
choose an integer value during the post-solve. Implement this. 
 &lt;p&gt; \anchor _todo000537 (user): It should probably
work with only small modification, investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a83458aab35755e7f4e0f1a2b38c912c2 "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a83458aab35755e7f4e0f1a2b38c912c2">operations_research::glop::UpdateRow::ComputeUnitRowLeftInverse</a>" (RowIndex leaving_row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000645 (user): Refactorize if the estimated accuracy is above a threshold.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a87bff95c808ef1850684ba48f3bf044f "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a87bff95c808ef1850684ba48f3bf044f">operations_research::glop::UpdateRow::ComputeUpdateRow</a>" (RowIndex leaving_row)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000646 (user): So far we didn't generalize the use of drop tolerances
everywhere in the solver, so we make sure to not modify
unit_row_left_inverse_ that is also used elsewhere. However, because of
that, we will not get the exact same result depending on the algortihm
used below because the ComputeUpdatesColumnWise() will still use these
small entries (no complexity changes). 
 &lt;p&gt; \anchor _todo000647 (user): The impact is not as high as I hopped though, so not too
important. 
 &lt;p&gt; \anchor _todo000648 (user): automate the computation of these constants at run-time? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::UpdateRow Member \_internalref classoperations__research_1_1glop_1_1UpdateRow#a0574601e3d61bdd8bafbd8996c78516b "<a class="el" href="classoperations__research_1_1glop_1_1UpdateRow.html#a0574601e3d61bdd8bafbd8996c78516b">operations_research::glop::UpdateRow::GetCoefficients</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000650 (user): Consider returning a packed vector of coefficient parallel to
GetNonZeroPositions() instead. It should be fast to compute and iteration
later should be quicker. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#ad86973493f57542e9a1e926b2e1f5198 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#ad86973493f57542e9a1e926b2e1f5198">operations_research::glop::VariablesInfo::EndDualPhaseI</a>" (Fractional dual_feasibility_tolerance, DenseRow::ConstView reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000657 (user): When there is a choice, use the previous status that might
have been warm-started ? but then this is not high priority since
warm-starting with a non-dual feasible basis seems unfrequent. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#a2b7789e59bf13941d89cc6accd874fe1 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#a2b7789e59bf13941d89cc6accd874fe1">operations_research::glop::VariablesInfo::TransformToDualPhaseIProblem</a>" (Fractional dual_feasibility_tolerance, DenseRow::ConstView reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000660 (user): Shall we re-add the bound when the variable is moved out of
the base? it is not needed, but might allow for more bound flips? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariablesInfo Member \_internalref classoperations__research_1_1glop_1_1VariablesInfo#aa6ae2139d9427d7dc458a93e2f8b5588 "<a class="el" href="classoperations__research_1_1glop_1_1VariablesInfo.html#aa6ae2139d9427d7dc458a93e2f8b5588">operations_research::glop::VariablesInfo::UpdateToBasicStatus</a>" (ColIndex col)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000653 (user): A bit annoying that we need to test this even if we
don't use the dual. But the cost is minimal. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::glop::VariableValues Member \_internalref classoperations__research_1_1glop_1_1VariableValues#ab0a189867045312e53d3f0c88974e81e "<a class="el" href="classoperations__research_1_1glop_1_1VariableValues.html#ab0a189867045312e53d3f0c88974e81e">operations_research::glop::VariableValues::RecomputeDualPrices</a>" (bool put_more_importance_on_norm=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000651 (user): On some problem like stp3d.mps or pds-100.mps, using different
price like abs(infeasibility) / squared_norms give better result. Some
solver switch according to a criteria like all entry are +1/-1, the column
have no more than 24 non-zero and the average column size is no more than
6! Understand and implement some variant of this? I think the gain is
mainly because of using sparser vectors? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLOPInterface Member \_internalref classoperations__research_1_1GLOPInterface#ac495bd550d8588e457e6998d9af89b53 "<a class="el" href="classoperations__research_1_1GLOPInterface.html#ac495bd550d8588e457e6998d9af89b53">operations_research::GLOPInterface::SetDualTolerance</a>" (double value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000799 (user): Modify parameters_ with the correct value.
The problem is that this is set by default by the wrapper to 1e-7 and for
now we want to use higher default tolerances in Glop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLOPInterface Member \_internalref classoperations__research_1_1GLOPInterface#a5e4f4b2a7b1140077d676a179a349dc3 "<a class="el" href="classoperations__research_1_1GLOPInterface.html#a5e4f4b2a7b1140077d676a179a349dc3">operations_research::GLOPInterface::SetPrimalTolerance</a>" (double value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000798 (user): Modify parameters_ with the correct value.
The problem is that this is set by default by the wrapper to 1e-7 and for
now we want to use higher default tolerances in Glop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a8244072bcb5c3ae1038d9c3f7be4bb8b "<a class="el" href="namespaceoperations__research.html#a8244072bcb5c3ae1038d9c3f7be4bb8b">operations_research::GlopSolveProto</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request, std::atomic&lt; bool &gt; *interrupt_solve, std::function&lt; void(const std::string &amp;)&gt; logging_callback)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000839 (user): We do not support all the parameters here. In particular the
logs before the solver is called will not be appended to the response. Fix
that, and remove code duplication for the logger config. One way should be
to not touch/configure anything if the logger is already created while
calling SolveCpModel() and call a common config function from here or from
inside Solve()? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a09ec441521b625aa6d45620f6b26d781 "<a class="el" href="namespaceoperations__research.html#a09ec441521b625aa6d45620f6b26d781">operations_research::GlopToMPSolverResultStatus</a>" (glop::ProblemStatus s)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000800 (user): We could argue that it is infeasible to find the optimal of
an unbounded problem. So it might just be simpler to completely get rid
of the MpSolver::UNBOUNDED status that seems to never be used
programmatically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GLPKInterface Member \_internalref classoperations__research_1_1GLPKInterface#a2a1e883d9de9f8d855a561dea457c8a4 "<a class="el" href="classoperations__research_1_1GLPKInterface.html#a2a1e883d9de9f8d855a561dea457c8a4">operations_research::GLPKInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000801 (user): support MIP.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#a42c71ed3bac0344dfe9964839806566b "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#a42c71ed3bac0344dfe9964839806566b">operations_research::GraphSymmetryFinder::FindSymmetries</a>" (std::vector&lt; int &gt; *node_equivalence_classes_io, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators, std::vector&lt; int &gt; *factorized_automorphism_group_size, TimeLimit *time_limit=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000011 (user): experiment with, and briefly describe the results of various
algorithms for picking the invariant node:
- random selection
- highest/lowest degree first
- enumerate by part index; or by part size
- etc. 
 &lt;p&gt; \anchor _todo000012 (user): better elect the representative of each equivalence class
in order to reduce the permutation support down the line
&lt;p&gt; \anchor _todo000013 &lt;p&gt; \anchor _todo000014 (user): Don't build a list; but instead use direct, inline iteration
on the representatives in the while() loop below, to benefit from the
incremental merging of the equivalence classes. 
 &lt;p&gt; \anchor _todo000015 (user): better, more complete explanation. 
 &lt;p&gt; \anchor _todo000026 (user): verify the minimality in unit tests.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#af670a8f7f325e3a7431f2723c52ec25d "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#af670a8f7f325e3a7431f2723c52ec25d">operations_research::GraphSymmetryFinder::GraphSymmetryFinder</a>" (const Graph &amp;graph, bool is_undirected)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000025 (user): support multi-arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GraphSymmetryFinder Member \_internalref classoperations__research_1_1GraphSymmetryFinder#a70544105d8f21edcbed63fdd7f6d34ab "<a class="el" href="classoperations__research_1_1GraphSymmetryFinder.html#a70544105d8f21edcbed63fdd7f6d34ab">operations_research::GraphSymmetryFinder::RecursivelyRefinePartitionByAdjacency</a>" (int first_unrefined_part_index, DynamicPartition *partition)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000010 (user): We are really imprecise in our counting, but it is fine. We
just need a way to enforce a deterministic limit on the computation effort. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GreedySolutionGenerator Member \_internalref classoperations__research_1_1GreedySolutionGenerator#a251d404900cb71cc133d8d019fed058b "<a class="el" href="classoperations__research_1_1GreedySolutionGenerator.html#ab50373b232711b27f49e7802c206d581" title="GreedySolutionGenerator.">operations_research::GreedySolutionGenerator::NextSolution</a>" (absl::Span&lt; const SubsetIndex &gt; focus, const SubsetCostVector &amp;costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000039 (user): research more about the best value for Arity. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GreedySolutionGenerator Member \_internalref classoperations__research_1_1GreedySolutionGenerator#ab50373b232711b27f49e7802c206d581 "<a class="el" href="classoperations__research_1_1GreedySolutionGenerator.html#ab50373b232711b27f49e7802c206d581" title="GreedySolutionGenerator.">operations_research::GreedySolutionGenerator::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000051 (user): Add time-outs and exit with a partial solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipConstraintHandlerContext Class \_internalref classoperations__research_1_1GScipConstraintHandlerContext "<a class="el" href="classoperations__research_1_1GScipConstraintHandlerContext.html">operations_research::GScipConstraintHandlerContext</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000775 (user): Add support for branching. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a33589f2b6c357ff092fa13326da0aba8 "<a class="el" href="namespaceoperations__research.html#a33589f2b6c357ff092fa13326da0aba8">operations_research::GScipCreateMaximum</a>" (GScip *gscip, const GScipLinearExpr &amp;resultant, absl::Span&lt; const GScipLinearExpr &gt; terms, absl::string_view name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000779 (user): it may be better to write this in terms of the disjuntive
constraint, we need to support disjunctions in gscip.h to do this.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipEventHandler Member \_internalref classoperations__research_1_1GScipEventHandler#a55733bd35aafd3ae06df04760d7fe05d "<a class="el" href="classoperations__research_1_1GScipEventHandler.html#a55733bd35aafd3ae06df04760d7fe05d">operations_research::GScipEventHandler::CatchEvent</a>" (SCIP_EVENTTYPE event_type)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000777 (user): Support Var and Row events.&lt;p&gt; \anchor _todo000778 (user): Support registering events in the EVENTINITSOL
callback, which would cause them to be trapped only after presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GScipLinearExpr Struct \_internalref structoperations__research_1_1GScipLinearExpr "<a class="el" href="structoperations__research_1_1GScipLinearExpr.html">operations_research::GScipLinearExpr</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000781 (user): delete this type and the methods below, use a generic version
templated on the variable type that supports operator overloads. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GuidedTabuSearch Member \_internalref classoperations__research_1_1GuidedTabuSearch#a130652dacbe5fae193481444dcc4354f "<a class="el" href="classoperations__research_1_1GuidedTabuSearch.html#ae9e079ba191daebeff738fa832239443">operations_research::GuidedTabuSearch::NextSolution</a>" (absl::Span&lt; const SubsetIndex &gt; focus, int num_iterations)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000043 (user): make the cost computation incremental.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GuidedTabuSearch Member \_internalref classoperations__research_1_1GuidedTabuSearch#a276460a461462ece00e2b69a4ba0cc75 "<a class="el" href="classoperations__research_1_1GuidedTabuSearch.html#a276460a461462ece00e2b69a4ba0cc75">operations_research::GuidedTabuSearch::SetLagrangianFactor</a>" (double factor)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000055 (user): re-introduce this is the code. It was used to favor
subsets with the same marginal costs but that would cover more elements.
But first, see if it makes sense to compute it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a47ea0f16d10d18c841917b6ab3695094 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a47ea0f16d10d18c841917b6ab3695094" title="Clears a constraint from all its terms.">operations_research::GurobiInterface::ClearConstraint</a>" (MPConstraint *constraint) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000806 (user): this is difficult to make incremental, like
SetConstraintBounds(), because of the auxiliary Gurobi variables that
range constraints introduce. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a80f01ad50450397a74e29c3db67ff69c "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a80f01ad50450397a74e29c3db67ff69c">operations_research::GurobiInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000809 (user): Not yet working.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#abdc377748278a3c5c35a847bfd146a31 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#abdc377748278a3c5c35a847bfd146a31" title="Iterates through the solutions in Gurobi&#39;s solution pool.">operations_research::GurobiInterface::NextSolution</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000808 (user): This reset may not be necessary, investigate.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a7862478121ae29647bf0a12ff9ef5ed7 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a7862478121ae29647bf0a12ff9ef5ed7" title="---— Model modifications and extraction --—">operations_research::GurobiInterface::Reset</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000803 - b/328604189: Fix logging issue upstream, switch to a different API
for copying parameters, or avoid calling Reset() in more places. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a3151b55e2c525025b89ce0c01cdf52be "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a3151b55e2c525025b89ce0c01cdf52be" title="Changes a coefficient in a constraint.">operations_research::GurobiInterface::SetCoefficient</a>" (MPConstraint *constraint, const MPVariable *variable, double new_value, double old_value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000805 (user): investigate if this has bad performance.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a937c9e7503e0bc746f8fa40c7591f16a "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a937c9e7503e0bc746f8fa40c7591f16a" title="Modify bounds of an extracted variable.">operations_research::GurobiInterface::SetConstraintBounds</a>" (int row_index, double lb, double ub) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000804 (user): this is nontrivial to make incremental:
1. Make sure it is a linear constraint (not an indicator or indicator
   range constraint).
2. Check if the sense of the constraint changes. If it was previously a
   range constraint, we can do nothing, and if it becomes a range
   constraint, we can do nothing. We could support range constraints if
   we tracked the auxiliary variable that is added with range
   constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::GurobiInterface Member \_internalref classoperations__research_1_1GurobiInterface#a3fdaaef4033cbc2f6e0ef07ade784682 "<a class="el" href="classoperations__research_1_1GurobiInterface.html#a3fdaaef4033cbc2f6e0ef07ade784682">operations_research::GurobiInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000807 (user): We could introduce our own "infeasible or unbounded" status. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HamiltonianPathSolver Member \_internalref classoperations__research_1_1HamiltonianPathSolver#ab7380d5367176d7d567876433d1dd918 "<a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html#ab7380d5367176d7d567876433d1dd918">operations_research::HamiltonianPathSolver&lt; CostType, CostFunction &gt;::Integer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000707 (user): remove this limitation by using pruning techniques. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aee1401375b23909949cce272a3b787db "<a class="el" href="namespaceoperations__research.html#aee1401375b23909949cce272a3b787db">operations_research::Hash1</a>" (uint64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000168 (user): use murmurhash. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HighsInterface Member \_internalref classoperations__research_1_1HighsInterface#aa0445eec4920c34b74fb03b837ff15b0 "<a class="el" href="classoperations__research_1_1HighsInterface.html#aa0445eec4920c34b74fb03b837ff15b0" title="Returns the basis status of a constraint.">operations_research::HighsInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000812 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HighsInterface Member \_internalref classoperations__research_1_1HighsInterface#a0b4fdd0d963276c0deca473d6b4b36a5 "<a class="el" href="classoperations__research_1_1HighsInterface.html#a0b4fdd0d963276c0deca473d6b4b36a5" title="Returns the basis status of a row.">operations_research::HighsInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000811 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::HighsInterface Member \_internalref classoperations__research_1_1HighsInterface#a9423aab732ca4e92e3640bd534e92023 "<a class="el" href="classoperations__research_1_1HighsInterface.html#a9423aab732ca4e92e3640bd534e92023">operations_research::HighsInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000813 (user): Consider returning the SolveLog here, as it could be essential
for interpreting the PDLP solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a977d36998909629c22521663e46a33ce "<a class="el" href="namespaceoperations__research.html#a977d36998909629c22521663e46a33ce" title="Solve the input MIP model with the HIGHS solver.">operations_research::HighsSolveProto</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000841 (user): report feasible status.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::InsertionSequenceContainer Member \_internalref classoperations__research_1_1InsertionSequenceContainer#a2d8c1748584bee64a6e1963605863c6b "<a class="el" href="classoperations__research_1_1InsertionSequenceContainer.html#a2d8c1748584bee64a6e1963605863c6b">operations_research::InsertionSequenceContainer::RemoveIf</a>" (const std::function&lt; bool(const InsertionSequence &amp;)&gt; &amp;p)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000427 (user): Benchmark this against std::swap().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::InsertionSequenceContainer Member \_internalref classoperations__research_1_1InsertionSequenceContainer#a7d4b83eb22546e3c1079283001dfe0d3 "<a class="el" href="classoperations__research_1_1InsertionSequenceContainer.html#a7d4b83eb22546e3c1079283001dfe0d3">operations_research::InsertionSequenceContainer::Sort</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000428 (user): benchmark this against other ways to get insertion
sequence in order, for instance sorting by index, separating {cost, index},
making a heap. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntegerPriorityQueue Member \_internalref classoperations__research_1_1IntegerPriorityQueue#a660816e2b5398fc18dd92a58327f630c "<a class="el" href="classoperations__research_1_1IntegerPriorityQueue.html#a660816e2b5398fc18dd92a58327f630c">operations_research::IntegerPriorityQueue&lt; Element, Compare &gt;::Clear</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002550 (user): we could make this sparse if it is needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::internal Namespace \_internalref namespaceoperations__research_1_1internal "<a class="el" href="namespaceoperations__research_1_1internal.html" title="End of the interface. Below is the implementation.">operations_research::internal</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000034 (user): Support arbitrary types with an int() or other numerical getter.
 &lt;p&gt; &lt;p&gt;(user): Support the user providing already-allocated memory buffers
             for the radix counts and/or for the temporary vector&lt;T&gt; copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::@344144027361276354137162267101132040275076124110::internal Namespace \_internalref namespaceoperations__research_1_1_0d344144027361276354137162267101132040275076124110_1_1internal "<a class="el" href="namespaceoperations__research_1_1internal.html" title="End of the interface. Below is the implementation.">operations_research::internal</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000046 (user): Make it an independent library.
- add support for decreasing counting sort,
- make payloads optional,
- support floats and doubles,
- improve performance.
- use vectorized code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::internal Namespace \_internalref namespaceoperations__research_1_1internal "<a class="el" href="namespaceoperations__research_1_1internal.html" title="End of the interface. Below is the implementation.">operations_research::internal</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000714 (user): introduce an enum to choose the algorithm. It's useless as
long as this file only provides Yen. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntersectingSubsetsIterator Class \_internalref classoperations__research_1_1IntersectingSubsetsIterator "<a class="el" href="classoperations__research_1_1IntersectingSubsetsIterator.html">operations_research::IntersectingSubsetsIterator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000072 (user): Add the possibility for range-for loops. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVar Member \_internalref classoperations__research_1_1IntVar#af3c6b509b9279db09301192b57dfb3cd "<a class="el" href="classoperations__research_1_1IntVar.html#af3c6b509b9279db09301192b57dfb3cd" title="This method remove the values from the domain of the variable.">operations_research::IntVar::RemoveValues</a>" (const std::vector&lt; int64_t &gt; &amp;values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000204 (user): Check and maybe inline this code.
 &lt;p&gt; \anchor _todo000205 (user) : Sort values! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVar Member \_internalref classoperations__research_1_1IntVar#a3b3b2ee0dc78430a3008c0894531196f "<a class="el" href="classoperations__research_1_1IntVar.html#a3b3b2ee0dc78430a3008c0894531196f" title="This method intersects the current domain with the values in the array.">operations_research::IntVar::SetValues</a>" (const std::vector&lt; int64_t &gt; &amp;values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000206 (user): use a clean and safe SortedUniqueCopy() class
that uses a global, static shared (and locked) storage.
&lt;p&gt; \anchor _todo000207 &lt;p&gt; \anchor _todo000208 (user): [optional] consider porting
STLSortAndRemoveDuplicates from ortools/base/stl_util.h to the
existing base/stl_util.h and using it here.
&lt;p&gt; \anchor _todo000209 &lt;p&gt; \anchor _todo000210 (user): We could filter out values not in the var. 
 &lt;p&gt; \anchor _todo000211 (user) : We could find the first position &gt;= vmin by dichotomy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVarFilteredDecisionBuilder Class \_internalref classoperations__research_1_1IntVarFilteredDecisionBuilder "<a class="el" href="classoperations__research_1_1IntVarFilteredDecisionBuilder.html">operations_research::IntVarFilteredDecisionBuilder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000425 (user): Eventually move this to the core CP solver library
when the code is mature enough. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::IntVarLocalSearchOperator Member \_internalref classoperations__research_1_1IntVarLocalSearchOperator#ac8bc688def85b27b6aa66e1f099050a4 "<a class="el" href="classoperations__research_1_1IntVarLocalSearchOperator.html#ac8bc688def85b27b6aa66e1f099050a4">operations_research::IntVarLocalSearchOperator::MakeOneNeighbor</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000172 (user): make it pure virtual, implies porting all apps overriding
MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator. 
 &lt;p&gt; \anchor _todo000233 (user): Make this a pure virtual.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackAssignment Struct \_internalref structoperations__research_1_1KnapsackAssignment "<a class="el" href="structoperations__research_1_1KnapsackAssignment.html">operations_research::KnapsackAssignment</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000031 (user): Add a new propagator class for conflict constraint.
 &lt;p&gt; &lt;p&gt;(user): Add a new propagator class used as a guide when the problem has
several dimensions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackBruteForceSolver Member \_internalref classoperations__research_1_1KnapsackBruteForceSolver#a0b4c315873262155800b2645fdab0535 "<a class="el" href="classoperations__research_1_1KnapsackBruteForceSolver.html#a0b4c315873262155800b2645fdab0535" title="Initializes the solver and enters the problem to be solved.">operations_research::KnapsackBruteForceSolver::Init</a>" (const std::vector&lt; int64_t &gt; &amp;profits, const std::vector&lt; std::vector&lt; int64_t &gt; &gt; &amp;weights, const std::vector&lt; int64_t &gt; &amp;capacities) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000030 (user): Implement multi-dimensional brute force solver.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackCapacityPropagator Member \_internalref classoperations__research_1_1KnapsackCapacityPropagator#af1d7d1e175e652c64962af490ab42247 "<a class="el" href="classoperations__research_1_1KnapsackCapacityPropagator.html#af1d7d1e175e652c64962af490ab42247">operations_research::KnapsackCapacityPropagator::ComputeProfitBounds</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000029 (user): Make it more incremental, by saving the break item in a
search node for instance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackGenericSolver Class \_internalref classoperations__research_1_1KnapsackGenericSolver "<a class="el" href="classoperations__research_1_1KnapsackGenericSolver.html">operations_research::KnapsackGenericSolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000032 (user): In the case of a multi-dimensional knapsack problem, implement
an aggregated propagator to combine all dimensions and give a better guide
to select the next item (see, for instance, Dobson's aggregated efficiency). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#ac5b423c249b7d295b22cd367d60a915a "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#ac5b423c249b7d295b22cd367d60a915a" title="Returns the basis status of a constraint.">operations_research::KnapsackInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000817 (user): set properly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#a91cb6e2a4e0c037e5ce12887e13d5a11 "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#a91cb6e2a4e0c037e5ce12887e13d5a11" title="Returns the basis status of a row.">operations_research::KnapsackInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000816 (user): set properly.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KnapsackInterface Member \_internalref classoperations__research_1_1KnapsackInterface#ad8e2065e33ed1870e473b6f296a93cba "<a class="el" href="classoperations__research_1_1KnapsackInterface.html#ad8e2065e33ed1870e473b6f296a93cba" title="--— Solve --—">operations_research::KnapsackInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000815 (user): Refine Analysis of the model to choose better solvers.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KShortestPaths Member \_internalref structoperations__research_1_1KShortestPaths#ae7f9e8331733fe236c6de52e9b1f5a96 "<a class="el" href="structoperations__research_1_1KShortestPaths.html#ae7f9e8331733fe236c6de52e9b1f5a96">operations_research::KShortestPaths&lt; GraphType &gt;::paths</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000718 (user): what about vectors of arcs? That might be faster
(potentially, add a function to transform it into a vector of nodes if the
user really needs it). It would also have the nice benefit of removing the
need for &lt;tt&gt;distances&lt;/tt&gt; (compute it on the fly), with a reference to the graph
and the costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::KShortestPathsOnDagWrapper Member \_internalref classoperations__research_1_1KShortestPathsOnDagWrapper#a2ceb0df92d0ba23cb3496ef96475dfa3 "<a class="el" href="classoperations__research_1_1KShortestPathsOnDagWrapper.html#a2ceb0df92d0ba23cb3496ef96475dfa3">operations_research::KShortestPathsOnDagWrapper&lt; GraphType &gt;::KShortestPathsOnDagWrapper</a>" (const GraphType *graph, const std::vector&lt; double &gt; *arc_lengths, absl::Span&lt; const NodeIndex &gt; topological_order, int path_count)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000671 (b/332475713): Optimize if reverse graph is already provided in
&lt;tt&gt;GraphType&lt;/tt&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LatticeMemoryManager Member \_internalref classoperations__research_1_1LatticeMemoryManager#af1eb6109d2fbc58a4f9709fc12472100 "<a class="el" href="classoperations__research_1_1LatticeMemoryManager.html#af1eb6109d2fbc58a4f9709fc12472100">operations_research::LatticeMemoryManager&lt; Set, CostType &gt;::BaseOffset</a>" (int card, Set s) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000701 (user): Evaluate the interest of the above.
There are 'card' f(set, j) to store. That is why we need to multiply
local_offset by card before adding it to the corresponding base_offset_. 
 &lt;p&gt; \anchor _todo000706 (user): Investigate how to compute BaseOffset(card - 1, s \ { n })
from BaseOffset(card, n) to speed up the DP iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LazyElementDegreeSolutionGenerator Member \_internalref classoperations__research_1_1LazyElementDegreeSolutionGenerator#a31c4a8628b9c14e1a6cdc6246a50d867 "<a class="el" href="classoperations__research_1_1LazyElementDegreeSolutionGenerator.html#a31c4a8628b9c14e1a6cdc6246a50d867">operations_research::LazyElementDegreeSolutionGenerator::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000053 (user): Add time-outs and exit with a partial solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LightPairRelocateOperator Class \_internalref classoperations__research_1_1LightPairRelocateOperator "<a class="el" href="classoperations__research_1_1LightPairRelocateOperator.html">operations_research::LightPairRelocateOperator&lt; ignore_path_vars &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000389 (user): Add a version which inserts the first node before the other
pair's first node; there are many redundant neighbors if done blindly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LightPairRelocateOperator Member \_internalref classoperations__research_1_1LightPairRelocateOperator#af4529ce2124290360fd0eb7aeddc4223 "<a class="el" href="classoperations__research_1_1LightPairRelocateOperator.html#af4529ce2124290360fd0eb7aeddc4223">operations_research::LightPairRelocateOperator&lt; ignore_path_vars &gt;::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000380 (user): extend to relocating before the start of sub-tours (when
all pairs have been matched). 
 &lt;p&gt; \anchor _todo000381 (user): Add support for incoming neighbors.
 &lt;p&gt; \anchor _todo000382 (user): Add support for lifo for neighbor-based move.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LinearExpr Member \_internalref classoperations__research_1_1LinearExpr#ac387e7f248b39ad0c52ad355fa646696 "<a class="el" href="classoperations__research_1_1LinearExpr.html#ac387e7f248b39ad0c52ad355fa646696">operations_research::LinearExpr::ToString</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000818 (user): support optionally cropping long strings.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalCheapestInsertionFilteredHeuristic Member \_internalref classoperations__research_1_1LocalCheapestInsertionFilteredHeuristic#a9fcbecded3ce956671e3e598df052891 "<a class="el" href="classoperations__research_1_1LocalCheapestInsertionFilteredHeuristic.html#a9fcbecded3ce956671e3e598df052891" title="Takes ownership of evaluator.">operations_research::LocalCheapestInsertionFilteredHeuristic::LocalCheapestInsertionFilteredHeuristic</a>" (RoutingModel *model, std::function&lt; bool()&gt; stop_search, std::function&lt; int64_t(int64_t, int64_t, int64_t)&gt; evaluator, RoutingSearchParameters::PairInsertionStrategy pair_insertion_strategy, std::vector&lt; RoutingSearchParameters::InsertionSortingProperty &gt; insertion_sorting_properties, LocalSearchFilterManager *filter_manager, bool use_first_solution_hint, BinCapacities *bin_capacities=nullptr, std::function&lt; bool(const std::vector&lt; RoutingModel::VariableValuePair &gt; &amp;, std::vector&lt; RoutingModel::VariableValuePair &gt; *)&gt; optimize_on_insertion=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000408 (user): Add support for penalty costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalDimensionCumulOptimizer Member \_internalref classoperations__research_1_1LocalDimensionCumulOptimizer#a30f6536c9b12eb7d0c6bcba75c50b158 "<a class="el" href="classoperations__research_1_1LocalDimensionCumulOptimizer.html#a30f6536c9b12eb7d0c6bcba75c50b158" title="LocalDimensionCumulOptimizer.">operations_research::LocalDimensionCumulOptimizer::LocalDimensionCumulOptimizer</a>" (const RoutingDimension *dimension, RoutingSearchParameters::SchedulingSolver solver_type)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000362 (user): Instead of passing false, detect if the relaxation
will always violate the MIPL constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearch Member \_internalref classoperations__research_1_1LocalSearch#a60a6c0d04aae31557a3f80a43e578c1d "<a class="el" href="classoperations__research_1_1LocalSearch.html#a5e713c214f20050381b848770f5fc7a4">operations_research::LocalSearch::LocalSearch</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IntVar *objective, SolutionPool *pool, DecisionBuilder *first_solution, LocalSearchOperator *ls_operator, DecisionBuilder *sub_decision_builder, RegularLimit *limit, LocalSearchFilterManager *filter_manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000255 (user): find a way to not have to pass vars here: redundant with
variables in operators 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearch Member \_internalref classoperations__research_1_1LocalSearch#aad8272c1b2ace102d8ee023e3dbbc92e "<a class="el" href="classoperations__research_1_1LocalSearch.html#aad8272c1b2ace102d8ee023e3dbbc92e">operations_research::LocalSearch::Next</a>" (Solver *solver) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000248 (user): abstract this from the local search part
 &lt;p&gt; &lt;p&gt;(user): handle the case where the tree depth is not enough to hold
               all solutions. 
 &lt;p&gt; \anchor _todo000249 (user): Find a way to make this balancing invisible to the
user (no increase in branch or fail counts for instance). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchFilter Member \_internalref classoperations__research_1_1LocalSearchFilter#a7ba0d3a0fab70da68c44fcc603b29bc9 "<a class="el" href="classoperations__research_1_1LocalSearchFilter.html#a7ba0d3a0fab70da68c44fcc603b29bc9">operations_research::LocalSearchFilter::Accept</a>" (const Assignment *delta, const Assignment *deltadelta, int64_t objective_min, int64_t objective_max)=0&lt;/dt&gt;&lt;dd&gt; \anchor _todo000178 (user): Remove arguments when there are no more need for those. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchFilterManager Member \_internalref classoperations__research_1_1LocalSearchFilterManager#af14f814b5f03c25c7a5c34ea2e850931 "<a class="el" href="classoperations__research_1_1LocalSearchFilterManager.html#af14f814b5f03c25c7a5c34ea2e850931">operations_research::LocalSearchFilterManager::Accept</a>" (LocalSearchMonitor *monitor, const Assignment *delta, const Assignment *deltadelta, int64_t objective_min, int64_t objective_max)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000239 (user): the behaviour of Accept relies on the initial order of
filters having at most one filter with negative objective values,
this could be fixed by having filters return their general bounds. 
 &lt;p&gt; \anchor _todo000240 (user): handle objective min.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchMonitor Member \_internalref classoperations__research_1_1LocalSearchMonitor#a0c4974eabff96027f2732bd11aa6acb8 "<a class="el" href="classoperations__research_1_1LocalSearchMonitor.html#a0c4974eabff96027f2732bd11aa6acb8" title="-------— Local Search Monitor --------—">operations_research::LocalSearchMonitor::LocalSearchMonitor</a>" (Solver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000179 (user): Add monitoring of local search filters.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchOperator Class \_internalref classoperations__research_1_1LocalSearchOperator "<a class="el" href="classoperations__research_1_1LocalSearchOperator.html">operations_research::LocalSearchOperator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000169 (user): rename Start to Synchronize ?
 &lt;p&gt; &lt;p&gt;(user): decouple the iterating from the defining of a neighbor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchProfiler Member \_internalref classoperations__research_1_1LocalSearchProfiler#a584c18d991ab2bae4bc0f1e707fad3a8 "<a class="el" href="classoperations__research_1_1LocalSearchProfiler.html#a584c18d991ab2bae4bc0f1e707fad3a8">operations_research::LocalSearchProfiler::PrintOverview</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000254 (user): Add make_next_neighbor_duration_seconds and
accept_neighbor_duration_seconds to stats. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocalSearchState Member \_internalref classoperations__research_1_1LocalSearchState#ab21fa79fdab637a71137bfb392c3bc42 "<a class="el" href="classoperations__research_1_1LocalSearchState.html#ab21fa79fdab637a71137bfb392c3bc42">operations_research::LocalSearchState::Commit</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000238 (user): When the class has more users, find a threshold ratio of
saved/total domains under which a sparse clear would be more efficient
for both Commit() and Revert(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::LocationContainer Member \_internalref classoperations__research_1_1LocationContainer#ad936b94007fe596c6ac61668da043262 "<a class="el" href="classoperations__research_1_1LocationContainer.html#ad936b94007fe596c6ac61668da043262">operations_research::LocationContainer::SameLocationFromIndex</a>" (int64_t node1, int64_t node2) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001097 (user): Fetch proper indices from routing model. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakeActiveOperator Member \_internalref classoperations__research_1_1MakeActiveOperator#a19615a0ecfca6d07afc862e5b0f4187c "<a class="el" href="classoperations__research_1_1MakeActiveOperator.html#a19615a0ecfca6d07afc862e5b0f4187c">operations_research::MakeActiveOperator&lt; ignore_path_vars &gt;::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000235 (user): Add support for neighbors of inactive nodes; would require
having a version without base nodes (probably not a PathOperator). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakePairActiveOperator Class \_internalref classoperations__research_1_1MakePairActiveOperator "<a class="el" href="classoperations__research_1_1MakePairActiveOperator.html">operations_research::MakePairActiveOperator&lt; ignore_path_vars &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000388 (user): Add option to prune neighbors where the order of node pairs
               is violated (ie precedence between pickup and delivery nodes).
 &lt;p&gt; &lt;p&gt;(user): Move this to local_search.cc if it's generic enough.
 &lt;p&gt; &lt;p&gt;(user): Detect pairs automatically by parsing the constraint model;
               we could then get rid of the pair API in the RoutingModel
               class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakeRelocateNeighborsOperator Class \_internalref classoperations__research_1_1MakeRelocateNeighborsOperator "<a class="el" href="classoperations__research_1_1MakeRelocateNeighborsOperator.html">operations_research::MakeRelocateNeighborsOperator&lt; ignore_path_vars &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000386 (user): Consider merging with standard Relocate in local_search.cc. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MakeRelocateNeighborsOperator Member \_internalref classoperations__research_1_1MakeRelocateNeighborsOperator#a01c340a6a5f90e84d89a6b1eef4bc7bd "<a class="el" href="classoperations__research_1_1MakeRelocateNeighborsOperator.html#a01c340a6a5f90e84d89a6b1eef4bc7bd">operations_research::MakeRelocateNeighborsOperator&lt; ignore_path_vars &gt;::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000377 (user): Add a parameter to either return false or break here,
depending if we want to permutate nodes within the same chain. 
 &lt;p&gt; \anchor _todo000378 (user): Handle incoming neighbors by going backwards on the
chain. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Namespace \_internalref namespaceoperations__research_1_1math__opt "<a class="el" href="namespaceoperations__research_1_1math__opt.html" title="An object oriented wrapper for quadratic constraints in ModelStorage.">operations_research::math_opt</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000991 (b/178702980): this should not be needed
IWYU pragma: no_include &lt;type_traits&gt; 
 &lt;p&gt; \anchor _todo001028 (b/272767311): initial basis, more precise returned basis.
 * Starting solution
 *  &lt;p&gt; &lt;p&gt;(b/271104776): Returning rays 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ab2cf3d362a53b88af5478096e7b70534 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ab2cf3d362a53b88af5478096e7b70534" title="The entire model is an IIS.">operations_research::math_opt::≤</a>" (variable bounds) TEST_P(InfeasibleSubsystemTest&lt;/dt&gt;&lt;dd&gt; \anchor _todo000977 (b/227217735): Test ranged quadratic constraints when supported.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ae492beecf00c5bcfab49f0eb64bd5467 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ae492beecf00c5bcfab49f0eb64bd5467">operations_research::math_opt::ApplyAllFilters</a>" (const ModelSolveParametersProto &amp;model_solve_params, SolutionProto &amp;solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000941 (b/261603235): this function is not very efficient, decide if this
matters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::BaseSolver Class \_internalref classoperations__research_1_1math__opt_1_1BaseSolver "<a class="el" href="classoperations__research_1_1math__opt_1_1BaseSolver.html">operations_research::math_opt::BaseSolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000937 : b/350984134 - Rename &lt;tt&gt;Solver&lt;/tt&gt; into &lt;tt&gt;InProcessSolver&lt;/tt&gt; and then rename
&lt;tt&gt;BaseSolver&lt;/tt&gt; into &lt;tt&gt;Solver&lt;/tt&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#abd2e26542d0c64cb9bdb653e943cd892 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#abd2e26542d0c64cb9bdb653e943cd892">operations_research::math_opt::CheckIdsSubset</a>" (absl::Span&lt; const int64_t &gt; ids, const IdNameBiMap &amp;universe, std::optional&lt; int64_t &gt; upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001066 (b/232526223): try merge this with the CheckIdsSubset overload below, or
at least have one call the other. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a614c1a306a138f7593f4ae84dbf034c9 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a614c1a306a138f7593f4ae84dbf034c9">operations_research::math_opt::FeasibleTerminationProto</a>" (const bool is_maximize, const LimitProto limit, const double primal_objective, const std::optional&lt; double &gt; optional_dual_objective, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000944 (b/290359402): Consider improving to require a finite dual bound when
dual feasible solutions are returned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ad41bc1edd376b9ab7c3182d9a7b35e87 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ad41bc1edd376b9ab7c3182d9a7b35e87">operations_research::math_opt::FilterSparseVector</a>" (const SparseDoubleVectorProto &amp;input, const SparseVectorFilterProto &amp;filter)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000940 (b/261603235): this function is not very efficient, decide if this
matters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a635b90e2d284268536fc4bd2a4ce2ac4 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a635b90e2d284268536fc4bd2a4ce2ac4">operations_research::math_opt::GetObjectiveBounds</a>" (const SolveResultProto &amp;solve_result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000938 (b/290091715): Remove once solve_stats.best_primal/dual_bound is removed
and we know termination.objective_bounds will always be present. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a5e3e49ddac3e4cb09a02f02e4fe83019 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a5e3e49ddac3e4cb09a02f02e4fe83019">operations_research::math_opt::GetProblemStatus</a>" (const SolveResultProto &amp;solve_result)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000939 (b/290091715): Remove once solve_stats.problem_status is removed and we
know termination.problem_status will always be present. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GlpkSolver Member \_internalref classoperations__research_1_1math__opt_1_1GlpkSolver#a862eb62a5ed02916d9ae0ddabe46ac08 "<a class="el" href="classoperations__research_1_1math__opt_1_1GlpkSolver.html#a862eb62a5ed02916d9ae0ddabe46ac08">operations_research::math_opt::GlpkSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000997 (b/187027049): glp_intopt with presolve off requires an optional
solution of the relaxed problem. Here we simply always enable pre-solve
but we should support disabling the presolve and call glp_simplex() in
that case. 
 &lt;p&gt; \anchor _todo000998 (b/259557110): the emptiness is tested by glp_interior() &lt;em&gt;after&lt;/em&gt;
some pre-processing (including removing fixed variables). The current
IsEmpty() is thus not good enough to deal with all cases. 
 &lt;p&gt; \anchor _todo000999 (b/187027049): add solver specific parameters for
glp_iptcp.ord_alg. 
 &lt;p&gt; \anchor _todo001000 (b/187027049): add option to use glp_exact().
 &lt;p&gt; \anchor _todo001001 (b/187027049): compute the dual value when the dual is feasible (or
problem optimal for interior point) based on the bounds and the dual values
for LPs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GScipSolver Member \_internalref classoperations__research_1_1math__opt_1_1GScipSolver#a91f57e875b852057eeaf6eeb837d1613 "<a class="el" href="classoperations__research_1_1math__opt_1_1GScipSolver.html#a91f57e875b852057eeaf6eeb837d1613">operations_research::math_opt::GScipSolver::Update</a>" (const ModelUpdateProto &amp;model_update) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001009 (b/215722113): maybe we could use SCIPaddCoefLinear() for sub-matrix 1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GurobiSolver Member \_internalref classoperations__research_1_1math__opt_1_1GurobiSolver#af25c8f69567b57e9e04f737af5937e84 "<a class="el" href="classoperations__research_1_1math__opt_1_1GurobiSolver.html#af25c8f69567b57e9e04f737af5937e84">operations_research::math_opt::GurobiSolver::ComputeInfeasibleSubsystem</a>" (const SolveParametersProto &amp;parameters, MessageCallback message_cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001025 (b/277339044): Remove code duplication with GurobiSolver::Solve().
 &lt;p&gt; \anchor _todo001026 (b/277246682): ensure that resetting parameters does not degrade
incrementalism performance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::GurobiSolver Member \_internalref classoperations__research_1_1math__opt_1_1GurobiSolver#aa521c1122a7faae79b63abea4a039cd2 "<a class="el" href="classoperations__research_1_1math__opt_1_1GurobiSolver.html#aa521c1122a7faae79b63abea4a039cd2">operations_research::math_opt::GurobiSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001024 (b/277246682): ensure that resetting parameters does not degrade
incrementalism performance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::HighsSolver Member \_internalref classoperations__research_1_1math__opt_1_1HighsSolver#a2ae5ff0de74ce55a8dc383175021d11b "<a class="el" href="classoperations__research_1_1math__opt_1_1HighsSolver.html#a2ae5ff0de74ce55a8dc383175021d11b">operations_research::math_opt::HighsSolver::New</a>" (const ModelProto &amp;model, const InitArgs &amp;init_args)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001031 (b/271595607): once HiGHS is updated, check if the unrounded bounds
cross instead. 
 &lt;p&gt; \anchor _todo001032 (b/271595607): once HiGHS is updated, pass the original bound, not
the rounded bound. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::HighsSolver Member \_internalref classoperations__research_1_1math__opt_1_1HighsSolver#a379b28def41c16cfc6c404dac890ddbe "<a class="el" href="classoperations__research_1_1math__opt_1_1HighsSolver.html#a379b28def41c16cfc6c404dac890ddbe">operations_research::math_opt::HighsSolver::Solve</a>" (const SolveParametersProto &amp;parameters, const ModelSolveParametersProto &amp;model_parameters, MessageCallback message_cb, const CallbackRegistrationProto &amp;callback_registration, Callback cb, const SolveInterrupter *interrupter) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001033 (b/271595607): delete this code once we upgrade HiGHS, if HiGHS does
return a proper infeasibility status for models with empty integer bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal Member \_internalref namespaceoperations__research_1_1math__opt_1_1internal#aa5b5865fba481a062135fc78e632b85c "<a class="el" href="namespaceoperations__research_1_1math__opt_1_1internal.html#aa5b5865fba481a062135fc78e632b85c">operations_research::math_opt::internal::CheckIdsRangeAndStrictlyIncreasing2</a>" (absl::Span&lt; const int64_t &gt; ids)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000946 (b/232526223): this is an exact copy of
CheckIdsRangeAndStrictlyIncreasing from ids_validator.h, find a way to share
the code.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal::IncrementalSolverImpl Member \_internalref classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl#a378d81b16d667bc8b2f534c6549000b2 "<a class="el" href="classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl.html#a378d81b16d667bc8b2f534c6549000b2">operations_research::math_opt::internal::IncrementalSolverImpl::ComputeInfeasibleSubsystem</a>" (const ComputeInfeasibleSubsystemArguments &amp;arguments) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000960 : b/260337466 - Add permanent errors and concurrency protection.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal::IncrementalSolverImpl Member \_internalref classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl#ae411aebc76f692bbca9c93ed22ab25d7 "<a class="el" href="classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl.html#ae411aebc76f692bbca9c93ed22ab25d7">operations_research::math_opt::internal::IncrementalSolverImpl::ComputeInfeasibleSubsystemWithoutUpdate</a>" (const ComputeInfeasibleSubsystemArguments &amp;arguments) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000963 : b/260337466 - Add permanent errors and concurrency protection.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal::IncrementalSolverImpl Member \_internalref classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl#a07dcb34f0dd810e54bb83f85bb60b58c "<a class="el" href="classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl.html#a07dcb34f0dd810e54bb83f85bb60b58c">operations_research::math_opt::internal::IncrementalSolverImpl::Solve</a>" (const SolveArguments &amp;arguments) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000959 : b/260337466 - Add permanent errors and concurrency protection.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal::IncrementalSolverImpl Member \_internalref classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl#a54daa57285b6a528ca4a7ee8175a254a "<a class="el" href="classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl.html#a54daa57285b6a528ca4a7ee8175a254a">operations_research::math_opt::internal::IncrementalSolverImpl::SolveWithoutUpdate</a>" (const SolveArguments &amp;arguments) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000962 : b/260337466 - Add permanent errors and concurrency protection.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::internal::IncrementalSolverImpl Member \_internalref classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl#a36a242cc2d29b0ab2f0316b5b8f469be "<a class="el" href="classoperations__research_1_1math__opt_1_1internal_1_1IncrementalSolverImpl.html#a36a242cc2d29b0ab2f0316b5b8f469be">operations_research::math_opt::internal::IncrementalSolverImpl::Update</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000961 : b/260337466 - Add permanent errors and concurrency protection.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::InvalidInputTest Class \_internalref classoperations__research_1_1math__opt_1_1InvalidInputTest "<a class="el" href="classoperations__research_1_1math__opt_1_1InvalidInputTest.html">operations_research::math_opt::InvalidInputTest</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000978 (b/172553545): this test should not be repeated for each solver since it
  tests that the Solver class validates the model before calling the
  interface. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af9843a1d7731647c94c6a7ae14cdd2da "<a class="el" href="namespaceoperations__research_1_1math__opt.html#af9843a1d7731647c94c6a7ae14cdd2da">operations_research::math_opt::IsOptimal</a>" (const std::optional&lt; double &gt; expected_primal_objective, const double tolerance)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000952 (b/309658404): Note the bounds should be at least finite once we validate
this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a290702c59542e55a40bc415231596028 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a497470e11ac93c9bb4f2e498c6fe99d0">operations_research::math_opt::LimitIs</a>" (Limit limit, testing::Matcher&lt; std::string &gt; detail_matcher=testing::_)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000951 : b/343234961 - Maybe change the name and sync the signatures/features. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ac307abe62a9d26ff0eac456704d950b6 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a4c0703c4f33214bf68365dee80418ca3">operations_research::math_opt::LimitTerminationProto</a>" (LimitProto limit, const double primal_objective, const double dual_objective, const bool claim_dual_feasible_solution_exists, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000945 (b/290359402): Consider improving to require a finite dual bound when
dual feasible solutions are returned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::LinearExpression Class \_internalref classoperations__research_1_1math__opt_1_1LinearExpression "<a class="el" href="classoperations__research_1_1math__opt_1_1LinearExpression.html">operations_research::math_opt::LinearExpression</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000970 (b/169415098): add a function to remove zero terms.
 &lt;p&gt; &lt;p&gt;(b/169415834): study if exact zeros should be automatically removed.
 &lt;p&gt; &lt;p&gt;(b/169415103): add tests that some expressions don't compile. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::LpIncompleteSolveTestParams Struct \_internalref structoperations__research_1_1math__opt_1_1LpIncompleteSolveTestParams "<a class="el" href="structoperations__research_1_1math__opt_1_1LpIncompleteSolveTestParams.html" title="Parameters for the LpIncompleteSolveTest suite below.">operations_research::math_opt::LpIncompleteSolveTestParams</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000983 (b/195295177): Consider splitting LpIncompleteSolveTest into simplex and
non-simplex tests to avoid repetition and need to input irrelevant bools from
LpIncompleteSolveTestParams when instantiating tests. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a5d8c9048c51c1bc6685751a7cb8514fe "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a5d8c9048c51c1bc6685751a7cb8514fe">operations_research::math_opt::MathOptModelToMPModelProto</a>" (const ::operations_research::math_opt::ModelProto &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000972 (user): use the constraint iterator from scip_solver.cc here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#a06cd12d3df5d04b34fde1050692bc46a "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#a06cd12d3df5d04b34fde1050692bc46a">operations_research::math_opt::Model::storage</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000956 (user): expose a way to efficiently iterate through the nonzeros of
the linear constraint matrix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#a737b42a14db864ac3afa891ecb212688 "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#a737b42a14db864ac3afa891ecb212688">operations_research::math_opt::Model::ValidateExistingLinearConstraintOfThisModel</a>" (LinearConstraint linear_constraint) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000955 (b/239810718): use &lt;&lt; for LinearConstraint once it does not CHECK.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Model Member \_internalref classoperations__research_1_1math__opt_1_1Model#ae3a2f02a80238331fcdb90fc410682df "<a class="el" href="classoperations__research_1_1math__opt_1_1Model.html#ae3a2f02a80238331fcdb90fc410682df" title="-----------------------— Linear constraints ----------------------------—">operations_research::math_opt::Model::ValidateExistingVariableOfThisModel</a>" (Variable variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000954 (b/239810718): use &lt;&lt; for Variable once it does not CHECK.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::ModelSolveParameters Member \_internalref structoperations__research_1_1math__opt_1_1ModelSolveParameters#ad0eeac04ea9c977961d68931e29e6442 "<a class="el" href="structoperations__research_1_1math__opt_1_1ModelSolveParameters.html#ad0eeac04ea9c977961d68931e29e6442">operations_research::math_opt::ModelSolveParameters::Proto</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000957 : b/315974557 - Return an error if a RepeatedField is too long.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#afa94d25b431c19de213fd01276bda3bf "<a class="el" href="namespaceoperations__research_1_1math__opt.html#afa94d25b431c19de213fd01276bda3bf">operations_research::math_opt::MoveVariablesToTheirBestFeasibleValue</a>" (const Model &amp;model, const VariableMap&lt; double &gt; &amp;input_solution, absl::Span&lt; const Variable &gt; variables, const MoveVariablesToTheirBestFeasibleValueOptions &amp;options)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000973 (b/193121090): here we build the proto as the APIs of MathOpt only
works with the proto and can't use the C++ Model (or ModelStorage). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a647b24c008c0cab90f59e848a507c244 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a647b24c008c0cab90f59e848a507c244">operations_research::math_opt::NoSolutionFoundTerminationProto</a>" (const bool is_maximize, const LimitProto limit, const std::optional&lt; double &gt; optional_dual_objective, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000943 (b/290359402): Consider improving to require a finite dual bound when
dual feasible solutions are returned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::ObjectiveStorage::Diff Member \_internalref structoperations__research_1_1math__opt_1_1ObjectiveStorage_1_1Diff#a269e380e623c1a8a281290585bb0c24f "<a class="el" href="structoperations__research_1_1math__opt_1_1ObjectiveStorage_1_1Diff.html#a269e380e623c1a8a281290585bb0c24f">operations_research::math_opt::ObjectiveStorage::Diff::objective_diffs</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001051 (b/259109678): Consider storing primary objective separately (like in
&lt;tt&gt;ObjectiveStorage&lt;/tt&gt;) if hashing is a noticeable bottleneck. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a529b5def5ea854858d5e3a6c094a0988 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const IndicatorConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000932 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af7ba8f15f41011f5b8109d7bef66511f "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const QuadraticConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000933 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a96a74dc7a0e6aa81c2279481c4c1e678 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const SecondOrderConeConstraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000934 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a1a9e610368627bfdb61a92bc85274327 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Sos1Constraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000935 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af810f3a175629e517744c9f265470b61 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Sos2Constraint &amp;constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000936 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a99d303a9027f99623639c132198aa097 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const LinearConstraint &amp;linear_constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000950 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a5db056654e1d14286315339c41c1bff0 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Objective &amp;objective)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000958 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ab1d61842701172037b05e011df664d90 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const LinearExpression &amp;expression)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000968 (b/169415597): improve linear expression format:
- make sure to quote the variable name so that we support: 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a9019e3ceb6908ea58dee5e0ea0e627f9 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const QuadraticExpression &amp;expr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000969 (b/169415597): improve quadratic expression formatting. See b/170991498
for desired improvements for LinearExpression streaming which are also
applicable here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ae8f450a61d6f3613fa723a717c3cbca3 "operations_research::math_opt::operator&lt;&lt;" (std::ostream &amp;ostr, const Variable &amp;variable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000971 (b/170992529): handle quoting of invalid characters in the name.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#a3f1deb6f9bb763a7c2635992bec9dcf9 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#a3f1deb6f9bb763a7c2635992bec9dcf9">operations_research::math_opt::OptimalTerminationProto</a>" (const double finite_primal_objective, const double dual_objective, const absl::string_view detail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000942 (b/290359402): additionally require dual_objective to be finite. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::PdlpBridge Member \_internalref classoperations__research_1_1math__opt_1_1PdlpBridge#a5be3dbbc95b4b889956096613a822e40 "<a class="el" href="classoperations__research_1_1math__opt_1_1PdlpBridge.html#a5be3dbbc95b4b889956096613a822e40">operations_research::math_opt::PdlpBridge::PrimalVariablesToProto</a>" (const Eigen::VectorXd &amp;primal_values, const SparseVectorFilterProto &amp;variable_filter) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001042 (b/183616124): we need to support the inverse of these methods for
warm start. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SimpleMipTestParameters Member \_internalref structoperations__research_1_1math__opt_1_1SimpleMipTestParameters#ac01adb283c3825d2dc482c74306d2766 "<a class="el" href="structoperations__research_1_1math__opt_1_1SimpleMipTestParameters.html#ac01adb283c3825d2dc482c74306d2766">operations_research::math_opt::SimpleMipTestParameters::report_unboundness_correctly</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000989 (b/202159173): remove this when we start using the direct CP-SAT API
and thus will be able to get proper details. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Solver Member \_internalref classoperations__research_1_1math__opt_1_1Solver#a9aa036d5c842854ba6702ee9d55276b6 "<a class="el" href="classoperations__research_1_1math__opt_1_1Solver.html#a9aa036d5c842854ba6702ee9d55276b6" title="Solves the current model (including all updates).">operations_research::math_opt::Solver::Solve</a>" (const SolveArgs &amp;arguments) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000947 (b/168037341): we should validate the result maths. Since the result
can be filtered, this should be included in the solver_interface
implementations. 
 &lt;p&gt; \anchor _todo000948 (b/290091715): Remove once language specific structs can use new
messages. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SolveResultMatcherOptions Member \_internalref structoperations__research_1_1math__opt_1_1SolveResultMatcherOptions#ae41b54030c8d6d4345348e188263eb7b "<a class="el" href="structoperations__research_1_1math__opt_1_1SolveResultMatcherOptions.html#ae41b54030c8d6d4345348e188263eb7b">operations_research::math_opt::SolveResultMatcherOptions::check_solutions_if_inf_or_unbounded</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000953 (b/201099290): this is perhaps not a good default. Gurobi as
 implemented is returning primal solutions for both unbounded and
 infeasible problems. We need to add unit tests that inspect this value
 and turn them on one solver at a time with a new parameter on
 SimpleLpTestParameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a1ef6c0a7d0962256e329df83b34a3668 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a1ef6c0a7d0962256e329df83b34a3668">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::column</a>" (ColumnId column_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001062 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a5b93353672b48d531e16f26eeb6c1238 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a5b93353672b48d531e16f26eeb6c1238">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::ColumnTerms</a>" (ColumnId col_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001064 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a35c2edd872d547e250e828a62e65ce71 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a35c2edd872d547e250e828a62e65ce71">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::row</a>" (RowId row_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001061 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#af45684890602a0abd734552aef5b53eb "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#af45684890602a0abd734552aef5b53eb">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::RowTerms</a>" (RowId row_id) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001063 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a6aca40055cfa8c9e5767ce467f5c89ae "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a6aca40055cfa8c9e5767ce467f5c89ae">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::Terms</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001065 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseMatrix#a346f0dd1bc945b8a3f6acce2f868b0f3 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseMatrix.html#a346f0dd1bc945b8a3f6acce2f868b0f3">operations_research::math_opt::SparseMatrix&lt; RowId, ColumnId &gt;::Update</a>" (const absl::flat_hash_set&lt; RowId &gt; &amp;deleted_rows, absl::Span&lt; const RowId &gt; new_rows, const absl::flat_hash_set&lt; ColumnId &gt; &amp;deleted_columns, absl::Span&lt; const ColumnId &gt; new_columns, const absl::flat_hash_set&lt; std::pair&lt; RowId, ColumnId &gt; &gt; &amp;dirty) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001054 (b/233630053): use iterator API.
 &lt;p&gt; \anchor _todo001055 (b/233630053) use iterator API.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#ae7fd3ba62ed1002264117fa864e7144f "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#ae7fd3ba62ed1002264117fa864e7144f">operations_research::math_opt::SparseSymmetricMatrix::Proto</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001052 (b/233630053): reuse the allocation once an iterator API is
supported. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a43ee2fbaa504f90f7690b0bf87861c97 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a43ee2fbaa504f90f7690b0bf87861c97">operations_research::math_opt::SparseSymmetricMatrix::RelatedVariables</a>" (VariableId variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001057 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a5daadc06a91ff1edeb4871b1801b84f9 "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a5daadc06a91ff1edeb4871b1801b84f9">operations_research::math_opt::SparseSymmetricMatrix::Terms</a>" (VariableId variable) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001058 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a4568f0449320e9203ed9969bad5d26dd "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a5daadc06a91ff1edeb4871b1801b84f9">operations_research::math_opt::SparseSymmetricMatrix::Terms</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001059 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a007fc8188b348177988fb88dffe12f3f "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a007fc8188b348177988fb88dffe12f3f">operations_research::math_opt::SparseSymmetricMatrix::Update</a>" (const absl::flat_hash_set&lt; VariableId &gt; &amp;deleted_variables, absl::Span&lt; const VariableId &gt; new_variables, const absl::flat_hash_set&lt; std::pair&lt; VariableId, VariableId &gt; &gt; &amp;dirty) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001053 (b/233630053): do not allocate here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a6297413386fb1ed24d1a6087c3f900cb "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a6297413386fb1ed24d1a6087c3f900cb">operations_research::math_opt::SparseSymmetricMatrix::values</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001060 (b/233630053): do not expose values_ directly, instead offer a way to
iterate over all the nonzero entries.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::SparseSymmetricMatrix Member \_internalref classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix#a89e72a700578de83bbd4eb42102bdc7a "<a class="el" href="classoperations__research_1_1math__opt_1_1SparseSymmetricMatrix.html#a89e72a700578de83bbd4eb42102bdc7a">operations_research::math_opt::SparseSymmetricMatrix::Variables</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001056 (b/233630053): expose an iterator based API to avoid making a copy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Termination Member \_internalref structoperations__research_1_1math__opt_1_1Termination#a09bb061e1a745c607004cbd2de7500fb "<a class="el" href="structoperations__research_1_1math__opt_1_1Termination.html#a09bb061e1a745c607004cbd2de7500fb">operations_research::math_opt::Termination::best_primal_solution</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000965 (b/290359402): Consider improving to require a finite dual bound when
/ dual feasible solutions are returned.
  static Termination NoSolutionFound(
      bool is_maximize, Limit limit,
      std::optional&lt;double&gt; optional_dual_objective = std::nullopt,
      std::string detail = {});&lt;p&gt; \anchor _todo000966 (b/290359402): Consider improving to require a finite dual bound when
/ dual feasible solutions are returned.
  static Termination Feasible(
      bool is_maximize, Limit limit, double finite_primal_objective,
      std::optional&lt;double&gt; optional_dual_objective = std::nullopt,
      std::string detail = {});&lt;p&gt; \anchor _todo000967 (b/231134639): investigate removing the oneof from the proto.
  absl::StatusOr&lt;SolveResultProto&gt; Proto() const;&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#ac51b998f0ab120a1855bd589f2553fad "<a class="el" href="namespaceoperations__research_1_1math__opt.html#ac51b998f0ab120a1855bd589f2553fad" title="Validates the input result.">operations_research::math_opt::ValidateResult</a>" (const SolveResultProto &amp;result, const ModelSolveParametersProto &amp;parameters, const ModelSummary &amp;model_summary)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001068 (b/290091715): Remove once problem_status and objective bounds are
removed from solve_stats and their presence is guaranteed in termination. 
 &lt;p&gt; \anchor _todo001069 (b/290091715): Replace by
TerminationProto termination = result.termination();
once problem_status and objective bounds are removed from solve_stats and
their presence is guaranteed in termination. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#aa782b35203234b683975688b30f3110f "<a class="el" href="namespaceoperations__research_1_1math__opt.html#aa782b35203234b683975688b30f3110f">operations_research::math_opt::ValidateSolution</a>" (const SolutionProto &amp;solution, const ModelSolveParametersProto &amp;parameters, const ModelSummary &amp;model_summary)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001071 (b/204457524): consider checking equality of statuses for single-sided
LPs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#add23cecedb126522044aca6764532ce3 "<a class="el" href="namespaceoperations__research_1_1math__opt.html#add23cecedb126522044aca6764532ce3">operations_research::math_opt::ValidateSolutions</a>" (const google::protobuf::RepeatedPtrField&lt; SolutionProto &gt; &amp;solutions, const ModelSolveParametersProto &amp;parameters, const ModelSummary &amp;model_summary)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001067 (b/204457524): check objective ordering when possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt Member \_internalref namespaceoperations__research_1_1math__opt#af099801286ce760f79dda3ce9b7be78d "<a class="el" href="namespaceoperations__research_1_1math__opt.html#af099801286ce760f79dda3ce9b7be78d">operations_research::math_opt::ValidateSolveParameters</a>" (const SolveParametersProto &amp;parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001073 (b/213697045): some parameters are still not validated.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::math_opt::Xpress Member \_internalref classoperations__research_1_1math__opt_1_1Xpress#a57dde68e6674a64a0aa0074ed12e52bc "<a class="el" href="classoperations__research_1_1math__opt_1_1Xpress.html#a5e18d0af208a8fd2d4a3fdb4cc2a3030">operations_research::math_opt::Xpress::AddVars</a>" (absl::Span&lt; const int &gt; vbegin, absl::Span&lt; const int &gt; vind, absl::Span&lt; const double &gt; vval, absl::Span&lt; const double &gt; obj, absl::Span&lt; const double &gt; lb, absl::Span&lt; const double &gt; ub, absl::Span&lt; const char &gt; vtype)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001043 : look into int64 support for number of vars (use XPRSaddcols64)
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MaxFlowStatusClass Member \_internalref classoperations__research_1_1MaxFlowStatusClass#aa3fbead787cfdfac0b9e7b217e06cbfba9b4b284d9cef8bc7ea112971c14584df "<a class="el" href="classoperations__research_1_1MaxFlowStatusClass.html#aa3fbead787cfdfac0b9e7b217e06cbfba9b4b284d9cef8bc7ea112971c14584df">operations_research::MaxFlowStatusClass::BAD_INPUT</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000683 (user): These are no longer used. Remove.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::mb::ModelSolverHelper Member \_internalref classoperations__research_1_1mb_1_1ModelSolverHelper#a1e93e0e8368250e4f20767b9692188ca "<a class="el" href="classoperations__research_1_1mb_1_1ModelSolverHelper.html#a1e93e0e8368250e4f20767b9692188ca">operations_research::mb::ModelSolverHelper::Solve</a>" (const ModelBuilderHelper &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000864 (user): Enable log_callback support.
&lt;p&gt; \anchor _todo000865 &lt;p&gt; \anchor _todo000866 (user): Enable interrupt_solve. 
 &lt;p&gt; \anchor _todo000867 (user): Enable log_callback support.
&lt;p&gt; \anchor _todo000868 &lt;p&gt; \anchor _todo000869 (user): Enable interrupt_solve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostFlow Struct \_internalref structoperations__research_1_1MinCostFlow "<a class="el" href="structoperations__research_1_1MinCostFlow.html">operations_research::MinCostFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000732 (b/385094969): Remove this alias after 2025-07-01 to give or-tools users
a grace period. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostFlowBase Member \_internalref classoperations__research_1_1MinCostFlowBase#ae5cad0c7d9c3eddbc7c3aefbee060457a3c1e555eb1251e00c277908c08018638 "<a class="el" href="classoperations__research_1_1MinCostFlowBase.html#ae5cad0c7d9c3eddbc7c3aefbee060457a3c1e555eb1251e00c277908c08018638">operations_research::MinCostFlowBase::BAD_CAPACITY_RANGE</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000733 (user): Not sure this is a good idea, probably better to make sure
client use reasonable capacities. Also we should template by FlowQuantity
and allow use of absl::int128 so we never have issue if the input is
int64_t. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a6f94ee8ea8298d25de3607ed56d2d94e "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a6f94ee8ea8298d25de3607ed56d2d94e">operations_research::MinCostPerfectMatching::AddEdgeWithCost</a>" (int tail, int head, int64_t cost)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000758 (user): We can easily shift all costs if negative costs are needed.&lt;p&gt; \anchor _todo000759 (user): We could just presolve them away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a4d798c6f197b745924e4e0ca184c3642 "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a4d798c6f197b745924e4e0ca184c3642">operations_research::MinCostPerfectMatching::MinCostPerfectMatching</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000756 (user): For now we ask the number of nodes at construction, but we
could automatically infer it from the added edges if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#a5f89c8890f72a582d15baf027b9cfeb9 "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#a5f89c8890f72a582d15baf027b9cfeb9">operations_research::MinCostPerfectMatching::Reset</a>" (int num_nodes)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000757 (user): Eventually, we may support incremental Solves(). Or at least
memory reuse if one wants to solve many problems in a row. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MinCostPerfectMatching Member \_internalref classoperations__research_1_1MinCostPerfectMatching#acce484fd341b33e5c371f0a1046821ed "<a class="el" href="classoperations__research_1_1MinCostPerfectMatching.html#acce484fd341b33e5c371f0a1046821ed">operations_research::MinCostPerfectMatching::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000737 (user): Improve the overflow detection if needed. The current one seems
ok though. 
 &lt;p&gt; \anchor _todo000738 (user): Maybe there is a faster/better way to recover the mapping
in the presence of blossoms. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a84aec4c6ee3b17edc9979b12ecdb5f63 "<a class="el" href="classoperations__research_1_1MPSolver.html#a84aec4c6ee3b17edc9979b12ecdb5f63">operations_research::MPSolver::ComputeConstraintActivities</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000825 (user): test this failure case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a9c8cc8b3c36fe9c08d8e0eefbc98b774 "<a class="el" href="classoperations__research_1_1MPSolver.html#a9c8cc8b3c36fe9c08d8e0eefbc98b774" title="Exports model to protocol buffer.">operations_research::MPSolver::ExportModelToProto</a>" (MPModelProto *output_model) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000821 (user): Add option to avoid filling the var name to avoid overly
large protocol buffers. 
 &lt;p&gt; \anchor _todo000822 (user): remove this step. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#aae2800c3df9ebf5f1e3c21cd5af3c9a9 "<a class="el" href="classoperations__research_1_1MPSolver.html#aae2800c3df9ebf5f1e3c21cd5af3c9a9">operations_research::MPSolver::LoadSolutionFromProto</a>" (const MPSolutionResponse &amp;response, double tolerance=std::numeric_limits&lt; double &gt;::infinity())&lt;/dt&gt;&lt;dd&gt; \anchor _todo000823 (user): Use parameter when they become available in this class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a9f2efb3304b325430e46e848574d63e5 "<a class="el" href="classoperations__research_1_1MPSolver.html#a18aef4e4cdea4ee15ce472d3b5f57962" title="Solves the problem using the default parameter values.">operations_research::MPSolver::Solve</a>" (const MPSolverParameters &amp;param)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000824 (user): replace this by model extraction to proto + proto validation
(the proto has very low overhead compared to the wrapper, both in
performance and memory, so it's ok). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolver Member \_internalref classoperations__research_1_1MPSolver#a2a4a0234b5830d4ea82d549b3b6b5baf "<a class="el" href="classoperations__research_1_1MPSolver.html#a2a4a0234b5830d4ea82d549b3b6b5baf">operations_research::MPSolver::VerifySolution</a>" (double tolerance, bool log_errors) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000826 (user): split.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#ac11b5863b3866e251564de9a5dcfb92e "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#ac11b5863b3866e251564de9a5dcfb92e">operations_research::MPSolverInterface::MPSolverInterface</a>" (MPSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000827 (user): Initialize objective value and bound to +/- inf (depending on
optimization direction). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#a3fd73560f782eaf5093a435c61783d09 "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#a3fd73560f782eaf5093a435c61783d09" title="Resets the extraction information.">operations_research::MPSolverInterface::ResetExtractionInformation</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000828 (user): remove this method.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::MPSolverInterface Member \_internalref classoperations__research_1_1MPSolverInterface#ad237855fa79fc36fbf9baedce589384c "<a class="el" href="classoperations__research_1_1MPSolverInterface.html#ad237855fa79fc36fbf9baedce589384c" title="Sets parameters common to LP and MIP in the underlying solver.">operations_research::MPSolverInterface::SetCommonParameters</a>" (const MPSolverParameters &amp;param)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000829 (user): Overhaul the code that sets parameters to enable changing
GLOP parameters without issuing warnings.
By default, we let GLOP keep its own default tolerance, much more accurate
than for the rest of the solvers.
 &lt;p&gt; \anchor _todo000830 (user): In the future, we could distinguish between the
algorithm to solve the root LP and the algorithm to solve node
LPs. Not sure if underlying solvers support it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a9618712e8edff7ae775417c7e2763062 "<a class="el" href="namespaceoperations__research.html#a9618712e8edff7ae775417c7e2763062">operations_research::NodePathImpliedBy</a>" (absl::Span&lt; const typename GraphType::ArcIndex &gt; arc_path, const GraphType &amp;graph)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000670 (b/332475804): If &lt;tt&gt;ArcPathTo&lt;/tt&gt; and/or &lt;tt&gt;NodePathTo&lt;/tt&gt; functions become
bottlenecks:
   (1) have the class preallocate a buffer of size &lt;tt&gt;num_nodes&lt;/tt&gt;
   (2) assign into an index rather than with push_back
   (3) return by absl::Span (or return a copy) with known size. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ObjectiveMonitor Member \_internalref classoperations__research_1_1ObjectiveMonitor#abfce94c7e8c5e81991ad9d744ecf7f3e "<a class="el" href="classoperations__research_1_1ObjectiveMonitor.html#abfce94c7e8c5e81991ad9d744ecf7f3e">operations_research::ObjectiveMonitor::ObjectiveMonitor</a>" (Solver *solver, const std::vector&lt; bool &gt; &amp;maximize, std::vector&lt; IntVar * &gt; vars, std::vector&lt; int64_t &gt; steps)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000438 (user): Remove optimization direction from solver or expose it for
each OptimizeVar variable. Note that Solver::optimization_direction() is
not used anywhere, only passed as information for the user. Direction set
based on highest level as of 02/2023. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Pack Member \_internalref classoperations__research_1_1Pack#af13898c8553d217fa3d52c6e2b504f8d "<a class="el" href="classoperations__research_1_1Pack.html#af13898c8553d217fa3d52c6e2b504f8d">operations_research::Pack::OneDomain</a>" (int var_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000256 (user): We know var ranges from 0 to bins_. There are lots
of simplifications possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PairExchangeOperator Member \_internalref classoperations__research_1_1PairExchangeOperator#a31ebe4f1abc2360aa8f4ba573ba05287 "<a class="el" href="classoperations__research_1_1PairExchangeOperator.html#a31ebe4f1abc2360aa8f4ba573ba05287">operations_research::PairExchangeOperator&lt; ignore_path_vars &gt;::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000383 (user): Support alternatives with neighbors.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PairRelocateOperator Member \_internalref classoperations__research_1_1PairRelocateOperator#a0b329c80a267fd1cf4b3a925429fa7c4 "<a class="el" href="classoperations__research_1_1PairRelocateOperator.html#a0b329c80a267fd1cf4b3a925429fa7c4">operations_research::PairRelocateOperator&lt; ignore_path_vars &gt;::PairRelocateOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;secondary_vars, std::function&lt; int(int64_t)&gt; start_empty_path_class, const std::vector&lt; PickupDeliveryPair &gt; &amp;pairs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000379 (user): Add a version where a (first_node, second_node) pair are
added respectively after first_node_neighbor and second_node_neighbor.
This requires a complete restructuring of the code, since we would require
scanning neighbors for a non-base node (second_node is an active sibling
of first_node). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad269bb3141acc83c2ebe88b1f57b1f95 "<a class="el" href="namespaceoperations__research.html#ad269bb3141acc83c2ebe88b1f57b1f95">operations_research::ParseAndSolve</a>" (const std::string &amp;filename, absl::string_view solver, const std::string &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001076 (user): Move naming code to parser.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathEnergyCostChecker Class \_internalref classoperations__research_1_1PathEnergyCostChecker "<a class="el" href="classoperations__research_1_1PathEnergyCostChecker.html">operations_research::PathEnergyCostChecker</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000344 (user): improve this class by:
- using WeightedWaveletTree to get the amount of energy above the threshold.
- detect when costs above and below are the same, to avoid correcting for
  energy above the threshold and get O(1) time per chain. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathLns Member \_internalref classoperations__research_1_1PathLns#a81f3519a55d2648015a7e69cee3f6939 "<a class="el" href="classoperations__research_1_1PathLns.html#a81f3519a55d2648015a7e69cee3f6939">operations_research::PathLns&lt; ignore_path_vars &gt;::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000236 (user): make this more efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#a670776038d80be84dbb818c4a2315d43 "<a class="el" href="classoperations__research_1_1PathOperator.html#a670776038d80be84dbb818c4a2315d43">operations_research::PathOperator&lt; ignore_path_vars &gt;::OnSamePathAsPreviousBase</a>" (int64_t)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000176 (user): ideally this should be OnSamePath(int64_t node1, int64_t
node2);
it's currently way more complicated to implement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#ac46c5e19f2ae1c938b0070f69784b244 "<a class="el" href="classoperations__research_1_1PathOperator.html#ac46c5e19f2ae1c938b0070f69784b244">operations_research::PathOperator&lt; ignore_path_vars &gt;::RestartAtPathStartOnSynchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000175 (user): remove this when automatic detection of such cases in done. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PathOperator Member \_internalref classoperations__research_1_1PathOperator#a119769d67cbf91b48d6051fd96a61d5f "<a class="el" href="classoperations__research_1_1PathOperator.html#a119769d67cbf91b48d6051fd96a61d5f">operations_research::PathOperator&lt; ignore_path_vars &gt;::SkipUnchanged</a>" (int index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000174 (user): Make the following methods protected.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a7bd16384c5572b001a57e9987bf5b0e9 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a7bd16384c5572b001a57e9987bf5b0e9">operations_research::pdlp::FindScalingFactor</a>" (const DiagonalTrustRegionProblem &amp;problem, const Sharder &amp;sharder, const double target_radius, const double solve_tol)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001095 (user): figure out what accuracy is useful to callers and redo the
stopping criterion accordingly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp::internal Member \_internalref namespaceoperations__research_1_1pdlp_1_1internal#a0d1a488cd88b2db320196184c8a60713 "<a class="el" href="namespaceoperations__research_1_1pdlp_1_1internal.html#a0d1a488cd88b2db320196184c8a60713">operations_research::pdlp::internal::ComputeInitialUndecidedComponents</a>" (const TrustRegionProblem &amp;problem, int64_t start_index, int64_t end_index, std::vector&lt; int64_t &gt; &amp;undecided_components)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001096 (user): Evaluate dropping this &lt;tt&gt;reserve()&lt;/tt&gt;, since it wastes space
if many components are decided. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a898c0c776a5736cf1931036d0d370724 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a898c0c776a5736cf1931036d0d370724">operations_research::pdlp::ProjectToDualVariableBounds</a>" (const ShardedQuadraticProgram &amp;sharded_qp, VectorXd &amp;dual)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001092 (user): Investigate whether it is more efficient to
use .cwiseMax() + .cwiseMin() with unaryExpr(s) that map
upper_bound_shard and lower_bound_shard to appropriate values. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp Member \_internalref namespaceoperations__research_1_1pdlp#a80b7dc41ed788020cbaf942674f623d9 "<a class="el" href="namespaceoperations__research_1_1pdlp.html#a80b7dc41ed788020cbaf942674f623d9">operations_research::pdlp::ReadQuadraticProgramOrDie</a>" (const std::string &amp;filename, bool include_names)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001090 (user): Update internal helper functions to use references instead of
pointers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::pdlp::ShardedWeightedAverage Member \_internalref classoperations__research_1_1pdlp_1_1ShardedWeightedAverage#a832ecd48fecace426aeb1c32f0322fbb "<a class="el" href="classoperations__research_1_1pdlp_1_1ShardedWeightedAverage.html#a832ecd48fecace426aeb1c32f0322fbb">operations_research::pdlp::ShardedWeightedAverage::ComputeAverage</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001091 (user): consider returning a reference to avoid this copy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#aeba91f0ed5437b1264431fc6562ff094 "<a class="el" href="classoperations__research_1_1PdlpInterface.html#aeba91f0ed5437b1264431fc6562ff094" title="Returns the basis status of a constraint.">operations_research::PdlpInterface::column_status</a>" (int variable_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000837 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#aecba606519ca8ae9dfb6493a4653cbfc "<a class="el" href="classoperations__research_1_1PdlpInterface.html#aecba606519ca8ae9dfb6493a4653cbfc" title="Returns the basis status of a row.">operations_research::PdlpInterface::row_status</a>" (int constraint_index) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000836 (user): While basis status isn't well defined for PDLP, we could
guess statuses that might be useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PdlpInterface Member \_internalref classoperations__research_1_1PdlpInterface#a22fcf7b9b53475d97d46e1eb057d1b87 "<a class="el" href="classoperations__research_1_1PdlpInterface.html#a22fcf7b9b53475d97d46e1eb057d1b87">operations_research::PdlpInterface::underlying_solver</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000838 (user): Consider returning the SolveLog here, as it could be essential
for interpreting the PDLP solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PiecewiseLinearExpr Member \_internalref classoperations__research_1_1PiecewiseLinearExpr#a29f2fd207e34ba398b1b772d21852f33 "<a class="el" href="classoperations__research_1_1PiecewiseLinearExpr.html#a29f2fd207e34ba398b1b772d21852f33" title="Accepts the given visitor.">operations_research::PiecewiseLinearExpr::Accept</a>" (ModelVisitor *const visitor) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000219 (user): Implement visitor.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PiecewiseLinearFunction Member \_internalref classoperations__research_1_1PiecewiseLinearFunction#adb77fb211d172324d3d02e974af56c5b "<a class="el" href="classoperations__research_1_1PiecewiseLinearFunction.html#adb77fb211d172324d3d02e974af56c5b" title="Returns the value of the piecewise linear function for x.">operations_research::PiecewiseLinearFunction::Value</a>" (int64_t x) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002553 (user): Allow the user to specify the
undefined value and use kint64max as the default. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#adb4766c06fff29c31c59bbccbc5ee83b "<a class="el" href="namespaceoperations__research.html#adb4766c06fff29c31c59bbccbc5ee83b">operations_research::PiecewiseLinearFunctionToSlopeAndYIntercept</a>" (const FloatSlopePiecewiseLinearFunction &amp;pwl_function, int index_start, int index_end)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000372 (user): Consider making the following two functions methods of
FloatSlopePiecewiseLinearFunction. They're only called in lp_scheduling.cc
and ../tour_optimization/model_test.cc, but they might come in handy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab930437cc9dc6b952276f7719f331409 "<a class="el" href="namespaceoperations__research.html#ab930437cc9dc6b952276f7719f331409">operations_research::PropagateLightweightVehicleBreaks</a>" (int path, DimensionValues &amp;dimension_values, absl::Span&lt; const std::pair&lt; int64_t, int64_t &gt; &gt; interbreaks)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000325 (user): consider adding deductions from the path to the break.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::PruningHamiltonianSolver Member \_internalref classoperations__research_1_1PruningHamiltonianSolver#aee868e1ea38d845f3da2cb0d38ad6d3f "<a class="el" href="classoperations__research_1_1PruningHamiltonianSolver.html#aee868e1ea38d845f3da2cb0d38ad6d3f">operations_research::PruningHamiltonianSolver&lt; CostType, CostFunction &gt;::Integer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000709 (user): Use generic map-based cache instead of lattice-based one.
 &lt;p&gt; &lt;p&gt;(user): Use SaturatedArithmetic for better precision. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Queue Member \_internalref classoperations__research_1_1Queue#a014c7261e4c1b40cd8d81d22e22c3e94 "<a class="el" href="classoperations__research_1_1Queue.html#a014c7261e4c1b40cd8d81d22e22c3e94">operations_research::Queue::ProcessConstraints</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000145 (user): Make to_add_ a queue to make the behavior more obvious. 
 &lt;p&gt; \anchor _todo000146 (user): Add profiling to initial propagation
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ad9e6cb141794cea6160e283e70c283c7 "<a class="el" href="namespaceoperations__research.html#ad9e6cb141794cea6160e283e70c283c7">operations_research::RadixSort</a>" (absl::Span&lt; T &gt; values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000038 (user): Expose an API that takes the "max value" as argument, for
users who want to take advantage of that knowledge to reduce the number of
passes. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ab5ef2e157c0cb5fad29b2b6db644f8a0 "<a class="el" href="namespaceoperations__research.html#ab5ef2e157c0cb5fad29b2b6db644f8a0" title="The internal template that does all the work.">operations_research::RadixSortTpl</a>" (absl::Span&lt; T &gt; values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000035 : remove the if constexpr so that compilation catches the bad cases.
 &lt;p&gt; \anchor _todo000036 (user): See if this is faster than memcpy + std::reverse().
 &lt;p&gt; \anchor _todo000037 (user): See if memcpy everything + memcpy here is faster than
memmove(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RandomSolutionGenerator Class \_internalref classoperations__research_1_1RandomSolutionGenerator "<a class="el" href="classoperations__research_1_1RandomSolutionGenerator.html" title="The consistency level is maintained up to kFreeAndUncovered.">operations_research::RandomSolutionGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000049 (user): make it possible to use other random generators. Idea: bias the
generator towards the columns with the least marginal costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RangeIntToIntFunction Member \_internalref classoperations__research_1_1RangeIntToIntFunction#a95dc968eea4874e0099cc74f38bd4aca "<a class="el" href="classoperations__research_1_1RangeIntToIntFunction.html#a95dc968eea4874e0099cc74f38bd4aca">operations_research::RangeIntToIntFunction::Query</a>" (int64_t argument) const =0&lt;/dt&gt;&lt;dd&gt; \anchor _todo002556 (user): Rename to Run 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a9dc92cf61d5051e6ec16fa5dc7e371ae "<a class="el" href="namespaceoperations__research.html#a9dc92cf61d5051e6ec16fa5dc7e371ae">operations_research::RationalApproximation</a>" (const double x, const double precision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002557 (user): make a parameterized template with integer and floating-point
type parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a12253044bb2027c42e090f5d54be9e6d "<a class="el" href="namespaceoperations__research.html#a12253044bb2027c42e090f5d54be9e6d" title="This is a row-based format where the elements are 1-indexed.">operations_research::ReadOrlibScp</a>" (absl::string_view filename)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000076 (user): add proper error handling. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a1bd9bbb304a58211dee6405bc7fc4056 "<a class="el" href="namespaceoperations__research.html#a1bd9bbb304a58211dee6405bc7fc4056">operations_research::ReadQapProblemOrDie</a>" (absl::string_view filepath)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002555 (user): Unit test cases when the function dies, or return
(and test) a status instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Relocate Member \_internalref classoperations__research_1_1Relocate#acd12eba6b4e2d62a89e7768c9d4269d9 "<a class="el" href="classoperations__research_1_1Relocate.html#acd12eba6b4e2d62a89e7768c9d4269d9">operations_research::Relocate&lt; ignore_path_vars &gt;::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000234 (user): Handle chain_length_ &gt; 1 for incoming neighbors by going
backwards on the chain. NOTE: In this setting it makes sense to have path
ends as base nodes as we move the chain "before" the base node. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a7953cda3a19373c8a5acd4d1b3a5d8ef "<a class="el" href="namespaceoperations__research.html#a7953cda3a19373c8a5acd4d1b3a5d8ef" title="-— RelocateAndMakeActive --—">operations_research::RelocateAndMakeActive</a>" (Solver *solver, const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;secondary_vars, std::function&lt; int(int64_t)&gt; start_empty_path_class)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000170 (user): Naming is close to MakeActiveAndRelocate but this one is
correct; rename MakeActiveAndRelocate if it is actually used. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RelocateExpensiveChain Member \_internalref classoperations__research_1_1RelocateExpensiveChain#ae44b8b6abeada0600f46ac7a76ed527c "<a class="el" href="classoperations__research_1_1RelocateExpensiveChain.html#ae44b8b6abeada0600f46ac7a76ed527c">operations_research::RelocateExpensiveChain&lt; ignore_path_vars &gt;::MakeNeighbor</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000384 (user): Consider node neighbors? The operator would no longer be
a path operator though, because we would no longer have any base nodes. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RevBitMatrix Member \_internalref classoperations__research_1_1RevBitMatrix#ae2bcb32bc27553f598733168bbc46fd2 "<a class="el" href="classoperations__research_1_1RevBitMatrix.html#ae2bcb32bc27553f598733168bbc46fd2" title="Does the &#39;row&#39; bitset contains only one bit set?">operations_research::RevBitMatrix::IsCardinalityOne</a>" (int row) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000454 (user) : Optimize this one.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RevVector Member \_internalref classoperations__research_1_1RevVector#a576b88e9d92029753f73f012e2b57599 "<a class="el" href="classoperations__research_1_1RevVector.html#a576b88e9d92029753f73f012e2b57599">operations_research::RevVector&lt; IndexType, T &gt;::MutableRef</a>" (IndexType index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002559 (user): Maybe we could have also used the [] operator, but it is harder
to be 100% sure that the mutable version is only called when we modify
the vector. And I had performance bug because of that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoundRobinCompoundObjectiveMonitor Member \_internalref classoperations__research_1_1RoundRobinCompoundObjectiveMonitor#af18c945c6d8d18299c62eaca1e9d7b23 "<a class="el" href="classoperations__research_1_1RoundRobinCompoundObjectiveMonitor.html#af18c945c6d8d18299c62eaca1e9d7b23" title="Accepts the given model visitor.">operations_research::RoundRobinCompoundObjectiveMonitor::Accept</a>" (ModelVisitor *visitor) const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000440 (user): properly implement this.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::routing::CVRPToursParser Member \_internalref classoperations__research_1_1routing_1_1CVRPToursParser#a00ad3b0ebb0be511e363d36c19068c4e "<a class="el" href="classoperations__research_1_1routing_1_1CVRPToursParser.html#a00ad3b0ebb0be511e363d36c19068c4e" title="Loads and parses a given tours file.">operations_research::routing::CVRPToursParser::LoadFile</a>" (absl::string_view file_name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001103 (user): Return false when issues were encountered while parsing the
file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::routing Member \_internalref namespaceoperations__research_1_1routing#a6c9b2ff20d25a2319901048490bfa0c4 "<a class="el" href="namespaceoperations__research_1_1routing.html#a6c9b2ff20d25a2319901048490bfa0c4" title="Formats a solution or solver statistic according to the given format.">operations_research::routing::FormatStatistic</a>" (absl::string_view name, T value, RoutingOutputFormat format)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001101 (user): think about using an enum instead of names (or even a
full-fledged struct/class) for the various types of fields. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::routing::TspLibTourParser Member \_internalref classoperations__research_1_1routing_1_1TspLibTourParser#ab7d90ffe89c11bc45b6d80900bb73caa "<a class="el" href="classoperations__research_1_1routing_1_1TspLibTourParser.html#ab7d90ffe89c11bc45b6d80900bb73caa" title="Loads and parses a given tour file.">operations_research::routing::TspLibTourParser::LoadFile</a>" (absl::string_view file_name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001102 (user): Return false when issues were encountered while parsing the
file. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingCPSatWrapper Member \_internalref classoperations__research_1_1RoutingCPSatWrapper#a54222815697e83432b6831b5a362bafc "<a class="el" href="classoperations__research_1_1RoutingCPSatWrapper.html#a54222815697e83432b6831b5a362bafc">operations_research::RoutingCPSatWrapper::Solve</a>" (absl::Duration duration_limit) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000376 (user): Consider storing "feasible" solutions in a separate
cache we use as hint when the "optimal" cache is empty. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingFilteredHeuristic Member \_internalref classoperations__research_1_1RoutingFilteredHeuristic#ac5032981b0d998f23d41289f5c3fdbf4 "<a class="el" href="classoperations__research_1_1RoutingFilteredHeuristic.html#ac5032981b0d998f23d41289f5c3fdbf4" title="Adds all unassigned nodes to empty vehicles.">operations_research::RoutingFilteredHeuristic::AddUnassignedNodesToEmptyVehicles</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000400 (user): check that delta_ is empty.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingFilteredHeuristic Member \_internalref classoperations__research_1_1RoutingFilteredHeuristic#a7bb79a29267b7b9153447234897a7949 "<a class="el" href="classoperations__research_1_1RoutingFilteredHeuristic.html#a7bb79a29267b7b9153447234897a7949" title="Make all unassigned nodes unperformed, always returns true.">operations_research::RoutingFilteredHeuristic::MakeUnassignedNodesUnperformed</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000401 (user): check that delta_ is empty.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingGlopWrapper Member \_internalref classoperations__research_1_1RoutingGlopWrapper#a6e9afdf1ffb0dba256ae65a29dcc3e64 "<a class="el" href="classoperations__research_1_1RoutingGlopWrapper.html#a6e9afdf1ffb0dba256ae65a29dcc3e64">operations_research::RoutingGlopWrapper::PrintModel</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000375 (user): Improve output readability. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingGlopWrapper Member \_internalref classoperations__research_1_1RoutingGlopWrapper#ae230124d932c4d9f0da5d5b9538b88ba "<a class="el" href="classoperations__research_1_1RoutingGlopWrapper.html#ae230124d932c4d9f0da5d5b9538b88ba">operations_research::RoutingGlopWrapper::SetVariableDisjointBounds</a>" (int index, const std::vector&lt; int64_t &gt; &amp;starts, const std::vector&lt; int64_t &gt; &amp;ends) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000374 (user): Investigate if we can avoid rebuilding the interval list
each time (we could keep a reference to the forbidden interval list in
RoutingDimension but we would need to store cumul offsets and use them
when checking intervals). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingIndexManager Member \_internalref classoperations__research_1_1RoutingIndexManager#a148a071cb5a92fe73501c7c299ed5eb1 "<a class="el" href="classoperations__research_1_1RoutingIndexManager.html#a148a071cb5a92fe73501c7c299ed5eb1">operations_research::RoutingIndexManager::num_unique_depots</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000359 (user) Add unit tests for NodesToIndices and IndicesToNodes.
 &lt;p&gt; &lt;p&gt;(user): Remove when removal of NodeIndex from RoutingModel is
complete. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingModelInspector Member \_internalref classoperations__research_1_1RoutingModelInspector#a84dbe032f5cce5e2e3acc042382b1f85 "<a class="el" href="classoperations__research_1_1RoutingModelInspector.html#a84dbe032f5cce5e2e3acc042382b1f85">operations_research::RoutingModelInspector::EndVisitModel</a>" (const std::string &amp;) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000307 (user): Perform transitive closure of dimension precedence graphs.
&lt;p&gt; \anchor _todo000308 &lt;p&gt; \anchor _todo000309 (user): Have a single annotated precedence graph. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingSolution Member \_internalref classoperations__research_1_1RoutingSolution#a93f14bf0ba7eb98f4f6d712ac12bef7e "<a class="el" href="classoperations__research_1_1RoutingSolution.html#a93f14bf0ba7eb98f4f6d712ac12bef7e">operations_research::RoutingSolution::GetRandomSequenceOfVisits</a>" (int64_t seed_visit, std::mt19937 &amp;rnd, std::bernoulli_distribution &amp;boolean_dist, int size) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000355 (user): consider taking the container in input to avoid multiple
memory allocations. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::RoutingSolution Member \_internalref classoperations__research_1_1RoutingSolution#a701bb2d0b439bff16cbb7bc24b191726 "<a class="el" href="classoperations__research_1_1RoutingSolution.html#a701bb2d0b439bff16cbb7bc24b191726" title="Initializes the routing solution for the given assignment.">operations_research::RoutingSolution::Reset</a>" (const Assignment *assignment)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000353 (user): consider resetting only previously set values.
 &lt;p&gt; \anchor _todo000354 (user): consider removing the resets below, and only rely on
nexts_. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aac65f6cb5816150efa463314f16ee1cd "<a class="el" href="namespaceoperations__research.html#aac65f6cb5816150efa463314f16ee1cd">operations_research::RunSeparation</a>" (internal::ScipCallbackRunner *runner, const ScipConstraintHandlerContext &amp;context, absl::Span&lt; SCIP_CONS * &gt; constraints, bool is_integral)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000854 (user): when infeasible is true, it better to have the scip
return status be cutoff instead of cutting plane added (e.g. see
cs/scip/src/scip/cons_knapsack.c). However, as we use
SCIPaddRow(), it isn't clear this will even happen. 
 &lt;p&gt; \anchor _todo000855 (user): Maybe it is better to expose more of these options,
potentially through user_suggested_constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Class \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html">operations_research::sat::ActivityBoundHelper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002233 (user): Use better algorithm. The problem is the same as finding upper
bound to the classic problem: maximum-independent set in a graph. We also
only use at most ones, but we could use the more general binary implication
graph. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#a0597d8e2ff729931de6b9e1e7df34298 "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#a0597d8e2ff729931de6b9e1e7df34298">operations_research::sat::ActivityBoundHelper::AddAllAtMostOnes</a>" (const CpModelProto &amp;proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002227 (user): Add long ones first, or at least the ones of size 2 after.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#a7569741972c7325665407db889dc36af "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#a7569741972c7325665407db889dc36af">operations_research::sat::ActivityBoundHelper::ComputeMaxActivity</a>" (absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; terms, std::vector&lt; std::array&lt; int64_t, 2 &gt; &gt; *conditional=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002236 (user): Indicate when the bounds are trivial (i.e. not intersection
with any amo) so that we don't waste more time processing the result? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ActivityBoundHelper Member \_internalref classoperations__research_1_1sat_1_1ActivityBoundHelper#ad71179e60a9659f4899d68ad8472b679 "<a class="el" href="classoperations__research_1_1sat_1_1ActivityBoundHelper.html#ad71179e60a9659f4899d68ad8472b679">operations_research::sat::ActivityBoundHelper::PresolveEnforcement</a>" (absl::Span&lt; const int &gt; refs, ConstraintProto *ct, absl::flat_hash_set&lt; int &gt; *literals_at_true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002229 (user): Ideally these amo should not be added to this class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9de52a1eb284f2cf6e20a2a0e713f092 "<a class="el" href="namespaceoperations__research_1_1sat.html#a9de52a1eb284f2cf6e20a2a0e713f092">operations_research::sat::AdaptGlobalParameters</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001576 (user): This was the old behavior, but consider switching this to
just a warning? it might be a valid usage to enumerate all solution of
a presolved model. 
 &lt;p&gt; \anchor _todo001577 (user): for now this is not deterministic so we disable it on
interleave search. Fix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af6541cdba8310f4fcbc8d8737cd29afa "<a class="el" href="namespaceoperations__research_1_1sat.html#af6541cdba8310f4fcbc8d8737cd29afa" title="l =&gt; (a + b &lt;= ub).">operations_research::sat::AddConditionalSum2LowerOrEqual</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, IntegerVariable a, IntegerVariable b, int64_t ub, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002191 (user): Refactor to be sure we do not miss any level zero relations.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad3913e8754c767cf5b0be9282bd4c6fe "<a class="el" href="namespaceoperations__research_1_1sat.html#ad3913e8754c767cf5b0be9282bd4c6fe">operations_research::sat::AddConditionalSum3LowerOrEqual</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, IntegerVariable a, IntegerVariable b, IntegerVariable c, int64_t ub, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002192 (user): Use level zero bounds to infer binary precedence relations? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a799cf49d8b3bb7f3ede756a639e6662c "<a class="el" href="namespaceoperations__research_1_1sat.html#a799cf49d8b3bb7f3ede756a639e6662c" title="Scheduling relaxations and cut generators.">operations_research::sat::AddCumulativeRelaxation</a>" (const AffineExpression &amp;capacity, SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands, const std::optional&lt; AffineExpression &gt; &amp;makespan, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002046 (user): We could use (capacity / demands_gcd) * demands_gcd. 
 &lt;p&gt; \anchor _todo002047 (user): Implement demands_gcd != 1 &amp;&amp; capacity is fixed.
 &lt;p&gt; \anchor _todo002048 (user): In some cases, we could have only one task that can be
first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9ab304db27f5c4170f35583c69269394 "<a class="el" href="namespaceoperations__research_1_1sat.html#a9ab304db27f5c4170f35583c69269394">operations_research::sat::AddDisjunctive</a>" (const std::vector&lt; IntervalVariable &gt; &amp;intervals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001713 (user): create them dynamically instead? 
 &lt;p&gt; \anchor _todo001734 (user): This is not completely true for empty intervals (start == end).
Make sure such intervals are ignored by the constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#abf0e8ef0b1ad01ad3a9aae0a009e5f13 "<a class="el" href="namespaceoperations__research_1_1sat.html#abf0e8ef0b1ad01ad3a9aae0a009e5f13">operations_research::sat::AddLinMaxCutGenerator</a>" (const ConstraintProto &amp;ct, Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002057 (user): Support linearization of general target expression.
 &lt;p&gt; \anchor _todo002058 (user): Move this out of here.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a919cb1a74305a95883f51e95343ac474 "<a class="el" href="namespaceoperations__research_1_1sat.html#a919cb1a74305a95883f51e95343ac474" title="enforcement_literals =&gt; sum &lt;= upper_bound">operations_research::sat::AddWeightedSumLowerOrEqual</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const int64_t &gt; coefficients, int64_t upper_bound, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001853 (user): Deal with the case with no enforcement literal, in case the
presolve was turned off? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AffineExpression Member \_internalref structoperations__research_1_1sat_1_1AffineExpression#ae2df741604041f566520f58d28482eef "<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html#ae2df741604041f566520f58d28482eef">operations_research::sat::AffineExpression::var</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001830 (user): Make this private to enforce the invariant that coeff cannot be
negative. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentBoundsPropagator Class \_internalref classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator.html">operations_research::sat::AllDifferentBoundsPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001112 (user): It might be difficult to find something faster than what is
implemented here. Some related reference:
https://cs.uwaterloo.ca/~vanbeek/Publications/ijcai03_TR.pdf 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentBoundsPropagator Member \_internalref classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator#abcd3b5d1133bde855025a642745ca3b6 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentBoundsPropagator.html#abcd3b5d1133bde855025a642745ca3b6">operations_research::sat::AllDifferentBoundsPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001111 (user): investigate the impact. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentConstraint Member \_internalref classoperations__research_1_1sat_1_1AllDifferentConstraint#aab6b1df5d9e513a4880255df19169bd6 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html#aab6b1df5d9e513a4880255df19169bd6">operations_research::sat::AllDifferentConstraint::AllDifferentConstraint</a>" (absl::Span&lt; const IntegerVariable &gt; variables, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001109 (user): Prune now, ignore these variables during solving. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AllDifferentConstraint Member \_internalref classoperations__research_1_1sat_1_1AllDifferentConstraint#a1adb3a2f02ebc277b22879cd01e994b2 "<a class="el" href="classoperations__research_1_1sat_1_1AllDifferentConstraint.html#a1adb3a2f02ebc277b22879cd01e994b2">operations_research::sat::AllDifferentConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001110 (user): If needed, there are several ways performance could be
improved.
If copying the variable state is too costly, it could be maintained instead.
If the propagator has too many fruitless calls (without failing/pruning),
we can remember the O(n) arcs used in the matching and the SCC decomposition,
and guard calls to Propagate() if these arcs are still valid. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afc1129274beafb17b41ac2fa278de60c "<a class="el" href="namespaceoperations__research_1_1sat.html#afc1129274beafb17b41ac2fa278de60c">operations_research::sat::AllValuesInDomain</a>" (const ProtoWithDomain &amp;proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001623 (user): work directly on the Domain class instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a43f4e0c653d01e67ff65ec40eb96e2e5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a43f4e0c653d01e67ff65ec40eb96e2e5">operations_research::sat::AnalyzeIntervals</a>" (bool transpose, absl::Span&lt; const int &gt; local_boxes, absl::Span&lt; const Rectangle &gt; rectangles, absl::Span&lt; const IntegerValue &gt; rectangle_energies, IntegerValue *x_threshold, IntegerValue *y_threshold, Rectangle *conflict)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001707 (user): If the number of unique x_max is smaller than the number of
unique x_min, it is better to do it the other way around. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac506719ca656893d93a2a6c940999265 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac506719ca656893d93a2a6c940999265">operations_research::sat::AppendBoolAndRelaxation</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *activity_helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002041 (user): These constraints can be many, and if they are not regrouped
in big at most ones, then they should probably only added lazily as cuts.
Regroup this with future clique-cut separation logic.&lt;p&gt; \anchor _todo002042 (user): More generally, do not miss the same structure if the bool_and
was expanded into many clauses!&lt;p&gt; \anchor _todo002043 (user): It is not 100% clear that just not adding one constraint is
worse. Relaxation is worse, but then we have less constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a99c02b5f23ff755783f84c851f8dcbb2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a99c02b5f23ff755783f84c851f8dcbb2">operations_research::sat::AppendElementEncodingRelaxation</a>" (Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002059 (user): We can do something similar with just an at most one, however
it is harder to detect that if all literal are false then none of the implied
value can be taken. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a42d3ac4927f1adbca821091239fc06c7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a42d3ac4927f1adbca821091239fc06c7">operations_research::sat::AppendLinearConstraintRelaxation</a>" (const ConstraintProto &amp;ct, bool linearize_enforced_constraints, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *activity_helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002051 (user): In LoadLinearConstraint() we already created intermediate
Booleans for each disjoint interval, we should reuse them here if
possible.&lt;p&gt; \anchor _todo002052 (user): process the "at most one" part of a == 1 separately? 
 &lt;p&gt; \anchor _todo002053 (user): Use cleaner "already loaded" logic, and mark as such constraint
already encoded by code like AppendRelaxationForEqualityEncoding(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a87160f650c0f35013f055fb81b3dfd30 "<a class="el" href="namespaceoperations__research_1_1sat.html#a87160f650c0f35013f055fb81b3dfd30">operations_research::sat::AppendLinMaxRelaxationPart1</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002066 (user): Support linear expression as target. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2184e325fd181f15124aa91c55fb0159 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2184e325fd181f15124aa91c55fb0159">operations_research::sat::AppendLinMaxRelaxationPart2</a>" (IntegerVariable target, absl::Span&lt; const Literal &gt; alternative_literals, absl::Span&lt; const LinearExpression &gt; exprs, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002050 (user): Remove hash_map ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9d126152f7618c43746d3f56577b803e "<a class="el" href="namespaceoperations__research_1_1sat.html#a9d126152f7618c43746d3f56577b803e">operations_research::sat::AppendMaxAffineRelaxation</a>" (const ConstraintProto &amp;ct, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002049 (user): experiment with:
  1) remove this code
  2) keep this code
  3) remove this code and create the cut generator at level 1. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af8a1aaff5bb36f1dfaf3daea8d5a076e "<a class="el" href="namespaceoperations__research_1_1sat.html#af8a1aaff5bb36f1dfaf3daea8d5a076e">operations_research::sat::AppendRelaxationForEqualityEncoding</a>" (IntegerVariable var, const Model &amp;model, LinearRelaxation *relaxation, int *num_tight, int *num_loose)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002040 (user): PartialDomainEncoding() filter pair corresponding to literal
set to false, however the initial variable Domain is not always updated. As
a result, these min/max can be larger than in reality. Try to fix this even
if in practice this is a rare occurrence, as the presolve should have
propagated most of what we can. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#abd42a035a99f910066d0a0356eff9ed6 "<a class="el" href="namespaceoperations__research_1_1sat.html#abd42a035a99f910066d0a0356eff9ed6">operations_research::sat::AppendSquareRelaxation</a>" (const ConstraintProto &amp;ct, Model *m, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002056 (user): We could add all or some below_hyperplans.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a1133b1086a2b84ebae1661a744df5a50 "<a class="el" href="namespaceoperations__research_1_1sat.html#a1133b1086a2b84ebae1661a744df5a50">operations_research::sat::ApplyLiteralMappingToBooleanProblem</a>" (const util_intops::StrongVector&lt; LiteralIndex, LiteralIndex &gt; &amp;mapping, LinearBooleanProblem *problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001120 (user): The names is currently all scrambled. Do something about it
so that non-fixed variables keep their names. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ArcGraphNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1ArcGraphNeighborhoodGenerator#a597c7e70c3f0260e498ff055dfd89d51 "<a class="el" href="classoperations__research_1_1sat_1_1ArcGraphNeighborhoodGenerator.html#a597c7e70c3f0260e498ff055dfd89d51">operations_research::sat::ArcGraphNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, SolveData &amp;data, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001257 (user): should we compress it or use a different representation ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::AssignmentInfo Member \_internalref structoperations__research_1_1sat_1_1AssignmentInfo#a2c118b72a43ea721d8c724184e7c54f6 "<a class="el" href="structoperations__research_1_1sat_1_1AssignmentInfo.html#a2c118b72a43ea721d8c724184e7c54f6">operations_research::sat::AssignmentInfo::level</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002278 (user): We may be able to get rid of that for faster enqueues. Most of
the code only need to know if this is 0 or the highest level, and for the
LBD computation, the literal of the conflict are already ordered by level,
so we could do it fairly efficiently.&lt;p&gt; \anchor _todo002279 (user): We currently don't support more than 2^28 decision levels. That
should be enough for most practical problem, but we should fail properly if
this limit is reached. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BasicKnapsackSolver Member \_internalref classoperations__research_1_1sat_1_1BasicKnapsackSolver#aed82b7ac647ae5bf0d661c41d26cdf48 "<a class="el" href="classoperations__research_1_1sat_1_1BasicKnapsackSolver.html#aed82b7ac647ae5bf0d661c41d26cdf48">operations_research::sat::BasicKnapsackSolver::Solve</a>" (absl::Span&lt; const Domain &gt; domains, absl::Span&lt; const int64_t &gt; coeffs, absl::Span&lt; const int64_t &gt; costs, const Domain &amp;rhs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002495 (user): We can also solve efficiently if max_activity - rhs.Min() is
small. Implement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae35ceb34b6366add1981140f6a173339 "<a class="el" href="namespaceoperations__research_1_1sat.html#ae35ceb34b6366add1981140f6a173339">operations_research::sat::BasicOrbitopeExtraction</a>" (absl::Span&lt; const std::unique_ptr&lt; SparsePermutation &gt; &gt; generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002458 (user): We could grow each and keep the real maximum. 
 &lt;p&gt; \anchor _todo002459 (user): Detect more than one orbitope? Note that once detected, the
structure can be exploited efficiently, but for now, a more "generic"
algorithm based on stabilizator should achieve the same preprocessing power,
so I don't know how hard we need to invest in orbitope detection.&lt;p&gt; \anchor _todo002460 (user): The heuristic is quite limited for now, but this works on
graph20-20-1rand.mps.gz. I suspect the generators provided by the detection
code follow our preconditions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Class \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html">operations_research::sat::BinaryImplicationGraph</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001168 (user): Most of the note below are done, but we currently only applies
the reduction before the solve. We should consider doing more in-processing.
The code could probably still be improved too.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ae18864358e7e3f0d4c9c7cf81e3757de "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ae18864358e7e3f0d4c9c7cf81e3757de">operations_research::sat::BinaryImplicationGraph::AddAtMostOne</a>" (absl::Span&lt; const Literal &gt; at_most_one)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001172 (user): Our algorithm could generalize easily to at_most_ones + a list
of literals that will be false if one of the literal in the amo is at one.
It is a way to merge common list of implications.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a76cf257e080c0b1fa5fd4b76f908e51c "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a76cf257e080c0b1fa5fd4b76f908e51c">operations_research::sat::BinaryImplicationGraph::AddBinaryClause</a>" (Literal a, Literal b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001138 (user): Not all of the solver knows about representative literal, do
use them here to maintains invariant? Explore this when we start cleaning our
clauses using equivalence during search. We can easily do it for every
conflict we learn instead of here. 
 &lt;p&gt; \anchor _todo001139 (user): Like this we will duplicate all binary clause from the
problem. However this leads to a simpler API (since we don't need to
special case the loading of the original clauses) and we mainly use drat
proof for testing anyway. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a07e88e219614208bf02f4bed078504f9 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a07e88e219614208bf02f4bed078504f9">operations_research::sat::BinaryImplicationGraph::ComputeTransitiveReduction</a>" (bool log_info=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001150 (user): Track which literal have new implications, and only process
the antecedents of these. 
 &lt;p&gt; \anchor _todo001151 (user): the situation with fixed variable is not really "clean".
Simplify the code so we are sure we don't run into issue or have to deal
with any of that here. 
 &lt;p&gt; \anchor _todo001152 (user): We should be able to reuse some propagation like it is done for
tree-look. Once a node is processed, we just need to process a node that
implies it. Test if we can make this faster. Alternatively, only clear
a part of is_marked_ (after the first child of root in reverse topo order).&lt;p&gt; \anchor _todo001153 (user): Can we exploit the fact that the implication graph is a
skew-symmetric graph (isomorphic to its transposed) so that we do less
work? 
 &lt;p&gt; \anchor _todo001154 (user): Another optim we can do is that we never need to expand
any node with a reverse topo order smaller or equal to the min of the
ones in this list. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aa80bafd5aaf59cc6c7a67176c6304239 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa80bafd5aaf59cc6c7a67176c6304239">operations_research::sat::BinaryImplicationGraph::DetectEquivalences</a>" (bool log_info=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001148 (user): We could just do it directly though.
 &lt;p&gt; \anchor _todo001149 (user): Maybe a better alternative is to not propagate when we fix
variables inside CleanUpAndAddAtMostOnes(). 
 &lt;p&gt; \anchor _todo001173 (user): Completely get rid of such literal instead? it might not be
reasonable code-wise to remap our literals in all of our constraints
though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ab589014979b15460c0cb295527097731 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab589014979b15460c0cb295527097731">operations_research::sat::BinaryImplicationGraph::DirectImplications</a>" (Literal literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001166 (user): lazy cleanup the lists on is_removed_?
 &lt;p&gt; &lt;p&gt;(user): Mark fixed variable as is_removed_ for faster iteration? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#af82f4ac499358536858b414345c0b13e "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#af82f4ac499358536858b414345c0b13e">operations_research::sat::BinaryImplicationGraph::EnableSharing</a>" (bool enable)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001171 (user): this is meant to share clause between workers, hopefully the
contention will not be too high. Double check and maybe add a batch version
were we keep new implication and add them in batches. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a2735353cc3b14a2ef6574ad9f52c06b7 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a2735353cc3b14a2ef6574ad9f52c06b7">operations_research::sat::BinaryImplicationGraph::ExtractAllBinaryClauses</a>" (Output *out) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001177 (user): When extracting to cp_model.proto we could be more efficient
by extracting bool_and constraint with many lhs terms. 
 &lt;p&gt; \anchor _todo001178 (user): Ideally we should just never have duplicate clauses in this
class. But it seems we do in some corner cases, so lets not output them
twice. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a2373a5130643f372ad3acc9e26622a01 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a2373a5130643f372ad3acc9e26622a01">operations_research::sat::BinaryImplicationGraph::GenerateAtMostOnesWithLargeWeight</a>" (absl::Span&lt; const Literal &gt; literals, absl::Span&lt; const double &gt; lp_values, absl::Span&lt; const double &gt; reduced_costs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001159 (user): For large problems or when we base the clique from a newly
added and violated 2-clique, we might consider only a subset of
fractional variables, so we might need to include fractional variable
first, but then their rc should be zero, so it should be already kind of
doing that.&lt;p&gt; \anchor _todo001160 (user): Prefer more fractional variables. 
 &lt;p&gt; \anchor _todo001161 (user): Treat at_most_one more efficiently. We can collect them
and scan each of them just once. 
 &lt;p&gt; \anchor _todo001162 (user): Expansion is pretty slow. Given that the base clique can
share literal beeing part of the same amo, we should be able to speed
that up, we don't want to scan an amo twice basically. 
 &lt;p&gt; \anchor _todo001175 (user): Refine the heuristic and unit test! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#af1d6fe0884e39f01edd6512ea6a7ce1c "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#af1d6fe0884e39f01edd6512ea6a7ce1c">operations_research::sat::BinaryImplicationGraph::HeuristicAmoPartition</a>" (std::vector&lt; Literal &gt; *literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001163 (user): Use deterministic limit.
 &lt;p&gt; &lt;p&gt;(user): Explore the graph instead of just looking at full amo, especially
since we expand small ones. 
 &lt;p&gt; \anchor _todo001176 (user): Add a limit to make sure this do not take too much time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ac0bb723bcd57582fa936d7e227d9c2e9 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ac0bb723bcd57582fa936d7e227d9c2e9">operations_research::sat::BinaryImplicationGraph::MergeAtMostOnes</a>" (absl::Span&lt; std::vector&lt; Literal &gt; &gt; at_most_ones, int64_t max_num_explored_nodes=1e8, double *dtime=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001157 (user): We should process clique with elements in common together so
that we can reuse MarkDescendants() which is slow. We should be able to
"cache" a few of the last calls. 
 &lt;p&gt; \anchor _todo001158 (user): next_index_to_try help, but we might still rescan most of
the one-watcher list of intersection[next_index_to_try], we could be
a bit faster here. 
 &lt;p&gt; \anchor _todo001174 (user): Switch to a dtime limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#aa37e2a622549d733c3bbb8b340f3c473 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#aa37e2a622549d733c3bbb8b340f3c473">operations_research::sat::BinaryImplicationGraph::MinimizeConflictExperimental</a>" (const Trail &amp;trail, std::vector&lt; Literal &gt; *c)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001145 (user): Also consider at most one?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#ab5846564f39bf6ba28ecdced8429d492 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#ab5846564f39bf6ba28ecdced8429d492">operations_research::sat::BinaryImplicationGraph::MinimizeConflictFirst</a>" (const Trail &amp;trail, std::vector&lt; Literal &gt; *c, SparseBitset&lt; BooleanVariable &gt; *marked)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001144 (user): if this is false, then we actually have a conflict of size 2.
This can only happen if the binary clause was not propagated properly
if for instance we do chronological bactracking without re-enqueuing the
consequence of a binary clause. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a3cbe67b46860621bfa57c87f5247a385 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a3cbe67b46860621bfa57c87f5247a385">operations_research::sat::BinaryImplicationGraph::MinimizeConflictWithReachability</a>" (std::vector&lt; Literal &gt; *c)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001142 (user): Also consider at most one? 
 &lt;p&gt; \anchor _todo001143 (user): This sounds like a good idea, but somehow it seems better not
to do that even though it is almost for free. Investigate more.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a7e4e6130c59dffa6ab52a1cff24400a2 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a7e4e6130c59dffa6ab52a1cff24400a2">operations_research::sat::BinaryImplicationGraph::RemoveFixedVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001146 (user): This might not be true if we remove implication by
transitive reduction and the process was aborted due to the computation
limit. I think it will be good to maintain that invariant though,
otherwise fixed literals might never be removed from these lists... 
 &lt;p&gt; \anchor _todo001147 (user): This might be a bit slow. Do not call all the time if needed,
this shouldn't change the correctness of the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryImplicationGraph Member \_internalref classoperations__research_1_1sat_1_1BinaryImplicationGraph#a4a7ae378f427890ed11dfa8efb7c1db7 "<a class="el" href="classoperations__research_1_1sat_1_1BinaryImplicationGraph.html#a4a7ae378f427890ed11dfa8efb7c1db7">operations_research::sat::BinaryImplicationGraph::TransformIntoMaxCliques</a>" (std::vector&lt; std::vector&lt; Literal &gt; &gt; *at_most_ones, int64_t max_num_explored_nodes=1e8)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001156 (user): Detect on the fly is superset already exist. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryRelationRepository Class \_internalref classoperations__research_1_1sat_1_1BinaryRelationRepository "<a class="el" href="classoperations__research_1_1sat_1_1BinaryRelationRepository.html">operations_research::sat::BinaryRelationRepository</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002189 (user): This is not always needed, find a way to clean this once we
don't need it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BinaryRelationRepository Member \_internalref classoperations__research_1_1sat_1_1BinaryRelationRepository#aae199244ab63b9373dd98d51bf5f389c "<a class="el" href="classoperations__research_1_1sat_1_1BinaryRelationRepository.html#aae199244ab63b9373dd98d51bf5f389c">operations_research::sat::BinaryRelationRepository::PropagateLocalBounds</a>" (const IntegerTrail &amp;integer_trail, Literal lit, const absl::flat_hash_map&lt; IntegerVariable, IntegerValue &gt; &amp;input, absl::flat_hash_map&lt; IntegerVariable, IntegerValue &gt; *output) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002186 (user): we might do that earlier? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BlockedClauseSimplifier Class \_internalref classoperations__research_1_1sat_1_1BlockedClauseSimplifier "<a class="el" href="classoperations__research_1_1sat_1_1BlockedClauseSimplifier.html">operations_research::sat::BlockedClauseSimplifier</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002351 (user): This requires that l only appear in clauses and not in the
integer part of CP-SAT. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac341ac6090ff0bed8ad2231c94cd3bfc "<a class="el" href="namespaceoperations__research_1_1sat.html#ac341ac6090ff0bed8ad2231c94cd3bfc">operations_research::sat::BooleanLinearConstraint</a>" (int64_t lower_bound, int64_t upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002393 (user): move them in another file, and unit-test them.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a937ae99fd6f6c445a8aad34f04222a1a "<a class="el" href="namespaceoperations__research_1_1sat.html#a937ae99fd6f6c445a8aad34f04222a1a" title="Returns true iff the Boolean linear expression is in canonical form.">operations_research::sat::BooleanLinearExpressionIsCanonical</a>" (absl::Span&lt; const LiteralWithCoeff &gt; cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002127 (user): Also check for no duplicates literals + unit tests.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BooleanOrIntegerVariable Struct \_internalref structoperations__research_1_1sat_1_1BooleanOrIntegerVariable "<a class="el" href="structoperations__research_1_1sat_1_1BooleanOrIntegerVariable.html">operations_research::sat::BooleanOrIntegerVariable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001898 (user): This is currently quadratic as we scan all variables to find the
first unassigned one. Fix. Note that this is also the case in many other
heuristics and should be fixed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BooleanXorPropagator Class \_internalref classoperations__research_1_1sat_1_1BooleanXorPropagator "<a class="el" href="classoperations__research_1_1sat_1_1BooleanXorPropagator.html">operations_research::sat::BooleanXorPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001198 (user): By using a two watcher mechanism, we can propagate this a lot
faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BoolRLTCutHelper Member \_internalref classoperations__research_1_1sat_1_1BoolRLTCutHelper#a06106288eec90bbe9cf46ac3712de757 "<a class="el" href="classoperations__research_1_1sat_1_1BoolRLTCutHelper.html#a06106288eec90bbe9cf46ac3712de757" title="Tries RLT separation of the input constraint. Returns true on success.">operations_research::sat::BoolRLTCutHelper::TrySimpleSeparation</a>" (const CutData &amp;input_ct)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001675 (user): do less work, add more stats.
 &lt;p&gt; \anchor _todo001676 (user): detect earlier that a factor is not worth checking because
we already loose too much with the DROP/MC_CORMICK cases ? Filter more ?
I think we can probably evaluate the factor efficiency during the first
loop which usually have a small complexity compared to num_factor_to_try
times num filtered terms. 
 &lt;p&gt; \anchor _todo001677 (user): we never use factor with lp value &lt; 1e-4, but we could use a
factor equal to 1.0 I think. Double check. 
 &lt;p&gt; \anchor _todo001678 (user): We could keep for each factor the max gain, so that we
can decided if it is not even worth trying a factor. 
 &lt;p&gt; \anchor _todo001679 (user): Avoid constructing the cut just to evaluate its efficacy.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::BoundedVariableElimination Member \_internalref classoperations__research_1_1sat_1_1BoundedVariableElimination#a8d5a5e9f809d97c6dc3cbc5d948f4a51 "<a class="el" href="classoperations__research_1_1sat_1_1BoundedVariableElimination.html#a8d5a5e9f809d97c6dc3cbc5d948f4a51">operations_research::sat::BoundedVariableElimination::DoOneRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002337 (user): but we shouldn't keep clauses containing removed literals.
It is still valid to do so, but it should be less efficient. 
 &lt;p&gt; \anchor _todo002338 (user): add a local dtime limit for the corner case where this take too
much time. We can adapt the limit depending on how much we want to spend on
inprocessing. 
 &lt;p&gt; \anchor _todo002339 (user): we might also find new equivalent variable l =&gt; var =&gt; l
here, but for now we ignore those. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CachedTaskBounds Struct \_internalref structoperations__research_1_1sat_1_1CachedTaskBounds "<a class="el" href="structoperations__research_1_1sat_1_1CachedTaskBounds.html">operations_research::sat::CachedTaskBounds</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002417 (user): Experiment caching more value. In particular
TaskByIncreasingShiftedStartMin() could tie break task for better heuristics? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CanonicalBooleanLinearProblem Class \_internalref classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem "<a class="el" href="classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem.html">operations_research::sat::CanonicalBooleanLinearProblem</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002141 (user): Simplify further the constraints.&lt;p&gt; \anchor _todo002142 (user): Remove the duplication between this and what the sat solver
is doing in AddLinearConstraint() which is basically the same.&lt;p&gt; \anchor _todo002143 (user): Remove duplicate constraints? some problems have them, and
this is not ideal for the symmetry computation since it leads to a lot of
symmetries of the associated graph that are not useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CanonicalBooleanLinearProblem Member \_internalref classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem#ad91fdf3c0b3d6b5f52ab35e1ea1cfd31 "<a class="el" href="classoperations__research_1_1sat_1_1CanonicalBooleanLinearProblem.html#ad91fdf3c0b3d6b5f52ab35e1ea1cfd31">operations_research::sat::CanonicalBooleanLinearProblem::AddLinearConstraint</a>" (bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002145 (user): Use a return status to distinguish errors if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a016498efd7ac3ee90eb0d00b38b0d061 "<a class="el" href="namespaceoperations__research_1_1sat.html#a016498efd7ac3ee90eb0d00b38b0d061">operations_research::sat::CanonicalizeLinearExpressionInternal</a>" (absl::Span&lt; const int &gt; enforcements, ProtoWithVarsAndCoeffs *proto, int64_t *offset, std::vector&lt; std::pair&lt; int, int64_t &gt; &gt; *tmp_terms, PresolveContextT *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002219 (user): Add a quick pass to skip most of the work below if the
constraint is already in canonical form? 
 &lt;p&gt; \anchor _todo002220 (user): Avoid the quadratic loop for the corner case of many
enforcement literal (this should be pretty rare though). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3f5064fe335d0bd2f67a8c9e3e132b4f "<a class="el" href="namespaceoperations__research_1_1sat.html#a3f5064fe335d0bd2f67a8c9e3e132b4f">operations_research::sat::CeilSquareRoot</a>" (int64_t a)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002494 (user): Find better implementation?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitCoveringPropagator Class \_internalref classoperations__research_1_1sat_1_1CircuitCoveringPropagator "<a class="el" href="classoperations__research_1_1sat_1_1CircuitCoveringPropagator.html">operations_research::sat::CircuitCoveringPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001130 (user): Make distinguished nodes an array of Boolean variables,
so this can be used for facility location problems. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitPropagator Member \_internalref classoperations__research_1_1sat_1_1CircuitPropagator#a54823f9c1557fcb9ee85d3c28c329bf0 "<a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html#a54823f9c1557fcb9ee85d3c28c329bf0">operations_research::sat::CircuitPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001123 (user): both this and the loop on must_be_in_cycle_ might take some
time on large graph. Optimize if this become an issue. 
 &lt;p&gt; \anchor _todo001124 (user): we can fail early in more case, like no more possible path
to any of the mandatory node. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CircuitPropagator Member \_internalref classoperations__research_1_1sat_1_1CircuitPropagator#a05dbff53ce702fea3c1b8dbd913a3228 "<a class="el" href="classoperations__research_1_1sat_1_1CircuitPropagator.html#a05dbff53ce702fea3c1b8dbd913a3228">operations_research::sat::CircuitPropagator::RegisterWith</a>" (GenericLiteralWatcher *watcher)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001122 (user): come up with a test that fail when this is not here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a445ddafc05cd8e1a75db81c1c4426179 "<a class="el" href="namespaceoperations__research_1_1sat.html#a445ddafc05cd8e1a75db81c1c4426179">operations_research::sat::ClauseIsEnforcementImpliesLiteral</a>" (absl::Span&lt; const int &gt; clause, absl::Span&lt; const int &gt; enforcement, int literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002234 (user): For the same complexity, we do not need to specify literal and
can recover it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a65d15a1a1d08387cb9f9e58e0e153540 "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a65d15a1a1d08387cb9f9e58e0e153540">operations_research::sat::ClauseManager::DeleteRemovedClauses</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001137 (user): If more indices are needed, generalize the code to a vector of
indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a4bb2615bf56f39aa7a070d8f4b2b8d03 "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a4bb2615bf56f39aa7a070d8f4b2b8d03">operations_research::sat::ClauseManager::Detach</a>" (SatClause *clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001169 (user): It might be better to have a "slower" mode in
PropagateOnFalse() that deal with detached clauses in the watcher list and
is activated until the next CleanUpWatchers() calls. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a00f87aaf6e3bf62d2de2f2c21f3f9d0b "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a00f87aaf6e3bf62d2de2f2c21f3f9d0b">operations_research::sat::ClauseManager::InprocessingAddClause</a>" (absl::Span&lt; const Literal &gt; new_clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001136 (user): We should return false...
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#ad50ac50e7697b1f7dbbaa750fd94cffa "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#ad50ac50e7697b1f7dbbaa750fd94cffa" title="This one do not need the clause to be detached.">operations_research::sat::ClauseManager::InprocessingFixLiteral</a>" (Literal true_literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001134 (user): remove the test when the DRAT issue with fixed literal is
resolved. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ClauseManager Member \_internalref classoperations__research_1_1sat_1_1ClauseManager#a19e5abfaaedf626fcfd0d44dd827fc24 "<a class="el" href="classoperations__research_1_1sat_1_1ClauseManager.html#a19e5abfaaedf626fcfd0d44dd827fc24" title="These must only be called between [Detach/Attach]AllClauses() calls.">operations_research::sat::ClauseManager::InprocessingRemoveClause</a>" (SatClause *clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001135 (user): We could do something slower if the clauses are attached like
we do for InprocessingRewriteClause(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CombinedDisjunctive Member \_internalref classoperations__research_1_1sat_1_1CombinedDisjunctive#ac88bd295048bf30b8726c9f600587287 "<a class="el" href="classoperations__research_1_1sat_1_1CombinedDisjunctive.html#ac88bd295048bf30b8726c9f600587287">operations_research::sat::CombinedDisjunctive&lt; time_direction &gt;::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001715 (user): AddEntry() and ComputeEndMin() could be combined.
 &lt;p&gt; \anchor _todo001716 (user): Maybe factor out the code? It does require a function with a
lot of arguments though. 
 &lt;p&gt; \anchor _todo001717 (user): Refactor the code to use the same algo as in
DisjunctiveDetectablePrecedences, it is superior and do not need
this function. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CompiledNoOverlap2dConstraint Member \_internalref classoperations__research_1_1sat_1_1CompiledNoOverlap2dConstraint#a10a4629693ae0553eacd5b7e28f2bb54 "<a class="el" href="classoperations__research_1_1sat_1_1CompiledNoOverlap2dConstraint.html#a10a4629693ae0553eacd5b7e28f2bb54">operations_research::sat::CompiledNoOverlap2dConstraint::ComputeViolation</a>" (absl::Span&lt; const int64_t &gt; solution) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001189 (user): Experiment with
violation +=
    std::max(std::min(NoOverlapMinRepairDistance(x_i, x_j, solution),
                      NoOverlapMinRepairDistance(y_i, y_j, solution)),
             int64_t{0});
Currently, the effect is unclear on 2d packing problems. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CompiledReservoirConstraint Member \_internalref classoperations__research_1_1sat_1_1CompiledReservoirConstraint#a2821a81e871d03153a3d610090648043 "<a class="el" href="classoperations__research_1_1sat_1_1CompiledReservoirConstraint.html#a2821a81e871d03153a3d610090648043" title="Updates the violation with the new value.">operations_research::sat::CompiledReservoirConstraint::PerformMove</a>" (int, int64_t, absl::Span&lt; const int64_t &gt; solution_with_new_value) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001194 (user): we could probably be more incremental here, but it is a bit
tricky to get right and not too important since the time is dominated by
evaluating moves, not taking them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a34cc8829256ea003a3f538b06d3a3a74 "<a class="el" href="namespaceoperations__research_1_1sat.html#a34cc8829256ea003a3f538b06d3a3a74" title="Builds the linear relaxation of a CpModelProto.">operations_research::sat::ComputeLinearRelaxation</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002060 (user): Should we add them to the LP anyway? this isn't clear as
we can sometimes create a lot of Booleans like this. 
 &lt;p&gt; \anchor _todo002061 (user): This is similar to AppendRelaxationForEqualityEncoding() above.
Investigate if we can merge the code. 
 &lt;p&gt; \anchor _todo002062 (user): I am not sure this is still needed. Investigate and explain why
or remove. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac47959359a009b02531ab19f206cdd54 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac47959359a009b02531ab19f206cdd54">operations_research::sat::ComputeTrueObjectiveLowerBound</a>" (const CpModelProto &amp;model_proto_with_floating_point_objective, const CpObjectiveProto &amp;integer_objective, const int64_t inner_integer_objective_lower_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002080 (user): Code a custom algo with more precision guarantee? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a6789b92ff0403313af6cb313636d1317 "<a class="el" href="namespaceoperations__research_1_1sat.html#a6789b92ff0403313af6cb313636d1317">operations_research::sat::ConditionalWeightedSumLowerOrEqual</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const int64_t &gt; coefficients, int64_t upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001854 (user): Delete once Telamon use new function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a08ac4c44a4524b21806a1ae9839bc5bd "<a class="el" href="namespaceoperations__research_1_1sat.html#a08ac4c44a4524b21806a1ae9839bc5bd">operations_research::sat::ConfigureSearchHeuristics</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001885 (user): We might want to restart if external info is available.
Code a custom restart for this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ConstraintPropagationOrder Member \_internalref classoperations__research_1_1sat_1_1ConstraintPropagationOrder#a71728e275e36bbedaaa8007d56131730 "<a class="el" href="classoperations__research_1_1sat_1_1ConstraintPropagationOrder.html#a71728e275e36bbedaaa8007d56131730">operations_research::sat::ConstraintPropagationOrder::NextId</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002038 (user): fix quadratic algo? We can use var_to_ids_func_() to maintain
the degree. But note that with the start_ optim and because we expect
mainly degree zero, this seems to be faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a807f0da8a99a471e809213176132588f "<a class="el" href="namespaceoperations__research_1_1sat.html#a807f0da8a99a471e809213176132588f" title="Constructs a search strategy tailored for the current model.">operations_research::sat::ConstructHeuristicSearchStrategy</a>" (const CpModelProto &amp;cp_model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001511 (user): Implement a routing search.
 &lt;p&gt; \anchor _todo001512 (user): Alternatively, support creation of SatPropagator at positive
level. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a40aa243acb668c453deb8600ab80b38a "<a class="el" href="namespaceoperations__research_1_1sat.html#a40aa243acb668c453deb8600ab80b38a" title="Constructs an integer completion search strategy.">operations_research::sat::ConstructIntegerCompletionSearchStrategy</a>" (absl::Span&lt; const IntegerVariable &gt; variable_mapping, IntegerVariable objective_var, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001513 (user): we could also fix terms of the objective in the right
direction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7ca3e1768bf680ee6b3bbec72f4d0955 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7ca3e1768bf680ee6b3bbec72f4d0955">operations_research::sat::ConstructOverlappingSets</a>" (absl::Span&lt; IndexedInterval &gt; intervals, CompactVectorVector&lt; int &gt; *result, absl::Span&lt; const int &gt; order)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001708 (user): we could only do that when we push a new set. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab621abdbab919d365ca747aebdd2ff74 "<a class="el" href="namespaceoperations__research_1_1sat.html#ab621abdbab919d365ca747aebdd2ff74" title="Constructs the search strategy specified in the given CpModelProto.">operations_research::sat::ConstructUserSearchStrategy</a>" (const CpModelProto &amp;cp_model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001510 (user): Improve the complexity if this becomes an issue which
may be the case if we do a fixed_search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ContinuousProber Member \_internalref classoperations__research_1_1sat_1_1ContinuousProber#a1e83f97c78745b456678edb911c2147c "<a class="el" href="classoperations__research_1_1sat_1_1ContinuousProber.html#a1e83f97c78745b456678edb911c2147c" title="The model_proto is just used to construct the lists of variable to probe.">operations_research::sat::ContinuousProber::ContinuousProber</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001894 (user): Ideally, we should scan the internal model. But there can be
a large blowup of variables during loading, which slows down the probing
part. Using model variables is a good heuristic to select 'impactful'
Boolean variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ContinuousProber Member \_internalref classoperations__research_1_1sat_1_1ContinuousProber#a1de4d4b22a2717e58b2444683a806d22 "<a class="el" href="classoperations__research_1_1sat_1_1ContinuousProber.html#a1de4d4b22a2717e58b2444683a806d22">operations_research::sat::ContinuousProber::Probe</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001895 (user):
  - sort variables before the iteration (statically or dynamically)
  - compress clause databases regularly (especially the implication graph)
  - better interleaving of the probing and shaving phases
  - move the shaving code directly in the probing class
  - probe all variables and not just the model ones 
 &lt;p&gt; \anchor _todo001896 (user): Probe optional variables. 
 &lt;p&gt; \anchor _todo001897 (user): Currently, the heuristics is that we alternate shaving and
not shaving, unless use_shaving_in_probing_search is false. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac9c41d8a7687386839ef94182e3badb9 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac9c41d8a7687386839ef94182e3badb9">operations_research::sat::ConvertCpModelProtoToMPModelProto</a>" (const CpModelProto &amp;input, MPModelProto *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002072 (user): Support more constraints with enforcement.
 &lt;p&gt; \anchor _todo002079 (user): This first version do not even handle basic Boolean constraint.
Support more constraints as needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2d32bfb7e130364f3dd94087b686b6f5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2d32bfb7e130364f3dd94087b686b6f5">operations_research::sat::ConvertMPModelProtoToCpModelProto</a>" (const SatParameters &amp;params, const MPModelProto &amp;mp_model, CpModelProto *cp_model, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002070 (user): This could be made larger if needed, so be smarter if we have
MIP problem that we cannot "convert" because of this. Note however than we
cannot go that much further because we need to make sure we will not run
into overflow if we add a big linear combination of such variables. It
should always be possible for a user to scale its problem so that all
relevant quantities are a couple of millions. A LP/MIP solver have a
similar condition in disguise because problem with a difference of more
than 6 magnitudes between the variable values will likely run into numeric
trouble. 
 &lt;p&gt; \anchor _todo002071 (user): We could avoid these cases by shifting the domain of
all variables to contain zero. This should also lead to a better scaling,
but it has some complications with integer variables and require some
post-solve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoreBasedOptimizer Member \_internalref classoperations__research_1_1sat_1_1CoreBasedOptimizer#ab0a342f8fad2c4262b0ddec85b98bdf8 "<a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html#ab0a342f8fad2c4262b0ddec85b98bdf8">operations_research::sat::CoreBasedOptimizer::Optimize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002108 (user): Try to understand exactly why and merge both code path. 
 &lt;p&gt; \anchor _todo002109 (user): It might be interesting to redo this kind of presolving
once high cost booleans have been fixed as we might have more at most
one between literal in the objective by then.&lt;p&gt; \anchor _todo002110 (user): The core is returned in the same order as the assumptions,
so we don't really need this map, we could just do a linear scan to
recover which node are part of the core. This however needs to be properly
unit tested before usage. 
 &lt;p&gt; \anchor _todo002111 (user): This always resets the solver to level zero.
Because of that we don't resume a solve in "chunk" perfectly. Fix. 
 &lt;p&gt; \anchor _todo002112 (user): If the search is aborted during this phase and we solve in
"chunk", we don't resume perfectly from where it was. Fix. 
 &lt;p&gt; \anchor _todo002113 (user): These can be simply removed from the list.
 &lt;p&gt; \anchor _todo002114 (user): we could keep an objective offset instead. 
 &lt;p&gt; \anchor _todo002115 (user): We can probably be smarter about the cost of the
assumptions though. 
 &lt;p&gt; \anchor _todo002116 (user): If the "search" is interrupted while computing cores, we
currently do not resume it flawlessly. We however add any cores we found
before aborting. 
 &lt;p&gt; \anchor _todo002117 (user): Maybe the solver should do it right away. 
 &lt;p&gt; \anchor _todo002122 (user): Change the algo slighlty to allow resuming from the last
aborted position. Currently, the search is "resumable", but it will restart
some of the work already done, so it might just never find anything. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoreBasedOptimizer Member \_internalref classoperations__research_1_1sat_1_1CoreBasedOptimizer#a5a4a53c17d32408e49285f11171673fa "<a class="el" href="classoperations__research_1_1sat_1_1CoreBasedOptimizer.html#a5a4a53c17d32408e49285f11171673fa">operations_research::sat::CoreBasedOptimizer::OptimizeWithSatEncoding</a>" (absl::Span&lt; const Literal &gt; literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const Coefficient &gt; coefficients, Coefficient offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002101 (user): We could create EncodingNode out of IntegerVariable.&lt;p&gt; \anchor _todo002102 (user): It could still be beneficial to add one. Experiments. 
 &lt;p&gt; \anchor _todo002103 (user): This might not be ideal if there are holes in the domain.
It should work by adding duplicates literal, but we should be able to
be more efficient. 
 &lt;p&gt; \anchor _todo002104 (user): Find multiple core like in the "main" algorithm. This is just
trying to solve with assumptions not involving the newly found core.&lt;p&gt; \anchor _todo002105 (user): With stratification, sometime we just spend too much time
trying to find a feasible solution/prove infeasibility and we could
instead just use stratification=0 to find easty core and improve lower
bound. 
 &lt;p&gt; \anchor _todo002123 (user):
- Support resuming for interleaved search.
- Implement all core heurisitics. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#a29be1489d397a5d646a838946a85a225 "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#a29be1489d397a5d646a838946a85a225">operations_research::sat::CoverCutHelper::TrySimpleKnapsack</a>" (const CutData &amp;input_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001663 (user): we don't have to pick max_coeff_in_cover and could use the
coefficient of the most fractional variable. Or like in the MIR code try
a few of them. Currently, the cut in the test is worse if we don't take
the max_coeff_in_cover though, so we need more understanding.&lt;p&gt; \anchor _todo001664 (user): It seems we could use a more advanced lifting function
described later in the paper. Investigate. 
 &lt;p&gt; \anchor _todo001665 (user): Experiment without this line that basically disable scoring.
 &lt;p&gt; \anchor _todo001666 (user): experiment with different value of scaling and param t.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#abf54256e1bd003c568c2efd55d75fdd6 "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#abf54256e1bd003c568c2efd55d75fdd6">operations_research::sat::CoverCutHelper::TrySingleNodeFlow</a>" (const CutData &amp;input_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001667 (user): Change the heuristic to depends on the lp_value of the implied
bounds. This way we can exactly match what happen in the old
FlowCoverCutHelper. 
 &lt;p&gt; \anchor _todo001668 (user): Shouldn't we just use rounding f() with maximum coeff to allows
lift of all other terms? but then except for the heuristic the cut is
really similar to the cover cut. 
 &lt;p&gt; \anchor _todo001669 (user): If the Mir*() function is used, we don't need to extend that
much the period. Fix. 
 &lt;p&gt; \anchor _todo001670 (user): do exact binary search to find highest x in
[-max_neg_magnitude, 0] such that f(x) == f(-max_neg_magnitude) ? not
really needed though since we know that we have this equality: 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CoverCutHelper Member \_internalref classoperations__research_1_1sat_1_1CoverCutHelper#a82f509c2f8c4ea40561f572f6a612ebd "<a class="el" href="classoperations__research_1_1sat_1_1CoverCutHelper.html#a82f509c2f8c4ea40561f572f6a612ebd">operations_research::sat::CoverCutHelper::TryWithLetchfordSouliLifting</a>" (const CutData &amp;input_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001671 (user): Merge Boolean terms that are complement of each other. 
 &lt;p&gt; \anchor _todo001672 (user): we currently only deal with Boolean in the cover. Fix.
 &lt;p&gt; \anchor _todo001673 (user): compute this in an overflow-safe way.
 &lt;p&gt; \anchor _todo001674 (user): For exact multiple of p/q we can increase the coeff by 1/2.
See section in the paper on getting maximal super additive function. 
 &lt;p&gt; \anchor _todo001695 (user): Generalize to non-Boolean, or use a different cover heuristic
for this:
- We want a Boolean only cover currently.
- We can always use implied bound for this, since there is more chance
  for a Bool only cover.
- Also, f() should be super additive on the value &lt;= rhs, i.e. f(a + b) &gt;=
  f(a) + f(b), so it is always good to use implied bounds of the form X =
  bound * B + Slack. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelMapping Member \_internalref classoperations__research_1_1sat_1_1CpModelMapping#a58809f5b0a739fa62cf923b2ed919df5 "<a class="el" href="classoperations__research_1_1sat_1_1CpModelMapping.html#a58809f5b0a739fa62cf923b2ed919df5">operations_research::sat::CpModelMapping::Affine</a>" (const LinearExpressionProto &amp;exp) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001303 (user): We could "easily" create an intermediate variable for more
complex linear expression. We could also identify duplicate expressions to
not create two identical integer variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Class \_internalref classoperations__research_1_1sat_1_1CpModelPresolver "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html">operations_research::sat::CpModelPresolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001504 (user): Identify disconnected components and returns a vector of
presolved model? If we go this route, it may be nicer to store the indices
inside the model. We can add a IntegerVariableProto::initial_index; 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Member \_internalref classoperations__research_1_1sat_1_1CpModelPresolver#a0d7a189b32ff5ccd484556256a04dc83 "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a0d7a189b32ff5ccd484556256a04dc83" title="Detects variable that must take different values.">operations_research::sat::CpModelPresolver::DetectDifferentVariables</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001439 (user): On that same problem, we could actually just have x != y and
remove the enforcement literal that is just used for that. But then we
will just re-create it, since we don't have a native way to handle x != y.&lt;p&gt; \anchor _todo001440 (user): Again on neos16.mps, we actually have cliques of x != y so we
end up with a bunch of groups of 7 variables in [0, 6] that are all
different. If we can detect that, then we close the problem quickly instead
of not closing it. 
 &lt;p&gt; \anchor _todo001441 (user): Handle this case?
 &lt;p&gt; \anchor _todo001442 (user): To avoid doing that more than once, we only run it if there
is no all-diff in the model already. This is not perfect.&lt;p&gt; \anchor _todo001443 (user): Start with the existing all diff and expand them rather than
not running this if there are all_diff present.&lt;p&gt; \anchor _todo001444 (user): Only add them at the end of the presolve! it hurt our presolve
(like probing is slower) and only serve for linear relaxation. 
 &lt;p&gt; \anchor _todo001445 (user): try to remove all the quadratic boolean and their
corresponding linear2 ? Any Boolean not used elsewhere could be
removed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Member \_internalref classoperations__research_1_1sat_1_1CpModelPresolver#a6b247edecbebdff3fadbd7661e484b9a "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a6b247edecbebdff3fadbd7661e484b9a">operations_research::sat::CpModelPresolver::DetectDuplicateColumns</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001427 (user): deal with enforcement_literal, especially bool_and. It is a bit
annoying to have to deal with all kind of constraints. Maybe convert
bool_and to at_most_one first? We already do that in other places. Note
however that an at most one of size 2 means at most 2 columns can be
identical. If we have a bool and with many term on the left, all column
could be indentical, but we have to linearize the constraint first. 
 &lt;p&gt; \anchor _todo001428 (user): deal with equivalent column with different objective value.
It might not be easy to presolve, but we can at least have a single
variable = sum of var appearing only in objective. And we can transfer the
min cost. 
 &lt;p&gt; \anchor _todo001429 (user): If we have duplicate columns appearing in Boolean constraint
we can only easily substitute if the sum of columns is a Boolean (i.e. if
it appear in an at most one or exactly one). Otherwise we will need to
transform such constraint to linear, do that? 
 &lt;p&gt; \anchor _todo001430 (user): maybe converting to linear + single code is better? 
 &lt;p&gt; \anchor _todo001431 (user): clear amo/exo of size 1.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelPresolver Member \_internalref classoperations__research_1_1sat_1_1CpModelPresolver#a4eea655cfbd484263d86d3d89af42bf5 "<a class="el" href="classoperations__research_1_1sat_1_1CpModelPresolver.html#a4eea655cfbd484263d86d3d89af42bf5">operations_research::sat::CpModelPresolver::Presolve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001487 (user): We should probably try to delay this even more. For that we
just need to isolate more the "dual" reduction that usually need to look at
the objective. 
 &lt;p&gt; \anchor _todo001488 (user): The presolve transformations we do after this is called might
result in even more presolve if we were to call this again! improve the
code. See for instance plusexample_6_sat.fzn were represolving the
presolved problem reduces it even more. 
 &lt;p&gt; \anchor _todo001489 (user): Decide where is the best place for this.&lt;p&gt; \anchor _todo001490 (user): try not to break symmetry in our clique extension or other
more advanced presolve rule? Ideally we could even exploit them. But in
this case, it is still good to compute them early. 
 &lt;p&gt; \anchor _todo001491 (user): Maybe this is a bit brittle. Also move this logic to
DetectAndAddSymmetryToProto() ? 
 &lt;p&gt; \anchor _todo001492 (user): more generally if we do some probing, the same relation will
be detected (and more). Also add an option to turn this off?&lt;p&gt; \anchor _todo001493 (user): instead of extracting at most one, extract pairwise conflicts
and add them to bool_and clauses? this is some sort of small scale
probing, but good for sat presolve and clique later? 
 &lt;p&gt; \anchor _todo001494 (user): revisit when different transformation appear.
&lt;p&gt; \anchor _todo001495 &lt;p&gt; \anchor _todo001496 (user): merge these code instead of doing many passes? 
 &lt;p&gt; \anchor _todo001497 (user): try to be smarter and avoid looping again if little changed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CpModelView Class \_internalref classoperations__research_1_1sat_1_1CpModelView "<a class="el" href="classoperations__research_1_1sat_1_1CpModelView.html">operations_research::sat::CpModelView</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001524 (user): For now it uses proto indices of the loaded model. We will need
to add a mapping to use proto indices of the non-presolved model to allow for
a client custom search with presolve. The main API shouldn't change though
and the change will be transparent. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af443c47f14a044d69553b02337b5dc52 "<a class="el" href="namespaceoperations__research_1_1sat.html#af443c47f14a044d69553b02337b5dc52">operations_research::sat::CpSolverResponseStats</a>" (const CpSolverResponse &amp;response, bool has_objective)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001525 (user): This is probably better named "binary_propagation", but we just
output "propagations" to be consistent with sat/analyze.sh. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae3fd4466b012022bab0c5c1839c77890 "<a class="el" href="namespaceoperations__research_1_1sat.html#ae3fd4466b012022bab0c5c1839c77890">operations_research::sat::CreateAlternativeLiteralsWithView</a>" (int num_literals, Model *model, LinearRelaxation *relaxation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002044 (user): We shouldn't need to create this view ideally. Even better,
we should be able to handle Literal natively in the linear relaxation,
but that is a lot of work. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a55cafa81679ac10c971927ca17ec7f2e "<a class="el" href="namespaceoperations__research_1_1sat.html#a55cafa81679ac10c971927ca17ec7f2e">operations_research::sat::CreateCumulativeEnergyCutGenerator</a>" (SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands_helper, const AffineExpression &amp;capacity, const std::optional&lt; AffineExpression &gt; &amp;makespan, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002408 (user): use level 0 bounds ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a88677d1180474733727feff2bbca0d31 "<a class="el" href="namespaceoperations__research_1_1sat.html#a88677d1180474733727feff2bbca0d31">operations_research::sat::CreateFlowCutGenerator</a>" (int num_nodes, const std::vector&lt; int &gt; &amp;tails, const std::vector&lt; int &gt; &amp;heads, const std::vector&lt; AffineExpression &gt; &amp;arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002274 (user): Support general linear expression for capacities.
 &lt;p&gt; &lt;p&gt;(user): Some model applies the same capacity to both an arc and its
reverse. Also support this case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2b7ca84b359f0e49b63ece216db6c944 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2b7ca84b359f0e49b63ece216db6c944">operations_research::sat::CreateNoOverlap2dEnergyCutGenerator</a>" (NoOverlap2DConstraintHelper *helper, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001705 (user): We could compute this once and for all in the helper.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a28abd2fe9199829f0c98ade48cfe459c "<a class="el" href="namespaceoperations__research_1_1sat.html#a28abd2fe9199829f0c98ade48cfe459c" title="A cut generator for z = x * y (x and y &gt;= 0).">operations_research::sat::CreatePositiveMultiplicationCutGenerator</a>" (AffineExpression z, AffineExpression x, AffineExpression y, int linearization_level, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001683 (user): As the bounds change monotonically, these cuts
dominate any previous one.  try to keep a reference to the cut and
replace it. Alternatively, add an API for a level-zero bound change
callback. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ace9a3f85b1ced1ed86954a6d4d620fbd "<a class="el" href="namespaceoperations__research_1_1sat.html#ace9a3f85b1ced1ed86954a6d4d620fbd">operations_research::sat::Cumulative</a>" (const std::vector&lt; IntervalVariable &gt; &amp;vars, absl::Span&lt; const AffineExpression &gt; demands, AffineExpression capacity, SchedulingConstraintHelper *helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001624 (user): Change that since we have optional interval
for this. 
 &lt;p&gt; \anchor _todo001625 (user): We need to exclude intervals that can be of size zero
because the disjunctive do not "ignore" them like the cumulative
does. That is, the interval [2,2) will be assumed to be in
disjunction with [1, 3) for instance. We need to uniformize the
handling of interval with size zero. 
 &lt;p&gt; \anchor _todo001626 (user): Do proper experiments to see how beneficial this is, the
disjunctive will propagate more but is also using slower algorithms.
That said, this is more a question of optimizing the disjunctive
propagation code.&lt;p&gt; \anchor _todo001627 (user): Another "known" idea is to detect pair of tasks that must
be in disjunction and to create a Boolean to indicate which one is
before the other. It shouldn't change the propagation, but may result
in a faster one with smaller explanations, and the solver can also take
decision on such Boolean.&lt;p&gt; \anchor _todo001628 (user): A better place for stuff like this could be in the
presolver so that it is easier to disable and play with alternatives. 
 &lt;p&gt; \anchor _todo001629 (user): Models that include the makespan as a special interval might
be better, but then not everyone does that. In particular this code
allows to have decent lower bound on the large cumulative minizinc
instances.&lt;p&gt; \anchor _todo001630 (user): this require the precedence constraints to be already loaded,
and there is no guarantee of that currently. Find a more robust way.&lt;p&gt; \anchor _todo001631 (user): There is a bit of code duplication with the disjunctive
precedence propagator. Abstract more? 
 &lt;p&gt; \anchor _todo001632 (user): Handle generic affine relation?
 &lt;p&gt; \anchor _todo001633 (user): This can lead to many constraints. By analyzing a bit more
the precedences, we could restrict that. In particular for cases were
the cumulative is always (bunch of tasks B), T, (bunch of tasks A) and
task T always in the middle, we never need to explicit list the
precedence of a task in B with a task in A.&lt;p&gt; \anchor _todo001634 (user): If more than one variable are after the same set of
intervals, we should regroup them in a single constraint rather than
having two independent constraint doing the same propagation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeDualFeasibleEnergyConstraint Member \_internalref classoperations__research_1_1sat_1_1CumulativeDualFeasibleEnergyConstraint#a214c101bb659b1243cc9a5c2c0882a1f "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeDualFeasibleEnergyConstraint.html#a214c101bb659b1243cc9a5c2c0882a1f">operations_research::sat::CumulativeDualFeasibleEnergyConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001643 (user): explore with using Theta-trees with a multi-valued energy
value. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeEnergyConstraint Member \_internalref classoperations__research_1_1sat_1_1CumulativeEnergyConstraint#a1058cbb9c9572113e896f5c7c471eacc "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeEnergyConstraint.html#a1058cbb9c9572113e896f5c7c471eacc">operations_research::sat::CumulativeEnergyConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001635 (user): just keep the current direction? 
 &lt;p&gt; \anchor _todo001636 (user): force capacity_max &gt;= 0, fail/remove optionals when 0.
 &lt;p&gt; \anchor _todo001637 (user): We do not need the capacity max in the reason, but by using
a lower one, we could maybe have propagated more the minimum capacity.
investigate. 
 &lt;p&gt; \anchor _todo001638 (user): This could be done lazily.
&lt;p&gt; \anchor _todo001639 &lt;p&gt; \anchor _todo001640 (user): the same required task can have its energy pruned
several times, making this algorithm O(n^2 log n). Is there a way
to get the best pruning in one go? This looks like edge-finding not
being able to converge in one pass, so it might not be easy. 
 &lt;p&gt; \anchor _todo001641 (user): Improve window_end using envelope of critical event.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeIsAfterSubsetConstraint Class \_internalref classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint.html">operations_research::sat::CumulativeIsAfterSubsetConstraint</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001644 (user): I am not sure this is the best way, but it does at least push
the level zero bound on the large cumulative instances. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CumulativeIsAfterSubsetConstraint Member \_internalref classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint#a9d0445b319d93772786a042918c970c2 "<a class="el" href="classoperations__research_1_1sat_1_1CumulativeIsAfterSubsetConstraint.html#a9d0445b319d93772786a042918c970c2">operations_research::sat::CumulativeIsAfterSubsetConstraint::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001642 (user): actually, we will push using the
last task, and the reason will be non-optimal, fix. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af421daf12e0e45a0bb3cc7655cd443cc "<a class="el" href="namespaceoperations__research_1_1sat.html#af421daf12e0e45a0bb3cc7655cd443cc">operations_research::sat::CumulativePrecedenceSearchHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001874 (user): tie-break tasks not fitting in the profile smartly. 
 &lt;p&gt; \anchor _todo001875 (user): If the two box cannot overlap because of high demand, use
repo.CreateDisjunctivePrecedenceLiteral() instead.&lt;p&gt; \anchor _todo001876 (user): Add heuristic ordering for creating interesting precedence
first. 
 &lt;p&gt; \anchor _todo001877 (user): We need to add the reason for demand_min and capacity_max.
&lt;p&gt; \anchor _todo001878 &lt;p&gt; \anchor _todo001879 (user): unfortunately we can't report it from here. 
 &lt;p&gt; \anchor _todo001880 (user): add heuristic criteria, right now we stop at first
one. See above. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CutDataBuilder Member \_internalref classoperations__research_1_1sat_1_1CutDataBuilder#a9774f1e81b584ea534b9f46023b7a430 "<a class="el" href="classoperations__research_1_1sat_1_1CutDataBuilder.html#a9774f1e81b584ea534b9f46023b7a430">operations_research::sat::CutDataBuilder::AddOrMergeBooleanTerms</a>" (absl::Span&lt; CutTerm &gt; terms, IntegerValue t, CutData *cut)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001645 (user): Because of merges, we might have entry with a coefficient of
zero than are not useful. Remove them? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CutDataBuilder Member \_internalref classoperations__research_1_1sat_1_1CutDataBuilder#a6c27f24f411983fa4e7333dcadb9fd55 "<a class="el" href="classoperations__research_1_1sat_1_1CutDataBuilder.html#a6c27f24f411983fa4e7333dcadb9fd55" title="Returns false if we encounter an integer overflow.">operations_research::sat::CutDataBuilder::ConvertToLinearConstraint</a>" (const CutData &amp;cut, LinearConstraint *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001646 (user): Divide by gcd first to avoid possible overflow in the
conversion? it is however unlikely given that our coeffs should be small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::CutTerm Member \_internalref structoperations__research_1_1sat_1_1CutTerm#a302409b0ad6af0cc718fab498bcdadde "<a class="el" href="structoperations__research_1_1sat_1_1CutTerm.html#a302409b0ad6af0cc718fab498bcdadde">operations_research::sat::CutTerm::expr_offset</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001694 (user): We might want to store that elsewhere, as sorting CutTerm is a
bit slow and we don't need to look at that in most places. Same for the
cached_implied_lb/ub below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DebugSolution Member \_internalref structoperations__research_1_1sat_1_1DebugSolution#a5cff986a172f5615625e27f2c084fc07 "<a class="el" href="structoperations__research_1_1sat_1_1DebugSolution.html#a5cff986a172f5615625e27f2c084fc07">operations_research::sat::DebugSolution::ivar_has_value</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001831 (user): When this happen we should be able to infer the value of these
derived variable in the solution. For now, we only do that for the
objective variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DecompositionGraphNeighborhoodGenerator Class \_internalref classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator "<a class="el" href="classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator.html">operations_research::sat::DecompositionGraphNeighborhoodGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001275 (user): Doing the full heuristic treewidth decomposition is probably
better because when we grow the current neighborhood, just using local
connection to the current candidate is probably not enough to orient the
search towards a good final neighborhood. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DecompositionGraphNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator#a4191b3fb4373c17867f7759056550a85 "<a class="el" href="classoperations__research_1_1sat_1_1DecompositionGraphNeighborhoodGenerator.html#a4191b3fb4373c17867f7759056550a85">operations_research::sat::DecompositionGraphNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, SolveData &amp;data, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001258 (user): Does starting by a constraint make sense too? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DelayedRootLevelDeduction Struct \_internalref structoperations__research_1_1sat_1_1DelayedRootLevelDeduction "<a class="el" href="structoperations__research_1_1sat_1_1DelayedRootLevelDeduction.html">operations_research::sat::DelayedRootLevelDeduction</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001811 (user): If we change the logic to not restart right away, we probably
need to remove duplicates bounds for the same variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa71dfa5c438ceb1f2474eea8ceb3c4ad "<a class="el" href="namespaceoperations__research_1_1sat.html#aa71dfa5c438ceb1f2474eea8ceb3c4ad" title="Detects symmetries and fill the symmetry field.">operations_research::sat::DetectAndAddSymmetryToProto</a>" (const SatParameters &amp;params, CpModelProto *proto, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001588 (user): It might be nice to just add this to the proto rather than
re-reading the generators and recomputing this in a few places. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3423c28a2a00161e74d9c6e0174bcbf6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a3423c28a2a00161e74d9c6e0174bcbf6">operations_research::sat::DetectAndExploitSymmetriesInPresolve</a>" (PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001589 (user): Doing that is not always good, on cod105.mps, fixing variables
instead of letting the inner solver handle Boolean symmetries make the
problem unsolvable instead of easily solved. This is probably because this
fixing do not exploit the full structure of these symmetries. Note
however that the fixing via propagation above close cod105 even more
efficiently. 
 &lt;p&gt; \anchor _todo001590 (user): The same effect could be achieved by adding symmetry breaking
constraints of the form "a &gt;= b " between Booleans and let the presolve do
the reduction. This might be less code, but it is also less efficient.
Similarly, when we cannot just fix variables to break symmetries, we could
add these constraints, but it is unclear if we should do it all the time or
not.&lt;p&gt; \anchor _todo001591 (user): code the generic approach with orbits and stabilizer. 
 &lt;p&gt; \anchor _todo001592 (user): generalize somehow. See if we can exploit this in
lb_tree_search directly. We also have a lot more structure than just the
objective can be ordered. Like if the objective is a max, we can still do
that.&lt;p&gt; \anchor _todo001593 (user): Actually the constraint we add is really just breaking the
orbitope symmetry on one line. But this line being the objective is key. We
can also explicitly look for a full permutation group of the objective
terms directly instead of finding the largest orbitope first. 
 &lt;p&gt; \anchor _todo001594 (user): Compute the stabilizer under the only non-fixed element and
iterate! 
 &lt;p&gt; \anchor _todo001595 (user): Tune more, especially as we handle symmetry better. Also the
estimate is pretty bad, we should probably compute stabilizer and decide
when we actually know how much we can fix compared to how many symmetry we
lose. 
 &lt;p&gt; \anchor _todo001596 (user): The code below requires that no variable appears twice in the
same at most one. In particular lit and not(lit) cannot appear in the same
at most one. 
 &lt;p&gt; \anchor _todo001597 (user): for 1/ and 2/ we could add an at most one constraint on the
full row if it is not already there!&lt;p&gt; \anchor _todo001598 (user): if the same at most one touch more than one row, we can
deduce more. It is a bit tricky and maybe not frequent enough to make a
big difference. Also, as we start to fix things, at most one might
propagate by themselves. 
 &lt;p&gt; \anchor _todo001599 (user): We could remove these rows from the orbitope. Note that
currently this never happen on the miplib (maybe in LNS though). 
 &lt;p&gt; \anchor _todo001600 (user): This is probably not needed if we add lexicographic
constraint instead of just breaking a single row below. 
 &lt;p&gt; \anchor _todo001617 (user): A bunch of other presolve transformations break the symmetry even
though they probably shouldn't. Like the find big liner overlap for instance.
Or when we fix variable but don't propagate to the full orbit. It might not
be too much work to:
  1/ Compute the symmetry early
  2/ Only do transformation that preserve them
To investigate. It seems disabling find_big_linear_overlap helps on
mas74.pb.gz, or the square??.mps for instance. But it is less good overall. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a753e3aea07903c667891eb57036d26de "<a class="el" href="namespaceoperations__research_1_1sat.html#a753e3aea07903c667891eb57036d26de">operations_research::sat::DetectImpliedIntegers</a>" (MPModelProto *mp_model, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002067 (user): be smarter! we should be able to handle these cases.
 &lt;p&gt; \anchor _todo002068 (user): If we scale more we migth be able to turn it into an
integer. 
 &lt;p&gt; \anchor _todo002078 (user): Actually implement the offset part. This currently only happens
on the 3 neos-46470* miplib problems where we have a non-integer rhs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a175a4aa8393ef1f42790017ac2ef3d0e "<a class="el" href="namespaceoperations__research_1_1sat.html#a175a4aa8393ef1f42790017ac2ef3d0e">operations_research::sat::DetectMakespan</a>" (absl::Span&lt; const IntervalVariable &gt; intervals, absl::Span&lt; const AffineExpression &gt; demands, const AffineExpression &amp;capacity, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002045 (user): Supports variable capacity.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3216f11aeb59c8cd63d2a1e8cdc6d47b "<a class="el" href="namespaceoperations__research_1_1sat.html#a3216f11aeb59c8cd63d2a1e8cdc6d47b" title="Automatically detect optional variables.">operations_research::sat::DetectOptionalVariables</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001294 (user): This deals with the simplest cases, but we could try to
detect literals that implies all the constraints in which a variable
appear to false. This can be done with a LCA computation in the tree of
Boolean implication (once the presolve remove cycles). Not sure if we can
properly exploit that afterwards though. Do some research! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DisjunctiveOverloadChecker Member \_internalref classoperations__research_1_1sat_1_1DisjunctiveOverloadChecker#a201afdaa7c1eb9776d9fd66837cd8fed "<a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveOverloadChecker.html#a201afdaa7c1eb9776d9fd66837cd8fed">operations_research::sat::DisjunctiveOverloadChecker::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001718 (user): Actually, we just infered a "not last" so we could check
for relevant_size &gt; 2 potential propagation?&lt;p&gt; \anchor _todo001719 (user): Can we detect and propagate all such relations easily and
do a pass before this maybe? On a related note, because this
propagator is not instantiated in both direction, we might miss some
easy propag. 
 &lt;p&gt; \anchor _todo001720 (user): Shall we keep propagating? we know the prefix didn't
change, so we could be faster here. On another hand, it might be
better to propagate all the linear constraints before returning
here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a33798fe85208035f149a5c124b89b7b4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a33798fe85208035f149a5c124b89b7b4">operations_research::sat::DisjunctivePrecedenceSearchHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001870 (user): tie break by size/start-max
&lt;p&gt; \anchor _todo001871 &lt;p&gt; \anchor _todo001872 (user): Use conditional lower bounds? note that in automatic search
all precedence will be fixed before this is called though. In fixed
search maybe we should use the other SchedulingSearchHeuristic(). 
 &lt;p&gt; \anchor _todo001873 (user): Also compare the second part of the precedence in
PrecedenceIsBetter() and not just the interval before? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DisjunctiveWithTwoItems Member \_internalref classoperations__research_1_1sat_1_1DisjunctiveWithTwoItems#aded29605fb1b5e0a55697fabdc9797ae "<a class="el" href="classoperations__research_1_1sat_1_1DisjunctiveWithTwoItems.html#aded29605fb1b5e0a55697fabdc9797ae">operations_research::sat::DisjunctiveWithTwoItems::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001714 (user): For optional interval whose presence in unknown and without
optional variable, the end-min may not be propagated to at least (start_min
+ size_min). Consider that into the computation so we may decide the
interval forced absence? Same for the start-max. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DivisionPropagator Class \_internalref classoperations__research_1_1sat_1_1DivisionPropagator "<a class="el" href="classoperations__research_1_1sat_1_1DivisionPropagator.html">operations_research::sat::DivisionPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001851 (user): Deal with overflow. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DivisionPropagator Member \_internalref classoperations__research_1_1sat_1_1DivisionPropagator#ac89f35a696a3d291bfafae382a1332ca "<a class="el" href="classoperations__research_1_1sat_1_1DivisionPropagator.html#ac89f35a696a3d291bfafae382a1332ca">operations_research::sat::DivisionPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001845 (user): We can propagate more, especially in the case where denom
spans across 0.
 &lt;p&gt; &lt;p&gt;(user): We can propagate a bit more if min_div = 0:
    (min_num &gt; -min_denom). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DomainDeductions Class \_internalref classoperations__research_1_1sat_1_1DomainDeductions "<a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html">operations_research::sat::DomainDeductions</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002230 (user): Also use these "deductions" in the solver directly. This is done
in good MIP solvers, and we should exploit them more.&lt;p&gt; \anchor _todo002231 (user): Also propagate implicit clauses (lit, not(lit)). Maybe merge
that with probing code? it might be costly to store all deduction done by
probing though, but I think this is what MIP solver do. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DomainDeductions Member \_internalref classoperations__research_1_1sat_1_1DomainDeductions#a90eec97bf72d63f4c921156b3f31c5a4 "<a class="el" href="classoperations__research_1_1sat_1_1DomainDeductions.html#a90eec97bf72d63f4c921156b3f31c5a4">operations_research::sat::DomainDeductions::ProcessClause</a>" (absl::Span&lt; const int &gt; clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002235 (user): We could probably be even more efficient. We could also
compute exactly what clauses need to be "waked up" as new deductions are
added. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DratProofHandler Member \_internalref classoperations__research_1_1sat_1_1DratProofHandler#a8ceaa4570135a1216539fccb736088ca "<a class="el" href="classoperations__research_1_1sat_1_1DratProofHandler.html#a8ceaa4570135a1216539fccb736088ca">operations_research::sat::DratProofHandler::ApplyMapping</a>" (const util_intops::StrongVector&lt; BooleanVariable, BooleanVariable &gt; &amp;mapping)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001737 (user): This is exactly the same mecanism as in the SatPostsolver
class. Factor out the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Class \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html">operations_research::sat::DualBoundStrengthening</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002531 (user): This is actually an important step to do before scaling as it can
usually reduce really large bounds! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Member \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening#aa3f78681f549714a6bcfabc007aa985d "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html#aa3f78681f549714a6bcfabc007aa985d" title="All constraints should be mapped to one of more call to these functions.">operations_research::sat::DualBoundStrengthening::CannotDecrease</a>" (absl::Span&lt; const int &gt; refs, int ct_index=-1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002510 (user): No need to set locking_ct_index_[var] if num_locks_[var] &gt; 1
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::DualBoundStrengthening Member \_internalref classoperations__research_1_1sat_1_1DualBoundStrengthening#a162bcb064138a579ee8192ffb9c244cb "<a class="el" href="classoperations__research_1_1sat_1_1DualBoundStrengthening.html#a162bcb064138a579ee8192ffb9c244cb">operations_research::sat::DualBoundStrengthening::Strengthen</a>" (PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002511 (user): Cover all the cases. 
 &lt;p&gt; \anchor _todo002512 (user): Fix variable right away rather than waiting for next call.
 &lt;p&gt; \anchor _todo002513 (user): We can also deal with more than one enforcement. 
 &lt;p&gt; \anchor _todo002514 (user): Generalize to non-Boolean. Also for Boolean, we might
miss some possible reduction if replacing X by 1 - X make a constraint
near-duplicate of another.&lt;p&gt; \anchor _todo002515 (user): We can generalize to non-linear constraint.&lt;p&gt; \anchor _todo002516 (user): Make sure implication graph is transitively reduced to not
miss such reduction. More generally, this might only use the graph rather
than the encoding into bool_and / at_most_one ? Basically if a =&gt;
all_direct_deduction, we can transform it into a &lt;=&gt; all_direct_deduction
if that is interesting. This could always be done on a max-2sat problem
in one of the two direction. Also think about max-2sat specific presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::EncodingNode Member \_internalref classoperations__research_1_1sat_1_1EncodingNode#a4db8bdd99cd1c21623273512082cd8a6 "<a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html#a4db8bdd99cd1c21623273512082cd8a6">operations_research::sat::EncodingNode::GenericNode</a>" (int lb, int ub, std::function&lt; Literal(int x)&gt; create_lit, Coefficient weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001739 (user): Not ideal, we should probably just provide index in the
original objective for sorting purpose. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::EncodingNode Member \_internalref classoperations__research_1_1sat_1_1EncodingNode#a93fd5b911e64c63ed4b1b32dc42a571d "<a class="el" href="classoperations__research_1_1sat_1_1EncodingNode.html#a93fd5b911e64c63ed4b1b32dc42a571d" title="Indicate that the node cannot grow further than its current assumption.">operations_research::sat::EncodingNode::TransformToBoolean</a>" (SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001740 (user): Avoid creating a Boolean just to fix it!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad991297f9637c704d1824dc9513ab8b8 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad991297f9637c704d1824dc9513ab8b8">operations_research::sat::ExactlyOnePerRowAndPerColumn</a>" (absl::Span&lt; const std::vector&lt; Literal &gt; &gt; graph)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001131 (user): Change to a sparse API like for the function above.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a265b8cf37f58fb2c78b247a6412ce519 "<a class="el" href="namespaceoperations__research_1_1sat.html#a265b8cf37f58fb2c78b247a6412ce519">operations_research::sat::ExploitDominanceRelations</a>" (const VarDomination &amp;var_domination, PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002523 (user): More generally, combine with probing? if a dominated
variable implies one of its dominant to zero, then it can be set to
zero. It seems adding the implication below should have the same
effect? but currently it requires a lot of presolve rounds. 
 &lt;p&gt; \anchor _todo002524 (user): if both variable are in a bool_or, this will allow us to
remove the dominated variable. Maybe we should exploit that to decide
which implication we add. Or just remove such variable and not add the
implications?&lt;p&gt; \anchor _todo002525 (user): generalize to non Booleans? 
 &lt;p&gt; \anchor _todo002526 (user): It look like testing this is not really necessary.
The reduction done by this class seem to be order independent. 
 &lt;p&gt; \anchor _todo002527 (user): Is this needed?
 &lt;p&gt; \anchor _todo002528 (user): maybe the last point can be improved. 
 &lt;p&gt; \anchor _todo002529 (user): We should probably be able to do something with this.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#adeb8d3a8598889ab54b14dd56b56ae1b "<a class="el" href="namespaceoperations__research_1_1sat.html#adeb8d3a8598889ab54b14dd56b56ae1b">operations_research::sat::ExtractAllSubsetsFromForest</a>" (absl::Span&lt; const int &gt; parent, std::vector&lt; int &gt; *subset_data, std::vector&lt; absl::Span&lt; const int &gt; &gt; *subsets, int node_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002273 (user): This also allocate O(n) memory internally, we could reuse it from
call to call if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a89efb582832622f508e29d0c32f56ca9 "<a class="el" href="namespaceoperations__research_1_1sat.html#a89efb582832622f508e29d0c32f56ca9">operations_research::sat::ExtractElementEncoding</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001291 (user): It should be safe otherwise the exactly_one will have
duplicate literal, but I am not sure that if presolve is off we can
assume that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afa73e23a5cfae0eaf253c2e2518e05e7 "<a class="el" href="namespaceoperations__research_1_1sat.html#afa73e23a5cfae0eaf253c2e2518e05e7">operations_research::sat::ExtractEncoding</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001283 (user): Regroup/presolve two encoding like b =&gt; x &gt; 2 and the same
Boolean b =&gt; x &gt; 5. These shouldn't happen if we merge linear constraints. 
 &lt;p&gt; \anchor _todo001284 (user): Debug what makes it unsat at this point.
 &lt;p&gt; \anchor _todo001285 (user): We will re-add the same implied bounds during probing, so
it might not be necessary to do that here. Also, it might be too early
if some of the literal view used in the LP are created later, but that
should be fixable via calls to implied_bounds-&gt;NotifyNewIntegerView(). 
 &lt;p&gt; \anchor _todo001286 (user): In these cases, we could fix the enforcement literal right
away or ignore the constraint. Note that it will be done later anyway
though. 
 &lt;p&gt; \anchor _todo001287 (user): Fully encode variable that are almost fully encoded? 
 &lt;p&gt; \anchor _todo001288 (user): Try to remove it. Normally we caught UNSAT above, but
tests are very flaky (it only happens in parallel). Keeping it there for
the time being. 
 &lt;p&gt; \anchor _todo001289 (user): delay this after PropagateEncodingFromEquivalenceRelations()?
Otherwise we might create new Boolean variables for no reason. Note
however, that in the presolve, we should only use the "representative" in
linear constraints, so we should be fine. 
 &lt;p&gt; \anchor _todo001290 (user): It is not 100% clear what is the best encoding and if
we should create equivalent literal or rely on propagator instead
to push bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac9d08e5135a1ae71b571b14fbff3381b "<a class="el" href="namespaceoperations__research_1_1sat.html#ac9d08e5135a1ae71b571b14fbff3381b">operations_research::sat::FailedLiteralProbingRound</a>" (ProbingOptions options, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002242 (user): Instead of minimizing index in topo order (which might be
nice for binary extraction), we could try to maximize reusability in
some way. 
 &lt;p&gt; \anchor _todo002243 (user): Can we be smarter here? Maybe we can still fix the
literal without going back to level zero by simply enqueuing it with
no reason? it will be backtracked over, but we will still lazily fix
it later. 
 &lt;p&gt; \anchor _todo002244 (user): We could be slightly more generic and subsume some
clauses that do not contains last_decision.Negated(). 
 &lt;p&gt; \anchor _todo002245 (user): Think about trying to extract clause that will not
get removed by transitive reduction later. If we can both extract
a =&gt; c and b =&gt; c , ideally we don't want to extract a =&gt; c first
if we already know that a =&gt; b.&lt;p&gt; \anchor _todo002246 (user): Similar to previous point, we could find the LCA
of all literals in the reason for this propagation. And use this
as a reason for later hyber binary resolution. Like we do when
this clause subsume the reason. 
 &lt;p&gt; \anchor _todo002247 (user): We might just want to do that even more lazily by
checking for detached clause while propagating here? and do a big
cleanup at the end. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FeasibilityJumpSolver Class \_internalref classoperations__research_1_1sat_1_1FeasibilityJumpSolver "<a class="el" href="classoperations__research_1_1sat_1_1FeasibilityJumpSolver.html">operations_research::sat::FeasibilityJumpSolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001758 (user): If we have more than one of these solver, we might want to share
the evaluator memory between them. Right now we basically keep a copy of the
model and its transpose for each FeasibilityJumpSolver. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FeasibilityJumpSolver Member \_internalref classoperations__research_1_1sat_1_1FeasibilityJumpSolver#adc255845d619b5cf9077d19faecb8762 "<a class="el" href="classoperations__research_1_1sat_1_1FeasibilityJumpSolver.html#adc255845d619b5cf9077d19faecb8762">operations_research::sat::FeasibilityJumpSolver::GenerateTask</a>" (int64_t) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001749 (user): Tune the improvement constant, maybe use luby.
 &lt;p&gt; \anchor _todo001750 (user): Find better names. DeterministicTime() is maintained by
this class while deterministic_time() is the one saved in the SubSolver
base class). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7287180e6e143d0a2c6f6e6c206cc656 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7287180e6e143d0a2c6f6e6c206cc656">operations_research::sat::FilterOrbitOnUnusedOrFixedVariables</a>" (SymmetryProto *symmetry, PresolveContext *context)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001601 (user): These are just basic checks and do not guarantee that we
properly kept this symmetry in the presolve.&lt;p&gt; \anchor _todo001602 (user): Deal with case where all variable in an orbit has been found
to be equivalent to each other. Or all variables have affine
representative, like if all domains where [0][2], we should have remapped
all such variable to Booleans. 
 &lt;p&gt; \anchor _todo001603 (user): Avoid the reconvertion. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0f79d28fdcdb115fb186792a0c215540 "<a class="el" href="namespaceoperations__research_1_1sat.html#a0f79d28fdcdb115fb186792a0c215540">operations_research::sat::FindBestScalingAndComputeErrors</a>" (absl::Span&lt; const double &gt; coefficients, absl::Span&lt; const double &gt; lower_bounds, absl::Span&lt; const double &gt; upper_bounds, int64_t max_absolute_activity, double wanted_absolute_activity_precision, double *relative_coeff_error, double *scaled_sum_error)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002069 (user): Make this faster. 
 &lt;p&gt; \anchor _todo002076 (user): unit test this and move to fp_utils.
 &lt;p&gt; &lt;p&gt;(user): Ideally the lower/upper should be int64_t so that we can have
an exact definition for the max_absolute_activity allowed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae16bafcf3c5377ed905021a96f93bdcf "<a class="el" href="namespaceoperations__research_1_1sat.html#ae16bafcf3c5377ed905021a96f93bdcf">operations_research::sat::FindCpModelSymmetries</a>" (const SatParameters &amp;params, const CpModelProto &amp;problem, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators, double deterministic_limit, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001587 (user): Change the API to not return an error when the time limit is
reached. 
 &lt;p&gt; \anchor _todo001615 (user): On SAT problems it is more powerful to detect permutations also
involving the negation of the problem variables. So that we could find a
symmetry x &lt;-&gt; not(y) for instance.&lt;p&gt; \anchor _todo001616 (user): As long as we only exploit symmetry involving only Boolean
variables we can make this code more efficient by not detecting symmetries
involing integer variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2e4999dc16f55afa8c5d30a733a26e3d "<a class="el" href="namespaceoperations__research_1_1sat.html#a2e4999dc16f55afa8c5d30a733a26e3d">operations_research::sat::FindDuplicateConstraints</a>" (const CpModelProto &amp;model_proto, bool ignore_enforcement)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001499 (user): we could delete duplicate identical interval, but we need
to make sure reference to them are updated. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a75271e8da6c6cb4c5c87226e150d47d7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a75271e8da6c6cb4c5c87226e150d47d7">operations_research::sat::FindLinearBooleanProblemSymmetries</a>" (const LinearBooleanProblem &amp;problem, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001118 (user): inject the appropriate time limit here.
 &lt;p&gt; \anchor _todo001119 (user): Remove them beforehand? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7492392221bdfcc832cce2d93c9b681c "<a class="el" href="namespaceoperations__research_1_1sat.html#a7492392221bdfcc832cce2d93c9b681c" title="Returns a stable fingerprint of a model.">operations_research::sat::FingerprintModel</a>" (const CpModelProto &amp;model, uint64_t seed=kDefaultFingerprintSeed)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001622 (user): Should we fingerprint decision strategies?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FirstFewValues Class \_internalref classoperations__research_1_1sat_1_1FirstFewValues "<a class="el" href="classoperations__research_1_1sat_1_1FirstFewValues.html">operations_research::sat::FirstFewValues&lt; n &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002501 (user): Maybe modulo some prime number we can keep more info.
 &lt;p&gt; &lt;p&gt;(user): Another common case is a bunch of really small values and larger
ones, so we could bound the sum of the small values and keep the first few
reachable by the big ones. This is similar to some presolve transformations. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FirstFewValues Member \_internalref classoperations__research_1_1sat_1_1FirstFewValues#afb10d079fe78aa99d7256c85f6d24bde "<a class="el" href="classoperations__research_1_1sat_1_1FirstFewValues.html#afb10d079fe78aa99d7256c85f6d24bde">operations_research::sat::FirstFewValues&lt; n &gt;::Add</a>" (const int64_t positive_value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002504 (user): Implement Add() with an upper bound on the multiplicity. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a28a1d7fdb9ee5a88b771b2965bf18596 "<a class="el" href="namespaceoperations__research_1_1sat.html#a28a1d7fdb9ee5a88b771b2965bf18596">operations_research::sat::FirstUnassignedVarAtItsMinHeuristic</a>" (absl::Span&lt; const IntegerVariable &gt; vars, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001860 (user): the complexity caused by the linear scan in this heuristic and
the one below is ok when search_branching is set to SAT_SEARCH because it is
not executed often, but otherwise it is done for each search decision,
which seems expensive. Improve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::FixedCapacityVector Class \_internalref classoperations__research_1_1sat_1_1FixedCapacityVector "<a class="el" href="classoperations__research_1_1sat_1_1FixedCapacityVector.html">operations_research::sat::FixedCapacityVector&lt; T &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002500 (user): Add more functions and unit-test. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a392d70cc768a13de271f87123513acf2 "<a class="el" href="namespaceoperations__research_1_1sat.html#a392d70cc768a13de271f87123513acf2" title="The argument must be non-negative.">operations_research::sat::FloorSquareRoot</a>" (int64_t a)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002493 (user): Find better implementation? In practice passing via double is
almost always correct, but the CapProd() might be a bit slow. However this
is only called when we do propagate something. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a36bf1351ffa74960b3040a96ddc37468 "<a class="el" href="namespaceoperations__research_1_1sat.html#a36bf1351ffa74960b3040a96ddc37468">operations_research::sat::FullyCompressTuples</a>" (absl::Span&lt; const int64_t &gt; domain_sizes, std::vector&lt; std::vector&lt; int64_t &gt; &gt; *tuples)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001618 (user): We can probably reuse the tuples memory always and never create
new one. We should also be able to code an iterative version of this. Note
however that the recursion level is bounded by the number of columns which
should be small. 
 &lt;p&gt; \anchor _todo001620 (user): To reduce memory, we could return some absl::Span in the last
layer instead of vector.&lt;p&gt; \anchor _todo001621 (user): The final compression is depend on the order of the variables.
For instance the table (1,1)(1,2)(1,3),(1,4),(2,3) can either be compressed
as (1,*)(2,3) or (1,{1,2,4})({1,3},3). More experiment are needed to devise
a better heuristic. It might for example be good to call CompressTuples()
first. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3cfa6389f471e5868e779c07148e4ee4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a3cfa6389f471e5868e779c07148e4ee4">operations_research::sat::GenerateCumulativeEnergeticCuts</a>" (absl::string_view cut_name, const util_intops::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; EnergyEvent &gt; events, const AffineExpression &amp;capacity, TimeLimit *time_limit, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002407 (user): We could reduce this set. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a79c07c2911bf5d9a1225cd3789ff0499 "<a class="el" href="namespaceoperations__research_1_1sat.html#a79c07c2911bf5d9a1225cd3789ff0499">operations_research::sat::GenerateCumulativeEnergeticCutsWithMakespanAndFixedCapacity</a>" (absl::string_view cut_name, const util_intops::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, std::vector&lt; EnergyEvent &gt; events, IntegerValue capacity, AffineExpression makespan, TimeLimit *time_limit, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002404 (user): We could reduce this set.
&lt;p&gt; \anchor _todo002405 &lt;p&gt; \anchor _todo002406 (user): we can compute the max usage between makespan_min and
   makespan_max. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af2a840612629fd37d42870c23e183609 "<a class="el" href="namespaceoperations__research_1_1sat.html#af2a840612629fd37d42870c23e183609">operations_research::sat::GenerateGraphForSymmetryDetection</a>" (const LinearBooleanProblem &amp;problem, std::vector&lt; int &gt; *initial_equivalence_classes)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001117 (user): reserve the memory for the graph? not sure it is worthwhile
since it would require some linear scan of the problem though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a53c4d8406e1afd37e5a99ed333207f32 "<a class="el" href="namespaceoperations__research_1_1sat.html#a53c4d8406e1afd37e5a99ed333207f32">operations_research::sat::GenerateShortCompletionTimeCutsWithExactBound</a>" (const std::string &amp;cut_name, std::vector&lt; CtEvent &gt; events, IntegerValue capacity_max, Model *model, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002409 (user): Improve performance
  - detect disjoint tasks (no need to crossover to the second part)
  - better caching of explored states 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Class \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html">operations_research::sat::GenericLiteralWatcher</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001813 (user): Move this to its own file. Add unit tests! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#ad53c31fda5130ffda98dbb242faf3145 "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#ad53c31fda5130ffda98dbb242faf3145">operations_research::sat::GenericLiteralWatcher::GenericLiteralWatcher</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001806 (user): This propagator currently needs to be last because it is the
only one enforcing that a fix-point is reached on the integer variables.
Figure out a better interaction between the sat propagation loop and
this one. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#a23370d30fab5bc955f314d3ced9add4a "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#a23370d30fab5bc955f314d3ced9add4a">operations_research::sat::GenericLiteralWatcher::Propagate</a>" (Trail *trail) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001807 (user): The queue will not be emptied, but I am not sure the solver
will be left in an usable state. Fix if it become needed to resume
the solve from the last time it was interrupted. In particular, we might
want to call UpdateCallingNeeds()? 
 &lt;p&gt; \anchor _todo001808 (user): Maybe just provide one function Propagate(watch_indices) ?
 &lt;p&gt; \anchor _todo001809 (user): However, on some problem, it seems to work better to not
do that. One possible reason is that the reason of a "natural"
propagation might be better than one we learned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GenericLiteralWatcher Member \_internalref classoperations__research_1_1sat_1_1GenericLiteralWatcher#ab3993b47fa18e5a83198e062ded08bb7 "<a class="el" href="classoperations__research_1_1sat_1_1GenericLiteralWatcher.html#ab3993b47fa18e5a83198e062ded08bb7" title="Registers a propagator and returns its unique ids.">operations_research::sat::GenericLiteralWatcher::Register</a>" (PropagatorInterface *propagator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001810 (user): This initial propagation does not respect any later priority
settings. Fix this. Maybe we should force users to pass the priority at
registration. For now I didn't want to change the interface because there
are plans to implement a kind of "dynamic" priority, and if it works we may
want to get rid of this altogether. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2d3beb2acf8977c52500de3ebe170d24 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2d3beb2acf8977c52500de3ebe170d24">operations_research::sat::GetFullWorkerParameters</a>" (const SatParameters &amp;base_params, const CpModelProto &amp;cp_model, int num_already_present, SubsolverNameFilter *filter)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001517 (user): For scheduling, this is important to find good first solution
but afterwards it is not really great and should probably be replaced by a
LNS worker. 
 &lt;p&gt; \anchor _todo001518 (user): Avoid launching two strategies if they are the same,
like if there is no lp, or everything is already linearized at level 1. 
 &lt;p&gt; \anchor _todo001519 (user): Enable probing_search in deterministic mode.
Currently it timeouts on small problems as the deterministic time limit
never hits the sharding limit. 
 &lt;p&gt; \anchor _todo001520 (user): Enable shaving search in interleave mode.
Currently it do not respect ^C, and has no per chunk time limit. 
 &lt;p&gt; \anchor _todo001521 (user): Enable lb_tree_search in deterministic mode. 
 &lt;p&gt; \anchor _todo001522 (user): Actually make sure the gap num_workers &lt;-&gt; num_heuristics is
contained. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae2f0522b87e92a3a69cd92fe98af4be7 "<a class="el" href="namespaceoperations__research_1_1sat.html#ae2f0522b87e92a3a69cd92fe98af4be7">operations_research::sat::GetNamedParameters</a>" (SatParameters base_params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001514 (user): Do more experiments, the LP with core could be useful, but we
probably need to incorporate the newly created integer variables from the
core algorithm into the LP. 
 &lt;p&gt; \anchor _todo001515 (user): Experiment with search_random_variable_pool_size.
 &lt;p&gt; \anchor _todo001516 (user): Experiments more here, in particular we could follow it if
it falls into the current subtree. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa8cc7ff53b39b6a28e821bc428dcb331 "<a class="el" href="namespaceoperations__research_1_1sat.html#aa8cc7ff53b39b6a28e821bc428dcb331">operations_research::sat::GetOrbits</a>" (int n, absl::Span&lt; const std::unique_ptr&lt; SparsePermutation &gt; &gt; generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002461 (user): We could reuse the internal memory if needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#afa1020b89b12f653b1ea0dd0d595557e "<a class="el" href="namespaceoperations__research_1_1sat.html#afa1020b89b12f653b1ea0dd0d595557e">operations_research::sat::GetSuperAdditiveRoundingFunction</a>" (IntegerValue rhs_remainder, IntegerValue divisor, IntegerValue t, IntegerValue max_scaling)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001647 (user): Use everywhere a two step computation to avoid overflow?
First divide by divisor, then multiply by t. For now, we limit t so that
we never have an overflow instead. 
 &lt;p&gt; \anchor _todo001648 (user): This function is not always maximal when
size % (max_scaling - 1) == 0. Improve? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7876cef7b031a084f24b5c5898c9710c "<a class="el" href="namespaceoperations__research_1_1sat.html#a7876cef7b031a084f24b5c5898c9710c">operations_research::sat::GetSuperAdditiveStrengtheningFunction</a>" (IntegerValue positive_rhs, IntegerValue min_magnitude)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001649 (user): Limit the number of value used with scaling like above. 
 &lt;p&gt; \anchor _todo001650 (user): we might want to intoduce some step to reduce the final
magnitude of the cut. 
 &lt;p&gt; \anchor _todo001692 (user): Extend it for ci &gt;= max_magnitude, we can probaly "lift" such
coefficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfDetector Class \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector.html">operations_research::sat::GreaterThanAtLeastOneOfDetector</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002190 (user): Shall we do that on the main thread before the workers are
spawned? note that the probing version need the model to be loaded though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfDetector Member \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector#a54971ccb8359a6ce699b946840ac5b0a "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfDetector.html#a54971ccb8359a6ce699b946840ac5b0a">operations_research::sat::GreaterThanAtLeastOneOfDetector::AddGreaterThanAtLeastOneOfConstraints</a>" (Model *model, bool auto_detect_clauses=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002184 (user): Do more extensive experiment. Remove the second approach as
it is more time consuming? or identify when it make sense. Note that the
first approach also allows to use "incomplete" at least one between arcs. 
 &lt;p&gt; \anchor _todo002185 (user): This does not take into account clause of size 2 since they
are stored in the BinaryImplicationGraph instead. Some ideas specific
to size 2:
- There can be a lot of such clauses, but it might be nice to consider
  them. we need to experiments.
- The automatic clause detection might be a better approach and it
  could be combined with probing. 
 &lt;p&gt; \anchor _todo002202 (user): This can be quite slow, add some kind of deterministic limit
so that we can use it all the time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfPropagator Member \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator#a11ee2dab5b47a3c04564b44d74c55ed3 "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator.html#a11ee2dab5b47a3c04564b44d74c55ed3" title="For LazyReasonInterface.">operations_research::sat::GreaterThanAtLeastOneOfPropagator::Explain</a>" (int id, IntegerValue propagation_slack, IntegerVariable var_to_explain, int trail_index, std::vector&lt; Literal &gt; *literals_reason, std::vector&lt; int &gt; *trail_indices_reason) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001195 (user): We could also skip this if we already have the reason for
the expression being high enough in the current conflict. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::GreaterThanAtLeastOneOfPropagator Member \_internalref classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator#a3b3ae77e1959c1da3c086669f8c28062 "<a class="el" href="classoperations__research_1_1sat_1_1GreaterThanAtLeastOneOfPropagator.html#a3b3ae77e1959c1da3c086669f8c28062">operations_research::sat::GreaterThanAtLeastOneOfPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001196 (user): In case of a conflict, we could push one of them to false if
it is the only one. 
 &lt;p&gt; \anchor _todo001197 (user): This could be optimized by keeping more info from the last
Propagate() calls. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af6433b3a01c71cd754d3d710f345b4c0 "<a class="el" href="namespaceoperations__research_1_1sat.html#af6433b3a01c71cd754d3d710f345b4c0">operations_research::sat::GreedyFastDecreasingGcd</a>" (const absl::Span&lt; const int64_t &gt; coeffs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001711 (user): The following is a heuristic to make drop the GCD as fast
as possible. It might be suboptimal in general (as we could miss two
coprime coefficients for instance). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::HittingSetOptimizer Class \_internalref classoperations__research_1_1sat_1_1HittingSetOptimizer "<a class="el" href="classoperations__research_1_1sat_1_1HittingSetOptimizer.html">operations_research::sat::HittingSetOptimizer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002091 (user): This class requires linking with the SCIP MIP solver which is
quite big, maybe we should find a way not to do that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::HittingSetOptimizer Member \_internalref classoperations__research_1_1sat_1_1HittingSetOptimizer#a82f11613372a6a2909c2dc75bcd6216b "<a class="el" href="classoperations__research_1_1sat_1_1HittingSetOptimizer.html#a82f11613372a6a2909c2dc75bcd6216b">operations_research::sat::HittingSetOptimizer::Optimize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002083 (user): remove code duplication with MinimizeWithCoreAndLazyEncoding(); 
 &lt;p&gt; \anchor _todo002084 (user): Even though we keep the same solver, currently the solve is
not really done incrementally. It might be hard to improve though.&lt;p&gt; \anchor _todo002085 (user): deal with time limit. 
 &lt;p&gt; \anchor _todo002086 (user): C^c is broken when using SCIP.
 &lt;p&gt; \anchor _todo002087 (user): It is actually easy to use a FEASIBLE result. If when
passing it to SAT it is no feasbile, we can still create cores. If it
is feasible, we have a solution, but we cannot increase the lower
bound. 
 &lt;p&gt; \anchor _todo002088 (user): Use the real weights and exploit the extra cores.
&lt;p&gt; \anchor _todo002089 &lt;p&gt; \anchor _todo002090 (user): If we extract more than the objective variables, we could
use the solution values from the MPModel as hints to the SAT model. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5ca12ac764578209e7eaa692a9029635 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5ca12ac764578209e7eaa692a9029635">operations_research::sat::Implication</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, IntegerLiteral i)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001814 (user): This is one of the rare case where it is better to use Equality()
rather than two Implications(). Maybe we should modify our internal
implementation to use half-reified encoding? that is do not propagate the
direction integer-bound =&gt; literal, but just literal =&gt; integer-bound? This
is the same as using different underlying variable for an integer literal and
its negation. 
 &lt;p&gt; \anchor _todo001815 (user): Double check what happen when we associate a trivially
true or false literal. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Class \_internalref classoperations__research_1_1sat_1_1ImpliedBounds "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html">operations_research::sat::ImpliedBounds</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001775 (user): This can quickly use up too much memory. Add some limit in place.
In particular, each time we have literal =&gt; integer_literal we should avoid
storing the same integer_literal for all other_literal for which
other_literal =&gt; literal. For this we need to interact with the
BinaryImplicationGraph.&lt;p&gt; \anchor _todo001776 (user): This is a bit of a duplicate with the Literal &lt;=&gt; IntegerLiteral
stored in the IntegerEncoder class. However we only need one side here.&lt;p&gt; \anchor _todo001777 (user): Do like in the DomainDeductions class and allow to process
clauses (or store them) to perform more level zero deductions. Note that this
is again a slight duplicate with what we do there (except that we work at the
Domain level in that presolve class).&lt;p&gt; \anchor _todo001778 (user): Add an implied bound cut generator to add these simple
constraints to the LP when needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Member \_internalref classoperations__research_1_1sat_1_1ImpliedBounds#accac5e129274770ef3d646e15aa13b1c "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html#accac5e129274770ef3d646e15aa13b1c">operations_research::sat::ImpliedBounds::Add</a>" (Literal literal, IntegerLiteral integer_literal)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001764 (user): Check that this never happen? it shouldn't. 
 &lt;p&gt; \anchor _todo001765 (user): Like in probing, we can also create hole in the domain if there
is some implied bounds for (literal.NegatedIndex, NegagtionOf(var)) that
crosses integer_literal.bound. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBounds Member \_internalref classoperations__research_1_1sat_1_1ImpliedBounds#ace9f6e200fff7933263a014bb9d62fb8 "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBounds.html#ace9f6e200fff7933263a014bb9d62fb8">operations_research::sat::ImpliedBounds::GetImpliedBounds</a>" (IntegerVariable var)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001766 (user): Check no duplicate and remove old entry if the enforcement
is tighter. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBoundsProcessor Member \_internalref classoperations__research_1_1sat_1_1ImpliedBoundsProcessor#aa292900f68528b54007deb7cdb6f4aec "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html#aa292900f68528b54007deb7cdb6f4aec">operations_research::sat::ImpliedBoundsProcessor::DecomposeWithImpliedLowerBound</a>" (const CutTerm &amp;term, IntegerValue factor_t, CutTerm &amp;bool_term, CutTerm &amp;slack_term)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001685 (user): Ignore if bound_diff == 1 ? But we can still merge B with
another entry if it exists, so it can still be good in this case.&lt;p&gt; \anchor _todo001686 (user): Only do it if coeff_b &gt; 0 ? But again we could still merge
B with an existing Boolean for a better cut even if coeff_b == 0. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ImpliedBoundsProcessor Member \_internalref classoperations__research_1_1sat_1_1ImpliedBoundsProcessor#abc85bd67065c500f99ed24f0dd044301 "<a class="el" href="classoperations__research_1_1sat_1_1ImpliedBoundsProcessor.html#abc85bd67065c500f99ed24f0dd044301">operations_research::sat::ImpliedBoundsProcessor::PostprocessWithImpliedBound</a>" (const std::function&lt; IntegerValue(IntegerValue)&gt; &amp;f, IntegerValue factor_t, CutData *cut)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001687 (user): Note that while the violation might be higher, if the slack
becomes large this will result in a less powerfull cut. Shall we do
that? It is a bit the same problematic with complementing.&lt;p&gt; \anchor _todo001688 (user): If the slack is close to zero, then this transformation
will always increase the violation. So we could potentially do it in
Before our divisor selection heuristic. But the norm of the final cut
will increase too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::InclusionDetector Member \_internalref classoperations__research_1_1sat_1_1InclusionDetector#ac5767e6b32e020c4e95dd254ab768620 "<a class="el" href="classoperations__research_1_1sat_1_1InclusionDetector.html#ac5767e6b32e020c4e95dd254ab768620">operations_research::sat::InclusionDetector&lt; Storage &gt;::DetectInclusions</a>" (const std::function&lt; void(int subset, int superset)&gt; &amp;process)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001785 (user): Alternatively, we could clean is_in_superset_ in the
call to StopProcessingCurrentSuperset() and force client to call it
before altering the superset content. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad715c4b2444c3b6fb162bc2382a2248e "<a class="el" href="namespaceoperations__research_1_1sat.html#ad715c4b2444c3b6fb162bc2382a2248e">operations_research::sat::IncreaseNodeSize</a>" (EncodingNode *node, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001741 (user): Experiment more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Class \_internalref classoperations__research_1_1sat_1_1Inprocessing "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html">operations_research::sat::Inprocessing</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002349 (user): Some algorithms here use the normal SAT propagation engine.
However we might want to temporarily disable activities/phase saving and so
on if we want to run them as in-processing steps so that they
do not "pollute" the normal SAT search.&lt;p&gt; \anchor _todo002350 (user): For the propagation, this depends on the SatSolver class, which
mean we cannot really use it without some refactoring as an in-processing
from the SatSolver::Solve() function. So we do need a special
InprocessingSolve() that lives outside SatSolver. Alternatively, we can
extract the propagation main loop and conflict analysis from SatSolver. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a3ab413def8a2242915ef31ff717baa17 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a3ab413def8a2242915ef31ff717baa17">operations_research::sat::Inprocessing::DetectEquivalencesAndStamp</a>" (bool use_transitive_reduction, bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002301 (user): consider doing the transitive reduction after each SCC.
It might be slow but we could try to make it more incremental to
compensate and it should allow further reduction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#aa0797dfc25a5c609254b61fe67828c11 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#aa0797dfc25a5c609254b61fe67828c11">operations_research::sat::Inprocessing::InprocessingRound</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002296 (user): Tune the heuristic, in particular, with the current code we
start some inprocessing before the first search. 
 &lt;p&gt; \anchor _todo002297 (user): The LP and incremental structure will still be called though,
which can take some time, try to disable it more cleanly. 
 &lt;p&gt; \anchor _todo002298 (user): We should probably also disable the variable/clauses activity
updates. 
 &lt;p&gt; \anchor _todo002299 (user): Add a small wrapper function to time this.
 &lt;p&gt; \anchor _todo002300 (user): try to enable these? The problem is that we can only remove
variables not used the non-pure SAT part of a model. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a67d25dadf7669215ab5b27b4d8046e18 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a67d25dadf7669215ab5b27b4d8046e18">operations_research::sat::Inprocessing::PresolveLoop</a>" (SatPresolveOptions options)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002292 (user): This should/could be integrated with the stamping since it
seems better to do just one loop instead of two over all clauses. Because
of memory access. it isn't that clear though. 
 &lt;p&gt; \anchor _todo002293 (user): Combine the two? this way we don't create a full literal &lt;-&gt;
clause graph twice. It might make sense to reach the BCE fix point which
is unique before each variable elimination. 
 &lt;p&gt; \anchor _todo002294 (user): this break some binary graph invariant. Fix!
 &lt;p&gt; \anchor _todo002295 (user): Maintain the total number of literals in the watched clauses.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a5e0f39f14f9c6d947181e7185d6ed865 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a5e0f39f14f9c6d947181e7185d6ed865">operations_research::sat::Inprocessing::RemoveFixedAndEquivalentVariables</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002302 (user): The level zero is required because we remove fixed variables
but if we split this into two functions, we could rewrite clause at any
level. 
 &lt;p&gt; \anchor _todo002303 (user): If only new fixed variables are there, we can use a faster
function. We should also merge the code with the deletion code in
sat_solver_.cc, but that require some refactoring of the dependence between
files. 
 &lt;p&gt; \anchor _todo002304 (user): we should output literal to the proof right away,
currently if we remove clauses before fixing literal the proof is
wrong. 
 &lt;p&gt; \anchor _todo002305 (user): find a way to auto-tune that after a run on borg...
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Inprocessing Member \_internalref classoperations__research_1_1sat_1_1Inprocessing#a2fbf49af4f2bef7419f9eff0fc4847b2 "<a class="el" href="classoperations__research_1_1sat_1_1Inprocessing.html#a2fbf49af4f2bef7419f9eff0fc4847b2">operations_research::sat::Inprocessing::SubsumeAndStrenghtenRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002306 (user): Use better work limits, see SAT09.CRAFTED.ramseycube.Q3inK12&lt;p&gt; \anchor _todo002307 (user): Be more incremental, each time a clause is added/reduced track
which literal are impacted? Also try to do orthogonal reductions from one
round to the next. 
 &lt;p&gt; \anchor _todo002308 (user): We could do that only if we do some reduction, but this is
quite fast though. 
 &lt;p&gt; \anchor _todo002309 (user): probably faster without the size indirection. 
 &lt;p&gt; \anchor _todo002310 (user): Storing signatures here might be faster? 
 &lt;p&gt; \anchor _todo002311 (user): Better abort limit. We could also limit the watcher sizes and
never look at really long clauses. Note that for an easier
incrementality, it is better to reach some kind of completion so we know
what new stuff need to be done. 
 &lt;p&gt; \anchor _todo002312 (user): Do some reduction using binary clauses. Note that only clause
that never propagated since last round need to be checked for binary
subsumption. 
 &lt;p&gt; \anchor _todo002313 (user): remove first and see if other still removable. Alternatively
use a "removed" marker and redo a check for each clause that simplifies
this one? Or just remove the first one, and wait for next round. 
 &lt;p&gt; \anchor _todo002314 (user): No need to add this clause if we know it cannot subsume
any new clause since last round. i.e. unchanged clause that do not
contains any literals of newly added clause do not need to be added
here. We can track two bitset in LiteralWatchers via a register
mechanism:
- literal of newly watched clauses since last clear.
- literal of reduced clauses since last clear.&lt;p&gt; \anchor _todo002315 (user): We could/should sort the literal in this clause by
using literals that appear in a small number of clauses first so that
we maximize the chance of early abort in the critical loops above.&lt;p&gt; \anchor _todo002316 (user): We could also move the watched literal first so we always
skip it. 
 &lt;p&gt; \anchor _todo002317 (user): tune the deterministic time.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Class \_internalref classoperations__research_1_1sat_1_1IntegerEncoder "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">operations_research::sat::IntegerEncoder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001812 (user): We could also lazily create precedences Booleans between two
arbitrary IntegerVariable. This is better done in the PrecedencesPropagator
though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a1a4e1df43e180231715e6fde6b4d0a8d "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a1a4e1df43e180231715e6fde6b4d0a8d">operations_research::sat::IntegerEncoder::Canonicalize</a>" (IntegerLiteral i_lit) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001817 (user): This is linear in the domain "complexity", we can do better if
needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a44f7926d822f4f2f659be6f503090ac4 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a44f7926d822f4f2f659be6f503090ac4">operations_research::sat::IntegerEncoder::FullyEncodeVariable</a>" (IntegerVariable var)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001789 (user): Maybe we can optimize the literal creation order and their
polarity as our default SAT heuristics initially depends on this.&lt;p&gt; \anchor _todo001790 (user): Currently, in some corner cases,
GetOrCreateLiteralAssociatedToEquality() might trigger some propagation
that update the domain of var, so we need to cache the values to not read
garbage. Note that it is okay to call the function on values no longer
reachable, as this will just do nothing. 
 &lt;p&gt; \anchor _todo001816 (user): It is currently only possible to call that at the decision
level zero because we cannot add ternary clause in the middle of the
search (for now). This is Checked. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#acb0b1234e31f51f99e14860cd628cde2 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#acb0b1234e31f51f99e14860cd628cde2">operations_research::sat::IntegerEncoder::GetAssociatedLiteral</a>" (IntegerLiteral i_lit) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001795 (user): Canonicalization might be slow.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a86897b73c47086f4bc261f9424b47de7 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a86897b73c47086f4bc261f9424b47de7">operations_research::sat::IntegerEncoder::GetOrCreateAssociatedLiteral</a>" (IntegerLiteral i_lit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001793 (user): on some problem this happens. We should probably make sure that
we don't create extra fixed Boolean variable for no reason. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#af0a2aeea649e70334c5b44dca14a5ae2 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#af0a2aeea649e70334c5b44dca14a5ae2">operations_research::sat::IntegerEncoder::GetOrCreateLiteralAssociatedToEquality</a>" (IntegerVariable var, IntegerValue value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001794 (user): this happens on some problem. We should probably
make sure that we don't create extra fixed Boolean variable for no reason.
&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a575c98a8e638de20b5a3a5861263c732 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a575c98a8e638de20b5a3a5861263c732" title="Gets the literal always set to true, make it if it does not exist.">operations_research::sat::IntegerEncoder::GetTrueLiteral</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001818 (user): Make sure we abort right away on unsat! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a7c648e8ec1bcd260e3d4ed64b293bb28 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a7c648e8ec1bcd260e3d4ed64b293bb28" title="Memory optimization: you can call this before encoding variables.">operations_research::sat::IntegerEncoder::ReserveSpaceForNumVariables</a>" (int num_vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001788 (user): Reserve vector index by literals? It is trickier, as we might not
know beforehand how many we will need. Consider alternatives to not waste
space like using dequeue. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerEncoder Member \_internalref classoperations__research_1_1sat_1_1IntegerEncoder#a59abe9efe4246f146066483c1955e602 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html#a59abe9efe4246f146066483c1955e602">operations_research::sat::IntegerEncoder::VariableIsFullyEncoded</a>" (IntegerVariable var) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001791 (user): Cache result as long as equality_by_var_[index] is unchanged?
It might not be needed since if the variable is not fully encoded, then
PartialDomainEncoding() will filter unreachable values, and so the size
check will be false until further value have been encoded. 
 &lt;p&gt; \anchor _todo001792 (user): Comparing the size might be enough, but we want to be always
valid even if either (*domains_[var]) or PartialDomainEncoding(var) are
not properly synced because the propagation is not finished. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerRoundingCutHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerRoundingCutHelper#a55348bee0f2fe5505e28cc64ddfb1404 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerRoundingCutHelper.html#a55348bee0f2fe5505e28cc64ddfb1404" title="Returns true on success. The cut can be accessed via cut().">operations_research::sat::IntegerRoundingCutHelper::ComputeCut</a>" (RoundingOptions options, const CutData &amp;base_ct, ImpliedBoundsProcessor *ib_processor=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001654 (user): This is slow, 50% of run time on a2c1s1.pb.gz. Optimize!
 &lt;p&gt; \anchor _todo001655 (user): We assume that this is called with and without the option
use_ib_before_heuristic, so that we can abort if no IB has been applied
since then we will redo the computation. This is not really clean. 
 &lt;p&gt; \anchor _todo001656 (user): Experiment for the best value of this initial violation
threshold. Note also that we use the l2 norm on the restricted position
here. Maybe we should change that? On that note, the L2 norm usage seems
a bit weird to me since it grows with the number of term in the cut. And
often, we already have a good cut, and we make it stronger by adding
extra terms that do not change its activity.&lt;p&gt; \anchor _todo001657 (user): If the rhs is small and close to zero, we might want to
consider different way of complementing the variables. 
 &lt;p&gt; \anchor _todo001658 (user): Avoid quadratic algorithm? Note that we are quadratic in
relevant positions not the full cut size, but this is still too much on
some problems. 
 &lt;p&gt; \anchor _todo001659 (user): This can be quadratic! we don't want to try too much of them.
Or optimize the algo, we should be able to be more incremental here.
see on g200x740.pb.gz for instance. 
 &lt;p&gt; \anchor _todo001660 (user): It is still unclear if we have a * X + b * (1 - X) &lt;= rhs
for a Boolean X, what is the best way to apply f and if we should merge
the terms. If there is no other terms, best is probably
f(rhs - a) * X + f(rhs - b) * (1 - X). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#a48a2360caaae5ab4fb4d19f88a769fb6 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#a48a2360caaae5ab4fb4d19f88a769fb6">operations_research::sat::IntegerSearchHelper::GetDecisionLiteral</a>" (const BooleanOrIntegerLiteral &amp;decision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001886 (user): Ideally it would be cool to delay the creation even more
until we have a conflict with these decisions, but it is currently
hard to do so. 
 &lt;p&gt; \anchor _todo001887 (user): It would be nicer if this can never happen. For now, it
does because of the Propagate() not reaching the fixed point as
mentioned in a&lt;p&gt; \anchor _todo001888 &lt;p&gt; \anchor _todo001889 above. As a work-around, we display a message
but do not crash and recall the decision heuristic. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#aee604e664f5122db61cd4c73f437be2a "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#aee604e664f5122db61cd4c73f437be2a">operations_research::sat::IntegerSearchHelper::SolveIntegerProblem</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001891 (user): We have the issue that at level zero. calling the propagation
loop more than once can propagate more! This is because we call the LP
again and again on each level zero propagation. This is causing some
CHECKs() to fail in multithread (rarely) because when we associate new
literals to integer ones, Propagate() is indirectly called. Not sure yet
how to fix. 
 &lt;p&gt; \anchor _todo001892 (user): Experiment more around dynamically changing the
threshold for storing LP solutions in the pool. Alternatively expose
this as parameter so this can be tuned later.&lt;p&gt; \anchor _todo001893 (user): Avoid adding the same solution many time if the LP didn't
change. Avoid adding solution that are too deep in the tree (most
variable fixed). Also use a callback rather than having this here, we
don't want this file to depend on cp_model.proto. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerSearchHelper Member \_internalref classoperations__research_1_1sat_1_1IntegerSearchHelper#a2e2faa726399df6f91e4dc89d9ed5117 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerSearchHelper.html#a2e2faa726399df6f91e4dc89d9ed5117">operations_research::sat::IntegerSearchHelper::TakeDecision</a>" (Literal decision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001890 (user): on some problems, this function can be quite long. Expand
so that we can check the time limit at each step? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a6e9beefb349f99c5af795d1b6f793b4e "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a6e9beefb349f99c5af795d1b6f793b4e">operations_research::sat::IntegerTrail::AddAllGreaterThanConstantReason</a>" (absl::Span&lt; AffineExpression &gt; exprs, IntegerValue target_min, std::vector&lt; int &gt; *indices) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001827 (user): This might better lives together with the propagation code,
but it does need access to data about the reason/conflict being currently
computed. Also for speed we do need all the code here in on block. Given
than we have just a few "lazy integer reason", we might not really want a
generic code in any case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a528e39b17cbbdccc58f61b4db9fd4141 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a528e39b17cbbdccc58f61b4db9fd4141">operations_research::sat::IntegerTrail::AppendNewBoundsFrom</a>" (int base_index, std::vector&lt; IntegerLiteral &gt; *output) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001805 (user): Implement a dense version if there is more trail entries
than variables! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a07f3c5bf9ad7390cb25efb3f6a0de3b3 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a07f3c5bf9ad7390cb25efb3f6a0de3b3">operations_research::sat::IntegerTrail::ConditionalEnqueue</a>" (Literal lit, IntegerLiteral i_lit, std::vector&lt; Literal &gt; *literal_reason, std::vector&lt; IntegerLiteral &gt; *integer_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001798 (user): We could even keep the reason and maybe do some reasoning using
at_least_one constraint on a set of the Boolean used here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#ad5b56d63f8471e66f6a23c28660d1d1a "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#ad5b56d63f8471e66f6a23c28660d1d1a">operations_research::sat::IntegerTrail::Enqueue</a>" (IntegerLiteral i_lit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001825 (user): If the given bound is equal to the current bound, maybe the new
reason is better? how to decide and what to do in this case? to think about
it. Currently we simply don't do anything. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a8db6515dea5128a088044e4604d60440 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#ad5b56d63f8471e66f6a23c28660d1d1a">operations_research::sat::IntegerTrail::Enqueue</a>" (IntegerLiteral i_lit, absl::Span&lt; const Literal &gt; literal_reason, absl::Span&lt; const IntegerLiteral &gt; integer_reason, int trail_index_with_same_reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001826 (user): This currently cannot refer to a trail_index with a lazy
reason. Fix or at least check that this is the case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#ae3ea8da78f7a6ec038887174bbad6ceb "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#ae3ea8da78f7a6ec038887174bbad6ceb">operations_research::sat::IntegerTrail::Propagate</a>" (Trail *trail) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001796 (user): refactor the interaction IntegerTrail &lt;-&gt; IntegerEncoder so
that we can just push right away such literal. Unfortunately, this is is
a big chunk of work. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a08821cc13b185da58f8a0c7f1c4b30e6 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a08821cc13b185da58f8a0c7f1c4b30e6">operations_research::sat::IntegerTrail::Reason</a>" (const Trail &amp;trail, int trail_index, int64_t conflict_id) const final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001804 (user): If this is called many time on the same variables, it could be
made faster by using some caching mechanism. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a3f82268fd6c91332511a3d8765d6d07f "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a3f82268fd6c91332511a3d8765d6d07f">operations_research::sat::IntegerTrail::RelaxLinearReason</a>" (IntegerValue slack, absl::Span&lt; const IntegerValue &gt; coeffs, std::vector&lt; IntegerLiteral &gt; *reason) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001797 (user): Get rid of this function and only keep the trail index one?
 &lt;p&gt; \anchor _todo001822 (user): Requiring all initial literal to be at their current bound is
not really clean. Maybe we can change the API to only take IntegerVariable
and produce the reason directly.&lt;p&gt; \anchor _todo001823 (user): change API so that this work is performed during the conflict
analysis where we can be smarter in how we relax the reason. Note however
that this function is mainly used when we have a conflict, so this is not
really high priority.&lt;p&gt; \anchor _todo001824 (user): Test that the code work in the presence of integer overflow. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntegerTrail Member \_internalref classoperations__research_1_1sat_1_1IntegerTrail#a86dbd554c727e96c1ce6e33a54a73235 "<a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html#a86dbd554c727e96c1ce6e33a54a73235">operations_research::sat::IntegerTrail::UpdateInitialDomain</a>" (IntegerVariable var, Domain domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001821 (user): There is some memory inefficiency if this is called many time
because of the underlying data structure we use. In practice, when used
with a presolve, this is not often used, so that is fine though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4f8e9410f7631560e2efea8f401e5aa1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4f8e9410f7631560e2efea8f401e5aa1">operations_research::sat::IntegerValueSelectionHeuristic</a>" (std::function&lt; BooleanOrIntegerLiteral()&gt; var_selection_heuristic, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001866 (user): Experiment more with value selection heuristics. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntervalsRepository Member \_internalref classoperations__research_1_1sat_1_1IntervalsRepository#af5a505d1d9ccdd7a4b8d3c3242020c79 "<a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html#af5a505d1d9ccdd7a4b8d3c3242020c79">operations_research::sat::IntervalsRepository::CreatePrecedenceLiteral</a>" (AffineExpression x, AffineExpression y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001901 (user): Also add {{y_plus_one, x}, x_before_y.Negated()} ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntervalsRepository Member \_internalref classoperations__research_1_1sat_1_1IntervalsRepository#a3d86b6b4ffb8661a2a67a558aded3b85 "<a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html#a3d86b6b4ffb8661a2a67a558aded3b85">operations_research::sat::IntervalsRepository::GetOrCreateDisjunctivePrecedenceLiteral</a>" (const IntervalDefinition &amp;a, const IntervalDefinition &amp;b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001900 (user): also add the reverse like start_b + 1 &lt;= end_a if negated?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::IntervalsRepository Member \_internalref classoperations__research_1_1sat_1_1IntervalsRepository#ae9f8653f78ec2416053ba12305b3b2a7 "<a class="el" href="classoperations__research_1_1sat_1_1IntervalsRepository.html#ae9f8653f78ec2416053ba12305b3b2a7">operations_research::sat::IntervalsRepository::GetOrCreateHelper</a>" (const std::vector&lt; IntervalVariable &gt; &amp;variables, bool register_as_disjunctive_helper=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001902 (user): Ideally we should sort the vector of variables, but right now
we cannot since we often use this with a parallel vector of demands. So this
"sorting" should happen in the presolver so we can share as much as possible. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LazyReasonInterface Member \_internalref classoperations__research_1_1sat_1_1LazyReasonInterface#adc031164213fd9db6f79e99441240ded "<a class="el" href="classoperations__research_1_1sat_1_1LazyReasonInterface.html#adc031164213fd9db6f79e99441240ded">operations_research::sat::LazyReasonInterface::Explain</a>" (int id, IntegerValue propagation_slack, IntegerVariable var_to_explain, int trail_index, std::vector&lt; Literal &gt; *literals_reason, std::vector&lt; int &gt; *trail_indices_reason)=0&lt;/dt&gt;&lt;dd&gt; \anchor _todo001820 (user): {id, propagation_slack, var_to_explain, trail_index} is just a
generic "payload" and we should probably rename it as such so that each
implementation can store different things. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Class \_internalref classoperations__research_1_1sat_1_1LbTreeSearch "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html">operations_research::sat::LbTreeSearch</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001926 (user): What this is doing is really similar to asking a SAT solver if
the current objective lower bound is reachable by solving a SAT problem.
However, this code handle on the side all the "conflict" of the form
objective &gt; current_lb. As a result, when it is UNSAT, we can bump the lower
bound by a bigger amount than one. We also do not completely loose everything
learned so far for the next iteration. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Member \_internalref classoperations__research_1_1sat_1_1LbTreeSearch#ab578e3dd57e9e2c0daff912371d19dc2 "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab578e3dd57e9e2c0daff912371d19dc2">operations_research::sat::LbTreeSearch::LbTreeSearch</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001903 (user): Starts with an initial variable score for all variable in
the objective at their minimum value? this should emulate the first step of
the core approach and gives a similar bound. 
 &lt;p&gt; \anchor _todo001904 (user): if we have many independent LP, this will find nothing. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LbTreeSearch Member \_internalref classoperations__research_1_1sat_1_1LbTreeSearch#ab5eed5bfd114852c086831f49823d8ba "<a class="el" href="classoperations__research_1_1sat_1_1LbTreeSearch.html#ab5eed5bfd114852c086831f49823d8ba" title="Explores the search space.">operations_research::sat::LbTreeSearch::Search</a>" (const std::function&lt; void()&gt; &amp;feasible_solution_observer)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001907 (user): a strong branching initial start, or allowing a few decision
per nodes might be a better approach.&lt;p&gt; \anchor _todo001908 (user): It would also be cool to exploit the reason for the LB increase
even more. 
 &lt;p&gt; \anchor _todo001909 (user): This is slightly different than bumping each time we
push a decision that result in an LB increase. This is also called on
backjump for instance. 
 &lt;p&gt; \anchor _todo001910 (user): We also need to update pseudo cost on conflict.
 &lt;p&gt; \anchor _todo001911 (user): No point checking that if the objective lb wasn't
assigned at this level.&lt;p&gt; \anchor _todo001912 (user): Exploit the reasons further. 
 &lt;p&gt; \anchor _todo001913 (user): If we remember how far we can backjump for both true/false
branch, we could be more efficient. 
 &lt;p&gt; \anchor _todo001914 (user): If we have new information and our current objective bound
is higher than any bound in a whole subtree, we might want to just
restart this subtree exploration? 
 &lt;p&gt; \anchor _todo001915 (user): The code is hard to follow. Fix and merge that with test
below. 
 &lt;p&gt; \anchor _todo001916 (user): In multithread, this change the behavior a lot since we
dive until we beat the best shared bound. Maybe we shouldn't do that. 
 &lt;p&gt; \anchor _todo001917 (user): We sometimes branch on the objective variable, this should
probably be avoided. 
 &lt;p&gt; \anchor _todo001918 (user): it would be nice to mark some node as infeasible if
this is the case. However this could happen after many decision and
we realize with the lp that one of them should have been fixed
earlier, without any infeasibility in the current branch. 
 &lt;p&gt; \anchor _todo001919 (user): Try to minimize the number of decisions? 
 &lt;p&gt; \anchor _todo001920 (user): We should probably save the basis in more cases.
 &lt;p&gt; \anchor _todo001921 (user): Uses old optimal constraint that we just potentially
backtracked over?&lt;p&gt; \anchor _todo001922 (user): We could do all at once rather than in O(#decision * #size). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LevelZeroEquality Member \_internalref classoperations__research_1_1sat_1_1LevelZeroEquality#a6f4c89def00ad8b950b31383f59ba094 "<a class="el" href="classoperations__research_1_1sat_1_1LevelZeroEquality.html#a6f4c89def00ad8b950b31383f59ba094">operations_research::sat::LevelZeroEquality::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001840 (user): We could go even further than just the GCD, and do more
arithmetic to tighten the target bounds. See for instance a problem like
ej.mps.gz that we don't solve easily, but has just 3 variables! the goal is
to minimize X, given 31013 X - 41014 Y - 51015 Z = -31013 (all &gt;=0, Y and Z
bounded with high values). I know some MIP solvers have a basic linear
diophantine equation support. 
 &lt;p&gt; \anchor _todo001841 (user): Once the GCD is not 1, we could at any level make sure the
objective is of the correct form. For now, this only happen in a few
miplib problem that we close quickly, so I didn't add the extra code yet. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a18679d8902d037df4ad5371ab25ad435 "<a class="el" href="namespaceoperations__research_1_1sat.html#a18679d8902d037df4ad5371ab25ad435">operations_research::sat::LinearBooleanProblemToCnfString</a>" (const LinearBooleanProblem &amp;problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001116 (user): implement this trick. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Class \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html">operations_research::sat::LinearConstraintBuilder</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001930 (user): Rename to LinearExpressionBuilder? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#ae7f3237b747cd3a0ae75daf2f77e19d8 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#ae7f3237b747cd3a0ae75daf2f77e19d8">operations_research::sat::LinearConstraintBuilder::AddDecomposedProduct</a>" (absl::Span&lt; const LiteralValueValue &gt; product)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001927 (user): Checks the value of literals.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a00685724ff7957bd0b8dbb337b2eacd6 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a00685724ff7957bd0b8dbb337b2eacd6">operations_research::sat::LinearConstraintBuilder::AddQuadraticLowerBound</a>" (AffineExpression left, AffineExpression right, IntegerTrail *integer_trail, bool *is_quadratic=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001932 (user): We could use (max - delta) instead of (min + delta) for each
expression instead. This would depend on the LP value of the left and
right. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a2b9598a931a588949a8b5f5af8304ead "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a2b9598a931a588949a8b5f5af8304ead">operations_research::sat::LinearConstraintBuilder::Build</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001933 (user): this doesn't invalidate the builder object, but if one wants
to do a lot of dynamic editing to the constraint, then then underlying
algorithm needs to be optimized for that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintBuilder Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintBuilder#a029e8c7ac32054484a98093c2ad7629a "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintBuilder.html#a9c3eb68e76b59f3aae54a9d8cd4cf42e">operations_research::sat::LinearConstraintBuilder::LinearConstraintBuilder</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001931 (user): Have a subclass so we can enforce that a caller using
AddLiteralTerm() must construct the Builder with an encoder. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintManager#a42364a248af8f1f81b89bf607243f28a "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html#a42364a248af8f1f81b89bf607243f28a">operations_research::sat::LinearConstraintManager::Add</a>" (LinearConstraint ct, bool *added=nullptr, bool *folded=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001939 (user): Shall we simplify again? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintManager#a7ed5d2e7a9f57fe18d3962de8ee08815 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html#a7ed5d2e7a9f57fe18d3962de8ee08815">operations_research::sat::LinearConstraintManager::AddCut</a>" (LinearConstraint ct, std::string type_name, std::string extra_info="")&lt;/dt&gt;&lt;dd&gt; \anchor _todo001940 (user): We could prevent overflow by dividing more. Note that mainly
happen with super large variable domain since we usually restrict the size
of the generated coefficients in our cuts. So it shouldn't be that
important. 
 &lt;p&gt; \anchor _todo001941 (user): Use better heuristic here for detecting good cuts and mark
them undeletable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintManager#a6736aa5d3e7f0a44c29023b2bc85a453 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintManager.html#a6736aa5d3e7f0a44c29023b2bc85a453">operations_research::sat::LinearConstraintManager::ChangeLp</a>" (glop::BasisState *solution_state, int *num_new_constraints=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001945 (user): Because we simplified this constraint, it is possible that
it is now a duplicate of another one. Merge them. 
 &lt;p&gt; \anchor _todo001946 (user): This blowup factor could be adaptative w.r.t. the constraint
limit. 
 &lt;p&gt; \anchor _todo001947 (user): find better algo, this does 1000 * 4000 scalar product! 
 &lt;p&gt; \anchor _todo001948 (user): Experiment with different weights or different
functions for computing score. 
 &lt;p&gt; \anchor _todo001949 (user): Instead of comparing num_deletable_constraints with cut
limit, compare number of deletable constraints not in lp against the limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager::ConstraintInfo Member \_internalref structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo#a466661f3078984c94567ad58040edb6e "<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo.html#a466661f3078984c94567ad58040edb6e">operations_research::sat::LinearConstraintManager::ConstraintInfo::inactive_count</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001951 (user): This is the number of time the constraint was consecutively
inactive, and go up to 100 with the default param, so we could optimize
the space used more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager::ConstraintInfo Member \_internalref structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo#abdf73acb15ffe53b95a4131d9ba9aac9 "<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo.html#abdf73acb15ffe53b95a4131d9ba9aac9">operations_research::sat::LinearConstraintManager::ConstraintInfo::is_deletable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001953 (user): We can have a better heuristics. Some generated good cuts
can be marked undeletable and some unused problem specified constraints
can be marked deletable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintManager::ConstraintInfo Member \_internalref structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo#af933df23d6da0e5b34f2f92696b70800 "<a class="el" href="structoperations__research_1_1sat_1_1LinearConstraintManager_1_1ConstraintInfo.html#af933df23d6da0e5b34f2f92696b70800">operations_research::sat::LinearConstraintManager::ConstraintInfo::objective_parallelism_computed</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001952 (user): Pack bool and in general optimize the memory of this class.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Class \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001846 (user): Technically we could still have an int128 overflow since we
sum n terms that cannot overflow but can still be pretty close to the limit.
Make sure this never happens! For most problem though, because the variable
bounds will be smaller than 10^9, we are pretty safe.&lt;p&gt; \anchor _todo001847 (user): If one has many such constraint, it will be more efficient to
propagate all of them at once rather than doing it one at the time.&lt;p&gt; \anchor _todo001848 (user): Explore tree structure to get a log(n) complexity.&lt;p&gt; \anchor _todo001849 (user): When the variables are Boolean, use directly the pseudo-Boolean
constraint implementation. But we do need support for enforcement literals
there. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#a53f0cc28cdfafb5721ce374d3c16a973 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#a53f0cc28cdfafb5721ce374d3c16a973" title="NOTE(user): This is only used with int128, so we code only a single version.">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::ConditionalLb</a>" (IntegerLiteral integer_literal, IntegerVariable target_var) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001835 (user): If there is a conflict (negative slack) we can be more
precise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#ace49b8f6c8907a190c3aee7d359791fd "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#ace49b8f6c8907a190c3aee7d359791fd">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::LinearConstraintPropagator</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const IntegerValue &gt; coeffs, IntegerValue upper_bound, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001832 (user): deal with this corner case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#abd5b6d0682d0018f82fdce4233f6f576 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#ace49b8f6c8907a190c3aee7d359791fd">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::LinearConstraintPropagator</a>" (LinearConstraint ct, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001833 (user): Avoid duplication with other constructor.
 &lt;p&gt; \anchor _todo001834 (user): deal with this corner case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#ae4ae154271da65071742b6a7dbe2d460 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#ae4ae154271da65071742b6a7dbe2d460">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001836 (user): If the new ub fall into an hole of the variable, we can
actually relax the reason more by computing a better slack. 
 &lt;p&gt; \anchor _todo001837 (user): this is never supposed to happen since if we didn't have a
conflict above, we should be able to reduce the upper bound. It might
indicate an issue with our Boolean &lt;-&gt; integer encoding. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#afb899d80eaee9952f8076176b345ee15 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#afb899d80eaee9952f8076176b345ee15">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::PropagateAtLevelZero</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001838 (user): Deal with enforcements. It is just a bit of code to read the
value of the literals at level zero. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintPropagator#acb9913bc77648b9229d90f8ebc306939 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintPropagator.html#acb9913bc77648b9229d90f8ebc306939">operations_research::sat::LinearConstraintPropagator&lt; use_int128 &gt;::RegisterWith</a>" (GenericLiteralWatcher *watcher)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001839 (user): if there is more than one, maybe we should watch more to
propagate a "conflict" as soon as only one is unassigned? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearConstraintSymmetrizer Member \_internalref classoperations__research_1_1sat_1_1LinearConstraintSymmetrizer#a729e59f6b4ff81696c80dc501daf4ab1 "<a class="el" href="classoperations__research_1_1sat_1_1LinearConstraintSymmetrizer.html#a729e59f6b4ff81696c80dc501daf4ab1">operations_research::sat::LinearConstraintSymmetrizer::FoldLinearConstraint</a>" (LinearConstraint *ct, bool *folded=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001934 (user): think how to prove this properly and especially
that the scaling is in 1/orbit_size) and will each appear once. We then
substitute each sum by the sum over the orbit, and divide coefficient by
their gcd.&lt;p&gt; \anchor _todo001935 (user): Now that we know the actual coefficient we could scale less.
Maybe the coefficient of an orbit_var is already divisible by orbit_size. 
 &lt;p&gt; \anchor _todo001936 (user): In some cases, this constraint will propagate/fix directly
the orbit sum variables, we might want to propagate this in the cp world?
This migth also remove bad scaling. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearIncrementalEvaluator Member \_internalref classoperations__research_1_1sat_1_1LinearIncrementalEvaluator#ad15e855847e8e9fd85eb17774c2fe277 "<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html#ad15e855847e8e9fd85eb17774c2fe277">operations_research::sat::LinearIncrementalEvaluator::PrecomputeCompactView</a>" (absl::Span&lt; const int64_t &gt; var_max_variation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001188 (user): We could delete them before. But at the time of this
optimization, I didn't want to change the behavior of the algorithm at all. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearIncrementalEvaluator Member \_internalref classoperations__research_1_1sat_1_1LinearIncrementalEvaluator#aed1038acba7b405fb9c01417e3a1f05f "<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html#aed1038acba7b405fb9c01417e3a1f05f">operations_research::sat::LinearIncrementalEvaluator::SlopeBreakpoints</a>" (int var, int64_t current_value, const Domain &amp;var_domain) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001187 (user): Deal with holes? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearIncrementalEvaluator Member \_internalref classoperations__research_1_1sat_1_1LinearIncrementalEvaluator#a099aa35ca98c88c59a3ea7269c34e704 "<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html#a099aa35ca98c88c59a3ea7269c34e704" title="Also for feasibility jump.">operations_research::sat::LinearIncrementalEvaluator::UpdateScoreOnWeightUpdate</a>" (int c, absl::Span&lt; const int64_t &gt; jump_deltas, absl::Span&lt; double &gt; var_to_score_change)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001182 (user): optimize even more for one sided constraints.
Note(user): I tried to factor the two usage of this, but it is slower. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearIncrementalEvaluator Member \_internalref classoperations__research_1_1sat_1_1LinearIncrementalEvaluator#a201fdc143b0a225b578f5a5d123ef53a "<a class="el" href="classoperations__research_1_1sat_1_1LinearIncrementalEvaluator.html#a201fdc143b0a225b578f5a5d123ef53a">operations_research::sat::LinearIncrementalEvaluator::WeightedViolationDelta</a>" (absl::Span&lt; const double &gt; weights, int var, int64_t delta) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001186 (user): We can safely abort early if we know that delta will be &gt;= 0.
 &lt;p&gt; &lt;p&gt;(user): Maybe we can compute an absolute value instead of removing
old_distance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearModel Member \_internalref classoperations__research_1_1sat_1_1LinearModel#a8c594ce81043440f547bf1320674a829 "<a class="el" href="classoperations__research_1_1sat_1_1LinearModel.html#a8c594ce81043440f547bf1320674a829">operations_research::sat::LinearModel::LinearModel</a>" (const CpModelProto &amp;model_proto)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001954 (user): Do we use the loader code to detect full encodings and
element encodings. 
 &lt;p&gt; \anchor _todo001955 (user): Deal with/Check double insertion.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#ac0030221b056d71c560de62bd9d57a09 "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#ac0030221b056d71c560de62bd9d57a09">operations_research::sat::LinearProgrammingConstraint::IncrementalPropagate</a>" (const std::vector&lt; int &gt; &amp;watch_indices) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001971 (user): The saved lp solution is still valid given the current variable
bounds, so the LP optimal didn't change. However we might still want to add
new cuts or new lazy constraints?&lt;p&gt; \anchor _todo001972 (user): Propagate the last optimal_constraint? Note that we need
to be careful since the reversible int in IntegerSumLE are not registered.
However, because we delete "optimalconstraints" on backtrack, we might not
care.&lt;p&gt; \anchor _todo001973 (user): We might still have problem at level zero. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#ac305ae4d90e003c68c190a412f9879de "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#ac305ae4d90e003c68c190a412f9879de">operations_research::sat::LinearProgrammingConstraint::LinearProgrammingConstraint</a>" (Model *model, absl::Span&lt; const IntegerVariable &gt; vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001956 (user): make SatParameters singleton too, otherwise changing them after
a constraint was added will have no effect on this class. 
 &lt;p&gt; \anchor _todo001957 (user): We shouldn't need to add variable from the orbit here in the
presence of symmetry. However they can still appear in cut, so it is a
bit tricky and require some refactoring to be tried. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a7ff29ebe58aca89b537dc833cc1c45de "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a7ff29ebe58aca89b537dc833cc1c45de" title="PropagatorInterface API.">operations_research::sat::LinearProgrammingConstraint::Propagate</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo002002 (user): It seems the time we loose by not stopping early might be worth
it because we end up with a better explanation at optimality. 
 &lt;p&gt; \anchor _todo002003 (user): Refactor so that they are just normal cut generators? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearProgrammingConstraint Member \_internalref classoperations__research_1_1sat_1_1LinearProgrammingConstraint#a6f4001652e985a2165ad4d6602eae29b "<a class="el" href="classoperations__research_1_1sat_1_1LinearProgrammingConstraint.html#a6f4001652e985a2165ad4d6602eae29b" title="ReversibleInterface API.">operations_research::sat::LinearProgrammingConstraint::SetLevel</a>" (int level) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001966 (user): Keep all optimal solution in the current branch?
&lt;p&gt; \anchor _todo001967 &lt;p&gt; \anchor _todo001968 (user): Still try to add cuts/constraints though!
&lt;p&gt; \anchor _todo001969 &lt;p&gt; \anchor _todo001970 (user): Reload the basis? This might cause issue with the basis
saving/loading code in lb_tree_search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Class \_internalref classoperations__research_1_1sat_1_1LinearPropagator "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html">operations_research::sat::LinearPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002037 (user): This is a work in progress and is currently incomplete:
- Lack more incremental support for faster propag.
- Lack detection and propagation of at least one of these linear is true
  which can be used to propagate more bound if a variable appear in all these
  constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a6b4adf9e4a241637f5dee4cc9ea43adc "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a6b4adf9e4a241637f5dee4cc9ea43adc" title="Adds a new constraint to the propagator.">operations_research::sat::LinearPropagator::AddConstraint</a>" (absl::Span&lt; const Literal &gt; enforcement_literals, absl::Span&lt; const IntegerVariable &gt; vars, absl::Span&lt; const IntegerValue &gt; coeffs, IntegerValue upper_bound)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002019 (user): we still waste the space in coeffs_buffer_ so that the
start are aligned with the variables_buffer_. 
 &lt;p&gt; \anchor _todo002020 (user): With some care, when we cannot propagate or the
constraint is not enforced, we could leave in_queue_[] at true but
not put the constraint in the queue. 
 &lt;p&gt; \anchor _todo002021 (user): Shall we register root level precedence from here rather than
separately? 
 &lt;p&gt; \anchor _todo002022 (user): Shall we decide on some ordering here? maybe big coeff first
so that we get the largest change in slack? the idea being to propagate
large change first in case of cycles. 
 &lt;p&gt; \anchor _todo002023 (user): Do we want to do that? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a615cc74a74066501e840dcc2343738ec "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a615cc74a74066501e840dcc2343738ec">operations_research::sat::LinearPropagator::LinearPropagator</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002014 (user): When we start to push too much (Cycle?) we should see what
other propagator says before repropagating this one, system for call
later? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LinearPropagator Member \_internalref classoperations__research_1_1sat_1_1LinearPropagator#a74432b1f2031ef1a7257cf98913c7390 "<a class="el" href="classoperations__research_1_1sat_1_1LinearPropagator.html#a74432b1f2031ef1a7257cf98913c7390">operations_research::sat::LinearPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo002015 (user): More than the propagation speed, I think it is important to
have proper explanation, so if A pushes B, but later on the queue we have C
that push A that push B again, that might be bad? We can try to avoid this
even further, by organizing the queue in passes:
 - Scan all relevant constraints, remember who pushes but DO NOT push yet!
 - If no cycle, do not pushes constraint whose slack will changes due to
   other pushes.
 - consider the new constraint that need to be scanned and repeat.
I think it is okay to scan twice the constraints that push something in
order to get better explanation. We tend to diverge from the class shortest
path algo in this regard.&lt;p&gt; \anchor _todo002016 (user): If we push the idea further, can we first compute the fix point
without pushing anything, then compute a good order of constraints for the
explanations? what is tricky is that we might need to "scan" more than once
a constraint I think. ex: Y, Z, T &gt;=0
 - 2 * Y + Z + T &lt;= 11   ==&gt;   Y &lt;= 5, Z &lt;= 11, T &lt;= 11  (1)
 - Z + Y &gt;= 6            ==&gt;   Z &gt;= 1
 - (1) again to push T &lt;= 10  and reach the propagation fixed point. 
 &lt;p&gt; \anchor _todo002017 (user): Maybe we should "update" explanation if we have a shorter
one to be less reliant on the propagation order. 
 &lt;p&gt; \anchor _todo002018 (user): This do not seems always good, especially since we pushed
Boolean with a really small explanation, maybe we want to push more of
these rather than go back to pure-binary propagation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Literal Member \_internalref classoperations__research_1_1sat_1_1Literal#a3b27485970070e73266f5530d2a7f55c "operations_research::sat::Literal::operator LiteralIndex" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002277 (user): LiteralIndex might not even be needed, but because of the
signed value business, it is still safer with it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a277ebf478f1fa693dd01867071080203 "<a class="el" href="namespaceoperations__research_1_1sat.html#a277ebf478f1fa693dd01867071080203">operations_research::sat::LoadAndSolveCpModelForTest</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001556 (user): Clean this up.
Solves a CpModelProto without any processing. Only used for unit tests. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a1efa4af8efff3dc82feb1add05075c63 "<a class="el" href="namespaceoperations__research_1_1sat.html#a1efa4af8efff3dc82feb1add05075c63">operations_research::sat::LoadBaseModel</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001560 (user): The core algo and symmetries seems to be problematic in some
cases. See for instance: neos-691058.mps.gz. This is probably because as
we modify the model, our symmetry might be wrong? investigate.&lt;p&gt; \anchor _todo001561 (user): More generally, we cannot load the symmetry if we create
new Booleans and constraints that link them to some Booleans of the model.
Creating Booleans related to integer variable is fine since we only deal
with Boolean only symmetry here. It is why we disable this when we have
linear relaxation as some of them create new constraints. 
 &lt;p&gt; \anchor _todo001562 (user): This is wrong. We should support a MODEL_INVALID end of solve
in the SharedResponseManager. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0df7b56e0026b783deeeff20487de7cf "<a class="el" href="namespaceoperations__research_1_1sat.html#a0df7b56e0026b783deeeff20487de7cf" title="Loads a BooleanProblem into a given SatSolver instance.">operations_research::sat::LoadBooleanProblem</a>" (const LinearBooleanProblem &amp;problem, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001115 (user): Currently, the sat solver can load without any issue
constraints with duplicate variables, so we just output a warning if the
problem is not "valid". Make this a strong check once we have some
preprocessing step to remove duplicates variable in the constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a64c230730625662a2a2032da620b6c6e "<a class="el" href="namespaceoperations__research_1_1sat.html#a64c230730625662a2a2032da620b6c6e">operations_research::sat::LoadBooleanSymmetries</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001282 (user): We could add these extra Boolean during expansion/presolve so
that we have the symmetry involing them. Or maybe comes up with a different
solution. 
 &lt;p&gt; \anchor _todo001300 (user): We currently only have the code for Booleans, it is why we
currently ignore symmetries involving integer variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4b4da650bfcb86c00bee1df0ab0cc953 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4b4da650bfcb86c00bee1df0ab0cc953" title="LinearConstraint version.">operations_research::sat::LoadConditionalLinearConstraint</a>" (const absl::Span&lt; const Literal &gt; enforcement_literals, const LinearConstraint &amp;cst, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001855 (user): Remove the conversion!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad81c56ee655b074e6d565cd223a70024 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad81c56ee655b074e6d565cd223a70024">operations_research::sat::LoadCpModel</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001563 (user): We don't have a good deterministic time on all constraints,
so this might take more time than wanted. 
 &lt;p&gt; \anchor _todo001564 (user): This might still create intermediate variables to
decompose the objective for no reason. Just deal directly with the
objective domain in the core algo by forbidding bad assumptions?
Alternatively, just ignore the core solution if it is "too" good and
rely on other solvers? 
 &lt;p&gt; \anchor _todo001565 (user): Support objective bounds import in LNS and Core based
search. 
 &lt;p&gt; \anchor _todo001566 (user): Remove code duplication with the solution_observer in
SolveLoadedCpModel(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ade08c3522dfce173ee1fd50fab3bd3c0 "<a class="el" href="namespaceoperations__research_1_1sat.html#ade08c3522dfce173ee1fd50fab3bd3c0">operations_research::sat::LoadLinearConstraint</a>" (const ConstraintProto &amp;ct, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001296 (user): Actually this should never be called since we process
linear1 in ExtractEncoding(). 
 &lt;p&gt; \anchor _todo001297 (user): Reuse ComputeLinearBounds()? but then we need another loop
to detect if we only have Booleans. 
 &lt;p&gt; \anchor _todo001298 (user): we should probably also implement an
half-reified version of this constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a23861bab6341cfcfeeff90c2b3e3ab7e "<a class="el" href="namespaceoperations__research_1_1sat.html#a23861bab6341cfcfeeff90c2b3e3ab7e">operations_research::sat::LoadLinMaxConstraint</a>" (const ConstraintProto &amp;ct, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001299 (user): Consider replacing the min propagator by max.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0f015dd7f088e0a586993ec925a94ced "<a class="el" href="namespaceoperations__research_1_1sat.html#a0f015dd7f088e0a586993ec925a94ced">operations_research::sat::LoadModelForProbing</a>" (PresolveContext *context, Model *local_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002216 (user): The model we load does not contain affine relations! But
ideally we should be able to remove all of them once we allow more complex
constraints to contains linear expression.&lt;p&gt; \anchor _todo002217 (user): remove code duplication with cp_model_solver. Here we also do
not run the heuristic to decide which variable to fully encode.&lt;p&gt; \anchor _todo002218 (user): Maybe do not load slow to propagate constraints? for instance
we do not use any linear relaxation here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a3609d4b9a2bd583c9daaa19a2f27e711 "<a class="el" href="namespaceoperations__research_1_1sat.html#a3609d4b9a2bd583c9daaa19a2f27e711">operations_research::sat::LoadSubcircuitConstraint</a>" (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const Literal &gt; literals, Model *model, bool multiple_subcircuit_through_zero)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001129 (user): Just ignore node zero if multiple_subcircuit_through_zero is
true. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a47e5d5cb3e7eb43191d094fc4752b5c6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a47e5d5cb3e7eb43191d094fc4752b5c6">operations_research::sat::LoadVariables</a>" (const CpModelProto &amp;model_proto, bool view_all_booleans_as_integers, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001281 (user): Fix the constant variable situation. An optional interval
with constant start/end or size cannot share the same constant
variable if it is used in non-optional situation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LocalBranchingLpBasedNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1LocalBranchingLpBasedNeighborhoodGenerator#a990c066dc55c689938c9229e9580f428 "<a class="el" href="classoperations__research_1_1sat_1_1LocalBranchingLpBasedNeighborhoodGenerator.html#a990c066dc55c689938c9229e9580f428">operations_research::sat::LocalBranchingLpBasedNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, SolveData &amp;data, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001259 (user): that might not be the most efficient if we abort just below. 
 &lt;p&gt; \anchor _todo001260 (user): This is a lot longer than a normal LNS, so it might cause
issue with the current round-robbin selection based on number of calls. 
 &lt;p&gt; \anchor _todo001261 (user): Shall we pass the objective upper bound so we have more
chance to fix variable via reduced cost fixing.&lt;p&gt; \anchor _todo001262 (user): Does the current solution can provide a warm-start for the
LP? 
 &lt;p&gt; \anchor _todo001263 (user): If we run into this case, it also means that every other LNS
that tries to more variable than here will never be able to improve. 
 &lt;p&gt; \anchor _todo001264 (user): Unfortunately like this we have a common difficulty for all
variant, we should probably fix that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae9ec04c047ef7bfe5cfa06c17ff0c76d "<a class="el" href="namespaceoperations__research_1_1sat.html#ae9ec04c047ef7bfe5cfa06c17ff0c76d">operations_research::sat::LpPseudoCostHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001861 (user): Use strong branching when not reliable.
&lt;p&gt; \anchor _todo001862 &lt;p&gt; \anchor _todo001863 (user): do not branch on integer lp? however it seems better to
do that !? Maybe this is because if it has a high pseudo cost
average, it is good anyway? 
 &lt;p&gt; \anchor _todo001864 (user): investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LsEvaluator Class \_internalref classoperations__research_1_1sat_1_1LsEvaluator "<a class="el" href="classoperations__research_1_1sat_1_1LsEvaluator.html">operations_research::sat::LsEvaluator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001192 (user): Ideas for constraint generated moves or sequences of moves? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LsEvaluator Member \_internalref classoperations__research_1_1sat_1_1LsEvaluator#a55666b5aee7e751b4bc51f963c2fbaa3 "<a class="el" href="classoperations__research_1_1sat_1_1LsEvaluator.html#a55666b5aee7e751b4bc51f963c2fbaa3">operations_research::sat::LsEvaluator::DeterministicTime</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001193 (user): Properly account all big time consumers.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::LsEvaluator Member \_internalref classoperations__research_1_1sat_1_1LsEvaluator#ac2c554a2c06db8258745c13c4c33ee5b "<a class="el" href="classoperations__research_1_1sat_1_1LsEvaluator.html#ac2c554a2c06db8258745c13c4c33ee5b">operations_research::sat::LsEvaluator::WeightedViolationDelta</a>" (bool linear_only, absl::Span&lt; const double &gt; weights, int var, int64_t delta, absl::Span&lt; int64_t &gt; mutable_solution) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001190 (user): refine on a per constraint basis. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af004193a12bf9ed78b295e7f7cb51e6f "<a class="el" href="namespaceoperations__research_1_1sat.html#af004193a12bf9ed78b295e7f7cb51e6f">operations_research::sat::MinimizeCore</a>" (SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002392 (user): One should use MinimizeCoreWithPropagation() instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4d6ba15542ec5d59958de53c92279b2a "<a class="el" href="namespaceoperations__research_1_1sat.html#a4d6ba15542ec5d59958de53c92279b2a">operations_research::sat::MinimizeCoreWithPropagation</a>" (TimeLimit *limit, SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002120 (user): Avoid spending too much time trying to minimize a core. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a56ad40efdac4d337987b0ca306aa7bd6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a56ad40efdac4d337987b0ca306aa7bd6">operations_research::sat::MinimizeCoreWithSearch</a>" (TimeLimit *limit, SatSolver *solver, std::vector&lt; Literal &gt; *core)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002095 (user): tune.
 &lt;p&gt; \anchor _todo002096 (user): Properly use the node depth instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a633a2eb5447b0e49f8958cb4bb4b7a44 "<a class="el" href="namespaceoperations__research_1_1sat.html#a633a2eb5447b0e49f8958cb4bb4b7a44">operations_research::sat::MinimizeL1DistanceWithHint</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001572 (user): As of now the repair hint doesn't support when
enumerate_all_solutions is set since the solution is created on a different
model. 
 &lt;p&gt; \anchor _todo001573 (user): For boolean variables we can avoid creating new variables.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MinPropagator Class \_internalref classoperations__research_1_1sat_1_1MinPropagator "<a class="el" href="classoperations__research_1_1sat_1_1MinPropagator.html">operations_research::sat::MinPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001850 (user): Implement a more efficient algorithm when the need arise. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MinPropagator Member \_internalref classoperations__research_1_1sat_1_1MinPropagator#aa5ab4a97c4fe03823494846846b5accd "<a class="el" href="classoperations__research_1_1sat_1_1MinPropagator.html#aa5ab4a97c4fe03823494846846b5accd">operations_research::sat::MinPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001842 (user): Not sure this code is useful since this will be detected
by the fact that the [lb, ub] of the min is empty. It depends on the
propagation order though, but probably the precedences propagator would
propagate before this one. So change this to a CHECK? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Model Member \_internalref classoperations__research_1_1sat_1_1Model#ad025b208280b29fc3cfe2b7d3d61c8f9 "<a class="el" href="classoperations__research_1_1sat_1_1Model.html#ad025b208280b29fc3cfe2b7d3d61c8f9">operations_research::sat::Model::GetOrCreate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002093 (user): directly store std::unique_ptr&lt;&gt; in singletons_? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ModelCopy Member \_internalref classoperations__research_1_1sat_1_1ModelCopy#ac6485d6a1464dec0bb052ecbf1db3da9 "<a class="el" href="classoperations__research_1_1sat_1_1ModelCopy.html#ac6485d6a1464dec0bb052ecbf1db3da9">operations_research::sat::ModelCopy::ImportAndSimplifyConstraints</a>" (const CpModelProto &amp;in_model, bool first_copy=false, std::function&lt; bool(int)&gt; active_constraints=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001204 (user): Merge with the phase 1 of the presolve code.&lt;p&gt; \anchor _todo001205 (user): It seems easy to forget to update this if any new constraint
contains an interval or if we add a field to an existing constraint. Find a
way to remind contributor to not forget this. 
 &lt;p&gt; \anchor _todo001206 (user): if ignore_names is false, we should make sure the
name are properly copied by all these functions. Or we should never copy
name and have a separate if (!ignore_name) copy the name... 
 &lt;p&gt; \anchor _todo001207 (user): find a better way than copy then clear_name()?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ModelRandomGenerator Member \_internalref classoperations__research_1_1sat_1_1ModelRandomGenerator#a94be5f7295c63407b5efb55e55724391 "<a class="el" href="classoperations__research_1_1sat_1_1ModelRandomGenerator.html#a94be5f7295c63407b5efb55e55724391">operations_research::sat::ModelRandomGenerator::LogSalt</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002503 (user): I didn't find a cleaner way to log this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a4a9b63c72d02a80a8f76efbb0f020a3f "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a4a9b63c72d02a80a8f76efbb0f020a3f">operations_research::sat::MutableUpperBoundedLinearConstraint::ClearAll</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002130 (user): We could be more efficient and have only one loop here.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a56db11b9d396d13e4cff87b74b086d81 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a56db11b9d396d13e4cff87b74b086d81">operations_research::sat::MutableUpperBoundedLinearConstraint::ComputeSlackForTrailPrefix</a>" (const Trail &amp;trail, int trail_index) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002132 (user): Keep this for DCHECK(), but maintain the slack incrementally
instead of recomputing it. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a467eaf21318efb233670a0035a2eae34 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a467eaf21318efb233670a0035a2eae34">operations_research::sat::MutableUpperBoundedLinearConstraint::ReduceCoefficients</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002131 (user): Also reduce the trivially false literal when coeff &gt; rhs_ ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::MutableUpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint#a2d8ea04aaae8c892a39770e35eced029 "<a class="el" href="classoperations__research_1_1sat_1_1MutableUpperBoundedLinearConstraint.html#a2d8ea04aaae8c892a39770e35eced029">operations_research::sat::MutableUpperBoundedLinearConstraint::ReduceCoefficientsAndComputeSlackForTrailPrefix</a>" (const Trail &amp;trail, int trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002146 (user): Ideally the slack should be maitainable incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Neighborhood Member \_internalref structoperations__research_1_1sat_1_1Neighborhood#a9d77507f928ca9524da987bfbf75eee8 "<a class="el" href="structoperations__research_1_1sat_1_1Neighborhood.html#a9d77507f928ca9524da987bfbf75eee8">operations_research::sat::Neighborhood::id</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001276 (user): Make sure that the id is unique for each generated
neighborhood for each generator. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGenerator#ac8a7ed70ccae23b555deecf09756273f "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGenerator.html#ac8a7ed70ccae23b555deecf09756273f">operations_research::sat::NeighborhoodGenerator::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo001253 (user): Weight more recent data.
degrade the current average to forget old learnings. 
 &lt;p&gt; \anchor _todo001254 (user): experiment with resetting the time limit if a solution is
found. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#a5aaa19b49886daea69dca24a40a3e422 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#a5aaa19b49886daea69dca24a40a3e422">operations_research::sat::NeighborhoodGeneratorHelper::FixGivenVariables</a>" (const CpSolverResponse &amp;base_solution, const Bitset64&lt; int &gt; &amp;variables_to_fix) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001249 (user): Maybe relax all variables in the objective when the number
is small or negligible compared to the number of variables. 
 &lt;p&gt; \anchor _todo001250 (user): If there is just one component, we can skip some computation. 
 &lt;p&gt; \anchor _todo001251 (user): We could handle some complex domain (size &gt; 2). 
 &lt;p&gt; \anchor _todo001252 (user): force better objective? Note that this is already done when the
hint above is successfully loaded (i.e. if it passes the presolve
correctly) since the solver will try to find better solution than the
current one. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#aca0952c56878d9ecc6a8557bd42d170e "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#aca0952c56878d9ecc6a8557bd42d170e">operations_research::sat::NeighborhoodGeneratorHelper::GetSchedulingPrecedences</a>" (const absl::flat_hash_set&lt; int &gt; &amp;ignored_intervals, const CpSolverResponse &amp;initial_solution, absl::BitGenRef random) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001247 (user): We could scan for model precedences and add them to the list
of precedences. This could enable more simplifications in the transitive
reduction phase. 
 &lt;p&gt; \anchor _todo001248 (user): Reduce precedence graph
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#aebc02302feafecf7907a5fcc097b7486 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#aebc02302feafecf7907a5fcc097b7486">operations_research::sat::NeighborhoodGeneratorHelper::graph_mutex_</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001277 (user): Refactor the class to be thread-safe instead, it should be
safer and more easily maintainable. Some complication with accessing the
variable&lt;-&gt;constraint graph efficiently though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NeighborhoodGeneratorHelper Member \_internalref classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper#a83668c50ed54cfcd6b559374579eeca7 "<a class="el" href="classoperations__research_1_1sat_1_1NeighborhoodGeneratorHelper.html#a83668c50ed54cfcd6b559374579eeca7">operations_research::sat::NeighborhoodGeneratorHelper::Synchronize</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo001234 (user): We could set the optional literal to false directly in
the bound sharing manager. We do have to be careful that all the
different solvers have the same optionality definition though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a10700832ca6bc420f2931eb707957b0b "<a class="el" href="namespaceoperations__research_1_1sat.html#a10700832ca6bc420f2931eb707957b0b">operations_research::sat::NewSatParameters</a>" (const std::string &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001526 (user): Support it on android.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4bd54ab16ebc1bd6fa80d1e23ab79adc "<a class="el" href="namespaceoperations__research_1_1sat.html#a10700832ca6bc420f2931eb707957b0b">operations_research::sat::NewSatParameters</a>" (const sat::SatParameters &amp;parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001527 (user): A notable exception to this is the TimeLimit which is
currently not initializing itself from the SatParameters in the model. It
will also starts counting from the time of its creation. It will be good
to find a solution that is less error prone. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad8af8f787d40f2ccb96beb5306c913c5 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad8af8f787d40f2ccb96beb5306c913c5">operations_research::sat::NewWeightedSum</a>" (const VectorInt &amp;coefficients, const std::vector&lt; IntegerVariable &gt; &amp;vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001856 (user): invert the coefficients/vars arguments. 
 &lt;p&gt; \anchor _todo001857 (user): deal with overflow here too! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NoCyclePropagator Member \_internalref classoperations__research_1_1sat_1_1NoCyclePropagator#acf6adfa6b3e9dae69d547428a884d51e "<a class="el" href="classoperations__research_1_1sat_1_1NoCyclePropagator.html#acf6adfa6b3e9dae69d547428a884d51e">operations_research::sat::NoCyclePropagator::NoCyclePropagator</a>" (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const Literal &gt; literals, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001125 (user): Uniformize this across propagator. Sometimes it is nice not
to register them, but most of them can be registered right away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NoCyclePropagator Member \_internalref classoperations__research_1_1sat_1_1NoCyclePropagator#a0751bd29114a60910d7626a21eb88b94 "<a class="el" href="classoperations__research_1_1sat_1_1NoCyclePropagator.html#a0751bd29114a60910d7626a21eb88b94">operations_research::sat::NoCyclePropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001126 (user): only explore node with newly added arcs.&lt;p&gt; \anchor _todo001127 (user): We could easily re-index the graph so that only nodes with arcs
are used. Because right now we are in O(num_nodes) even if the graph is
empty. 
 &lt;p&gt; \anchor _todo001128 (user): We could be more efficient here, but this is only executed on
conflicts. We should at least make sure we return a single cycle even
though if this is called often enough, we shouldn't have a lot more than
this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8be20b017a46b4e9d7097ee32622eba8 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8be20b017a46b4e9d7097ee32622eba8">operations_research::sat::NonDeterministicLoop</a>" (std::vector&lt; std::unique_ptr&lt; SubSolver &gt; &gt; &amp;subsolvers, const int num_threads, ModelSharedTimeLimit *time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002451 (user): We could also directly register callback to set stopping
Boolean to false in a few places. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::NonOverlappingRectanglesEnergyPropagator Member \_internalref classoperations__research_1_1sat_1_1NonOverlappingRectanglesEnergyPropagator#a62a25736327376f2887d657c9885ee4b "<a class="el" href="classoperations__research_1_1sat_1_1NonOverlappingRectanglesEnergyPropagator.html#a62a25736327376f2887d657c9885ee4b">operations_research::sat::NonOverlappingRectanglesEnergyPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001696 (user): double-check/revisit the algo for box of variable sizes.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ObjectiveEncoder Member \_internalref classoperations__research_1_1sat_1_1ObjectiveEncoder#aba8bf46b2a10fabd82ffd3dbf2f0e174 "<a class="el" href="classoperations__research_1_1sat_1_1ObjectiveEncoder.html#aba8bf46b2a10fabd82ffd3dbf2f0e174">operations_research::sat::ObjectiveEncoder::nodes</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001747 (user): Remove mutable version once refactoring is done.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ObjectiveEncoder Member \_internalref classoperations__research_1_1sat_1_1ObjectiveEncoder#aea57787b48ca659a4962d5b674a72762 "<a class="el" href="classoperations__research_1_1sat_1_1ObjectiveEncoder.html#aea57787b48ca659a4962d5b674a72762">operations_research::sat::ObjectiveEncoder::ProcessCore</a>" (absl::Span&lt; const Literal &gt; core, Coefficient min_weight, Coefficient gap, std::string *info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001743 (user): propagate proper ub first.
 &lt;p&gt; \anchor _todo001744 (user): this node is closed and can be removed from the core.
 &lt;p&gt; \anchor _todo001745 (user): If assignment.LiteralIsTrue(bool_nodes[j]) We can
minimize the core here by removing bool_nodes[i] from it. Note
however that since we already minimized the core, this is
unlikely to happen. 
 &lt;p&gt; \anchor _todo001746 (user): If we infered the exactly one from the binary implication
graph, there is no need to add the amo since it is already there. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ObjectiveShavingSolver Member \_internalref classoperations__research_1_1sat_1_1ObjectiveShavingSolver#a7885d03789e15398197965ce723c3d59 "<a class="el" href="classoperations__research_1_1sat_1_1ObjectiveShavingSolver.html#a7885d03789e15398197965ce723c3d59">operations_research::sat::ObjectiveShavingSolver::Synchronize</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo002425 (user): Also stop if we have enough newly fixed / improved root level
bounds so that we think it is worth represolving and restarting. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a09190309faf157e3b7187403cfcb514c "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a09190309faf157e3b7187403cfcb514c">operations_research::sat::PbConstraints::AddConstraint</a>" (const std::vector&lt; LiteralWithCoeff &gt; &amp;cst, Coefficient rhs, Trail *trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002138 (user): This is relatively slow. Take the "transpose" all at once, and
maybe put small constraints first on the to_update_ lists. 
 &lt;p&gt; \anchor _todo002139 (user): the index is needed to give the correct thresholds_ entry
to InitializeRhs() below, but this linear scan is not super
efficient. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a9474a3e975c9c26b00740c514d82c373 "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a9474a3e975c9c26b00740c514d82c373">operations_research::sat::PbConstraints::BumpActivity</a>" (UpperBoundedLinearConstraint *constraint)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002151 (user): Remove duplication with other activity update functions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PbConstraints Member \_internalref classoperations__research_1_1sat_1_1PbConstraints#a38e94ac484dcbd409e942d4e6f51d585 "<a class="el" href="classoperations__research_1_1sat_1_1PbConstraints.html#a38e94ac484dcbd409e942d4e6f51d585">operations_research::sat::PbConstraints::ClearConflictingConstraint</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002150 (user): This is a hack to get the PB conflict, because the rest of
the solver API assume only clause conflict. Find a cleaner way? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PostsolveClauses Struct \_internalref structoperations__research_1_1sat_1_1PostsolveClauses "<a class="el" href="structoperations__research_1_1sat_1_1PostsolveClauses.html">operations_research::sat::PostsolveClauses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002348 (user): Use a flat memory structure instead. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a1951d3606d9c0c92204c310b911bf0e7 "<a class="el" href="namespaceoperations__research_1_1sat.html#a1951d3606d9c0c92204c310b911bf0e7">operations_research::sat::PostsolveLinear</a>" (const ConstraintProto &amp;ct, std::vector&lt; Domain &gt; *domains)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001304 (user): This is a bit hacky, if we need to postsolve both
constraints at once, it might be cleaner to do that in a single
postsolve operation. However this allows us to reuse normal constraints
for the postsolve specification, which is nice. 
 &lt;p&gt; \anchor _todo001305 (user): I am not 100% that the algo here might cover all the presolve
case, so if this fail, it might indicate an issue here and not in the
presolve/solver code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aba206d3b30a8812e9fae0e74c7277ad9 "<a class="el" href="namespaceoperations__research_1_1sat.html#aba206d3b30a8812e9fae0e74c7277ad9">operations_research::sat::PostsolveResponse</a>" (const int64_t num_variables_in_original_model, const CpModelProto &amp;mapping_proto, absl::Span&lt; const int &gt; postsolve_mapping, std::vector&lt; int64_t &gt; *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001306 (user): We could use the search strategy to fix free variables to some
chosen values? The feature might never be needed though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5c02c475828b411a8dbd4b3c399eb251 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5c02c475828b411a8dbd4b3c399eb251">operations_research::sat::PostsolveResponseWithFullSolver</a>" (int num_variables_in_original_model, CpModelProto mapping_proto, absl::Span&lt; const int &gt; postsolve_mapping, std::vector&lt; int64_t &gt; *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001574 (user): If this ever shows up in the profile, we could avoid copying
the mapping_proto if we are careful about how we modify the variable domain
before postsolving it. Note that 'num_variables_in_original_model' refers to
the model before presolve. 
 &lt;p&gt; \anchor _todo001575 (user): this problem is usually trivial, but we may still want to
impose a time limit or copy some of the parameters passed by the user. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Class \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html">operations_research::sat::PrecedenceRelations</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002187 (user): Support conditional relation.
 &lt;p&gt; &lt;p&gt;(user): Support non-DAG like graph.
 &lt;p&gt; &lt;p&gt;(user): Support variable offset that can be updated as search progress. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Member \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations#a4ca1b54209b1598460d8ef4eee99221b "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html#a4ca1b54209b1598460d8ef4eee99221b">operations_research::sat::PrecedenceRelations::Add</a>" (IntegerVariable tail, IntegerVariable head, IntegerValue offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002153 (user): Return infeasible if tail == head and offset &gt; 0.
&lt;p&gt; \anchor _todo002154 &lt;p&gt; \anchor _todo002155 (user): if tail = Negation(head) also update Domain. 
 &lt;p&gt; \anchor _todo002156 (user): AddInternal() only returns true if this is the first relation
between head and tail. But we can still avoid an extra lookup. 
 &lt;p&gt; \anchor _todo002157 (user): Alternatively, force caller to do a Resize(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Member \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations#a95dab1b3432098f1e966ec42fb3a26f3 "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html#a95dab1b3432098f1e966ec42fb3a26f3">operations_research::sat::PrecedenceRelations::Build</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002158 (user): Support negative offset?&lt;p&gt; \anchor _todo002159 (user): This can fail if we don't have a DAG. We could just skip Bad
edges instead, and have a sub-DAG as an heuristic. Or analyze the arc
weight and make sure cycle are not an issue. We can also start with arcs
with strictly positive weight.&lt;p&gt; \anchor _todo002160 (user): Only explore the sub-graph reachable from "vars". 
 &lt;p&gt; \anchor _todo002161 (user): Also do that if we don't have a DAG? 
 &lt;p&gt; \anchor _todo002197 (user): Be more dynamic as we start to add relations during search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedenceRelations Member \_internalref classoperations__research_1_1sat_1_1PrecedenceRelations#acc266b82a08891d9278284b41a66a9ce "<a class="el" href="classoperations__research_1_1sat_1_1PrecedenceRelations.html#acc266b82a08891d9278284b41a66a9ce">operations_research::sat::PrecedenceRelations::ComputeFullPrecedences</a>" (absl::Span&lt; const IntegerVariable &gt; vars, std::vector&lt; FullIntegerPrecedence &gt; *output)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002162 (user): use vector of fixed size. 
 &lt;p&gt; \anchor _todo002163 (user): optimize when needed. 
 &lt;p&gt; \anchor _todo002164 (user): Release the memory right away. 
 &lt;p&gt; \anchor _todo002193 (user): generalize.&lt;p&gt; \anchor _todo002194 (user): Put some work limit in place, as this can be slow. Complexity
is in O(vars.size()) * num_arcs.&lt;p&gt; \anchor _todo002195 (user): Since we don't need ALL precedences, we could just work on a
sub-DAG of the full precedence graph instead of aborting. Or we can just
support the general non-DAG cases.&lt;p&gt; \anchor _todo002196 (user): Many relations can be redundant. Filter them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Class \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html">operations_research::sat::PrecedencesPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002188 (user): We could easily generalize the code to support any relation of
the form a*X + b*Y + c*Z &gt;= rhs (or &lt;=). Do that since this class should be
a lot faster at propagating small linear inequality than the generic
propagator and the overhead of supporting coefficient should not be too bad. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a15a72ea359f6b0297496d690fb35d81a "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a15a72ea359f6b0297496d690fb35d81a" title="This version check current precedence. It is however &quot;slow&quot;.">operations_research::sat::PrecedencesPropagator::AddPrecedenceWithOffsetIfNew</a>" (IntegerVariable i1, IntegerVariable i2, IntegerValue offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002172 (user): Modify arc in place!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PrecedencesPropagator Member \_internalref classoperations__research_1_1sat_1_1PrecedencesPropagator#a68e6ed997752f220d4571c5faa136ce5 "<a class="el" href="classoperations__research_1_1sat_1_1PrecedencesPropagator.html#a68e6ed997752f220d4571c5faa136ce5">operations_research::sat::PrecedencesPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo002165 (user): Because of our code to deal with InPropagationLoop(), this is
not always true. Find a cleaner way to DCHECK() while not failing in this
corner case. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7a3e424a9963561cbd837b7a293b416e "<a class="el" href="namespaceoperations__research_1_1sat.html#a7a3e424a9963561cbd837b7a293b416e">operations_research::sat::PresolveBooleanLinearExpression</a>" (std::vector&lt; Literal &gt; *literals, std::vector&lt; Coefficient &gt; *coefficients, Coefficient *offset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002121 (user): Merge this with similar code like
ComputeBooleanLinearExpressionCanonicalForm(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a5670894aad056fc4452807432b031858 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a5670894aad056fc4452807432b031858" title="b =&gt; (x ∈ domain).">operations_research::sat::PresolveContext::AddImplyInDomain</a>" (int b, int x, const Domain &amp;domain)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002204 (user): Find the best way to create such small proto. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a0e57a4d478e6619ec142e1c0e3da51a3 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a0e57a4d478e6619ec142e1c0e3da51a3">operations_research::sat::PresolveContext::CanonicalizeObjective</a>" (bool simplify_domain=true)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002213 (user): This is a bit duplicated with the presolve linear code.
We also do not propagate back any domain restriction from the objective to
the variables if any. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a2ccc5bf972c4cfe911eb430e97dd3c57 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a2ccc5bf972c4cfe911eb430e97dd3c57">operations_research::sat::PresolveContext::CanonicalizeVariable</a>" (int ref)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002223 (user): When we can always get rid of affine relation, it might be good
to do a final pass to canonicalize all domains in a model after presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#acfa9e96fd82123e73419f70c85690153 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#acfa9e96fd82123e73419f70c85690153">operations_research::sat::PresolveContext::ConstraintVariableUsageIsConsistent</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002206 (user): Also test var_to_constraints_ !!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#ac5377b5320ad26e469e680b7d3bab02b "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#ac5377b5320ad26e469e680b7d3bab02b">operations_research::sat::PresolveContext::InsertVarValueEncoding</a>" (int literal, int var, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002225 (user): This function is not always correct if
!context-&gt;DomainOf(var).contains(value), we could make it correct but it
might be a bit expansive to do so. For now we just have a DCHECK(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a6e1524915705b3272bab45c634fb5a37 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a6e1524915705b3272bab45c634fb5a37">operations_research::sat::PresolveContext::IsFullyEncoded</a>" (int ref) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002226 (user): If the domain was shrunk, we can have a false positive.
Still it means that the number of values removed is greater than the number
of values not encoded. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a2f2b400df7ac9b5f827da6414de38553 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a2f2b400df7ac9b5f827da6414de38553">operations_research::sat::PresolveContext::NewIntVarWithDefinition</a>" (const Domain &amp;domain, absl::Span&lt; const std::pair&lt; int, int64_t &gt; &gt; definition, bool append_constraint_to_mapping_model=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002203 (user): When we encounter overflow (rare), we still create a variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a3ee008e9272dbcc3132a667eefc41923 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a3ee008e9272dbcc3132a667eefc41923">operations_research::sat::PresolveContext::NotifyThatModelIsUnsat</a>" (absl::string_view message="")&lt;/dt&gt;&lt;dd&gt; \anchor _todo002222 (user): Report any explanation for the client in a nicer way?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a3ecb80a62e74147541a2067b27392547 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a3ecb80a62e74147541a2067b27392547">operations_research::sat::PresolveContext::ReadObjectiveFromProto</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002212 (user): There should be no negative reference here !
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#aac36698e66fbf7ae8920b82be903b0e0 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#aac36698e66fbf7ae8920b82be903b0e0">operations_research::sat::PresolveContext::ResetAfterCopy</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002224 (user): The ModelCopier should probably not depend on the full context
it only need to read/write domains and call UpdateRuleStats(), so we might
want to split that part out so that we can just initialize the full context
later. Alternatively, we could just move more complex part of the context
out, like the graph, the encoding, the affine representative, and so on to
individual and easier to manage classes. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a392085a404b28b5e5a405c4e115e5332 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a392085a404b28b5e5a405c4e115e5332">operations_research::sat::PresolveContext::ShiftCostInExactlyOne</a>" (absl::Span&lt; const int &gt; exactly_one, int64_t shift)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002214 (user): Be more precise with this objective_overflow_detection_ and
always keep it up to date on each offset / coeff change. 
 &lt;p&gt; \anchor _todo002215 (user): This is a bit hacky, find a nicer way. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#a21f9fb012d35d444b8d3438157f5c9c3 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#a21f9fb012d35d444b8d3438157f5c9c3">operations_research::sat::PresolveContext::StoreAffineRelation</a>" (int var_x, int var_y, int64_t coeff, int64_t offset, bool debug_no_recursion=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002207 (user): I am not 100% sure why, but sometimes the representative is
fixed but that is not propagated to var_x or var_y and this causes issues. 
 &lt;p&gt; \anchor _todo002208 (user): we can do better for overflow by not always choosing the
min at zero, do the best things if it becomes needed. 
 &lt;p&gt; \anchor _todo002209 (user): can we force the rep and remove GetAffineRelation()?
 &lt;p&gt; \anchor _todo002210 (user): I am not sure this is needed given the propagation above. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PresolveContext Member \_internalref classoperations__research_1_1sat_1_1PresolveContext#ab43f7366b32b2ac40cc0f7f668040c49 "<a class="el" href="classoperations__research_1_1sat_1_1PresolveContext.html#ab43f7366b32b2ac40cc0f7f668040c49">operations_research::sat::PresolveContext::UpdateRuleStats</a>" (const std::string &amp;name, int num_times=1)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002205 rules as this is used to decide if
we loop again. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aef7dd0a73fe3618ca37a526969940761 "<a class="el" href="namespaceoperations__research_1_1sat.html#aef7dd0a73fe3618ca37a526969940761">operations_research::sat::PresolveFixed2dRectangles</a>" (absl::Span&lt; const RectangleInRange &gt; non_fixed_boxes, std::vector&lt; Rectangle &gt; *fixed_boxes)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001105 (user): instead of doing the greedy algorithm first with optional
boxes, and then the one that is exact for mandatory boxes but weak for
optional ones, refactor the second algorithm. One possible way of doing
that would be to follow the shape boundary of optional+mandatory boxes and
look whether we can shave off some turns. For example, if we have a shape
like below, with the "+" representing area covered by optional boxes, we
can replace the turns by a straight line.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a76af37fab5c93f2f256ff65457866fb4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a76af37fab5c93f2f256ff65457866fb4">operations_research::sat::ProbeAndFindEquivalentLiteral</a>" (SatSolver *solver, SatPostsolver *postsolver, DratProofHandler *drat_proof_handler, util_intops::StrongVector&lt; LiteralIndex, LiteralIndex &gt; *mapping, SolverLogger *logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002440 (user): Add some constraint so that it does?&lt;p&gt; \anchor _todo002441 (user): check compatibility? if x ~ not(x) =&gt; unsat.
but probably, the solver would have found this too? not sure... 
 &lt;p&gt; \anchor _todo002442 (user): Fixing a variable might fix more of them by propagation, so
we might not fix everything possible with these loops. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a60a37142e38a0a290d70b030405db801 "<a class="el" href="namespaceoperations__research_1_1sat.html#a60a37142e38a0a290d70b030405db801">operations_research::sat::ProbeAndSimplifyProblem</a>" (SatPostsolver *postsolver, LinearBooleanProblem *problem)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001121 (user): expose the number of iterations as a parameter.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a98f7eb19b1030f3da667a3914c7ba666 "<a class="el" href="namespaceoperations__research_1_1sat.html#a98f7eb19b1030f3da667a3914c7ba666">operations_research::sat::ProbeLiteral</a>" (Literal assumption, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002097 (user): Still use it if the problem is Boolean only. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#ab1e9d80c7f62d666ad8a3ec5a14f3c13 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a2127d7db0f3c791613c92c8177e02432">operations_research::sat::Prober::ProbeBooleanVariables</a>" (double deterministic_time_limit, absl::Span&lt; const BooleanVariable &gt; bool_vars)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002240 (user): Instead of an hard deterministic limit, we should probably
use a lower one, but reset it each time we have found something useful. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#a2127d7db0f3c791613c92c8177e02432 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a2127d7db0f3c791613c92c8177e02432">operations_research::sat::Prober::ProbeBooleanVariables</a>" (double deterministic_time_limit)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002248 (user): For now we process the Boolean in their natural order, this is
not the most efficient.&lt;p&gt; \anchor _todo002249 (user): This might generate a lot of new direct implications. We might
not want to add them directly to the BinaryImplicationGraph and could
instead use them directly to detect equivalent literal like in
ProbeAndFindEquivalentLiteral(). The situation is not clear.&lt;p&gt; \anchor _todo002250 (user): More generally, we might want to register any literal =&gt; bound
in the IntegerEncoder. This would allow to remember them and use them in
other part of the solver (cuts, lifting, ...).&lt;p&gt; \anchor _todo002251 (user): Rename to include Integer in the name and distinguish better
from FailedLiteralProbing() below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Prober Member \_internalref classoperations__research_1_1sat_1_1Prober#a530c77d3421958a676e67d4463b2c1a1 "<a class="el" href="classoperations__research_1_1sat_1_1Prober.html#a530c77d3421958a676e67d4463b2c1a1">operations_research::sat::Prober::ProbeDnf</a>" (absl::string_view name, absl::Span&lt; const std::vector&lt; Literal &gt; &gt; dnf)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002241 (user): Can we use the callback_?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#a0ad34d874b506bc2be329d5cc4f8e185 "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#a0ad34d874b506bc2be329d5cc4f8e185">operations_research::sat::ProbingOptions::deterministic_limit</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002252 (user): We can also provide a middle ground and probe all failed
literal but do not extract all binary clauses.&lt;p&gt; \anchor _todo002253 (user): The fix point is not yet reached since we don't currently
simplify non-binary clauses with these equivalence, but we will. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#af5a82baa2dc19e7fe7e018b63c499042 "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#af5a82baa2dc19e7fe7e018b63c499042">operations_research::sat::ProbingOptions::extract_binary_clauses</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002254 (user): Note that adding binary clause before/during the SAT presolve
is currently not always a good idea. This is because we don't simplify the
other clause as much as we could. Also, there can be up to a quadratic
number of clauses added this way, which might slow down things a lot. But
then because of the deterministic limit, we usually cannot add too much
clauses, even for huge problems, since we will reach the limit before that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProbingOptions Member \_internalref structoperations__research_1_1sat_1_1ProbingOptions#ab4df2ae2f59c5cb13fe680c9580fc64f "<a class="el" href="structoperations__research_1_1sat_1_1ProbingOptions.html#ab4df2ae2f59c5cb13fe680c9580fc64f">operations_research::sat::ProbingOptions::use_queue</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002255 (user): Decide which one is better, currently the difference seems
small but the queue seems slightly faster. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDecomposer Member \_internalref classoperations__research_1_1sat_1_1ProductDecomposer#a45c18f04782c89b35181121f284b5ceb "<a class="el" href="classoperations__research_1_1sat_1_1ProductDecomposer.html#a45c18f04782c89b35181121f284b5ceb">operations_research::sat::ProductDecomposer::TryToLinearize</a>" (const AffineExpression &amp;left, const AffineExpression &amp;right, LinearConstraintBuilder *builder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001769 (user): Experiment with x * x where constants = 0, x is
fully encoded, and the domain is small. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a03747fb4560f490b6db42ffb749c8f2e "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a03747fb4560f490b6db42ffb749c8f2e">operations_research::sat::ProductDetector::InitializeBooleanRLTCuts</a>" (absl::Span&lt; const IntegerVariable &gt; lp_vars, const util_intops::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001772 (user): limit work if too many ternary.
 &lt;p&gt; \anchor _todo001773 (user): Maybe we shouldn't reconstruct this every time, but it is hard
in case of multiple lps to make sure we don't use variables not in the lp
otherwise. 
 &lt;p&gt; \anchor _todo001774 (user): Just switch to memclear() when dense. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a3a17220935c42077613be222734fef7a "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a3a17220935c42077613be222734fef7a">operations_research::sat::ProductDetector::LinearizeProduct</a>" (IntegerVariable a, IntegerVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001783 (user): Implement!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#af7fe2b019ee2556cd2b2813b34877945 "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#af7fe2b019ee2556cd2b2813b34877945">operations_research::sat::ProductDetector::ProcessBinaryClause</a>" (absl::Span&lt; const Literal &gt; binary_clause)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001770 (user): As product are discovered, we could remove entries from our
hash maps! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a7473e11336cf79ccf7f4a54a890625fc "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a7473e11336cf79ccf7f4a54a890625fc">operations_research::sat::ProductDetector::ProcessConditionalEquality</a>" (Literal l, IntegerVariable x, IntegerVariable y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001771 (user): Linear scan can be bad if b =&gt; X = many other variables.
Hopefully this will not be common. 
 &lt;p&gt; \anchor _todo001782 (user): Generalize to a * X + b = l * (Y + c) since these are also
easy to linearize if we see l * Y. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductDetector Member \_internalref classoperations__research_1_1sat_1_1ProductDetector#a308ee96e864c4e4fac744ac329ecac39 "<a class="el" href="classoperations__research_1_1sat_1_1ProductDetector.html#a308ee96e864c4e4fac744ac329ecac39">operations_research::sat::ProductDetector::ProductLowerBound</a>" (IntegerVariable a, IntegerVariable b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001784 (user): Implement! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProductPropagator Member \_internalref classoperations__research_1_1sat_1_1ProductPropagator#a1a947c821f05a6e347602ffaa4162d1d "<a class="el" href="classoperations__research_1_1sat_1_1ProductPropagator.html#a1a947c821f05a6e347602ffaa4162d1d">operations_research::sat::ProductPropagator::Propagate</a>" () final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001844 (user): In the reasons, including all 4 bounds is always correct, but
we might be able to relax some of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad8873d5bb4db4affe6faa2da6553882a "<a class="el" href="namespaceoperations__research_1_1sat.html#ad8873d5bb4db4affe6faa2da6553882a" title="Fills and propagates the set of reachable states/labels.">operations_research::sat::PropagateAutomaton</a>" (const AutomatonConstraintProto &amp;proto, const PresolveContext &amp;context, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *states, std::vector&lt; absl::flat_hash_set&lt; int64_t &gt; &gt; *labels)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001619 (user): Note that if we have duplicate variables controlling different
time point, this might not reach the fixed point. Fix? it is not that
important as the expansion take care of this case anyway. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad1ebf465eb7ccee4f79a5b8cfccfe7d9 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad1ebf465eb7ccee4f79a5b8cfccfe7d9">operations_research::sat::PropagateEncodingFromEquivalenceRelations</a>" (const CpModelProto &amp;model_proto, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001292 (user): This is not supposed to happen, but apparently it did on
once on routing_GCM_0001_sat.fzn. Investigate and fix. 
 &lt;p&gt; \anchor _todo001293 (user): This is similar to LoadEquivalenceAC() for unreified
constraints, but when the later is called, more encoding might have taken
place. 
 &lt;p&gt; \anchor _todo001301 (user): In an ideal world, all affine relations like this should be
removed in the presolve. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ProtoTrail Class \_internalref classoperations__research_1_1sat_1_1ProtoTrail "<a class="el" href="classoperations__research_1_1sat_1_1ProtoTrail.html">operations_research::sat::ProtoTrail</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002535 (user): It'd be good to store an earlier level at which
implications may be propagated. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7bb3adbf30215f4aafac3f24caf00f84 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7bb3adbf30215f4aafac3f24caf00f84">operations_research::sat::PseudoCost</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001868 (user): This will be overridden by the value decision heuristic in
almost all cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PseudoCosts Member \_internalref classoperations__research_1_1sat_1_1PseudoCosts#a21a08a0f912507d4cdcb1b9fea5e1297 "<a class="el" href="classoperations__research_1_1sat_1_1PseudoCosts.html#a21a08a0f912507d4cdcb1b9fea5e1297">operations_research::sat::PseudoCosts::AfterTakingDecision</a>" (bool conflict=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002256 (user): tune that.&lt;p&gt; \anchor _todo002257 (user): Handle this case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::PseudoCosts Member \_internalref classoperations__research_1_1sat_1_1PseudoCosts#a78be0e06d6c1f84281b45b79cb946d92 "<a class="el" href="classoperations__research_1_1sat_1_1PseudoCosts.html#a78be0e06d6c1f84281b45b79cb946d92" title="Returns the variable with best reliable pseudo cost that is not fixed.">operations_research::sat::PseudoCosts::GetBestDecisionVar</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002258 (user): Supports search randomization tolerance.
 &lt;p&gt; &lt;p&gt;(user): Implement generic class to choose the randomized
solution, and supports sub-linear variable selection. 
 &lt;p&gt; \anchor _todo002259 (user): Avoid the O(num_relevant_variable) loop.
In practice since a variable only become relevant after 100 records, this
list might be small compared to the number of variable though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab37f2f037c1a414988b378b00ae80dcf "<a class="el" href="namespaceoperations__research_1_1sat.html#ab37f2f037c1a414988b378b00ae80dcf">operations_research::sat::QuickSolveWithHint</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001571 (user): This is fixable, but then do we need the hint when optimizing
with core? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ac2b9ed2c9fd55af7cfd4effe1ad5a5d6 "<a class="el" href="namespaceoperations__research_1_1sat.html#ac2b9ed2c9fd55af7cfd4effe1ad5a5d6">operations_research::sat::RandomizeOnRestartHeuristic</a>" (bool lns_mode, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001881 (user): Add other policies and perform more experiments.
 &lt;p&gt; \anchor _todo001882 (user): Do more experiments to find better distribution. 
 &lt;p&gt; \anchor _todo001883 (user): These distribution values are just guessed values. They
need to be tuned. 
 &lt;p&gt; \anchor _todo001884 (user): Also use LP value as assignment like in Bop. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a774bb7b95d0309e6e4448b044b88c456 "<a class="el" href="namespaceoperations__research_1_1sat.html#a774bb7b95d0309e6e4448b044b88c456" title="Adds the current LP solution to the pool.">operations_research::sat::RecordLPRelaxationValues</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002261 (user): The default of ::infinity() for variable for which we do not
have any LP solution is weird and inconsistent with ModelLpValues default
which is zero. Fix. Note that in practice, at linearization level 2, all
variable will eventually have an lp relaxation value, so it shoulnd't
matter much to just use zero in RINS/RENS. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RectanglesPackingRelaxTwoNeighborhoodsGenerator Member \_internalref classoperations__research_1_1sat_1_1RectanglesPackingRelaxTwoNeighborhoodsGenerator#ae2fcafe99fcbbb79d163ffb01069b44c "<a class="el" href="classoperations__research_1_1sat_1_1RectanglesPackingRelaxTwoNeighborhoodsGenerator.html#ae2fcafe99fcbbb79d163ffb01069b44c">operations_research::sat::RectanglesPackingRelaxTwoNeighborhoodsGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, SolveData &amp;data, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001265 (user): This computes the distance between the center of the
rectangles. We could use the real distance between the closest points, but
not sure it is worth the extra complexity. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4c7c0126948e1cf811fc9fe8519915e5 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4c7c0126948e1cf811fc9fe8519915e5">operations_research::sat::ReduceNodes</a>" (Coefficient upper_bound, Coefficient *lower_bound, std::vector&lt; EncodingNode * &gt; *nodes, SatSolver *solver)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001742 (user): with DEFAULT_ASSUMPTION_ORDER, this will lead to a somewhat
weird behavior, since we will reverse the nodes at each iteration... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ae9354f9bc95baa7e65765e065b38fefc "<a class="el" href="namespaceoperations__research_1_1sat.html#ae9354f9bc95baa7e65765e065b38fefc">operations_research::sat::RegisterClausesLevelZeroImport</a>" (int id, SharedClausesManager *shared_clauses_manager, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001559 (user): Can we import them in the core worker ? 
 &lt;p&gt; \anchor _todo001586 (user): Can we import them in the core worker ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aceadbdc1d18fb949cc787a53e656d65a "<a class="el" href="namespaceoperations__research_1_1sat.html#aceadbdc1d18fb949cc787a53e656d65a">operations_research::sat::RegisterVariableBoundsLevelZeroExport</a>" (const CpModelProto &amp;, SharedBoundsManager *shared_bounds_manager, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001557 (user): We could imagine an API based on atomic&lt;int64_t&gt;
that could preemptively check if this new bounds are improving. 
 &lt;p&gt; \anchor _todo001558 (user): Find a better way? It seems nicer to register this before
any variable is modified. But then we don't want to call it each time
we reach level zero during probing. It should be better to only call
it when a new variable has been fixed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxationInducedNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1RelaxationInducedNeighborhoodGenerator#a27044402508dfaff5018cda97b8812bb "<a class="el" href="classoperations__research_1_1sat_1_1RelaxationInducedNeighborhoodGenerator.html#a27044402508dfaff5018cda97b8812bb" title="Both initial solution and difficulty values are ignored.">operations_research::sat::RelaxationInducedNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, SolveData &amp;data, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001267 (user): Instead of aborting, pick the closest point in the domain?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomConstraintsGenerator Class \_internalref classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator.html">operations_research::sat::RelaxRandomConstraintsGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001274 (user): In the presence of connected components, this should just work
on one of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomConstraintsGenerator Member \_internalref classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator#a04859b2428944a741b89fe22973f4517 "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomConstraintsGenerator.html#a04859b2428944a741b89fe22973f4517">operations_research::sat::RelaxRandomConstraintsGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, SolveData &amp;data, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001255 (user): Clean-up when target_size == 0.
 &lt;p&gt; \anchor _todo001256 (user): randomize order of variable addition when close to the
limit. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RelaxRandomVariablesGenerator Class \_internalref classoperations__research_1_1sat_1_1RelaxRandomVariablesGenerator "<a class="el" href="classoperations__research_1_1sat_1_1RelaxRandomVariablesGenerator.html">operations_research::sat::RelaxRandomVariablesGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001273 (user): In the presence of connected components, this should just work
on one of them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a89dc2fa5d4896cd17270cf7d40099e08 "<a class="el" href="namespaceoperations__research_1_1sat.html#a89dc2fa5d4896cd17270cf7d40099e08">operations_research::sat::ReportEnergyConflict</a>" (Rectangle bounding_box, absl::Span&lt; const int &gt; boxes, SchedulingConstraintHelper *x, SchedulingConstraintHelper *y)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001706 (user): Also relax the box if possible. 
 &lt;p&gt; \anchor _todo001710 (user): relax the bounding box dimension to have a relaxed explanation.
We can also minimize the number of required intervals. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RestartPolicy Member \_internalref classoperations__research_1_1sat_1_1RestartPolicy#a52594750ea119a9ac928e3f09b77f140 "<a class="el" href="classoperations__research_1_1sat_1_1RestartPolicy.html#a52594750ea119a9ac928e3f09b77f140" title="Resets the policy using the current model parameters.">operations_research::sat::RestartPolicy::Reset</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002260 (user): for some reason, strategies_.assign() does not work as the
returned type of the proto enum iterator is int ?! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RoundingOptions Struct \_internalref structoperations__research_1_1sat_1_1RoundingOptions "<a class="el" href="structoperations__research_1_1sat_1_1RoundingOptions.html">operations_research::sat::RoundingOptions</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001693 (user): There is a bunch of heuristic involved here, and we could spend
more effort tuning them. In particular, one can try many heuristics and keep
the best looking cut (or more than one). This is not on the critical code
path, so we can spend more effort in finding good cuts. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::RoutingFullPathNeighborhoodGenerator Member \_internalref classoperations__research_1_1sat_1_1RoutingFullPathNeighborhoodGenerator#aeff93863f1883bca4c136ffefd51519f "<a class="el" href="classoperations__research_1_1sat_1_1RoutingFullPathNeighborhoodGenerator.html#aeff93863f1883bca4c136ffefd51519f">operations_research::sat::RoutingFullPathNeighborhoodGenerator::Generate</a>" (const CpSolverResponse &amp;initial_solution, SolveData &amp;data, absl::BitGenRef random) final&lt;/dt&gt;&lt;dd&gt; \anchor _todo001266 (user): Restrict this if the difficulty is very low. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#a118a1b216d1e79a4b9c250f3030adda7 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#a118a1b216d1e79a4b9c250f3030adda7" title="Returns the vector of the current assignment preferences.">operations_research::sat::SatDecisionPolicy::AllPreferences</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002285 (user): we currently assume that if the tie_breaker is zero then
no preference was set (which is not 100% correct). Fix that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#ad02a374fc46af7a8ed8112257438dbc1 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#ad02a374fc46af7a8ed8112257438dbc1">operations_research::sat::SatDecisionPolicy::NextBranch</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002286 (user): This may not be super efficient if almost all the
variables are assigned. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatDecisionPolicy Member \_internalref classoperations__research_1_1sat_1_1SatDecisionPolicy#a9f05bb03afa86725c194d50e613f2593 "<a class="el" href="classoperations__research_1_1sat_1_1SatDecisionPolicy.html#a9f05bb03afa86725c194d50e613f2593" title="Called on Untrail() so that we can update the set of possible decisions.">operations_research::sat::SatDecisionPolicy::Untrail</a>" (int target_trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002287 (user): avoid looping twice over the trail?
 &lt;p&gt; \anchor _todo002288 (user): Expose parameters for these values. 
 &lt;p&gt; \anchor _todo002289 (user): This heuristic can make this code quite slow because
all the untrailed variable will cause a priority queue update. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPostsolver Member \_internalref classoperations__research_1_1sat_1_1SatPostsolver#a3336b2762049c2d81e2bd255e9c9ecc8 "<a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html#a3336b2762049c2d81e2bd255e9c9ecc8">operations_research::sat::SatPostsolver::Clause</a>" (int i) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002447 (user): we could avoid the copy here, but because clauses_literals_
is a deque, we do need a special return class and cannot juste use
absl::Span&lt;Literal&gt; for instance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPostsolver Member \_internalref classoperations__research_1_1sat_1_1SatPostsolver#ad351af493e5b70fc12534bc0806cc444 "<a class="el" href="classoperations__research_1_1sat_1_1SatPostsolver.html#ad351af493e5b70fc12534bc0806cc444">operations_research::sat::SatPostsolver::FixVariable</a>" (Literal x)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002446 (user): this as almost the same effect as adding an unit clause, and we
should probably remove this to simplify the code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolveOptions Member \_internalref structoperations__research_1_1sat_1_1SatPresolveOptions#a99051170412df0832ce84112ddd314c0 "<a class="el" href="structoperations__research_1_1sat_1_1SatPresolveOptions.html#a99051170412df0832ce84112ddd314c0">operations_research::sat::SatPresolveOptions::use_transitive_reduction</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002352 (user): Doing that before the current SAT presolve also change the
possible reduction. This shouldn't matter if we use the binary implication
graph and its reachability instead of just binary clause though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Class \_internalref classoperations__research_1_1sat_1_1SatPresolver "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html">operations_research::sat::SatPresolver</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002443 (user): Interact more with a SAT solver to reuse its propagation logic.&lt;p&gt; \anchor _todo002444 (user): Forbid the removal of some variables. This way we can presolve
only the clause part of a general Boolean problem by not removing variables
appearing in pseudo-Boolean constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a48d43c858e789a63bf76da7414b55a5f "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a48d43c858e789a63bf76da7414b55a5f">operations_research::sat::SatPresolver::ClauseIndex</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002448 (user): use IntType!
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a4b58b71a43c02cbec8fefb126f0a61cb "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a4b58b71a43c02cbec8fefb126f0a61cb">operations_research::sat::SatPresolver::CrossProduct</a>" (Literal x)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002437 (user): Choose if we use x or x.Negated() depending on the list
sizes? The function achieve the same if x = x.Negated(), however the
loops are not done in the same order which may change this incomplete
"blocked" clause detection. 
 &lt;p&gt; \anchor _todo002438 (user): We could only update the priority queue once for each variable
instead of doing it many times. 
 &lt;p&gt; \anchor _todo002439 (user): At this point x.Variable() is added back to the priority queue.
Avoid doing that. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#adb7846ae7bbe4ca2e07a1dba94fe686e "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a32df98e6426d1e7a18247a18207717f1">operations_research::sat::SatPresolver::Presolve</a>" (const std::vector&lt; bool &gt; &amp;var_that_can_be_removed)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002426 (user): When a clause is strengthened, add it to a queue so it can
be processed again? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a32df98e6426d1e7a18247a18207717f1 "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a32df98e6426d1e7a18247a18207717f1">operations_research::sat::SatPresolver::Presolve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002449 (user): Add support for a time limit and some kind of iterations limit
so that this can never take too much time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#af7e0881274e8e8cec31c85429900b42a "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#af7e0881274e8e8cec31c85429900b42a" title="Visible for testing. Just applies the BVA step of the presolve.">operations_research::sat::SatPresolver::PresolveWithBva</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002427 (user): Put work limit in place !
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPresolver Member \_internalref classoperations__research_1_1sat_1_1SatPresolver#a8d8418b2601e61829de5e7b3f4df122b "<a class="el" href="classoperations__research_1_1sat_1_1SatPresolver.html#a8d8418b2601e61829de5e7b3f4df122b">operations_research::sat::SatPresolver::ProcessClauseToSimplifyOthers</a>" (ClauseIndex clause_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002434 (user): Binary clauses are really common, and we can probably do this
more efficiently for them. For instance, we could just take the intersection
of two sorted lists to get the simplified clauses. 
 &lt;p&gt; \anchor _todo002435 (user): not super optimal since we could abort earlier if
opposite_literal is not the negation of shortest_list. Note that this
applies to the second call to
ProcessClauseToSimplifyOthersUsingLiteral() above too. 
 &lt;p&gt; \anchor _todo002436 (user): remove the old clauses_[ci] afterwards.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPropagator Member \_internalref classoperations__research_1_1sat_1_1SatPropagator#a2bde4f8c3d7c6326050ac164391bf2a7 "<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a2bde4f8c3d7c6326050ac164391bf2a7" title="######################## Implementations below ########################">operations_research::sat::SatPropagator::PropagatePreconditionsAreSatisfied</a>" (const Trail &amp;trail) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002275 (user): A few of these method should be moved in a .cc
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatPropagator Member \_internalref classoperations__research_1_1sat_1_1SatPropagator#a5f04df27e81298743cf658683344b0a0 "<a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a5f04df27e81298743cf658683344b0a0">operations_research::sat::SatPropagator::Untrail</a>" (const Trail &amp;, int trail_index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002281 (user): Currently this is called at each Backtrack(), but we could
bundle the calls in case multiple conflict one after the other are detected
even before the Propagate() call of a SatPropagator is called.&lt;p&gt; \anchor _todo002282 (user): It is not yet 100% the case, but this can be guaranteed to be
called with a trail index that will always be the start of a new decision
level. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a8b9ba983bd9f911d0605f7615ebf3725 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a8b9ba983bd9f911d0605f7615ebf3725">operations_research::sat::SatSolver::AddClauseDuringSearch</a>" (absl::Span&lt; const Literal &gt; literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002357 (user): We generate in some corner cases clauses with
literals[0].Variable() == literals[1].Variable(). Avoid doing that and
adding such binary clauses to the graph? 
 &lt;p&gt; \anchor _todo002401 (user): Backjump and propagate on a falsified clause? this is currently
not needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a098038f8e0409a8243ff3f7eafb517f8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a098038f8e0409a8243ff3f7eafb517f8">operations_research::sat::SatSolver::AddLinearConstraint</a>" (bool use_lower_bound, Coefficient lower_bound, bool use_upper_bound, Coefficient upper_bound, std::vector&lt; LiteralWithCoeff &gt; *cst)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002397 (user): Instead of failing, implement an error handling code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a647efe64188a8e657a25ab23ddcc08d8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a647efe64188a8e657a25ab23ddcc08d8">operations_research::sat::SatSolver::AddProblemClause</a>" (absl::Span&lt; const Literal &gt; literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002396 (user): Rename this to AddClause() ? Also get rid of the specialized
AddUnitClause(), AddBinaryClause() and AddTernaryClause() since they
just end up calling this? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a7c0c2912da716e49c8b5d84108e463d7 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a7c0c2912da716e49c8b5d84108e463d7">operations_research::sat::SatSolver::Backtrack</a>" (int target_level)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002367 (user): The backtrack method should not be called when the model is
        unsat. Add a DCHECK to prevent that, but before fix the
        bop::BopOptimizerBase architecture. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a1ac88207c0228d80d19751186955240f "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a1ac88207c0228d80d19751186955240f">operations_research::sat::SatSolver::deterministic_time</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002356 (user): Find a better procedure to fix the weight than just educated
guess. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a0174fd7221118d81a925d32aaed1cc79 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a0174fd7221118d81a925d32aaed1cc79">operations_research::sat::SatSolver::ExtractClauses</a>" (Output *out)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002400 (user): also copy the removable clauses? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#ad4458486171153c1793c28e2091140d9 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ad4458486171153c1793c28e2091140d9">operations_research::sat::SatSolver::FinishPropagation</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002361 (user): Exiting like this might cause issue since the propagation
is not "finished" but some code might assume it is. However since we
already might repropagate in the LP constraint, most of the code
should support "not finished propagation". 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a84e27e6cb848b3176ab5680292d116a8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a84e27e6cb848b3176ab5680292d116a8">operations_research::sat::SatSolver::IsModelUnsat</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002398 (user): remove this function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a5420a6d871314779beeac0c074241c1a "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a5420a6d871314779beeac0c074241c1a">operations_research::sat::SatSolver::model</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002394 (user): Remove. This is temporary for accessing the model deep within
some old code that didn't use the Model object. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a3afed23ec8289b170f0a25ec4b10dd84 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a3afed23ec8289b170f0a25ec4b10dd84">operations_research::sat::SatSolver::ProcessCurrentConflict</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002362 (user): We might still want to "learn" the clause, especially if
it reduces to only one literal in which case we can just fix it. 
 &lt;p&gt; \anchor _todo002363 (user): Note that we use the clause above to update the variable
activities and not the pb conflict. Experiment. 
 &lt;p&gt; \anchor _todo002364 (user): This is error prone, find a better way? 
 &lt;p&gt; \anchor _todo002365 (user): It is unclear what the best heuristic is here. Both the current
trail index or the trail before the current decision perform well, but
using the full trail seems slightly better even though it will contain the
current conflicting literal. 
 &lt;p&gt; \anchor _todo002366 (user): Either remove that algorithm or support subsumption by just
checking if it is okay to do so, or doing it on the fly while computing the
first UIP. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a9188c70cc1096900a623a26319a1d4b8 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a9188c70cc1096900a623a26319a1d4b8">operations_research::sat::SatSolver::Propagate</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002378 (user): Support propagating only the "first" propagators. That can
be useful for probing/in-processing, so we can control if we do only the SAT
part or the full integer part... 
 &lt;p&gt; \anchor _todo002379 (user): This might not really be needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#a50484f243bcc0ec12ed3919d84dc38ad "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#a50484f243bcc0ec12ed3919d84dc38ad">operations_research::sat::SatSolver::SetAssignmentPreference</a>" (Literal literal, float weight)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002399 (user): Clean this up by making clients directly talk to
SatDecisionPolicy. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SatSolver Member \_internalref classoperations__research_1_1sat_1_1SatSolver#ae8f40548efeb9f6bde6ff1cd872acc38 "<a class="el" href="classoperations__research_1_1sat_1_1SatSolver.html#ae8f40548efeb9f6bde6ff1cd872acc38">operations_research::sat::SatSolver::SetNumVariables</a>" (int num_variables)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002395 (user): Rename to IncreaseNumVariablesTo() until we support removing
variables... 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SavedVariable Class \_internalref classoperations__research_1_1sat_1_1SavedVariable "<a class="el" href="classoperations__research_1_1sat_1_1SavedVariable.html">operations_research::sat::SavedVariable</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002221 (user): get rid of this, we don't have the notion of equivalent variable
anymore, but the more general affine relation one. We just need to support
general affine for the linear1 involving an absolute value. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad6d384c7c56f3027894875278e4b9526 "<a class="el" href="namespaceoperations__research_1_1sat.html#ad6d384c7c56f3027894875278e4b9526">operations_research::sat::ScaleContinuousVariables</a>" (double scaling, double max_bound, MPModelProto *mp_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002077 (user): Also scale the solution hint if any. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab5275984bb2d64275b69e881316b7f34 "<a class="el" href="namespaceoperations__research_1_1sat.html#ab5275984bb2d64275b69e881316b7f34">operations_research::sat::ScanModelForDominanceDetection</a>" (PresolveContext &amp;context, VarDomination *var_domination)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002517 (user): Maybe we should avoid recomputing that here.
 &lt;p&gt; \anchor _todo002518 (user): Handle enforcement better here. 
 &lt;p&gt; \anchor _todo002519 (user): the way we process that is a bit restrictive. By
working on the implication graph we could detect more dominance
relations. Since if a =&gt; b we say that a++ can only be paired with
b&amp;ndash;, but it could actually be paired with any variables that when
dereased implies b = 0. This is a bit mitigated by the fact that
we regroup when we can such implications into big at most ones. 
 &lt;p&gt; \anchor _todo002520 (user): We might be able to detect that nothing can be done earlier
during the constraint scanning. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7b440ecab00a601d5643f21df87c7cc6 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7b440ecab00a601d5643f21df87c7cc6" title="Scan the model so that dual_bound_strengthening.Strenghten() works.">operations_research::sat::ScanModelForDualBoundStrengthening</a>" (const PresolveContext &amp;context, DualBoundStrengthening *dual_bound_strengthening)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002521 (user): Maybe we should avoid recomputing that here.
 &lt;p&gt; \anchor _todo002522 (user): Handle enforcement better here. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ScatteredIntegerVector Member \_internalref classoperations__research_1_1sat_1_1ScatteredIntegerVector#a5d028844e2ffb568bbc68185f7cb6260 "<a class="el" href="classoperations__research_1_1sat_1_1ScatteredIntegerVector.html#a5d028844e2ffb568bbc68185f7cb6260">operations_research::sat::ScatteredIntegerVector::ConvertToLinearConstraint</a>" (absl::Span&lt; const IntegerVariable &gt; integer_variables, IntegerValue upper_bound, std::optional&lt; std::pair&lt; IntegerVariable, IntegerValue &gt; &gt; extra_term=std::nullopt)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002012 (user): Ideally we should convert to IntegerVariable as late as
possible. Prefer to use GetTerms(). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SccGraph Member \_internalref classoperations__research_1_1sat_1_1SccGraph#aee95126bcb16bb7a70ab00218a15fd7f "operations_research::sat::SccGraph::operator[]" (int32_t node) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo001167 (user): avoid looping more than twice on the same at most one
constraints? Note that the second time we loop we have x =&gt; y =&gt;
not(x), so we can already detect that x must be false which we
detect below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#acbf45814a5a4f7554173a02e61970fa8 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#acbf45814a5a4f7554173a02e61970fa8">operations_research::sat::SchedulingConstraintHelper::GetCurrentMinDistanceBetweenTasks</a>" (int a, int b, bool add_reason_if_after=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002412 (user): be more precise when we know a and b are in disjunction.
we really just need start_b &gt; start_a, or even &gt;= if duration is non-zero. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a648ff007cfc81bd0a4369701a7048a27 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a648ff007cfc81bd0a4369701a7048a27">operations_research::sat::SchedulingConstraintHelper::GetEnergyProfile</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002414 (user): Avoid recomputing it if nothing changed.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a98e816cae622855fe8eae0766b4e0aaf "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a98e816cae622855fe8eae0766b4e0aaf">operations_research::sat::SchedulingConstraintHelper::InPropagationLoop</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002421 (user): Change the propagation loop code so that we don't stop
pushing in the middle of the propagation as more advanced propagator do
not handle this correctly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a4f2023a21c5e1475e6468be2147b6e14 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a4f2023a21c5e1475e6468be2147b6e14">operations_research::sat::SchedulingConstraintHelper::PropagatePrecedence</a>" (int a, int b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002413 (user): Adding new constraint during propagation might not be the
best idea as it can create some complication. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a230beffeb33f166d27bc233bed77237a "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a9bdd04da3355e5f68ff83e8ef53c22bb">operations_research::sat::SchedulingConstraintHelper::SchedulingConstraintHelper</a>" (int num_tasks, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002419 (user): Remove this. It is a hack because the disjunctive class needs
to fetch the maximum possible number of task at construction. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingConstraintHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingConstraintHelper#a0829ed1b078db163e11c4114f71758c3 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingConstraintHelper.html#a0829ed1b078db163e11c4114f71758c3">operations_research::sat::SchedulingConstraintHelper::TaskByIncreasingStartMin</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002420 (user): we could merge the first loop of IncrementalSort() with the
loop that fill TaskTime.time at each call. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Class \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html">operations_research::sat::SchedulingDemandHelper</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002418 (user): Cache energy min and reason for the non O(1) cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#a8b7226d12b17723e0174250fd2024f46 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#a8b7226d12b17723e0174250fd2024f46">operations_research::sat::SchedulingDemandHelper::AddEnergyMinInWindowReason</a>" (int t, IntegerValue window_start, IntegerValue window_end)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002416 (user): only include the one we need?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#a2d1174d156b8b53adca37b7a29e021f4 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#a2d1174d156b8b53adca37b7a29e021f4">operations_research::sat::SchedulingDemandHelper::CacheAllEnergyValues</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002423 (user): this is error prone, maybe we should revisit. But if
there is many alternatives, we don't want to rescan the list more than a
linear number of time per propagation.&lt;p&gt; \anchor _todo002424 (user): Add more complex EnergyMinBefore(time) once we also support
expressing the interval as a set of alternatives.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SchedulingDemandHelper Member \_internalref classoperations__research_1_1sat_1_1SchedulingDemandHelper#ad690f09e6894f8f9e9b01642fa1fc822 "<a class="el" href="classoperations__research_1_1sat_1_1SchedulingDemandHelper.html#ad690f09e6894f8f9e9b01642fa1fc822">operations_research::sat::SchedulingDemandHelper::DecreaseEnergyMax</a>" (int t, IntegerValue value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002415 (user): Propagate if possible.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a85b41013bb2f7709a99765d5c491f381 "<a class="el" href="namespaceoperations__research_1_1sat.html#a85b41013bb2f7709a99765d5c491f381" title="A simple heuristic for scheduling models.">operations_research::sat::SchedulingSearchHeuristic</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001869 (user): we should also precompute fixed precedences and only fix
interval that have all their predecessors fixed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab771e6d4ef64d782505e2abdc6c0dbe3 "<a class="el" href="namespaceoperations__research_1_1sat.html#ab771e6d4ef64d782505e2abdc6c0dbe3">operations_research::sat::SeparateFlowInequalities</a>" (int num_nodes, absl::Span&lt; const int &gt; tails, absl::Span&lt; const int &gt; heads, absl::Span&lt; const AffineExpression &gt; arc_capacities, std::function&lt; void(const std::vector&lt; bool &gt; &amp;in_subset, IntegerValue *min_incoming_flow, IntegerValue *min_outgoing_flow)&gt; get_flows, const util_intops::StrongVector&lt; IntegerVariable, double &gt; &amp;lp_values, LinearConstraintManager *manager, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002266 (user): Alternatively, try MIR heuristics if the coefficients in
the capacities are not all the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#af306b332a6cfbebe5858dcdedfdfb132 "<a class="el" href="namespaceoperations__research_1_1sat.html#af306b332a6cfbebe5858dcdedfdfb132">operations_research::sat::SeparateSubtourInequalities</a>" (OutgoingCutHelper &amp;helper, LinearConstraintManager *manager)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002264 (user): Currently if we add too many not so relevant cuts, our generic
MIP cut heuritic are way too slow on TSP/VRP problems. 
 &lt;p&gt; \anchor _todo002265 (user): I had an older version that tried the n-cuts generated during
the course of the algorithm. This could also be interesting. But it is
hard to tell with our current benchmark setup. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4accab74442b986ddcc870636b232756 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4accab74442b986ddcc870636b232756">operations_research::sat::SequentialValueSelection</a>" (std::vector&lt; std::function&lt; IntegerLiteral(IntegerVariable)&gt; &gt; value_selection_heuristics, std::function&lt; BooleanOrIntegerLiteral()&gt; var_selection_heuristic, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001865 (user): we will likely stop at the first non-fixed variable. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedBoundsManager Member \_internalref classoperations__research_1_1sat_1_1SharedBoundsManager#a57b36555b4bb9b7c5051d183e180c16d "<a class="el" href="classoperations__research_1_1sat_1_1SharedBoundsManager.html#a57b36555b4bb9b7c5051d183e180c16d">operations_research::sat::SharedBoundsManager::FixVariablesFromPartialSolution</a>" (absl::Span&lt; const int64_t &gt; solution, absl::Span&lt; const int &gt; variables_to_fix)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002465 (user): Because we look at the non-synchronized and up to date bounds,
this break determinism if two solution for the same subpart comes at the same
time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedClasses Member \_internalref structoperations__research_1_1sat_1_1SharedClasses#a0ef7eff0563df64a34cebf1186994d1f "<a class="el" href="structoperations__research_1_1sat_1_1SharedClasses.html#a0ef7eff0563df64a34cebf1186994d1f">operations_research::sat::SharedClasses::RegisterSharedClassesInLocalModel</a>" (Model *local_model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001578 (user): Use parameters and not the presence/absence of these class
to decide when to use them. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedClausesManager Member \_internalref classoperations__research_1_1sat_1_1SharedClausesManager#a3ebbcf2be803ef7f2cbad87a044dc4ec "<a class="el" href="classoperations__research_1_1sat_1_1SharedClausesManager.html#a3ebbcf2be803ef7f2cbad87a044dc4ec">operations_research::sat::SharedClausesManager::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002466 (user): We could cleanup binary clauses that have been consumed.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedLsSolutionRepository Class \_internalref classoperations__research_1_1sat_1_1SharedLsSolutionRepository "<a class="el" href="classoperations__research_1_1sat_1_1SharedLsSolutionRepository.html">operations_research::sat::SharedLsSolutionRepository</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002468 (user): We could also use it after first solution to orient a SAT search
towards better solutions. But then it is a bit trickier to rank solutions
compared to the old ones. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedResponseManager Member \_internalref classoperations__research_1_1sat_1_1SharedResponseManager#af4876e4857461716fabf61e3df652bd6 "<a class="el" href="classoperations__research_1_1sat_1_1SharedResponseManager.html#af4876e4857461716fabf61e3df652bd6" title="Updates the inner objective bounds.">operations_research::sat::SharedResponseManager::UpdateInnerObjectiveBounds</a>" (const std::string &amp;update_info, IntegerValue lb, IntegerValue ub)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002463 (user): A thread might not be notified right away that the new bounds
that it is pushing make the problem infeasible. Fix that. For now we just
abort early here to avoid logging the "#Done" message multiple times. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Class \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository "<a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002467 (user): Maybe add some criteria to only keep solution with an objective
really close to the best solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Member \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository#a3979e96964973d704e7a1bd43b95aa27 "<a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html#a3979e96964973d704e7a1bd43b95aa27" title="Returns a random solution biased towards good solutions.">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::GetRandomBiasedSolution</a>" (absl::BitGenRef random) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002469 (user): Experiments on the best distribution.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository::Solution Member \_internalref structoperations__research_1_1sat_1_1SharedSolutionRepository_1_1Solution#a1e89b8e75d0f5d4196f9cc06abbfa689 "<a class="el" href="structoperations__research_1_1sat_1_1SharedSolutionRepository_1_1Solution.html#a1e89b8e75d0f5d4196f9cc06abbfa689">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::Solution::rank</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002471 (user): Some LNS code assume that for the SharedSolutionRepository
this rank is actually the unscaled internal minimization objective.
Remove this assumptions by simply recomputing this value since it is not
too costly to do so. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedSolutionRepository Member \_internalref classoperations__research_1_1sat_1_1SharedSolutionRepository#a902c7f2bb1e91b85d85bad84726bf89b "<a class="el" href="classoperations__research_1_1sat_1_1SharedSolutionRepository.html#a902c7f2bb1e91b85d85bad84726bf89b">operations_research::sat::SharedSolutionRepository&lt; ValueType &gt;::Synchronize</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002470 (user): Introduce a notion of orthogonality to diversify the pool? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedTreeManager Member \_internalref classoperations__research_1_1sat_1_1SharedTreeManager#a98c561c89b5bc43b4aa0debbcef4200e "<a class="el" href="classoperations__research_1_1sat_1_1SharedTreeManager.html#a98c561c89b5bc43b4aa0debbcef4200e">operations_research::sat::SharedTreeManager::ProposeSplit</a>" (ProtoTrail &amp;path, ProtoLiteral decision)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002532 (user): Need to write up the shape this creates.
This rule will allow twice as many leaves in the preferred subtree. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SharedTreeManager Member \_internalref classoperations__research_1_1sat_1_1SharedTreeManager#aa6d71bb864a47eaeb3edb91b97819686 "<a class="el" href="classoperations__research_1_1sat_1_1SharedTreeManager.html#aa6d71bb864a47eaeb3edb91b97819686" title="Assigns a path prefix that the worker should explore.">operations_research::sat::SharedTreeManager::ReplaceTree</a>" (ProtoTrail &amp;path)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002533 (user): Investigate assigning a random leaf so workers can still
improve shared tree bounds. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a4bfc95b7fb811709c6763963bee970a4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a4bfc95b7fb811709c6763963bee970a4">operations_research::sat::ShaveObjectiveLb</a>" (Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001867 (user): Do we need a mechanism to reduce the range of possible gaps
when nothing gets proven? This could be a parameter or some adaptative code. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a0479a7ca6dd22cbabccdf623aea07315 "<a class="el" href="namespaceoperations__research_1_1sat.html#a0479a7ca6dd22cbabccdf623aea07315">operations_research::sat::SimplifyCanonicalBooleanLinearConstraint</a>" (std::vector&lt; LiteralWithCoeff &gt; *cst, Coefficient *rhs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002128 (user): Use more complex simplification like dividing by the gcd of
everyone and using less different coefficients if possible. 
 &lt;p&gt; \anchor _todo002129 (user): It is probably better to remove these literals and have other
constraint setting them to false from the symmetry finder perspective. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ab649ca11fd81e049dc7a8c0dd1104b5b "<a class="el" href="namespaceoperations__research_1_1sat.html#ab649ca11fd81e049dc7a8c0dd1104b5b">operations_research::sat::SimplifyClause</a>" (const std::vector&lt; Literal &gt; &amp;a, std::vector&lt; Literal &gt; *b, LiteralIndex *opposite_literal, int64_t *num_inspected_literals)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002445 (user): when a.size() &lt;&lt; b.size(), we should use binary search instead
of scanning b linearly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SolutionCrush::TableRowLiteral Member \_internalref structoperations__research_1_1sat_1_1SolutionCrush_1_1TableRowLiteral#a85da1340c09a35072be063500239ec67 "<a class="el" href="structoperations__research_1_1sat_1_1SolutionCrush_1_1TableRowLiteral.html#a85da1340c09a35072be063500239ec67">operations_research::sat::SolutionCrush::TableRowLiteral::var_values</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002450 (user): use a vector of (var, value) pairs instead?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a336d2faa10d80d646232f5e6d91891d4 "<a class="el" href="namespaceoperations__research_1_1sat.html#a336d2faa10d80d646232f5e6d91891d4">operations_research::sat::SolutionIsFeasible</a>" (const CpModelProto &amp;model, absl::Span&lt; const int64_t &gt; variable_values, const CpModelProto *mapping_proto, const std::vector&lt; int &gt; *postsolve_mapping)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001201 (user): This is not really a "feasibility" question, but we should
probably check that the response objective matches with the one we can
compute here. This might better be done in another function though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a9d67b9c66f1cb9c1dcc3415cd5af11bf "<a class="el" href="namespaceoperations__research_1_1sat.html#a9d67b9c66f1cb9c1dcc3415cd5af11bf">operations_research::sat::SolveCpModel</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001528 (user): We currently reuse the MODEL_INVALID status even though it
is not the best name for this. Maybe we can add a PARAMETERS_INVALID
when it become needed. Or rename to INVALID_INPUT ? 
 &lt;p&gt; \anchor _todo001529 (user): provide an option to skip this step for speed? 
 &lt;p&gt; \anchor _todo001530 (user): Change status to IMPRECISE? 
 &lt;p&gt; \anchor _todo001531 (user): We could actually report a complete feasible hint before this
point. But the proper fix is to report it even before the presolve. 
 &lt;p&gt; \anchor _todo001532 (user): reduce this function size and find a better place for this?
 &lt;p&gt; \anchor _todo001533 (user): We could try to dump our linear relaxation too. 
 &lt;p&gt; \anchor _todo001534 (user): Even for an optimization, if we load the solution right away,
we might not have the same behavior as the initial search that follow the
hint will be infeasible, so the activities of the variables will be
different. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a43a3828d1897a92ece5fd4f6018fe3da "<a class="el" href="namespaceoperations__research_1_1sat.html#a43a3828d1897a92ece5fd4f6018fe3da">operations_research::sat::SolveDiophantine</a>" (absl::Span&lt; const int64_t &gt; coeffs, int64_t rhs, absl::Span&lt; const int64_t &gt; var_lbs, absl::Span&lt; const int64_t &gt; var_ubs)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001712 (user): look if there is a natural improvement. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a635874624086317f36f097b23b84d3eb "<a class="el" href="namespaceoperations__research_1_1sat.html#a635874624086317f36f097b23b84d3eb" title="Solves the given flatzinc model using the CP-SAT solver.">operations_research::sat::SolveFzWithCpModelProto</a>" (const fz::Model &amp;model, const fz::FlatzincSatParameters &amp;p, const std::string &amp;sat_params, SolverLogger *logger, SolverLogger *solution_logger)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000457 (user): Supports setting the number of workers to 0, which will
then query the number of cores available. This is complex now as we
need to still support the expected behabior (no flags -&gt; 1 thread
fixed search, -f -&gt; 1 thread free search). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a11198d99e855837fa730eb6a5097a801 "<a class="el" href="namespaceoperations__research_1_1sat.html#a11198d99e855837fa730eb6a5097a801">operations_research::sat::SolveLoadedCpModel</a>" (const CpModelProto &amp;model_proto, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001567 (user): This should be transformed so that it can be called many times
and resume from the last search state as if it wasn't interrupted. That would
allow use to easily interleave different heuristics in the same thread. 
 &lt;p&gt; \anchor _todo001568 (user): This doesn't work with splitting in chunk for now. It
shouldn't be too hard to fix. 
 &lt;p&gt; \anchor _todo001569 (user): This parameter breaks the splitting in chunk of a Solve().
It should probably be moved into another SubSolver altogether. 
 &lt;p&gt; \anchor _todo001570 (user): Remove the weird translation INFEASIBLE-&gt;FEASIBLE in the
function above? 
 &lt;p&gt; \anchor _todo001585 (user): This should be transformed so that it can be called many times
and resume from the last search state as if it wasn't interrupted. That would
allow use to easily interleave different heuristics in the same thread. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SortedSubsetSums Member \_internalref classoperations__research_1_1sat_1_1SortedSubsetSums#a8d115f2b8d379dc3bac048105c4e0fc2 "<a class="el" href="classoperations__research_1_1sat_1_1SortedSubsetSums.html#a8d115f2b8d379dc3bac048105c4e0fc2">operations_research::sat::SortedSubsetSums::Compute</a>" (absl::Span&lt; const int64_t &gt; elements, int64_t maximum_sum, bool abort_if_maximum_reached=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002505 (user): We could optimize even further the case of a small maximum_sum. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2af162f5376a8d8234b9287b5c8163c1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a2af162f5376a8d8234b9287b5c8163c1">operations_research::sat::SplitAndLoadIntermediateConstraints</a>" (bool lb_required, bool ub_required, std::vector&lt; IntegerVariable &gt; *vars, std::vector&lt; int64_t &gt; *coeffs, Model *m)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001295 (user): We could use a smarter way to determine buckets, like putting
everyone with the same coeff together if possible and the split is ok. 
 &lt;p&gt; \anchor _todo001302 (user): Alternatively, we could use a O(num_changes) propagation (a
bit tricky to implement), or a decomposition into a tree with more than
one level. Both requires experimentations. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a5154a61154ff9b3522e0c0eba7ed0319 "<a class="el" href="namespaceoperations__research_1_1sat.html#a5154a61154ff9b3522e0c0eba7ed0319">operations_research::sat::SplitAroundLpValue</a>" (IntegerVariable var, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001858 (user): Depending if we branch up or down, this might not exclude the
LP value, which is potentially a bad thing.&lt;p&gt; \anchor _todo001859 (user): Why is the reduced cost doing things differently? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SquarePropagator Class \_internalref classoperations__research_1_1sat_1_1SquarePropagator "<a class="el" href="classoperations__research_1_1sat_1_1SquarePropagator.html">operations_research::sat::SquarePropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001852 (user): Only works for x nonnegative. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#a2e92cf06868589083c5369b049fc5a26 "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#a2e92cf06868589083c5369b049fc5a26">operations_research::sat::StampingSimplifier::ComputeStampsForNextRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002319 (user): compute some dtime, it is always zero currently.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#abf4ca83561578670ef702769097d29fd "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#abf4ca83561578670ef702769097d29fd">operations_research::sat::StampingSimplifier::DoOneRound</a>" (bool log_info)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002318 (user): We could probably deal with it if needed so that we don't
need to do equivalence detection each time we want to run this. 
 &lt;p&gt; \anchor _todo002354 (user): To save one scan over all the clauses, we could do the fixed
and equivalence variable cleaning here too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#adeaa7bc64c667a667195ba5f6161f8c1 "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#adeaa7bc64c667a667195ba5f6161f8c1">operations_research::sat::StampingSimplifier::ProcessClauses</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002323 below. 
 &lt;p&gt; \anchor _todo002324 (user): Note that it is okay to still use top_entry, but we
might miss the removal of b if b =&gt; c. Also the paper do things
differently. Make sure we don't miss any simplification
opportunites by not changing top_entry. Same in the other
branches. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::StampingSimplifier Member \_internalref classoperations__research_1_1sat_1_1StampingSimplifier#ab4ed798d7a5c1b5957e4f9605963174e "<a class="el" href="classoperations__research_1_1sat_1_1StampingSimplifier.html#ab4ed798d7a5c1b5957e4f9605963174e" title="Visible for testing.">operations_research::sat::StampingSimplifier::SampleTreeAndFillParent</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002320 (user): Better algo to not select redundant parent.&lt;p&gt; \anchor _todo002321 (user): if parents_[x] = y, try not to have parents_[not(y)] = not(x)
because this is not as useful for the simplification power.&lt;p&gt; \anchor _todo002322 (user): More generally, we could sample a parent while probing so
that we consider all hyper binary implications (in the case we don't add
them to the implication graph already). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubsetsDetector Member \_internalref classoperations__research_1_1sat_1_1SubsetsDetector#a30eb576fe954759035b63e24294867b2 "<a class="el" href="classoperations__research_1_1sat_1_1SubsetsDetector.html#a30eb576fe954759035b63e24294867b2">operations_research::sat::SubsetsDetector&lt; Storage &gt;::FindSubsets</a>" (absl::Span&lt; const int &gt; superset, int *next_index_to_try, const std::function&lt; void(int subset)&gt; &amp;process)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001786 (user): Technically we do not need to check the watched position or
the "other element" position, we could do that by permuting them first
or last and iterating on a subspan. However, in many slow situation, we
have millions of size 2 sets, and the time is dominated by the first
check. 
 &lt;p&gt; \anchor _todo001787 (user): Remove this and the more complex API need once we move
class. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a4edf090e6f497b612dab8bfc4b53cd4c "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a4edf090e6f497b612dab8bfc4b53cd4c">operations_research::sat::SubSolver::DeterministicTimingInfo</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002454 (user): remove trailing "<br  />
" from ValueAsString().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a68765bc7ed07ce93ffeddbe61ad40d65 "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a68765bc7ed07ce93ffeddbe61ad40d65">operations_research::sat::SubSolver::GenerateTask</a>" (int64_t task_id)=0&lt;/dt&gt;&lt;dd&gt; \anchor _todo002452 (user): We could use a more complex selection logic and pass in the
deterministic time limit this subtask should run for. Unclear at this
stage.&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SubSolver Member \_internalref classoperations__research_1_1sat_1_1SubSolver#a03147f5723fa17d3ce80ace93578af57 "<a class="el" href="classoperations__research_1_1sat_1_1SubSolver.html#a03147f5723fa17d3ce80ace93578af57">operations_research::sat::SubSolver::TimingInfo</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo002453 (user): remove trailing "<br  />
" from ValueAsString() or just build the
table line directly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SymmetryPropagator Class \_internalref classoperations__research_1_1sat_1_1SymmetryPropagator "<a class="el" href="classoperations__research_1_1sat_1_1SymmetryPropagator.html">operations_research::sat::SymmetryPropagator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002456 (user): Implement the optimizations mentioned in the paper?
 &lt;p&gt; &lt;p&gt;(user): Instrument and see if the code can be optimized. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::SymmetryPropagator Member \_internalref classoperations__research_1_1sat_1_1SymmetryPropagator#a020a35d3244af33a45a416f037529459 "<a class="el" href="classoperations__research_1_1sat_1_1SymmetryPropagator.html#a020a35d3244af33a45a416f037529459">operations_research::sat::SymmetryPropagator::AddSymmetry</a>" (std::unique_ptr&lt; SparsePermutation &gt; permutation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002457 (user): Currently this can only be called before PropagateNext() is
called (DCHECKed). Not sure if we need more incrementality though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TimeTablingPerTask Class \_internalref classoperations__research_1_1sat_1_1TimeTablingPerTask "<a class="el" href="classoperations__research_1_1sat_1_1TimeTablingPerTask.html">operations_research::sat::TimeTablingPerTask</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002482 (user): Use SchedulingDemandHelper. In particular, if we know the task
is from a set of fixed alternatives, we might be able to push it more. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TimeTablingPerTask Member \_internalref classoperations__research_1_1sat_1_1TimeTablingPerTask#a3e048be6a5e38900071af4c347b0dff9 "<a class="el" href="classoperations__research_1_1sat_1_1TimeTablingPerTask.html#a3e048be6a5e38900071af4c347b0dff9">operations_research::sat::TimeTablingPerTask::TimeTablingPerTask</a>" (AffineExpression capacity, SchedulingConstraintHelper *helper, SchedulingDemandHelper *demands, Model *model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002477 (user): This usually correspond to a makespan interval.
We should just detect and propagate it separately as it would result
in a faster propagation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopN Class \_internalref classoperations__research_1_1sat_1_1TopN "<a class="el" href="classoperations__research_1_1sat_1_1TopN.html">operations_research::sat::TopN&lt; Element, Score &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002502 (user): We could use gtl::TopN when/if it gets open sourced. Note that
we might be slighlty faster here since we use an indirection and don't move
the Element class around as much. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopN Member \_internalref classoperations__research_1_1sat_1_1TopN#aab2091998d8295f6ecc5fd5f2beeebbb "<a class="el" href="classoperations__research_1_1sat_1_1TopN.html#aab2091998d8295f6ecc5fd5f2beeebbb">operations_research::sat::TopN&lt; Element, Score &gt;::Add</a>" (Element e, Score score)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002506 (user): We could delay that on the n + 1 push.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TopNCuts Class \_internalref classoperations__research_1_1sat_1_1TopNCuts "<a class="el" href="classoperations__research_1_1sat_1_1TopNCuts.html">operations_research::sat::TopNCuts</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo001950 (user): Avoid computing efficacity twice.
 &lt;p&gt; &lt;p&gt;(user): We don't use any orthogonality consideration here.
 &lt;p&gt; &lt;p&gt;(user): Detect duplicate cuts? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::Trail Member \_internalref classoperations__research_1_1sat_1_1Trail#af94a42301fbeb5da23fdfd2c914f2a01 "<a class="el" href="classoperations__research_1_1sat_1_1Trail.html#af94a42301fbeb5da23fdfd2c914f2a01">operations_research::sat::Trail::Resize</a>" (int num_variables)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002276 (user): these vectors are not always used. Initialize them
dynamically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a8fc9e60de9ebec04b0d8e62c0bcd7aa1 "<a class="el" href="namespaceoperations__research_1_1sat.html#a8fc9e60de9ebec04b0d8e62c0bcd7aa1">operations_research::sat::TransformToGeneratorOfStabilizer</a>" (int to_stabilize, std::vector&lt; std::unique_ptr&lt; SparsePermutation &gt; &gt; *generators)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002462 (user): Implement! 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::TryEdgeRectanglePropagator Member \_internalref classoperations__research_1_1sat_1_1TryEdgeRectanglePropagator#a0b0d3c6b3b9672a4d27704f604596ba1 "<a class="el" href="classoperations__research_1_1sat_1_1TryEdgeRectanglePropagator.html#a0b0d3c6b3b9672a4d27704f604596ba1">operations_research::sat::TryEdgeRectanglePropagator::GetMinimumProblemWithPropagation</a>" (int box_index, IntegerValue new_x_min)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001107 (user): skip the boxes that are fixed at level zero. They do not
contribute to the size of the explanation (so we shouldn't minimize their
number) and make the SetCover problem harder to solve. 
 &lt;p&gt; \anchor _todo001108 (user): We now know for each box the list of placements that it
contributes to the conflict. We could use this information to relax the
bounds of this box on the explanation of the propagation. For example, for
a box that always overlaps at least five units to the right when it does,
we could call AddStartMinReason(x_min - 4) instead of
AddStartMinReason(x_min). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a7e710c5266505c51982912036c840755 "<a class="el" href="namespaceoperations__research_1_1sat.html#a7e710c5266505c51982912036c840755" title="Adds linearization of different types of constraints.">operations_research::sat::TryToLinearizeConstraint</a>" (const CpModelProto &amp;model_proto, const ConstraintProto &amp;ct, int linearization_level, Model *model, LinearRelaxation *relaxation, ActivityBoundHelper *helper=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002054 (user): In full generality, we could encode all the constraint as an LP.
 &lt;p&gt; &lt;p&gt;(user): Add unit tests for this method.
 &lt;p&gt; &lt;p&gt;(user): Remove and merge with model loading. 
 &lt;p&gt; \anchor _todo002055 (user): Use the same pattern as the other 2 scheduling methods:
  - single function
  - generate helpers once&lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#aa5783ecb0b6b7f12fc2ea70339ec7acd "<a class="el" href="namespaceoperations__research_1_1sat.html#aa5783ecb0b6b7f12fc2ea70339ec7acd">operations_research::sat::TryToReconcileEncodings</a>" (const AffineExpression &amp;size2_affine, const AffineExpression &amp;affine, absl::Span&lt; const ValueLiteralPair &gt; affine_var_encoding, bool put_affine_left_in_result, IntegerEncoder *integer_encoder)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001767 (user): Consider removing this once we are more complete in our implied
bounds repository. Because if we can reconcile an encoding, then any of the
literal in the at most one should imply a value on the boolean view use in
the size2 affine. 
 &lt;p&gt; \anchor _todo001768 (user): I am not sure how this can happen since size2_affine is
supposed to be non-fixed. Maybe we miss some propag. Investigate. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a67f3b45ddd9ba6330059295e6258e4e6 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a67f3b45ddd9ba6330059295e6258e4e6">operations_research::sat::UpperBoundedLinearConstraint::AddToConflict</a>" (MutableUpperBoundedLinearConstraint *conflict)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002148 (user): Provides instead an easy to use iterator over an
UpperBoundedLinearConstraint and move this function to
MutableUpperBoundedLinearConstraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a7e533d8923312b0d052abae98cab81b8 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a7e533d8923312b0d052abae98cab81b8">operations_research::sat::UpperBoundedLinearConstraint::FillReason</a>" (const Trail &amp;trail, int source_trail_index, BooleanVariable propagated_variable, std::vector&lt; Literal &gt; *reason)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002147 (user): Maybe it is possible to derive a better reason by using more
information. For instance one could use the mask of literals that are
better to use during conflict minimization (namely the one already in the
1-UIP conflict). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#ab83a887ed56694501b3e60f573db6d74 "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#ab83a887ed56694501b3e60f573db6d74">operations_research::sat::UpperBoundedLinearConstraint::InitializeRhs</a>" (Coefficient rhs, int trail_index, Coefficient *threshold, Trail *trail, PbConstraintsEnqueueHelper *helper)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002133 (user): The source trail index for the propagation reason (i.e.
max_relevant_trail_index) may be higher than necessary (for some of the
propagated literals). Currently this works with FillReason(), but it was a
source of a really nasty bug (see CL 68906167) because of the (rhs == 1)
optim. Find a good way to test the logic. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::UpperBoundedLinearConstraint Member \_internalref classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint#a0d48dc8a24a03dea028d9f0e62ee257f "<a class="el" href="classoperations__research_1_1sat_1_1UpperBoundedLinearConstraint.html#a0d48dc8a24a03dea028d9f0e62ee257f">operations_research::sat::UpperBoundedLinearConstraint::ResolvePBConflict</a>" (const Trail &amp;trail, BooleanVariable var, MutableUpperBoundedLinearConstraint *conflict, Coefficient *conflict_slack)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002134 (user): Investigate if this is a good idea. It doesn't happen often,
but does happened. Maybe we can detect this before in Propagate()? The
setup is:
- At a given trail_index, var is propagated and added on the trail.
- There is some constraint literals assigned to true with a trail index
  in (trail_index, var.trail_index).
- Their sum is high enough to cause a conflict.
- But individually, their coefficients are too small to be propagated, so
  the conflict is not yet detected. It will be when these variables are
  processed by PropagateNext(). 
 &lt;p&gt; \anchor _todo002135 (user): If there is more "cancelation" than the min_coeffs below when
we add the two constraints, the resulting slack may be even lower. Taking
that into account is probably good. 
 &lt;p&gt; \anchor _todo002136 (user): The best will be to relax as little as possible. 
 &lt;p&gt; \anchor _todo002137 (user): track the cancelation here so we can update
*conflict_slack properly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2eec7d4958da587ee893e334ab7756cc "<a class="el" href="namespaceoperations__research_1_1sat.html#a2eec7d4958da587ee893e334ab7756cc">operations_research::sat::ValidateCpModel</a>" (const CpModelProto &amp;model, bool after_presolve)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001202 (user): Add any needed overflow validation because we are far from
exhaustive. We could also run a small presolve that tighten variable bounds
before the overflow check to facilitate the lives of our users, but it is a
some work to put in place. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a2073b9c892ac56b197b31cb583e25f3d "<a class="el" href="namespaceoperations__research_1_1sat.html#a2073b9c892ac56b197b31cb583e25f3d">operations_research::sat::ValidateInputCpModel</a>" (const SatParameters &amp;params, const CpModelProto &amp;model)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001203 (user): Ideally we would have just one ValidateCpModel() function but
this was introduced after many users already use ValidateCpModel() without
parameters. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#ad582c9543b77917ac1084bbfda601f5e "<a class="el" href="namespaceoperations__research_1_1sat.html#ad582c9543b77917ac1084bbfda601f5e">operations_research::sat::ValidateLinearConstraintForOverflow</a>" (const LinearConstraint &amp;constraint, const IntegerTrail &amp;integer_trail)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001928 (user): Avoid duplication with PossibleIntegerOverflow() in the checker?
At least make sure the code is the same. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a80f1b6bbf960239725bec385f09a5b14 "<a class="el" href="namespaceoperations__research_1_1sat.html#a80f1b6bbf960239725bec385f09a5b14">operations_research::sat::ValidateParameters</a>" (const SatParameters &amp;params)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002126 (user): Consider using annotations directly in the proto for these
validation. It is however not open sourced. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat Member \_internalref namespaceoperations__research_1_1sat#a007d129b4917935f84c9ae0823c2cb11 "<a class="el" href="namespaceoperations__research_1_1sat.html#a007d129b4917935f84c9ae0823c2cb11">operations_research::sat::VarDebugString</a>" (const CpModelProto &amp;proto, int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo001199 (user): unfortunately, we need this indirection to get a DebugString()
in a const way from an index. Because building an IntVar is non-const. 
 &lt;p&gt; \anchor _todo001200 (user): Use domain pretty print function.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VarDomination Class \_internalref classoperations__research_1_1sat_1_1VarDomination "<a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html">operations_research::sat::VarDomination</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002530 (user): We have a lot of benchmarks and tests that shows that we don't
report wrong relations, but we lack unit test that make sure we don't miss
any. Try to improve the situation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VarDomination Member \_internalref classoperations__research_1_1sat_1_1VarDomination#ab03b7579b6f0728fd7c98fccae5196ed "<a class="el" href="classoperations__research_1_1sat_1_1VarDomination.html#ab03b7579b6f0728fd7c98fccae5196ed">operations_research::sat::VarDomination::EndFirstPhase</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo002507 (user): Use more heuristics to not miss as much dominance relation when
we crop initial lists. 
 &lt;p&gt; \anchor _todo002508 (user): Tune the initial size, 50 might be a bit large, since our
complexity is borned by this number times the number of entries in the
constraints. Still we should in most situation be a lot lower than that. 
 &lt;p&gt; \anchor _todo002509 (user): Maybe we should do that with all lists in case the
input function are called with duplicates too. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VariableWithSameReasonIdentifier Class \_internalref classoperations__research_1_1sat_1_1VariableWithSameReasonIdentifier "<a class="el" href="classoperations__research_1_1sat_1_1VariableWithSameReasonIdentifier.html">operations_research::sat::VariableWithSameReasonIdentifier</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002144 (user): With the new SAME_REASON_AS mechanism, this is more general so
move out of pb_constraint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::VectorWithSparseUsage Class \_internalref classoperations__research_1_1sat_1_1VectorWithSparseUsage "<a class="el" href="classoperations__research_1_1sat_1_1VectorWithSparseUsage.html">operations_research::sat::VectorWithSparseUsage&lt; T &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002232 (user): Maybe a SparseBitset + sparse clear is better. But this is a
worth alternative to test IMO. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#a58a0ce20218c3abd705302dd4de5474f "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#a58a0ce20218c3abd705302dd4de5474f">operations_research::sat::ZeroHalfCutHelper::AddOneConstraint</a>" (glop::RowIndex, absl::Span&lt; const glop::ColIndex &gt; cols, absl::Span&lt; const IntegerValue &gt; coeffs, IntegerValue lb, IntegerValue ub)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002536 (user): experiment with the best value. probably only tight rows are
best? and we could use the basis status rather than recomputing the
activity for that.&lt;p&gt; \anchor _todo002537 (user): Avoid adding duplicates and just randomly pick one. Note
that we should also remove duplicate in a generic way. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#a67c63ecc26af5761893b5b5e93e7c5dd "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#a67c63ecc26af5761893b5b5e93e7c5dd">operations_research::sat::ZeroHalfCutHelper::ProcessVariables</a>" (const std::vector&lt; double &gt; &amp;lp_values, absl::Span&lt; const IntegerValue &gt; lower_bounds, absl::Span&lt; const IntegerValue &gt; upper_bounds)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002539 (user): This is a first implementation, both the heuristic and the
code performance can probably be improved uppon. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::sat::ZeroHalfCutHelper Member \_internalref classoperations__research_1_1sat_1_1ZeroHalfCutHelper#a263bfb5f369c64ebc8abba96d2e69d63 "<a class="el" href="classoperations__research_1_1sat_1_1ZeroHalfCutHelper.html#a263bfb5f369c64ebc8abba96d2e69d63">operations_research::sat::ZeroHalfCutHelper::SymmetricDifference</a>" (absl::Span&lt; const int &gt; a, std::vector&lt; int &gt; *b)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002538 (user): optim by doing that at the end?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SatInterface Member \_internalref classoperations__research_1_1SatInterface#aa26cae7629efd16954fcc84081c98410 "<a class="el" href="classoperations__research_1_1SatInterface.html#aa26cae7629efd16954fcc84081c98410">operations_research::SatInterface::SetPresolveMode</a>" (int value) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000851 (user): Implement me.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a01d1829b304f98e931c8bd5f3ccdcc42 "<a class="el" href="namespaceoperations__research.html#a01d1829b304f98e931c8bd5f3ccdcc42">operations_research::SatSolveProto</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request, std::atomic&lt; bool &gt; *interrupt_solve, std::function&lt; void(const std::string &amp;)&gt; logging_callback, std::function&lt; void(const MPSolution &amp;)&gt; solution_callback)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000843 (user): We do not support all the parameters here. In particular the
logs before the solver is called will not be appended to the response. Fix
that, and remove code duplication for the logger config. One way should be
to not touch/configure anything if the logger is already created while
calling SolveCpModel() and call a common config function from here or from
inside Solve()? 
 &lt;p&gt; \anchor _todo000844 (user): We put the INFEASIBLE_OR_UNBOUNBED case here since there
is no return status that exactly matches it. 
 &lt;p&gt; \anchor _todo000845 (user): Implement the row and column status. 
 &lt;p&gt; \anchor _todo000846 (user): Remove the postsolve hack of copying to a response. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SavingsFilteredHeuristic::SavingsContainer Member \_internalref classoperations__research_1_1SavingsFilteredHeuristic_1_1SavingsContainer#a540b8ac71e4a7b1341ec7451e0a3df83 "<a class="el" href="classoperations__research_1_1SavingsFilteredHeuristic_1_1SavingsContainer.html#a540b8ac71e4a7b1341ec7451e0a3df83">operations_research::SavingsFilteredHeuristic::SavingsContainer&lt; Saving &gt;::Sort</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000421 (user): Also do this when reiterating on next_savings_. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScipConstraintHandlerContext Member \_internalref classoperations__research_1_1ScipConstraintHandlerContext#ae4b686d5d1040fcf4db709e98a2022af "<a class="el" href="classoperations__research_1_1ScipConstraintHandlerContext.html#ae4b686d5d1040fcf4db709e98a2022af">operations_research::ScipConstraintHandlerContext::is_pseudo_solution</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000857 (user): maybe this can be abstracted away. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScipConstraintHandlerDescription Struct \_internalref structoperations__research_1_1ScipConstraintHandlerDescription "<a class="el" href="structoperations__research_1_1ScipConstraintHandlerDescription.html">operations_research::ScipConstraintHandlerDescription</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000856 (user): no effort has been made to optimize the default values of
enforcement_priority, feasibility_check_priority, eager_frequency, or
separation_priority. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SCIPInterface Member \_internalref classoperations__research_1_1SCIPInterface#a8682d7f525de8a5c389cf5e1b495f1ac "<a class="el" href="classoperations__research_1_1SCIPInterface.html#a8682d7f525de8a5c389cf5e1b495f1ac">operations_research::SCIPInterface::Solve</a>" (const MPSolverParameters &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000858 (user): Is that still true now (2018) ? 
 &lt;p&gt; \anchor _todo000859 (user): I more or less copied this from the SCIPreadSol() code that
reads a solution from a file. I am not sure what SCIPisTransformed() is
or what is the difference between the try and add version. In any case
this seems to always call SCIPaddSolFree() for now and it works. 
 &lt;p&gt; \anchor _todo000860 (user): We could introduce our own "infeasible or unbounded" status. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::ScopedFloatingPointEnv Class \_internalref classoperations__research_1_1ScopedFloatingPointEnv "<a class="el" href="classoperations__research_1_1ScopedFloatingPointEnv.html">operations_research::ScopedFloatingPointEnv</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002548 (user): Make it work on 32 bits.
 &lt;p&gt; &lt;p&gt;(user): Make it work on msvc, currently calls to _controlfp crash. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SequenceVar Member \_internalref classoperations__research_1_1SequenceVar#a9858103573f2d43dda6714eacfc2b76b "<a class="el" href="classoperations__research_1_1SequenceVar.html#a9858103573f2d43dda6714eacfc2b76b">operations_research::SequenceVar::ComputePossibleFirstsAndLasts</a>" (std::vector&lt; int &gt; *possible_firsts, std::vector&lt; int &gt; *possible_lasts)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000433 (user): use domain iterator.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SequenceVar Member \_internalref classoperations__research_1_1SequenceVar#ac6537f9c14b5450c8e44ec475bce71c7 "<a class="el" href="classoperations__research_1_1SequenceVar.html#ac6537f9c14b5450c8e44ec475bce71c7" title="--— SequenceVar --—">operations_research::SequenceVar::SequenceVar</a>" (Solver *s, const std::vector&lt; IntervalVar * &gt; &amp;intervals, const std::vector&lt; IntVar * &gt; &amp;nexts, const std::string &amp;name)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000432 (user): Add better class invariants, in particular checks
that ranked_first, ranked_last, and unperformed are truly disjoint. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverInvariant Member \_internalref classoperations__research_1_1SetCoverInvariant#a11ab8b9645323b91c44a1cb9967e55f2 "<a class="el" href="classoperations__research_1_1SetCoverInvariant.html#a11ab8b9645323b91c44a1cb9967e55f2">operations_research::SetCoverInvariant::ComputeIsRedundant</a>" (SubsetIndex subset) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000057 (user): Implement this using AVX-512? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverInvariant Member \_internalref classoperations__research_1_1SetCoverInvariant#ad7d9ad7be33c9647ba71758e56daa68f "<a class="el" href="classoperations__research_1_1SetCoverInvariant.html#ad7d9ad7be33c9647ba71758e56daa68f">operations_research::SetCoverInvariant::SelectNoUpdate</a>" (SubsetIndex subset)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000058 (user): Merge with Select. Introduce consistency levels and maybe split
the invariant into three. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverLagrangian Member \_internalref classoperations__research_1_1SetCoverLagrangian#aeae68a824e917a294697ff76b2811e7a "<a class="el" href="classoperations__research_1_1SetCoverLagrangian.html#aeae68a824e917a294697ff76b2811e7a">operations_research::SetCoverLagrangian::ComputeGap</a>" (const SubsetCostVector &amp;reduced_costs, const SubsetBoolVector &amp;solution, const ElementCostVector &amp;multipliers) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000065 (user): Parallelize this, if need be.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverLagrangian Member \_internalref classoperations__research_1_1SetCoverLagrangian#adaab24db67d2771d15bb343171af0aff "<a class="el" href="classoperations__research_1_1SetCoverLagrangian.html#adaab24db67d2771d15bb343171af0aff" title="Initializes the multipliers vector (u) based on the cost per subset.">operations_research::SetCoverLagrangian::InitializeLagrangeMultipliers</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000060 (user): Parallelize this.
 &lt;p&gt; \anchor _todo000061 (user): Parallelize this.
 &lt;p&gt; \anchor _todo000062 (user): use std::min_element on rows[element] with a custom
comparator that gets marginal_costs[subset]. Check performance. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverLagrangian Member \_internalref classoperations__research_1_1SetCoverLagrangian#a3c9602adfa3dbf354e8788d3eb4ae42a "<a class="el" href="classoperations__research_1_1SetCoverLagrangian.html#a3c9602adfa3dbf354e8788d3eb4ae42a">operations_research::SetCoverLagrangian::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000069 (user): Add time-outs and exit with a partial solution. This seems
unlikely, though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverLagrangian Member \_internalref classoperations__research_1_1SetCoverLagrangian#a895b3ee915078aa7e4797380dc48f9cd "<a class="el" href="classoperations__research_1_1SetCoverLagrangian.html#a895b3ee915078aa7e4797380dc48f9cd" title="Computes the reduced costs for all subsets in parallel using ThreadPool.">operations_research::SetCoverLagrangian::ParallelComputeReducedCosts</a>" (const SubsetCostVector &amp;costs, const ElementCostVector &amp;multipliers) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000063 (user): compute a close-to-optimal k-subset partitioning of the columns
based on their sizes. [***] 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverLagrangian Member \_internalref classoperations__research_1_1SetCoverLagrangian#a5cf44bc52b80fcd2298c7bb19a2134e4 "<a class="el" href="classoperations__research_1_1SetCoverLagrangian.html#a5cf44bc52b80fcd2298c7bb19a2134e4">operations_research::SetCoverLagrangian::ParallelComputeSubgradient</a>" (const SubsetCostVector &amp;reduced_costs) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000064 (user): it may be better to split the elements among the threads,
although this might be less well-balanced. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverMip Member \_internalref classoperations__research_1_1SetCoverMip#a001442db41cffab6e77f01a2de737956 "<a class="el" href="classoperations__research_1_1SetCoverMip.html#a001442db41cffab6e77f01a2de737956">operations_research::SetCoverMip::NextSolution</a>" (bool use_integers, double time_limit_in_seconds)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000070 (user): Add time-outs and exit with a partial solution. This seems
unlikely, though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverModel Member \_internalref classoperations__research_1_1SetCoverModel#ac7471075ebb259039dec01311c1000b2 "<a class="el" href="classoperations__research_1_1SetCoverModel.html#ac7471075ebb259039dec01311c1000b2">operations_research::SetCoverModel::ComputeRowDeltaSizeStats</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000073 (user): actually use this to compress the rows and columns. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SetCoverModel Member \_internalref classoperations__research_1_1SetCoverModel#a14a443043e7a3976dd53b2a08763e3b1 "<a class="el" href="classoperations__research_1_1SetCoverModel.html#a14a443043e7a3976dd53b2a08763e3b1">operations_research::SetCoverModel::GenerateRandomModelFrom</a>" (const SetCoverModel &amp;seed_model, BaseInt num_elements, BaseInt num_subsets, double row_scale, double column_scale, double cost_scale)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000071 (user): if necessary, use a better distribution for the costs.
The generation of the costs is done in two steps. First, compute the
minimum and maximum costs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a759cbf01a64672ed6d944df33e681bc7 "<a class="el" href="namespaceoperations__research.html#a759cbf01a64672ed6d944df33e681bc7">operations_research::setobjoffset</a>" (const XPRSprob &amp;mLp, double value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000871 detect xpress version
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleLinearSumAssignment Member \_internalref classoperations__research_1_1SimpleLinearSumAssignment#a613c560fdd07ae94350736adaf2dab56 "<a class="el" href="classoperations__research_1_1SimpleLinearSumAssignment.html#a613c560fdd07ae94350736adaf2dab56">operations_research::SimpleLinearSumAssignment::Solve</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000661 (user): Improve the LinearSumAssignment api to clearly define
the error cases. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Class \_internalref classoperations__research_1_1SimpleMaxFlow "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html">operations_research::SimpleMaxFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000719 (user): If the need arises, extend this interface to support warm start. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Member \_internalref classoperations__research_1_1SimpleMaxFlow#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700 "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700">operations_research::SimpleMaxFlow::POSSIBLE_OVERFLOW</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000721 (user): rename POSSIBLE_OVERFLOW to INT_OVERFLOW and modify our
clients. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMaxFlow Member \_internalref classoperations__research_1_1SimpleMaxFlow#a57296b653813abdd8d711048e87d1212 "<a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a57296b653813abdd8d711048e87d1212">operations_research::SimpleMaxFlow::SetArcCapacity</a>" (ArcIndex arc, FlowQuantity capacity)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000720 (user): Support incrementality in the max flow implementation. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SimpleMinCostFlow Class \_internalref classoperations__research_1_1SimpleMinCostFlow "<a class="el" href="classoperations__research_1_1SimpleMinCostFlow.html">operations_research::SimpleMinCostFlow</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000731 (user): If the need arises, extend this interface to support warm start
and incrementality between solves. Note that this is already supported by the
GenericMinCostFlow&lt;&gt; interface. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a0e4560b3dd453377ef8c29372e7e75e1 "<a class="el" href="namespaceoperations__research.html#a0e4560b3dd453377ef8c29372e7e75e1" title="Same as above but taking alternative parameters for each alternative model.">operations_research::SolveFromAssignmentWithAlternativeSolversAndParameters</a>" (const Assignment *assignment, RoutingModel *primary_model, const RoutingSearchParameters &amp;parameters, const std::vector&lt; RoutingModel * &gt; &amp;alternative_models, const std::vector&lt; RoutingSearchParameters &gt; &amp;alternative_parameters, int max_non_improving_iterations)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000398 (user): Add support for multiple metaheuristics. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#ae1b6e8c0d3d27218470118e9182605ed "<a class="el" href="namespaceoperations__research.html#ae1b6e8c0d3d27218470118e9182605ed">operations_research::SolveModelWithSat</a>" (RoutingModel *model, const RoutingSearchParameters &amp;search_parameters, const Assignment *initial_solution, Assignment *solution)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000390 (user): Check that performance is acceptable.
 &lt;p&gt; \anchor _todo000391 (user): Check that performance is acceptable.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a1874495370d2fab28ba9487e2f845b81 "<a class="el" href="namespaceoperations__research.html#a1874495370d2fab28ba9487e2f845b81">operations_research::SolveMPModel</a>" (LazyMutableCopy&lt; MPModelRequest &gt; request, const SolveInterrupter *interrupter)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000863 (b/311704821): this function should not delegate to MPSolver, also true
for the functions below. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a87ca0b6abf9c8724900387f5aa557c04 "<a class="el" href="classoperations__research_1_1Solver.html#a87ca0b6abf9c8724900387f5aa557c04">operations_research::Solver::Action</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000148 (user): wrap in swig.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a38d14a90db2f0ae3bc1563d453e4f93e "<a class="el" href="classoperations__research_1_1Solver.html#a38d14a90db2f0ae3bc1563d453e4f93e">operations_research::Solver::AddPropagationMonitor</a>" (PropagationMonitor *monitor)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000144 (user): Check solver state?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa290140ba6c4d6ef672c792a63bad57c "<a class="el" href="classoperations__research_1_1Solver.html#aa290140ba6c4d6ef672c792a63bad57c">operations_research::Solver::ClearNeighbors</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000150 (user): Find a workaround to avoid exposing this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a00ddb4cf5be5463ec6b494808bc8f192 "<a class="el" href="classoperations__research_1_1Solver.html#a00ddb4cf5be5463ec6b494808bc8f192" title="--— ConstraintSolverParameters --—">operations_research::Solver::DefaultSolverParameters</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000149 (user): Move to constraint_solver_parameters.h. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ae3b660d3dece402d0ca5448d127c0f6f "<a class="el" href="classoperations__research_1_1Solver.html#ae3b660d3dece402d0ca5448d127c0f6f">operations_research::Solver::GetOrCreateLocalSearchState</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000166 (user): Investigate if this should be moved to Search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aeb2e6947882d148bfaece200f5c6b131 "<a class="el" href="classoperations__research_1_1Solver.html#aeb2e6947882d148bfaece200f5c6b131" title="Returns whether we are instrumenting demons.">operations_research::Solver::InstrumentsDemons</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000139 (user): remove this complex logic.
We need the double test because parameters are set too late when using
python in the open source. This is the cheapest work-around. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ae63acd77b8c2ee40387795051298f659 "<a class="el" href="classoperations__research_1_1Solver.html#ae63acd77b8c2ee40387795051298f659">operations_research::Solver::IntValueStrategy</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000147 (user): add HIGHEST_MIN and LOWEST_MAX.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a64fd8adbc00c3bed16bf4b824dfd3e2b "<a class="el" href="classoperations__research_1_1Solver.html#a64fd8adbc00c3bed16bf4b824dfd3e2b">operations_research::Solver::LocalSearchProfile</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000164 (user): Merge demon and local search profiles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a579ddb4232150f04e17c0852fc8e1c60 "<a class="el" href="classoperations__research_1_1Solver.html#a579ddb4232150f04e17c0852fc8e1c60" title="Force the &quot;nexts&quot; variable to create a complete Hamiltonian path.">operations_research::Solver::MakeCircuit</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000221 (user): Merge NoCycle and Circuit.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa1b2edf76ef068b3d1cc8b56f7e7af23 "<a class="el" href="classoperations__research_1_1Solver.html#aa1b2edf76ef068b3d1cc8b56f7e7af23">operations_research::Solver::MakeDelayedPathCumul</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, const std::vector&lt; IntVar * &gt; &amp;cumuls, const std::vector&lt; IntVar * &gt; &amp;transits)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000155 (user): Merge with other path-cumuls constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0132207ac0371c18971693c8a6d9b29c "<a class="el" href="classoperations__research_1_1Solver.html#a0132207ac0371c18971693c8a6d9b29c" title="Aggregated version of count: |{i | v[i] == values[j]}| == cards[j].">operations_research::Solver::MakeDistribute</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; int64_t &gt; &amp;values, const std::vector&lt; IntVar * &gt; &amp;cards)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000182 (user) : we can sort values (and cards) before doing the test.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0ceffed2d421a344403f5a8366baa136 "<a class="el" href="classoperations__research_1_1Solver.html#a0ceffed2d421a344403f5a8366baa136" title="expr / value (integer division)">operations_research::Solver::MakeDiv</a>" (IntExpr *expr, int64_t value)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000202 (user) : implement special case.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0ab2b02352f4ab51aeb392314d7b60a5 "<a class="el" href="classoperations__research_1_1Solver.html#a0ab2b02352f4ab51aeb392314d7b60a5" title="boolvar == (var == value)">operations_research::Solver::MakeIsEqualCstCt</a>" (IntExpr *var, int64_t value, IntVar *boolvar)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000197 (user) : what happens if the constraint is not posted?
The cache becomes tainted. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a10c9da29e0f571f2fac430761d133016 "<a class="el" href="classoperations__research_1_1Solver.html#a10c9da29e0f571f2fac430761d133016">operations_research::Solver::MakeLexicalLess</a>" (const std::vector&lt; IntVar * &gt; &amp;left, const std::vector&lt; IntVar * &gt; &amp;right)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000153 (user): Add void MakeSortedArray(
                            const std::vector&lt;IntVar*&gt;&amp; vars,
                            std::vector&lt;IntVar*&gt;* const sorted); 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a79d9441a76ca41dce4b28ff9be616363 "<a class="el" href="classoperations__research_1_1Solver.html#a79d9441a76ca41dce4b28ff9be616363">operations_research::Solver::MakeLocalSearchPhase</a>" (Assignment *assignment, LocalSearchPhaseParameters *parameters)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000163 (user): Make a variant which runs a local search after each
               solution found in a DFS. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#aa8c0e8504dd5125dd200e9e3d9ef1e75 "<a class="el" href="classoperations__research_1_1Solver.html#aa8c0e8504dd5125dd200e9e3d9ef1e75">operations_research::Solver::MakeNoCycle</a>" (const std::vector&lt; IntVar * &gt; &amp;nexts, const std::vector&lt; IntVar * &gt; &amp;active, IndexFilter1 sink_handler=nullptr)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000154 (user): Implement MakeAllNullIntersect taking an array of
variable vectors. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#af6c9a69ab6f3bf11e703e91812d34223 "<a class="el" href="classoperations__research_1_1Solver.html#af6c9a69ab6f3bf11e703e91812d34223">operations_research::Solver::MakeNotBetweenCt</a>" (IntExpr *expr, int64_t l, int64_t u)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000198 (user): Add back simplification code if expr is constant *
other_expr. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ac78afa51e3d5d28e84916a6fc47375de "<a class="el" href="classoperations__research_1_1Solver.html#a8b56cd87a1851c3f17a27e76fdaa9579" title="Local Search Operators.">operations_research::Solver::MakeOperator</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IndexEvaluator3 evaluator, EvaluatorLocalSearchOperators op)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000162 (user): Make the callback an IndexEvaluator2 when there are no
secondary variables. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0456a638eb3c86b7e3c6bbcc6f1a961c "<a class="el" href="classoperations__research_1_1Solver.html#a0456a638eb3c86b7e3c6bbcc6f1a961c">operations_research::Solver::MakePathConnected</a>" (std::vector&lt; IntVar * &gt; nexts, std::vector&lt; int64_t &gt; sources, std::vector&lt; int64_t &gt; sinks, std::vector&lt; IntVar * &gt; status)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000156 (user): Only does checking on WhenBound events on next variables.
Check whether more propagation is needed. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a793b6001916186ac1d7041a10fdd41d6 "<a class="el" href="classoperations__research_1_1Solver.html#a793b6001916186ac1d7041a10fdd41d6">operations_research::Solver::MakePathPrecedenceConstraint</a>" (std::vector&lt; IntVar * &gt; nexts, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;precedences)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000157 (user): This constraint does not make holes in variable domains;
the implementation can easily be modified to do that; evaluate the impact
on models solved with local search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a66461677e91be7682f36b8660889fd2f "<a class="el" href="classoperations__research_1_1Solver.html#a66461677e91be7682f36b8660889fd2f">operations_research::Solver::MakePhase</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IntVarStrategy var_str, IntValueStrategy val_str)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000161 (user): name each of them differently, and document them (and do that
for all other functions that have several homonyms in this .h). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a039ebfef32db8ee5641b25328954cce9 "<a class="el" href="classoperations__research_1_1Solver.html#a66461677e91be7682f36b8660889fd2f">operations_research::Solver::MakePhase</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, IndexEvaluator2 eval, IndexEvaluator1 tie_breaker, EvaluatorStrategy str)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000437 (user): support tie breaker
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a84584b7705a787a70e09341e4a0e30f5 "<a class="el" href="classoperations__research_1_1Solver.html#a84584b7705a787a70e09341e4a0e30f5">operations_research::Solver::MakePiecewiseLinearExpr</a>" (IntExpr *expr, const PiecewiseLinearFunction &amp;f)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000151 (user): Investigate if we can merge all three piecewise linear
expressions. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#ac9865c3135d8b9b3f7de73c92dac53a4 "<a class="el" href="classoperations__research_1_1Solver.html#ac9865c3135d8b9b3f7de73c92dac53a4">operations_research::Solver::MakeSearchLog</a>" (int branch_period)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000159 (user): DEPRECATE API of MakeSearchLog(.., IntVar* var,..).
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#afbef3a751ed2de0600ef603df8dbc16f "<a class="el" href="classoperations__research_1_1Solver.html#afbef3a751ed2de0600ef603df8dbc16f">operations_research::Solver::MakeSemiContinuousExpr</a>" (IntExpr *expr, int64_t fixed_charge, int64_t step)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000203 (user) : benchmark with virtualization of
PosIntDivDown and PosIntDivUp - or function pointers. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#acdd432e2ef445bb100f999ebb36e8d9c "<a class="el" href="classoperations__research_1_1Solver.html#acdd432e2ef445bb100f999ebb36e8d9c">operations_research::Solver::MakeSimulatedAnnealing</a>" (bool maximize, IntVar *v, int64_t step, int64_t initial_temperature)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000158 (user): document behavior 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a0d6603ccdf190d08e5eb55a383cb7f42 "<a class="el" href="classoperations__research_1_1Solver.html#a0d6603ccdf190d08e5eb55a383cb7f42">operations_research::Solver::MakeSortingConstraint</a>" (const std::vector&lt; IntVar * &gt; &amp;vars, const std::vector&lt; IntVar * &gt; &amp;sorted)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000152 (user): Do we need a version with an array of escape values.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a4c57adb4aa21bbbb303282a2fb12a546 "<a class="el" href="classoperations__research_1_1Solver.html#a4c57adb4aa21bbbb303282a2fb12a546" title="Opens a new top level search.">operations_research::Solver::NewSearch</a>" (DecisionBuilder *db, const std::vector&lt; SearchMonitor * &gt; &amp;monitors)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000141 (user) : reset statistics
 &lt;p&gt; \anchor _todo000142 (user): delete top level search after EndSearch(). 
 &lt;p&gt; \anchor _todo000143 (user): Check if these two lines are still necessary.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#afa66a85cec14980401bb16d4f4a84aa1 "<a class="el" href="classoperations__research_1_1Solver.html#afa66a85cec14980401bb16d4f4a84aa1">operations_research::Solver::SetUseFastLocalSearch</a>" (bool use_fast_local_search)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000165 (user): Get rid of the following methods once fast local search is
enabled for metaheuristics.
Disables/enables fast local search. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::Solver Member \_internalref classoperations__research_1_1Solver#a904f4c25cf6302fc577889db54b240cc "<a class="el" href="classoperations__research_1_1Solver.html#a904f4c25cf6302fc577889db54b240cc">operations_research::Solver::Try</a>" (DecisionBuilder *db1, DecisionBuilder *db2)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000160 (user): The search tree can be balanced by using binary
"Try"-builders "recursively". For instance, Try(a,b,c,d) will give a tree
unbalanced to the right, whereas Try(Try(a,b), Try(b,c)) will give a
balanced tree. Investigate if we should only provide the binary version
and/or if we should balance automatically. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SolverLogger Member \_internalref classoperations__research_1_1SolverLogger#a596c5e6e999145f99d9afdb60ef52c84 "<a class="el" href="classoperations__research_1_1SolverLogger.html#a596c5e6e999145f99d9afdb60ef52c84">operations_research::SolverLogger::FlushPendingThrottledLogs</a>" (bool ignore_rates=false)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002551 (user): If this is called too often, we could optimize it and do
nothing if there are no skipped logs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#aec0a1432f35c101cf94319828d2e13a7 "<a class="el" href="namespaceoperations__research.html#aec0a1432f35c101cf94319828d2e13a7">operations_research::SolveWithAlternativeSolvers</a>" (RoutingModel *primary_model, const std::vector&lt; RoutingModel * &gt; &amp;alternative_models, const RoutingSearchParameters &amp;parameters, int max_non_improving_iterations)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000424 (user): Add a version taking search parameters for alternative models. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Class \_internalref classoperations__research_1_1SortedDisjointIntervalList "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html">operations_research::SortedDisjointIntervalList</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002572 (user): Templatize the class on the type of the bounds.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#a53aa27777a48b981046ad09b97bded60 "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a53aa27777a48b981046ad09b97bded60">operations_research::SortedDisjointIntervalList::InsertInterval</a>" (int64_t start, int64_t end)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002569 (user): tune the algorithm below if it proves to be a bottleneck.
For example, one could try to avoid an insertion if it's not needed
(when the interval merges with a single existing interval or is fully
contained by one). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#ad937d5864aa7a209f5c565a49daad904 "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a012ebc58df4ae590e12e89509b69ee90">operations_research::SortedDisjointIntervalList::InsertIntervals</a>" (const std::vector&lt; int &gt; &amp;starts, const std::vector&lt; int &gt; &amp;ends)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002570 (user): treat kint32min and kint32max as their kint64 variants.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SortedDisjointIntervalList Member \_internalref classoperations__research_1_1SortedDisjointIntervalList#a592c99d8ddbc2a357683903882c437ba "<a class="el" href="classoperations__research_1_1SortedDisjointIntervalList.html#a1d800ef9b7bcda7b2bd88941e63e9c0d">operations_research::SortedDisjointIntervalList::SortedDisjointIntervalList</a>" (const std::vector&lt; int64_t &gt; &amp;starts, const std::vector&lt; int64_t &gt; &amp;ends)&lt;/dt&gt;&lt;dd&gt; \anchor _todo002573 (user): Explain why we favored this API to the more natural
input std::vector&lt;ClosedInterval&gt; or std::vector&lt;std::pair&lt;int, int&gt;&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#a9fc0ca5752b5ad6cc2a78ff7c512b22a "<a class="el" href="classoperations__research_1_1SparsePermutation.html#a9fc0ca5752b5ad6cc2a78ff7c512b22a">operations_research::SparsePermutation::LastElementInCycle</a>" (int i) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000079 (user): Provide a full iterator for this? Note that we have more
information with the loop above. Not sure it is needed though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#a1190fc1695811df74812b7fb1051f3bc "<a class="el" href="classoperations__research_1_1SparsePermutation.html#a1190fc1695811df74812b7fb1051f3bc">operations_research::SparsePermutation::RemoveCycles</a>" (absl::Span&lt; const int &gt; cycle_indices)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000077 (user): make this a class member to avoid allocation if the complexity
becomes an issue. In this case, also optimize the loop below by not copying
the first cycles. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SparsePermutation Member \_internalref classoperations__research_1_1SparsePermutation#aff385d18c768ffa364c5dccb5fb35c0a "<a class="el" href="classoperations__research_1_1SparsePermutation.html#aff385d18c768ffa364c5dccb5fb35c0a">operations_research::SparsePermutation::Size</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000078 (user): complete the reader API.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a93f8f72c3931f60faed67abfe9b85f3e "<a class="el" href="namespaceoperations__research.html#a93f8f72c3931f60faed67abfe9b85f3e">operations_research::splitMyString</a>" (const std::string &amp;str, Container &amp;cont, char delim=' ')&lt;/dt&gt;&lt;dd&gt; \anchor _todo000878 useless ?
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SteepestSearch Member \_internalref classoperations__research_1_1SteepestSearch#a7b76a69a07f9abf4e7cd0ff88925208d "<a class="el" href="classoperations__research_1_1SteepestSearch.html#a7b76a69a07f9abf4e7cd0ff88925208d">operations_research::SteepestSearch::NextSolution</a>" (int num_iterations)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000054 (user): Add time-outs and exit with a partial solution. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SwapActiveChainOperator Member \_internalref classoperations__research_1_1SwapActiveChainOperator#ae44a5b221ccfb910745682e0179cf679 "<a class="el" href="classoperations__research_1_1SwapActiveChainOperator.html#ae44a5b221ccfb910745682e0179cf679">operations_research::SwapActiveChainOperator&lt; ignore_path_vars &gt;::DebugString</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000251 (user): Skip unfeasible chains by forcing the first base node to be
before the second one. Ideally this should be done as follows:
int64_t GetBaseNodeRestartPosition(int base_index) override {
  return (base_index == 0) ? StartNode(base_index) : BaseNode(base_index -
  1);
}
However due to the fact we are iterating over the chains multiple times
(once for each unperformed node), this breaks the ending position of the
neighborhood (causing an infinite iteration). 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SwapActiveToShortestPathOperator Class \_internalref classoperations__research_1_1SwapActiveToShortestPathOperator "<a class="el" href="classoperations__research_1_1SwapActiveToShortestPathOperator.html" title="| / \ ^">operations_research::SwapActiveToShortestPathOperator&lt; ignore_path_vars &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000387 (user): Support vehicle-class-dependent arc_evaluators. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::SymmetryManager Member \_internalref classoperations__research_1_1SymmetryManager#a6f8f0310d17cfdf227de35d5eaeb6ec2 "<a class="el" href="classoperations__research_1_1SymmetryManager.html#a6f8f0310d17cfdf227de35d5eaeb6ec2">operations_research::SymmetryManager::CheckSymmetries</a>" (int index)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000447 (user) : Improve speed, cache previous min and build them
incrementally. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeDistribution Class \_internalref classoperations__research_1_1TimeDistribution "<a class="el" href="classoperations__research_1_1TimeDistribution.html">operations_research::TimeDistribution</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002574 (user): Since we inherit from DistributionStat, we currently store the
sum of CPU cycles as a double internally. A better option is to use int64_t
because with the 53 bits of precision of a double, we will run into an issue
if the sum of times reaches 52 days for a 2GHz processor. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TimeLimit Class \_internalref classoperations__research_1_1TimeLimit "<a class="el" href="classoperations__research_1_1TimeLimit.html">operations_research::TimeLimit</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo002576 (user): The expression "deterministic time" should be replaced with
                "number of operations" to avoid confusion with "real" time. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TrivialSolutionGenerator Class \_internalref classoperations__research_1_1TrivialSolutionGenerator "<a class="el" href="classoperations__research_1_1TrivialSolutionGenerator.html" title="The consistency level is maintained up to kFreeAndUncovered.">operations_research::TrivialSolutionGenerator</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000048 (user): make the different algorithms concurrent, solving independent
subproblems in different threads.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::TrivialSolutionGenerator Member \_internalref classoperations__research_1_1TrivialSolutionGenerator#a72b5cae65519e7893e32e217ef056384 "<a class="el" href="classoperations__research_1_1TrivialSolutionGenerator.html#a72b5cae65519e7893e32e217ef056384" title="TrivialSolutionGenerator.">operations_research::TrivialSolutionGenerator::NextSolution</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000050 (user): Add time-outs and exit with a partial solution. This seems
unlikely, though. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::WeightedWaveletTree Member \_internalref classoperations__research_1_1WeightedWaveletTree#a8244c49d1623329f3fd59d622c805d1c "<a class="el" href="classoperations__research_1_1WeightedWaveletTree.html#a8244c49d1623329f3fd59d622c805d1c">operations_research::WeightedWaveletTree::MakeTreeFromNewElements</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000327 (user): investigate whether balancing the tree using the
number of occurrences of each height would be beneficial.
&lt;p&gt; \anchor _todo000328 &lt;p&gt; \anchor _todo000329 (user): use a heap-like encoding for the binary search tree:
children of i at 2*i and 2*i+1. Better cache line utilization. 
 &lt;p&gt; \anchor _todo000330 (user): stable_partition allocates memory,
find a way to fill layers without this. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a16607e74836faff69fe760ced72898ce "<a class="el" href="classoperations__research_1_1XpressInterface.html#a16607e74836faff69fe760ced72898ce" title="Adds a linear constraint.">operations_research::XpressInterface::AddRowConstraint</a>" (MPConstraint *ct) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000874 
Make new constraints basic (rowstat[jrow]=1)
Try not to delete basic variables, or non-basic constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#aa8856606b3e293087775ce7725e1dd99 "<a class="el" href="classoperations__research_1_1XpressInterface.html#aa8856606b3e293087775ce7725e1dd99" title="Add a variable.">operations_research::XpressInterface::AddVariable</a>" (MPVariable *var) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000875 
Make new variables non-basic at their lower bound (colstat[icol]=0), unless
a variable has an infinite lower bound and a finite upper bound, in which
case make the variable non-basic at its upper bound (colstat[icol]=2) Try
not to delete basic variables, or non-basic constraints. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a19631de62b2acb1c83d926ebea3c8e09 "<a class="el" href="classoperations__research_1_1XpressInterface.html#a19631de62b2acb1c83d926ebea3c8e09">operations_research::XpressInterface::ComputeExactConditionNumber</a>" () const override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000880 (user): Not yet working.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a99b8c52ba056e774c77c291506de3da1 "<a class="el" href="classoperations__research_1_1XpressInterface.html#a99b8c52ba056e774c77c291506de3da1" title="Extract all variables that have not yet been extracted.">operations_research::XpressInterface::ExtractNewVariables</a>" () override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000876 : Use a bitarray to flag the constraints that actually
intersect new variables? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#ada4d7eb4cf0ff57af8f2585fe4dfbdf6 "<a class="el" href="classoperations__research_1_1XpressInterface.html#ada4d7eb4cf0ff57af8f2585fe4dfbdf6" title="Modifies integrality of an extracted variable.">operations_research::XpressInterface::SetVariableInteger</a>" (int var_index, bool integer) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000872 : Should we check the current type and don't do anything
      in case the type does not change? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressInterface Member \_internalref classoperations__research_1_1XpressInterface#a6d7d562bf9d60d8006799f9f14d89afd "<a class="el" href="classoperations__research_1_1XpressInterface.html#a6d7d562bf9d60d8006799f9f14d89afd">operations_research::XpressInterface::Solve</a>" (MPSolverParameters const &amp;param) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000877 : check number of variables / constraints 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research::XpressMPCallbackContext Member \_internalref classoperations__research_1_1XpressMPCallbackContext#a7aa4754c5d84c3a8eb47a8f1384bc29f "<a class="el" href="classoperations__research_1_1XpressMPCallbackContext.html#a7aa4754c5d84c3a8eb47a8f1384bc29f">operations_research::XpressMPCallbackContext::SuggestSolution</a>" (const absl::flat_hash_map&lt; const MPVariable *, double &gt; &amp;solution) override&lt;/dt&gt;&lt;dd&gt; \anchor _todo000879 : remove this workaround when it is handled in XPRESS 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope operations_research Member \_internalref namespaceoperations__research#a64fe81674568cb08066a026a7d9eae8e "<a class="el" href="namespaceoperations__research.html#a64fe81674568cb08066a026a7d9eae8e">operations_research::YenKShortestPaths</a>" (const GraphType &amp;graph, const std::vector&lt; PathDistance &gt; &amp;arc_lengths, typename GraphType::NodeIndex source, typename GraphType::NodeIndex destination, unsigned k)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000713 (user): relax to "no negative-weight cycles" (no Dijkstra).
- The graphs might have loops.&lt;p&gt; \anchor _todo000715 (user): Yen's algorithm can work with negative weights, but
Dijkstra cannot.&lt;p&gt; \anchor _todo000716 (user): think about adding parallelism for this loop to improve
running times. This is not a priority as long as the algorithm is
faster than the one in &lt;tt&gt;shortest_paths.h&lt;/tt&gt;. 
 &lt;p&gt; \anchor _todo000717 (user): would it be faster to fingerprint the paths and
filter by fingerprints? Due to the probability of error with
fingerprints, still use this slow-but-exact code, but after
filtering. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref scip__callback_8cc#a55103a9413973772f122a9c3dfef5030 "SCIP_DECL_CONSENFOPS" (EnforcePseudoSolutionC)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000852 (user): are we sure the pseudo solution is LP feasible? It seems like
it doesn't need to be.  The code in RunSeparation might assume this? 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref scip__callback_8cc#a2e5ec3c32f1a6cde27f8a3538ea801bd "SCIP_DECL_CONSLOCK" (VariableRoundingLockC)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000853 (user): this could be a little better, but we would need to add
another method to override on ScipConstraintHandler&lt;ConstraintData&gt;. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope StronglyConnectedComponentsFinder Class \_internalref classStronglyConnectedComponentsFinder "<a class="el" href="classStronglyConnectedComponentsFinder.html">StronglyConnectedComponentsFinder&lt; NodeIndex, Graph, SccOutput &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000768 (user): Possible optimizations:
- Try to reserve the vectors which sizes are bounded by num_nodes.
- Use an index rather than doing push_back(), pop_back() on them. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref timer_8h#a430398fcce7a0820817d8dae9c226d00 "<a class="el" href="timer_8h.html#a430398fcce7a0820817d8dae9c226d00">UserTimer</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000082 (user): implement it properly. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Namespace \_internalref namespaceutil "util" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000687 (b/385094969): Once we no longer use &lt;tt&gt;Next()/Ok()&lt;/tt&gt; for iterators, we can
get rid of &lt;tt&gt;limit_&lt;/tt&gt;, which will make iteration much more efficient.&lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a4d620734ced86ff6b1b0faf61d6a2ed8 "<a class="el" href="classutil_1_1BaseGraph.html#a4d620734ced86ff6b1b0faf61d6a2ed8" title="Capacity reserved for future arcs, always &gt;= num_arcs_.">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::arc_capacity</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000690 (user): Same questions as the ones in node_capacity().
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a1e69188fcfb16d515686584fed636944 "<a class="el" href="classutil_1_1BaseGraph.html#a1e69188fcfb16d515686584fed636944">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::FreezeCapacities</a>" ()&lt;/dt&gt;&lt;dd&gt; \anchor _todo000691 (user): Only define this in debug mode at the cost of having a lot
of ifndef NDEBUG all over the place? remove the function completely ? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::BaseGraph Member \_internalref classutil_1_1BaseGraph#a37bfc797d615a301e75e2212de0dd11b "<a class="el" href="classutil_1_1BaseGraph.html#a37bfc797d615a301e75e2212de0dd11b" title="Capacity reserved for future nodes, always &gt;= num_nodes_.">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasNegativeReverseArcs &gt;::node_capacity</a>" () const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000689 (user): Is it needed? remove completely? return the real capacities
at the cost of having a different implementation for each graphs? 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a628255019800e5a053d08b1f0c5a05f2 "<a class="el" href="namespaceutil.html#a628255019800e5a053d08b1f0c5a05f2">util::EqualRange</a>" (MultiMap &amp;multi_map, const typename MultiMap::key_type &amp;key)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000711 (user): go further and expose only the values, not the pairs (key,
values) since the caller already knows the key. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::FlowGraph Class \_internalref classutil_1_1FlowGraph "<a class="el" href="classutil_1_1FlowGraph.html">util::FlowGraph&lt; NodeIndexType, ArcIndexType &gt;</a>" &lt;/dt&gt;&lt;dd&gt; \anchor _todo000672 (user): Currently only max-flow handles this graph, but not
min-cost-flow. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::FlowGraph Member \_internalref classutil_1_1FlowGraph#afd96ab1a061f14fe423bb7533d1211f5 "<a class="el" href="classutil_1_1FlowGraph.html#ac1986fea9d5664286e66d2875e457da4">util::FlowGraph&lt; NodeIndexType, ArcIndexType &gt;::Build</a>" (std::vector&lt; ArcIndexType &gt; *permutation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000673 (user): For now we only support sorting, or all new reverse after
and keep the original arc order. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::graph Member \_internalref namespaceutil_1_1graph#a440afdf238e5a752bbe4e1bcc8878fe7 "<a class="el" href="namespaceutil_1_1graph.html#a440afdf238e5a752bbe4e1bcc8878fe7">util::graph::FindCycleInGraph</a>" (const AdjacencyLists &amp;adj)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000769 (user): Caching adj[cur_state-&gt;node] in a local stack to improve
locality and so that the [] operator is called exactly once per node. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a9470623ca7db3c4a62ce3b326c6b07d8 "<a class="el" href="namespaceutil.html#a9470623ca7db3c4a62ce3b326c6b07d8">util::PermuteWithExplicitElementType</a>" (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000688 (user): consider slower but more memory efficient implementations that
follow the cycles of the permutation and use a bitmap to indicate what has
been permuted or to mark the beginning of each cycle. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util Member \_internalref namespaceutil#a06fa201576c927d92657e090fa86bfdb "<a class="el" href="namespaceutil.html#a06fa201576c927d92657e090fa86bfdb">util::RemoveCyclesFromPath</a>" (const Graph &amp;graph, std::vector&lt; int &gt; *arc_path)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000770 (user): In some cases, there is more than one possible solution. We could
take some arc costs and return the cheapest path instead. Or return the
shortest path in term of number of arcs. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcMixedGraph Member \_internalref classutil_1_1ReverseArcMixedGraph#a5ebe11f2abcd78ad1f5606e27d1688bb "<a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a5ebe11f2abcd78ad1f5606e27d1688bb">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>" (ArcIndexType arc) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000694 (user): support Head() and Tail() before Build(), like StaticGraph&lt;&gt;.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcMixedGraph::OutgoingArcIterator Member \_internalref classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator#ac265893b8e1a6db1380522442bf66c84 "<a class="el" href="classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator.html#ac265893b8e1a6db1380522442bf66c84">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>" (OutgoingArcIterator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000698 (user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this
iterator rather than a simple IntegerRange on the arc indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph Member \_internalref classutil_1_1ReverseArcStaticGraph#a590ee70b96ce87433ba89b067495aa5f "<a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a485803d141f9c80beaaae7094548d672">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Build</a>" (std::vector&lt; ArcIndexType &gt; *permutation)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000692 (user): the 0 is wasted here, but minor optimisation.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph Member \_internalref classutil_1_1ReverseArcStaticGraph#a72e8ed03fe3f8ff27d156622a86900aa "<a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a72e8ed03fe3f8ff27d156622a86900aa">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>" (ArcIndexType arc) const&lt;/dt&gt;&lt;dd&gt; \anchor _todo000693 (user): support Head() and Tail() before Build(), like StaticGraph&lt;&gt;.
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::ReverseArcStaticGraph::OutgoingArcIterator Member \_internalref classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator#a4f7501971b3fcc6ab34772a93c449ac6 "<a class="el" href="classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator.html#a4f7501971b3fcc6ab34772a93c449ac6">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>" (OutgoingArcIterator)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000697 (user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this
iterator rather than a simple IntegerRange on the arc indices. 
 &lt;/dd&gt; &lt;dt&gt;
\_setscope util::SVector Member \_internalref classutil_1_1SVector#a287f9791ba2e68e137d53fc038bbe432 "<a class="el" href="classutil_1_1SVector.html#a287f9791ba2e68e137d53fc038bbe432">util::SVector&lt; T &gt;::reserve</a>" (int n)&lt;/dt&gt;&lt;dd&gt; \anchor _todo000695 (user): in C++17 we could use std::uninitialized_move instead
of this loop. 
 &lt;/dd&gt; &lt;dt&gt;
Member \_internalref parser_8tab_8cc#ad3cdc959806aba1ada0fd7e5d4184f88 "yyparse" (<a class="el" href="structoperations__research_1_1fz_1_1ParserContext.html" title="This is the context used during parsing.">operations_research::fz::ParserContext</a> *context, <a class="el" href="classoperations__research_1_1fz_1_1Model.html">operations_research::fz::Model</a> *model, bool *ok, void *scanner)</p>
</dd>
<dd><p class="startdd"><a class="anchor" id="_todo000468"></a>(user): Check that the assignment is included in the domain. </p>
<p class="interdd"><a class="anchor" id="_todo000469"></a>(user): CHECK all values within domain. </p>
<p class="interdd"><a class="anchor" id="_todo000470"></a>(user): CHECK all values within domain. </p>
<p class="enddd"><a class="anchor" id="_todo000471"></a>(user): check that all assignments are included in the domain. </p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
