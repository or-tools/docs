<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::IntegerTrail Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.9</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1IntegerTrail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoperations__research_1_1sat_1_1IntegerTrail-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::IntegerTrail Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="integer_8h_source.html">integer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for operations_research::sat::IntegerTrail:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classoperations__research_1_1sat_1_1IntegerTrail.png" usemap="#operations_5Fresearch::sat::IntegerTrail_map" alt=""/>
  <map id="operations_5Fresearch::sat::IntegerTrail_map" name="operations_5Fresearch::sat::IntegerTrail_map">
<area href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints." alt="operations_research::sat::SatPropagator" shape="rect" coords="0,0,238,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6b2207a9fdf534839d89a6c44d02221f" id="r_a6b2207a9fdf534839d89a6c44d02221f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2207a9fdf534839d89a6c44d02221f">LazyReasonFunction</a></td></tr>
<tr class="separator:a6b2207a9fdf534839d89a6c44d02221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78066df21a20a46eff4bc4c8f9c8ed42" id="r_a78066df21a20a46eff4bc4c8f9c8ed42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78066df21a20a46eff4bc4c8f9c8ed42">IntegerTrail</a> (<a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *<a class="el" href="gurobi__interface_8cc.html#a0728f23c9a47655d38e0bf1a2f200bcf">model</a>)</td></tr>
<tr class="separator:a78066df21a20a46eff4bc4c8f9c8ed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acea0c0c0e8c14aa5bb4433d7fba05f" id="r_a7acea0c0c0e8c14aa5bb4433d7fba05f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acea0c0c0e8c14aa5bb4433d7fba05f">IntegerTrail</a> (const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;)=delete</td></tr>
<tr class="memdesc:a7acea0c0c0e8c14aa5bb4433d7fba05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is neither copyable nor movable.  <br /></td></tr>
<tr class="separator:a7acea0c0c0e8c14aa5bb4433d7fba05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16980d1e840f686778ee0d1d70f4d716" id="r_a16980d1e840f686778ee0d1d70f4d716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16980d1e840f686778ee0d1d70f4d716">operator=</a> (const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;)=delete</td></tr>
<tr class="separator:a16980d1e840f686778ee0d1d70f4d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9508c20a8a224902bf8bbc9f633976e8" id="r_a9508c20a8a224902bf8bbc9f633976e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9508c20a8a224902bf8bbc9f633976e8">~IntegerTrail</a> () final</td></tr>
<tr class="separator:a9508c20a8a224902bf8bbc9f633976e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ea8da78f7a6ec038887174bbad6ceb" id="r_ae3ea8da78f7a6ec038887174bbad6ceb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ea8da78f7a6ec038887174bbad6ceb">Propagate</a> (<a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> *trail) final</td></tr>
<tr class="separator:ae3ea8da78f7a6ec038887174bbad6ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46e312c99c8b0a71ae78459c6c456ac" id="r_ad46e312c99c8b0a71ae78459c6c456ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad46e312c99c8b0a71ae78459c6c456ac">Untrail</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, int literal_trail_index) final</td></tr>
<tr class="separator:ad46e312c99c8b0a71ae78459c6c456ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090881ffd3442b49e6e858dd6cc9f433" id="r_a090881ffd3442b49e6e858dd6cc9f433"><td class="memItemLeft" align="right" valign="top">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a090881ffd3442b49e6e858dd6cc9f433">Reason</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail, int trail_index) const final</td></tr>
<tr class="separator:a090881ffd3442b49e6e858dd6cc9f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce9339e32d63fa818656755fa51c373" id="r_a8ce9339e32d63fa818656755fa51c373"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce9339e32d63fa818656755fa51c373">NumIntegerVariables</a> () const</td></tr>
<tr class="separator:a8ce9339e32d63fa818656755fa51c373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae029cc33c5b2378c55eefad250b90e73" id="r_ae029cc33c5b2378c55eefad250b90e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae029cc33c5b2378c55eefad250b90e73">ReserveSpaceForNumVariables</a> (int num_vars)</td></tr>
<tr class="separator:ae029cc33c5b2378c55eefad250b90e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbb45a8a0ccb613694b2b739f904837" id="r_aebbb45a8a0ccb613694b2b739f904837"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebbb45a8a0ccb613694b2b739f904837">AddIntegerVariable</a> (IntegerValue <a class="el" href="gscip__solver_8cc.html#a1e2f9a2352c1d9a6cada9544898fceec">lower_bound</a>, IntegerValue <a class="el" href="gscip__solver_8cc.html#a1ba5ca0f61f2fa13bd23bf0f89004f35">upper_bound</a>)</td></tr>
<tr class="separator:aebbb45a8a0ccb613694b2b739f904837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0979a7027ada907ff46cf852eac66fa3" id="r_a0979a7027ada907ff46cf852eac66fa3"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0979a7027ada907ff46cf852eac66fa3">AddIntegerVariable</a> (const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;domain)</td></tr>
<tr class="separator:a0979a7027ada907ff46cf852eac66fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b90291347a80b54c35232033f35d4f" id="r_ac7b90291347a80b54c35232033f35d4f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7b90291347a80b54c35232033f35d4f">InitialVariableDomain</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:ac7b90291347a80b54c35232033f35d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dbd554c727e96c1ce6e33a54a73235" id="r_a86dbd554c727e96c1ce6e33a54a73235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86dbd554c727e96c1ce6e33a54a73235">UpdateInitialDomain</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>, <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> domain)</td></tr>
<tr class="separator:a86dbd554c727e96c1ce6e33a54a73235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56559b64fd022de467f5be44ec1d897" id="r_ae56559b64fd022de467f5be44ec1d897"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae56559b64fd022de467f5be44ec1d897">GetOrCreateConstantIntegerVariable</a> (IntegerValue <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:ae56559b64fd022de467f5be44ec1d897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff3feafd28f46006559ad6f5eebbf91" id="r_a1ff3feafd28f46006559ad6f5eebbf91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff3feafd28f46006559ad6f5eebbf91">NumConstantVariables</a> () const</td></tr>
<tr class="separator:a1ff3feafd28f46006559ad6f5eebbf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd05d19e276120cc061cd16151fba7d" id="r_a6bd05d19e276120cc061cd16151fba7d"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bd05d19e276120cc061cd16151fba7d">AddIntegerVariable</a> ()</td></tr>
<tr class="separator:a6bd05d19e276120cc061cd16151fba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2afe8b074760d54d767d2d73f60aea" id="r_a0b2afe8b074760d54d767d2d73f60aea"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b2afe8b074760d54d767d2d73f60aea">LowerBound</a> (IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="memdesc:a0b2afe8b074760d54d767d2d73f60aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current lower/upper bound of the given integer variable.  <br /></td></tr>
<tr class="separator:a0b2afe8b074760d54d767d2d73f60aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a11e8bd15eb96039315693963c28609" id="r_a4a11e8bd15eb96039315693963c28609"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a11e8bd15eb96039315693963c28609">UpperBound</a> (IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="separator:a4a11e8bd15eb96039315693963c28609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8992aea3b02b54b4cc9e3f0a0a957be8" id="r_a8992aea3b02b54b4cc9e3f0a0a957be8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8992aea3b02b54b4cc9e3f0a0a957be8">IsFixed</a> (IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="memdesc:a8992aea3b02b54b4cc9e3f0a0a957be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variable is fixed.  <br /></td></tr>
<tr class="separator:a8992aea3b02b54b4cc9e3f0a0a957be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57acc6d5dfd2c061fe3b06cab3a3c320" id="r_a57acc6d5dfd2c061fe3b06cab3a3c320"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57acc6d5dfd2c061fe3b06cab3a3c320">FixedValue</a> (IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="memdesc:a57acc6d5dfd2c061fe3b06cab3a3c320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the variable is fixed and returns its value.  <br /></td></tr>
<tr class="separator:a57acc6d5dfd2c061fe3b06cab3a3c320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1e43a55688b0002d08e82778295a47" id="r_acb1e43a55688b0002d08e82778295a47"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb1e43a55688b0002d08e82778295a47">LowerBound</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="memdesc:acb1e43a55688b0002d08e82778295a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above for an affine expression.  <br /></td></tr>
<tr class="separator:acb1e43a55688b0002d08e82778295a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28683ffcfe4f53e81be588b86aa51a5" id="r_ab28683ffcfe4f53e81be588b86aa51a5"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28683ffcfe4f53e81be588b86aa51a5">UpperBound</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="separator:ab28683ffcfe4f53e81be588b86aa51a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884cca348e1b3063a012c1f362e38591" id="r_a884cca348e1b3063a012c1f362e38591"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a884cca348e1b3063a012c1f362e38591">IsFixed</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="separator:a884cca348e1b3063a012c1f362e38591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d8a915592e980145cb623fc1a417d3" id="r_a22d8a915592e980145cb623fc1a417d3"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d8a915592e980145cb623fc1a417d3">FixedValue</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="separator:a22d8a915592e980145cb623fc1a417d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7d94f60772f7fa56fb85bdcdad2ce0" id="r_a5e7d94f60772f7fa56fb85bdcdad2ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e7d94f60772f7fa56fb85bdcdad2ce0">LowerBoundAsLiteral</a> (IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="separator:a5e7d94f60772f7fa56fb85bdcdad2ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b23637b887286282df5a02cbae3db0f" id="r_a3b23637b887286282df5a02cbae3db0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b23637b887286282df5a02cbae3db0f">UpperBoundAsLiteral</a> (IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="separator:a3b23637b887286282df5a02cbae3db0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32873f018d4520f331a392d96506c720" id="r_a32873f018d4520f331a392d96506c720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32873f018d4520f331a392d96506c720">LowerBoundAsLiteral</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="separator:a32873f018d4520f331a392d96506c720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b52c18d302bea4fcce8f77f1d07f153" id="r_a0b52c18d302bea4fcce8f77f1d07f153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b52c18d302bea4fcce8f77f1d07f153">UpperBoundAsLiteral</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="separator:a0b52c18d302bea4fcce8f77f1d07f153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4599342f2a8902e9d86ccb386e7dbfb9" id="r_a4599342f2a8902e9d86ccb386e7dbfb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4599342f2a8902e9d86ccb386e7dbfb9">IntegerLiteralIsTrue</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> l) const</td></tr>
<tr class="memdesc:a4599342f2a8902e9d86ccb386e7dbfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value (if known) of an <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>.  <br /></td></tr>
<tr class="separator:a4599342f2a8902e9d86ccb386e7dbfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1e5c8cb577505b2e62061395b95e4b" id="r_a5e1e5c8cb577505b2e62061395b95e4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e1e5c8cb577505b2e62061395b95e4b">IntegerLiteralIsFalse</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> l) const</td></tr>
<tr class="separator:a5e1e5c8cb577505b2e62061395b95e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3738bb49556079e3f031e4f9abff18d" id="r_ad3738bb49556079e3f031e4f9abff18d"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3738bb49556079e3f031e4f9abff18d">LevelZeroLowerBound</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="memdesc:ad3738bb49556079e3f031e4f9abff18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns globally valid lower/upper bound on the given integer variable.  <br /></td></tr>
<tr class="separator:ad3738bb49556079e3f031e4f9abff18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7324f4682ebd510a35917832db076" id="r_ab8c7324f4682ebd510a35917832db076"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c7324f4682ebd510a35917832db076">LevelZeroUpperBound</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:ab8c7324f4682ebd510a35917832db076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa325f29140f8674328aa62599b38dddb" id="r_aa325f29140f8674328aa62599b38dddb"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa325f29140f8674328aa62599b38dddb">LevelZeroLowerBound</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> exp) const</td></tr>
<tr class="memdesc:aa325f29140f8674328aa62599b38dddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns globally valid lower/upper bound on the given affine expression.  <br /></td></tr>
<tr class="separator:aa325f29140f8674328aa62599b38dddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba132505b7638ffe247d0a7a495b0d1" id="r_acba132505b7638ffe247d0a7a495b0d1"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba132505b7638ffe247d0a7a495b0d1">LevelZeroUpperBound</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> exp) const</td></tr>
<tr class="separator:acba132505b7638ffe247d0a7a495b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b314b421ea132fee84f4afcd244f987" id="r_a3b314b421ea132fee84f4afcd244f987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b314b421ea132fee84f4afcd244f987">IsFixedAtLevelZero</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="memdesc:a3b314b421ea132fee84f4afcd244f987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the variable is fixed at level 0.  <br /></td></tr>
<tr class="separator:a3b314b421ea132fee84f4afcd244f987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96414f2789e8f83f0df830b5c6b55b47" id="r_a96414f2789e8f83f0df830b5c6b55b47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96414f2789e8f83f0df830b5c6b55b47">IsFixedAtLevelZero</a> (<a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="memdesc:a96414f2789e8f83f0df830b5c6b55b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the affine expression is fixed at level 0.  <br /></td></tr>
<tr class="separator:a96414f2789e8f83f0df830b5c6b55b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f437eb0dbb5af48d9e21983d69e3db8" id="r_a8f437eb0dbb5af48d9e21983d69e3db8"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f437eb0dbb5af48d9e21983d69e3db8">ConditionalLowerBound</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l, IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="separator:a8f437eb0dbb5af48d9e21983d69e3db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66382da2a09be1293d5232bdfbc9cf21" id="r_a66382da2a09be1293d5232bdfbc9cf21"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66382da2a09be1293d5232bdfbc9cf21">ConditionalLowerBound</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="separator:a66382da2a09be1293d5232bdfbc9cf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e2ec2502be35c12ac3f31f87330e5b" id="r_a96e2ec2502be35c12ac3f31f87330e5b"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96e2ec2502be35c12ac3f31f87330e5b">ConditionalUpperBound</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l, IntegerVariable <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="memdesc:a96e2ec2502be35c12ac3f31f87330e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current upper bound assuming the literal is true.  <br /></td></tr>
<tr class="separator:a96e2ec2502be35c12ac3f31f87330e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b6c7522936396b71b49a11bfe7375e" id="r_ae6b6c7522936396b71b49a11bfe7375e"><td class="memItemLeft" align="right" valign="top">IntegerValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b6c7522936396b71b49a11bfe7375e">ConditionalUpperBound</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> l, <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> expr) const</td></tr>
<tr class="separator:ae6b6c7522936396b71b49a11bfe7375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f82268fd6c91332511a3d8765d6d07f" id="r_a3f82268fd6c91332511a3d8765d6d07f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f82268fd6c91332511a3d8765d6d07f">RelaxLinearReason</a> (IntegerValue slack, absl::Span&lt; const IntegerValue &gt; coeffs, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *reason) const</td></tr>
<tr class="separator:a3f82268fd6c91332511a3d8765d6d07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7989e54ca025aeeea341d59e30cd8f60" id="r_a7989e54ca025aeeea341d59e30cd8f60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7989e54ca025aeeea341d59e30cd8f60">AppendRelaxedLinearReason</a> (IntegerValue slack, absl::Span&lt; const IntegerValue &gt; coeffs, absl::Span&lt; const IntegerVariable &gt; vars, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *reason) const</td></tr>
<tr class="memdesc:a7989e54ca025aeeea341d59e30cd8f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but take in IntegerVariables instead of IntegerLiterals.  <br /></td></tr>
<tr class="separator:a7989e54ca025aeeea341d59e30cd8f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9710320ee9ff075b750bcb7da22664" id="r_a1b9710320ee9ff075b750bcb7da22664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b9710320ee9ff075b750bcb7da22664">RelaxLinearReason</a> (IntegerValue slack, absl::Span&lt; const IntegerValue &gt; coeffs, std::vector&lt; int &gt; *trail_indices) const</td></tr>
<tr class="memdesc:a1b9710320ee9ff075b750bcb7da22664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but relax the given trail indices.  <br /></td></tr>
<tr class="separator:a1b9710320ee9ff075b750bcb7da22664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ad14c32577dee8a53863b58ca4598c" id="r_a11ad14c32577dee8a53863b58ca4598c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11ad14c32577dee8a53863b58ca4598c">RemoveLevelZeroBounds</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *reason) const</td></tr>
<tr class="separator:a11ad14c32577dee8a53863b58ca4598c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f3f24dfc832d45939478360f2a9ef1" id="r_aa5f3f24dfc832d45939478360f2a9ef1"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literal_reason, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integer_reason)</td></tr>
<tr class="separator:aa5f3f24dfc832d45939478360f2a9ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2153942f118e9639ca52903d781b26" id="r_a3f2153942f118e9639ca52903d781b26"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f2153942f118e9639ca52903d781b26">SafeEnqueue</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integer_reason)</td></tr>
<tr class="separator:a3f2153942f118e9639ca52903d781b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f3c5bf9ad7390cb25efb3f6a0de3b3" id="r_a07f3c5bf9ad7390cb25efb3f6a0de3b3"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07f3c5bf9ad7390cb25efb3f6a0de3b3">ConditionalEnqueue</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="linear__model_8cc.html#a2c015641fdf48f9e1627e4607b49195c">lit</a>, <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *literal_reason, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *integer_reason)</td></tr>
<tr class="separator:a07f3c5bf9ad7390cb25efb3f6a0de3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d98735536061f5c38f91ddd6a0b073" id="r_ae5d98735536061f5c38f91ddd6a0b073"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5d98735536061f5c38f91ddd6a0b073">Enqueue</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literal_reason, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integer_reason, int trail_index_with_same_reason)</td></tr>
<tr class="separator:ae5d98735536061f5c38f91ddd6a0b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927b756797dfabbf96039477004166e9" id="r_a927b756797dfabbf96039477004166e9"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a927b756797dfabbf96039477004166e9">Enqueue</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit, <a class="el" href="#a6b2207a9fdf534839d89a6c44d02221f">LazyReasonFunction</a> lazy_reason)</td></tr>
<tr class="separator:a927b756797dfabbf96039477004166e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40e3a18d801827c17fc32f1214d6d31" id="r_ab40e3a18d801827c17fc32f1214d6d31"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab40e3a18d801827c17fc32f1214d6d31">RootLevelEnqueue</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> i_lit)</td></tr>
<tr class="separator:ab40e3a18d801827c17fc32f1214d6d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cfaa9b1848cc1edbdb5c50e7d42188" id="r_ac2cfaa9b1848cc1edbdb5c50e7d42188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2cfaa9b1848cc1edbdb5c50e7d42188">EnqueueLiteral</a> (<a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> <a class="el" href="linear__model_8cc.html#a6582b538eeea909324f67bfaac0e0958">literal</a>, absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literal_reason, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integer_reason)</td></tr>
<tr class="separator:ac2cfaa9b1848cc1edbdb5c50e7d42188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ff017ebe16e1bdeb3b3195d4a889d" id="r_ae61ff017ebe16e1bdeb3b3195d4a889d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61ff017ebe16e1bdeb3b3195d4a889d">ReasonFor</a> (<a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> <a class="el" href="linear__model_8cc.html#a6582b538eeea909324f67bfaac0e0958">literal</a>) const</td></tr>
<tr class="separator:ae61ff017ebe16e1bdeb3b3195d4a889d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fb45f018e2314a5d367335536e503c" id="r_ac1fb45f018e2314a5d367335536e503c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1fb45f018e2314a5d367335536e503c">MergeReasonInto</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; literals, std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *output) const</td></tr>
<tr class="separator:ac1fb45f018e2314a5d367335536e503c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2270b728687bb84a6940473a2470a5f9" id="r_a2270b728687bb84a6940473a2470a5f9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2270b728687bb84a6940473a2470a5f9">num_enqueues</a> () const</td></tr>
<tr class="separator:a2270b728687bb84a6940473a2470a5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb8119d2cd0700aba64cb957c72dd2" id="r_a76bb8119d2cd0700aba64cb957c72dd2"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76bb8119d2cd0700aba64cb957c72dd2">timestamp</a> () const</td></tr>
<tr class="separator:a76bb8119d2cd0700aba64cb957c72dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae355fe55d1dbb006cac7cf8260d97b0" id="r_aae355fe55d1dbb006cac7cf8260d97b0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae355fe55d1dbb006cac7cf8260d97b0">num_level_zero_enqueues</a> () const</td></tr>
<tr class="memdesc:aae355fe55d1dbb006cac7cf8260d97b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as num_enqueues but only count the level zero changes.  <br /></td></tr>
<tr class="separator:aae355fe55d1dbb006cac7cf8260d97b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d6ed54b4b6fe9a9b104dd5f92f4f95" id="r_a38d6ed54b4b6fe9a9b104dd5f92f4f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d6ed54b4b6fe9a9b104dd5f92f4f95">RegisterWatcher</a> (<a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt; IntegerVariable &gt; *p)</td></tr>
<tr class="separator:a38d6ed54b4b6fe9a9b104dd5f92f4f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703b4b6b6c812f4e5a6dff0315657d08" id="r_a703b4b6b6c812f4e5a6dff0315657d08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a703b4b6b6c812f4e5a6dff0315657d08">ReportConflict</a> (absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; literal_reason, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integer_reason)</td></tr>
<tr class="separator:a703b4b6b6c812f4e5a6dff0315657d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e20213d10155e1ddc4a69a221d0c3a2" id="r_a7e20213d10155e1ddc4a69a221d0c3a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e20213d10155e1ddc4a69a221d0c3a2">ReportConflict</a> (absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integer_reason)</td></tr>
<tr class="separator:a7e20213d10155e1ddc4a69a221d0c3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bf7830edb81a77ca4ff8bdfd5bf940" id="r_a14bf7830edb81a77ca4ff8bdfd5bf940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14bf7830edb81a77ca4ff8bdfd5bf940">VariableLowerBoundIsFromLevelZero</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="memdesc:a14bf7830edb81a77ca4ff8bdfd5bf940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the variable lower bound is still the one from level zero.  <br /></td></tr>
<tr class="separator:a14bf7830edb81a77ca4ff8bdfd5bf940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed031e413d60e94e731421366337eff" id="r_a6ed031e413d60e94e731421366337eff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ed031e413d60e94e731421366337eff">RegisterReversibleClass</a> (<a class="el" href="classoperations__research_1_1ReversibleInterface.html">ReversibleInterface</a> *rev)</td></tr>
<tr class="separator:a6ed031e413d60e94e731421366337eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09afe7249372985fcb81aadc1317cc65" id="r_a09afe7249372985fcb81aadc1317cc65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09afe7249372985fcb81aadc1317cc65">Index</a> () const</td></tr>
<tr class="separator:a09afe7249372985fcb81aadc1317cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838d2c31760b5b9f554ea080ad6cb74a" id="r_a838d2c31760b5b9f554ea080ad6cb74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838d2c31760b5b9f554ea080ad6cb74a">AppendNewBounds</a> (std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *output) const</td></tr>
<tr class="separator:a838d2c31760b5b9f554ea080ad6cb74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528e39b17cbbdccc58f61b4db9fd4141" id="r_a528e39b17cbbdccc58f61b4db9fd4141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a528e39b17cbbdccc58f61b4db9fd4141">AppendNewBoundsFrom</a> (int base_index, std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *output) const</td></tr>
<tr class="separator:a528e39b17cbbdccc58f61b4db9fd4141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1418937c67404cb3fb4b9b73c1198593" id="r_a1418937c67404cb3fb4b9b73c1198593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1418937c67404cb3fb4b9b73c1198593">FindTrailIndexOfVarBefore</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>, int threshold) const</td></tr>
<tr class="separator:a1418937c67404cb3fb4b9b73c1198593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84095a48055d452c73c88fa757eaea43" id="r_a84095a48055d452c73c88fa757eaea43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84095a48055d452c73c88fa757eaea43">InPropagationLoop</a> () const</td></tr>
<tr class="separator:a84095a48055d452c73c88fa757eaea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049cddb7be16d2b9eb09a838558131ea" id="r_a049cddb7be16d2b9eb09a838558131ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a049cddb7be16d2b9eb09a838558131ea">NotifyThatPropagationWasAborted</a> ()</td></tr>
<tr class="separator:a049cddb7be16d2b9eb09a838558131ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aef13eb728ffde07b8f7aa50e55aed" id="r_a94aef13eb728ffde07b8f7aa50e55aed"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94aef13eb728ffde07b8f7aa50e55aed">NextVariableToBranchOnInPropagationLoop</a> () const</td></tr>
<tr class="separator:a94aef13eb728ffde07b8f7aa50e55aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f1de43bcab881e1834b5ea598ae143" id="r_ae7f1de43bcab881e1834b5ea598ae143"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7f1de43bcab881e1834b5ea598ae143">CurrentBranchHadAnIncompletePropagation</a> ()</td></tr>
<tr class="separator:ae7f1de43bcab881e1834b5ea598ae143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad945b25fb07d230d8932c92420ecb8" id="r_adad945b25fb07d230d8932c92420ecb8"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adad945b25fb07d230d8932c92420ecb8">FirstUnassignedVariable</a> () const</td></tr>
<tr class="separator:adad945b25fb07d230d8932c92420ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6312d9245c7a7333676c423412910d05" id="r_a6312d9245c7a7333676c423412910d05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6312d9245c7a7333676c423412910d05">HasPendingRootLevelDeduction</a> () const</td></tr>
<tr class="memdesc:a6312d9245c7a7333676c423412910d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can fix new fact at level zero.  <br /></td></tr>
<tr class="separator:a6312d9245c7a7333676c423412910d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bdc70211090f52a8ad50526cf060fe" id="r_aa0bdc70211090f52a8ad50526cf060fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0bdc70211090f52a8ad50526cf060fe">RegisterDebugChecker</a> (std::function&lt; bool(absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; clause, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integers)&gt; checker)</td></tr>
<tr class="separator:aa0bdc70211090f52a8ad50526cf060fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classoperations__research_1_1sat_1_1SatPropagator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">operations_research::sat::SatPropagator</a></td></tr>
<tr class="memitem:a338bfb8cc78f5ac5dd1f69d87a4f57f3 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_a338bfb8cc78f5ac5dd1f69d87a4f57f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a338bfb8cc78f5ac5dd1f69d87a4f57f3">SatPropagator</a> (const std::string &amp;<a class="el" href="default__search_8cc.html#ac673bc430bdc3fdaa09f7becf98ef267">name</a>)</td></tr>
<tr class="separator:a338bfb8cc78f5ac5dd1f69d87a4f57f3 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef45a5f6716cda23320e8f6e738aa950 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_aef45a5f6716cda23320e8f6e738aa950"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#aef45a5f6716cda23320e8f6e738aa950">SatPropagator</a> (const <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> &amp;)=delete</td></tr>
<tr class="memdesc:aef45a5f6716cda23320e8f6e738aa950 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is neither copyable nor movable.  <br /></td></tr>
<tr class="separator:aef45a5f6716cda23320e8f6e738aa950 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7d7f0ab73e800e6119c225408795d8 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_afb7d7f0ab73e800e6119c225408795d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#afb7d7f0ab73e800e6119c225408795d8">operator=</a> (const <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">SatPropagator</a> &amp;)=delete</td></tr>
<tr class="separator:afb7d7f0ab73e800e6119c225408795d8 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1840f1dece6d0b89fa5fe9340660c0 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_afc1840f1dece6d0b89fa5fe9340660c0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#afc1840f1dece6d0b89fa5fe9340660c0">~SatPropagator</a> ()=default</td></tr>
<tr class="separator:afc1840f1dece6d0b89fa5fe9340660c0 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5876a992300dcbcf936d11d9b9dd0512 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_a5876a992300dcbcf936d11d9b9dd0512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a5876a992300dcbcf936d11d9b9dd0512">SetPropagatorId</a> (int id)</td></tr>
<tr class="memdesc:a5876a992300dcbcf936d11d9b9dd0512 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets/Gets this propagator unique id.  <br /></td></tr>
<tr class="separator:a5876a992300dcbcf936d11d9b9dd0512 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5afb5d4be1ac4f9c4f0758fb8dc40d inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_a2e5afb5d4be1ac4f9c4f0758fb8dc40d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a2e5afb5d4be1ac4f9c4f0758fb8dc40d">PropagatorId</a> () const</td></tr>
<tr class="separator:a2e5afb5d4be1ac4f9c4f0758fb8dc40d inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bde4f8c3d7c6326050ac164391bf2a7 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_a2bde4f8c3d7c6326050ac164391bf2a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a2bde4f8c3d7c6326050ac164391bf2a7">PropagatePreconditionsAreSatisfied</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail) const</td></tr>
<tr class="separator:a2bde4f8c3d7c6326050ac164391bf2a7 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c40cad4e160b493cb16c9f4373275e inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_ad1c40cad4e160b493cb16c9f4373275e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#ad1c40cad4e160b493cb16c9f4373275e">PropagationIsDone</a> (const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;trail) const</td></tr>
<tr class="memdesc:ad1c40cad4e160b493cb16c9f4373275e inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff all the trail was inspected by this propagator.  <br /></td></tr>
<tr class="separator:ad1c40cad4e160b493cb16c9f4373275e inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab639102372f03758b18523b613ae69e1 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator" id="r_ab639102372f03758b18523b613ae69e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#ab639102372f03758b18523b613ae69e1">IsEmpty</a> () const</td></tr>
<tr class="separator:ab639102372f03758b18523b613ae69e1 inherit pub_methods_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classoperations__research_1_1sat_1_1SatPropagator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html">operations_research::sat::SatPropagator</a></td></tr>
<tr class="memitem:a5edc374f55007ef72a87fd7516bad764 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator" id="r_a5edc374f55007ef72a87fd7516bad764"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a5edc374f55007ef72a87fd7516bad764">name_</a></td></tr>
<tr class="separator:a5edc374f55007ef72a87fd7516bad764 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6484a3ad51a1f74b403fc21c47055601 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator" id="r_a6484a3ad51a1f74b403fc21c47055601"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a6484a3ad51a1f74b403fc21c47055601">propagator_id_</a></td></tr>
<tr class="separator:a6484a3ad51a1f74b403fc21c47055601 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5714ef513aadb9a616a215de533b9eb4 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator" id="r_a5714ef513aadb9a616a215de533b9eb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a5714ef513aadb9a616a215de533b9eb4">propagation_trail_index_</a></td></tr>
<tr class="separator:a5714ef513aadb9a616a215de533b9eb4 inherit pro_attribs_classoperations__research_1_1sat_1_1SatPropagator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class maintains a set of integer variables with their current bounds. Bounds can be propagated from an external "source" and this class helps to maintain the reason for each propagation. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00751">751</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6b2207a9fdf534839d89a6c44d02221f" name="a6b2207a9fdf534839d89a6c44d02221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2207a9fdf534839d89a6c44d02221f">&#9670;&#160;</a></span>LazyReasonFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6b2207a9fdf534839d89a6c44d02221f">operations_research::sat::IntegerTrail::LazyReasonFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;void(</div>
<div class="line">      IntegerLiteral literal_to_explain, <span class="keywordtype">int</span> trail_index_of_literal,</div>
<div class="line">      std::vector&lt;Literal&gt;* literals, std::vector&lt;int&gt;* dependencies)&gt;</div>
</div><!-- fragment --><p>Lazy reason API.</p>
<p>The function is provided with the <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> to explain and its index in the integer trail. It must fill the two vectors so that literals contains any <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> part of the reason and dependencies contains the trail index of any <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> that is also part of the reason.</p>
<p>Remark: sometimes this is called to fill the conflict while the literal to explain is propagated. In this case, trail_index_of_literal will be the current trail index, and we cannot assume that there is anything filled yet in integer_literal[trail_index_of_literal]. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00993">993</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a78066df21a20a46eff4bc4c8f9c8ed42" name="a78066df21a20a46eff4bc4c8f9c8ed42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78066df21a20a46eff4bc4c8f9c8ed42">&#9670;&#160;</a></span>IntegerTrail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerTrail::IntegerTrail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00753">753</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a7acea0c0c0e8c14aa5bb4433d7fba05f" name="a7acea0c0c0e8c14aa5bb4433d7fba05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acea0c0c0e8c14aa5bb4433d7fba05f">&#9670;&#160;</a></span>IntegerTrail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerTrail::IntegerTrail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type is neither copyable nor movable. </p>

</div>
</div>
<a id="a9508c20a8a224902bf8bbc9f633976e8" name="a9508c20a8a224902bf8bbc9f633976e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9508c20a8a224902bf8bbc9f633976e8">&#9670;&#160;</a></span>~IntegerTrail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::sat::IntegerTrail::~IntegerTrail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00689">689</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6bd05d19e276120cc061cd16151fba7d" name="a6bd05d19e276120cc061cd16151fba7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd05d19e276120cc061cd16151fba7d">&#9670;&#160;</a></span>AddIntegerVariable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerTrail::AddIntegerVariable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a6bd05d19e276120cc061cd16151fba7d">AddIntegerVariable()</a> but uses the maximum possible range. Note that since we take negation of bounds in various places, we make sure that we don't have overflow when we take the negation of the lower bound or of the upper bound. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00830">830</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a0979a7027ada907ff46cf852eac66fa3" name="a0979a7027ada907ff46cf852eac66fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0979a7027ada907ff46cf852eac66fa3">&#9670;&#160;</a></span>AddIntegerVariable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerTrail::AddIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for a more complex domain specified as a sorted list of disjoint intervals. See the <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> class. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00848">848</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="aebbb45a8a0ccb613694b2b739f904837" name="aebbb45a8a0ccb613694b2b739f904837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbb45a8a0ccb613694b2b739f904837">&#9670;&#160;</a></span>AddIntegerVariable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerTrail::AddIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new integer variable. Adding integer variable can only be done when the decision level is zero (checked). The given bounds are INCLUSIVE and must not cross.</p>
<p>Note on integer overflow: 'upper_bound - lower_bound' must fit on an int64_t, this is DCHECKed. More generally, depending on the constraints that are added, the bounds magnitude must be small enough to satisfy each constraint overflow precondition. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00820">820</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a838d2c31760b5b9f554ea080ad6cb74a" name="a838d2c31760b5b9f554ea080ad6cb74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838d2c31760b5b9f554ea080ad6cb74a">&#9670;&#160;</a></span>AppendNewBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::AppendNewBounds </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>output</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inspects the trail and output all the non-level zero bounds (one per variables) to the output. The algo is sparse if there is only a few propagations on the trail. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l02002">2002</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a528e39b17cbbdccc58f61b4db9fd4141" name="a528e39b17cbbdccc58f61b4db9fd4141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528e39b17cbbdccc58f61b4db9fd4141">&#9670;&#160;</a></span>AppendNewBoundsFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::AppendNewBoundsFrom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base_index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inspects the trail and output all the non-level zero bounds from the base index (one per variables) to the output. The algo is sparse if there is only a few propagations on the trail.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001675">Todo</a></b></dt><dd>(user): Implement a dense version if there is more trail entries than variables! </dd></dl>
<p>In order to push the best bound for each variable, we loop backward.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l02008">2008</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a7989e54ca025aeeea341d59e30cd8f60" name="a7989e54ca025aeeea341d59e30cd8f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7989e54ca025aeeea341d59e30cd8f60">&#9670;&#160;</a></span>AppendRelaxedLinearReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::AppendRelaxedLinearReason </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>slack</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerVariable &gt;</td>          <td class="paramname"><span class="paramname"><em>vars</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>reason</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above but take in IntegerVariables instead of IntegerLiterals. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01018">1018</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a07f3c5bf9ad7390cb25efb3f6a0de3b3" name="a07f3c5bf9ad7390cb25efb3f6a0de3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f3c5bf9ad7390cb25efb3f6a0de3b3">&#9670;&#160;</a></span>ConditionalEnqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::ConditionalEnqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>lit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>literal_reason</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>integer_reason</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes the given integer literal assuming that the Boolean literal is true. This can do a few things:</p><ul>
<li>If lit it true, add it to the reason and push the integer bound.</li>
<li>If the bound is infeasible, push lit to false.</li>
<li>If the underlying variable is optional and also controlled by lit, push the bound even if lit is not assigned. </li>
</ul>
<p>We can't push anything in this case.</p>
<p>We record it for this propagation phase (until the next untrail) as this is relatively fast and heuristics can exploit this.</p>
<dl class="section note"><dt>Note</dt><dd>currently we only use <a class="el" href="#a07f3c5bf9ad7390cb25efb3f6a0de3b3">ConditionalEnqueue()</a> in scheduling propagator, and these propagator are quite slow so this is not visible.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001667">Todo</a></b></dt><dd>(user): We could even keep the reason and maybe do some reasoning using at_least_one constraint on a set of the Boolean used here. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01247">1247</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a66382da2a09be1293d5232bdfbc9cf21" name="a66382da2a09be1293d5232bdfbc9cf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66382da2a09be1293d5232bdfbc9cf21">&#9670;&#160;</a></span>ConditionalLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::ConditionalLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01643">1643</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a8f437eb0dbb5af48d9e21983d69e3db8" name="a8f437eb0dbb5af48d9e21983d69e3db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f437eb0dbb5af48d9e21983d69e3db8">&#9670;&#160;</a></span>ConditionalLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::ConditionalLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advanced usage. Returns the current lower bound assuming the literal is true. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01634">1634</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ae6b6c7522936396b71b49a11bfe7375e" name="ae6b6c7522936396b71b49a11bfe7375e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b6c7522936396b71b49a11bfe7375e">&#9670;&#160;</a></span>ConditionalUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::ConditionalUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01654">1654</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a96e2ec2502be35c12ac3f31f87330e5b" name="a96e2ec2502be35c12ac3f31f87330e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e2ec2502be35c12ac3f31f87330e5b">&#9670;&#160;</a></span>ConditionalUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::ConditionalUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current upper bound assuming the literal is true. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01649">1649</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ae7f1de43bcab881e1834b5ea598ae143" name="ae7f1de43bcab881e1834b5ea598ae143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f1de43bcab881e1834b5ea598ae143">&#9670;&#160;</a></span>CurrentBranchHadAnIncompletePropagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::CurrentBranchHadAnIncompletePropagation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we had an incomplete propagation, it is important to fix all the variables and not really on the propagation to do so. This is related to the <a class="el" href="#a84095a48055d452c73c88fa757eaea43">InPropagationLoop()</a> code above. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01490">1490</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="aa5f3f24dfc832d45939478360f2a9ef1" name="aa5f3f24dfc832d45939478360f2a9ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f3f24dfc832d45939478360f2a9ef1">&#9670;&#160;</a></span>Enqueue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::Enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literal_reason</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integer_reason</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue new information about a variable bound. Calling this with a less restrictive bound than the current one will have no effect.</p>
<p>The reason for this "assignment" must be provided as:</p><ul>
<li>A set of <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> currently being all false.</li>
<li>A set of <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> currently being all true.</li>
</ul>
<p>IMPORTANT: Notice the inversed sign in the literal reason. This is a bit confusing but internally SAT use this direction for efficiency.</p>
<p>Note(user): Duplicates Literal/IntegerLiteral are supported because we call STLSortAndRemoveDuplicates() in <a class="el" href="#ac1fb45f018e2314a5d367335536e503c">MergeReasonInto()</a>, but maybe they shouldn't for efficiency reason.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001696">Todo</a></b></dt><dd>(user): If the given bound is equal to the current bound, maybe the new reason is better? how to decide and what to do in this case? to think about it. Currently we simply don't do anything. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01240">1240</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ae5d98735536061f5c38f91ddd6a0b073" name="ae5d98735536061f5c38f91ddd6a0b073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d98735536061f5c38f91ddd6a0b073">&#9670;&#160;</a></span>Enqueue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::Enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literal_reason</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integer_reason</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>trail_index_with_same_reason</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a>, but takes an extra argument which if smaller than integer_trail_.size() is interpreted as the trail index of an old <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a> that had the same reason as this one. Note that the given Span must still be valid as they are used in case of conflict.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001697">Todo</a></b></dt><dd>(user): This currently cannot refer to a trail_index with a lazy reason. Fix or at least check that this is the case. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01284">1284</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a927b756797dfabbf96039477004166e9" name="a927b756797dfabbf96039477004166e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927b756797dfabbf96039477004166e9">&#9670;&#160;</a></span>Enqueue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::Enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6b2207a9fdf534839d89a6c44d02221f">LazyReasonFunction</a></td>          <td class="paramname"><span class="paramname"><em>lazy_reason</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01292">1292</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ac2cfaa9b1848cc1edbdb5c50e7d42188" name="ac2cfaa9b1848cc1edbdb5c50e7d42188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cfaa9b1848cc1edbdb5c50e7d42188">&#9670;&#160;</a></span>EnqueueLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::EnqueueLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a></td>          <td class="paramname"><span class="paramname"><em>literal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literal_reason</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integer_reason</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueues the given literal on the trail. See the comment of <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a> for the reason format. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01383">1383</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a1418937c67404cb3fb4b9b73c1198593" name="a1418937c67404cb3fb4b9b73c1198593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1418937c67404cb3fb4b9b73c1198593">&#9670;&#160;</a></span>FindTrailIndexOfVarBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::IntegerTrail::FindTrailIndexOfVarBefore </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the trail index &lt; threshold of a TrailEntry about var. Returns -1 if there is no such entry (at a positive decision level). This is basically the trail index of the lower bound of var at the time.</p>
<p>Important: We do some optimization internally, so this should only be used from within a <a class="el" href="#a6b2207a9fdf534839d89a6c44d02221f">LazyReasonFunction()</a>. </p>
<p>Optimization. We assume this is only called when computing a reason, so we can ignore this trail_index if we already need a more restrictive reason for this var.</p>
<p>Check the validity of the cached index and use it if possible.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00926">926</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="adad945b25fb07d230d8932c92420ecb8" name="adad945b25fb07d230d8932c92420ecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad945b25fb07d230d8932c92420ecb8">&#9670;&#160;</a></span>FirstUnassignedVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerTrail::FirstUnassignedVariable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01494">1494</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a22d8a915592e980145cb623fc1a417d3" name="a22d8a915592e980145cb623fc1a417d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d8a915592e980145cb623fc1a417d3">&#9670;&#160;</a></span>FixedValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::FixedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01685">1685</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a57acc6d5dfd2c061fe3b06cab3a3c320" name="a57acc6d5dfd2c061fe3b06cab3a3c320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57acc6d5dfd2c061fe3b06cab3a3c320">&#9670;&#160;</a></span>FixedValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::FixedValue </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the variable is fixed and returns its value. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01629">1629</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ae56559b64fd022de467f5be44ec1d897" name="ae56559b64fd022de467f5be44ec1d897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56559b64fd022de467f5be44ec1d897">&#9670;&#160;</a></span>GetOrCreateConstantIntegerVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerTrail::GetOrCreateConstantIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as AddIntegerVariable(value, value), but this is a bit more efficient because it reuses another constant with the same value if its exist.</p>
<p>Note(user): Creating constant integer variable is a bit wasteful, but not that much, and it allows to simplify a lot of constraints that do not need to handle this case any differently than the general one. Maybe there is a better solution, but this is not really high priority as of December 2016. </p>
<dl class="section note"><dt>Note</dt><dd>this might invalidate insert.first-&gt;second.</dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00905">905</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a6312d9245c7a7333676c423412910d05" name="a6312d9245c7a7333676c423412910d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6312d9245c7a7333676c423412910d05">&#9670;&#160;</a></span>HasPendingRootLevelDeduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::HasPendingRootLevelDeduction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if we can fix new fact at level zero. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01107">1107</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a09afe7249372985fcb81aadc1317cc65" name="a09afe7249372985fcb81aadc1317cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09afe7249372985fcb81aadc1317cc65">&#9670;&#160;</a></span>Index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::IntegerTrail::Index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01073">1073</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ac7b90291347a80b54c35232033f35d4f" name="ac7b90291347a80b54c35232033f35d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b90291347a80b54c35232033f35d4f">&#9670;&#160;</a></span>InitialVariableDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1Domain.html">Domain</a> &amp; operations_research::sat::IntegerTrail::InitialVariableDomain </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the initial domain of the given variable. Note that the min/max are updated with level zero propagation, but not holes. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00856">856</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a84095a48055d452c73c88fa757eaea43" name="a84095a48055d452c73c88fa757eaea43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84095a48055d452c73c88fa757eaea43">&#9670;&#160;</a></span>InPropagationLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::InPropagationLoop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basic heuristic to detect when we are in a propagation loop, and suggest a good variable to branch on (taking the middle value) to get out of it.</p>
<p>We count the number of propagation at the current level, and returns true if it seems really large. Note that we disable this if we are in fixed search. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01443">1443</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a5e1e5c8cb577505b2e62061395b95e4b" name="a5e1e5c8cb577505b2e62061395b95e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1e5c8cb577505b2e62061395b95e4b">&#9670;&#160;</a></span>IntegerLiteralIsFalse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::IntegerLiteralIsFalse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01706">1706</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a4599342f2a8902e9d86ccb386e7dbfb9" name="a4599342f2a8902e9d86ccb386e7dbfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4599342f2a8902e9d86ccb386e7dbfb9">&#9670;&#160;</a></span>IntegerLiteralIsTrue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::IntegerLiteralIsTrue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value (if known) of an <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a>. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01702">1702</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a884cca348e1b3063a012c1f362e38591" name="a884cca348e1b3063a012c1f362e38591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884cca348e1b3063a012c1f362e38591">&#9670;&#160;</a></span>IsFixed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::IsFixed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01680">1680</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a8992aea3b02b54b4cc9e3f0a0a957be8" name="a8992aea3b02b54b4cc9e3f0a0a957be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8992aea3b02b54b4cc9e3f0a0a957be8">&#9670;&#160;</a></span>IsFixed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::IsFixed </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variable is fixed. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01625">1625</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a96414f2789e8f83f0df830b5c6b55b47" name="a96414f2789e8f83f0df830b5c6b55b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96414f2789e8f83f0df830b5c6b55b47">&#9670;&#160;</a></span>IsFixedAtLevelZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::IsFixedAtLevelZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the affine expression is fixed at level 0. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01739">1739</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a3b314b421ea132fee84f4afcd244f987" name="a3b314b421ea132fee84f4afcd244f987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b314b421ea132fee84f4afcd244f987">&#9670;&#160;</a></span>IsFixedAtLevelZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::IsFixedAtLevelZero </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the variable is fixed at level 0. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01722">1722</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aa325f29140f8674328aa62599b38dddb" name="aa325f29140f8674328aa62599b38dddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa325f29140f8674328aa62599b38dddb">&#9670;&#160;</a></span>LevelZeroLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::LevelZeroLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>exp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns globally valid lower/upper bound on the given affine expression. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01727">1727</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ad3738bb49556079e3f031e4f9abff18d" name="ad3738bb49556079e3f031e4f9abff18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3738bb49556079e3f031e4f9abff18d">&#9670;&#160;</a></span>LevelZeroLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::LevelZeroLowerBound </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns globally valid lower/upper bound on the given integer variable. </p>
<p>The level zero bounds are stored at the beginning of the trail and they also serves as sentinels. Their index match the variables index. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01712">1712</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="acba132505b7638ffe247d0a7a495b0d1" name="acba132505b7638ffe247d0a7a495b0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba132505b7638ffe247d0a7a495b0d1">&#9670;&#160;</a></span>LevelZeroUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::LevelZeroUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>exp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01733">1733</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ab8c7324f4682ebd510a35917832db076" name="ab8c7324f4682ebd510a35917832db076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c7324f4682ebd510a35917832db076">&#9670;&#160;</a></span>LevelZeroUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::LevelZeroUpperBound </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01717">1717</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="acb1e43a55688b0002d08e82778295a47" name="acb1e43a55688b0002d08e82778295a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1e43a55688b0002d08e82778295a47">&#9670;&#160;</a></span>LowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::LowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above for an affine expression. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01670">1670</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a0b2afe8b074760d54d767d2d73f60aea" name="a0b2afe8b074760d54d767d2d73f60aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2afe8b074760d54d767d2d73f60aea">&#9670;&#160;</a></span>LowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::LowerBound </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current lower/upper bound of the given integer variable. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01617">1617</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a32873f018d4520f331a392d96506c720" name="a32873f018d4520f331a392d96506c720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32873f018d4520f331a392d96506c720">&#9670;&#160;</a></span>LowerBoundAsLiteral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::IntegerTrail::LowerBoundAsLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the integer literal that represent the current lower/upper bound of the given affine expression. In case the expression is constant, it returns <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html#a344a4d0623476ecc0a5d5df9085b3602">IntegerLiteral::TrueLiteral()</a>. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01690">1690</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a5e7d94f60772f7fa56fb85bdcdad2ce0" name="a5e7d94f60772f7fa56fb85bdcdad2ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7d94f60772f7fa56fb85bdcdad2ce0">&#9670;&#160;</a></span>LowerBoundAsLiteral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::IntegerTrail::LowerBoundAsLiteral </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the integer literal that represent the current lower/upper bound of the given integer variable. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01660">1660</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ac1fb45f018e2314a5d367335536e503c" name="ac1fb45f018e2314a5d367335536e503c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fb45f018e2314a5d367335536e503c">&#9670;&#160;</a></span>MergeReasonInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::MergeReasonInto </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literals</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the reason for the given integer literals to the output and call STLSortAndRemoveDuplicates() on it. This function accept "constant" literal. </p>
<p>Any indices lower than that means that there is no reason needed. </p><dl class="section note"><dt>Note</dt><dd>it is important for size to be signed because of -1 indices.</dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01834">1834</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a94aef13eb728ffde07b8f7aa50e55aed" name="a94aef13eb728ffde07b8f7aa50e55aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94aef13eb728ffde07b8f7aa50e55aed">&#9670;&#160;</a></span>NextVariableToBranchOnInPropagationLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerTrail::NextVariableToBranchOnInPropagationLoop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We try to select a variable with a large domain that was propagated a lot already. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01461">1461</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a049cddb7be16d2b9eb09a838558131ea" name="a049cddb7be16d2b9eb09a838558131ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049cddb7be16d2b9eb09a838558131ea">&#9670;&#160;</a></span>NotifyThatPropagationWasAborted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::NotifyThatPropagationWasAborted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01453">1453</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a2270b728687bb84a6940473a2470a5f9" name="a2270b728687bb84a6940473a2470a5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2270b728687bb84a6940473a2470a5f9">&#9670;&#160;</a></span>num_enqueues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::IntegerTrail::num_enqueues </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of enqueues that changed a variable bounds. We don't count enqueues called with a less restrictive bound than the current one.</p>
<p>Note(user): this can be used to see if any of the bounds changed. Just looking at the integer trail index is not enough because at level zero it doesn't change since we directly update the "fixed" bounds. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01030">1030</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="aae355fe55d1dbb006cac7cf8260d97b0" name="aae355fe55d1dbb006cac7cf8260d97b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae355fe55d1dbb006cac7cf8260d97b0">&#9670;&#160;</a></span>num_level_zero_enqueues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::IntegerTrail::num_level_zero_enqueues </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as num_enqueues but only count the level zero changes. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01034">1034</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a1ff3feafd28f46006559ad6f5eebbf91" name="a1ff3feafd28f46006559ad6f5eebbf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff3feafd28f46006559ad6f5eebbf91">&#9670;&#160;</a></span>NumConstantVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::IntegerTrail::NumConstantVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The +1 if for the special key zero (the only case when we have an odd number of entries).</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00920">920</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a8ce9339e32d63fa818656755fa51c373" name="a8ce9339e32d63fa818656755fa51c373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce9339e32d63fa818656755fa51c373">&#9670;&#160;</a></span>NumIntegerVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::IntegerTrail::NumIntegerVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of created integer variables.</p>
<dl class="section note"><dt>Note</dt><dd>this is twice the number of call to <a class="el" href="#a6bd05d19e276120cc061cd16151fba7d">AddIntegerVariable()</a> since we automatically create the <a class="el" href="namespaceoperations__research_1_1sat.html#a3cc13a38d3e6a002d912b72eac52dcd1" title="Returns the vector of the negated variables.">NegationOf()</a> variable too. </dd></dl>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l00782">782</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a16980d1e840f686778ee0d1d70f4d716" name="a16980d1e840f686778ee0d1d70f4d716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16980d1e840f686778ee0d1d70f4d716">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp; operations_research::sat::IntegerTrail::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3ea8da78f7a6ec038887174bbad6ceb" name="ae3ea8da78f7a6ec038887174bbad6ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ea8da78f7a6ec038887174bbad6ceb">&#9670;&#160;</a></span>Propagate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::Propagate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> *</td>          <td class="paramname"><span class="paramname"><em>trail</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints.">SatPropagator</a> interface. These functions make sure the current bounds information is in sync with the current solver literal trail. Any class/propagator using this class must make sure it is synced to the correct state before calling any of its functions. </p>
<p>Make sure that our internal "integer_search_levels_" size matches the sat decision levels. At the level zero, integer_search_levels_ should be empty.</p>
<p>This is required because when loading a model it is possible that we add (literal &lt;-&gt; integer literal) associations for literals that have already been propagated here. This often happens when the presolve is off and many variables are fixed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001665">Todo</a></b></dt><dd>(user): refactor the interaction <a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a> &lt;-&gt; <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a> so that we can just push right away such literal. Unfortunately, this is is a big chunk of work. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>we do not call Enqueue here but directly the update domain function so that we do not abort even if the level zero bounds were up to date.</dd></dl>
<p>Process all the "associated" literals and <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a> the corresponding bounds.</p>
<p>The reason is simply the associated literal.</p>

<p>Implements <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a8417cfbc49d425aac62ce622b058b018">operations_research::sat::SatPropagator</a>.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00696">696</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a090881ffd3442b49e6e858dd6cc9f433" name="a090881ffd3442b49e6e858dd6cc9f433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090881ffd3442b49e6e858dd6cc9f433">&#9670;&#160;</a></span>Reason()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::IntegerTrail::Reason </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>trail</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>trail_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001674">Todo</a></b></dt><dd>(user): If this is called many time on the same variables, it could be made faster by using some caching mechanism. </dd></dl>

<p>Reimplemented from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#ae623c1e4b5cc13194317411f19eff4ac">operations_research::sat::SatPropagator</a>.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01984">1984</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ae61ff017ebe16e1bdeb3b3195d4a889d" name="ae61ff017ebe16e1bdeb3b3195d4a889d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61ff017ebe16e1bdeb3b3195d4a889d">&#9670;&#160;</a></span>ReasonFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; operations_research::sat::IntegerTrail::ReasonFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>literal</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the reason (as set of <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> currently false) for a given integer literal. Note that the bound must be less restrictive than the current bound (checked). </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01828">1828</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="aa0bdc70211090f52a8ad50526cf060fe" name="aa0bdc70211090f52a8ad50526cf060fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bdc70211090f52a8ad50526cf060fe">&#9670;&#160;</a></span>RegisterDebugChecker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::RegisterDebugChecker </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt; clause, absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; integers)&gt;</td>          <td class="paramname"><span class="paramname"><em>checker</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is set, and in debug mode, we will call this on all conflict to be checked for potential issue. Usually against a known optimal solution. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01114">1114</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a6ed031e413d60e94e731421366337eff" name="a6ed031e413d60e94e731421366337eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed031e413d60e94e731421366337eff">&#9670;&#160;</a></span>RegisterReversibleClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::RegisterReversibleClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1ReversibleInterface.html">ReversibleInterface</a> *</td>          <td class="paramname"><span class="paramname"><em>rev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a reversible class. This class will always be synced with the correct decision level. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01069">1069</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a38d6ed54b4b6fe9a9b104dd5f92f4f95" name="a38d6ed54b4b6fe9a9b104dd5f92f4f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d6ed54b4b6fe9a9b104dd5f92f4f95">&#9670;&#160;</a></span>RegisterWatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::RegisterWatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1SparseBitset.html">SparseBitset</a>&lt; IntegerVariable &gt; *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All the registered bitsets will be set to one each time a LbVar is modified. It is up to the client to clear it if it wants to be notified with the newly modified variables. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01039">1039</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a1b9710320ee9ff075b750bcb7da22664" name="a1b9710320ee9ff075b750bcb7da22664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9710320ee9ff075b750bcb7da22664">&#9670;&#160;</a></span>RelaxLinearReason() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::RelaxLinearReason </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>slack</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>trail_indices</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above but relax the given trail indices. </p>
<p>We start by filtering *trail_indices:</p><ul>
<li>remove all level zero entries.</li>
<li>keep the one that cannot be relaxed.</li>
<li>move the other one to the relax_heap_ (and creating the heap).</li>
</ul>
<p>We ignore level zero entries.</p>
<p>If the coeff is too large, we cannot relax this entry.</p>
<p>This is a bit hacky, but when it is used from MergeReasonIntoInternal(), we never relax a reason that will not be expanded because it is already part of the current conflict.</p>
<dl class="section note"><dt>Note</dt><dd>both terms of the product are positive.</dd></dl>
<p>The slack might have changed since the entry was added.</p>
<p>Relax, and decide what to do with the new value of index.</p>
<p>Same code as in the first block.</p>
<p>If we aborted early because of the slack, we need to push all remaining indices back into the reason.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01033">1033</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a3f82268fd6c91332511a3d8765d6d07f" name="a3f82268fd6c91332511a3d8765d6d07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f82268fd6c91332511a3d8765d6d07f">&#9670;&#160;</a></span>RelaxLinearReason() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::RelaxLinearReason </td>
          <td>(</td>
          <td class="paramtype">IntegerValue</td>          <td class="paramname"><span class="paramname"><em>slack</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const IntegerValue &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>reason</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advanced usage. Given the reason for (Sum_i coeffs[i] * reason[i].var &gt;= current_lb) initially in reason, this function relaxes the reason given that we only need the explanation of (Sum_i coeffs[i] * reason[i].var &gt;= current_lb - slack).</p>
<p>Preconditions:</p><ul>
<li>coeffs must be of same size as reason, and all entry must be positive.</li>
<li><p class="startli">*reason must initially contains the trivial initial reason, that is the current lower-bound of each variables.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001693">Todo</a></b></dt><dd>(user): Requiring all initial literal to be at their current bound is not really clean. Maybe we can change the API to only take IntegerVariable and produce the reason directly.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001694">Todo</a></b></dt><dd>(user): change API so that this work is performed during the conflict analysis where we can be smarter in how we relax the reason. Note however that this function is mainly used when we have a conflict, so this is not really high priority.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001695">Todo</a></b></dt><dd>(user): Test that the code work in the presence of integer overflow. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001666">Todo</a></b></dt><dd>(user): Get rid of this function and only keep the trail index one? </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00996">996</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a11ad14c32577dee8a53863b58ca4598c" name="a11ad14c32577dee8a53863b58ca4598c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ad14c32577dee8a53863b58ca4598c">&#9670;&#160;</a></span>RemoveLevelZeroBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::RemoveLevelZeroBounds </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>reason</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes from the reasons the literal that are always true. This is mainly useful for experiments/testing. </p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01130">1130</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a7e20213d10155e1ddc4a69a221d0c3a2" name="a7e20213d10155e1ddc4a69a221d0c3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e20213d10155e1ddc4a69a221d0c3a2">&#9670;&#160;</a></span>ReportConflict() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::ReportConflict </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integer_reason</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01054">1054</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a703b4b6b6c812f4e5a6dff0315657d08" name="a703b4b6b6c812f4e5a6dff0315657d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703b4b6b6c812f4e5a6dff0315657d08">&#9670;&#160;</a></span>ReportConflict() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::ReportConflict </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>literal_reason</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integer_reason</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper functions to report a conflict. Always return false so a client can simply do: return integer_trail_-&gt;ReportConflict(...); </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01046">1046</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ae029cc33c5b2378c55eefad250b90e73" name="ae029cc33c5b2378c55eefad250b90e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae029cc33c5b2378c55eefad250b90e73">&#9670;&#160;</a></span>ReserveSpaceForNumVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::ReserveSpaceForNumVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimization: you can call this before calling <a class="el" href="#a6bd05d19e276120cc061cd16151fba7d">AddIntegerVariable()</a> num_vars time. </p>
<p>We only store the domain for the positive variable.</p>
<p>Because we always create both a variable and its negation.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00807">807</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ab40e3a18d801827c17fc32f1214d6d31" name="ab40e3a18d801827c17fc32f1214d6d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40e3a18d801827c17fc32f1214d6d31">&#9670;&#160;</a></span>RootLevelEnqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::RootLevelEnqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes we infer some root level bounds but we are not at the root level. In this case, we will update the level-zero bounds right away, but will delay the current push until the next restart.</p>
<dl class="section note"><dt>Note</dt><dd>if you want to also push the literal at the current level, then just calling <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a> is enough. Since there is no reason, the literal will still be recorded properly. </dd></dl>
<p>We update right away the level zero bounds, but delay the actual enqueue until we are back at level zero. This allow to properly push any associated literal.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01200">1200</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a3f2153942f118e9639ca52903d781b26" name="a3f2153942f118e9639ca52903d781b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2153942f118e9639ca52903d781b26">&#9670;&#160;</a></span>SafeEnqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::SafeEnqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a></td>          <td class="paramname"><span class="paramname"><em>i_lit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const <a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>integer_reason</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue new information about a variable bound. It has the same behavior as the <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a> method, except that it accepts true and false integer literals, both for i_lit, and for the integer reason.</p>
<p>This method will do nothing if i_lit is a true literal. It will report a conflict if i_lit is a false literal, and enqueue i_lit normally otherwise. Furthemore, it will check that the integer reason does not contain any false literals, and will remove true literals before calling <a class="el" href="#a703b4b6b6c812f4e5a6dff0315657d08">ReportConflict()</a> or <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#a703b4b6b6c812f4e5a6dff0315657d08">ReportConflict()</a> deal correctly with constant literals.</dd></dl>
<p>Most of our propagation code do not use "constant" literal, so to not have to test for them in <a class="el" href="#aa5f3f24dfc832d45939478360f2a9ef1">Enqueue()</a>, we clear them beforehand.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l01223">1223</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a76bb8119d2cd0700aba64cb957c72dd2" name="a76bb8119d2cd0700aba64cb957c72dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bb8119d2cd0700aba64cb957c72dd2">&#9670;&#160;</a></span>timestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t operations_research::sat::IntegerTrail::timestamp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01031">1031</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="ad46e312c99c8b0a71ae78459c6c456ac" name="ad46e312c99c8b0a71ae78459c6c456ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46e312c99c8b0a71ae78459c6c456ac">&#9670;&#160;</a></span>Untrail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::sat::IntegerTrail::Untrail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1sat_1_1Trail.html">Trail</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>trail</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>trail_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reverts the state so that all the literals with a trail index greater or equal to the given one are not processed for propagation. Note that the trail current decision level is already reverted before this is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002128">Todo</a></b></dt><dd>(user): Currently this is called at each Backtrack(), but we could bundle the calls in case multiple conflict one after the other are detected even before the <a class="el" href="#ae3ea8da78f7a6ec038887174bbad6ceb">Propagate()</a> call of a <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html" title="Base class for all the SAT constraints.">SatPropagator</a> is called.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo002129">Todo</a></b></dt><dd>(user): It is not yet 100% the case, but this can be guaranteed to be called with a trail index that will always be the start of a new decision level. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if a conflict was detected before <a class="el" href="#ae3ea8da78f7a6ec038887174bbad6ceb">Propagate()</a> of this class was even called, it is possible that there is nothing to backtrack.</dd></dl>
<p>Clear reason.</p>
<p>We notify the new level once all variables have been restored to their old value.</p>

<p>Reimplemented from <a class="el" href="classoperations__research_1_1sat_1_1SatPropagator.html#a68acada7af835c9c6870ceb876dc2d9c">operations_research::sat::SatPropagator</a>.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00758">758</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="a86dbd554c727e96c1ce6e33a54a73235" name="a86dbd554c727e96c1ce6e33a54a73235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dbd554c727e96c1ce6e33a54a73235">&#9670;&#160;</a></span>UpdateInitialDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::UpdateInitialDomain </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1Domain.html">Domain</a></td>          <td class="paramname"><span class="paramname"><em>domain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes the intersection with the current initial variable domain.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001692">Todo</a></b></dt><dd>(user): There is some memory inefficiency if this is called many time because of the underlying data structure we use. In practice, when used with a presolve, this is not often used, so that is fine though. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>we don't support optional variable here. Or at least if you set the domain of an optional variable to zero, the problem will be declared unsat. </dd></dl>
<p>Update directly the level zero bounds.</p>
<p>Do not forget to update the watchers.</p>
<p>Update the encoding.</p>

<p class="definition">Definition at line <a class="el" href="integer_8cc_source.html#l00866">866</a> of file <a class="el" href="integer_8cc_source.html">integer.cc</a>.</p>

</div>
</div>
<a id="ab28683ffcfe4f53e81be588b86aa51a5" name="ab28683ffcfe4f53e81be588b86aa51a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28683ffcfe4f53e81be588b86aa51a5">&#9670;&#160;</a></span>UpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::UpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01675">1675</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a4a11e8bd15eb96039315693963c28609" name="a4a11e8bd15eb96039315693963c28609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a11e8bd15eb96039315693963c28609">&#9670;&#160;</a></span>UpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerValue operations_research::sat::IntegerTrail::UpperBound </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01621">1621</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a0b52c18d302bea4fcce8f77f1d07f153" name="a0b52c18d302bea4fcce8f77f1d07f153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b52c18d302bea4fcce8f77f1d07f153">&#9670;&#160;</a></span>UpperBoundAsLiteral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::IntegerTrail::UpperBoundAsLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01696">1696</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a3b23637b887286282df5a02cbae3db0f" name="a3b23637b887286282df5a02cbae3db0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b23637b887286282df5a02cbae3db0f">&#9670;&#160;</a></span>UpperBoundAsLiteral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1IntegerLiteral.html">IntegerLiteral</a> operations_research::sat::IntegerTrail::UpperBoundAsLiteral </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01665">1665</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<a id="a14bf7830edb81a77ca4ff8bdfd5bf940" name="a14bf7830edb81a77ca4ff8bdfd5bf940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bf7830edb81a77ca4ff8bdfd5bf940">&#9670;&#160;</a></span>VariableLowerBoundIsFromLevelZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::IntegerTrail::VariableLowerBoundIsFromLevelZero </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the variable lower bound is still the one from level zero. </p>

<p class="definition">Definition at line <a class="el" href="integer_8h_source.html#l01063">1063</a> of file <a class="el" href="integer_8h_source.html">integer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ortools/sat/<a class="el" href="integer_8h_source.html">integer.h</a></li>
<li>ortools/sat/<a class="el" href="integer_8cc_source.html">integer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1IntegerTrail.html">IntegerTrail</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
