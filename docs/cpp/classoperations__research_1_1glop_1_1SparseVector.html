<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.6</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classoperations__research_1_1glop_1_1SparseVector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classoperations__research_1_1glop_1_1SparseVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a783efd95525f21afc8045cdb1e9eb00a"><td class="memItemLeft" align="right" valign="top">typedef IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a></td></tr>
<tr class="separator:a783efd95525f21afc8045cdb1e9eb00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c031d168b70a7966cb28608543423c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1glop_1_1StrictITIVector.html">StrictITIVector</a>&lt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>, <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a></td></tr>
<tr class="separator:a38c031d168b70a7966cb28608543423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcfccfaf0aa53fac439442676718dad"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1glop_1_1Permutation.html">Permutation</a>&lt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a></td></tr>
<tr class="separator:abfcfccfaf0aa53fac439442676718dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf0ace6a94f9445f57879cc743f5df4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abbf0ace6a94f9445f57879cc743f5df4">Iterator</a> = IteratorType</td></tr>
<tr class="separator:abbf0ace6a94f9445f57879cc743f5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94af89df9f08aaa81ad38379314fd697"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a94af89df9f08aaa81ad38379314fd697">Entry</a> = typename Iterator::Entry</td></tr>
<tr class="separator:a94af89df9f08aaa81ad38379314fd697"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb55a2b5b5c9a55751c36dcc6d25e764"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abb55a2b5b5c9a55751c36dcc6d25e764">SparseVector</a> ()</td></tr>
<tr class="separator:abb55a2b5b5c9a55751c36dcc6d25e764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b239a430871f919f487f09dc327f3bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a8b239a430871f919f487f09dc327f3bd">SparseVector</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;other)</td></tr>
<tr class="separator:a8b239a430871f919f487f09dc327f3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf565f4186d66676cf35a47eb7368c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afbbf565f4186d66676cf35a47eb7368c">SparseVector</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:afbbf565f4186d66676cf35a47eb7368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7a9e3bec9b51c7da9dcba8070b496c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a7a7a9e3bec9b51c7da9dcba8070b496c">operator=</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;other)</td></tr>
<tr class="separator:a7a7a9e3bec9b51c7da9dcba8070b496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106991245e0aff64298d2db9ab1348ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a106991245e0aff64298d2db9ab1348ab">operator=</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a106991245e0aff64298d2db9ab1348ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813464eed0da3d6c5fd242737287fa50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abbf0ace6a94f9445f57879cc743f5df4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a813464eed0da3d6c5fd242737287fa50">begin</a> () const</td></tr>
<tr class="separator:a813464eed0da3d6c5fd242737287fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d33ef32a9c194add63c1fde30a50e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abbf0ace6a94f9445f57879cc743f5df4">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a96d33ef32a9c194add63c1fde30a50e3">end</a> () const</td></tr>
<tr class="separator:a96d33ef32a9c194add63c1fde30a50e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bae030fee9573298314a0ace2cec75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a95bae030fee9573298314a0ace2cec75">Clear</a> ()</td></tr>
<tr class="memdesc:a95bae030fee9573298314a0ace2cec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the vector, i.e. removes all entries.  <br /></td></tr>
<tr class="separator:a95bae030fee9573298314a0ace2cec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787556a86e18fc0018ace32864ab6cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a787556a86e18fc0018ace32864ab6cca">ClearAndRelease</a> ()</td></tr>
<tr class="memdesc:a787556a86e18fc0018ace32864ab6cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the vector and releases the memory it uses.  <br /></td></tr>
<tr class="separator:a787556a86e18fc0018ace32864ab6cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd919747388eab4fd137af29ed60653b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#acd919747388eab4fd137af29ed60653b">Reserve</a> (EntryIndex new_capacity)</td></tr>
<tr class="memdesc:acd919747388eab4fd137af29ed60653b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve the underlying storage for the given number of entries.  <br /></td></tr>
<tr class="separator:acd919747388eab4fd137af29ed60653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c72b464276dcf2ba155d80251f4202"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a83c72b464276dcf2ba155d80251f4202">IsEmpty</a> () const</td></tr>
<tr class="memdesc:a83c72b464276dcf2ba155d80251f4202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector is empty.  <br /></td></tr>
<tr class="separator:a83c72b464276dcf2ba155d80251f4202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0952c189b9c921d79526b96295a2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afb0952c189b9c921d79526b96295a2c8">CleanUp</a> ()</td></tr>
<tr class="separator:afb0952c189b9c921d79526b96295a2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a828355962a7387720b536b6bdd15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac74a828355962a7387720b536b6bdd15">IsCleanedUp</a> () const</td></tr>
<tr class="separator:ac74a828355962a7387720b536b6bdd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0482bae6353661bcadb00b0c799ef744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a0482bae6353661bcadb00b0c799ef744">Swap</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> *other)</td></tr>
<tr class="separator:a0482bae6353661bcadb00b0c799ef744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de8ae60841ab8f3ff08b69507852bbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a4de8ae60841ab8f3ff08b69507852bbc">PopulateFromSparseVector</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;sparse_vector)</td></tr>
<tr class="separator:a4de8ae60841ab8f3ff08b69507852bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d81341bcace205399732fde5dbb3cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac0d81341bcace205399732fde5dbb3cf">PopulateFromDenseVector</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;dense_vector)</td></tr>
<tr class="separator:ac0d81341bcace205399732fde5dbb3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06311fa39f485335dcce7c8304b1998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#aa06311fa39f485335dcce7c8304b1998">AppendEntriesWithOffset</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;sparse_vector, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> offset)</td></tr>
<tr class="separator:aa06311fa39f485335dcce7c8304b1998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06a99b7d06f0cd40e0d166c9033a9f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae06a99b7d06f0cd40e0d166c9033a9f9">CheckNoDuplicates</a> () const</td></tr>
<tr class="separator:ae06a99b7d06f0cd40e0d166c9033a9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dca9ca5b566fb602e4ae640e2fed7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a86dca9ca5b566fb602e4ae640e2fed7d">CheckNoDuplicates</a> (<a class="el" href="classoperations__research_1_1glop_1_1StrictITIVector.html">StrictITIVector</a>&lt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>, bool &gt; *boolean_vector) const</td></tr>
<tr class="separator:a86dca9ca5b566fb602e4ae640e2fed7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68c2b45ba21cb0a49e6c174cbfadc9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ab68c2b45ba21cb0a49e6c174cbfadc9f">SetCoefficient</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="local__search_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="memdesc:ab68c2b45ba21cb0a49e6c174cbfadc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the coefficient at index, i.e. vector[index] = value;.  <br /></td></tr>
<tr class="separator:ab68c2b45ba21cb0a49e6c174cbfadc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926e7298a1f2e422fb38604e2facc21f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a926e7298a1f2e422fb38604e2facc21f">DeleteEntry</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="local__search_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)</td></tr>
<tr class="separator:a926e7298a1f2e422fb38604e2facc21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063a66ff363cb24cfdde29d9d890365b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a063a66ff363cb24cfdde29d9d890365b">RemoveNearZeroEntries</a> (<a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> threshold)</td></tr>
<tr class="separator:a063a66ff363cb24cfdde29d9d890365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b51bb8727f85df9198481f762f247d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a7b51bb8727f85df9198481f762f247d9">RemoveNearZeroEntriesWithWeights</a> (<a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> threshold, const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;weights)</td></tr>
<tr class="separator:a7b51bb8727f85df9198481f762f247d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1257f73f0c0ff73e821aec33dfbac598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a1257f73f0c0ff73e821aec33dfbac598">MoveEntryToFirstPosition</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="local__search_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)</td></tr>
<tr class="separator:a1257f73f0c0ff73e821aec33dfbac598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0966e6b28455197163868d2920ff8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a9a0966e6b28455197163868d2920ff8b">MoveEntryToLastPosition</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="local__search_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)</td></tr>
<tr class="separator:a9a0966e6b28455197163868d2920ff8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad3d6118e2d5851a8e15ac6733fdb04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#adad3d6118e2d5851a8e15ac6733fdb04">MultiplyByConstant</a> (<a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> factor)</td></tr>
<tr class="separator:adad3d6118e2d5851a8e15ac6733fdb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd313597bd4e184e641e3f3199c879b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a4cd313597bd4e184e641e3f3199c879b">ComponentWiseMultiply</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;factors)</td></tr>
<tr class="separator:a4cd313597bd4e184e641e3f3199c879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad0083c2f6044ed4f1ebd7b5b62c5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#acad0083c2f6044ed4f1ebd7b5b62c5ca">DivideByConstant</a> (<a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> factor)</td></tr>
<tr class="separator:acad0083c2f6044ed4f1ebd7b5b62c5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b2c492beb0335dab369dddba5d3c37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ab4b2c492beb0335dab369dddba5d3c37">ComponentWiseDivide</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;factors)</td></tr>
<tr class="separator:ab4b2c492beb0335dab369dddba5d3c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2d3fdba8ab62dc5d4782bc9234d385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#aef2d3fdba8ab62dc5d4782bc9234d385">CopyToDenseVector</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> num_indices, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> *dense_vector) const</td></tr>
<tr class="separator:aef2d3fdba8ab62dc5d4782bc9234d385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac5a2f6d6ac61d04c8e1f31411919a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#adcac5a2f6d6ac61d04c8e1f31411919a">PermutedCopyToDenseVector</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;index_perm, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> num_indices, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> *dense_vector) const</td></tr>
<tr class="separator:adcac5a2f6d6ac61d04c8e1f31411919a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7779651c62ecf78d42cd31c95809e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae7779651c62ecf78d42cd31c95809e1c">AddMultipleToDenseVector</a> (<a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> multiplier, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> *dense_vector) const</td></tr>
<tr class="separator:ae7779651c62ecf78d42cd31c95809e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4338dc5442b4b76d73df0c2e03db8b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a4338dc5442b4b76d73df0c2e03db8b80">AddMultipleToSparseVectorAndDeleteCommonIndex</a> (<a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> multiplier, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> removed_common_index, <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> drop_tolerance, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> *accumulator_vector) const</td></tr>
<tr class="separator:a4338dc5442b4b76d73df0c2e03db8b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac070c931ce54add3f2d380dcae5bdeff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac070c931ce54add3f2d380dcae5bdeff">AddMultipleToSparseVectorAndIgnoreCommonIndex</a> (<a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> multiplier, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> removed_common_index, <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> drop_tolerance, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> *accumulator_vector) const</td></tr>
<tr class="separator:ac070c931ce54add3f2d380dcae5bdeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413aff7fdefb423b0525d6e9ffdaf15e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a413aff7fdefb423b0525d6e9ffdaf15e">ApplyIndexPermutation</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;index_perm)</td></tr>
<tr class="memdesc:a413aff7fdefb423b0525d6e9ffdaf15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the index permutation to all entries: index = index_perm[index];.  <br /></td></tr>
<tr class="separator:a413aff7fdefb423b0525d6e9ffdaf15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231cac7d79c5dc40c4c0d2c629474688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a231cac7d79c5dc40c4c0d2c629474688">ApplyPartialIndexPermutation</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;index_perm)</td></tr>
<tr class="separator:a231cac7d79c5dc40c4c0d2c629474688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8066cbc5d5b7f8e794677b027cd96a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac8066cbc5d5b7f8e794677b027cd96a2">MoveTaggedEntriesTo</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;index_perm, <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> *output)</td></tr>
<tr class="separator:ac8066cbc5d5b7f8e794677b027cd96a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbae873b1b6a1f33cac11606834b6d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#afbae873b1b6a1f33cac11606834b6d0e">LookUpCoefficient</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="local__search_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>) const</td></tr>
<tr class="separator:afbae873b1b6a1f33cac11606834b6d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118659107ff8fe0c31459ad296c7f72d"><td class="memItemLeft" align="right" valign="top">EntryIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a118659107ff8fe0c31459ad296c7f72d">num_entries</a> () const</td></tr>
<tr class="memdesc:a118659107ff8fe0c31459ad296c7f72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note this method can only be used when the vector has no duplicates.  <br /></td></tr>
<tr class="separator:a118659107ff8fe0c31459ad296c7f72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c9e369dc0834dfb944aa50558aeb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a75c9e369dc0834dfb944aa50558aeb70">GetFirstIndex</a> () const</td></tr>
<tr class="separator:a75c9e369dc0834dfb944aa50558aeb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7a2f9820def1574f18bbf609d86ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a1d7a2f9820def1574f18bbf609d86ff3">GetFirstCoefficient</a> () const</td></tr>
<tr class="separator:a1d7a2f9820def1574f18bbf609d86ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ca8690e61feacde9400bf46978a395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ad5ca8690e61feacde9400bf46978a395">GetLastIndex</a> () const</td></tr>
<tr class="memdesc:ad5ca8690e61feacde9400bf46978a395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like GetFirst*, but for the last entry.  <br /></td></tr>
<tr class="separator:ad5ca8690e61feacde9400bf46978a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20878f0786bb8d8c0a8c839c7292e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae20878f0786bb8d8c0a8c839c7292e5c">GetLastCoefficient</a> () const</td></tr>
<tr class="separator:ae20878f0786bb8d8c0a8c839c7292e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281b1ceefbefc14e321958f139dd8ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutil_1_1IntegerRange.html">::util::IntegerRange</a>&lt; EntryIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a281b1ceefbefc14e321958f139dd8ea3">AllEntryIndices</a> () const</td></tr>
<tr class="separator:a281b1ceefbefc14e321958f139dd8ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ed62e96387e02a6365812690e6b7fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae9ed62e96387e02a6365812690e6b7fe">IsEqualTo</a> (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp;other) const</td></tr>
<tr class="separator:ae9ed62e96387e02a6365812690e6b7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ec76e954ad165db00ce7a123bf0f89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a96ec76e954ad165db00ce7a123bf0f89">DebugString</a> () const</td></tr>
<tr class="separator:a96ec76e954ad165db00ce7a123bf0f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac31cf3a0abb1e667080a0bbb5e04268f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ac31cf3a0abb1e667080a0bbb5e04268f">AddEntry</a> (<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="local__search_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> <a class="el" href="demon__profiler_8cc.html#ac072af30c4ffbc834bb4c681f6ecb514">value</a>)</td></tr>
<tr class="separator:ac31cf3a0abb1e667080a0bbb5e04268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa403826e7986ab9ce2c68c0f27404b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#aa403826e7986ab9ce2c68c0f27404b3d">ResizeDown</a> (EntryIndex new_size)</td></tr>
<tr class="separator:aa403826e7986ab9ce2c68c0f27404b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86678568efb9f5b9aee1b034b577e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#af86678568efb9f5b9aee1b034b577e51">GetIndex</a> (EntryIndex i) const</td></tr>
<tr class="separator:af86678568efb9f5b9aee1b034b577e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08d1ba6474874dea7e01e7185a9529c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#aa08d1ba6474874dea7e01e7185a9529c">GetCoefficient</a> (EntryIndex i) const</td></tr>
<tr class="separator:aa08d1ba6474874dea7e01e7185a9529c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3323546eab84bd0887b14821d54ef9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ad3323546eab84bd0887b14821d54ef9e">MutableIndex</a> (EntryIndex i)</td></tr>
<tr class="separator:ad3323546eab84bd0887b14821d54ef9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9bf37adc39b8418a6035e7aa181d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abb9bf37adc39b8418a6035e7aa181d2e">MutableCoefficient</a> (EntryIndex i)</td></tr>
<tr class="separator:abb9bf37adc39b8418a6035e7aa181d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acfde05c6fddd3f82b855b7c6d1f396f8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; char[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#acfde05c6fddd3f82b855b7c6d1f396f8">buffer_</a></td></tr>
<tr class="separator:acfde05c6fddd3f82b855b7c6d1f396f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bee34a6dd340eb0c130b29e1c68b33"><td class="memItemLeft" align="right" valign="top">EntryIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a92bee34a6dd340eb0c130b29e1c68b33">num_entries_</a></td></tr>
<tr class="separator:a92bee34a6dd340eb0c130b29e1c68b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5340312c5955bd057c13dabe398f9bf5"><td class="memItemLeft" align="right" valign="top">EntryIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a5340312c5955bd057c13dabe398f9bf5">capacity_</a></td></tr>
<tr class="separator:a5340312c5955bd057c13dabe398f9bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb9fe4370fab3b2ffb59f076b3e7b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#aa9eb9fe4370fab3b2ffb59f076b3e7b1">index_</a></td></tr>
<tr class="memdesc:aa9eb9fe4370fab3b2ffb59f076b3e7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to the first elements of the index and coefficient arrays.  <br /></td></tr>
<tr class="separator:aa9eb9fe4370fab3b2ffb59f076b3e7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ca448e72034a09503ed79f4c46a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a079ca448e72034a09503ed79f4c46a85">coefficient_</a></td></tr>
<tr class="separator:a079ca448e72034a09503ed79f4c46a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905f925c4884ff9c163e630ffef925c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a905f925c4884ff9c163e630ffef925c9">may_contain_duplicates_</a></td></tr>
<tr class="separator:a905f925c4884ff9c163e630ffef925c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename IndexType, typename IteratorType = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt;<br />
class operations_research::glop::SparseVector&lt; IndexType, IteratorType &gt;</div><p><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> This class allows to store a vector taking advantage of its sparsity. Space complexity is in O(num_entries). In the current implementation, entries are stored in a first-in order (order of <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ab68c2b45ba21cb0a49e6c174cbfadc9f" title="Defines the coefficient at index, i.e. vector[index] = value;.">SetCoefficient()</a> calls) when they are added; then the "cleaning" process sorts them by index (and duplicates are removed: the last entry takes precedence). Many methods assume that the entries are sorted by index and without duplicates, and DCHECK() that.</p>
<p>Default copy construction is fully supported.</p>
<p>This class uses strong integer types (i.e. no implicit cast to/from other integer types) for both:</p><ul>
<li>the index of entries (eg. SparseVector&lt;RowIndex&gt; is a <a class="el" href="classoperations__research_1_1glop_1_1SparseColumn.html">SparseColumn</a>, see ./sparse_column.h).</li>
<li><p class="startli">the <em>internal</em> indices of entries in the internal storage, which is an entirely different type: EntryType. This class can be extended with a custom iterator/entry type for the iterator-based API. This can be used to extend the interface with additional methods for the entries returned by the iterators; for an example of such extension, see <a class="el" href="classoperations__research_1_1glop_1_1SparseColumnEntry.html">SparseColumnEntry</a> in <a class="el" href="sparse__column_8h.html">sparse_column.h</a>. The custom entries and iterators should be derived from <a class="el" href="classoperations__research_1_1glop_1_1SparseVectorEntry.html">SparseVectorEntry</a> and SparseVectorIterator, or at least provide the same public and protected interface.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000798">Todo:</a></b></dt><dd>(user): un-expose this type to client; by getting rid of the index-based APIs and leveraging iterator-based APIs; if possible. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00086">86</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a38c031d168b70a7966cb28608543423c" name="a38c031d168b70a7966cb28608543423c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c031d168b70a7966cb28608543423c">&#9670;&#160;</a></span>DenseVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1glop_1_1StrictITIVector.html">StrictITIVector</a>&lt;<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>, <a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&gt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::DenseVector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00090">90</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a94af89df9f08aaa81ad38379314fd697" name="a94af89df9f08aaa81ad38379314fd697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94af89df9f08aaa81ad38379314fd697">&#9670;&#160;</a></span>Entry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::Entry =  typename Iterator::Entry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00094">94</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a783efd95525f21afc8045cdb1e9eb00a" name="a783efd95525f21afc8045cdb1e9eb00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783efd95525f21afc8045cdb1e9eb00a">&#9670;&#160;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef IndexType <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::Index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00088">88</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="abfcfccfaf0aa53fac439442676718dad" name="abfcfccfaf0aa53fac439442676718dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcfccfaf0aa53fac439442676718dad">&#9670;&#160;</a></span>IndexPermutation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1glop_1_1Permutation.html">Permutation</a>&lt;<a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&gt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::IndexPermutation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00091">91</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="abbf0ace6a94f9445f57879cc743f5df4" name="abbf0ace6a94f9445f57879cc743f5df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf0ace6a94f9445f57879cc743f5df4">&#9670;&#160;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::Iterator =  IteratorType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00093">93</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb55a2b5b5c9a55751c36dcc6d25e764" name="abb55a2b5b5c9a55751c36dcc6d25e764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb55a2b5b5c9a55751c36dcc6d25e764">&#9670;&#160;</a></span>SparseVector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::SparseVector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> implementation </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00466">466</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a8b239a430871f919f487f09dc327f3bd" name="a8b239a430871f919f487f09dc327f3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b239a430871f919f487f09dc327f3bd">&#9670;&#160;</a></span>SparseVector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::SparseVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE(user): STL uses the expensive copy constructor when relocating elements of a vector, unless the move constructor exists <em>and</em> it is marked as noexcept. However, the noexcept annotation is banned by the style guide, and the only way to get it is by using the default move constructor and assignment operator generated by the compiler. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00474">474</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="afbbf565f4186d66676cf35a47eb7368c" name="afbbf565f4186d66676cf35a47eb7368c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf565f4186d66676cf35a47eb7368c">&#9670;&#160;</a></span>SparseVector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::SparseVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac31cf3a0abb1e667080a0bbb5e04268f" name="ac31cf3a0abb1e667080a0bbb5e04268f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31cf3a0abb1e667080a0bbb5e04268f">&#9670;&#160;</a></span>AddEntry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::AddEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new entry to the sparse vector, growing the internal buffer if needed. It does not set may_contain_duplicates_ to true. </p>
<p>Grow the internal storage if there is no space left for the new entry. We increase the size to max(4, 1.5*current capacity).</p>
<p>Reserve(capacity_ == 0 ? EntryIndex(4) : EntryIndex(2 * capacity_.value()));</p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00320">320</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ae7779651c62ecf78d42cd31c95809e1c" name="ae7779651c62ecf78d42cd31c95809e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7779651c62ecf78d42cd31c95809e1c">&#9670;&#160;</a></span>AddMultipleToDenseVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::AddMultipleToDenseVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> *&#160;</td>
          <td class="paramname"><em>dense_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the operation dense_vector += multiplier * this. This is known as multiply-accumulate or (fused) multiply-add. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00827">827</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a4338dc5442b4b76d73df0c2e03db8b80" name="a4338dc5442b4b76d73df0c2e03db8b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4338dc5442b4b76d73df0c2e03db8b80">&#9670;&#160;</a></span>AddMultipleToSparseVectorAndDeleteCommonIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::AddMultipleToSparseVectorAndDeleteCommonIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>removed_common_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; *&#160;</td>
          <td class="paramname"><em>accumulator_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>BOTH vectors (the current and the destination) MUST be "clean", i.e. sorted and without duplicates. Performs the operation accumulator_vector += multiplier * this, removing a given index which must be in both vectors, and pruning new entries whose absolute value are under the given drop_tolerance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00837">837</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ac070c931ce54add3f2d380dcae5bdeff" name="ac070c931ce54add3f2d380dcae5bdeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac070c931ce54add3f2d380dcae5bdeff">&#9670;&#160;</a></span>AddMultipleToSparseVectorAndIgnoreCommonIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::AddMultipleToSparseVectorAndIgnoreCommonIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>removed_common_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; *&#160;</td>
          <td class="paramname"><em>accumulator_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a4338dc5442b4b76d73df0c2e03db8b80">AddMultipleToSparseVectorAndDeleteCommonIndex()</a> but instead of deleting the common index, leave it unchanged. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00846">846</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a281b1ceefbefc14e321958f139dd8ea3" name="a281b1ceefbefc14e321958f139dd8ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281b1ceefbefc14e321958f139dd8ea3">&#9670;&#160;</a></span>AllEntryIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutil_1_1IntegerRange.html">::util::IntegerRange</a>&lt; EntryIndex &gt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::AllEntryIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to loop over the entry indices like this: for (const EntryIndex i : sparse_vector.AllEntryIndices()) { ... } </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000803">Todo:</a></b></dt><dd>(user): consider removing this, in favor of the natural range iteration. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00305">305</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="aa06311fa39f485335dcce7c8304b1998" name="aa06311fa39f485335dcce7c8304b1998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06311fa39f485335dcce7c8304b1998">&#9670;&#160;</a></span>AppendEntriesWithOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::AppendEntriesWithOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sparse_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends all entries from sparse_vector to the current vector; the indices of the appended entries are increased by offset. If the current vector already has a value at an index changed by this method, this value is overwritten with the value from sparse_vector. </p><dl class="section note"><dt>Note</dt><dd>while offset may be negative itself, the indices of all entries after applying the offset must be non-negative. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00638">638</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a413aff7fdefb423b0525d6e9ffdaf15e" name="a413aff7fdefb423b0525d6e9ffdaf15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413aff7fdefb423b0525d6e9ffdaf15e">&#9670;&#160;</a></span>ApplyIndexPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::ApplyIndexPermutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>index_perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the index permutation to all entries: index = index_perm[index];. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00938">938</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a231cac7d79c5dc40c4c0d2c629474688" name="a231cac7d79c5dc40c4c0d2c629474688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231cac7d79c5dc40c4c0d2c629474688">&#9670;&#160;</a></span>ApplyPartialIndexPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::ApplyPartialIndexPermutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>index_perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as ApplyIndexPermutation but deletes the index if index_perm[index] is negative. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00946">946</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a813464eed0da3d6c5fd242737287fa50" name="a813464eed0da3d6c5fd242737287fa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813464eed0da3d6c5fd242737287fa50">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-only API for a given <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> entry. The typical way for a client to use this is to use the natural range iteration defined by the Iterator class below: SparseVector&lt;int&gt; v; ... for (const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a94af89df9f08aaa81ad38379314fd697">SparseVector&lt;int&gt;::Entry</a> e : v) { LOG(INFO) &lt;&lt; "Index: " &lt;&lt; e.index() &lt;&lt; ", Coeff: " &lt;&lt; e.coefficient(); }</p>
<dl class="section note"><dt>Note</dt><dd>this can only be used when the vector has no duplicates.</dd></dl>
<p>Note(user): using either "const SparseVector&lt;int&gt;::Entry&amp;" or "const SparseVector&lt;int&gt;::Entry" yields the exact same performance on the netlib, thus we recommend to use the latter version, for consistency. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00451">451</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ae06a99b7d06f0cd40e0d166c9033a9f9" name="ae06a99b7d06f0cd40e0d166c9033a9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06a99b7d06f0cd40e0d166c9033a9f9">&#9670;&#160;</a></span>CheckNoDuplicates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::CheckNoDuplicates</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true when the vector contains no duplicates. Runs in O(max_index + num_entries), max_index being the largest index in entry. This method allocates (and deletes) a Boolean array of size max_index. </p><dl class="section note"><dt>Note</dt><dd>we use a mutable Boolean to make subsequent call runs in O(1). </dd></dl>
<p>Using <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a118659107ff8fe0c31459ad296c7f72d" title="Note this method can only be used when the vector has no duplicates.">num_entries()</a> or any function in that will call <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae06a99b7d06f0cd40e0d166c9033a9f9">CheckNoDuplicates()</a> again will cause an infinite loop!</p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00681">681</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a86dca9ca5b566fb602e4ae640e2fed7d" name="a86dca9ca5b566fb602e4ae640e2fed7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dca9ca5b566fb602e4ae640e2fed7d">&#9670;&#160;</a></span>CheckNoDuplicates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::CheckNoDuplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1StrictITIVector.html">StrictITIVector</a>&lt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>, bool &gt; *&#160;</td>
          <td class="paramname"><em>boolean_vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae06a99b7d06f0cd40e0d166c9033a9f9">CheckNoDuplicates()</a> except it uses a reusable boolean vector to make the code more efficient. Runs in O(num_entries). </p><dl class="section note"><dt>Note</dt><dd>boolean_vector should be initialized to false before calling this method; It will remain equal to false after calls to <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae06a99b7d06f0cd40e0d166c9033a9f9">CheckNoDuplicates()</a>. </dd>
<dd>
we use a mutable Boolean to make subsequent call runs in O(1). </dd></dl>
<p>Note(user): Using <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a118659107ff8fe0c31459ad296c7f72d" title="Note this method can only be used when the vector has no duplicates.">num_entries()</a> or any function that call <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae06a99b7d06f0cd40e0d166c9033a9f9">CheckNoDuplicates()</a> again will cause an infinite loop!</p>
<p>Update size if needed.</p>
<p>Reset boolean_vector to false.</p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00649">649</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="afb0952c189b9c921d79526b96295a2c8" name="afb0952c189b9c921d79526b96295a2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0952c189b9c921d79526b96295a2c8">&#9670;&#160;</a></span>CleanUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::CleanUp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans the vector, i.e. removes zero-values entries, removes duplicates entries and sorts remaining entries in increasing index order. Runs in O(num_entries * log(num_entries)). </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000799">Todo:</a></b></dt><dd>(user): Implement in-place sorting of the entries and cleanup. The current version converts the data to an array-of-pairs representation that can be sorted easily with std::stable_sort, and the converts the sorted data back to the struct-of-arrays implementation. The current version is ~20% slower than the in-place sort on the array-of-struct representation. It is not visible on GLOP benchmarks, but it increases peak memory usage by ~8%. Implementing in-place search will require either implementing a custom sorting code, or custom iterators that abstract away the internal representation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00551">551</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a95bae030fee9573298314a0ace2cec75" name="a95bae030fee9573298314a0ace2cec75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bae030fee9573298314a0ace2cec75">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::Clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the vector, i.e. removes all entries. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00486">486</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a787556a86e18fc0018ace32864ab6cca" name="a787556a86e18fc0018ace32864ab6cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787556a86e18fc0018ace32864ab6cca">&#9670;&#160;</a></span>ClearAndRelease()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::ClearAndRelease</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the vector and releases the memory it uses. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00492">492</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ab4b2c492beb0335dab369dddba5d3c37" name="ab4b2c492beb0335dab369dddba5d3c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b2c492beb0335dab369dddba5d3c37">&#9670;&#160;</a></span>ComponentWiseDivide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::ComponentWiseDivide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides all entries by its corresponding factor, i.e. entry.coefficient /= factors[entry.index]. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00798">798</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a4cd313597bd4e184e641e3f3199c879b" name="a4cd313597bd4e184e641e3f3199c879b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd313597bd4e184e641e3f3199c879b">&#9670;&#160;</a></span>ComponentWiseMultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::ComponentWiseMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies all entries by its corresponding factor, i.e. entry.coefficient *= factors[entry.index]. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00782">782</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="aef2d3fdba8ab62dc5d4782bc9234d385" name="aef2d3fdba8ab62dc5d4782bc9234d385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2d3fdba8ab62dc5d4782bc9234d385">&#9670;&#160;</a></span>CopyToDenseVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::CopyToDenseVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>num_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> *&#160;</td>
          <td class="paramname"><em>dense_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populates a dense vector from the sparse vector. Runs in O(num_indices) as the dense vector values have to be reset to 0.0. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00806">806</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a96ec76e954ad165db00ce7a123bf0f89" name="a96ec76e954ad165db00ce7a123bf0f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ec76e954ad165db00ce7a123bf0f89">&#9670;&#160;</a></span>DebugString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::DebugString</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An exhaustive, pretty-printed listing of the entries, in their internal order. a.DebugString() == b.DebugString() iff a.IsEqualTo(b). </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l01019">1019</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a926e7298a1f2e422fb38604e2facc21f" name="a926e7298a1f2e422fb38604e2facc21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926e7298a1f2e422fb38604e2facc21f">&#9670;&#160;</a></span>DeleteEntry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::DeleteEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an entry from the vector if present. The order of the other entries is preserved. Runs in O(num_entries). </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00699">699</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="acad0083c2f6044ed4f1ebd7b5b62c5ca" name="acad0083c2f6044ed4f1ebd7b5b62c5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad0083c2f6044ed4f1ebd7b5b62c5ca">&#9670;&#160;</a></span>DivideByConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::DivideByConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divides all entries by factor. i.e. entry.coefficient /= factor. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00790">790</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a96d33ef32a9c194add63c1fde30a50e3" name="a96d33ef32a9c194add63c1fde30a50e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d33ef32a9c194add63c1fde30a50e3">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00456">456</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="aa08d1ba6474874dea7e01e7185a9529c" name="aa08d1ba6474874dea7e01e7185a9529c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08d1ba6474874dea7e01e7185a9529c">&#9670;&#160;</a></span>GetCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::GetCoefficient </td>
          <td>(</td>
          <td class="paramtype">EntryIndex&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00352">352</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a1d7a2f9820def1574f18bbf609d86ff3" name="a1d7a2f9820def1574f18bbf609d86ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7a2f9820def1574f18bbf609d86ff3">&#9670;&#160;</a></span>GetFirstCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::GetFirstCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00286">286</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a75c9e369dc0834dfb944aa50558aeb70" name="a75c9e369dc0834dfb944aa50558aeb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c9e369dc0834dfb944aa50558aeb70">&#9670;&#160;</a></span>GetFirstIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::GetFirstIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first entry's index and coefficient; note that 'first' doesn't mean 'entry with the smallest index'. Runs in O(1). Note this method can only be used when the vector has no duplicates. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00282">282</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="af86678568efb9f5b9aee1b034b577e51" name="af86678568efb9f5b9aee1b034b577e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86678568efb9f5b9aee1b034b577e51">&#9670;&#160;</a></span>GetIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::GetIndex </td>
          <td>(</td>
          <td class="paramtype">EntryIndex&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read-only access to the indices and coefficients of the entries of the sparse vector. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00347">347</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ae20878f0786bb8d8c0a8c839c7292e5c" name="ae20878f0786bb8d8c0a8c839c7292e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20878f0786bb8d8c0a8c839c7292e5c">&#9670;&#160;</a></span>GetLastCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::GetLastCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00296">296</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ad5ca8690e61feacde9400bf46978a395" name="ad5ca8690e61feacde9400bf46978a395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ca8690e61feacde9400bf46978a395">&#9670;&#160;</a></span>GetLastIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::GetLastIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like GetFirst*, but for the last entry. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00292">292</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ac74a828355962a7387720b536b6bdd15" name="ac74a828355962a7387720b536b6bdd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74a828355962a7387720b536b6bdd15">&#9670;&#160;</a></span>IsCleanedUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::IsCleanedUp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the entries of this <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> are in strictly increasing index order and if the vector contains no duplicates nor zero coefficients. Runs in O(num_entries). It is not const because it modifies possibly_contains_duplicates_. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00587">587</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a83c72b464276dcf2ba155d80251f4202" name="a83c72b464276dcf2ba155d80251f4202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c72b464276dcf2ba155d80251f4202">&#9670;&#160;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::IsEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the vector is empty. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00536">536</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ae9ed62e96387e02a6365812690e6b7fe" name="ae9ed62e96387e02a6365812690e6b7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ed62e96387e02a6365812690e6b7fe">&#9670;&#160;</a></span>IsEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::IsEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this vector is exactly equal to the given one, i.e. all its index indices and coefficients appear in the same order and are equal. </p>
<p>We do not take into account the mutable value may_contain_duplicates_.</p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l01007">1007</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="afbae873b1b6a1f33cac11606834b6d0e" name="afbae873b1b6a1f33cac11606834b6d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbae873b1b6a1f33cac11606834b6d0e">&#9670;&#160;</a></span>LookUpCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::LookUpCoefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the coefficient at position index. Call with care: runs in O(number-of-entries) as entries may not be sorted. </p>
<p>Keep in mind the vector may contains several entries with the same index. In such a case the last one is returned. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000802">Todo:</a></b></dt><dd>(user): investigate whether an optimized version of LookUpCoefficient for "clean" columns yields speed-ups. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00991">991</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a1257f73f0c0ff73e821aec33dfbac598" name="a1257f73f0c0ff73e821aec33dfbac598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1257f73f0c0ff73e821aec33dfbac598">&#9670;&#160;</a></span>MoveEntryToFirstPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::MoveEntryToFirstPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the entry with given Index to the first position in the vector. If the entry is not present, nothing happens. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00747">747</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a9a0966e6b28455197163868d2920ff8b" name="a9a0966e6b28455197163868d2920ff8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0966e6b28455197163868d2920ff8b">&#9670;&#160;</a></span>MoveEntryToLastPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::MoveEntryToLastPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the entry with given Index to the last position in the vector. If the entry is not present, nothing happens. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00760">760</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ac8066cbc5d5b7f8e794677b027cd96a2" name="ac8066cbc5d5b7f8e794677b027cd96a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8066cbc5d5b7f8e794677b027cd96a2">&#9670;&#160;</a></span>MoveTaggedEntriesTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::MoveTaggedEntriesTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>index_perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the entries for which index_perm[index] is non-negative and appends them to output. Note that the index of the entries are NOT permuted. </p>
<dl class="section note"><dt>Note</dt><dd>this function is called many times, so performance does matter and it is why we optimized the "nothing to do" case.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000801">Todo:</a></b></dt><dd>(user): In the way we use this function, we know that will not happen, but it is better to be careful so we can check that properly in debug mode. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00961">961</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="adad3d6118e2d5851a8e15ac6733fdb04" name="adad3d6118e2d5851a8e15ac6733fdb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad3d6118e2d5851a8e15ac6733fdb04">&#9670;&#160;</a></span>MultiplyByConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::MultiplyByConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies all entries by factor. i.e. entry.coefficient *= factor. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00774">774</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="abb9bf37adc39b8418a6035e7aa181d2e" name="abb9bf37adc39b8418a6035e7aa181d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9bf37adc39b8418a6035e7aa181d2e">&#9670;&#160;</a></span>MutableCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a> &amp; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::MutableCoefficient </td>
          <td>(</td>
          <td class="paramtype">EntryIndex&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00365">365</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ad3323546eab84bd0887b14821d54ef9e" name="ad3323546eab84bd0887b14821d54ef9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3323546eab84bd0887b14821d54ef9e">&#9670;&#160;</a></span>MutableIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a> &amp; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::MutableIndex </td>
          <td>(</td>
          <td class="paramtype">EntryIndex&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutable access to the indices and coefficients of the entries of the sparse vector. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00360">360</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a118659107ff8fe0c31459ad296c7f72d" name="a118659107ff8fe0c31459ad296c7f72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118659107ff8fe0c31459ad296c7f72d">&#9670;&#160;</a></span>num_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EntryIndex <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::num_entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note this method can only be used when the vector has no duplicates. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00273">273</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a7a7a9e3bec9b51c7da9dcba8070b496c" name="a7a7a9e3bec9b51c7da9dcba8070b496c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7a9e3bec9b51c7da9dcba8070b496c">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00480">480</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a106991245e0aff64298d2db9ab1348ab" name="a106991245e0aff64298d2db9ab1348ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106991245e0aff64298d2db9ab1348ab">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a> &amp; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcac5a2f6d6ac61d04c8e1f31411919a" name="adcac5a2f6d6ac61d04c8e1f31411919a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcac5a2f6d6ac61d04c8e1f31411919a">&#9670;&#160;</a></span>PermutedCopyToDenseVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::PermutedCopyToDenseVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#abfcfccfaf0aa53fac439442676718dad">IndexPermutation</a> &amp;&#160;</td>
          <td class="paramname"><em>index_perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>num_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> *&#160;</td>
          <td class="paramname"><em>dense_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populates a dense vector from the permuted sparse vector. Runs in O(num_indices) as the dense vector values have to be reset to 0.0. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00816">816</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ac0d81341bcace205399732fde5dbb3cf" name="ac0d81341bcace205399732fde5dbb3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d81341bcace205399732fde5dbb3cf">&#9670;&#160;</a></span>PopulateFromDenseVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::PopulateFromDenseVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populates the current vector from dense_vector. Runs in O(num_indices_in_dense_vector). </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00625">625</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a4de8ae60841ab8f3ff08b69507852bbc" name="a4de8ae60841ab8f3ff08b69507852bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de8ae60841ab8f3ff08b69507852bbc">&#9670;&#160;</a></span>PopulateFromSparseVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::PopulateFromSparseVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>sparse_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populates the current vector from sparse_vector. Runs in O(num_entries). </p>
<p>Clear the sparse vector before reserving the new capacity. If we didn't do this, Reserve would have to copy the current contents of the vector if it allocated a new buffer. This would be wasteful, since we overwrite it in the next step anyway.</p>
<p>If there are no entries, then sparse_vector.index_ or .coefficient_ may be nullptr or invalid, and accessing them in memmove is UB, even if the moved size is zero.</p>
<p>NOTE(user): Using a single memmove would be slightly faster, but it would not work correctly if this already had a greater capacity than sparse_vector, because the coefficient_ pointer would be positioned incorrectly.</p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00599">599</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a063a66ff363cb24cfdde29d9d890365b" name="a063a66ff363cb24cfdde29d9d890365b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063a66ff363cb24cfdde29d9d890365b">&#9670;&#160;</a></span>RemoveNearZeroEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::RemoveNearZeroEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to 0.0 (i.e. remove) all entries whose fabs() is lower or equal to the given threshold. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00716">716</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a7b51bb8727f85df9198481f762f247d9" name="a7b51bb8727f85df9198481f762f247d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b51bb8727f85df9198481f762f247d9">&#9670;&#160;</a></span>RemoveNearZeroEntriesWithWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::RemoveNearZeroEntriesWithWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a38c031d168b70a7966cb28608543423c">DenseVector</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as RemoveNearZeroEntries, but the entry magnitude of each row is multiplied by weights[row] before being compared with threshold. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00732">732</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="acd919747388eab4fd137af29ed60653b" name="acd919747388eab4fd137af29ed60653b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd919747388eab4fd137af29ed60653b">&#9670;&#160;</a></span>Reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::Reserve </td>
          <td>(</td>
          <td class="paramtype">EntryIndex&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve the underlying storage for the given number of entries. </p>
<p>Round up the capacity to a multiple of four. This way, the start of the coefficient array will be aligned to 16-bytes, provided that the buffer used for storing the data is aligned in that way.</p>
<p>Avoid copying the data if the vector is empty.</p>
<p>NOTE(user): We use memmove instead of std::copy, because the latter leads to naive copying code when used with strong ints (a loop that copies a single 32-bit value in each iteration), and as of 06/2016, memmove is 3-4x faster on Haswell.</p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00502">502</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="aa403826e7986ab9ce2c68c0f27404b3d" name="aa403826e7986ab9ce2c68c0f27404b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa403826e7986ab9ce2c68c0f27404b3d">&#9670;&#160;</a></span>ResizeDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::ResizeDown </td>
          <td>(</td>
          <td class="paramtype">EntryIndex&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the sparse vector to a smaller size, without re-allocating the internal storage. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00339">339</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="ab68c2b45ba21cb0a49e6c174cbfadc9f" name="ab68c2b45ba21cb0a49e6c174cbfadc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68c2b45ba21cb0a49e6c174cbfadc9f">&#9670;&#160;</a></span>SetCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::SetCoefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the coefficient at index, i.e. vector[index] = value;. </p>
<p>Do not filter out zero values, as a zero value can be added to reset a previous value. Zero values and duplicates will be removed by CleanUp. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00692">692</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a0482bae6353661bcadb00b0c799ef744" name="a0482bae6353661bcadb00b0c799ef744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0482bae6353661bcadb00b0c799ef744">&#9670;&#160;</a></span>Swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a>&lt; IndexType, IteratorType &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the content of this sparse vector with the one passed as argument. Works in O(1). </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00541">541</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acfde05c6fddd3f82b855b7c6d1f396f8" name="acfde05c6fddd3f82b855b7c6d1f396f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfde05c6fddd3f82b855b7c6d1f396f8">&#9670;&#160;</a></span>buffer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;char[]&gt; <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::buffer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The internal storage of the sparse vector. Both the indices and the coefficients are stored in the same buffer; the first sizeof(Index)*capacity_ bytes are used for storing the indices, the following sizeof(Fractional)*capacity_ bytes contain the values. This representation ensures that for small vectors, both the indices and the coefficients are in the same page/cache line. We use a single buffer for both arrays. The amount of data copied during relocations is the same in both cases, and it is much smaller than the cost of an additional allocation - especially when the vectors are small. Moreover, using two separate vectors/buffers would mean that even small vectors would be spread across at least two different cache lines. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00382">382</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a5340312c5955bd057c13dabe398f9bf5" name="a5340312c5955bd057c13dabe398f9bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5340312c5955bd057c13dabe398f9bf5">&#9670;&#160;</a></span>capacity_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EntryIndex <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::capacity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00384">384</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a079ca448e72034a09503ed79f4c46a85" name="a079ca448e72034a09503ed79f4c46a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ca448e72034a09503ed79f4c46a85">&#9670;&#160;</a></span>coefficient_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research_1_1glop.html#a0cac235bd48eb39d15cc101516dc1e90">Fractional</a>* <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::coefficient_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00388">388</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="aa9eb9fe4370fab3b2ffb59f076b3e7b1" name="aa9eb9fe4370fab3b2ffb59f076b3e7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eb9fe4370fab3b2ffb59f076b3e7b1">&#9670;&#160;</a></span>index_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#a783efd95525f21afc8045cdb1e9eb00a">Index</a>* <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::index_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointers to the first elements of the index and coefficient arrays. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00387">387</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a905f925c4884ff9c163e630ffef925c9" name="a905f925c4884ff9c163e630ffef925c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905f925c4884ff9c163e630ffef925c9">&#9670;&#160;</a></span>may_contain_duplicates_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::may_contain_duplicates_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is here to speed up the <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html#ae06a99b7d06f0cd40e0d166c9033a9f9">CheckNoDuplicates()</a> methods and is mutable so we can perform checks on const argument. </p>

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00392">392</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<a id="a92bee34a6dd340eb0c130b29e1c68b33" name="a92bee34a6dd340eb0c130b29e1c68b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bee34a6dd340eb0c130b29e1c68b33">&#9670;&#160;</a></span>num_entries_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename IteratorType  = VectorIterator&lt;SparseVectorEntry&lt;IndexType&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EntryIndex <a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">operations_research::glop::SparseVector</a>&lt; IndexType, IteratorType &gt;::num_entries_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lp__data_2sparse__vector_8h_source.html#l00383">383</a> of file <a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ortools/lp_data/<a class="el" href="lp__data_2sparse__vector_8h_source.html">sparse_vector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1glop.html">glop</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1glop_1_1SparseVector.html">SparseVector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
