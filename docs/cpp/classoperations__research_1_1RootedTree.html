<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::RootedTree&lt; NodeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.12</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1RootedTree.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classoperations__research_1_1RootedTree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::RootedTree&lt; NodeType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4049f5904a26c840abc6bb431b550d03" id="r_a4049f5904a26c840abc6bb431b550d03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4049f5904a26c840abc6bb431b550d03">RootedTree</a> (NodeType <a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f">root</a>, std::vector&lt; NodeType &gt; <a class="el" href="#a724c8698eccaca79def747e32e116bca">parents</a>)</td></tr>
<tr class="memdesc:a4049f5904a26c840abc6bb431b550d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="#ade974daabf3c2e52ea600e1189cfbc89">Create()</a>, but data is not validated (UB on bad input).  <br /></td></tr>
<tr class="separator:a4049f5904a26c840abc6bb431b550d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55ef899cfc8c9fd88225bdb049b515f" id="r_aa55ef899cfc8c9fd88225bdb049b515f"><td class="memItemLeft" align="right" valign="top">NodeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f">root</a> () const</td></tr>
<tr class="memdesc:aa55ef899cfc8c9fd88225bdb049b515f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root node of this rooted tree.  <br /></td></tr>
<tr class="separator:aa55ef899cfc8c9fd88225bdb049b515f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ab258d96a2a50808380b8a3f3b76cb" id="r_aa5ab258d96a2a50808380b8a3f3b76cb"><td class="memItemLeft" align="right" valign="top">NodeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb">num_nodes</a> () const</td></tr>
<tr class="memdesc:aa5ab258d96a2a50808380b8a3f3b76cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in this rooted tree.  <br /></td></tr>
<tr class="separator:aa5ab258d96a2a50808380b8a3f3b76cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724c8698eccaca79def747e32e116bca" id="r_a724c8698eccaca79def747e32e116bca"><td class="memItemLeft" align="right" valign="top">absl::Span&lt; const NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents</a> () const</td></tr>
<tr class="separator:a724c8698eccaca79def747e32e116bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd4765096274b9231b2214bf57450e3" id="r_a5fd4765096274b9231b2214bf57450e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd4765096274b9231b2214bf57450e3">PathToRoot</a> (NodeType node) const</td></tr>
<tr class="separator:a5fd4765096274b9231b2214bf57450e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f5dabc41bfd43771c5f6762f3d3591" id="r_ac7f5dabc41bfd43771c5f6762f3d3591"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f5dabc41bfd43771c5f6762f3d3591">PathFromRoot</a> (NodeType node) const</td></tr>
<tr class="separator:ac7f5dabc41bfd43771c5f6762f3d3591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128a439860546245cdc85efb04b1c5e5" id="r_a128a439860546245cdc85efb04b1c5e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a128a439860546245cdc85efb04b1c5e5">DistanceToRoot</a> (NodeType start, absl::Span&lt; const double &gt; arc_lengths) const</td></tr>
<tr class="separator:a128a439860546245cdc85efb04b1c5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c3fc5deed861a90f45cce29fd20153" id="r_af1c3fc5deed861a90f45cce29fd20153"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, std::vector&lt; NodeType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c3fc5deed861a90f45cce29fd20153">DistanceAndPathToRoot</a> (NodeType start, absl::Span&lt; const double &gt; arc_lengths) const</td></tr>
<tr class="separator:af1c3fc5deed861a90f45cce29fd20153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26ddfc79499d26ea845cf14c148caeb" id="r_af26ddfc79499d26ea845cf14c148caeb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af26ddfc79499d26ea845cf14c148caeb">Path</a> (NodeType start, NodeType end, NodeType lca) const</td></tr>
<tr class="separator:af26ddfc79499d26ea845cf14c148caeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7fb1272cf6a922bbffd9e62bf85b61" id="r_a3f7fb1272cf6a922bbffd9e62bf85b61"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f7fb1272cf6a922bbffd9e62bf85b61">Distance</a> (NodeType start, NodeType end, NodeType lca, absl::Span&lt; const double &gt; arc_lengths) const</td></tr>
<tr class="separator:a3f7fb1272cf6a922bbffd9e62bf85b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f4634df539aa73b35ccd11c152ba31" id="r_a62f4634df539aa73b35ccd11c152ba31"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, std::vector&lt; NodeType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62f4634df539aa73b35ccd11c152ba31">DistanceAndPath</a> (NodeType start, NodeType end, NodeType lca, absl::Span&lt; const double &gt; arc_lengths) const</td></tr>
<tr class="separator:a62f4634df539aa73b35ccd11c152ba31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aff8514d3518186624924df30d967a" id="r_ac0aff8514d3518186624924df30d967a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0aff8514d3518186624924df30d967a">DistanceOfPath</a> (absl::Span&lt; const NodeType &gt; path, absl::Span&lt; const double &gt; arc_lengths) const</td></tr>
<tr class="separator:ac0aff8514d3518186624924df30d967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa669a5f9743b25bc50baa66521c85471" id="r_aa669a5f9743b25bc50baa66521c85471"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa669a5f9743b25bc50baa66521c85471">TopologicalSort</a> () const</td></tr>
<tr class="separator:aa669a5f9743b25bc50baa66521c85471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d56158b298dd44e49875371d07d78c" id="r_aa3d56158b298dd44e49875371d07d78c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa3d56158b298dd44e49875371d07d78c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3d56158b298dd44e49875371d07d78c">AllDistancesToRoot</a> (absl::Span&lt; const T &gt; arc_lengths) const</td></tr>
<tr class="separator:aa3d56158b298dd44e49875371d07d78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd262d42955547a669b8be22ecfefa7" id="r_a8bd262d42955547a669b8be22ecfefa7"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a8bd262d42955547a669b8be22ecfefa7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8bd262d42955547a669b8be22ecfefa7">AllDistancesToRoot</a> (absl::Span&lt; const T &gt; arc_lengths, absl::Span&lt; const NodeType &gt; topological_order) const</td></tr>
<tr class="separator:a8bd262d42955547a669b8be22ecfefa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a378d2c68082ff7b20e1344bb1192af" id="r_a9a378d2c68082ff7b20e1344bb1192af"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a378d2c68082ff7b20e1344bb1192af">AllDepths</a> () const</td></tr>
<tr class="separator:a9a378d2c68082ff7b20e1344bb1192af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30050d5627e2c29f7bad2d94481acfb" id="r_aa30050d5627e2c29f7bad2d94481acfb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30050d5627e2c29f7bad2d94481acfb">AllDepths</a> (absl::Span&lt; const NodeType &gt; topological_order) const</td></tr>
<tr class="separator:aa30050d5627e2c29f7bad2d94481acfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f18fab9aa4478128078cf0aea9c412b" id="r_a7f18fab9aa4478128078cf0aea9c412b"><td class="memItemLeft" align="right" valign="top">NodeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f18fab9aa4478128078cf0aea9c412b">LowestCommonAncestorByDepth</a> (NodeType n1, NodeType n2, absl::Span&lt; const NodeType &gt; depths) const</td></tr>
<tr class="separator:a7f18fab9aa4478128078cf0aea9c412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a2235124d31e08e8fe12ad5d43cbcf" id="r_a81a2235124d31e08e8fe12ad5d43cbcf"><td class="memItemLeft" align="right" valign="top">NodeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81a2235124d31e08e8fe12ad5d43cbcf">LowestCommonAncestorBySearch</a> (NodeType n1, NodeType n2, std::vector&lt; bool &gt; &amp;visited_workspace) const</td></tr>
<tr class="separator:a81a2235124d31e08e8fe12ad5d43cbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebce6f41bf6a10d58d3c640a716ec3ee" id="r_aebce6f41bf6a10d58d3c640a716ec3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebce6f41bf6a10d58d3c640a716ec3ee">Evert</a> (NodeType new_root)</td></tr>
<tr class="separator:aebce6f41bf6a10d58d3c640a716ec3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ade974daabf3c2e52ea600e1189cfbc89" id="r_ade974daabf3c2e52ea600e1189cfbc89"><td class="memItemLeft" align="right" valign="top">static absl::StatusOr&lt; <a class="el" href="classoperations__research_1_1RootedTree.html">RootedTree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade974daabf3c2e52ea600e1189cfbc89">Create</a> (NodeType <a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f">root</a>, std::vector&lt; NodeType &gt; <a class="el" href="#a724c8698eccaca79def747e32e116bca">parents</a>, std::vector&lt; NodeType &gt; *error_cycle=nullptr, std::vector&lt; NodeType &gt; *topological_order=nullptr)</td></tr>
<tr class="separator:ade974daabf3c2e52ea600e1189cfbc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8dc5bcad8efdd72daa51fbec588deb0e" id="r_a8dc5bcad8efdd72daa51fbec588deb0e"><td class="memItemLeft" align="right" valign="top">static constexpr NodeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dc5bcad8efdd72daa51fbec588deb0e">kNullParent</a> = static_cast&lt;NodeType&gt;(-1)</td></tr>
<tr class="separator:a8dc5bcad8efdd72daa51fbec588deb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename NodeType = int32_t&gt;<br />
class operations_research::RootedTree&lt; NodeType &gt;</div><p>A tree is an undirected graph with no cycles, n nodes, and n-1 undirected edges. Consequently, a tree is connected. Given a tree on the nodes [0..n), a <a class="el" href="classoperations__research_1_1RootedTree.html">RootedTree</a> picks any node to be the root, and then converts all edges into (directed) arcs pointing at the root. Each node has one outgoing edge, so we can store the adjacency list of this directed view of the graph as a single vector of integers with length equal to the number of nodes. At the root index, we store <a class="el" href="#a8dc5bcad8efdd72daa51fbec588deb0e">RootedTree::kNullParent</a>=-1, and at every other index, we store the next node towards the root (the parent in the tree).</p>
<p>This class is templated on the NodeType, which must be an integer type, e.g., int or int32_t (signed and unsigned types both work).</p>
<p>The following operations are supported:</p><ul>
<li>Path from node to root in O(path length to root)</li>
<li>Lowest Common Ancestor (LCA) of two nodes in O(path length between nodes)</li>
<li>Depth of all nodes in O(num nodes)</li>
<li>Topological sort in O(num nodes)</li>
<li>Path between any two nodes in O(path length between nodes)</li>
</ul>
<p>Users can provide a vector&lt;double&gt; of arc lengths (indexed by source) to get:</p><ul>
<li>Distance from node to root in O(path length to root)</li>
<li>Distance from all nodes to root in O(num nodes)</li>
<li>Distance between any two nodes in O(path length between nodes)</li>
</ul>
<p>Operations on rooted trees are generally more efficient than on adjacency list representations because the entire tree is in one contiguous allocation. There is also an asymptotic advantage on path finding problems.</p>
<p>Two methods for finding the LCA are provided. The first requires the depth of every node ahead of time. The second requires a workspace of n bools, all starting at false. These values are modified and restored to false when the LCA computation finishes. In both cases, if the depths/workspace allocation is an O(n) precomputation, then the LCA runs in O(path length). Non-asymptotically, the depth method requires more precomputation, but the LCA is faster and does not require the user to manage mutable state (i.e., may be better for multi-threaded computation).</p>
<p>An operation that is missing is bulk LCA, see <a href="https://en.wikipedia.org/wiki/Tarjan%27s_off-line_lowest_common_ancestors_algorithm">https://en.wikipedia.org/wiki/Tarjan%27s_off-line_lowest_common_ancestors_algorithm</a>. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00087">87</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4049f5904a26c840abc6bb431b550d03" name="a4049f5904a26c840abc6bb431b550d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4049f5904a26c840abc6bb431b550d03">&#9670;&#160;</a></span>RootedTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType = int32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::RootedTree </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NodeType &gt;</td>          <td class="paramname"><span class="paramname"><em>parents</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="#ade974daabf3c2e52ea600e1189cfbc89">Create()</a>, but data is not validated (UB on bad input). </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00104">104</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a378d2c68082ff7b20e1344bb1192af" name="a9a378d2c68082ff7b20e1344bb1192af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a378d2c68082ff7b20e1344bb1192af">&#9670;&#160;</a></span>AllDepths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType = int32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::AllDepths </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance (arcs to move over) from every node to the root.</p>
<p>If you already have a topological order, prefer AllDepths(absl::Span&lt;const NodeType&gt;). </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00231">231</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="aa30050d5627e2c29f7bad2d94481acfb" name="aa30050d5627e2c29f7bad2d94481acfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30050d5627e2c29f7bad2d94481acfb">&#9670;&#160;</a></span>AllDepths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::AllDepths </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const NodeType &gt;</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance (arcs to move over) from every node to the root.</p>
<p><code>topological_order</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> and start with <code><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a></code>, or else we CHECK fail. It can be any topological over nodes when the orientation of the arcs from rooting the tree is reversed. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00720">720</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="aa3d56158b298dd44e49875371d07d78c" name="aa3d56158b298dd44e49875371d07d78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d56158b298dd44e49875371d07d78c">&#9670;&#160;</a></span>AllDistancesToRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::AllDistancesToRoot </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_lengths</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance of every node from <code><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a></code>, if the edge leaving node i has length costs[i].</p>
<p><code>arc_lengths[i]</code> is the length of the arc from node i to <code><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[i]</code>. <code>arc_lengths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> or else we CHECK fail. The value of <code>arc_lengths[<a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>]</code> is unused.</p>
<p>If you already have a topological order, prefer <code>AllDistances(absl::Span&lt;const double&gt; costs, / absl::Span&lt;const int&gt;&amp; topological_order)</code>. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00730">730</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a8bd262d42955547a669b8be22ecfefa7" name="a8bd262d42955547a669b8be22ecfefa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd262d42955547a669b8be22ecfefa7">&#9670;&#160;</a></span>AllDistancesToRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::AllDistancesToRoot </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_lengths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const NodeType &gt;</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the distance from every node to <a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>.</p>
<p><code>arc_lengths[i]</code> is the length of the arc from node i to <code><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[i]</code>. <code>arc_lengths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> or else we CHECK fail. The value of <code>arc_lengths[<a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>]</code> is unused.</p>
<p><code>topological_order</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> and start with <code><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a></code>, or else we CHECK fail. It can be any topological over nodes when the orientation of the arcs from rooting the tree is reversed. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00737">737</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="ade974daabf3c2e52ea600e1189cfbc89" name="ade974daabf3c2e52ea600e1189cfbc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade974daabf3c2e52ea600e1189cfbc89">&#9670;&#160;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::StatusOr&lt; <a class="el" href="classoperations__research_1_1RootedTree.html">RootedTree</a>&lt; NodeType &gt; &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::Create </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NodeType &gt;</td>          <td class="paramname"><span class="paramname"><em>parents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NodeType &gt; *</td>          <td class="paramname"><span class="paramname"><em>error_cycle</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NodeType &gt; *</td>          <td class="paramname"><span class="paramname"><em>topological_order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the constructor but checks that the tree is valid. Uses O(num nodes) temporary space with O(log(n)) allocations.</p>
<p>If the input is cyclic, an InvalidArgument error will be returned with "cycle" as a substring. Further, if error_cycle is not null, it will be cleared and then set to contain the cycle. We will not modify error cycle or return an error message containing the string cycle if there is no cycle. The cycle output will always begin with its smallest element. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00465">465</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a3f7fb1272cf6a922bbffd9e62bf85b61" name="a3f7fb1272cf6a922bbffd9e62bf85b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7fb1272cf6a922bbffd9e62bf85b61">&#9670;&#160;</a></span>Distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::Distance </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>lca</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_lengths</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the arc lengths of the arcs in the path from <code>start</code> to <code>end</code>.</p>
<p><code>lca</code> is the lowest common ancestor of <code>start</code> and <code>end</code>. This can be computed using <a class="el" href="#a7f18fab9aa4478128078cf0aea9c412b">LowestCommonAncestorByDepth()</a> or <a class="el" href="#a7f18fab9aa4478128078cf0aea9c412b">LowestCommonAncestorByDepth()</a>, both defined on this class.</p>
<p><code>arc_lengths[i]</code> is the length of the arc from node i to <code><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[i]</code>. <code>arc_lengths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> or else we CHECK fail. The value of <code>arc_lengths[<a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>]</code> is unused.</p>
<p>Runs in time O(number of edges connecting start to end). </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00570">570</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a62f4634df539aa73b35ccd11c152ba31" name="a62f4634df539aa73b35ccd11c152ba31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f4634df539aa73b35ccd11c152ba31">&#9670;&#160;</a></span>DistanceAndPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, std::vector&lt; NodeType &gt; &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::DistanceAndPath </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>lca</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_lengths</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path from <code>start</code> to <code>end</code> as a vector of nodes starting with <code>start</code>, and the sum of the arc lengths of the arcs in the path.</p>
<p><code>lca</code> is the lowest common ancestor of <code>start</code> and <code>end</code>. This can be computed using <a class="el" href="#a7f18fab9aa4478128078cf0aea9c412b">LowestCommonAncestorByDepth()</a> or <a class="el" href="#a7f18fab9aa4478128078cf0aea9c412b">LowestCommonAncestorByDepth()</a>, both defined on this class.</p>
<p><code>arc_lengths[i]</code> is the length of the arc from node i to <code><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[i]</code>. <code>arc_lengths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> or else we CHECK fail. The value of <code>arc_lengths[<a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>]</code> is unused.</p>
<p>Runs in time O(number of edges connecting start to end). </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00578">578</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="af1c3fc5deed861a90f45cce29fd20153" name="af1c3fc5deed861a90f45cce29fd20153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c3fc5deed861a90f45cce29fd20153">&#9670;&#160;</a></span>DistanceAndPathToRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, std::vector&lt; NodeType &gt; &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::DistanceAndPathToRoot </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_lengths</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path from <code>start</code> to <code><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a></code> as a vector of nodes starting with <code>start</code>, and the sum of the arc lengths of the arcs in the path.</p>
<p><code>arc_lengths[i]</code> is the length of the arc from node i to <code><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[i]</code>. <code>arc_lengths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> or else we CHECK fail. The value of <code>arc_lengths[<a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>]</code> is unused. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00533">533</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="ac0aff8514d3518186624924df30d967a" name="ac0aff8514d3518186624924df30d967a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0aff8514d3518186624924df30d967a">&#9670;&#160;</a></span>DistanceOfPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::DistanceOfPath </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const NodeType &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_lengths</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a path of nodes, returns the sum of the length of the arcs connecting them.</p>
<p><code>path</code> must be a list of nodes in the tree where path[i+1] == <a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[path[i]].</p>
<p><code>arc_lengths[i]</code> is the length of the arc from node i to <code><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[i]</code>. <code>arc_lengths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> or else we CHECK fail. The value of <code>arc_lengths[<a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>]</code> is unused. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00587">587</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a128a439860546245cdc85efb04b1c5e5" name="a128a439860546245cdc85efb04b1c5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128a439860546245cdc85efb04b1c5e5">&#9670;&#160;</a></span>DistanceToRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::DistanceToRoot </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const double &gt;</td>          <td class="paramname"><span class="paramname"><em>arc_lengths</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of the arc lengths of the arcs in the path from <code>start</code> to <code><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a></code>.</p>
<p><code>arc_lengths[i]</code> is the length of the arc from node i to <code><a class="el" href="#a724c8698eccaca79def747e32e116bca">parents()</a>[i]</code>. <code>arc_lengths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code> or else we CHECK fail. The value of <code>arc_lengths[<a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a>]</code> is unused. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00526">526</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="aebce6f41bf6a10d58d3c640a716ec3ee" name="aebce6f41bf6a10d58d3c640a716ec3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebce6f41bf6a10d58d3c640a716ec3ee">&#9670;&#160;</a></span>Evert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::Evert </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>new_root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modifies the tree in place to change the root. Runs in O(path length from root() to new_root). </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00688">688</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a7f18fab9aa4478128078cf0aea9c412b" name="a7f18fab9aa4478128078cf0aea9c412b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f18fab9aa4478128078cf0aea9c412b">&#9670;&#160;</a></span>LowestCommonAncestorByDepth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodeType <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::LowestCommonAncestorByDepth </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>n1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>n2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const NodeType &gt;</td>          <td class="paramname"><span class="paramname"><em>depths</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lowest common ancestor of n1 and n2.</p>
<p><code>depths</code> must have size equal to <code><a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a></code>, or else we CHECK fail. Values must be the distance of each node to the root in arcs (see <a class="el" href="#a9a378d2c68082ff7b20e1344bb1192af">AllDepths()</a>). </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00606">606</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a81a2235124d31e08e8fe12ad5d43cbcf" name="a81a2235124d31e08e8fe12ad5d43cbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a2235124d31e08e8fe12ad5d43cbcf">&#9670;&#160;</a></span>LowestCommonAncestorBySearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NodeType <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::LowestCommonAncestorBySearch </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>n1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>n2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>visited_workspace</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lowest common ancestor of n1 and n2.</p>
<p><code>visited_workspace</code> must be a vector with <a class="el" href="#aa5ab258d96a2a50808380b8a3f3b76cb" title="The number of nodes in this rooted tree.">num_nodes()</a> size, or else we CHECK fail. All values of <code>visited_workspace</code> should be false. It will be modified and then restored to its starting state. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00636">636</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="aa5ab258d96a2a50808380b8a3f3b76cb" name="aa5ab258d96a2a50808380b8a3f3b76cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ab258d96a2a50808380b8a3f3b76cb">&#9670;&#160;</a></span>num_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType = int32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeType <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::num_nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of nodes in this rooted tree. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00111">111</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a724c8698eccaca79def747e32e116bca" name="a724c8698eccaca79def747e32e116bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724c8698eccaca79def747e32e116bca">&#9670;&#160;</a></span>parents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType = int32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Span&lt; const NodeType &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::parents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector that holds the parent of each non root node, and kNullParent at the root. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00115">115</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="af26ddfc79499d26ea845cf14c148caeb" name="af26ddfc79499d26ea845cf14c148caeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26ddfc79499d26ea845cf14c148caeb">&#9670;&#160;</a></span>Path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::Path </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>lca</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path from <code>start</code> to <code>end</code> as a vector of nodes starting with <code>start</code> and ending with <code>end</code>.</p>
<p><code>lca</code> is the lowest common ancestor of <code>start</code> and <code>end</code>. This can be computed using <a class="el" href="#a7f18fab9aa4478128078cf0aea9c412b">LowestCommonAncestorByDepth()</a> or <a class="el" href="#a7f18fab9aa4478128078cf0aea9c412b">LowestCommonAncestorByDepth()</a>, both defined on this class.</p>
<p>Runs in time O(path length). </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00547">547</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="ac7f5dabc41bfd43771c5f6762f3d3591" name="ac7f5dabc41bfd43771c5f6762f3d3591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f5dabc41bfd43771c5f6762f3d3591">&#9670;&#160;</a></span>PathFromRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::PathFromRoot </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path from <code><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a></code> to <code>node</code> as a vector of nodes starting with <code>node</code>. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00508">508</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="a5fd4765096274b9231b2214bf57450e3" name="a5fd4765096274b9231b2214bf57450e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd4765096274b9231b2214bf57450e3">&#9670;&#160;</a></span>PathToRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::PathToRoot </td>
          <td>(</td>
          <td class="paramtype">NodeType</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path from <code>node</code> to <code><a class="el" href="#aa55ef899cfc8c9fd88225bdb049b515f" title="The root node of this rooted tree.">root()</a></code> as a vector of nodes starting with <code>node</code>. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00497">497</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="aa55ef899cfc8c9fd88225bdb049b515f" name="aa55ef899cfc8c9fd88225bdb049b515f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55ef899cfc8c9fd88225bdb049b515f">&#9670;&#160;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType = int32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeType <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The root node of this rooted tree. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00108">108</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<a id="aa669a5f9743b25bc50baa66521c85471" name="aa669a5f9743b25bc50baa66521c85471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa669a5f9743b25bc50baa66521c85471">&#9670;&#160;</a></span>TopologicalSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NodeType &gt; <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::TopologicalSort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a topological ordering of the nodes where the root is first and every other node appears after its parent. </p>

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00516">516</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8dc5bcad8efdd72daa51fbec588deb0e" name="a8dc5bcad8efdd72daa51fbec588deb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc5bcad8efdd72daa51fbec588deb0e">&#9670;&#160;</a></span>kNullParent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType = int32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeType <a class="el" href="classoperations__research_1_1RootedTree.html">operations_research::RootedTree</a>&lt; NodeType &gt;::kNullParent = static_cast&lt;NodeType&gt;(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="rooted__tree_8h_source.html#l00089">89</a> of file <a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ortools/graph/<a class="el" href="rooted__tree_8h_source.html">rooted_tree.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1RootedTree.html">RootedTree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
