<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: operations_research::sat::CpModelMapping Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.9</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classoperations__research_1_1sat_1_1CpModelMapping.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classoperations__research_1_1sat_1_1CpModelMapping-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">operations_research::sat::CpModelMapping Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a79f03b471d74d225235179c6de80e97b" id="r_a79f03b471d74d225235179c6de80e97b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79f03b471d74d225235179c6de80e97b">IsBoolean</a> (int ref) const</td></tr>
<tr class="separator:a79f03b471d74d225235179c6de80e97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2061423a87ee2e08762711e9ba7235" id="r_a7a2061423a87ee2e08762711e9ba7235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2061423a87ee2e08762711e9ba7235">IsInteger</a> (int ref) const</td></tr>
<tr class="separator:a7a2061423a87ee2e08762711e9ba7235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0641a3ce3460bebb7c09b9f8100e1c" id="r_a4f0641a3ce3460bebb7c09b9f8100e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">sat::Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f0641a3ce3460bebb7c09b9f8100e1c">Literal</a> (int ref) const</td></tr>
<tr class="separator:a4f0641a3ce3460bebb7c09b9f8100e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca100c15df08addef3dcb51c1caa822" id="r_aeca100c15df08addef3dcb51c1caa822"><td class="memItemLeft" align="right" valign="top">IntegerVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeca100c15df08addef3dcb51c1caa822">Integer</a> (int ref) const</td></tr>
<tr class="separator:aeca100c15df08addef3dcb51c1caa822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58809f5b0a739fa62cf923b2ed919df5" id="r_a58809f5b0a739fa62cf923b2ed919df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58809f5b0a739fa62cf923b2ed919df5">Affine</a> (const LinearExpressionProto &amp;exp) const</td></tr>
<tr class="separator:a58809f5b0a739fa62cf923b2ed919df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0278bd96db6d4ec1eb86faf469b973" id="r_add0278bd96db6d4ec1eb86faf469b973"><td class="memItemLeft" align="right" valign="top">IntervalVariable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add0278bd96db6d4ec1eb86faf469b973">Interval</a> (int <a class="el" href="namespaceoperations__research_1_1sat.html#ab0c36038a18f65060a8232934b26cb7e">i</a>) const</td></tr>
<tr class="separator:add0278bd96db6d4ec1eb86faf469b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b2f0ae3351898e0cfa8bf6e2838cb2" id="r_a54b2f0ae3351898e0cfa8bf6e2838cb2"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:a54b2f0ae3351898e0cfa8bf6e2838cb2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IntegerVariable &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54b2f0ae3351898e0cfa8bf6e2838cb2">Integers</a> (const List &amp;list) const</td></tr>
<tr class="separator:a54b2f0ae3351898e0cfa8bf6e2838cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b496238831906b4107850c1a94599f" id="r_ad8b496238831906b4107850c1a94599f"><td class="memTemplParams" colspan="2">template&lt;typename ProtoIndices &gt; </td></tr>
<tr class="memitem:ad8b496238831906b4107850c1a94599f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">sat::Literal</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8b496238831906b4107850c1a94599f">Literals</a> (const ProtoIndices &amp;indices) const</td></tr>
<tr class="separator:ad8b496238831906b4107850c1a94599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc26436f6b8e54c313eb8b3e224af018" id="r_adc26436f6b8e54c313eb8b3e224af018"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:adc26436f6b8e54c313eb8b3e224af018"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc26436f6b8e54c313eb8b3e224af018">Affines</a> (const List &amp;list) const</td></tr>
<tr class="separator:adc26436f6b8e54c313eb8b3e224af018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf40621718d23022540784c1a62b29f" id="r_a9cf40621718d23022540784c1a62b29f"><td class="memTemplParams" colspan="2">template&lt;typename ProtoIndices &gt; </td></tr>
<tr class="memitem:a9cf40621718d23022540784c1a62b29f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IntervalVariable &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cf40621718d23022540784c1a62b29f">Intervals</a> (const ProtoIndices &amp;indices) const</td></tr>
<tr class="separator:a9cf40621718d23022540784c1a62b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7fa5597cf7f1924d26beb05b477eb5" id="r_a8d7fa5597cf7f1924d26beb05b477eb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7fa5597cf7f1924d26beb05b477eb5">ConstraintIsAlreadyLoaded</a> (const ConstraintProto *<a class="el" href="demon__profiler_8cc.html#a05da18ca9c7b657a4a6ea24e07c9b695">ct</a>) const</td></tr>
<tr class="separator:a8d7fa5597cf7f1924d26beb05b477eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc96e13e0b2d2310b52d9485dfe2296" id="r_a8dc96e13e0b2d2310b52d9485dfe2296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dc96e13e0b2d2310b52d9485dfe2296">IsHalfEncodingConstraint</a> (const ConstraintProto *<a class="el" href="demon__profiler_8cc.html#a05da18ca9c7b657a4a6ea24e07c9b695">ct</a>) const</td></tr>
<tr class="separator:a8dc96e13e0b2d2310b52d9485dfe2296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80348275984a3c29fd5125beaabcbe16" id="r_a80348275984a3c29fd5125beaabcbe16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80348275984a3c29fd5125beaabcbe16">GetProtoVariableFromBooleanVariable</a> (BooleanVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:a80348275984a3c29fd5125beaabcbe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae19f2739b2818ee2c391e363b46999a" id="r_aae19f2739b2818ee2c391e363b46999a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae19f2739b2818ee2c391e363b46999a">GetProtoVariableFromIntegerVariable</a> (IntegerVariable <a class="el" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>) const</td></tr>
<tr class="separator:aae19f2739b2818ee2c391e363b46999a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84cb76ba64ccd2c3d161a2441b43aa7" id="r_af84cb76ba64ccd2c3d161a2441b43aa7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; IntegerVariable &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84cb76ba64ccd2c3d161a2441b43aa7">GetVariableMapping</a> () const</td></tr>
<tr class="separator:af84cb76ba64ccd2c3d161a2441b43aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab612ad30bfefef6301f83a2bd661662c" id="r_ab612ad30bfefef6301f83a2bd661662c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab612ad30bfefef6301f83a2bd661662c">GetExprFromProto</a> (const LinearExpressionProto &amp;expr_proto) const</td></tr>
<tr class="separator:ab612ad30bfefef6301f83a2bd661662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4c3c076a77a2af4ea12b5b41237ad9" id="r_a2b4c3c076a77a2af4ea12b5b41237ad9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b4c3c076a77a2af4ea12b5b41237ad9">NumIntegerVariables</a> () const</td></tr>
<tr class="memdesc:a2b4c3c076a77a2af4ea12b5b41237ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For logging only, these are not super efficient.  <br /></td></tr>
<tr class="separator:a2b4c3c076a77a2af4ea12b5b41237ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ef226b1c8a471dc2ac7cf966cb34f7" id="r_ae3ef226b1c8a471dc2ac7cf966cb34f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ef226b1c8a471dc2ac7cf966cb34f7">NumBooleanVariables</a> () const</td></tr>
<tr class="separator:ae3ef226b1c8a471dc2ac7cf966cb34f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4b9d7c4d6b206f4c6302ca52d6e57a" id="r_a9e4b9d7c4d6b206f4c6302ca52d6e57a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e4b9d7c4d6b206f4c6302ca52d6e57a">NumProtoVariables</a> () const</td></tr>
<tr class="memdesc:a9e4b9d7c4d6b206f4c6302ca52d6e57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables in the loaded proto.  <br /></td></tr>
<tr class="separator:a9e4b9d7c4d6b206f4c6302ca52d6e57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1a6eefe7a5bfd8bdf83407c9e6af56f5" id="r_a1a6eefe7a5bfd8bdf83407c9e6af56f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6eefe7a5bfd8bdf83407c9e6af56f5">LoadVariables</a> (const CpModelProto &amp;<a class="el" href="cp__model__solver_8cc.html#ac3c7e255171970400b8e766957e73d85">model_proto</a>, bool view_all_booleans_as_integers, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:a1a6eefe7a5bfd8bdf83407c9e6af56f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78bf6fcea4b54f750e2457e47b4f46a" id="r_ad78bf6fcea4b54f750e2457e47b4f46a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78bf6fcea4b54f750e2457e47b4f46a">ExtractEncoding</a> (const CpModelProto &amp;<a class="el" href="cp__model__solver_8cc.html#ac3c7e255171970400b8e766957e73d85">model_proto</a>, <a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *m)</td></tr>
<tr class="separator:ad78bf6fcea4b54f750e2457e47b4f46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds the mapping between CpModel proto indices and the sat::model ones.</p>
<p>This also holds some information used when loading a CpModel proto. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00067">67</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a58809f5b0a739fa62cf923b2ed919df5" name="a58809f5b0a739fa62cf923b2ed919df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58809f5b0a739fa62cf923b2ed919df5">&#9670;&#160;</a></span>Affine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> operations_research::sat::CpModelMapping::Affine </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>exp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001190">Todo</a></b></dt><dd>(user): We could "easily" create an intermediate variable for more complex linear expression. We could also identify duplicate expressions to not create two identical integer variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00096">96</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="adc26436f6b8e54c313eb8b3e224af018" name="adc26436f6b8e54c313eb8b3e224af018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc26436f6b8e54c313eb8b3e224af018">&#9670;&#160;</a></span>Affines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structoperations__research_1_1sat_1_1AffineExpression.html">AffineExpression</a> &gt; operations_research::sat::CpModelMapping::Affines </td>
          <td>(</td>
          <td class="paramtype">const List &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00129">129</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a8d7fa5597cf7f1924d26beb05b477eb5" name="a8d7fa5597cf7f1924d26beb05b477eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7fa5597cf7f1924d26beb05b477eb5">&#9670;&#160;</a></span>ConstraintIsAlreadyLoaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::CpModelMapping::ConstraintIsAlreadyLoaded </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Depending on the option, we will load constraints in stages. This is used to detect constraints that are already loaded. For instance the interval constraints and the linear constraint of size 1 (encodings) are usually loaded first. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00148">148</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="ab612ad30bfefef6301f83a2bd661662c" name="ab612ad30bfefef6301f83a2bd661662c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab612ad30bfefef6301f83a2bd661662c">&#9670;&#160;</a></span>GetExprFromProto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structoperations__research_1_1sat_1_1LinearExpression.html">LinearExpression</a> operations_research::sat::CpModelMapping::GetExprFromProto </td>
          <td>(</td>
          <td class="paramtype">const LinearExpressionProto &amp;</td>          <td class="paramname"><span class="paramname"><em>expr_proto</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00175">175</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a80348275984a3c29fd5125beaabcbe16" name="a80348275984a3c29fd5125beaabcbe16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80348275984a3c29fd5125beaabcbe16">&#9670;&#160;</a></span>GetProtoVariableFromBooleanVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::CpModelMapping::GetProtoVariableFromBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">BooleanVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>both these functions returns positive reference or -1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00162">162</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="aae19f2739b2818ee2c391e363b46999a" name="aae19f2739b2818ee2c391e363b46999a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae19f2739b2818ee2c391e363b46999a">&#9670;&#160;</a></span>GetProtoVariableFromIntegerVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::CpModelMapping::GetProtoVariableFromIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">IntegerVariable</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00166">166</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="af84cb76ba64ccd2c3d161a2441b43aa7" name="af84cb76ba64ccd2c3d161a2441b43aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84cb76ba64ccd2c3d161a2441b43aa7">&#9670;&#160;</a></span>GetVariableMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; IntegerVariable &gt; &amp; operations_research::sat::CpModelMapping::GetVariableMapping </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00171">171</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="aeca100c15df08addef3dcb51c1caa822" name="aeca100c15df08addef3dcb51c1caa822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca100c15df08addef3dcb51c1caa822">&#9670;&#160;</a></span>Integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVariable operations_research::sat::CpModelMapping::Integer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00087">87</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a54b2f0ae3351898e0cfa8bf6e2838cb2" name="a54b2f0ae3351898e0cfa8bf6e2838cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b2f0ae3351898e0cfa8bf6e2838cb2">&#9670;&#160;</a></span>Integers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IntegerVariable &gt; operations_research::sat::CpModelMapping::Integers </td>
          <td>(</td>
          <td class="paramtype">const List &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00113">113</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="add0278bd96db6d4ec1eb86faf469b973" name="add0278bd96db6d4ec1eb86faf469b973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0278bd96db6d4ec1eb86faf469b973">&#9670;&#160;</a></span>Interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntervalVariable operations_research::sat::CpModelMapping::Interval </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00105">105</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a9cf40621718d23022540784c1a62b29f" name="a9cf40621718d23022540784c1a62b29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf40621718d23022540784c1a62b29f">&#9670;&#160;</a></span>Intervals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoIndices &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IntervalVariable &gt; operations_research::sat::CpModelMapping::Intervals </td>
          <td>(</td>
          <td class="paramtype">const ProtoIndices &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00137">137</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a79f03b471d74d225235179c6de80e97b" name="a79f03b471d74d225235179c6de80e97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f03b471d74d225235179c6de80e97b">&#9670;&#160;</a></span>IsBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::CpModelMapping::IsBoolean </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given CpModelProto variable reference refers to a Boolean variable. Such variable will always have an associated <a class="el" href="#a4f0641a3ce3460bebb7c09b9f8100e1c">Literal()</a>, but not always an associated <a class="el" href="#aeca100c15df08addef3dcb51c1caa822">Integer()</a>. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00072">72</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a8dc96e13e0b2d2310b52d9485dfe2296" name="a8dc96e13e0b2d2310b52d9485dfe2296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc96e13e0b2d2310b52d9485dfe2296">&#9670;&#160;</a></span>IsHalfEncodingConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::CpModelMapping::IsHalfEncodingConstraint </td>
          <td>(</td>
          <td class="paramtype">const ConstraintProto *</td>          <td class="paramname"><span class="paramname"><em>ct</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given constraint is a "half-encoding" constraint. That is, if it is of the form (b =&gt; size 1 linear) but there is no (&lt;=) side in the model. Such constraint are detected while we extract integer encoding and are cached here so that we can deal properly with them during the linear relaxation. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00157">157</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a7a2061423a87ee2e08762711e9ba7235" name="a7a2061423a87ee2e08762711e9ba7235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2061423a87ee2e08762711e9ba7235">&#9670;&#160;</a></span>IsInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::sat::CpModelMapping::IsInteger </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00077">77</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a4f0641a3ce3460bebb7c09b9f8100e1c" name="a4f0641a3ce3460bebb7c09b9f8100e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0641a3ce3460bebb7c09b9f8100e1c">&#9670;&#160;</a></span>Literal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1sat_1_1Literal.html">sat::Literal</a> operations_research::sat::CpModelMapping::Literal </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00082">82</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="ad8b496238831906b4107850c1a94599f" name="ad8b496238831906b4107850c1a94599f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b496238831906b4107850c1a94599f">&#9670;&#160;</a></span>Literals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProtoIndices &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">sat::Literal</a> &gt; operations_research::sat::CpModelMapping::Literals </td>
          <td>(</td>
          <td class="paramtype">const ProtoIndices &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00121">121</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="ae3ef226b1c8a471dc2ac7cf966cb34f7" name="ae3ef226b1c8a471dc2ac7cf966cb34f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ef226b1c8a471dc2ac7cf966cb34f7">&#9670;&#160;</a></span>NumBooleanVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::CpModelMapping::NumBooleanVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00194">194</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a2b4c3c076a77a2af4ea12b5b41237ad9" name="a2b4c3c076a77a2af4ea12b5b41237ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4c3c076a77a2af4ea12b5b41237ad9">&#9670;&#160;</a></span>NumIntegerVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::CpModelMapping::NumIntegerVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For logging only, these are not super efficient. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00187">187</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<a id="a9e4b9d7c4d6b206f4c6302ca52d6e57a" name="a9e4b9d7c4d6b206f4c6302ca52d6e57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4b9d7c4d6b206f4c6302ca52d6e57a">&#9670;&#160;</a></span>NumProtoVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::sat::CpModelMapping::NumProtoVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of variables in the loaded proto. </p>

<p class="definition">Definition at line <a class="el" href="cp__model__mapping_8h_source.html#l00203">203</a> of file <a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ad78bf6fcea4b54f750e2457e47b4f46a" name="ad78bf6fcea4b54f750e2457e47b4f46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78bf6fcea4b54f750e2457e47b4f46a">&#9670;&#160;</a></span>ExtractEncoding</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ExtractEncoding </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The logic assumes that the linear constraints have been presolved, so that equality with a domain bound have been converted to &lt;= or &gt;= and so that we never have any trivial inequalities.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001170">Todo</a></b></dt><dd>(user): Regroup/presolve two encoding like b =&gt; x &gt; 2 and the same Boolean b =&gt; x &gt; 5. These shouldn't happen if we merge linear constraints. </dd></dl>
<p>Extract the encodings (IntegerVariable &lt;-&gt; Booleans) present in the model. This effectively load some linear constraints of size 1 that will be marked as already loaded. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001171">Todo</a></b></dt><dd>(user): Debug what makes it unsat at this point. </dd></dl>
<p>Detection of literal equivalent to (i_var == value). We collect all the half-reified constraint lit =&gt; equality or lit =&gt; inequality for a given variable, and we will later sort them to detect equivalence.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001172">Todo</a></b></dt><dd>(user): We will re-add the same implied bounds during probing, so it might not be necessary to do that here. Also, it might be too early if some of the literal view used in the LP are created later, but that should be fixable via calls to implied_bounds-&gt;NotifyNewIntegerView(). </dd></dl>
<p>Detection of literal equivalent to (i_var &gt;= bound). We also collect all the half-refied part and we will sort the vector for detection of the equivalence.</p>
<p>Loop over all constraints and fill var_to_equalities and inequalities.</p>
<p>ct is a linear constraint with one term and one enforcement literal.</p>
<p>Detect enforcement_literal =&gt; (var &gt;= value or var &lt;= value).</p>
<p>Detect implied bounds. The test is less strict than the above test.</p>
<p>Detect enforcement_literal =&gt; (var == value or var != value).</p>
<dl class="section note"><dt>Note</dt><dd>for domain with 2 values like [0, 1], we will detect both == 0 and != 1. Similarly, for a domain in [min, max], we should both detect (== min) and (&lt;= min), and both detect (== max) and (&gt;= max).</dd></dl>
<p>Detect <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &lt;=&gt; X &gt;= value</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001173">Todo</a></b></dt><dd>(user): In these cases, we could fix the enforcement literal right away or ignore the constraint. Note that it will be done later anyway though. </dd></dl>
<p>Encode the half-inequalities.</p>
<p>Detect <a class="el" href="classoperations__research_1_1sat_1_1Literal.html">Literal</a> &lt;=&gt; X == value and associate them in the <a class="el" href="classoperations__research_1_1sat_1_1IntegerEncoder.html">IntegerEncoder</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001174">Todo</a></b></dt><dd>(user): Fully encode variable that are almost fully encoded? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001175">Todo</a></b></dt><dd>(user): Try to remove it. Normally we caught UNSAT above, but tests are very flaky (it only happens in parallel). Keeping it there for the time being. </dd></dl>
<p>Encode the half-equalities.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001176">Todo</a></b></dt><dd>(user): delay this after <a class="el" href="namespaceoperations__research_1_1sat.html#ad1ebf465eb7ccee4f79a5b8cfccfe7d9">PropagateEncodingFromEquivalenceRelations()</a>? Otherwise we might create new Boolean variables for no reason. Note however, that in the presolve, we should only use the "representative" in linear constraints, so we should be fine. </dd></dl>
<p>If we have just an half-equality, lets not create the &lt;=&gt; literal but just add two implications. If we don't create hole, we don't really need the reverse literal. This way it is also possible for the <a class="el" href="namespaceoperations__research_1_1sat.html#a89efb582832622f508e29d0c32f56ca9">ExtractElementEncoding()</a> to detect later that actually this literal is &lt;=&gt; to var == value, and this way we create one less Boolean for the same result.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001177">Todo</a></b></dt><dd>(user): It is not 100% clear what is the best encoding and if we should create equivalent literal or rely on propagator instead to push bounds. </dd></dl>
<p>Update stats.</p>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00379">379</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<a id="a1a6eefe7a5bfd8bdf83407c9e6af56f5" name="a1a6eefe7a5bfd8bdf83407c9e6af56f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6eefe7a5bfd8bdf83407c9e6af56f5">&#9670;&#160;</a></span>LoadVariables</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoadVariables </td>
          <td>(</td>
          <td class="paramtype">const CpModelProto &amp;</td>          <td class="paramname"><span class="paramname"><em>model_proto</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>view_all_booleans_as_integers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1sat_1_1Model.html">Model</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts all the used variables in the CpModelProto and creates a <a class="el" href="classoperations__research_1_1sat_1_1Model.html">sat::Model</a> representation for them. More precisely</p><ul>
<li>All Boolean variables will be mapped.</li>
<li>All Interval variables will be mapped.</li>
<li>All non-Boolean variable will have a corresponding IntegerVariable, and depending on the view_all_booleans_as_integers, some or all of the BooleanVariable will also have an IntegerVariable corresponding to its "integer view".</li>
</ul>
<p>Note(user): We could create IntegerVariable on the fly as they are needed, but that loose the original variable order which might be useful in heuristics later. </p>
<p>All [0, 1] variables always have a corresponding Boolean, even if it is fixed to 0 (domain == [0,0]) or fixed to 1 (domain == [1,1]).</p>
<p>Compute the list of positive variable reference for which we need to create an IntegerVariable.</p>
<p>Compute the integer variable references used by the model.</p>
<p>Add the objectives variables that needs to be referenceable as integer even if they are only used as Booleans.</p>
<p>Make sure any unused variable, that is not already a Boolean is considered "used".</p>
<p>We want the variable in the problem order.</p>
<p>It is important for memory usage to reserve tight vector has we have many indexed by IntegerVariable. Unfortunately, we create intermediate IntegerVariable while loading large linear constraint, or when we have disjoint LP component. So this is a best effort at a tight upper bound.</p>
<p>Link any variable that has both views.</p>
<p>Associate with corresponding integer variable.</p>
<p>Create the interval variables.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo001168">Todo</a></b></dt><dd>(user): Fix the constant variable situation. An optional interval with constant start/end or size cannot share the same constant variable if it is used in non-optional situation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cp__model__loader_8cc_source.html#l00126">126</a> of file <a class="el" href="cp__model__loader_8cc_source.html">cp_model_loader.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ortools/sat/<a class="el" href="cp__model__mapping_8h_source.html">cp_model_mapping.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="namespaceoperations__research_1_1sat.html">sat</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1sat_1_1CpModelMapping.html">CpModelMapping</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
