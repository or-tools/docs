<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Google OR-Tools: com.google.ortools.glop.GlopParametersOrBuilder Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="orLogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Google OR-Tools<span id="projectnumber">&#160;v9.8</span>
   </div>
   <div id="projectbrief">a fast and portable software suite for combinatorial optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">com.google.ortools.glop.GlopParametersOrBuilder Interface Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for com.google.ortools.glop.GlopParametersOrBuilder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.png" usemap="#com.google.ortools.glop.GlopParametersOrBuilder_map" alt=""/>
  <map id="com.google.ortools.glop.GlopParametersOrBuilder_map" name="com.google.ortools.glop.GlopParametersOrBuilder_map">
<area href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html" alt="com.google.ortools.glop.GlopParameters" shape="rect" coords="0,112,296,136"/>
<area href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html" alt="com.google.ortools.glop.GlopParameters.Builder" shape="rect" coords="306,112,602,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a537a7accd43fe4936816ec92974844d3" id="r_a537a7accd43fe4936816ec92974844d3"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a537a7accd43fe4936816ec92974844d3">hasScalingMethod</a> ()</td></tr>
<tr class="separator:a537a7accd43fe4936816ec92974844d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9febb7569532d7e603825104ee5d6527" id="r_a9febb7569532d7e603825104ee5d6527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1ScalingAlgorithm.html">com.google.ortools.glop.GlopParameters.ScalingAlgorithm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a9febb7569532d7e603825104ee5d6527">getScalingMethod</a> ()</td></tr>
<tr class="separator:a9febb7569532d7e603825104ee5d6527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17152932ac2754d2483b15f0cbbcf087" id="r_a17152932ac2754d2483b15f0cbbcf087"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a17152932ac2754d2483b15f0cbbcf087">hasFeasibilityRule</a> ()</td></tr>
<tr class="separator:a17152932ac2754d2483b15f0cbbcf087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af634e1a2234d40106b00b24dd9ff90df" id="r_af634e1a2234d40106b00b24dd9ff90df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1PricingRule.html">com.google.ortools.glop.GlopParameters.PricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af634e1a2234d40106b00b24dd9ff90df">getFeasibilityRule</a> ()</td></tr>
<tr class="separator:af634e1a2234d40106b00b24dd9ff90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ed3d3852c22a715547eac1dc1d965e" id="r_a33ed3d3852c22a715547eac1dc1d965e"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a33ed3d3852c22a715547eac1dc1d965e">hasOptimizationRule</a> ()</td></tr>
<tr class="separator:a33ed3d3852c22a715547eac1dc1d965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a304249e2edfbe888051813cbecd80" id="r_a12a304249e2edfbe888051813cbecd80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1PricingRule.html">com.google.ortools.glop.GlopParameters.PricingRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a12a304249e2edfbe888051813cbecd80">getOptimizationRule</a> ()</td></tr>
<tr class="separator:a12a304249e2edfbe888051813cbecd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc95a6ef1ce64d7265d3b5a998ca781" id="r_abfc95a6ef1ce64d7265d3b5a998ca781"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#abfc95a6ef1ce64d7265d3b5a998ca781">hasRefactorizationThreshold</a> ()</td></tr>
<tr class="separator:abfc95a6ef1ce64d7265d3b5a998ca781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad5d98242d252f68126d3f2b1f79373" id="r_a0ad5d98242d252f68126d3f2b1f79373"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a0ad5d98242d252f68126d3f2b1f79373">getRefactorizationThreshold</a> ()</td></tr>
<tr class="separator:a0ad5d98242d252f68126d3f2b1f79373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f19bf67c1260ea4639d16e96169651" id="r_a09f19bf67c1260ea4639d16e96169651"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a09f19bf67c1260ea4639d16e96169651">hasRecomputeReducedCostsThreshold</a> ()</td></tr>
<tr class="separator:a09f19bf67c1260ea4639d16e96169651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62ba2a483dc9ff5cd26156f43908dcc" id="r_ab62ba2a483dc9ff5cd26156f43908dcc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ab62ba2a483dc9ff5cd26156f43908dcc">getRecomputeReducedCostsThreshold</a> ()</td></tr>
<tr class="separator:ab62ba2a483dc9ff5cd26156f43908dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2eafe9f79b4eb827f6df049148cda8" id="r_aac2eafe9f79b4eb827f6df049148cda8"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aac2eafe9f79b4eb827f6df049148cda8">hasRecomputeEdgesNormThreshold</a> ()</td></tr>
<tr class="separator:aac2eafe9f79b4eb827f6df049148cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c4c2b0860293f41a7546f54685899c" id="r_a92c4c2b0860293f41a7546f54685899c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a92c4c2b0860293f41a7546f54685899c">getRecomputeEdgesNormThreshold</a> ()</td></tr>
<tr class="separator:a92c4c2b0860293f41a7546f54685899c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54173d0ec7f85e646fa94c435f9017a5" id="r_a54173d0ec7f85e646fa94c435f9017a5"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a54173d0ec7f85e646fa94c435f9017a5">hasPrimalFeasibilityTolerance</a> ()</td></tr>
<tr class="separator:a54173d0ec7f85e646fa94c435f9017a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada54fd9b40c20973115ebd273a60aa05" id="r_ada54fd9b40c20973115ebd273a60aa05"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ada54fd9b40c20973115ebd273a60aa05">getPrimalFeasibilityTolerance</a> ()</td></tr>
<tr class="separator:ada54fd9b40c20973115ebd273a60aa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac26fda23f883dc187c931ddfa5bfcb0" id="r_aac26fda23f883dc187c931ddfa5bfcb0"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aac26fda23f883dc187c931ddfa5bfcb0">hasDualFeasibilityTolerance</a> ()</td></tr>
<tr class="separator:aac26fda23f883dc187c931ddfa5bfcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c779083c72a250715943ffb612f9202" id="r_a1c779083c72a250715943ffb612f9202"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a1c779083c72a250715943ffb612f9202">getDualFeasibilityTolerance</a> ()</td></tr>
<tr class="separator:a1c779083c72a250715943ffb612f9202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03201546d79bdc99feb199d3abc51233" id="r_a03201546d79bdc99feb199d3abc51233"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a03201546d79bdc99feb199d3abc51233">hasRatioTestZeroThreshold</a> ()</td></tr>
<tr class="separator:a03201546d79bdc99feb199d3abc51233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c288236ebc4aa6e8762f8a5bbb96e1" id="r_a86c288236ebc4aa6e8762f8a5bbb96e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a86c288236ebc4aa6e8762f8a5bbb96e1">getRatioTestZeroThreshold</a> ()</td></tr>
<tr class="separator:a86c288236ebc4aa6e8762f8a5bbb96e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d75029ce0436565584381905110bb2" id="r_a30d75029ce0436565584381905110bb2"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a30d75029ce0436565584381905110bb2">hasHarrisToleranceRatio</a> ()</td></tr>
<tr class="separator:a30d75029ce0436565584381905110bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f7cee79d876a4674d5e5c8e261047a" id="r_a79f7cee79d876a4674d5e5c8e261047a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a79f7cee79d876a4674d5e5c8e261047a">getHarrisToleranceRatio</a> ()</td></tr>
<tr class="separator:a79f7cee79d876a4674d5e5c8e261047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421765b93f831ddeedc3ccea237e2f6e" id="r_a421765b93f831ddeedc3ccea237e2f6e"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a421765b93f831ddeedc3ccea237e2f6e">hasSmallPivotThreshold</a> ()</td></tr>
<tr class="separator:a421765b93f831ddeedc3ccea237e2f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac7bcd8d379ef7597c7fbcc8abc89cc" id="r_adac7bcd8d379ef7597c7fbcc8abc89cc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#adac7bcd8d379ef7597c7fbcc8abc89cc">getSmallPivotThreshold</a> ()</td></tr>
<tr class="separator:adac7bcd8d379ef7597c7fbcc8abc89cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7ab5f510ccf852c2922e6a84a222bb" id="r_a4b7ab5f510ccf852c2922e6a84a222bb"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a4b7ab5f510ccf852c2922e6a84a222bb">hasMinimumAcceptablePivot</a> ()</td></tr>
<tr class="separator:a4b7ab5f510ccf852c2922e6a84a222bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644cd565a007caa2ab6e91206c647531" id="r_a644cd565a007caa2ab6e91206c647531"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a644cd565a007caa2ab6e91206c647531">getMinimumAcceptablePivot</a> ()</td></tr>
<tr class="separator:a644cd565a007caa2ab6e91206c647531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f72c9357eb7204f7437af91e57566d3" id="r_a0f72c9357eb7204f7437af91e57566d3"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a0f72c9357eb7204f7437af91e57566d3">hasDropTolerance</a> ()</td></tr>
<tr class="separator:a0f72c9357eb7204f7437af91e57566d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b63e77c29d433c8f888c4b99309426" id="r_a70b63e77c29d433c8f888c4b99309426"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a70b63e77c29d433c8f888c4b99309426">getDropTolerance</a> ()</td></tr>
<tr class="separator:a70b63e77c29d433c8f888c4b99309426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01841739b6a158f221bdca095231212f" id="r_a01841739b6a158f221bdca095231212f"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a01841739b6a158f221bdca095231212f">hasUseScaling</a> ()</td></tr>
<tr class="separator:a01841739b6a158f221bdca095231212f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777b56df4b65d15df9d0503749452770" id="r_a777b56df4b65d15df9d0503749452770"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a777b56df4b65d15df9d0503749452770">getUseScaling</a> ()</td></tr>
<tr class="separator:a777b56df4b65d15df9d0503749452770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96feadf405b3d70d4ed81d8dd4b44337" id="r_a96feadf405b3d70d4ed81d8dd4b44337"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a96feadf405b3d70d4ed81d8dd4b44337">hasCostScaling</a> ()</td></tr>
<tr class="separator:a96feadf405b3d70d4ed81d8dd4b44337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84d2e617be2478eaf7b77f13fb4bafc" id="r_ac84d2e617be2478eaf7b77f13fb4bafc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1CostScalingAlgorithm.html">com.google.ortools.glop.GlopParameters.CostScalingAlgorithm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac84d2e617be2478eaf7b77f13fb4bafc">getCostScaling</a> ()</td></tr>
<tr class="separator:ac84d2e617be2478eaf7b77f13fb4bafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13ea69bc6052c5f0f54b5328738435f" id="r_ac13ea69bc6052c5f0f54b5328738435f"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac13ea69bc6052c5f0f54b5328738435f">hasInitialBasis</a> ()</td></tr>
<tr class="separator:ac13ea69bc6052c5f0f54b5328738435f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac217fddbe2b01ad51c05c51ffa5dd99c" id="r_ac217fddbe2b01ad51c05c51ffa5dd99c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1InitialBasisHeuristic.html">com.google.ortools.glop.GlopParameters.InitialBasisHeuristic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac217fddbe2b01ad51c05c51ffa5dd99c">getInitialBasis</a> ()</td></tr>
<tr class="separator:ac217fddbe2b01ad51c05c51ffa5dd99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259beb5104af867a47d3d357e2181385" id="r_a259beb5104af867a47d3d357e2181385"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a259beb5104af867a47d3d357e2181385">hasUseTransposedMatrix</a> ()</td></tr>
<tr class="separator:a259beb5104af867a47d3d357e2181385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b84271636acdd21cb8b646e9a08117" id="r_ad7b84271636acdd21cb8b646e9a08117"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ad7b84271636acdd21cb8b646e9a08117">getUseTransposedMatrix</a> ()</td></tr>
<tr class="separator:ad7b84271636acdd21cb8b646e9a08117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac434ef15f7b64f6bf9f009e48a288269" id="r_ac434ef15f7b64f6bf9f009e48a288269"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac434ef15f7b64f6bf9f009e48a288269">hasBasisRefactorizationPeriod</a> ()</td></tr>
<tr class="separator:ac434ef15f7b64f6bf9f009e48a288269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b2b0d4b302a482cc5f9e739b00cad3" id="r_ae1b2b0d4b302a482cc5f9e739b00cad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ae1b2b0d4b302a482cc5f9e739b00cad3">getBasisRefactorizationPeriod</a> ()</td></tr>
<tr class="separator:ae1b2b0d4b302a482cc5f9e739b00cad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea89f77e6fe1c1944882e3a5d00ca9f" id="r_a8ea89f77e6fe1c1944882e3a5d00ca9f"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a8ea89f77e6fe1c1944882e3a5d00ca9f">hasDynamicallyAdjustRefactorizationPeriod</a> ()</td></tr>
<tr class="separator:a8ea89f77e6fe1c1944882e3a5d00ca9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396d448165bd34ab763804a90bad197d" id="r_a396d448165bd34ab763804a90bad197d"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a396d448165bd34ab763804a90bad197d">getDynamicallyAdjustRefactorizationPeriod</a> ()</td></tr>
<tr class="separator:a396d448165bd34ab763804a90bad197d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fddc6861c1636dcd3d261a3c011016" id="r_a07fddc6861c1636dcd3d261a3c011016"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a07fddc6861c1636dcd3d261a3c011016">hasSolveDualProblem</a> ()</td></tr>
<tr class="separator:a07fddc6861c1636dcd3d261a3c011016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d611164e4f2b2e89648b959af4efe5" id="r_af1d611164e4f2b2e89648b959af4efe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1SolverBehavior.html">com.google.ortools.glop.GlopParameters.SolverBehavior</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af1d611164e4f2b2e89648b959af4efe5">getSolveDualProblem</a> ()</td></tr>
<tr class="separator:af1d611164e4f2b2e89648b959af4efe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace08259ab16d9ea673413dca43bd802" id="r_aace08259ab16d9ea673413dca43bd802"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aace08259ab16d9ea673413dca43bd802">hasDualizerThreshold</a> ()</td></tr>
<tr class="separator:aace08259ab16d9ea673413dca43bd802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab523d4a62e7eaf86b6ea56fe16951a76" id="r_ab523d4a62e7eaf86b6ea56fe16951a76"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ab523d4a62e7eaf86b6ea56fe16951a76">getDualizerThreshold</a> ()</td></tr>
<tr class="separator:ab523d4a62e7eaf86b6ea56fe16951a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9826793e31d57cc82f015844fa53738c" id="r_a9826793e31d57cc82f015844fa53738c"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a9826793e31d57cc82f015844fa53738c">hasSolutionFeasibilityTolerance</a> ()</td></tr>
<tr class="separator:a9826793e31d57cc82f015844fa53738c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e8901ff92de143edf3577fae1bc15e" id="r_a68e8901ff92de143edf3577fae1bc15e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a68e8901ff92de143edf3577fae1bc15e">getSolutionFeasibilityTolerance</a> ()</td></tr>
<tr class="separator:a68e8901ff92de143edf3577fae1bc15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420e8e885658f73f7747713b13743dd" id="r_ac420e8e885658f73f7747713b13743dd"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac420e8e885658f73f7747713b13743dd">hasProvideStrongOptimalGuarantee</a> ()</td></tr>
<tr class="separator:ac420e8e885658f73f7747713b13743dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a636e69a87155ac1b821dd3c391255" id="r_ab2a636e69a87155ac1b821dd3c391255"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ab2a636e69a87155ac1b821dd3c391255">getProvideStrongOptimalGuarantee</a> ()</td></tr>
<tr class="separator:ab2a636e69a87155ac1b821dd3c391255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378b5a277c72f1582faa6adc0bc8d25f" id="r_a378b5a277c72f1582faa6adc0bc8d25f"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a378b5a277c72f1582faa6adc0bc8d25f">hasChangeStatusToImprecise</a> ()</td></tr>
<tr class="separator:a378b5a277c72f1582faa6adc0bc8d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af547e816a0d7436446e17bf79ea0d940" id="r_af547e816a0d7436446e17bf79ea0d940"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af547e816a0d7436446e17bf79ea0d940">getChangeStatusToImprecise</a> ()</td></tr>
<tr class="separator:af547e816a0d7436446e17bf79ea0d940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995bf2182e7c53616504cce5a9140937" id="r_a995bf2182e7c53616504cce5a9140937"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a995bf2182e7c53616504cce5a9140937">hasMaxNumberOfReoptimizations</a> ()</td></tr>
<tr class="separator:a995bf2182e7c53616504cce5a9140937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f5ab9c08f05dfad9dd90f29be702db" id="r_a16f5ab9c08f05dfad9dd90f29be702db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a16f5ab9c08f05dfad9dd90f29be702db">getMaxNumberOfReoptimizations</a> ()</td></tr>
<tr class="separator:a16f5ab9c08f05dfad9dd90f29be702db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a42f2ecd280800713c7587f36154ba" id="r_a99a42f2ecd280800713c7587f36154ba"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a99a42f2ecd280800713c7587f36154ba">hasLuFactorizationPivotThreshold</a> ()</td></tr>
<tr class="separator:a99a42f2ecd280800713c7587f36154ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7bf5a01ec20e4f746b2118fe618155" id="r_a2b7bf5a01ec20e4f746b2118fe618155"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a2b7bf5a01ec20e4f746b2118fe618155">getLuFactorizationPivotThreshold</a> ()</td></tr>
<tr class="separator:a2b7bf5a01ec20e4f746b2118fe618155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e570d95069a9b181cee0d9a26e20ebc" id="r_a0e570d95069a9b181cee0d9a26e20ebc"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a0e570d95069a9b181cee0d9a26e20ebc">hasMaxTimeInSeconds</a> ()</td></tr>
<tr class="separator:a0e570d95069a9b181cee0d9a26e20ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d864146ccc9ffce0b0b9ff5f89ab9ea" id="r_a6d864146ccc9ffce0b0b9ff5f89ab9ea"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a6d864146ccc9ffce0b0b9ff5f89ab9ea">getMaxTimeInSeconds</a> ()</td></tr>
<tr class="separator:a6d864146ccc9ffce0b0b9ff5f89ab9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35ad2e2b849c4418f23363bd294ca1b" id="r_af35ad2e2b849c4418f23363bd294ca1b"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af35ad2e2b849c4418f23363bd294ca1b">hasMaxDeterministicTime</a> ()</td></tr>
<tr class="separator:af35ad2e2b849c4418f23363bd294ca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae541aea6cf7a03f765071f2ffd72f8a7" id="r_ae541aea6cf7a03f765071f2ffd72f8a7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ae541aea6cf7a03f765071f2ffd72f8a7">getMaxDeterministicTime</a> ()</td></tr>
<tr class="separator:ae541aea6cf7a03f765071f2ffd72f8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a8fc93775f349538b0f90f6b1266c2" id="r_ab9a8fc93775f349538b0f90f6b1266c2"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ab9a8fc93775f349538b0f90f6b1266c2">hasMaxNumberOfIterations</a> ()</td></tr>
<tr class="separator:ab9a8fc93775f349538b0f90f6b1266c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d792d76bc39e838f4f96b37907c901" id="r_ac0d792d76bc39e838f4f96b37907c901"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac0d792d76bc39e838f4f96b37907c901">getMaxNumberOfIterations</a> ()</td></tr>
<tr class="separator:ac0d792d76bc39e838f4f96b37907c901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d6c4338ce851deaf361df5d3395f84" id="r_ac2d6c4338ce851deaf361df5d3395f84"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac2d6c4338ce851deaf361df5d3395f84">hasMarkowitzZlatevParameter</a> ()</td></tr>
<tr class="separator:ac2d6c4338ce851deaf361df5d3395f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62054f5aa3bd7bb7c97ef153413e8100" id="r_a62054f5aa3bd7bb7c97ef153413e8100"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a62054f5aa3bd7bb7c97ef153413e8100">getMarkowitzZlatevParameter</a> ()</td></tr>
<tr class="separator:a62054f5aa3bd7bb7c97ef153413e8100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c7171d16a7f89e42d206c08d211f9a" id="r_aa2c7171d16a7f89e42d206c08d211f9a"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aa2c7171d16a7f89e42d206c08d211f9a">hasMarkowitzSingularityThreshold</a> ()</td></tr>
<tr class="separator:aa2c7171d16a7f89e42d206c08d211f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae8ac4cffb7d5250b4bb73de4a32bbb" id="r_a4ae8ac4cffb7d5250b4bb73de4a32bbb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a4ae8ac4cffb7d5250b4bb73de4a32bbb">getMarkowitzSingularityThreshold</a> ()</td></tr>
<tr class="separator:a4ae8ac4cffb7d5250b4bb73de4a32bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3431c1b7058d844e59375e161ffd6" id="r_aebb3431c1b7058d844e59375e161ffd6"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aebb3431c1b7058d844e59375e161ffd6">hasUseDualSimplex</a> ()</td></tr>
<tr class="separator:aebb3431c1b7058d844e59375e161ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a58181a95ff2d4be7967c9170445250" id="r_a2a58181a95ff2d4be7967c9170445250"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a2a58181a95ff2d4be7967c9170445250">getUseDualSimplex</a> ()</td></tr>
<tr class="separator:a2a58181a95ff2d4be7967c9170445250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6980720b1fec416145639286483e48" id="r_a7c6980720b1fec416145639286483e48"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a7c6980720b1fec416145639286483e48">hasAllowSimplexAlgorithmChange</a> ()</td></tr>
<tr class="separator:a7c6980720b1fec416145639286483e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92311b85a075944117e529f6fad3d01" id="r_ac92311b85a075944117e529f6fad3d01"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ac92311b85a075944117e529f6fad3d01">getAllowSimplexAlgorithmChange</a> ()</td></tr>
<tr class="separator:ac92311b85a075944117e529f6fad3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7736d7766bf0dcbe6cff8e534a6637" id="r_a7a7736d7766bf0dcbe6cff8e534a6637"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a7a7736d7766bf0dcbe6cff8e534a6637">hasDevexWeightsResetPeriod</a> ()</td></tr>
<tr class="separator:a7a7736d7766bf0dcbe6cff8e534a6637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5136baa9b0049a18c3aaea199f1273c" id="r_af5136baa9b0049a18c3aaea199f1273c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af5136baa9b0049a18c3aaea199f1273c">getDevexWeightsResetPeriod</a> ()</td></tr>
<tr class="separator:af5136baa9b0049a18c3aaea199f1273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21723afc146157a00d496d53b6f44ca2" id="r_a21723afc146157a00d496d53b6f44ca2"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a21723afc146157a00d496d53b6f44ca2">hasUsePreprocessing</a> ()</td></tr>
<tr class="separator:a21723afc146157a00d496d53b6f44ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f34a7639c79b4206813d55c4f91a0d" id="r_ab2f34a7639c79b4206813d55c4f91a0d"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ab2f34a7639c79b4206813d55c4f91a0d">getUsePreprocessing</a> ()</td></tr>
<tr class="separator:ab2f34a7639c79b4206813d55c4f91a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d84593884ed6d9861243d059f8dac0" id="r_a55d84593884ed6d9861243d059f8dac0"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a55d84593884ed6d9861243d059f8dac0">hasUseMiddleProductFormUpdate</a> ()</td></tr>
<tr class="separator:a55d84593884ed6d9861243d059f8dac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be9f3b6c7a60c192460c6160c09ff7a" id="r_a4be9f3b6c7a60c192460c6160c09ff7a"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a4be9f3b6c7a60c192460c6160c09ff7a">getUseMiddleProductFormUpdate</a> ()</td></tr>
<tr class="separator:a4be9f3b6c7a60c192460c6160c09ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dda59c0fc003bbaa895658aa70f13b1" id="r_a9dda59c0fc003bbaa895658aa70f13b1"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a9dda59c0fc003bbaa895658aa70f13b1">hasInitializeDevexWithColumnNorms</a> ()</td></tr>
<tr class="separator:a9dda59c0fc003bbaa895658aa70f13b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da47bb64441449725dd4122943306a0" id="r_a7da47bb64441449725dd4122943306a0"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a7da47bb64441449725dd4122943306a0">getInitializeDevexWithColumnNorms</a> ()</td></tr>
<tr class="separator:a7da47bb64441449725dd4122943306a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61772acdda660c5b6d99b6bbef8f2f5" id="r_af61772acdda660c5b6d99b6bbef8f2f5"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af61772acdda660c5b6d99b6bbef8f2f5">hasExploitSingletonColumnInInitialBasis</a> ()</td></tr>
<tr class="separator:af61772acdda660c5b6d99b6bbef8f2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6431d2897662a59578d0f5336b17a0e7" id="r_a6431d2897662a59578d0f5336b17a0e7"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a6431d2897662a59578d0f5336b17a0e7">getExploitSingletonColumnInInitialBasis</a> ()</td></tr>
<tr class="separator:a6431d2897662a59578d0f5336b17a0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb674de5a2faa9feb086de90481f2b" id="r_aa0eb674de5a2faa9feb086de90481f2b"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aa0eb674de5a2faa9feb086de90481f2b">hasDualSmallPivotThreshold</a> ()</td></tr>
<tr class="separator:aa0eb674de5a2faa9feb086de90481f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753494fa2147812d05c36caf9e9d46d7" id="r_a753494fa2147812d05c36caf9e9d46d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a753494fa2147812d05c36caf9e9d46d7">getDualSmallPivotThreshold</a> ()</td></tr>
<tr class="separator:a753494fa2147812d05c36caf9e9d46d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaf12f94185980f5aefaaef018003e7" id="r_a5aaf12f94185980f5aefaaef018003e7"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a5aaf12f94185980f5aefaaef018003e7">hasPreprocessorZeroTolerance</a> ()</td></tr>
<tr class="separator:a5aaf12f94185980f5aefaaef018003e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80262c6c2035ce0e80f8d78f666b592" id="r_aa80262c6c2035ce0e80f8d78f666b592"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aa80262c6c2035ce0e80f8d78f666b592">getPreprocessorZeroTolerance</a> ()</td></tr>
<tr class="separator:aa80262c6c2035ce0e80f8d78f666b592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5aa44b2b7adbea2f5045c175ddcb3e" id="r_aaf5aa44b2b7adbea2f5045c175ddcb3e"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aaf5aa44b2b7adbea2f5045c175ddcb3e">hasObjectiveLowerLimit</a> ()</td></tr>
<tr class="separator:aaf5aa44b2b7adbea2f5045c175ddcb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e08be278f19b55a3952b75c7710bc82" id="r_a1e08be278f19b55a3952b75c7710bc82"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a1e08be278f19b55a3952b75c7710bc82">getObjectiveLowerLimit</a> ()</td></tr>
<tr class="separator:a1e08be278f19b55a3952b75c7710bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb3499ec18aa86849c18c493373fd20" id="r_abfb3499ec18aa86849c18c493373fd20"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#abfb3499ec18aa86849c18c493373fd20">hasObjectiveUpperLimit</a> ()</td></tr>
<tr class="separator:abfb3499ec18aa86849c18c493373fd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2fc522b85ec6a4a29f0ed24fe543b" id="r_a19f2fc522b85ec6a4a29f0ed24fe543b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a19f2fc522b85ec6a4a29f0ed24fe543b">getObjectiveUpperLimit</a> ()</td></tr>
<tr class="separator:a19f2fc522b85ec6a4a29f0ed24fe543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c7b733637e5eba725b4b827b13028c" id="r_af9c7b733637e5eba725b4b827b13028c"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af9c7b733637e5eba725b4b827b13028c">hasDegenerateMinistepFactor</a> ()</td></tr>
<tr class="separator:af9c7b733637e5eba725b4b827b13028c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3695587485e5ceb96e3317753eb7ec" id="r_a6c3695587485e5ceb96e3317753eb7ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a6c3695587485e5ceb96e3317753eb7ec">getDegenerateMinistepFactor</a> ()</td></tr>
<tr class="separator:a6c3695587485e5ceb96e3317753eb7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f84c519e0d95bb3ef30a117207984e" id="r_a14f84c519e0d95bb3ef30a117207984e"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a14f84c519e0d95bb3ef30a117207984e">hasRandomSeed</a> ()</td></tr>
<tr class="separator:a14f84c519e0d95bb3ef30a117207984e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed5c9fbb7cfa6002bc09770cd3a842d" id="r_a8ed5c9fbb7cfa6002bc09770cd3a842d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a8ed5c9fbb7cfa6002bc09770cd3a842d">getRandomSeed</a> ()</td></tr>
<tr class="separator:a8ed5c9fbb7cfa6002bc09770cd3a842d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fa25667a66b83889210156d12b9dfc" id="r_ae4fa25667a66b83889210156d12b9dfc"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ae4fa25667a66b83889210156d12b9dfc">hasNumOmpThreads</a> ()</td></tr>
<tr class="separator:ae4fa25667a66b83889210156d12b9dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6a141e74359f694144686e8eb4af9e" id="r_aea6a141e74359f694144686e8eb4af9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#aea6a141e74359f694144686e8eb4af9e">getNumOmpThreads</a> ()</td></tr>
<tr class="separator:aea6a141e74359f694144686e8eb4af9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1487ba12eb996411f8b78296fa6b7533" id="r_a1487ba12eb996411f8b78296fa6b7533"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a1487ba12eb996411f8b78296fa6b7533">hasPerturbCostsInDualSimplex</a> ()</td></tr>
<tr class="separator:a1487ba12eb996411f8b78296fa6b7533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64374ab99b193a15c4fbf4f170408976" id="r_a64374ab99b193a15c4fbf4f170408976"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a64374ab99b193a15c4fbf4f170408976">getPerturbCostsInDualSimplex</a> ()</td></tr>
<tr class="separator:a64374ab99b193a15c4fbf4f170408976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2c22b9ca5af5c2f535fdd214c1c53b" id="r_acb2c22b9ca5af5c2f535fdd214c1c53b"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#acb2c22b9ca5af5c2f535fdd214c1c53b">hasUseDedicatedDualFeasibilityAlgorithm</a> ()</td></tr>
<tr class="separator:acb2c22b9ca5af5c2f535fdd214c1c53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52437f824def118ad8305c4a90643a02" id="r_a52437f824def118ad8305c4a90643a02"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a52437f824def118ad8305c4a90643a02">getUseDedicatedDualFeasibilityAlgorithm</a> ()</td></tr>
<tr class="separator:a52437f824def118ad8305c4a90643a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af220bfd71a7abc8cd01d3338b00e7b7a" id="r_af220bfd71a7abc8cd01d3338b00e7b7a"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#af220bfd71a7abc8cd01d3338b00e7b7a">hasRelativeCostPerturbation</a> ()</td></tr>
<tr class="separator:af220bfd71a7abc8cd01d3338b00e7b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db3b7bdce0428b3b7e4577a15f602c3" id="r_a8db3b7bdce0428b3b7e4577a15f602c3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a8db3b7bdce0428b3b7e4577a15f602c3">getRelativeCostPerturbation</a> ()</td></tr>
<tr class="separator:a8db3b7bdce0428b3b7e4577a15f602c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6511649735e18fb9a9953ac0507fcf" id="r_a9c6511649735e18fb9a9953ac0507fcf"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a9c6511649735e18fb9a9953ac0507fcf">hasRelativeMaxCostPerturbation</a> ()</td></tr>
<tr class="separator:a9c6511649735e18fb9a9953ac0507fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868b717f36b7f38db50b197d42a7c5d9" id="r_a868b717f36b7f38db50b197d42a7c5d9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a868b717f36b7f38db50b197d42a7c5d9">getRelativeMaxCostPerturbation</a> ()</td></tr>
<tr class="separator:a868b717f36b7f38db50b197d42a7c5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6739734eab3ea8e96f3b789a7619348f" id="r_a6739734eab3ea8e96f3b789a7619348f"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a6739734eab3ea8e96f3b789a7619348f">hasInitialConditionNumberThreshold</a> ()</td></tr>
<tr class="separator:a6739734eab3ea8e96f3b789a7619348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c807e6de7d506c59d2833bbdd3c52b" id="r_ad3c807e6de7d506c59d2833bbdd3c52b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ad3c807e6de7d506c59d2833bbdd3c52b">getInitialConditionNumberThreshold</a> ()</td></tr>
<tr class="separator:ad3c807e6de7d506c59d2833bbdd3c52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56fc9d9628af347713d2a063216e360" id="r_ab56fc9d9628af347713d2a063216e360"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ab56fc9d9628af347713d2a063216e360">hasLogSearchProgress</a> ()</td></tr>
<tr class="separator:ab56fc9d9628af347713d2a063216e360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4765fac898b4e5dfde0fc826b7764fca" id="r_a4765fac898b4e5dfde0fc826b7764fca"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a4765fac898b4e5dfde0fc826b7764fca">getLogSearchProgress</a> ()</td></tr>
<tr class="separator:a4765fac898b4e5dfde0fc826b7764fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b73e797e1481c044b2517d9e77832e7" id="r_a1b73e797e1481c044b2517d9e77832e7"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a1b73e797e1481c044b2517d9e77832e7">hasLogToStdout</a> ()</td></tr>
<tr class="separator:a1b73e797e1481c044b2517d9e77832e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7fabb1f0fe4d182c11c5fb92b38dfe" id="r_acd7fabb1f0fe4d182c11c5fb92b38dfe"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#acd7fabb1f0fe4d182c11c5fb92b38dfe">getLogToStdout</a> ()</td></tr>
<tr class="separator:acd7fabb1f0fe4d182c11c5fb92b38dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8fa40a3867e150950678ace20e5dde" id="r_a9b8fa40a3867e150950678ace20e5dde"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a9b8fa40a3867e150950678ace20e5dde">hasCrossoverBoundSnappingDistance</a> ()</td></tr>
<tr class="separator:a9b8fa40a3867e150950678ace20e5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72706c0e32f577c4ac8620093e8adc3f" id="r_a72706c0e32f577c4ac8620093e8adc3f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a72706c0e32f577c4ac8620093e8adc3f">getCrossoverBoundSnappingDistance</a> ()</td></tr>
<tr class="separator:a72706c0e32f577c4ac8620093e8adc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63d018a50c9a663f31d158b1a398cc5" id="r_ae63d018a50c9a663f31d158b1a398cc5"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ae63d018a50c9a663f31d158b1a398cc5">hasPushToVertex</a> ()</td></tr>
<tr class="separator:ae63d018a50c9a663f31d158b1a398cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdbbef31d6916a17fe2fb9c80d6db54" id="r_a2fdbbef31d6916a17fe2fb9c80d6db54"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a2fdbbef31d6916a17fe2fb9c80d6db54">getPushToVertex</a> ()</td></tr>
<tr class="separator:a2fdbbef31d6916a17fe2fb9c80d6db54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcc98856831c2fc6ec297d58040adb7" id="r_a5fcc98856831c2fc6ec297d58040adb7"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a5fcc98856831c2fc6ec297d58040adb7">hasUseImpliedFreePreprocessor</a> ()</td></tr>
<tr class="separator:a5fcc98856831c2fc6ec297d58040adb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1f15b416906598d1076410f0936bd2" id="r_adc1f15b416906598d1076410f0936bd2"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#adc1f15b416906598d1076410f0936bd2">getUseImpliedFreePreprocessor</a> ()</td></tr>
<tr class="separator:adc1f15b416906598d1076410f0936bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7922c0fd1ee413d57b2b0ca9bc14aa73" id="r_a7922c0fd1ee413d57b2b0ca9bc14aa73"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a7922c0fd1ee413d57b2b0ca9bc14aa73">hasMaxValidMagnitude</a> ()</td></tr>
<tr class="separator:a7922c0fd1ee413d57b2b0ca9bc14aa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e1e4a0e2eec8222fd4b891b8914fed" id="r_a13e1e4a0e2eec8222fd4b891b8914fed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a13e1e4a0e2eec8222fd4b891b8914fed">getMaxValidMagnitude</a> ()</td></tr>
<tr class="separator:a13e1e4a0e2eec8222fd4b891b8914fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ef9b78768b004c1adab607e2c6f605" id="r_ae9ef9b78768b004c1adab607e2c6f605"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#ae9ef9b78768b004c1adab607e2c6f605">hasDualPricePrioritizeNorm</a> ()</td></tr>
<tr class="separator:ae9ef9b78768b004c1adab607e2c6f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eaa6bc38355a15d54e94bc81114172" id="r_a76eaa6bc38355a15d54e94bc81114172"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html#a76eaa6bc38355a15d54e94bc81114172">getDualPricePrioritizeNorm</a> ()</td></tr>
<tr class="separator:a76eaa6bc38355a15d54e94bc81114172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="GlopParametersOrBuilder_8java_source.html#l00007">7</a> of file <a class="el" href="GlopParametersOrBuilder_8java_source.html">GlopParametersOrBuilder.java</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac92311b85a075944117e529f6fad3d01" name="ac92311b85a075944117e529f6fad3d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92311b85a075944117e529f6fad3d01">&#9670;&#160;</a></span>getAllowSimplexAlgorithmChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getAllowSimplexAlgorithmChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
During incremental solve, let the solver decide if it use the primal or
dual simplex algorithm depending on the current solution and on the new
problem. Note that even if this is true, the value of use_dual_simplex
still indicates the default algorithm that the solver will use.
</pre><p><code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>The allowSimplexAlgorithmChange. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a3caf95556ae801d52cb0bf3368903c84">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a1fef1451f819d0bbc0466eb9f2265eec">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ae1b2b0d4b302a482cc5f9e739b00cad3" name="ae1b2b0d4b302a482cc5f9e739b00cad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b2b0d4b302a482cc5f9e739b00cad3">&#9670;&#160;</a></span>getBasisRefactorizationPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com.google.ortools.glop.GlopParametersOrBuilder.getBasisRefactorizationPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Number of iterations between two basis refactorizations. Note that various
conditions in the algorithm may trigger a refactorization before this
period is reached. Set this to 0 if you want to refactorize at each step.
</pre><p><code>optional int32 basis_refactorization_period = 19 [default = 64];</code> </p><dl class="section return"><dt>Returns</dt><dd>The basisRefactorizationPeriod. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a2ab540a81a906b63d92fbdcc858c382e">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a2b35eedc5712ef57e7d56a506c1c834e">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af547e816a0d7436446e17bf79ea0d940" name="af547e816a0d7436446e17bf79ea0d940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af547e816a0d7436446e17bf79ea0d940">&#9670;&#160;</a></span>getChangeStatusToImprecise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getChangeStatusToImprecise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, the internal API will change the return status to imprecise if the
solution does not respect the internal tolerances.
</pre><p><code>optional bool change_status_to_imprecise = 58 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The changeStatusToImprecise. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a0d65098e5ef726646b2908178eec4d22">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#abad617887131e18984309fc476161e87">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ac84d2e617be2478eaf7b77f13fb4bafc" name="ac84d2e617be2478eaf7b77f13fb4bafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84d2e617be2478eaf7b77f13fb4bafc">&#9670;&#160;</a></span>getCostScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1CostScalingAlgorithm.html">com.google.ortools.glop.GlopParameters.CostScalingAlgorithm</a> com.google.ortools.glop.GlopParametersOrBuilder.getCostScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code> </p><dl class="section return"><dt>Returns</dt><dd>The costScaling. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a0e122a65683a9e7660fda26b5574aac7">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a1095c15f5e058d092a43f14e1777cc22">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a72706c0e32f577c4ac8620093e8adc3f" name="a72706c0e32f577c4ac8620093e8adc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72706c0e32f577c4ac8620093e8adc3f">&#9670;&#160;</a></span>getCrossoverBoundSnappingDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getCrossoverBoundSnappingDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If the starting basis contains FREE variable with bounds, we will move
any such variable to their closer bounds if the distance is smaller than
this parameter.

The starting statuses can contains FREE variables with bounds, if a user
set it like this externally. Also, any variable with an initial BASIC
status that was not kept in the initial basis is marked as FREE before this
step is applied.

Note that by default a FREE variable is assumed to be zero unless a
starting value was specified via SetStartingVariableValuesForNextSolve().

Note that, at the end of the solve, some of these FREE variable with bounds
and an interior point value might still be left in the final solution.
Enable push_to_vertex to clean these up.
</pre><p><code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>The crossoverBoundSnappingDistance. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#add5ef4ef2c1a100c4fe8eafc00795cd9">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a90f42189c7f992ab2d31b7968451d496">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a6c3695587485e5ceb96e3317753eb7ec" name="a6c3695587485e5ceb96e3317753eb7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3695587485e5ceb96e3317753eb7ec">&#9670;&#160;</a></span>getDegenerateMinistepFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getDegenerateMinistepFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
During a degenerate iteration, the more conservative approach is to do a
step of length zero (while shifting the bound of the leaving variable).
That is, the variable values are unchanged for the primal simplex or the
reduced cost are unchanged for the dual simplex. However, instead of doing
a step of length zero, it seems to be better on degenerate problems to do a
small positive step. This is what is recommended in the EXPAND procedure
described in:
P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
cycling procedure for linearly constrained optimization".
Mathematical Programming, 45:437&amp;#92;u2013474, 1989.

Here, during a degenerate iteration we do a small positive step of this
factor times the primal (resp. dual) tolerance. In the primal simplex, this
may effectively push variable values (very slightly) further out of their
bounds (resp. reduced costs for the dual simplex).

Setting this to zero reverts to the more conservative approach of a zero
step during degenerate iterations.
</pre><p><code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code> </p><dl class="section return"><dt>Returns</dt><dd>The degenerateMinistepFactor. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5a1ff0b1701ee2d061d99fff0616122b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a62cf22a3420971fc0509bebfe95c72e6">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af5136baa9b0049a18c3aaea199f1273c" name="af5136baa9b0049a18c3aaea199f1273c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5136baa9b0049a18c3aaea199f1273c">&#9670;&#160;</a></span>getDevexWeightsResetPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com.google.ortools.glop.GlopParametersOrBuilder.getDevexWeightsResetPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Devex weights will be reset to 1.0 after that number of updates.
</pre><p><code>optional int32 devex_weights_reset_period = 33 [default = 150];</code> </p><dl class="section return"><dt>Returns</dt><dd>The devexWeightsResetPeriod. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aba1a6e0d131cfa40b4154f6e468d1645">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a19eb173c67381112f260eb146d14fb6c">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a70b63e77c29d433c8f888c4b99309426" name="a70b63e77c29d433c8f888c4b99309426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b63e77c29d433c8f888c4b99309426">&#9670;&#160;</a></span>getDropTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getDropTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
In order to increase the sparsity of the manipulated vectors, floating
point values with a magnitude smaller than this parameter are set to zero
(only in some places). This parameter should be positive or zero.
</pre><p><code>optional double drop_tolerance = 52 [default = 1e-14];</code> </p><dl class="section return"><dt>Returns</dt><dd>The dropTolerance. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a908d504f40b5d805f11b90d45c880ca5">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a5921d454bd75ea4eef41625c794af9ed">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a1c779083c72a250715943ffb612f9202" name="a1c779083c72a250715943ffb612f9202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c779083c72a250715943ffb612f9202">&#9670;&#160;</a></span>getDualFeasibilityTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getDualFeasibilityTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Variables whose reduced costs have an absolute value smaller than this
tolerance are not considered as entering candidates. That is they do not
take part in deciding whether a solution is dual-feasible or not.

Note that this value can temporarily increase during the execution of the
algorithm if the estimated precision of the reduced costs is higher than
this tolerance. Note also that we scale the costs (in the presolve step) so
that the cost magnitude range contains one.

This is also known as the optimality tolerance in other solvers.
</pre><p><code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code> </p><dl class="section return"><dt>Returns</dt><dd>The dualFeasibilityTolerance. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a048cb8a3afae7bd3fda39c5eb39640f5">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a60e725a2ad558ca68086f72f0310324b">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ab523d4a62e7eaf86b6ea56fe16951a76" name="ab523d4a62e7eaf86b6ea56fe16951a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab523d4a62e7eaf86b6ea56fe16951a76">&#9670;&#160;</a></span>getDualizerThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getDualizerThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
of constraints of the problem is more than this threshold times the number
of variables.
</pre><p><code>optional double dualizer_threshold = 21 [default = 1.5];</code> </p><dl class="section return"><dt>Returns</dt><dd>The dualizerThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a368c249b1115e803ccadb7cff432c7f6">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a0f3ca51a369b708aecd97566afec2e6a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a76eaa6bc38355a15d54e94bc81114172" name="a76eaa6bc38355a15d54e94bc81114172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76eaa6bc38355a15d54e94bc81114172">&#9670;&#160;</a></span>getDualPricePrioritizeNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getDualPricePrioritizeNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
On some problem like stp3d or pds-100 this makes a huge difference in
speed and number of iterations of the dual simplex.
</pre><p><code>optional bool dual_price_prioritize_norm = 69 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>The dualPricePrioritizeNorm. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a1998dca33537524792d7dcbcc1927292">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#af0bdb03b9e980308ba2092de6d772a25">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a753494fa2147812d05c36caf9e9d46d7" name="a753494fa2147812d05c36caf9e9d46d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753494fa2147812d05c36caf9e9d46d7">&#9670;&#160;</a></span>getDualSmallPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getDualSmallPivotThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Like small_pivot_threshold but for the dual simplex. This is needed because
the dual algorithm does not interpret this value in the same way.
TODO(user): Clean this up and use the same small pivot detection.
</pre><p><code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code> </p><dl class="section return"><dt>Returns</dt><dd>The dualSmallPivotThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5ab097cb610dda08949890171d06f070">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a75f59c6346ef579e9bd36fd5aa83a180">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a396d448165bd34ab763804a90bad197d" name="a396d448165bd34ab763804a90bad197d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396d448165bd34ab763804a90bad197d">&#9670;&#160;</a></span>getDynamicallyAdjustRefactorizationPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getDynamicallyAdjustRefactorizationPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If this is true, then basis_refactorization_period becomes a lower bound on
the number of iterations between two refactorization (provided there is no
numerical accuracy issues). Depending on the estimated time to refactorize
vs the extra time spend in each solves because of the LU update, we try to
balance the two times.
</pre><p><code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The dynamicallyAdjustRefactorizationPeriod. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a87cc4f3b8c68c7c2181d9671c9422ead">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a12ff1ce0fe491597deff5ce3399d378d">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a6431d2897662a59578d0f5336b17a0e7" name="a6431d2897662a59578d0f5336b17a0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6431d2897662a59578d0f5336b17a0e7">&#9670;&#160;</a></span>getExploitSingletonColumnInInitialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getExploitSingletonColumnInInitialBasis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we exploit the singleton columns already present in the
problem when we create the initial basis.
</pre><p><code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The exploitSingletonColumnInInitialBasis. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5691de90839513fd97ce1e27b42ce89c">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a47ac0b5961f53c985253072ed2b173ef">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af634e1a2234d40106b00b24dd9ff90df" name="af634e1a2234d40106b00b24dd9ff90df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af634e1a2234d40106b00b24dd9ff90df">&#9670;&#160;</a></span>getFeasibilityRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1PricingRule.html">com.google.ortools.glop.GlopParameters.PricingRule</a> com.google.ortools.glop.GlopParametersOrBuilder.getFeasibilityRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
PricingRule to use during the feasibility phase.
</pre><p><code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code> </p><dl class="section return"><dt>Returns</dt><dd>The feasibilityRule. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a2210dedff092a33628aa183149f6364c">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a9eb31758d7938b09866c45697e6ee5e0">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a79f7cee79d876a4674d5e5c8e261047a" name="a79f7cee79d876a4674d5e5c8e261047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f7cee79d876a4674d5e5c8e261047a">&#9670;&#160;</a></span>getHarrisToleranceRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getHarrisToleranceRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
This impacts the ratio test and indicates by how much we allow a basic
variable value that we move to go out of bounds. The value should be in
[0.0, 1.0) and should be interpreted as a ratio of the
primal_feasibility_tolerance. Setting this to 0.0 basically disables the
Harris ratio test while setting this too close to 1.0 will make it
difficult to keep the variable values inside their bounds modulo the
primal_feasibility_tolerance.

Note that the same comment applies to the dual simplex ratio test. There,
we allow the reduced costs to be of an infeasible sign by as much as this
ratio times the dual_feasibility_tolerance.
</pre><p><code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code> </p><dl class="section return"><dt>Returns</dt><dd>The harrisToleranceRatio. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a7c329f387489927e63e8395fa3b3c348">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#af91e6ace5b4e845c3a6cd1d96dd93afe">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ac217fddbe2b01ad51c05c51ffa5dd99c" name="ac217fddbe2b01ad51c05c51ffa5dd99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac217fddbe2b01ad51c05c51ffa5dd99c">&#9670;&#160;</a></span>getInitialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1InitialBasisHeuristic.html">com.google.ortools.glop.GlopParameters.InitialBasisHeuristic</a> com.google.ortools.glop.GlopParametersOrBuilder.getInitialBasis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
What heuristic is used to try to replace the fixed slack columns in the
initial basis of the primal simplex.
</pre><p><code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code> </p><dl class="section return"><dt>Returns</dt><dd>The initialBasis. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a3c3e7dd504c26eda49f5e42c483e8e5e">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a30ce1a4af692d88b8b5b42a6525a0141">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ad3c807e6de7d506c59d2833bbdd3c52b" name="ad3c807e6de7d506c59d2833bbdd3c52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c807e6de7d506c59d2833bbdd3c52b">&#9670;&#160;</a></span>getInitialConditionNumberThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getInitialConditionNumberThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If our upper bound on the condition number of the initial basis (from our
heurisitic or a warm start) is above this threshold, we revert to an all
slack basis.
</pre><p><code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code> </p><dl class="section return"><dt>Returns</dt><dd>The initialConditionNumberThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5ecc7a3f0dc0b1f52cef349dcd662c18">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad9f079d9e99a76b32e0c83d5975c8395">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a7da47bb64441449725dd4122943306a0" name="a7da47bb64441449725dd4122943306a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da47bb64441449725dd4122943306a0">&#9670;&#160;</a></span>getInitializeDevexWithColumnNorms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getInitializeDevexWithColumnNorms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether we initialize devex weights to 1.0 or to the norms of the matrix
columns.
</pre><p><code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The initializeDevexWithColumnNorms. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#af37c0a6b2c470ff65f3e5c689c1ceab3">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a72a29ed4aab7e5640c815cf5c282ba40">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a4765fac898b4e5dfde0fc826b7764fca" name="a4765fac898b4e5dfde0fc826b7764fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4765fac898b4e5dfde0fc826b7764fca">&#9670;&#160;</a></span>getLogSearchProgress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getLogSearchProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, logs the progress of a solve to LOG(INFO). Note that the same
messages can also be turned on by displaying logs at level 1 for the
relevant files.
</pre><p><code>optional bool log_search_progress = 61 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>The logSearchProgress. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a1fdf3a5589739ed4b0f2c5f488b783db">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a4683009b0636496784275cc4d5559020">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="acd7fabb1f0fe4d182c11c5fb92b38dfe" name="acd7fabb1f0fe4d182c11c5fb92b38dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7fabb1f0fe4d182c11c5fb92b38dfe">&#9670;&#160;</a></span>getLogToStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getLogToStdout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, logs will be displayed to stdout instead of using Google log info.
</pre><p><code>optional bool log_to_stdout = 66 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The logToStdout. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a4c0bbafba0a54f93ae3eed1749a78565">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a802aa84ef583555b00dbb2e8a9d322a8">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a2b7bf5a01ec20e4f746b2118fe618155" name="a2b7bf5a01ec20e4f746b2118fe618155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7bf5a01ec20e4f746b2118fe618155">&#9670;&#160;</a></span>getLuFactorizationPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getLuFactorizationPivotThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Threshold for LU-factorization: for stability reasons, the magnitude of the
chosen pivot at a given step is guaranteed to be greater than this
threshold times the maximum magnitude of all the possible pivot choices in
the same column. The value must be in [0,1].
</pre><p><code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code> </p><dl class="section return"><dt>Returns</dt><dd>The luFactorizationPivotThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ae6bd6203551dba79369fa5aad2f1e7cc">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad16d6f591019d187effd5487af4d92f9">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a4ae8ac4cffb7d5250b4bb73de4a32bbb" name="a4ae8ac4cffb7d5250b4bb73de4a32bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae8ac4cffb7d5250b4bb73de4a32bbb">&#9670;&#160;</a></span>getMarkowitzSingularityThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getMarkowitzSingularityThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If a pivot magnitude is smaller than this during the Markowitz LU
factorization, then the matrix is assumed to be singular. Note that
this is an absolute threshold and is not relative to the other possible
pivots on the same column (see lu_factorization_pivot_threshold).
</pre><p><code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code> </p><dl class="section return"><dt>Returns</dt><dd>The markowitzSingularityThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a9653a6cbf436c0b3f650ae278e4cd796">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ae336acb2ad8d2c5fe08bf434197ba911">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a62054f5aa3bd7bb7c97ef153413e8100" name="a62054f5aa3bd7bb7c97ef153413e8100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62054f5aa3bd7bb7c97ef153413e8100">&#9670;&#160;</a></span>getMarkowitzZlatevParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com.google.ortools.glop.GlopParametersOrBuilder.getMarkowitzZlatevParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
How many columns do we look at in the Markowitz pivoting rule to find
a good pivot. See markowitz.h.
</pre><p><code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code> </p><dl class="section return"><dt>Returns</dt><dd>The markowitzZlatevParameter. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a119f61ea4f6d0d1b3efdb7b3aa634b5f">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a859581e027b85d29eaeef0a91dc5d027">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ae541aea6cf7a03f765071f2ffd72f8a7" name="ae541aea6cf7a03f765071f2ffd72f8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae541aea6cf7a03f765071f2ffd72f8a7">&#9670;&#160;</a></span>getMaxDeterministicTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getMaxDeterministicTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Maximum deterministic time allowed to solve a problem. The deterministic
time is more or less correlated to the running time, and its unit should
be around the second (at least on a Xeon(R) CPU E5-1650 v2 &amp;#64; 3.50GHz).

TODO(user): Improve the correlation.
</pre><p><code>optional double max_deterministic_time = 45 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>The maxDeterministicTime. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#adf7182a951c94c182908f1ab30725706">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a30cf364543baba3d98a262ccb369a9c6">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ac0d792d76bc39e838f4f96b37907c901" name="ac0d792d76bc39e838f4f96b37907c901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d792d76bc39e838f4f96b37907c901">&#9670;&#160;</a></span>getMaxNumberOfIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long com.google.ortools.glop.GlopParametersOrBuilder.getMaxNumberOfIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Maximum number of simplex iterations to solve a problem.
A value of -1 means no limit.
</pre><p><code>optional int64 max_number_of_iterations = 27 [default = -1];</code> </p><dl class="section return"><dt>Returns</dt><dd>The maxNumberOfIterations. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5e2da0c0ae2d53e20547f9a8b5c72633">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a31aabc1f864bf9109b23a13862a51ce3">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a16f5ab9c08f05dfad9dd90f29be702db" name="a16f5ab9c08f05dfad9dd90f29be702db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f5ab9c08f05dfad9dd90f29be702db">&#9670;&#160;</a></span>getMaxNumberOfReoptimizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getMaxNumberOfReoptimizations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When the solution of phase II is imprecise, we re-run the phase II with the
opposite algorithm from that imprecise solution (i.e., if primal or dual
simplex was used, we use dual or primal simplex, respectively). We repeat
such re-optimization until the solution is precise, or we hit this limit.
</pre><p><code>optional double max_number_of_reoptimizations = 56 [default = 40];</code> </p><dl class="section return"><dt>Returns</dt><dd>The maxNumberOfReoptimizations. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#add77c7419fa379e88be1983f8f067abd">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a308a90e94a05bd274d028d89b941d288">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a6d864146ccc9ffce0b0b9ff5f89ab9ea" name="a6d864146ccc9ffce0b0b9ff5f89ab9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d864146ccc9ffce0b0b9ff5f89ab9ea">&#9670;&#160;</a></span>getMaxTimeInSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getMaxTimeInSeconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Maximum time allowed in seconds to solve a problem.
</pre><p><code>optional double max_time_in_seconds = 26 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>The maxTimeInSeconds. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a857155283e8c0430d81470b3c11e8cc1">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a8d65d83d9dd9473d4cfb7ec6831cb83c">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a13e1e4a0e2eec8222fd4b891b8914fed" name="a13e1e4a0e2eec8222fd4b891b8914fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e1e4a0e2eec8222fd4b891b8914fed">&#9670;&#160;</a></span>getMaxValidMagnitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getMaxValidMagnitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Any finite values in the input LP must be below this threshold, otherwise
the model will be reported invalid. This is needed to avoid floating point
overflow when evaluating bounds * coeff for instance. In practice, users
shouldn't use super large values in an LP. With the default threshold, even
evaluating large constraint with variables at their bound shouldn't cause
any overflow.
</pre><p><code>optional double max_valid_magnitude = 199 [default = 1e+30];</code> </p><dl class="section return"><dt>Returns</dt><dd>The maxValidMagnitude. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ad74b5d163ea97bfd107a582d2c25427d">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aabebbc31fdcbab8c99962a7af8896521">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a644cd565a007caa2ab6e91206c647531" name="a644cd565a007caa2ab6e91206c647531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644cd565a007caa2ab6e91206c647531">&#9670;&#160;</a></span>getMinimumAcceptablePivot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getMinimumAcceptablePivot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We never follow a basis change with a pivot under this threshold.
</pre><p><code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code> </p><dl class="section return"><dt>Returns</dt><dd>The minimumAcceptablePivot. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a253772af17dcaacd897de58b1e33df32">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ab0ca535527a8de29a6749143253c04a7">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aea6a141e74359f694144686e8eb4af9e" name="aea6a141e74359f694144686e8eb4af9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6a141e74359f694144686e8eb4af9e">&#9670;&#160;</a></span>getNumOmpThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com.google.ortools.glop.GlopParametersOrBuilder.getNumOmpThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Number of threads in the OMP parallel sections. If left to 1, the code will
not create any OMP threads and will remain single-threaded.
</pre><p><code>optional int32 num_omp_threads = 44 [default = 1];</code> </p><dl class="section return"><dt>Returns</dt><dd>The numOmpThreads. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#adebc2092ca279adf15374c731d58b7b8">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a74efb899cc235e05eff775c762973e4f">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a1e08be278f19b55a3952b75c7710bc82" name="a1e08be278f19b55a3952b75c7710bc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e08be278f19b55a3952b75c7710bc82">&#9670;&#160;</a></span>getObjectiveLowerLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getObjectiveLowerLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
The solver will stop as soon as it has proven that the objective is smaller
than objective_lower_limit or greater than objective_upper_limit. Depending
on the simplex algorithm (primal or dual) and the optimization direction,
note that only one bound will be used at the time.

Important: The solver does not add any tolerances to these values, and as
soon as the objective (as computed by the solver, so with some imprecision)
crosses one of these bounds (strictly), the search will stop. It is up to
the client to add any tolerance if needed.
</pre><p><code>optional double objective_lower_limit = 40 [default = -inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>The objectiveLowerLimit. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a269da5b561261b38944c4c11e6c0e323">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#adb8c21aa09d190e47be744010299df50">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a19f2fc522b85ec6a4a29f0ed24fe543b" name="a19f2fc522b85ec6a4a29f0ed24fe543b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f2fc522b85ec6a4a29f0ed24fe543b">&#9670;&#160;</a></span>getObjectiveUpperLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getObjectiveUpperLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional double objective_upper_limit = 41 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>The objectiveUpperLimit. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a55b907679a160609fe4297a69ff120f9">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a51dbb5252d57fa4d63dba9f12afcd1bd">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a12a304249e2edfbe888051813cbecd80" name="a12a304249e2edfbe888051813cbecd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a304249e2edfbe888051813cbecd80">&#9670;&#160;</a></span>getOptimizationRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1PricingRule.html">com.google.ortools.glop.GlopParameters.PricingRule</a> com.google.ortools.glop.GlopParametersOrBuilder.getOptimizationRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
PricingRule to use during the optimization phase.
</pre><p><code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code> </p><dl class="section return"><dt>Returns</dt><dd>The optimizationRule. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a224671b98c3f3bfe467d0b146a626ef1">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ae8c52aec9c05576f2672da685a646c4a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a64374ab99b193a15c4fbf4f170408976" name="a64374ab99b193a15c4fbf4f170408976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64374ab99b193a15c4fbf4f170408976">&#9670;&#160;</a></span>getPerturbCostsInDualSimplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getPerturbCostsInDualSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When this is true, then the costs are randomly perturbed before the dual
simplex is even started. This has been shown to improve the dual simplex
performance. For a good reference, see Huangfu Q (2013) "High performance
simplex solver", Ph.D, dissertation, University of Edinburgh.
</pre><p><code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>The perturbCostsInDualSimplex. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a24c197113bd8ce1ed9373310dfbc62c1">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a11f3b64cbf363484f97ffa16ae8927a0">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aa80262c6c2035ce0e80f8d78f666b592" name="aa80262c6c2035ce0e80f8d78f666b592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80262c6c2035ce0e80f8d78f666b592">&#9670;&#160;</a></span>getPreprocessorZeroTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getPreprocessorZeroTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
A floating point tolerance used by the preprocessors. This is used for
things like detecting if two columns/rows are proportional or if an
interval is empty.

Note that the preprocessors also use solution_feasibility_tolerance() to
detect if a problem is infeasible.
</pre><p><code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code> </p><dl class="section return"><dt>Returns</dt><dd>The preprocessorZeroTolerance. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5554e48d05bcdc3becf2e361640a6aed">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a486e508d0f4907d3879b92b3f3a47198">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ada54fd9b40c20973115ebd273a60aa05" name="ada54fd9b40c20973115ebd273a60aa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada54fd9b40c20973115ebd273a60aa05">&#9670;&#160;</a></span>getPrimalFeasibilityTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getPrimalFeasibilityTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
This tolerance indicates by how much we allow the variable values to go out
of bounds and still consider the current solution primal-feasible. We also
use the same tolerance for the error A.x - b. Note that the two errors are
closely related if A is scaled in such a way that the greatest coefficient
magnitude on each column is 1.0.

This is also simply called feasibility tolerance in other solvers.
</pre><p><code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code> </p><dl class="section return"><dt>Returns</dt><dd>The primalFeasibilityTolerance. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#af4fd869bdff7ca2673baf3a5b1c13f99">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a08b9563dd9be3239f94b499f55bb7d30">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ab2a636e69a87155ac1b821dd3c391255" name="ab2a636e69a87155ac1b821dd3c391255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a636e69a87155ac1b821dd3c391255">&#9670;&#160;</a></span>getProvideStrongOptimalGuarantee()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getProvideStrongOptimalGuarantee </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, then when the solver returns a solution with an OPTIMAL status,
we can guarantee that:
- The primal variable are in their bounds.
- The dual variable are in their bounds.
- If we modify each component of the right-hand side a bit and each
  component of the objective function a bit, then the pair (primal values,
  dual values) is an EXACT optimal solution of the perturbed problem.
- The modifications above are smaller than the associated tolerances as
  defined in the comment for solution_feasibility_tolerance (*).

(*): This is the only place where the guarantee is not tight since we
compute the upper bounds with scalar product of the primal/dual
solution and the initial problem coefficients with only double precision.

Note that whether or not this option is true, we still check the
primal/dual infeasibility and objective gap. However if it is false, we
don't move the primal/dual values within their bounds and leave them
untouched.
</pre><p><code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The provideStrongOptimalGuarantee. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aa130cdbf75f0f62d5d42b140137844a4">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a2cedba2f03d06cff639d6bce032c8244">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a2fdbbef31d6916a17fe2fb9c80d6db54" name="a2fdbbef31d6916a17fe2fb9c80d6db54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdbbef31d6916a17fe2fb9c80d6db54">&#9670;&#160;</a></span>getPushToVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getPushToVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If the optimization phases finishes with super-basic variables (i.e.,
variables that either 1) have bounds but are FREE in the basis, or 2) have
no bounds and are FREE in the basis at a nonzero value), then run a "push"
phase to push these variables to bounds, obtaining a vertex solution. Note
this situation can happen only if a starting value was specified via
SetStartingVariableValuesForNextSolve().
</pre><p><code>optional bool push_to_vertex = 65 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The pushToVertex. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a9747096535cb1760594c8c5bfb169780">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aa51ee7b35729a0f1fbb58b570e0e053a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a8ed5c9fbb7cfa6002bc09770cd3a842d" name="a8ed5c9fbb7cfa6002bc09770cd3a842d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed5c9fbb7cfa6002bc09770cd3a842d">&#9670;&#160;</a></span>getRandomSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int com.google.ortools.glop.GlopParametersOrBuilder.getRandomSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
At the beginning of each solve, the random number generator used in some
part of the solver is reinitialized to this seed. If you change the random
seed, the solver may make different choices during the solving process.
Note that this may lead to a different solution, for example a different
optimal basis.

For some problems, the running time may vary a lot depending on small
change in the solving algorithm. Running the solver with different seeds
enables to have more robust benchmarks when evaluating new features.

Also note that the solver is fully deterministic: two runs of the same
binary, on the same machine, on the exact same data and with the same
parameters will go through the exact same iterations. If they hit a time
limit, they might of course yield different results because one will have
advanced farther than the other.
</pre><p><code>optional int32 random_seed = 43 [default = 1];</code> </p><dl class="section return"><dt>Returns</dt><dd>The randomSeed. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ab9931874afed53c63c97ec2709debcb2">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a42f69f22bfe848e887fcbe224c16890f">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a86c288236ebc4aa6e8762f8a5bbb96e1" name="a86c288236ebc4aa6e8762f8a5bbb96e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c288236ebc4aa6e8762f8a5bbb96e1">&#9670;&#160;</a></span>getRatioTestZeroThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getRatioTestZeroThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
During the primal simplex (resp. dual simplex), the coefficients of the
direction (resp. update row) with a magnitude lower than this threshold are
not considered during the ratio test. This tolerance is related to the
precision at which a Solve() involving the basis matrix can be performed.

TODO(user): Automatically increase it when we detect that the precision
of the Solve() is worse than this.
</pre><p><code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code> </p><dl class="section return"><dt>Returns</dt><dd>The ratioTestZeroThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5d78962166e5e0b47a20b49c60d29f56">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ac2a2b8f0365721945063e7f652bfe17f">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a92c4c2b0860293f41a7546f54685899c" name="a92c4c2b0860293f41a7546f54685899c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c4c2b0860293f41a7546f54685899c">&#9670;&#160;</a></span>getRecomputeEdgesNormThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getRecomputeEdgesNormThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Note that the threshold is a relative error on the actual norm (not the
squared one) and that edge norms are always greater than 1. Recomputing
norms is a really expensive operation and a large threshold is ok since
this doesn't impact directly the solution but just the entering variable
choice.
</pre><p><code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code> </p><dl class="section return"><dt>Returns</dt><dd>The recomputeEdgesNormThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a8a43bc3c5ea0f33a0c860ffeb29cd5ec">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ace79087faa204dd90c0e2bf6f2dc9a30">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ab62ba2a483dc9ff5cd26156f43908dcc" name="ab62ba2a483dc9ff5cd26156f43908dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62ba2a483dc9ff5cd26156f43908dcc">&#9670;&#160;</a></span>getRecomputeReducedCostsThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getRecomputeReducedCostsThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We estimate the accuracy of the iteratively computed reduced costs. If
it falls below this threshold, we reinitialize them from scratch. Note
that such an operation is pretty fast, so we can use a low threshold.
It is important to have a good accuracy here (better than the
dual_feasibility_tolerance below) to be sure of the sign of such a cost.
</pre><p><code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code> </p><dl class="section return"><dt>Returns</dt><dd>The recomputeReducedCostsThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a7d3bba1f3ce619245886310190a014c8">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ac17ae2b91ba6d93fdf1b87749482859d">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a0ad5d98242d252f68126d3f2b1f79373" name="a0ad5d98242d252f68126d3f2b1f79373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad5d98242d252f68126d3f2b1f79373">&#9670;&#160;</a></span>getRefactorizationThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getRefactorizationThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We estimate the factorization accuracy of B during each pivot by using
the fact that we can compute the pivot coefficient in two ways:
- From direction[leaving_row].
- From update_row[entering_column].
If the two values have a relative difference above this threshold, we
trigger a refactorization.
</pre><p><code>optional double refactorization_threshold = 6 [default = 1e-09];</code> </p><dl class="section return"><dt>Returns</dt><dd>The refactorizationThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#abec8598112d1bd448a205ae9d168ae9f">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a9c99063ec6a409478b5b8cb280801e68">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a8db3b7bdce0428b3b7e4577a15f602c3" name="a8db3b7bdce0428b3b7e4577a15f602c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db3b7bdce0428b3b7e4577a15f602c3">&#9670;&#160;</a></span>getRelativeCostPerturbation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getRelativeCostPerturbation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
The magnitude of the cost perturbation is given by
RandomIn(1.0, 2.0) * (
    relative_cost_perturbation * cost
  + relative_max_cost_perturbation * max_cost);
</pre><p><code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code> </p><dl class="section return"><dt>Returns</dt><dd>The relativeCostPerturbation. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a8c18cd06e1e852a105019e7f5efdfc16">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ab0b34373596a51078ffdbd6f1b34807a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a868b717f36b7f38db50b197d42a7c5d9" name="a868b717f36b7f38db50b197d42a7c5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868b717f36b7f38db50b197d42a7c5d9">&#9670;&#160;</a></span>getRelativeMaxCostPerturbation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getRelativeMaxCostPerturbation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code> </p><dl class="section return"><dt>Returns</dt><dd>The relativeMaxCostPerturbation. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#af33899445f897637f08c9492ce51a669">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad540bb796f8436939e44d02634e92c55">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a9febb7569532d7e603825104ee5d6527" name="a9febb7569532d7e603825104ee5d6527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9febb7569532d7e603825104ee5d6527">&#9670;&#160;</a></span>getScalingMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1ScalingAlgorithm.html">com.google.ortools.glop.GlopParameters.ScalingAlgorithm</a> com.google.ortools.glop.GlopParametersOrBuilder.getScalingMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code> </p><dl class="section return"><dt>Returns</dt><dd>The scalingMethod. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a1167124e2733c0ae7cf9d72fe26d9c20">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#adae827ab4f57f7c384c93e25fd046f65">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="adac7bcd8d379ef7597c7fbcc8abc89cc" name="adac7bcd8d379ef7597c7fbcc8abc89cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac7bcd8d379ef7597c7fbcc8abc89cc">&#9670;&#160;</a></span>getSmallPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getSmallPivotThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When we choose the leaving variable, we want to avoid small pivot because
they are the less precise and may cause numerical instabilities. For a
pivot under this threshold times the infinity norm of the direction, we try
various countermeasures in order to avoid using it.
</pre><p><code>optional double small_pivot_threshold = 14 [default = 1e-06];</code> </p><dl class="section return"><dt>Returns</dt><dd>The smallPivotThreshold. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a3bee9e33ed2c4ddc89db1c52b42f7f84">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ab5d9e0e3f4049fc6b84df57aecbe0fe4">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a68e8901ff92de143edf3577fae1bc15e" name="a68e8901ff92de143edf3577fae1bc15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e8901ff92de143edf3577fae1bc15e">&#9670;&#160;</a></span>getSolutionFeasibilityTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com.google.ortools.glop.GlopParametersOrBuilder.getSolutionFeasibilityTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When the problem status is OPTIMAL, we check the optimality using this
relative tolerance and change the status to IMPRECISE if an issue is
detected.

The tolerance is "relative" in the sense that our thresholds are:
- tolerance * max(1.0, abs(bound)) for crossing a given bound.
- tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
- tolerance for an infeasible dual value.
</pre><p><code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code> </p><dl class="section return"><dt>Returns</dt><dd>The solutionFeasibilityTolerance. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ab70ddcaaf3b8dcc2a7a67b6fd536350e">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aefd9c7ff3f39c7aea55e1df68e7ec78e">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af1d611164e4f2b2e89648b959af4efe5" name="af1d611164e4f2b2e89648b959af4efe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d611164e4f2b2e89648b959af4efe5">&#9670;&#160;</a></span>getSolveDualProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="enumcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1SolverBehavior.html">com.google.ortools.glop.GlopParameters.SolverBehavior</a> com.google.ortools.glop.GlopParametersOrBuilder.getSolveDualProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we solve the dual of the given problem.
With a value of auto, the algorithm decide which approach is probably the
fastest depending on the problem dimensions (see dualizer_threshold).
</pre><p><code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code> </p><dl class="section return"><dt>Returns</dt><dd>The solveDualProblem. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a51595a0062d9957ec6f580fd0fba5a6b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a16a40c0ca741c11f27be8f2797d93e0b">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a52437f824def118ad8305c4a90643a02" name="a52437f824def118ad8305c4a90643a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52437f824def118ad8305c4a90643a02">&#9670;&#160;</a></span>getUseDedicatedDualFeasibilityAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getUseDedicatedDualFeasibilityAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We have two possible dual phase I algorithms. Both work on an LP that
minimize the sum of dual infeasiblities. One use dedicated code (when this
param is true), the other one use exactly the same code as the dual phase
II but on an auxiliary problem where the variable bounds of the original
problem are changed.

TODO(user): For now we have both, but ideally the non-dedicated version
will win since it is a lot less code to maintain.
</pre><p><code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The useDedicatedDualFeasibilityAlgorithm. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a88ddc97e1fed5f8ce103fb0ee17bd7df">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a77cb1df544a724f836206d056ace9d40">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a2a58181a95ff2d4be7967c9170445250" name="a2a58181a95ff2d4be7967c9170445250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a58181a95ff2d4be7967c9170445250">&#9670;&#160;</a></span>getUseDualSimplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getUseDualSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we use the dual simplex algorithm instead of the primal.
</pre><p><code>optional bool use_dual_simplex = 31 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>The useDualSimplex. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#afd14ee62b48a31377ff83bec74bc3b39">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a11df276271c2c036644ec87e184f0c6f">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="adc1f15b416906598d1076410f0936bd2" name="adc1f15b416906598d1076410f0936bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1f15b416906598d1076410f0936bd2">&#9670;&#160;</a></span>getUseImpliedFreePreprocessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getUseImpliedFreePreprocessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If presolve runs, include the pass that detects implied free variables.
</pre><p><code>optional bool use_implied_free_preprocessor = 67 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The useImpliedFreePreprocessor. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a6f21e82aca4115f77cca2b4d275b680a">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a6a65173a225b89ad37e17c7743c29967">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a4be9f3b6c7a60c192460c6160c09ff7a" name="a4be9f3b6c7a60c192460c6160c09ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be9f3b6c7a60c192460c6160c09ff7a">&#9670;&#160;</a></span>getUseMiddleProductFormUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getUseMiddleProductFormUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not to use the middle product form update rather than the
standard eta LU update. The middle form product update should be a lot more
efficient (close to the Forrest-Tomlin update, a bit slower but easier to
implement). See for more details:
Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
simplex method", 28 january 2013, Technical Report ERGO-13-0001
<a href="http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf">http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf</a>
</pre><p><code>optional bool use_middle_product_form_update = 35 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The useMiddleProductFormUpdate. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a298eb9d367c5780a6c3d18e50fe06f0b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a891fe1e7ec6eaefefac55cdb0c9990f5">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ab2f34a7639c79b4206813d55c4f91a0d" name="ab2f34a7639c79b4206813d55c4f91a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f34a7639c79b4206813d55c4f91a0d">&#9670;&#160;</a></span>getUsePreprocessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getUsePreprocessing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we use advanced preprocessing techniques.
</pre><p><code>optional bool use_preprocessing = 34 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The usePreprocessing. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a43800ba78316d64fcdd30f9f68f86e84">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a8ddbd4b848369a7b0311405ae2ec673b">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a777b56df4b65d15df9d0503749452770" name="a777b56df4b65d15df9d0503749452770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777b56df4b65d15df9d0503749452770">&#9670;&#160;</a></span>getUseScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getUseScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we scale the matrix A so that the maximum coefficient on
each line and each column is 1.0.
</pre><p><code>optional bool use_scaling = 16 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The useScaling. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ac1d7fb7298d51e63ce0c9b64cb27e5f2">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a3ef0f82e72cbd852ee4f0cd0b95af8fd">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ad7b84271636acdd21cb8b646e9a08117" name="ad7b84271636acdd21cb8b646e9a08117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b84271636acdd21cb8b646e9a08117">&#9670;&#160;</a></span>getUseTransposedMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.getUseTransposedMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we keep a transposed version of the matrix A to speed-up the
pricing at the cost of extra memory and the initial tranposition
computation.
</pre><p><code>optional bool use_transposed_matrix = 18 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>The useTransposedMatrix. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ac8257d13c7495edfc084247a3431414c">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad4881aba630ac5fbfed025aa9b6ec4c2">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a7c6980720b1fec416145639286483e48" name="a7c6980720b1fec416145639286483e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6980720b1fec416145639286483e48">&#9670;&#160;</a></span>hasAllowSimplexAlgorithmChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasAllowSimplexAlgorithmChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
During incremental solve, let the solver decide if it use the primal or
dual simplex algorithm depending on the current solution and on the new
problem. Note that even if this is true, the value of use_dual_simplex
still indicates the default algorithm that the solver will use.
</pre><p><code>optional bool allow_simplex_algorithm_change = 32 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the allowSimplexAlgorithmChange field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#add6168297385d78dc516e149db51abec">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a41901c8b44f59457b918df3b701be1cd">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ac434ef15f7b64f6bf9f009e48a288269" name="ac434ef15f7b64f6bf9f009e48a288269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac434ef15f7b64f6bf9f009e48a288269">&#9670;&#160;</a></span>hasBasisRefactorizationPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasBasisRefactorizationPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Number of iterations between two basis refactorizations. Note that various
conditions in the algorithm may trigger a refactorization before this
period is reached. Set this to 0 if you want to refactorize at each step.
</pre><p><code>optional int32 basis_refactorization_period = 19 [default = 64];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the basisRefactorizationPeriod field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ac01ff4e2af576b6a5956844efef2f6d9">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a941ddb7af98bdbe4304c318588b04e1a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a378b5a277c72f1582faa6adc0bc8d25f" name="a378b5a277c72f1582faa6adc0bc8d25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378b5a277c72f1582faa6adc0bc8d25f">&#9670;&#160;</a></span>hasChangeStatusToImprecise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasChangeStatusToImprecise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, the internal API will change the return status to imprecise if the
solution does not respect the internal tolerances.
</pre><p><code>optional bool change_status_to_imprecise = 58 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the changeStatusToImprecise field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a1977039ad4f499fddbbfc6f6f73e9c27">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad7c6c85773278e2908d2b389a86ba8fd">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a96feadf405b3d70d4ed81d8dd4b44337" name="a96feadf405b3d70d4ed81d8dd4b44337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96feadf405b3d70d4ed81d8dd4b44337">&#9670;&#160;</a></span>hasCostScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasCostScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the costScaling field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a039aaeb24c2d910bf7de39306da83690">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aa505d0c9dab991a7a31c114b6fef7995">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a9b8fa40a3867e150950678ace20e5dde" name="a9b8fa40a3867e150950678ace20e5dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8fa40a3867e150950678ace20e5dde">&#9670;&#160;</a></span>hasCrossoverBoundSnappingDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasCrossoverBoundSnappingDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If the starting basis contains FREE variable with bounds, we will move
any such variable to their closer bounds if the distance is smaller than
this parameter.

The starting statuses can contains FREE variables with bounds, if a user
set it like this externally. Also, any variable with an initial BASIC
status that was not kept in the initial basis is marked as FREE before this
step is applied.

Note that by default a FREE variable is assumed to be zero unless a
starting value was specified via SetStartingVariableValuesForNextSolve().

Note that, at the end of the solve, some of these FREE variable with bounds
and an interior point value might still be left in the final solution.
Enable push_to_vertex to clean these up.
</pre><p><code>optional double crossover_bound_snapping_distance = 64 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the crossoverBoundSnappingDistance field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aaa9a7a68d9657331538f16386cda1a14">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a77267a3bcbbaf7cd7b1f8b6bdb2b724e">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af9c7b733637e5eba725b4b827b13028c" name="af9c7b733637e5eba725b4b827b13028c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c7b733637e5eba725b4b827b13028c">&#9670;&#160;</a></span>hasDegenerateMinistepFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDegenerateMinistepFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
During a degenerate iteration, the more conservative approach is to do a
step of length zero (while shifting the bound of the leaving variable).
That is, the variable values are unchanged for the primal simplex or the
reduced cost are unchanged for the dual simplex. However, instead of doing
a step of length zero, it seems to be better on degenerate problems to do a
small positive step. This is what is recommended in the EXPAND procedure
described in:
P. E. Gill, W. Murray, M. A. Saunders, and M. H. Wright. "A practical anti-
cycling procedure for linearly constrained optimization".
Mathematical Programming, 45:437&amp;#92;u2013474, 1989.

Here, during a degenerate iteration we do a small positive step of this
factor times the primal (resp. dual) tolerance. In the primal simplex, this
may effectively push variable values (very slightly) further out of their
bounds (resp. reduced costs for the dual simplex).

Setting this to zero reverts to the more conservative approach of a zero
step during degenerate iterations.
</pre><p><code>optional double degenerate_ministep_factor = 42 [default = 0.01];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the degenerateMinistepFactor field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a181778751002347813e75f462e140b2a">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a278b94188c1f7a26131e7a9fd6ef5e70">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a7a7736d7766bf0dcbe6cff8e534a6637" name="a7a7736d7766bf0dcbe6cff8e534a6637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7736d7766bf0dcbe6cff8e534a6637">&#9670;&#160;</a></span>hasDevexWeightsResetPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDevexWeightsResetPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Devex weights will be reset to 1.0 after that number of updates.
</pre><p><code>optional int32 devex_weights_reset_period = 33 [default = 150];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the devexWeightsResetPeriod field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a10b6902fde3221b09d3aaf1ed9650c30">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a9c5bc861f0800393631f64ad63807eda">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a0f72c9357eb7204f7437af91e57566d3" name="a0f72c9357eb7204f7437af91e57566d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f72c9357eb7204f7437af91e57566d3">&#9670;&#160;</a></span>hasDropTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDropTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
In order to increase the sparsity of the manipulated vectors, floating
point values with a magnitude smaller than this parameter are set to zero
(only in some places). This parameter should be positive or zero.
</pre><p><code>optional double drop_tolerance = 52 [default = 1e-14];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the dropTolerance field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#abb8ca6b7ea4fcd1e54e0271c47fabf3a">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a195099e2ccdaf63ba28b558a8aac487d">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aac26fda23f883dc187c931ddfa5bfcb0" name="aac26fda23f883dc187c931ddfa5bfcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac26fda23f883dc187c931ddfa5bfcb0">&#9670;&#160;</a></span>hasDualFeasibilityTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDualFeasibilityTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Variables whose reduced costs have an absolute value smaller than this
tolerance are not considered as entering candidates. That is they do not
take part in deciding whether a solution is dual-feasible or not.

Note that this value can temporarily increase during the execution of the
algorithm if the estimated precision of the reduced costs is higher than
this tolerance. Note also that we scale the costs (in the presolve step) so
that the cost magnitude range contains one.

This is also known as the optimality tolerance in other solvers.
</pre><p><code>optional double dual_feasibility_tolerance = 11 [default = 1e-08];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the dualFeasibilityTolerance field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aa69b94f3309eb775d1756a73f413a305">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a96d32db4add0ba58859b84d4268a5e40">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aace08259ab16d9ea673413dca43bd802" name="aace08259ab16d9ea673413dca43bd802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace08259ab16d9ea673413dca43bd802">&#9670;&#160;</a></span>hasDualizerThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDualizerThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When solve_dual_problem is LET_SOLVER_DECIDE, take the dual if the number
of constraints of the problem is more than this threshold times the number
of variables.
</pre><p><code>optional double dualizer_threshold = 21 [default = 1.5];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the dualizerThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aaafda8b98bbdc9cb597d37b67661c731">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a10a6ea84fa3ae1c8894a20d8d55cbac9">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ae9ef9b78768b004c1adab607e2c6f605" name="ae9ef9b78768b004c1adab607e2c6f605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ef9b78768b004c1adab607e2c6f605">&#9670;&#160;</a></span>hasDualPricePrioritizeNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDualPricePrioritizeNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
On some problem like stp3d or pds-100 this makes a huge difference in
speed and number of iterations of the dual simplex.
</pre><p><code>optional bool dual_price_prioritize_norm = 69 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the dualPricePrioritizeNorm field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#afc365031902270ac71ce73282ffebf9d">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a507f985476320f67162bcbb811df85b3">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aa0eb674de5a2faa9feb086de90481f2b" name="aa0eb674de5a2faa9feb086de90481f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eb674de5a2faa9feb086de90481f2b">&#9670;&#160;</a></span>hasDualSmallPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDualSmallPivotThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Like small_pivot_threshold but for the dual simplex. This is needed because
the dual algorithm does not interpret this value in the same way.
TODO(user): Clean this up and use the same small pivot detection.
</pre><p><code>optional double dual_small_pivot_threshold = 38 [default = 0.0001];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the dualSmallPivotThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a0c2d131aefed0209965e840e341a46ae">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad164a763c789996c2f101c2159db686a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a8ea89f77e6fe1c1944882e3a5d00ca9f" name="a8ea89f77e6fe1c1944882e3a5d00ca9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea89f77e6fe1c1944882e3a5d00ca9f">&#9670;&#160;</a></span>hasDynamicallyAdjustRefactorizationPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasDynamicallyAdjustRefactorizationPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If this is true, then basis_refactorization_period becomes a lower bound on
the number of iterations between two refactorization (provided there is no
numerical accuracy issues). Depending on the estimated time to refactorize
vs the extra time spend in each solves because of the LU update, we try to
balance the two times.
</pre><p><code>optional bool dynamically_adjust_refactorization_period = 63 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the dynamicallyAdjustRefactorizationPeriod field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a9f98f0580fe6f54b8e2184add215fe0c">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a83fcdbf715cc75e5ea8ee4dc66c51f4a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af61772acdda660c5b6d99b6bbef8f2f5" name="af61772acdda660c5b6d99b6bbef8f2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61772acdda660c5b6d99b6bbef8f2f5">&#9670;&#160;</a></span>hasExploitSingletonColumnInInitialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasExploitSingletonColumnInInitialBasis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we exploit the singleton columns already present in the
problem when we create the initial basis.
</pre><p><code>optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the exploitSingletonColumnInInitialBasis field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aa4cbdd2cb84b258bfb24e8e90eda9053">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a07bc21d3dda575bfb8c6a79174820708">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a17152932ac2754d2483b15f0cbbcf087" name="a17152932ac2754d2483b15f0cbbcf087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17152932ac2754d2483b15f0cbbcf087">&#9670;&#160;</a></span>hasFeasibilityRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasFeasibilityRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
PricingRule to use during the feasibility phase.
</pre><p><code>optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the feasibilityRule field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a3afc12b15dfe4485b442d9829499c4e3">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#acf7aca4cbc7e35f9dbf704c2a3a9f153">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a30d75029ce0436565584381905110bb2" name="a30d75029ce0436565584381905110bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d75029ce0436565584381905110bb2">&#9670;&#160;</a></span>hasHarrisToleranceRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasHarrisToleranceRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
This impacts the ratio test and indicates by how much we allow a basic
variable value that we move to go out of bounds. The value should be in
[0.0, 1.0) and should be interpreted as a ratio of the
primal_feasibility_tolerance. Setting this to 0.0 basically disables the
Harris ratio test while setting this too close to 1.0 will make it
difficult to keep the variable values inside their bounds modulo the
primal_feasibility_tolerance.

Note that the same comment applies to the dual simplex ratio test. There,
we allow the reduced costs to be of an infeasible sign by as much as this
ratio times the dual_feasibility_tolerance.
</pre><p><code>optional double harris_tolerance_ratio = 13 [default = 0.5];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the harrisToleranceRatio field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a4aa1b6ea7fd7a820e799de93f9fe5411">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad3f11184f90e39fedd1774474170e9a9">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ac13ea69bc6052c5f0f54b5328738435f" name="ac13ea69bc6052c5f0f54b5328738435f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13ea69bc6052c5f0f54b5328738435f">&#9670;&#160;</a></span>hasInitialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasInitialBasis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
What heuristic is used to try to replace the fixed slack columns in the
initial basis of the primal simplex.
</pre><p><code>optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the initialBasis field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a7b2a12ec0b98ffbe5e7734eb6e077b8d">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#abecacc776ded847e8e8c42168d34fd68">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a6739734eab3ea8e96f3b789a7619348f" name="a6739734eab3ea8e96f3b789a7619348f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6739734eab3ea8e96f3b789a7619348f">&#9670;&#160;</a></span>hasInitialConditionNumberThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasInitialConditionNumberThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If our upper bound on the condition number of the initial basis (from our
heurisitic or a warm start) is above this threshold, we revert to an all
slack basis.
</pre><p><code>optional double initial_condition_number_threshold = 59 [default = 1e+50];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the initialConditionNumberThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a5677631860737b2c82d8c321aa709b43">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#afd3639220a9d4147a6fed8825eeee5bc">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a9dda59c0fc003bbaa895658aa70f13b1" name="a9dda59c0fc003bbaa895658aa70f13b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dda59c0fc003bbaa895658aa70f13b1">&#9670;&#160;</a></span>hasInitializeDevexWithColumnNorms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasInitializeDevexWithColumnNorms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether we initialize devex weights to 1.0 or to the norms of the matrix
columns.
</pre><p><code>optional bool initialize_devex_with_column_norms = 36 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the initializeDevexWithColumnNorms field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a07996cac3bf1ec7fab6fa8ce581d85df">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a894973f82c1c9eaed4d2cf21bf1e5509">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ab56fc9d9628af347713d2a063216e360" name="ab56fc9d9628af347713d2a063216e360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56fc9d9628af347713d2a063216e360">&#9670;&#160;</a></span>hasLogSearchProgress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasLogSearchProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, logs the progress of a solve to LOG(INFO). Note that the same
messages can also be turned on by displaying logs at level 1 for the
relevant files.
</pre><p><code>optional bool log_search_progress = 61 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the logSearchProgress field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a9b77480dbc9795478fdcc699fa4637fb">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a3700f309526a382692102110a1d696df">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a1b73e797e1481c044b2517d9e77832e7" name="a1b73e797e1481c044b2517d9e77832e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b73e797e1481c044b2517d9e77832e7">&#9670;&#160;</a></span>hasLogToStdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasLogToStdout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, logs will be displayed to stdout instead of using Google log info.
</pre><p><code>optional bool log_to_stdout = 66 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the logToStdout field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a171c53ddd4023ed17a2b913d5af78571">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a4a0e4b52f7d62a89c7dfd1fe199d3d69">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a99a42f2ecd280800713c7587f36154ba" name="a99a42f2ecd280800713c7587f36154ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a42f2ecd280800713c7587f36154ba">&#9670;&#160;</a></span>hasLuFactorizationPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasLuFactorizationPivotThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Threshold for LU-factorization: for stability reasons, the magnitude of the
chosen pivot at a given step is guaranteed to be greater than this
threshold times the maximum magnitude of all the possible pivot choices in
the same column. The value must be in [0,1].
</pre><p><code>optional double lu_factorization_pivot_threshold = 25 [default = 0.01];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the luFactorizationPivotThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ad778c5ed92e827410c28efdea3f705e3">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ad4dd65ff2c5cb8265eb845d0012e0e94">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aa2c7171d16a7f89e42d206c08d211f9a" name="aa2c7171d16a7f89e42d206c08d211f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c7171d16a7f89e42d206c08d211f9a">&#9670;&#160;</a></span>hasMarkowitzSingularityThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMarkowitzSingularityThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If a pivot magnitude is smaller than this during the Markowitz LU
factorization, then the matrix is assumed to be singular. Note that
this is an absolute threshold and is not relative to the other possible
pivots on the same column (see lu_factorization_pivot_threshold).
</pre><p><code>optional double markowitz_singularity_threshold = 30 [default = 1e-15];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the markowitzSingularityThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a41ead82ea88387cb7f005272f86bc27b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#afbba7d434efeacf275ad2a91ccb976c8">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ac2d6c4338ce851deaf361df5d3395f84" name="ac2d6c4338ce851deaf361df5d3395f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d6c4338ce851deaf361df5d3395f84">&#9670;&#160;</a></span>hasMarkowitzZlatevParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMarkowitzZlatevParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
How many columns do we look at in the Markowitz pivoting rule to find
a good pivot. See markowitz.h.
</pre><p><code>optional int32 markowitz_zlatev_parameter = 29 [default = 3];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the markowitzZlatevParameter field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ad66e40682ef805a6b8f620deb5a55790">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a04c14cdfc213dcebfbeba35a52ea1d32">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af35ad2e2b849c4418f23363bd294ca1b" name="af35ad2e2b849c4418f23363bd294ca1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35ad2e2b849c4418f23363bd294ca1b">&#9670;&#160;</a></span>hasMaxDeterministicTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMaxDeterministicTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Maximum deterministic time allowed to solve a problem. The deterministic
time is more or less correlated to the running time, and its unit should
be around the second (at least on a Xeon(R) CPU E5-1650 v2 &amp;#64; 3.50GHz).

TODO(user): Improve the correlation.
</pre><p><code>optional double max_deterministic_time = 45 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the maxDeterministicTime field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a6394bb6c8026dcd618dfe6eabe797664">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a2b70d115643396bc9dc03b80e013866a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ab9a8fc93775f349538b0f90f6b1266c2" name="ab9a8fc93775f349538b0f90f6b1266c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a8fc93775f349538b0f90f6b1266c2">&#9670;&#160;</a></span>hasMaxNumberOfIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMaxNumberOfIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Maximum number of simplex iterations to solve a problem.
A value of -1 means no limit.
</pre><p><code>optional int64 max_number_of_iterations = 27 [default = -1];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the maxNumberOfIterations field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a6f7f7ef267588beb3b6dc91ac5cf8b00">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a5d9523f96e9e019e97090b4eb1392b2f">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a995bf2182e7c53616504cce5a9140937" name="a995bf2182e7c53616504cce5a9140937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995bf2182e7c53616504cce5a9140937">&#9670;&#160;</a></span>hasMaxNumberOfReoptimizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMaxNumberOfReoptimizations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When the solution of phase II is imprecise, we re-run the phase II with the
opposite algorithm from that imprecise solution (i.e., if primal or dual
simplex was used, we use dual or primal simplex, respectively). We repeat
such re-optimization until the solution is precise, or we hit this limit.
</pre><p><code>optional double max_number_of_reoptimizations = 56 [default = 40];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the maxNumberOfReoptimizations field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aec9bfc0bf4560191827bb99bae52f76a">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a56d57d80f2f614e13627b40018ea04e4">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a0e570d95069a9b181cee0d9a26e20ebc" name="a0e570d95069a9b181cee0d9a26e20ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e570d95069a9b181cee0d9a26e20ebc">&#9670;&#160;</a></span>hasMaxTimeInSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMaxTimeInSeconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Maximum time allowed in seconds to solve a problem.
</pre><p><code>optional double max_time_in_seconds = 26 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the maxTimeInSeconds field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a1bf24bde65fa7cef604bd2fd6bdd5d39">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aa6b25a629a89d7f4b2a168ae8061a9a1">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a7922c0fd1ee413d57b2b0ca9bc14aa73" name="a7922c0fd1ee413d57b2b0ca9bc14aa73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7922c0fd1ee413d57b2b0ca9bc14aa73">&#9670;&#160;</a></span>hasMaxValidMagnitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMaxValidMagnitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Any finite values in the input LP must be below this threshold, otherwise
the model will be reported invalid. This is needed to avoid floating point
overflow when evaluating bounds * coeff for instance. In practice, users
shouldn't use super large values in an LP. With the default threshold, even
evaluating large constraint with variables at their bound shouldn't cause
any overflow.
</pre><p><code>optional double max_valid_magnitude = 199 [default = 1e+30];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the maxValidMagnitude field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a8f3b9a4de93e42434aa547b225e9b555">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ab3328d1b77039b5d0ceb005883b42a69">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a4b7ab5f510ccf852c2922e6a84a222bb" name="a4b7ab5f510ccf852c2922e6a84a222bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7ab5f510ccf852c2922e6a84a222bb">&#9670;&#160;</a></span>hasMinimumAcceptablePivot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasMinimumAcceptablePivot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We never follow a basis change with a pivot under this threshold.
</pre><p><code>optional double minimum_acceptable_pivot = 15 [default = 1e-06];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the minimumAcceptablePivot field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a3a800db36588ed7ce34726e387715a05">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a475bc08edb813c65175fee21bd2355d2">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ae4fa25667a66b83889210156d12b9dfc" name="ae4fa25667a66b83889210156d12b9dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fa25667a66b83889210156d12b9dfc">&#9670;&#160;</a></span>hasNumOmpThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasNumOmpThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Number of threads in the OMP parallel sections. If left to 1, the code will
not create any OMP threads and will remain single-threaded.
</pre><p><code>optional int32 num_omp_threads = 44 [default = 1];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the numOmpThreads field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ac543472ca61a4f1040b0d687ebf34e2e">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a6295582a29a1ba97a2861a27ba7e1df7">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aaf5aa44b2b7adbea2f5045c175ddcb3e" name="aaf5aa44b2b7adbea2f5045c175ddcb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5aa44b2b7adbea2f5045c175ddcb3e">&#9670;&#160;</a></span>hasObjectiveLowerLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasObjectiveLowerLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
The solver will stop as soon as it has proven that the objective is smaller
than objective_lower_limit or greater than objective_upper_limit. Depending
on the simplex algorithm (primal or dual) and the optimization direction,
note that only one bound will be used at the time.

Important: The solver does not add any tolerances to these values, and as
soon as the objective (as computed by the solver, so with some imprecision)
crosses one of these bounds (strictly), the search will stop. It is up to
the client to add any tolerance if needed.
</pre><p><code>optional double objective_lower_limit = 40 [default = -inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the objectiveLowerLimit field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a8129ea90fa6cb7a2ad0443830de360fc">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a6dd17537c18a4f5de4b3b5e86d1ec206">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="abfb3499ec18aa86849c18c493373fd20" name="abfb3499ec18aa86849c18c493373fd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb3499ec18aa86849c18c493373fd20">&#9670;&#160;</a></span>hasObjectiveUpperLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasObjectiveUpperLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional double objective_upper_limit = 41 [default = inf];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the objectiveUpperLimit field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ada7ca7dc34e52b3d308ba944f1b588ac">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aa01786f3ab84bfda369783b41b2c0c69">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a33ed3d3852c22a715547eac1dc1d965e" name="a33ed3d3852c22a715547eac1dc1d965e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ed3d3852c22a715547eac1dc1d965e">&#9670;&#160;</a></span>hasOptimizationRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasOptimizationRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
PricingRule to use during the optimization phase.
</pre><p><code>optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the optimizationRule field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a3f3ffd0bbfb70d71cb8fc8728c81e55f">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a97371f691fd3feac15f110a7d3ad1482">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a1487ba12eb996411f8b78296fa6b7533" name="a1487ba12eb996411f8b78296fa6b7533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1487ba12eb996411f8b78296fa6b7533">&#9670;&#160;</a></span>hasPerturbCostsInDualSimplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasPerturbCostsInDualSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When this is true, then the costs are randomly perturbed before the dual
simplex is even started. This has been shown to improve the dual simplex
performance. For a good reference, see Huangfu Q (2013) "High performance
simplex solver", Ph.D, dissertation, University of Edinburgh.
</pre><p><code>optional bool perturb_costs_in_dual_simplex = 53 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the perturbCostsInDualSimplex field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a6f06f970c111d188c96be0758610db6b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#acd03ce3b0fa50310a7b666d2dd553b20">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a5aaf12f94185980f5aefaaef018003e7" name="a5aaf12f94185980f5aefaaef018003e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaf12f94185980f5aefaaef018003e7">&#9670;&#160;</a></span>hasPreprocessorZeroTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasPreprocessorZeroTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
A floating point tolerance used by the preprocessors. This is used for
things like detecting if two columns/rows are proportional or if an
interval is empty.

Note that the preprocessors also use solution_feasibility_tolerance() to
detect if a problem is infeasible.
</pre><p><code>optional double preprocessor_zero_tolerance = 39 [default = 1e-09];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the preprocessorZeroTolerance field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a286fbe8c6c2f6783382ac89128a35300">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a259e7c21648f07cdd64d8b9a0d6528c1">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a54173d0ec7f85e646fa94c435f9017a5" name="a54173d0ec7f85e646fa94c435f9017a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54173d0ec7f85e646fa94c435f9017a5">&#9670;&#160;</a></span>hasPrimalFeasibilityTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasPrimalFeasibilityTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
This tolerance indicates by how much we allow the variable values to go out
of bounds and still consider the current solution primal-feasible. We also
use the same tolerance for the error A.x - b. Note that the two errors are
closely related if A is scaled in such a way that the greatest coefficient
magnitude on each column is 1.0.

This is also simply called feasibility tolerance in other solvers.
</pre><p><code>optional double primal_feasibility_tolerance = 10 [default = 1e-08];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the primalFeasibilityTolerance field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a0885ea7b2abeb66412dee317dd400480">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a396f945c3c7b8b5fbbe635280de395ae">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ac420e8e885658f73f7747713b13743dd" name="ac420e8e885658f73f7747713b13743dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac420e8e885658f73f7747713b13743dd">&#9670;&#160;</a></span>hasProvideStrongOptimalGuarantee()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasProvideStrongOptimalGuarantee </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If true, then when the solver returns a solution with an OPTIMAL status,
we can guarantee that:
- The primal variable are in their bounds.
- The dual variable are in their bounds.
- If we modify each component of the right-hand side a bit and each
  component of the objective function a bit, then the pair (primal values,
  dual values) is an EXACT optimal solution of the perturbed problem.
- The modifications above are smaller than the associated tolerances as
  defined in the comment for solution_feasibility_tolerance (*).

(*): This is the only place where the guarantee is not tight since we
compute the upper bounds with scalar product of the primal/dual
solution and the initial problem coefficients with only double precision.

Note that whether or not this option is true, we still check the
primal/dual infeasibility and objective gap. However if it is false, we
don't move the primal/dual values within their bounds and leave them
untouched.
</pre><p><code>optional bool provide_strong_optimal_guarantee = 24 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the provideStrongOptimalGuarantee field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a102f64781223319fdd3383c6c14aedec">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aa88bfda106aca5b418c8f9ee2ec95bd3">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="ae63d018a50c9a663f31d158b1a398cc5" name="ae63d018a50c9a663f31d158b1a398cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63d018a50c9a663f31d158b1a398cc5">&#9670;&#160;</a></span>hasPushToVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasPushToVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If the optimization phases finishes with super-basic variables (i.e.,
variables that either 1) have bounds but are FREE in the basis, or 2) have
no bounds and are FREE in the basis at a nonzero value), then run a "push"
phase to push these variables to bounds, obtaining a vertex solution. Note
this situation can happen only if a starting value was specified via
SetStartingVariableValuesForNextSolve().
</pre><p><code>optional bool push_to_vertex = 65 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the pushToVertex field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a2fa956c7fdc9b6559b3581ecac8cc9de">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#adcb8da3a8e4a5f3233342489c22bc731">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a14f84c519e0d95bb3ef30a117207984e" name="a14f84c519e0d95bb3ef30a117207984e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f84c519e0d95bb3ef30a117207984e">&#9670;&#160;</a></span>hasRandomSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasRandomSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
At the beginning of each solve, the random number generator used in some
part of the solver is reinitialized to this seed. If you change the random
seed, the solver may make different choices during the solving process.
Note that this may lead to a different solution, for example a different
optimal basis.

For some problems, the running time may vary a lot depending on small
change in the solving algorithm. Running the solver with different seeds
enables to have more robust benchmarks when evaluating new features.

Also note that the solver is fully deterministic: two runs of the same
binary, on the same machine, on the exact same data and with the same
parameters will go through the exact same iterations. If they hit a time
limit, they might of course yield different results because one will have
advanced farther than the other.
</pre><p><code>optional int32 random_seed = 43 [default = 1];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the randomSeed field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ac953e054e7c8cb4b2e2bb5ad972416de">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#af1d794c2ee8c8c5ae79586906e152f79">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a03201546d79bdc99feb199d3abc51233" name="a03201546d79bdc99feb199d3abc51233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03201546d79bdc99feb199d3abc51233">&#9670;&#160;</a></span>hasRatioTestZeroThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasRatioTestZeroThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
During the primal simplex (resp. dual simplex), the coefficients of the
direction (resp. update row) with a magnitude lower than this threshold are
not considered during the ratio test. This tolerance is related to the
precision at which a Solve() involving the basis matrix can be performed.

TODO(user): Automatically increase it when we detect that the precision
of the Solve() is worse than this.
</pre><p><code>optional double ratio_test_zero_threshold = 12 [default = 1e-09];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the ratioTestZeroThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a1c0c06dd5e0aeffccb82d0e67a9b51b8">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a35030ed0e1afd781637fc588bbb6c476">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aac2eafe9f79b4eb827f6df049148cda8" name="aac2eafe9f79b4eb827f6df049148cda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2eafe9f79b4eb827f6df049148cda8">&#9670;&#160;</a></span>hasRecomputeEdgesNormThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasRecomputeEdgesNormThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Note that the threshold is a relative error on the actual norm (not the
squared one) and that edge norms are always greater than 1. Recomputing
norms is a really expensive operation and a large threshold is ok since
this doesn't impact directly the solution but just the entering variable
choice.
</pre><p><code>optional double recompute_edges_norm_threshold = 9 [default = 100];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the recomputeEdgesNormThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ad51d111b32981a06bfc20c362fd992b1">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aed5f716654fa3c744e550ee7048ba8dc">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a09f19bf67c1260ea4639d16e96169651" name="a09f19bf67c1260ea4639d16e96169651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f19bf67c1260ea4639d16e96169651">&#9670;&#160;</a></span>hasRecomputeReducedCostsThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasRecomputeReducedCostsThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We estimate the accuracy of the iteratively computed reduced costs. If
it falls below this threshold, we reinitialize them from scratch. Note
that such an operation is pretty fast, so we can use a low threshold.
It is important to have a good accuracy here (better than the
dual_feasibility_tolerance below) to be sure of the sign of such a cost.
</pre><p><code>optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the recomputeReducedCostsThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a44e9eb375f8a7c841970e7c4dbfc5b38">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a0b831dd51da8559d262d89ca4c80461f">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="abfc95a6ef1ce64d7265d3b5a998ca781" name="abfc95a6ef1ce64d7265d3b5a998ca781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc95a6ef1ce64d7265d3b5a998ca781">&#9670;&#160;</a></span>hasRefactorizationThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasRefactorizationThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We estimate the factorization accuracy of B during each pivot by using
the fact that we can compute the pivot coefficient in two ways:
- From direction[leaving_row].
- From update_row[entering_column].
If the two values have a relative difference above this threshold, we
trigger a refactorization.
</pre><p><code>optional double refactorization_threshold = 6 [default = 1e-09];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the refactorizationThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a394cf178c1239421e0235f7e128405c9">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a8e42795683674273fee1184c6eec069b">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="af220bfd71a7abc8cd01d3338b00e7b7a" name="af220bfd71a7abc8cd01d3338b00e7b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af220bfd71a7abc8cd01d3338b00e7b7a">&#9670;&#160;</a></span>hasRelativeCostPerturbation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasRelativeCostPerturbation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
The magnitude of the cost perturbation is given by
RandomIn(1.0, 2.0) * (
    relative_cost_perturbation * cost
  + relative_max_cost_perturbation * max_cost);
</pre><p><code>optional double relative_cost_perturbation = 54 [default = 1e-05];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the relativeCostPerturbation field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ad10d775f67ba46751dfb5cbe07a1473b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a5ed495e09fd46d46ff7d818f9e680856">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a9c6511649735e18fb9a9953ac0507fcf" name="a9c6511649735e18fb9a9953ac0507fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6511649735e18fb9a9953ac0507fcf">&#9670;&#160;</a></span>hasRelativeMaxCostPerturbation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasRelativeMaxCostPerturbation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional double relative_max_cost_perturbation = 55 [default = 1e-07];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the relativeMaxCostPerturbation field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ab7aad94f1375cf8774b7f0e046d444eb">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#af735c721cbf70eec65de189fa4beeb04">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a537a7accd43fe4936816ec92974844d3" name="a537a7accd43fe4936816ec92974844d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a7accd43fe4936816ec92974844d3">&#9670;&#160;</a></span>hasScalingMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasScalingMethod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the scalingMethod field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aad9d5326cce01be06fc3431bd143fd2c">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a58e6a8a41a1008752e2d2675da37242e">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a421765b93f831ddeedc3ccea237e2f6e" name="a421765b93f831ddeedc3ccea237e2f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421765b93f831ddeedc3ccea237e2f6e">&#9670;&#160;</a></span>hasSmallPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasSmallPivotThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When we choose the leaving variable, we want to avoid small pivot because
they are the less precise and may cause numerical instabilities. For a
pivot under this threshold times the infinity norm of the direction, we try
various countermeasures in order to avoid using it.
</pre><p><code>optional double small_pivot_threshold = 14 [default = 1e-06];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the smallPivotThreshold field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a0125c79d6dc850a12cc5f9b779a8dba0">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a626cca29ce066519ab4629c31ffbde09">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a9826793e31d57cc82f015844fa53738c" name="a9826793e31d57cc82f015844fa53738c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9826793e31d57cc82f015844fa53738c">&#9670;&#160;</a></span>hasSolutionFeasibilityTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasSolutionFeasibilityTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
When the problem status is OPTIMAL, we check the optimality using this
relative tolerance and change the status to IMPRECISE if an issue is
detected.

The tolerance is "relative" in the sense that our thresholds are:
- tolerance * max(1.0, abs(bound)) for crossing a given bound.
- tolerance * max(1.0, abs(cost)) for an infeasible reduced cost.
- tolerance for an infeasible dual value.
</pre><p><code>optional double solution_feasibility_tolerance = 22 [default = 1e-06];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the solutionFeasibilityTolerance field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ae81d02c3203d92fcb56ae495ac88da21">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#aa9b0ab055af434ab99f43a5e111ee1cc">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a07fddc6861c1636dcd3d261a3c011016" name="a07fddc6861c1636dcd3d261a3c011016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fddc6861c1636dcd3d261a3c011016">&#9670;&#160;</a></span>hasSolveDualProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasSolveDualProblem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we solve the dual of the given problem.
With a value of auto, the algorithm decide which approach is probably the
fastest depending on the problem dimensions (see dualizer_threshold).
</pre><p><code>optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the solveDualProblem field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a2c87e413829620fa8d3c850abc76d177">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a369094b8488169bfc336760bf6bafc72">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="acb2c22b9ca5af5c2f535fdd214c1c53b" name="acb2c22b9ca5af5c2f535fdd214c1c53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2c22b9ca5af5c2f535fdd214c1c53b">&#9670;&#160;</a></span>hasUseDedicatedDualFeasibilityAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasUseDedicatedDualFeasibilityAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
We have two possible dual phase I algorithms. Both work on an LP that
minimize the sum of dual infeasiblities. One use dedicated code (when this
param is true), the other one use exactly the same code as the dual phase
II but on an auxiliary problem where the variable bounds of the original
problem are changed.

TODO(user): For now we have both, but ideally the non-dedicated version
will win since it is a lot less code to maintain.
</pre><p><code>optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the useDedicatedDualFeasibilityAlgorithm field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a8e5d8e8eaed7209cda22c4f71dbd2a06">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a102c57d33486bc6d5863bb407def1230">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="aebb3431c1b7058d844e59375e161ffd6" name="aebb3431c1b7058d844e59375e161ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3431c1b7058d844e59375e161ffd6">&#9670;&#160;</a></span>hasUseDualSimplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasUseDualSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we use the dual simplex algorithm instead of the primal.
</pre><p><code>optional bool use_dual_simplex = 31 [default = false];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the useDualSimplex field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a996d3809b80567279f04c3ca8edbf04b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a6ad4ff852cb286f857517d6ce8f260f3">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a5fcc98856831c2fc6ec297d58040adb7" name="a5fcc98856831c2fc6ec297d58040adb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcc98856831c2fc6ec297d58040adb7">&#9670;&#160;</a></span>hasUseImpliedFreePreprocessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasUseImpliedFreePreprocessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
If presolve runs, include the pass that detects implied free variables.
</pre><p><code>optional bool use_implied_free_preprocessor = 67 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the useImpliedFreePreprocessor field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ae889738dd68d86e60660f03d0802443f">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a25fa4409fd67eac083ab36e814c1abe6">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a55d84593884ed6d9861243d059f8dac0" name="a55d84593884ed6d9861243d059f8dac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d84593884ed6d9861243d059f8dac0">&#9670;&#160;</a></span>hasUseMiddleProductFormUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasUseMiddleProductFormUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not to use the middle product form update rather than the
standard eta LU update. The middle form product update should be a lot more
efficient (close to the Forrest-Tomlin update, a bit slower but easier to
implement). See for more details:
Qi Huangfu, J. A. Julian Hall, "Novel update techniques for the revised
simplex method", 28 january 2013, Technical Report ERGO-13-0001
<a href="http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf">http://www.maths.ed.ac.uk/hall/HuHa12/ERGO-13-001.pdf</a>
</pre><p><code>optional bool use_middle_product_form_update = 35 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the useMiddleProductFormUpdate field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#aefeb42c1b78ad0a811f65ce6e6908de8">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a2df19510039cef372ba7aba7bac6c5bc">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a21723afc146157a00d496d53b6f44ca2" name="a21723afc146157a00d496d53b6f44ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21723afc146157a00d496d53b6f44ca2">&#9670;&#160;</a></span>hasUsePreprocessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasUsePreprocessing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we use advanced preprocessing techniques.
</pre><p><code>optional bool use_preprocessing = 34 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the usePreprocessing field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a6190b532798e3edca3b3ba7c50d43f3b">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a45502bc907e6afbd170fd80eaec8837a">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a01841739b6a158f221bdca095231212f" name="a01841739b6a158f221bdca095231212f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01841739b6a158f221bdca095231212f">&#9670;&#160;</a></span>hasUseScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasUseScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we scale the matrix A so that the maximum coefficient on
each line and each column is 1.0.
</pre><p><code>optional bool use_scaling = 16 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the useScaling field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#ae8d52d0d9992225f08729254c80555c0">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#ae7ae8e5412cc0eb267b040866199e22c">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<a id="a259beb5104af867a47d3d357e2181385" name="a259beb5104af867a47d3d357e2181385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259beb5104af867a47d3d357e2181385">&#9670;&#160;</a></span>hasUseTransposedMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean com.google.ortools.glop.GlopParametersOrBuilder.hasUseTransposedMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
Whether or not we keep a transposed version of the matrix A to speed-up the
pricing at the cost of extra memory and the initial tranposition
computation.
</pre><p><code>optional bool use_transposed_matrix = 18 [default = true];</code> </p><dl class="section return"><dt>Returns</dt><dd>Whether the useTransposedMatrix field is set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters.html#a9e527f2c8c16e232df0026e705fa8ec5">com.google.ortools.glop.GlopParameters</a>, and <a class="el" href="classcom_1_1google_1_1ortools_1_1glop_1_1GlopParameters_1_1Builder.html#a0592aab7f59f39da4d4879f47ebddfda">com.google.ortools.glop.GlopParameters.Builder</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>build/java/ortools-java/src/main/java/com/google/ortools/glop/<a class="el" href="GlopParametersOrBuilder_8java_source.html">GlopParametersOrBuilder.java</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>com</b></li><li class="navelem"><b>google</b></li><li class="navelem"><a class="el" href="namespacecom_1_1google_1_1ortools.html">ortools</a></li><li class="navelem"><a class="el" href="namespacecom_1_1google_1_1ortools_1_1glop.html">glop</a></li><li class="navelem"><a class="el" href="interfacecom_1_1google_1_1ortools_1_1glop_1_1GlopParametersOrBuilder.html">GlopParametersOrBuilder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
