<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 10.0.2"/>
    <title>ortools.sat.python.cp_model API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>
            <img src="https://developers.google.com/optimization/images/orLogo.png" class="logo" alt="project logo"/>




        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="function" href="#DisplayBounds">DisplayBounds</a>
            </li>
            <li>
                    <a class="function" href="#ShortName">ShortName</a>
            </li>
            <li>
                    <a class="function" href="#ShortExprName">ShortExprName</a>
            </li>
            <li>
                    <a class="class" href="#LinearExpr">LinearExpr</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#LinearExpr.__init__">LinearExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#LinearExpr.Sum">Sum</a>
                        </li>
                        <li>
                                <a class="function" href="#LinearExpr.WeightedSum">WeightedSum</a>
                        </li>
                        <li>
                                <a class="function" href="#LinearExpr.Term">Term</a>
                        </li>
                        <li>
                                <a class="function" href="#LinearExpr.IsEmptyOrAllNull">IsEmptyOrAllNull</a>
                        </li>
                        <li>
                                <a class="function" href="#LinearExpr.RebuildFromLinearExpressionProto">RebuildFromLinearExpressionProto</a>
                        </li>
                        <li>
                                <a class="function" href="#LinearExpr.GetIntegerVarValueMap">GetIntegerVarValueMap</a>
                        </li>
                        <li>
                                <a class="function" href="#LinearExpr.GetFloatVarValueMap">GetFloatVarValueMap</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVar">IntVar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVar.__init__">IntVar</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Index">Index</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Proto">Proto</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.IsEqualTo">IsEqualTo</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Name">Name</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Not">Not</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#BoundedLinearExpression">BoundedLinearExpression</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BoundedLinearExpression.__init__">BoundedLinearExpression</a>
                        </li>
                        <li>
                                <a class="function" href="#BoundedLinearExpression.Expression">Expression</a>
                        </li>
                        <li>
                                <a class="function" href="#BoundedLinearExpression.Bounds">Bounds</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Constraint">Constraint</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Constraint.__init__">Constraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.OnlyEnforceIf">OnlyEnforceIf</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Index">Index</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Proto">Proto</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntervalVar">IntervalVar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntervalVar.__init__">IntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.Index">Index</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.Proto">Proto</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.Name">Name</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartExpr">StartExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SizeExpr">SizeExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndExpr">EndExpr</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#ObjectIsATrueLiteral">ObjectIsATrueLiteral</a>
            </li>
            <li>
                    <a class="function" href="#ObjectIsAFalseLiteral">ObjectIsAFalseLiteral</a>
            </li>
            <li>
                    <a class="class" href="#CpModel">CpModel</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#CpModel.__init__">CpModel</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewIntVar">NewIntVar</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewIntVarFromDomain">NewIntVarFromDomain</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewBoolVar">NewBoolVar</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewConstant">NewConstant</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddLinearConstraint">AddLinearConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddLinearExpressionInDomain">AddLinearExpressionInDomain</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.Add">Add</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAllDifferent">AddAllDifferent</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddElement">AddElement</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddCircuit">AddCircuit</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddMultipleCircuit">AddMultipleCircuit</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAllowedAssignments">AddAllowedAssignments</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddForbiddenAssignments">AddForbiddenAssignments</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAutomaton">AddAutomaton</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddInverse">AddInverse</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddReservoirConstraint">AddReservoirConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddReservoirConstraintWithActive">AddReservoirConstraintWithActive</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddMapDomain">AddMapDomain</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddImplication">AddImplication</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddBoolOr">AddBoolOr</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAtLeastOne">AddAtLeastOne</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAtMostOne">AddAtMostOne</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddExactlyOne">AddExactlyOne</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddBoolAnd">AddBoolAnd</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddBoolXOr">AddBoolXOr</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddMinEquality">AddMinEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddMaxEquality">AddMaxEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddDivisionEquality">AddDivisionEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAbsEquality">AddAbsEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddModuloEquality">AddModuloEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddMultiplicationEquality">AddMultiplicationEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewIntervalVar">NewIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewFixedSizeIntervalVar">NewFixedSizeIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewOptionalIntervalVar">NewOptionalIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.NewOptionalFixedSizeIntervalVar">NewOptionalFixedSizeIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddNoOverlap">AddNoOverlap</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddNoOverlap2D">AddNoOverlap2D</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddCumulative">AddCumulative</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.CopyFrom">CopyFrom</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.GetBoolVarFromProtoIndex">GetBoolVarFromProtoIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.GetIntVarFromProtoIndex">GetIntVarFromProtoIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.GetIntervalVarFromProtoIndex">GetIntervalVarFromProtoIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.Proto">Proto</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.Negated">Negated</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.GetOrMakeIndex">GetOrMakeIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.GetOrMakeBooleanIndex">GetOrMakeBooleanIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.GetIntervalIndex">GetIntervalIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.GetOrMakeIndexFromConstant">GetOrMakeIndexFromConstant</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.VarIndexToVarProto">VarIndexToVarProto</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.ParseLinearExpression">ParseLinearExpression</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.Minimize">Minimize</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.Maximize">Maximize</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.HasObjective">HasObjective</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddDecisionStrategy">AddDecisionStrategy</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.ModelStats">ModelStats</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.Validate">Validate</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.ExportToFile">ExportToFile</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AssertIsBooleanVariable">AssertIsBooleanVariable</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddHint">AddHint</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.ClearHints">ClearHints</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAssumption">AddAssumption</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.AddAssumptions">AddAssumptions</a>
                        </li>
                        <li>
                                <a class="function" href="#CpModel.ClearAssumptions">ClearAssumptions</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#ExpandGeneratorOrTuple">ExpandGeneratorOrTuple</a>
            </li>
            <li>
                    <a class="function" href="#EvaluateLinearExpr">EvaluateLinearExpr</a>
            </li>
            <li>
                    <a class="function" href="#EvaluateBooleanExpression">EvaluateBooleanExpression</a>
            </li>
            <li>
                    <a class="class" href="#CpSolver">CpSolver</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#CpSolver.__init__">CpSolver</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.Solve">Solve</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.SolveWithSolutionCallback">SolveWithSolutionCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.SearchForAllSolutions">SearchForAllSolutions</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.StopSearch">StopSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.BooleanValue">BooleanValue</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.ObjectiveValue">ObjectiveValue</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.BestObjectiveBound">BestObjectiveBound</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.StatusName">StatusName</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.NumBooleans">NumBooleans</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.NumConflicts">NumConflicts</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.NumBranches">NumBranches</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.WallTime">WallTime</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.UserTime">UserTime</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.ResponseStats">ResponseStats</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.ResponseProto">ResponseProto</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.SufficientAssumptionsForInfeasibility">SufficientAssumptionsForInfeasibility</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolver.SolutionInfo">SolutionInfo</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#CpSolverSolutionCallback">CpSolverSolutionCallback</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#CpSolverSolutionCallback.__init__">CpSolverSolutionCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolverSolutionCallback.OnSolutionCallback">OnSolutionCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolverSolutionCallback.BooleanValue">BooleanValue</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolverSolutionCallback.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#CpSolverSolutionCallback.Response">Response</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ObjectiveSolutionPrinter">ObjectiveSolutionPrinter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ObjectiveSolutionPrinter.__init__">ObjectiveSolutionPrinter</a>
                        </li>
                        <li>
                                <a class="function" href="#ObjectiveSolutionPrinter.on_solution_callback">on_solution_callback</a>
                        </li>
                        <li>
                                <a class="function" href="#ObjectiveSolutionPrinter.solution_count">solution_count</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#VarArrayAndObjectiveSolutionPrinter">VarArrayAndObjectiveSolutionPrinter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#VarArrayAndObjectiveSolutionPrinter.__init__">VarArrayAndObjectiveSolutionPrinter</a>
                        </li>
                        <li>
                                <a class="function" href="#VarArrayAndObjectiveSolutionPrinter.on_solution_callback">on_solution_callback</a>
                        </li>
                        <li>
                                <a class="function" href="#VarArrayAndObjectiveSolutionPrinter.solution_count">solution_count</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#VarArraySolutionPrinter">VarArraySolutionPrinter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#VarArraySolutionPrinter.__init__">VarArraySolutionPrinter</a>
                        </li>
                        <li>
                                <a class="function" href="#VarArraySolutionPrinter.on_solution_callback">on_solution_callback</a>
                        </li>
                        <li>
                                <a class="function" href="#VarArraySolutionPrinter.solution_count">solution_count</a>
                        </li>
                </ul>

            </li>
    </ul>


            <footer>OR-Tools 9.3</footer>

        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
ortools<wbr>.sat<wbr>.python<wbr>.cp_model    </h1>

                        <div class="docstring"><p>Methods for building and solving CP-SAT models.</p>

<p>The following two sections describe the main
methods for building and solving CP-SAT models.</p>

<ul>
<li><a href="#cp_model.CpModel"><code>CpModel</code></a>: Methods for creating
models, including variables and constraints.</li>
<li><a href="#cp_model.CpSolver"><code>CPSolver</code></a>: Methods for solving
a model and evaluating solutions.</li>
</ul>

<p>The following methods implement callbacks that the
solver calls each time it finds a new solution.</p>

<ul>
<li><a href="#cp_model.CpSolverSolutionCallback"><code>CpSolverSolutionCallback</code></a>:
A general method for implementing callbacks.</li>
<li><a href="#cp_model.ObjectiveSolutionPrinter"><code>ObjectiveSolutionPrinter</code></a>:
Print objective values and elapsed time for intermediate solutions.</li>
<li><a href="#cp_model.VarArraySolutionPrinter"><code>VarArraySolutionPrinter</code></a>:
Print intermediate solutions (variable values, time).</li>
<li>[<code><a href="#VarArrayAndObjectiveSolutionPrinter">VarArrayAndObjectiveSolutionPrinter</a></code>]
  (#cp_model.VarArrayAndObjectiveSolutionPrinter):
Print both intermediate solutions and objective values.</li>
</ul>

<p>Additional methods for solving CP-SAT models:</p>

<ul>
<li><a href="#cp_model.Constraint"><code>Constraint</code></a>: A few utility methods for modifying
constraints created by <code><a href="#CpModel">CpModel</a></code>.</li>
<li><a href="#lineacp_model.LinearExpr"><code>LinearExpr</code></a>: Methods for creating constraints
and the objective from large arrays of coefficients.</li>
</ul>

<p>Other methods and functions listed are primarily used for developing OR-Tools,
rather than for solving specific optimization problems.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="c1"># Copyright 2010-2021 Google LLC</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="sd">&quot;&quot;&quot;Methods for building and solving CP-SAT models.</span>

<span class="sd">The following two sections describe the main</span>
<span class="sd">methods for building and solving CP-SAT models.</span>

<span class="sd">* [`CpModel`](#cp_model.CpModel): Methods for creating</span>
<span class="sd">models, including variables and constraints.</span>
<span class="sd">* [`CPSolver`](#cp_model.CpSolver): Methods for solving</span>
<span class="sd">a model and evaluating solutions.</span>

<span class="sd">The following methods implement callbacks that the</span>
<span class="sd">solver calls each time it finds a new solution.</span>

<span class="sd">* [`CpSolverSolutionCallback`](#cp_model.CpSolverSolutionCallback):</span>
<span class="sd">  A general method for implementing callbacks.</span>
<span class="sd">* [`ObjectiveSolutionPrinter`](#cp_model.ObjectiveSolutionPrinter):</span>
<span class="sd">  Print objective values and elapsed time for intermediate solutions.</span>
<span class="sd">* [`VarArraySolutionPrinter`](#cp_model.VarArraySolutionPrinter):</span>
<span class="sd">  Print intermediate solutions (variable values, time).</span>
<span class="sd">* [`VarArrayAndObjectiveSolutionPrinter`]</span>
<span class="sd">      (#cp_model.VarArrayAndObjectiveSolutionPrinter):</span>
<span class="sd">  Print both intermediate solutions and objective values.</span>

<span class="sd">Additional methods for solving CP-SAT models:</span>

<span class="sd">* [`Constraint`](#cp_model.Constraint): A few utility methods for modifying</span>
<span class="sd">  constraints created by `CpModel`.</span>
<span class="sd">* [`LinearExpr`](#lineacp_model.LinearExpr): Methods for creating constraints</span>
<span class="sd">  and the objective from large arrays of coefficients.</span>

<span class="sd">Other methods and functions listed are primarily used for developing OR-Tools,</span>
<span class="sd">rather than for solving specific optimization problems.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">ortools.sat</span> <span class="kn">import</span> <span class="n">cp_model_pb2</span>
<span class="kn">from</span> <span class="nn">ortools.sat</span> <span class="kn">import</span> <span class="n">sat_parameters_pb2</span>
<span class="kn">from</span> <span class="nn">ortools.sat.python</span> <span class="kn">import</span> <span class="n">cp_model_helper</span> <span class="k">as</span> <span class="n">cmh</span>
<span class="kn">from</span> <span class="nn">ortools.sat.python</span> <span class="kn">import</span> <span class="n">swig_helper</span>
<span class="kn">from</span> <span class="nn">ortools.util.python</span> <span class="kn">import</span> <span class="n">sorted_interval_list</span>

<span class="n">Domain</span> <span class="o">=</span> <span class="n">sorted_interval_list</span><span class="o">.</span><span class="n">Domain</span>

<span class="c1"># The classes below allow linear expressions to be expressed naturally with the</span>
<span class="c1"># usual arithmetic operators + - * / and with constant numbers, which makes the</span>
<span class="c1"># python API very intuitive. See../ samples/*.py for examples.</span>

<span class="n">INT_MIN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9223372036854775808</span>  <span class="c1"># hardcoded to be platform independent.</span>
<span class="n">INT_MAX</span> <span class="o">=</span> <span class="mi">9223372036854775807</span>
<span class="n">INT32_MAX</span> <span class="o">=</span> <span class="mi">2147483647</span>
<span class="n">INT32_MIN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483648</span>

<span class="c1"># CpSolver status (exported to avoid importing cp_model_cp2).</span>
<span class="n">UNKNOWN</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">UNKNOWN</span>
<span class="n">MODEL_INVALID</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">MODEL_INVALID</span>
<span class="n">FEASIBLE</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">FEASIBLE</span>
<span class="n">INFEASIBLE</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">INFEASIBLE</span>
<span class="n">OPTIMAL</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">OPTIMAL</span>

<span class="c1"># Variable selection strategy</span>
<span class="n">CHOOSE_FIRST</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">CHOOSE_FIRST</span>
<span class="n">CHOOSE_LOWEST_MIN</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">CHOOSE_LOWEST_MIN</span>
<span class="n">CHOOSE_HIGHEST_MAX</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">CHOOSE_HIGHEST_MAX</span>
<span class="n">CHOOSE_MIN_DOMAIN_SIZE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">CHOOSE_MIN_DOMAIN_SIZE</span><span class="p">)</span>
<span class="n">CHOOSE_MAX_DOMAIN_SIZE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">CHOOSE_MAX_DOMAIN_SIZE</span><span class="p">)</span>

<span class="c1"># Domain reduction strategy</span>
<span class="n">SELECT_MIN_VALUE</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">SELECT_MIN_VALUE</span>
<span class="n">SELECT_MAX_VALUE</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">SELECT_MAX_VALUE</span>
<span class="n">SELECT_LOWER_HALF</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">SELECT_LOWER_HALF</span>
<span class="n">SELECT_UPPER_HALF</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">DecisionStrategyProto</span><span class="o">.</span><span class="n">SELECT_UPPER_HALF</span>

<span class="c1"># Search branching</span>
<span class="n">AUTOMATIC_SEARCH</span> <span class="o">=</span> <span class="n">sat_parameters_pb2</span><span class="o">.</span><span class="n">SatParameters</span><span class="o">.</span><span class="n">AUTOMATIC_SEARCH</span>
<span class="n">FIXED_SEARCH</span> <span class="o">=</span> <span class="n">sat_parameters_pb2</span><span class="o">.</span><span class="n">SatParameters</span><span class="o">.</span><span class="n">FIXED_SEARCH</span>
<span class="n">PORTFOLIO_SEARCH</span> <span class="o">=</span> <span class="n">sat_parameters_pb2</span><span class="o">.</span><span class="n">SatParameters</span><span class="o">.</span><span class="n">PORTFOLIO_SEARCH</span>
<span class="n">LP_SEARCH</span> <span class="o">=</span> <span class="n">sat_parameters_pb2</span><span class="o">.</span><span class="n">SatParameters</span><span class="o">.</span><span class="n">LP_SEARCH</span>


<span class="k">def</span> <span class="nf">DisplayBounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Displays a flattened list of intervals.&quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;..&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">ShortName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a short name of an integer variable, or its negation.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;Not(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">ShortName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">DisplayBounds</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ShortExprName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pretty-print LinearExpressionProto instances.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">vars</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">var_name</span> <span class="o">=</span> <span class="n">ShortName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">var_name</span>
        <span class="k">elif</span> <span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;-</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s1"> * </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1"> + </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="c1"># TODO(user): Support more than affine expressions.</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LinearExpr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Holds an integer linear expression.</span>

<span class="sd">  A linear expression is built from integer constants and variables.</span>
<span class="sd">  For example, `x + 2 * (y - z + 1)`.</span>

<span class="sd">  Linear expressions are used in CP-SAT models in constraints and in the</span>
<span class="sd">  objective:</span>

<span class="sd">  * You can define linear constraints as in:</span>

<span class="sd">  ```</span>
<span class="sd">  model.Add(x + 2 * y &lt;= 5)</span>
<span class="sd">  model.Add(sum(array_of_vars) == 5)</span>
<span class="sd">  ```</span>

<span class="sd">  * In CP-SAT, the objective is a linear expression:</span>

<span class="sd">  ```</span>
<span class="sd">  model.Minimize(x + 2 * y + z)</span>
<span class="sd">  ```</span>

<span class="sd">  * For large arrays, using the LinearExpr class is faster that using the python</span>
<span class="sd">  `sum()` function. You can create constraints and the objective from lists of</span>
<span class="sd">  linear expressions or coefficients as follows:</span>

<span class="sd">  ```</span>
<span class="sd">  model.Minimize(cp_model.LinearExpr.Sum(expressions))</span>
<span class="sd">  model.Add(cp_model.LinearExpr.WeightedSum(expressions, coefficients) &gt;= 0)</span>
<span class="sd">  ```</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the expression sum(expressions).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_SumArray</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">WeightedSum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the expression sum(expressions[i] * coefficients[i]).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">IsEmptyOrAllNull</span><span class="p">(</span><span class="n">coefficients</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_WeightedSum</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Term</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates `expression * coefficient`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">coefficient</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expression</span> <span class="o">*</span> <span class="n">coefficient</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">IsEmptyOrAllNull</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefficients</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">RebuildFromLinearExpressionProto</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">proto</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recreate a LinearExpr from a LinearExpressionProto.&quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">offset</span>
        <span class="n">num_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">proto</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">(),</span> <span class="n">proto</span><span class="o">.</span><span class="n">coeffs</span><span class="p">()):</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">IntVar</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                    <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">all_ones</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_SumArray</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_WeightedSum</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntegerVarValueMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scans the expression, and returns (var_coef_map, constant).&quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>  <span class="c1"># Flatten to avoid recursion.</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">-=</span> <span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">constant</span>

    <span class="k">def</span> <span class="nf">GetFloatVarValueMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scans the expression. Returns (var_coef_map, constant, is_integer).&quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>  <span class="c1"># Flatten to avoid recursion.</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>  <span class="c1"># Keep integrality.</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">-=</span> <span class="n">coeff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">is_integer</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_integer</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                    <span class="n">is_integer</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">is_integer</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling abs() on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddAbsEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">_ProductCst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">_ProductCst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling / on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddDivisionEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling // on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddDivisionEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling </span><span class="si">%%</span><span class="s1"> on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddModuloEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling ** on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddMultiplicationEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling left shift on a linear expression is not supported&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling right shift on a linear expression is not supported&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling and on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddBoolAnd&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling or on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddBoolOr&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling xor on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddBoolXor&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ProductCst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Evaluating a LinearExpr instance as a Boolean is not implemented.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span><span class="p">,</span> <span class="n">arg</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">arg</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;&lt; INT_MIN is not supported&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">arg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;&gt; INT_MAX is not supported&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">arg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span>
                                           <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">_Sum</span><span class="p">(</span><span class="n">LinearExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the sum of two LinearExprs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not an linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">Left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__left</span>

    <span class="k">def</span> <span class="nf">Right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__right</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__left</span><span class="si">}</span><span class="s1"> + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__right</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Sum(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__left</span><span class="p">)</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__right</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span>


<span class="k">class</span> <span class="nc">_ProductCst</span><span class="p">(</span><span class="n">LinearExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the product of a LinearExpr by a constant.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__coef</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__coef</span> <span class="o">=</span> <span class="n">coeff</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__coef</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__coef</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; * &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;ProductCst(&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__coef</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

    <span class="k">def</span> <span class="nf">Coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__coef</span>

    <span class="k">def</span> <span class="nf">Expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span>


<span class="k">class</span> <span class="nc">_SumArray</span><span class="p">(</span><span class="n">LinearExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the sum of a list of LinearExpr and a constant.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">=</span> <span class="n">constant</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not an linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1"> + </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span><span class="p">)),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;SumArray(</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span>

    <span class="k">def</span> <span class="nf">Constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span>


<span class="k">class</span> <span class="nc">_WeightedSum</span><span class="p">(</span><span class="n">LinearExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents sum(ai * xi) + b.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__coefficients</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">=</span> <span class="n">constant</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;In the LinearExpr.WeightedSum method, the expression array and the &#39;</span>
                <span class="s1">&#39; coefficient array must have the same length.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">+=</span> <span class="n">e</span> <span class="o">*</span> <span class="n">c</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__coefficients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not an linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__coefficients</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">output</span> <span class="ow">and</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">output</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">output</span> <span class="ow">and</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_minus_one</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">output</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39; + </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_minus_one</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39; - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">coeff</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39; + </span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">coeff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39; - </span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">-</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39; + </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__constant</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="s1">&#39; - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">__constant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;WeightedSum([</span><span class="si">{}</span><span class="s1">], [</span><span class="si">{}</span><span class="s1">], </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span><span class="p">)),</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__coefficients</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions</span>

    <span class="k">def</span> <span class="nf">Coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__coefficients</span>

    <span class="k">def</span> <span class="nf">Constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span>


<span class="k">class</span> <span class="nc">IntVar</span><span class="p">(</span><span class="n">LinearExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An integer variable.</span>

<span class="sd">  An IntVar is an object that can take on any integer value within defined</span>
<span class="sd">  ranges. Variables appear in constraint like:</span>

<span class="sd">      x + y &gt;= 5</span>
<span class="sd">      AllDifferent([x, y, z])</span>

<span class="sd">  Solving a model is equivalent to finding, for each variable, a single value</span>
<span class="sd">  from the set of initial values (called the initial domain), such that the</span>
<span class="sd">  model is feasible, or optimal if you provided an objective function.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See CpModel.NewIntVar below.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Python do not support multiple __init__ methods.</span>
        <span class="c1"># This method is only called from the CpModel class.</span>
        <span class="c1"># We hack the parameter to support the two cases:</span>
        <span class="c1"># case 1:</span>
        <span class="c1">#     model is a CpModelProto, domain is a Domain, and name is a string.</span>
        <span class="c1"># case 2:</span>
        <span class="c1">#     model is a CpModelProto, domain is an index (int), and name is None.</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">FlattenedIntervals</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the variable in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the variable protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span>

    <span class="k">def</span> <span class="nf">IsEqualTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if self == other in the python sense.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span>
                  <span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># Special case for constants.</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;unnamed_var_</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">DisplayBounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the negation of a Boolean variable.</span>

<span class="sd">    This method implements the logical negation of a Boolean variable.</span>
<span class="sd">    It is only valid if the variable has a Boolean domain (0 or 1).</span>

<span class="sd">    Note that this method is nilpotent: `x.Not().Not() == x`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bound</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot call Not on a non boolean variable: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="o">=</span> <span class="n">_NotBooleanVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span>


<span class="k">class</span> <span class="nc">_NotBooleanVariable</span><span class="p">(</span><span class="n">LinearExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Negation of a boolean variable.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__boolvar</span> <span class="o">=</span> <span class="n">boolvar</span>

    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">__boolvar</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__boolvar</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;not(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Evaluating a literal as a Boolean value is not implemented.&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BoundedLinearExpression</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a linear constraint: `lb &lt;= linear expression &lt;= ub`.</span>

<span class="sd">  The only use of this class is to be added to the CpModel through</span>
<span class="sd">  `CpModel.Add(expression)`, as in:</span>

<span class="sd">      model.Add(x + 2 * y -1 &gt;= z)</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="o">&gt;</span> <span class="n">INT_MIN</span> <span class="ow">and</span> <span class="n">ub</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lb</span> <span class="o">==</span> <span class="n">ub</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; == &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &lt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &lt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lb</span> <span class="o">&gt;</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &gt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ub</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &lt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;True (unbounded expr &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MIN</span> <span class="ow">and</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; != &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in [&#39;</span> <span class="o">+</span> <span class="n">DisplayBounds</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>

    <span class="k">def</span> <span class="nf">Expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span>

    <span class="k">def</span> <span class="nf">Bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
        <span class="n">all_coeffs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coeffs_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">same_var</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">eq_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">different_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ne_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">all_coeffs</span> <span class="o">==</span> <span class="n">same_var</span> <span class="ow">and</span>
                <span class="n">constant</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">eq_bounds</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">ne_bounds</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">eq_bounds</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">all_coeffs</span> <span class="o">==</span> <span class="n">different_vars</span> <span class="ow">and</span>
                <span class="n">constant</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">eq_bounds</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">ne_bounds</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">ne_bounds</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Evaluating a BoundedLinearExpression </span><span class="se">\&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1"> as a Boolean value&#39;</span>
            <span class="o">+</span> <span class="s1">&#39; is not supported.&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Constraint</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for constraints.</span>

<span class="sd">  Constraints are built by the CpModel through the Add&lt;XXX&gt; methods.</span>
<span class="sd">  Once created by the CpModel class, they are automatically added to the model.</span>
<span class="sd">  The purpose of this class is to allow specification of enforcement literals</span>
<span class="sd">  for this constraint.</span>

<span class="sd">      b = model.NewBoolVar(&#39;b&#39;)</span>
<span class="sd">      x = model.NewIntVar(0, 10, &#39;x&#39;)</span>
<span class="sd">      y = model.NewIntVar(0, 10, &#39;y&#39;)</span>

<span class="sd">      model.Add(x + 2 * y == 5).OnlyEnforceIf(b.Not())</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span> <span class="o">=</span> <span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">OnlyEnforceIf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">boolvar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an enforcement literal to the constraint.</span>

<span class="sd">    This method adds one or more literals (that is, a boolean variable or its</span>
<span class="sd">    negation) as enforcement literals. The conjunction of all these literals</span>
<span class="sd">    determines whether the constraint is active or not. It acts as an</span>
<span class="sd">    implication, so if the conjunction is true, it implies that the constraint</span>
<span class="sd">    must be enforced. If it is false, then the constraint is ignored.</span>

<span class="sd">    BoolOr, BoolAnd, and linear constraints all support enforcement literals.</span>

<span class="sd">    Args:</span>
<span class="sd">      *boolvar: One or more Boolean literals.</span>

<span class="sd">    Returns:</span>
<span class="sd">      self.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">boolvar</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">bool</span><span class="p">(</span><span class="n">lit</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Always true. Do nothing.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the constraint in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the constraint protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span>


<span class="k">class</span> <span class="nc">IntervalVar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an Interval variable.</span>

<span class="sd">  An interval variable is both a constraint and a variable. It is defined by</span>
<span class="sd">  three integer variables: start, size, and end.</span>

<span class="sd">  It is a constraint because, internally, it enforces that start + size == end.</span>

<span class="sd">  It is also a variable as it can appear in specific scheduling constraints:</span>
<span class="sd">  NoOverlap, NoOverlap2D, Cumulative.</span>

<span class="sd">  Optionally, an enforcement literal can be added to this constraint, in which</span>
<span class="sd">  case these scheduling constraints will ignore interval variables with</span>
<span class="sd">  enforcement literals assigned to false. Conversely, these constraints will</span>
<span class="sd">  also set these enforcement literals to false if they cannot fit these</span>
<span class="sd">  intervals into the schedule.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="c1"># As with the IntVar::__init__ method, we hack the __init__ method to</span>
        <span class="c1"># support two use cases:</span>
        <span class="c1">#   case 1: called when creating a new interval variable.</span>
        <span class="c1">#      {start|size|end} are linear expressions, is_present_index is either</span>
        <span class="c1">#      None or the index of a Boolean literal. name is a string</span>
        <span class="c1">#   case 2: called when querying an existing interval variable.</span>
        <span class="c1">#      start_index is an int, all parameters after are None.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_present_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_present_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_present_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the interval constraint in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the interval protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(start = </span><span class="si">%s</span><span class="s1">, size = </span><span class="si">%s</span><span class="s1">, end = </span><span class="si">%s</span><span class="s1">, is_present = </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">),</span>
                <span class="n">ShortName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(start = </span><span class="si">%s</span><span class="s1">, size = </span><span class="si">%s</span><span class="s1">, end = </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SizeExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ObjectIsATrueLiteral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if literal is either True, or a Boolean literals fixed to True.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">ObjectIsAFalseLiteral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if literal is either False, or a Boolean literals fixed to False.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">CpModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Methods for building a CP model.</span>

<span class="sd">  Methods beginning with:</span>

<span class="sd">  * ```New``` create integer, boolean, or interval variables.</span>
<span class="sd">  * ```Add``` create new constraints and add them to the model.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpModelProto</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Integer variable.</span>

    <span class="k">def</span> <span class="nf">NewIntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an integer variable with domain [lb, ub].</span>

<span class="sd">    The CP-SAT solver is limited to integer variables. If you have fractional</span>
<span class="sd">    values, scale them up so that they become integers; if you have strings,</span>
<span class="sd">    encode them as integers.</span>

<span class="sd">    Args:</span>
<span class="sd">      lb: Lower bound for the variable.</span>
<span class="sd">      ub: Upper bound for the variable.</span>
<span class="sd">      name: The name of the variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      a variable whose domain is [lb, ub].</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewIntVarFromDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an integer variable from a domain.</span>

<span class="sd">    A domain is a set of integers specified by a collection of intervals.</span>
<span class="sd">    For example, `model.NewIntVarFromDomain(cp_model.</span>
<span class="sd">         Domain.FromIntervals([[1, 2], [4, 6]]), &#39;x&#39;)`</span>

<span class="sd">    Args:</span>
<span class="sd">      domain: An instance of the Domain class.</span>
<span class="sd">      name: The name of the variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a variable whose domain is the given domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewBoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a 0-1 variable with the given name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewConstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Declares a constant integer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                      <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Linear constraints.</span>

    <span class="k">def</span> <span class="nf">AddLinearConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the constraint: `lb &lt;= linear_expr &lt;= ub`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddLinearExpressionInDomain</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">AddLinearExpressionInDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the constraint: `linear_expr` in `domain`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
            <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="n">linear_expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntVar</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Wrong argument&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
                <span class="n">cmh</span><span class="o">.</span><span class="n">capped_subtraction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">domain</span><span class="o">.</span><span class="n">FlattenedIntervals</span><span class="p">()</span>
            <span class="p">])</span>
            <span class="k">return</span> <span class="n">ct</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">domain</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([])</span>  <span class="c1"># Evaluate to false.</span>
            <span class="c1"># Nothing to do otherwise.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Not supported: CpModel.AddLinearExpressionInDomain(&#39;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a `BoundedLinearExpression` to the model.</span>

<span class="sd">    Args:</span>
<span class="sd">      ct: A [`BoundedLinearExpression`](#boundedlinearexpression).</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">BoundedLinearExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddLinearExpressionInDomain</span><span class="p">(</span>
                <span class="n">ct</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">Domain</span><span class="o">.</span><span class="n">FromFlatIntervals</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">ct</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([</span><span class="kc">True</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ct</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([])</span>  <span class="c1"># Evaluate to false.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not supported: CpModel.Add(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="c1"># General Integer Constraints.</span>

    <span class="k">def</span> <span class="nf">AddAllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AllDifferent(expressions).</span>

<span class="sd">    This constraint forces all expressions to have different values.</span>

<span class="sd">    Args:</span>
<span class="sd">      *expressions: simple expressions of the form a * var + constant.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">all_diff</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expanded</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the element constraint: `variables[index] == target`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddElement expects a non-empty variables array&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">variables</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Circuit(arcs).</span>

<span class="sd">    Adds a circuit constraint from a sparse list of arcs that encode the graph.</span>

<span class="sd">    A circuit is a unique Hamiltonian path in a subgraph of the total</span>
<span class="sd">    graph. In case a node &#39;i&#39; is not in the path, then there must be a</span>
<span class="sd">    loop arc &#39;i -&gt; i&#39; associated with a true literal. Otherwise</span>
<span class="sd">    this constraint will fail.</span>

<span class="sd">    Args:</span>
<span class="sd">      arcs: a list of arcs. An arc is a tuple (source_node, destination_node,</span>
<span class="sd">        literal). The arc is selected in the circuit if the literal is true.</span>
<span class="sd">        Both source_node and destination_node must be integers between 0 and the</span>
<span class="sd">        number of nodes - 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the list of arcs is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddCircuit expects a non-empty array of arcs&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMultipleCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a multiple circuit constraint, aka the &quot;VRP&quot; constraint.</span>

<span class="sd">    The direct graph where arc #i (from tails[i] to head[i]) is present iff</span>
<span class="sd">    literals[i] is true must satisfy this set of properties:</span>
<span class="sd">    - #incoming arcs == 1 except for node 0.</span>
<span class="sd">    - #outgoing arcs == 1 except for node 0.</span>
<span class="sd">    - for node zero, #incoming arcs == #outgoing arcs.</span>
<span class="sd">    - There are no duplicate arcs.</span>
<span class="sd">    - Self-arcs are allowed except for node 0.</span>
<span class="sd">    - There is no cycle in this graph, except through node 0.</span>

<span class="sd">    Args:</span>
<span class="sd">      arcs: a list of arcs. An arc is a tuple (source_node, destination_node,</span>
<span class="sd">        literal). The arc is selected in the circuit if the literal is true.</span>
<span class="sd">        Both source_node and destination_node must be integers between 0 and the</span>
<span class="sd">        number of nodes - 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the list of arcs is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddMultipleCircuit expects a non-empty array of arcs&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AllowedAssignments(variables, tuples_list).</span>

<span class="sd">    An AllowedAssignments constraint is a constraint on an array of variables,</span>
<span class="sd">    which requires that when all variables are assigned values, the resulting</span>
<span class="sd">    array equals one of the  tuples in `tuple_list`.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: A list of variables.</span>
<span class="sd">      tuples_list: A list of admissible tuples. Each tuple must have the same</span>
<span class="sd">        length as the variables, and the ith value of a tuple corresponds to the</span>
<span class="sd">        ith variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: If a tuple does not have the same size as the list of</span>
<span class="sd">          variables.</span>
<span class="sd">      ValueError: If the array of variables is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddAllowedAssignments expects a non-empty variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tuples_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arity</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Tuple &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; has the wrong arity&#39;</span><span class="p">)</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">ar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddForbiddenAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AddForbiddenAssignments(variables, [tuples_list]).</span>

<span class="sd">    A ForbiddenAssignments constraint is a constraint on an array of variables</span>
<span class="sd">    where the list of impossible combinations is provided in the tuples list.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: A list of variables.</span>
<span class="sd">      tuples_list: A list of forbidden tuples. Each tuple must have the same</span>
<span class="sd">        length as the variables, and the *i*th value of a tuple corresponds to</span>
<span class="sd">        the *i*th variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: If a tuple does not have the same size as the list of</span>
<span class="sd">                 variables.</span>
<span class="sd">      ValueError: If the array of variables is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddForbiddenAssignments expects a non-empty variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddAllowedAssignments</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">negated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAutomaton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_variables</span><span class="p">,</span> <span class="n">starting_state</span><span class="p">,</span> <span class="n">final_states</span><span class="p">,</span>
                     <span class="n">transition_triples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an automaton constraint.</span>

<span class="sd">    An automaton constraint takes a list of variables (of size *n*), an initial</span>
<span class="sd">    state, a set of final states, and a set of transitions. A transition is a</span>
<span class="sd">    triplet (*tail*, *transition*, *head*), where *tail* and *head* are states,</span>
<span class="sd">    and *transition* is the label of an arc from *head* to *tail*,</span>
<span class="sd">    corresponding to the value of one variable in the list of variables.</span>

<span class="sd">    This automaton will be unrolled into a flow with *n* + 1 phases. Each phase</span>
<span class="sd">    contains the possible states of the automaton. The first state contains the</span>
<span class="sd">    initial state. The last phase contains the final states.</span>

<span class="sd">    Between two consecutive phases *i* and *i* + 1, the automaton creates a set</span>
<span class="sd">    of arcs. For each transition (*tail*, *transition*, *head*), it will add</span>
<span class="sd">    an arc from the state *tail* of phase *i* and the state *head* of phase</span>
<span class="sd">    *i* + 1. This arc is labeled by the value *transition* of the variables</span>
<span class="sd">    `variables[i]`. That is, this arc can only be selected if `variables[i]`</span>
<span class="sd">    is assigned the value *transition*.</span>

<span class="sd">    A feasible solution of this constraint is an assignment of variables such</span>
<span class="sd">    that, starting from the initial state in phase 0, there is a path labeled by</span>
<span class="sd">    the values of the variables that ends in one of the final states in the</span>
<span class="sd">    final phase.</span>

<span class="sd">    Args:</span>
<span class="sd">      transition_variables: A non-empty list of variables whose values</span>
<span class="sd">        correspond to the labels of the arcs traversed by the automaton.</span>
<span class="sd">      starting_state: The initial state of the automaton.</span>
<span class="sd">      final_states: A non-empty list of admissible final states.</span>
<span class="sd">      transition_triples: A list of transitions for the automaton, in the</span>
<span class="sd">        following format (current_state, variable_value, next_state).</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if `transition_variables`, `final_states`, or</span>
<span class="sd">        `transition_triples` are empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transition_variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddAutomaton expects a non-empty transition_variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">final_states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddAutomaton expects some final states&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transition_triples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddAutomaton expects some transition triples&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">transition_variables</span><span class="p">])</span>
        <span class="n">starting_state</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">starting_state</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">starting_state</span> <span class="o">=</span> <span class="n">starting_state</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">final_states</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">final_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transition_triples</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Tuple &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s1">&#39; has the wrong arity (!= 3)&#39;</span><span class="p">)</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_tail</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_head</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddInverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">inverse_variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Inverse(variables, inverse_variables).</span>

<span class="sd">    An inverse constraint enforces that if `variables[i]` is assigned a value</span>
<span class="sd">    `j`, then `inverse_variables[j]` is assigned a value `i`. And vice versa.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: An array of integer variables.</span>
<span class="sd">      inverse_variables: An array of integer variables.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: if variables and inverse_variables have different lengths, or</span>
<span class="sd">          if they are empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">inverse_variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;The Inverse constraint does not accept empty arrays&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inverse_variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;In the inverse constraint, the two array variables and&#39;</span>
                <span class="s1">&#39; inverse_variables must have the same length.&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">f_direct</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">f_inverse</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inverse_variables</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddReservoirConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">level_changes</span><span class="p">,</span> <span class="n">min_level</span><span class="p">,</span>
                               <span class="n">max_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Reservoir(times, level_changes, min_level, max_level).</span>

<span class="sd">    Maintains a reservoir level within bounds. The water level starts at 0, and</span>
<span class="sd">    at any time, it must be between min_level and max_level.</span>

<span class="sd">    If the affine expression `times[i]` is assigned a value t, then the current</span>
<span class="sd">    level changes by `level_changes[i]`, which is constant, at time t.</span>

<span class="sd">     Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please</span>
<span class="sd">     use fixed level_changes to simulate initial state.</span>

<span class="sd">     Therefore, at any time:</span>
<span class="sd">         sum(level_changes[i] if times[i] &lt;= t) in [min_level, max_level]</span>

<span class="sd">    Args:</span>
<span class="sd">      times: A list of affine expressions which specify the time of the filling</span>
<span class="sd">        or emptying the reservoir.</span>
<span class="sd">      level_changes: A list of integer values that specifies the amount of the</span>
<span class="sd">        emptying or filling.</span>
<span class="sd">      min_level: At any time, the level of the reservoir must be greater or</span>
<span class="sd">        equal than the min level.</span>
<span class="sd">      max_level: At any time, the level of the reservoir must be less or equal</span>
<span class="sd">        than the max level.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if max_level &lt; min_level.</span>

<span class="sd">      ValueError: if max_level &lt; 0.</span>

<span class="sd">      ValueError: if min_level &gt; 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="n">min_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Reservoir constraint must have a max_level &gt;= min_level&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a max_level &gt;= 0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a min_level &lt;= 0&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">time_exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">level_changes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">level_changes</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">min_level</span> <span class="o">=</span> <span class="n">min_level</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="n">max_level</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddReservoirConstraintWithActive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">level_changes</span><span class="p">,</span> <span class="n">actives</span><span class="p">,</span>
                                         <span class="n">min_level</span><span class="p">,</span> <span class="n">max_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Reservoir(times, level_changes, actives, min_level, max_level).</span>

<span class="sd">    Maintains a reservoir level within bounds. The water level starts at 0, and</span>
<span class="sd">    at any time, it must be between min_level and max_level.</span>

<span class="sd">    If the variable `times[i]` is assigned a value t, and `actives[i]` is</span>
<span class="sd">    `True`, then the current level changes by `level_changes[i]`, which is</span>
<span class="sd">    constant,</span>
<span class="sd">    at time t.</span>

<span class="sd">     Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please</span>
<span class="sd">     use fixed level_changes to simulate initial state.</span>

<span class="sd">     Therefore, at any time:</span>
<span class="sd">         sum(level_changes[i] * actives[i] if times[i] &lt;= t) in [min_level,</span>
<span class="sd">         max_level]</span>


<span class="sd">    The array of boolean variables &#39;actives&#39;, if defined, indicates which</span>
<span class="sd">    actions are actually performed.</span>

<span class="sd">    Args:</span>
<span class="sd">      times: A list of affine expressions which specify the time of the filling</span>
<span class="sd">        or emptying the reservoir.</span>
<span class="sd">      level_changes: A list of integer values that specifies the amount of the</span>
<span class="sd">        emptying or filling.</span>
<span class="sd">      actives: a list of boolean variables. They indicates if the</span>
<span class="sd">        emptying/refilling events actually take place.</span>
<span class="sd">      min_level: At any time, the level of the reservoir must be greater or</span>
<span class="sd">        equal than the min level.</span>
<span class="sd">      max_level: At any time, the level of the reservoir must be less or equal</span>
<span class="sd">        than the max level.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if max_level &lt; min_level.</span>

<span class="sd">      ValueError: if max_level &lt; 0.</span>

<span class="sd">      ValueError: if min_level &gt; 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="n">min_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Reservoir constraint must have a max_level &gt;= min_level&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a max_level &gt;= 0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a min_level &lt;= 0&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">time_exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">level_changes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">level_changes</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">active_literals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">actives</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">min_level</span> <span class="o">=</span> <span class="n">min_level</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="n">max_level</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMapDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">bool_var_array</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `var == i + offset &lt;=&gt; bool_var_array[i] == true for all i`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bool_var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bool_var_array</span><span class="p">):</span>
            <span class="n">b_index</span> <span class="o">=</span> <span class="n">bool_var</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="n">var_index</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_index</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_index</span><span class="p">)</span>

            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_index</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">b_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">AddImplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `a =&gt; b` (`a` implies `b`).&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_or</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddBoolOr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `Or(literals) == true`: Sum(literals) &gt;= 1.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_or</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAtLeastOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as `AddBoolOr`: `Sum(literals) &gt;= 1`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">(</span><span class="o">*</span><span class="n">literals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddAtMostOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `AtMostOne(literals)`: `Sum(literals) &lt;= 1`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">at_most_one</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddExactlyOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `ExactlyOne(literals)`: `Sum(literals) == 1`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">exactly_one</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddBoolAnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `And(literals) == true`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_and</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddBoolXOr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `XOr(literals) == true`.</span>

<span class="sd">    In contrast to AddBoolOr and AddBoolAnd, it does not support</span>
<span class="sd">        .OnlyEnforceIf().</span>

<span class="sd">    Args:</span>
<span class="sd">      *literals: the list of literals in the constraint.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `Constraint` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_xor</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">exprs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Min(exprs)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">exprs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Max(exprs)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddDivisionEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == num // denom` (integer division rounded towards 0).&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">denom</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Abs(var)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddModuloEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target = var % mod`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMultiplicationEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == expressions[0] * .. * expressions[n]`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_prod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_prod</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="c1"># Scheduling support</span>

    <span class="k">def</span> <span class="nf">NewIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, size, and end.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Internally, it ensures that `start + size == end`.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      end: The end of the interval. It can be an affine or constant expression.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>

        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: size must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: end must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewFixedSizeIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, and a fixed size.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It must be an integer value.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewOptionalIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_present</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an optional interval var from start, size, end, and is_present.</span>

<span class="sd">    An optional interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap. This constraint is protected by an is_present</span>
<span class="sd">    literal that indicates if it is active or not.</span>

<span class="sd">    Internally, it ensures that `is_present` implies `start + size == end`.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an integer value, or an</span>
<span class="sd">        integer variable.</span>
<span class="sd">      size: The size of the interval. It can be an integer value, or an integer</span>
<span class="sd">        variable.</span>
<span class="sd">      end: The end of the interval. It can be an integer value, or an integer</span>
<span class="sd">        variable.</span>
<span class="sd">      is_present: A literal that indicates if the interval is active or not. A</span>
<span class="sd">        inactive interval is simply ignored by all constraints.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="c1"># Add the linear constraint.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">OnlyEnforceIf</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>

        <span class="c1"># Creates the IntervalConstraintProto object.</span>
        <span class="n">is_present_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: size must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: end must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span>
                           <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewOptionalFixedSizeIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">is_present</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, and a fixed size.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It must be an integer value.</span>
<span class="sd">      is_present: A literal that indicates if the interval is active or not. A</span>
<span class="sd">        inactive interval is simply ignored by all constraints.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="n">is_present_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span>
                           <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddNoOverlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_vars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds NoOverlap(interval_vars).</span>

<span class="sd">    A NoOverlap constraint ensures that all present intervals do not overlap</span>
<span class="sd">    in time.</span>

<span class="sd">    Args:</span>
<span class="sd">      interval_vars: The list of interval variables to constrain.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">interval_vars</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddNoOverlap2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_intervals</span><span class="p">,</span> <span class="n">y_intervals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds NoOverlap2D(x_intervals, y_intervals).</span>

<span class="sd">    A NoOverlap2D constraint ensures that all present rectangles do not overlap</span>
<span class="sd">    on a plane. Each rectangle is aligned with the X and Y axis, and is defined</span>
<span class="sd">    by two intervals which represent its projection onto the X and Y axis.</span>

<span class="sd">    Furthermore, one box is optional if at least one of the x or y interval is</span>
<span class="sd">    optional.</span>

<span class="sd">    Args:</span>
<span class="sd">      x_intervals: The X coordinates of the rectangles.</span>
<span class="sd">      y_intervals: The Y coordinates of the rectangles.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap_2d</span><span class="o">.</span><span class="n">x_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_intervals</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap_2d</span><span class="o">.</span><span class="n">y_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y_intervals</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddCumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">demands</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Cumulative(intervals, demands, capacity).</span>

<span class="sd">    This constraint enforces that:</span>

<span class="sd">        for all t:</span>
<span class="sd">          sum(demands[i]</span>
<span class="sd">            if (start(intervals[i]) &lt;= t &lt; end(intervals[i])) and</span>
<span class="sd">            (intervals[i] is present)) &lt;= capacity</span>

<span class="sd">    Args:</span>
<span class="sd">      intervals: The list of intervals.</span>
<span class="sd">      demands: The list of demands for each interval. Each demand must be &gt;= 0.</span>
<span class="sd">        Each demand can be an integer value, or an integer variable.</span>
<span class="sd">      capacity: The maximum capacity of the cumulative constraint. It must be a</span>
<span class="sd">        positive integer value or variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">demands</span><span class="p">:</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">demands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">capacity</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">capacity</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="c1"># Support for deep copy.</span>
    <span class="k">def</span> <span class="nf">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the model, and creates a new one from a CpModelProto instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">other_model</span><span class="o">.</span><span class="n">Proto</span><span class="p">())</span>

        <span class="c1"># Rebuild constant map.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">GetBoolVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created Boolean variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetBoolVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetBoolVarFromProtoIndex: index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> does not reference&#39;</span> <span class="o">+</span>
                <span class="s1">&#39; a Boolean variable&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created integer variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntervalVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created interval variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntervalVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ct</span><span class="o">.</span><span class="n">HasField</span><span class="p">(</span><span class="s1">&#39;interval&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntervalVarFromProtoIndex: index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> does not reference an&#39;</span>
                <span class="o">+</span> <span class="s1">&#39; interval variable&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Helpers.</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the underlying CpModelProto.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span>

    <span class="k">def</span> <span class="nf">Negated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">GetOrMakeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of a variable, its negation, or a number.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">)</span> <span class="ow">and</span>
              <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">arg</span><span class="o">.</span><span class="n">Expression</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetOrMakeIndex(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an index from a boolean expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AssertIsBooleanVariable</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AssertIsBooleanVariable</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">Not</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_boolean</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetOrMakeBooleanIndex(&#39;</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntervalIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntervalVar</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetIntervalIndex(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">VarIndexToVarProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">var_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="o">-</span><span class="n">var_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">ParseLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a LinearExpressionProto built from a LinearExpr instance.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">LinearExpressionProto</span><span class="p">()</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">negate</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="n">linear_expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">constant</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Wrong argument&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
            <span class="n">result</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_SetObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;objective&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;floating_point_objective&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">minimize</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Negated</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">Index</span><span class="p">()))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
            <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">is_integer</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">GetFloatVarValueMap</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">is_integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">minimize</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">constant</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">constant</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">minimize</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Negated</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">maximize</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">minimize</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">constant</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39; is not a valid objective&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model to minimize(obj).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetObjective</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model to maximize(obj).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetObjective</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">HasField</span><span class="p">(</span><span class="s1">&#39;objective&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDecisionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">var_strategy</span><span class="p">,</span> <span class="n">domain_strategy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a search strategy to the model.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: a list of variables this strategy will assign.</span>
<span class="sd">      var_strategy: heuristic to choose the next variable to assign.</span>
<span class="sd">      domain_strategy: heuristic to reduce the domain of the selected variable.</span>
<span class="sd">        Currently, this is advanced code: the union of all strategies added to</span>
<span class="sd">          the model must be complete, i.e. instantiates all variables.</span>
<span class="sd">          Otherwise, Solve() will fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="n">strategy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">search_strategy</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">strategy</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="n">strategy</span><span class="o">.</span><span class="n">variable_selection_strategy</span> <span class="o">=</span> <span class="n">var_strategy</span>
        <span class="n">strategy</span><span class="o">.</span><span class="n">domain_reduction_strategy</span> <span class="o">=</span> <span class="n">domain_strategy</span>

    <span class="k">def</span> <span class="nf">ModelStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string containing some model statistics.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedModelStats</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">Validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string indicating that the model is invalid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedValidateModel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">ExportToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the model as a protocol buffer to &#39;file&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">      file: file to write the model to. If the filename ends with &#39;txt&#39;, the</span>
<span class="sd">        model will be written as a text file, otherwise, the binary format will</span>
<span class="sd">        be used.</span>

<span class="sd">    Returns:</span>
<span class="sd">      True if the model was correctly written.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedWriteModelToFile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssertIsBooleanVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s1">&#39; is not a boolean variable&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39; is not a boolean variable&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds &#39;var == value&#39; as a hint to the solver.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">solution_hint</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">solution_hint</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ClearHints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove any solution hint from the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;solution_hint&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddAssumption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the literal &#39;lit&#39; to the model as assumptions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">assumptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">lit</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">AddAssumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the literals to the model as assumptions.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AddAssumption</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ClearAssumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all assumptions from the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;assumptions&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>  <span class="c1"># Tuple</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LinearExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">args</span>
    <span class="c1"># Generator</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">EvaluateLinearExpr</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate a linear expression against a solution.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot interpret </span><span class="si">%s</span><span class="s1"> as a linear expression.&#39;</span> <span class="o">%</span>
                        <span class="n">expression</span><span class="p">)</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="n">expression</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
            <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s1"> as a linear expression.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">EvaluateBooleanExpression</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate a boolean expression against a solution.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span>
                                                   <span class="n">_NotBooleanVariable</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="o">-</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">literal</span><span class="si">}</span><span class="s1"> as a boolean expression.&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CpSolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main solver class.</span>

<span class="sd">  The purpose of this class is to search for a solution to the model provided</span>
<span class="sd">  to the Solve() method.</span>

<span class="sd">  Once Solve() is called, this class allows inspecting the solution found</span>
<span class="sd">  with the Value() and BooleanValue() methods, as well as general statistics</span>
<span class="sd">  about the solve procedure.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">sat_parameters_pb2</span><span class="o">.</span><span class="n">SatParameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="p">:</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">solution_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves a problem and passes each solution to the callback if not null.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="n">solve_wrapper</span> <span class="o">=</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="p">()</span>

        <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="o">.</span><span class="n">SetSerializedParameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">solve_wrapper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solution_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">AddSolutionCallback</span><span class="p">(</span><span class="n">solution_callback</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">AddLogCallback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span><span class="o">.</span><span class="n">FromString</span><span class="p">(</span>
            <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="o">.</span><span class="n">SerializedSolve</span><span class="p">(</span>
                <span class="n">model</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">solve_wrapper</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">solution_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">ClearSolutionCallback</span><span class="p">(</span><span class="n">solution_callback</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>

    <span class="k">def</span> <span class="nf">SolveWithSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED Use Solve() with the callback argument.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;SolveWithSolutionCallback is deprecated; use Solve() with&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;the callback argument.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchForAllSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED Use Solve() with the right parameter.</span>

<span class="sd">    Search for all solutions of a satisfiability problem.</span>

<span class="sd">    This method searches for all feasible solutions of a given model.</span>
<span class="sd">    Then it feeds the solution to the callback.</span>

<span class="sd">    Note that the model cannot contain an objective.</span>

<span class="sd">    Args:</span>
<span class="sd">      model: The model to solve.</span>
<span class="sd">      callback: The callback that will be called at each solution.</span>

<span class="sd">    Returns:</span>
<span class="sd">      The status of the solve:</span>

<span class="sd">      * *FEASIBLE* if some solutions have been found</span>
<span class="sd">      * *INFEASIBLE* if the solver has proved there are no solution</span>
<span class="sd">      * *OPTIMAL* if all solutions have been found</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;SearchForAllSolutions is deprecated; use Solve() with&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;enumerate_all_solutions = True.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">HasObjective</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Search for all solutions is only defined on &#39;</span>
                            <span class="s1">&#39;satisfiability problems&#39;</span><span class="p">)</span>
        <span class="c1"># Store old parameter.</span>
        <span class="n">enumerate_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

        <span class="c1"># Restore parameter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span> <span class="o">=</span> <span class="n">enumerate_all</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>

    <span class="k">def</span> <span class="nf">StopSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stops the current search asynchronously.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="o">.</span><span class="n">StopSearch</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of a linear expression after solve.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EvaluateLinearExpr</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BooleanValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the boolean value of a literal after solve.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EvaluateBooleanExpression</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of the objective after solve.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">objective_value</span>

    <span class="k">def</span> <span class="nf">BestObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the best lower (upper) bound found when min(max)imizing.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">best_objective_bound</span>

    <span class="k">def</span> <span class="nf">StatusName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the name of the status returned by Solve().&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>
        <span class="k">return</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverStatus</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumBooleans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of boolean variables managed by the SAT solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_booleans</span>

    <span class="k">def</span> <span class="nf">NumConflicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of conflicts since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_conflicts</span>

    <span class="k">def</span> <span class="nf">NumBranches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of search branches explored by the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_branches</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the wall time in seconds since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">wall_time</span>

    <span class="k">def</span> <span class="nf">UserTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the user time in seconds since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">user_time</span>

    <span class="k">def</span> <span class="nf">ResponseStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns some statistics on the solution found as a string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedSolverResponseStats</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">ResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the response object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span>

    <span class="k">def</span> <span class="nf">SufficientAssumptionsForInfeasibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the indices of the infeasible assumptions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">sufficient_assumptions_for_infeasibility</span>

    <span class="k">def</span> <span class="nf">SolutionInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns some information on the solve process.</span>

<span class="sd">    Returns some information on how the solution was found, or the reason</span>
<span class="sd">    why the model or the parameters are invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">solution_info</span>


<span class="k">class</span> <span class="nc">CpSolverSolutionCallback</span><span class="p">(</span><span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solution callback.</span>

<span class="sd">  This class implements a callback that will be called at each new solution</span>
<span class="sd">  found during search.</span>

<span class="sd">  The method OnSolutionCallback() will be called by the solver, and must be</span>
<span class="sd">  implemented. The current solution can be queried using the BooleanValue()</span>
<span class="sd">  and Value() methods.</span>

<span class="sd">  It inherits the following methods from its base class:</span>

<span class="sd">  * `ObjectiveValue(self)`</span>
<span class="sd">  * `BestObjectiveBound(self)`</span>
<span class="sd">  * `NumBooleans(self)`</span>
<span class="sd">  * `NumConflicts(self)`</span>
<span class="sd">  * `NumBranches(self)`</span>
<span class="sd">  * `WallTime(self)`</span>
<span class="sd">  * `UserTime(self)`</span>

<span class="sd">  These methods returns the same information as their counterpart in the</span>
<span class="sd">  `CpSolver` class.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OnSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Proxy for the same method in snake case.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_solution_callback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">BooleanValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the boolean value of a boolean literal.</span>

<span class="sd">    Args:</span>
<span class="sd">        lit: A boolean variable or its negation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The Boolean value of the literal in the solution.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: if `lit` is not a boolean variable or its negation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasResponse</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">lit</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SolutionBooleanValue</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">lit</span><span class="si">}</span><span class="s1"> as a boolean expression.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates an linear expression in the current solution.</span>

<span class="sd">    Args:</span>
<span class="sd">        expression: a linear expression of the model.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An integer value equal to the evaluation of the linear expression</span>
<span class="sd">        against the current solution.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: if &#39;expression&#39; is not a LinearExpr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasResponse</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="n">expression</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                    <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SolutionIntegerValue</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">SolutionIntegerValue</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">expression</span><span class="si">}</span><span class="s1"> as a linear expression.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">Response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current solution response.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span><span class="o">.</span><span class="n">FromString</span><span class="p">(</span>
            <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="o">.</span><span class="n">SerializedResponse</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">ObjectiveSolutionPrinter</span><span class="p">(</span><span class="n">CpSolverSolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Display the objective value and time of intermediate solutions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ObjectiveValue</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s, objective = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>


<span class="k">class</span> <span class="nc">VarArrayAndObjectiveSolutionPrinter</span><span class="p">(</span><span class="n">CpSolverSolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print intermediate solutions (objective, variable values, time).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ObjectiveValue</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s, objective = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>


<span class="k">class</span> <span class="nc">VarArraySolutionPrinter</span><span class="p">(</span><span class="n">CpSolverSolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print intermediate solutions (variable values, time).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>
</pre></div>

        </details>

            </section>
                <section id="DisplayBounds">
                            <div class="attr function"><a class="headerlink" href="#DisplayBounds">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DisplayBounds</span><span class="signature">(bounds)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">DisplayBounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Displays a flattened list of intervals.&quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;..&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

        </details>

            <div class="docstring"><p>Displays a flattened list of intervals.</p>
</div>


                </section>
                <section id="ShortName">
                            <div class="attr function"><a class="headerlink" href="#ShortName">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ShortName</span><span class="signature">(model, i)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ShortName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a short name of an integer variable, or its negation.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;Not(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">ShortName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">DisplayBounds</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a short name of an integer variable, or its negation.</p>
</div>


                </section>
                <section id="ShortExprName">
                            <div class="attr function"><a class="headerlink" href="#ShortExprName">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ShortExprName</span><span class="signature">(model, e)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ShortExprName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pretty-print LinearExpressionProto instances.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">vars</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">var_name</span> <span class="o">=</span> <span class="n">ShortName</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">var_name</span>
        <span class="k">elif</span> <span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;-</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s1"> * </span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1"> + </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="c1"># TODO(user): Support more than affine expressions.</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Pretty-print LinearExpressionProto instances.</p>
</div>


                </section>
                <section id="LinearExpr">
                                <div class="attr class">
        <a class="headerlink" href="#LinearExpr">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">LinearExpr</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LinearExpr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Holds an integer linear expression.</span>

<span class="sd">  A linear expression is built from integer constants and variables.</span>
<span class="sd">  For example, `x + 2 * (y - z + 1)`.</span>

<span class="sd">  Linear expressions are used in CP-SAT models in constraints and in the</span>
<span class="sd">  objective:</span>

<span class="sd">  * You can define linear constraints as in:</span>

<span class="sd">  ```</span>
<span class="sd">  model.Add(x + 2 * y &lt;= 5)</span>
<span class="sd">  model.Add(sum(array_of_vars) == 5)</span>
<span class="sd">  ```</span>

<span class="sd">  * In CP-SAT, the objective is a linear expression:</span>

<span class="sd">  ```</span>
<span class="sd">  model.Minimize(x + 2 * y + z)</span>
<span class="sd">  ```</span>

<span class="sd">  * For large arrays, using the LinearExpr class is faster that using the python</span>
<span class="sd">  `sum()` function. You can create constraints and the objective from lists of</span>
<span class="sd">  linear expressions or coefficients as follows:</span>

<span class="sd">  ```</span>
<span class="sd">  model.Minimize(cp_model.LinearExpr.Sum(expressions))</span>
<span class="sd">  model.Add(cp_model.LinearExpr.WeightedSum(expressions, coefficients) &gt;= 0)</span>
<span class="sd">  ```</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the expression sum(expressions).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_SumArray</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">WeightedSum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the expression sum(expressions[i] * coefficients[i]).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">IsEmptyOrAllNull</span><span class="p">(</span><span class="n">coefficients</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_WeightedSum</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Term</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates `expression * coefficient`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">coefficient</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expression</span> <span class="o">*</span> <span class="n">coefficient</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">IsEmptyOrAllNull</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefficients</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">RebuildFromLinearExpressionProto</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">proto</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recreate a LinearExpr from a LinearExpressionProto.&quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">offset</span>
        <span class="n">num_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">proto</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">(),</span> <span class="n">proto</span><span class="o">.</span><span class="n">coeffs</span><span class="p">()):</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">IntVar</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                    <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">all_ones</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_SumArray</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_WeightedSum</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntegerVarValueMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scans the expression, and returns (var_coef_map, constant).&quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>  <span class="c1"># Flatten to avoid recursion.</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">-=</span> <span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">constant</span>

    <span class="k">def</span> <span class="nf">GetFloatVarValueMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scans the expression. Returns (var_coef_map, constant, is_integer).&quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>  <span class="c1"># Flatten to avoid recursion.</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>  <span class="c1"># Keep integrality.</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">-=</span> <span class="n">coeff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">is_integer</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_integer</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                    <span class="n">is_integer</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">is_integer</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling abs() on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddAbsEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">_ProductCst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_a_number</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">_ProductCst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling / on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddDivisionEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling // on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddDivisionEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling </span><span class="si">%%</span><span class="s1"> on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddModuloEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling ** on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddMultiplicationEquality&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling left shift on a linear expression is not supported&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling right shift on a linear expression is not supported&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling and on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddBoolAnd&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling or on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddBoolOr&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;calling xor on a linear expression is not supported, &#39;</span>
            <span class="s1">&#39;please use CpModel.AddBoolXor&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ProductCst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Evaluating a LinearExpr instance as a Boolean is not implemented.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span><span class="p">,</span> <span class="n">arg</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">arg</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;&lt; INT_MIN is not supported&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">arg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;&gt; INT_MAX is not supported&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">arg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">arg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundedLinearExpression</span><span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">arg</span><span class="p">,</span>
                                           <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Holds an integer linear expression.</p>

<p>A linear expression is built from integer constants and variables.
For example, <code>x + 2 * (y - z + 1)</code>.</p>

<p>Linear expressions are used in CP-SAT models in constraints and in the
objective:</p>

<ul>
<li>You can define linear constraints as in:</li>
</ul>

<pre><code>model.Add(x + 2 * y &lt;= 5)
model.Add(sum(array_of_vars) == 5)
</code></pre>

<ul>
<li>In CP-SAT, the objective is a linear expression:</li>
</ul>

<pre><code>model.Minimize(x + 2 * y + z)
</code></pre>

<ul>
<li>For large arrays, using the LinearExpr class is faster that using the python
<code>sum()</code> function. You can create constraints and the objective from lists of
linear expressions or coefficients as follows:</li>
</ul>

<pre><code>model.Minimize(cp_model.LinearExpr.Sum(expressions))
model.Add(cp_model.LinearExpr.WeightedSum(expressions, coefficients) &gt;= 0)
</code></pre>
</div>


                            <div id="LinearExpr.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">LinearExpr</span><span class="signature">()</span>
    </div>

    
    

                            </div>
                            <div id="LinearExpr.Sum" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.Sum">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">Sum</span><span class="signature">(cls, expressions)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the expression sum(expressions).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_SumArray</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates the expression sum(expressions).</p>
</div>


                            </div>
                            <div id="LinearExpr.WeightedSum" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.WeightedSum">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">WeightedSum</span><span class="signature">(cls, expressions, coefficients)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">WeightedSum</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the expression sum(expressions[i] * coefficients[i]).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">IsEmptyOrAllNull</span><span class="p">(</span><span class="n">coefficients</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_WeightedSum</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates the expression sum(expressions[i] * coefficients[i]).</p>
</div>


                            </div>
                            <div id="LinearExpr.Term" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.Term">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">Term</span><span class="signature">(cls, expression, coefficient)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Term</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates `expression * coefficient`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">coefficient</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expression</span> <span class="o">*</span> <span class="n">coefficient</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates <code>expression * coefficient</code>.</p>
</div>


                            </div>
                            <div id="LinearExpr.IsEmptyOrAllNull" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.IsEmptyOrAllNull">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">IsEmptyOrAllNull</span><span class="signature">(cls, coefficients)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">IsEmptyOrAllNull</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefficients</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_zero</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="LinearExpr.RebuildFromLinearExpressionProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.RebuildFromLinearExpressionProto">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">RebuildFromLinearExpressionProto</span><span class="signature">(cls, model, proto)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">RebuildFromLinearExpressionProto</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">proto</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recreate a LinearExpr from a LinearExpressionProto.&quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">offset</span>
        <span class="n">num_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">num_elements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">proto</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">vars</span><span class="p">(),</span> <span class="n">proto</span><span class="o">.</span><span class="n">coeffs</span><span class="p">()):</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">IntVar</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_one</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                    <span class="n">all_ones</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">all_ones</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_SumArray</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_WeightedSum</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Recreate a LinearExpr from a LinearExpressionProto.</p>
</div>


                            </div>
                            <div id="LinearExpr.GetIntegerVarValueMap" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.GetIntegerVarValueMap">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetIntegerVarValueMap</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetIntegerVarValueMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scans the expression, and returns (var_coef_map, constant).&quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>  <span class="c1"># Flatten to avoid recursion.</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">-=</span> <span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">constant</span>
</pre></div>

        </details>

            <div class="docstring"><p>Scans the expression, and returns (var_coef_map, constant).</p>
</div>


                            </div>
                            <div id="LinearExpr.GetFloatVarValueMap" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LinearExpr.GetFloatVarValueMap">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetFloatVarValueMap</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetFloatVarValueMap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scans the expression. Returns (var_coef_map, constant, is_integer).&quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>  <span class="c1"># Flatten to avoid recursion.</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>  <span class="c1"># Keep integrality.</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">constant</span> <span class="o">+=</span> <span class="n">coeff</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">-=</span> <span class="n">coeff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized linear expression: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">is_integer</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_integer</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">coeff</span><span class="p">):</span>
                    <span class="n">is_integer</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">is_integer</span>
</pre></div>

        </details>

            <div class="docstring"><p>Scans the expression. Returns (var_coef_map, constant, is_integer).</p>
</div>


                            </div>
                </section>
                <section id="IntVar">
                                <div class="attr class">
        <a class="headerlink" href="#IntVar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVar</span><wbr>(<span class="base"><a href="#LinearExpr">LinearExpr</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVar</span><span class="p">(</span><span class="n">LinearExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An integer variable.</span>

<span class="sd">  An IntVar is an object that can take on any integer value within defined</span>
<span class="sd">  ranges. Variables appear in constraint like:</span>

<span class="sd">      x + y &gt;= 5</span>
<span class="sd">      AllDifferent([x, y, z])</span>

<span class="sd">  Solving a model is equivalent to finding, for each variable, a single value</span>
<span class="sd">  from the set of initial values (called the initial domain), such that the</span>
<span class="sd">  model is feasible, or optimal if you provided an objective function.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See CpModel.NewIntVar below.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Python do not support multiple __init__ methods.</span>
        <span class="c1"># This method is only called from the CpModel class.</span>
        <span class="c1"># We hack the parameter to support the two cases:</span>
        <span class="c1"># case 1:</span>
        <span class="c1">#     model is a CpModelProto, domain is a Domain, and name is a string.</span>
        <span class="c1"># case 2:</span>
        <span class="c1">#     model is a CpModelProto, domain is an index (int), and name is None.</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">FlattenedIntervals</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the variable in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the variable protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span>

    <span class="k">def</span> <span class="nf">IsEqualTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if self == other in the python sense.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span>
                  <span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># Special case for constants.</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;unnamed_var_</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">DisplayBounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the negation of a Boolean variable.</span>

<span class="sd">    This method implements the logical negation of a Boolean variable.</span>
<span class="sd">    It is only valid if the variable has a Boolean domain (0 or 1).</span>

<span class="sd">    Note that this method is nilpotent: `x.Not().Not() == x`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bound</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot call Not on a non boolean variable: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="o">=</span> <span class="n">_NotBooleanVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span>
</pre></div>

        </details>

            <div class="docstring"><p>An integer variable.</p>

<p>An IntVar is an object that can take on any integer value within defined
ranges. Variables appear in constraint like:</p>

<pre><code>x + y &gt;= 5
AllDifferent([x, y, z])
</code></pre>

<p>Solving a model is equivalent to finding, for each variable, a single value
from the set of initial values (called the initial domain), such that the
model is feasible, or optimal if you provided an objective function.</p>
</div>


                            <div id="IntVar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVar</span><span class="signature">(model, domain, name)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See CpModel.NewIntVar below.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Python do not support multiple __init__ methods.</span>
        <span class="c1"># This method is only called from the CpModel class.</span>
        <span class="c1"># We hack the parameter to support the two cases:</span>
        <span class="c1"># case 1:</span>
        <span class="c1">#     model is a CpModelProto, domain is a Domain, and name is a string.</span>
        <span class="c1"># case 2:</span>
        <span class="c1">#     model is a CpModelProto, domain is an index (int), and name is None.</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">FlattenedIntervals</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>

        </details>

            <div class="docstring"><p>See <a href="#CpModel.NewIntVar">CpModel.NewIntVar</a> below.</p>
</div>


                            </div>
                            <div id="IntVar.Index" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Index">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Index</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the variable in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index of the variable in the model.</p>
</div>


                            </div>
                            <div id="IntVar.Proto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Proto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Proto</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the variable protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the variable protobuf.</p>
</div>


                            </div>
                            <div id="IntVar.IsEqualTo" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.IsEqualTo">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsEqualTo</span><span class="signature">(self, other)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsEqualTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if self == other in the python sense.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if self == other in the python sense.</p>
</div>


                            </div>
                            <div id="IntVar.Name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Name</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">name</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVar.Not" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Not">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Not</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the negation of a Boolean variable.</span>

<span class="sd">    This method implements the logical negation of a Boolean variable.</span>
<span class="sd">    It is only valid if the variable has a Boolean domain (0 or 1).</span>

<span class="sd">    Note that this method is nilpotent: `x.Not().Not() == x`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__var</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bound</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot call Not on a non boolean variable: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span> <span class="o">=</span> <span class="n">_NotBooleanVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__negation</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the negation of a Boolean variable.</p>

<p>This method implements the logical negation of a Boolean variable.
It is only valid if the variable has a Boolean domain (0 or 1).</p>

<p>Note that this method is nilpotent: <code>x.Not().Not() == x</code>.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#LinearExpr">LinearExpr</a></dt>
                                <dd id="IntVar.Sum" class="function"><a href="#LinearExpr.Sum">Sum</a></dd>
                <dd id="IntVar.WeightedSum" class="function"><a href="#LinearExpr.WeightedSum">WeightedSum</a></dd>
                <dd id="IntVar.Term" class="function"><a href="#LinearExpr.Term">Term</a></dd>
                <dd id="IntVar.IsEmptyOrAllNull" class="function"><a href="#LinearExpr.IsEmptyOrAllNull">IsEmptyOrAllNull</a></dd>
                <dd id="IntVar.RebuildFromLinearExpressionProto" class="function"><a href="#LinearExpr.RebuildFromLinearExpressionProto">RebuildFromLinearExpressionProto</a></dd>
                <dd id="IntVar.GetIntegerVarValueMap" class="function"><a href="#LinearExpr.GetIntegerVarValueMap">GetIntegerVarValueMap</a></dd>
                <dd id="IntVar.GetFloatVarValueMap" class="function"><a href="#LinearExpr.GetFloatVarValueMap">GetFloatVarValueMap</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="BoundedLinearExpression">
                                <div class="attr class">
        <a class="headerlink" href="#BoundedLinearExpression">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BoundedLinearExpression</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BoundedLinearExpression</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a linear constraint: `lb &lt;= linear expression &lt;= ub`.</span>

<span class="sd">  The only use of this class is to be added to the CpModel through</span>
<span class="sd">  `CpModel.Add(expression)`, as in:</span>

<span class="sd">      model.Add(x + 2 * y -1 &gt;= z)</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="o">&gt;</span> <span class="n">INT_MIN</span> <span class="ow">and</span> <span class="n">ub</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lb</span> <span class="o">==</span> <span class="n">ub</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; == &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &lt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &lt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lb</span> <span class="o">&gt;</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &gt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ub</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &lt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;True (unbounded expr &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MIN</span> <span class="ow">and</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; != &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in [&#39;</span> <span class="o">+</span> <span class="n">DisplayBounds</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>

    <span class="k">def</span> <span class="nf">Expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span>

    <span class="k">def</span> <span class="nf">Bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
        <span class="n">all_coeffs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">coeffs_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">same_var</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">eq_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">different_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ne_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">all_coeffs</span> <span class="o">==</span> <span class="n">same_var</span> <span class="ow">and</span>
                <span class="n">constant</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">eq_bounds</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">ne_bounds</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">eq_bounds</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">all_coeffs</span> <span class="o">==</span> <span class="n">different_vars</span> <span class="ow">and</span>
                <span class="n">constant</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">eq_bounds</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">ne_bounds</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">==</span> <span class="n">ne_bounds</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Evaluating a BoundedLinearExpression </span><span class="se">\&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1"> as a Boolean value&#39;</span>
            <span class="o">+</span> <span class="s1">&#39; is not supported.&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Represents a linear constraint: <code>lb &lt;= linear expression &lt;= ub</code>.</p>

<p>The only use of this class is to be added to the CpModel through
<code><a href="#CpModel.Add">CpModel.Add</a>(expression)</code>, as in:</p>

<pre><code>model.Add(x + 2 * y -1 &gt;= z)
</code></pre>
</div>


                            <div id="BoundedLinearExpression.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BoundedLinearExpression.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BoundedLinearExpression</span><span class="signature">(expr, bounds)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span> <span class="o">=</span> <span class="n">bounds</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BoundedLinearExpression.Expression" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BoundedLinearExpression.Expression">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Expression</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expr</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BoundedLinearExpression.Bounds" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BoundedLinearExpression.Bounds">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Bounds</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bounds</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="Constraint">
                                <div class="attr class">
        <a class="headerlink" href="#Constraint">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Constraint</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Constraint</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for constraints.</span>

<span class="sd">  Constraints are built by the CpModel through the Add&lt;XXX&gt; methods.</span>
<span class="sd">  Once created by the CpModel class, they are automatically added to the model.</span>
<span class="sd">  The purpose of this class is to allow specification of enforcement literals</span>
<span class="sd">  for this constraint.</span>

<span class="sd">      b = model.NewBoolVar(&#39;b&#39;)</span>
<span class="sd">      x = model.NewIntVar(0, 10, &#39;x&#39;)</span>
<span class="sd">      y = model.NewIntVar(0, 10, &#39;y&#39;)</span>

<span class="sd">      model.Add(x + 2 * y == 5).OnlyEnforceIf(b.Not())</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span> <span class="o">=</span> <span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">OnlyEnforceIf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">boolvar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an enforcement literal to the constraint.</span>

<span class="sd">    This method adds one or more literals (that is, a boolean variable or its</span>
<span class="sd">    negation) as enforcement literals. The conjunction of all these literals</span>
<span class="sd">    determines whether the constraint is active or not. It acts as an</span>
<span class="sd">    implication, so if the conjunction is true, it implies that the constraint</span>
<span class="sd">    must be enforced. If it is false, then the constraint is ignored.</span>

<span class="sd">    BoolOr, BoolAnd, and linear constraints all support enforcement literals.</span>

<span class="sd">    Args:</span>
<span class="sd">      *boolvar: One or more Boolean literals.</span>

<span class="sd">    Returns:</span>
<span class="sd">      self.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">boolvar</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">bool</span><span class="p">(</span><span class="n">lit</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Always true. Do nothing.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the constraint in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the constraint protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base class for constraints.</p>

<p>Constraints are built by the CpModel through the Add<XXX> methods.
Once created by the CpModel class, they are automatically added to the model.
The purpose of this class is to allow specification of enforcement literals
for this constraint.</p>

<pre><code>b = model.NewBoolVar('b')
x = model.NewIntVar(0, 10, 'x')
y = model.NewIntVar(0, 10, 'y')

model.Add(x + 2 * y == 5).OnlyEnforceIf(b.Not())
</code></pre>
</div>


                            <div id="Constraint.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Constraint</span><span class="signature">(constraints)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span> <span class="o">=</span> <span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.OnlyEnforceIf" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.OnlyEnforceIf">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OnlyEnforceIf</span><span class="signature">(self, *boolvar)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OnlyEnforceIf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">boolvar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an enforcement literal to the constraint.</span>

<span class="sd">    This method adds one or more literals (that is, a boolean variable or its</span>
<span class="sd">    negation) as enforcement literals. The conjunction of all these literals</span>
<span class="sd">    determines whether the constraint is active or not. It acts as an</span>
<span class="sd">    implication, so if the conjunction is true, it implies that the constraint</span>
<span class="sd">    must be enforced. If it is false, then the constraint is ignored.</span>

<span class="sd">    BoolOr, BoolAnd, and linear constraints all support enforcement literals.</span>

<span class="sd">    Args:</span>
<span class="sd">      *boolvar: One or more Boolean literals.</span>

<span class="sd">    Returns:</span>
<span class="sd">      self.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">boolvar</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">bool</span><span class="p">(</span><span class="n">lit</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Always true. Do nothing.</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds an enforcement literal to the constraint.</p>

<p>This method adds one or more literals (that is, a boolean variable or its
negation) as enforcement literals. The conjunction of all these literals
determines whether the constraint is active or not. It acts as an
implication, so if the conjunction is true, it implies that the constraint
must be enforced. If it is false, then the constraint is ignored.</p>

<p>BoolOr, BoolAnd, and linear constraints all support enforcement literals.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>*boolvar:</strong>  One or more Boolean literals.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>self.</p>
</blockquote>
</div>


                            </div>
                            <div id="Constraint.Index" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Index">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Index</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the constraint in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index of the constraint in the model.</p>
</div>


                            </div>
                            <div id="Constraint.Proto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Proto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Proto</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the constraint protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the constraint protobuf.</p>
</div>


                            </div>
                </section>
                <section id="IntervalVar">
                                <div class="attr class">
        <a class="headerlink" href="#IntervalVar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntervalVar</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntervalVar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an Interval variable.</span>

<span class="sd">  An interval variable is both a constraint and a variable. It is defined by</span>
<span class="sd">  three integer variables: start, size, and end.</span>

<span class="sd">  It is a constraint because, internally, it enforces that start + size == end.</span>

<span class="sd">  It is also a variable as it can appear in specific scheduling constraints:</span>
<span class="sd">  NoOverlap, NoOverlap2D, Cumulative.</span>

<span class="sd">  Optionally, an enforcement literal can be added to this constraint, in which</span>
<span class="sd">  case these scheduling constraints will ignore interval variables with</span>
<span class="sd">  enforcement literals assigned to false. Conversely, these constraints will</span>
<span class="sd">  also set these enforcement literals to false if they cannot fit these</span>
<span class="sd">  intervals into the schedule.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="c1"># As with the IntVar::__init__ method, we hack the __init__ method to</span>
        <span class="c1"># support two use cases:</span>
        <span class="c1">#   case 1: called when creating a new interval variable.</span>
        <span class="c1">#      {start|size|end} are linear expressions, is_present_index is either</span>
        <span class="c1">#      None or the index of a Boolean literal. name is a string</span>
        <span class="c1">#   case 2: called when querying an existing interval variable.</span>
        <span class="c1">#      start_index is an int, all parameters after are None.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_present_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_present_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_present_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the interval constraint in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the interval protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(start = </span><span class="si">%s</span><span class="s1">, size = </span><span class="si">%s</span><span class="s1">, end = </span><span class="si">%s</span><span class="s1">, is_present = </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">),</span>
                <span class="n">ShortName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(start = </span><span class="si">%s</span><span class="s1">, size = </span><span class="si">%s</span><span class="s1">, end = </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                <span class="n">ShortExprName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SizeExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Represents an Interval variable.</p>

<p>An interval variable is both a constraint and a variable. It is defined by
three integer variables: start, size, and end.</p>

<p>It is a constraint because, internally, it enforces that start + size == end.</p>

<p>It is also a variable as it can appear in specific scheduling constraints:
NoOverlap, NoOverlap2D, Cumulative.</p>

<p>Optionally, an enforcement literal can be added to this constraint, in which
case these scheduling constraints will ignore interval variables with
enforcement literals assigned to false. Conversely, these constraints will
also set these enforcement literals to false if they cannot fit these
intervals into the schedule.</p>
</div>


                            <div id="IntervalVar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntervalVar</span><span class="signature">(model, start, size, end, is_present_index, name)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="c1"># As with the IntVar::__init__ method, we hack the __init__ method to</span>
        <span class="c1"># support two use cases:</span>
        <span class="c1">#   case 1: called when creating a new interval variable.</span>
        <span class="c1">#      {start|size|end} are linear expressions, is_present_index is either</span>
        <span class="c1">#      None or the index of a Boolean literal. name is a string</span>
        <span class="c1">#   case 2: called when querying an existing interval variable.</span>
        <span class="c1">#      start_index is an int, all parameters after are None.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_present_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_present_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_present_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.Index" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.Index">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Index</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of the interval constraint in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index of the interval constraint in the model.</p>
</div>


                            </div>
                            <div id="IntervalVar.Proto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.Proto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Proto</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the interval protobuf.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the interval protobuf.</p>
</div>


                            </div>
                            <div id="IntervalVar.Name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.Name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Name</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">name</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartExpr</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SizeExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SizeExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SizeExpr</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SizeExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndExpr</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">RebuildFromLinearExpressionProto</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ct</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="ObjectIsATrueLiteral">
                            <div class="attr function"><a class="headerlink" href="#ObjectIsATrueLiteral">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectIsATrueLiteral</span><span class="signature">(literal)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ObjectIsATrueLiteral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if literal is either True, or a Boolean literals fixed to True.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checks if literal is either True, or a Boolean literals fixed to True.</p>
</div>


                </section>
                <section id="ObjectIsAFalseLiteral">
                            <div class="attr function"><a class="headerlink" href="#ObjectIsAFalseLiteral">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectIsAFalseLiteral</span><span class="signature">(literal)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ObjectIsAFalseLiteral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if literal is either False, or a Boolean literals fixed to False.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checks if literal is either False, or a Boolean literals fixed to False.</p>
</div>


                </section>
                <section id="CpModel">
                                <div class="attr class">
        <a class="headerlink" href="#CpModel">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">CpModel</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CpModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Methods for building a CP model.</span>

<span class="sd">  Methods beginning with:</span>

<span class="sd">  * ```New``` create integer, boolean, or interval variables.</span>
<span class="sd">  * ```Add``` create new constraints and add them to the model.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpModelProto</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Integer variable.</span>

    <span class="k">def</span> <span class="nf">NewIntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an integer variable with domain [lb, ub].</span>

<span class="sd">    The CP-SAT solver is limited to integer variables. If you have fractional</span>
<span class="sd">    values, scale them up so that they become integers; if you have strings,</span>
<span class="sd">    encode them as integers.</span>

<span class="sd">    Args:</span>
<span class="sd">      lb: Lower bound for the variable.</span>
<span class="sd">      ub: Upper bound for the variable.</span>
<span class="sd">      name: The name of the variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      a variable whose domain is [lb, ub].</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewIntVarFromDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an integer variable from a domain.</span>

<span class="sd">    A domain is a set of integers specified by a collection of intervals.</span>
<span class="sd">    For example, `model.NewIntVarFromDomain(cp_model.</span>
<span class="sd">         Domain.FromIntervals([[1, 2], [4, 6]]), &#39;x&#39;)`</span>

<span class="sd">    Args:</span>
<span class="sd">      domain: An instance of the Domain class.</span>
<span class="sd">      name: The name of the variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a variable whose domain is the given domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewBoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a 0-1 variable with the given name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewConstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Declares a constant integer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                      <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Linear constraints.</span>

    <span class="k">def</span> <span class="nf">AddLinearConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the constraint: `lb &lt;= linear_expr &lt;= ub`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddLinearExpressionInDomain</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">AddLinearExpressionInDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the constraint: `linear_expr` in `domain`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
            <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="n">linear_expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntVar</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Wrong argument&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
                <span class="n">cmh</span><span class="o">.</span><span class="n">capped_subtraction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">domain</span><span class="o">.</span><span class="n">FlattenedIntervals</span><span class="p">()</span>
            <span class="p">])</span>
            <span class="k">return</span> <span class="n">ct</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">domain</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([])</span>  <span class="c1"># Evaluate to false.</span>
            <span class="c1"># Nothing to do otherwise.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Not supported: CpModel.AddLinearExpressionInDomain(&#39;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a `BoundedLinearExpression` to the model.</span>

<span class="sd">    Args:</span>
<span class="sd">      ct: A [`BoundedLinearExpression`](#boundedlinearexpression).</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">BoundedLinearExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddLinearExpressionInDomain</span><span class="p">(</span>
                <span class="n">ct</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">Domain</span><span class="o">.</span><span class="n">FromFlatIntervals</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">ct</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([</span><span class="kc">True</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ct</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([])</span>  <span class="c1"># Evaluate to false.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not supported: CpModel.Add(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="c1"># General Integer Constraints.</span>

    <span class="k">def</span> <span class="nf">AddAllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AllDifferent(expressions).</span>

<span class="sd">    This constraint forces all expressions to have different values.</span>

<span class="sd">    Args:</span>
<span class="sd">      *expressions: simple expressions of the form a * var + constant.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">all_diff</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expanded</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the element constraint: `variables[index] == target`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddElement expects a non-empty variables array&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">variables</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Circuit(arcs).</span>

<span class="sd">    Adds a circuit constraint from a sparse list of arcs that encode the graph.</span>

<span class="sd">    A circuit is a unique Hamiltonian path in a subgraph of the total</span>
<span class="sd">    graph. In case a node &#39;i&#39; is not in the path, then there must be a</span>
<span class="sd">    loop arc &#39;i -&gt; i&#39; associated with a true literal. Otherwise</span>
<span class="sd">    this constraint will fail.</span>

<span class="sd">    Args:</span>
<span class="sd">      arcs: a list of arcs. An arc is a tuple (source_node, destination_node,</span>
<span class="sd">        literal). The arc is selected in the circuit if the literal is true.</span>
<span class="sd">        Both source_node and destination_node must be integers between 0 and the</span>
<span class="sd">        number of nodes - 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the list of arcs is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddCircuit expects a non-empty array of arcs&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMultipleCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a multiple circuit constraint, aka the &quot;VRP&quot; constraint.</span>

<span class="sd">    The direct graph where arc #i (from tails[i] to head[i]) is present iff</span>
<span class="sd">    literals[i] is true must satisfy this set of properties:</span>
<span class="sd">    - #incoming arcs == 1 except for node 0.</span>
<span class="sd">    - #outgoing arcs == 1 except for node 0.</span>
<span class="sd">    - for node zero, #incoming arcs == #outgoing arcs.</span>
<span class="sd">    - There are no duplicate arcs.</span>
<span class="sd">    - Self-arcs are allowed except for node 0.</span>
<span class="sd">    - There is no cycle in this graph, except through node 0.</span>

<span class="sd">    Args:</span>
<span class="sd">      arcs: a list of arcs. An arc is a tuple (source_node, destination_node,</span>
<span class="sd">        literal). The arc is selected in the circuit if the literal is true.</span>
<span class="sd">        Both source_node and destination_node must be integers between 0 and the</span>
<span class="sd">        number of nodes - 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the list of arcs is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddMultipleCircuit expects a non-empty array of arcs&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AllowedAssignments(variables, tuples_list).</span>

<span class="sd">    An AllowedAssignments constraint is a constraint on an array of variables,</span>
<span class="sd">    which requires that when all variables are assigned values, the resulting</span>
<span class="sd">    array equals one of the  tuples in `tuple_list`.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: A list of variables.</span>
<span class="sd">      tuples_list: A list of admissible tuples. Each tuple must have the same</span>
<span class="sd">        length as the variables, and the ith value of a tuple corresponds to the</span>
<span class="sd">        ith variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: If a tuple does not have the same size as the list of</span>
<span class="sd">          variables.</span>
<span class="sd">      ValueError: If the array of variables is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddAllowedAssignments expects a non-empty variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tuples_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arity</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Tuple &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; has the wrong arity&#39;</span><span class="p">)</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">ar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddForbiddenAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AddForbiddenAssignments(variables, [tuples_list]).</span>

<span class="sd">    A ForbiddenAssignments constraint is a constraint on an array of variables</span>
<span class="sd">    where the list of impossible combinations is provided in the tuples list.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: A list of variables.</span>
<span class="sd">      tuples_list: A list of forbidden tuples. Each tuple must have the same</span>
<span class="sd">        length as the variables, and the *i*th value of a tuple corresponds to</span>
<span class="sd">        the *i*th variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: If a tuple does not have the same size as the list of</span>
<span class="sd">                 variables.</span>
<span class="sd">      ValueError: If the array of variables is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddForbiddenAssignments expects a non-empty variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddAllowedAssignments</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">negated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAutomaton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_variables</span><span class="p">,</span> <span class="n">starting_state</span><span class="p">,</span> <span class="n">final_states</span><span class="p">,</span>
                     <span class="n">transition_triples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an automaton constraint.</span>

<span class="sd">    An automaton constraint takes a list of variables (of size *n*), an initial</span>
<span class="sd">    state, a set of final states, and a set of transitions. A transition is a</span>
<span class="sd">    triplet (*tail*, *transition*, *head*), where *tail* and *head* are states,</span>
<span class="sd">    and *transition* is the label of an arc from *head* to *tail*,</span>
<span class="sd">    corresponding to the value of one variable in the list of variables.</span>

<span class="sd">    This automaton will be unrolled into a flow with *n* + 1 phases. Each phase</span>
<span class="sd">    contains the possible states of the automaton. The first state contains the</span>
<span class="sd">    initial state. The last phase contains the final states.</span>

<span class="sd">    Between two consecutive phases *i* and *i* + 1, the automaton creates a set</span>
<span class="sd">    of arcs. For each transition (*tail*, *transition*, *head*), it will add</span>
<span class="sd">    an arc from the state *tail* of phase *i* and the state *head* of phase</span>
<span class="sd">    *i* + 1. This arc is labeled by the value *transition* of the variables</span>
<span class="sd">    `variables[i]`. That is, this arc can only be selected if `variables[i]`</span>
<span class="sd">    is assigned the value *transition*.</span>

<span class="sd">    A feasible solution of this constraint is an assignment of variables such</span>
<span class="sd">    that, starting from the initial state in phase 0, there is a path labeled by</span>
<span class="sd">    the values of the variables that ends in one of the final states in the</span>
<span class="sd">    final phase.</span>

<span class="sd">    Args:</span>
<span class="sd">      transition_variables: A non-empty list of variables whose values</span>
<span class="sd">        correspond to the labels of the arcs traversed by the automaton.</span>
<span class="sd">      starting_state: The initial state of the automaton.</span>
<span class="sd">      final_states: A non-empty list of admissible final states.</span>
<span class="sd">      transition_triples: A list of transitions for the automaton, in the</span>
<span class="sd">        following format (current_state, variable_value, next_state).</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if `transition_variables`, `final_states`, or</span>
<span class="sd">        `transition_triples` are empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transition_variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddAutomaton expects a non-empty transition_variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">final_states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddAutomaton expects some final states&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transition_triples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddAutomaton expects some transition triples&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">transition_variables</span><span class="p">])</span>
        <span class="n">starting_state</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">starting_state</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">starting_state</span> <span class="o">=</span> <span class="n">starting_state</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">final_states</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">final_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transition_triples</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Tuple &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s1">&#39; has the wrong arity (!= 3)&#39;</span><span class="p">)</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_tail</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_head</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddInverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">inverse_variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Inverse(variables, inverse_variables).</span>

<span class="sd">    An inverse constraint enforces that if `variables[i]` is assigned a value</span>
<span class="sd">    `j`, then `inverse_variables[j]` is assigned a value `i`. And vice versa.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: An array of integer variables.</span>
<span class="sd">      inverse_variables: An array of integer variables.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: if variables and inverse_variables have different lengths, or</span>
<span class="sd">          if they are empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">inverse_variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;The Inverse constraint does not accept empty arrays&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inverse_variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;In the inverse constraint, the two array variables and&#39;</span>
                <span class="s1">&#39; inverse_variables must have the same length.&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">f_direct</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">f_inverse</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inverse_variables</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddReservoirConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">level_changes</span><span class="p">,</span> <span class="n">min_level</span><span class="p">,</span>
                               <span class="n">max_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Reservoir(times, level_changes, min_level, max_level).</span>

<span class="sd">    Maintains a reservoir level within bounds. The water level starts at 0, and</span>
<span class="sd">    at any time, it must be between min_level and max_level.</span>

<span class="sd">    If the affine expression `times[i]` is assigned a value t, then the current</span>
<span class="sd">    level changes by `level_changes[i]`, which is constant, at time t.</span>

<span class="sd">     Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please</span>
<span class="sd">     use fixed level_changes to simulate initial state.</span>

<span class="sd">     Therefore, at any time:</span>
<span class="sd">         sum(level_changes[i] if times[i] &lt;= t) in [min_level, max_level]</span>

<span class="sd">    Args:</span>
<span class="sd">      times: A list of affine expressions which specify the time of the filling</span>
<span class="sd">        or emptying the reservoir.</span>
<span class="sd">      level_changes: A list of integer values that specifies the amount of the</span>
<span class="sd">        emptying or filling.</span>
<span class="sd">      min_level: At any time, the level of the reservoir must be greater or</span>
<span class="sd">        equal than the min level.</span>
<span class="sd">      max_level: At any time, the level of the reservoir must be less or equal</span>
<span class="sd">        than the max level.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if max_level &lt; min_level.</span>

<span class="sd">      ValueError: if max_level &lt; 0.</span>

<span class="sd">      ValueError: if min_level &gt; 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="n">min_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Reservoir constraint must have a max_level &gt;= min_level&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a max_level &gt;= 0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a min_level &lt;= 0&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">time_exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">level_changes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">level_changes</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">min_level</span> <span class="o">=</span> <span class="n">min_level</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="n">max_level</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddReservoirConstraintWithActive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">level_changes</span><span class="p">,</span> <span class="n">actives</span><span class="p">,</span>
                                         <span class="n">min_level</span><span class="p">,</span> <span class="n">max_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Reservoir(times, level_changes, actives, min_level, max_level).</span>

<span class="sd">    Maintains a reservoir level within bounds. The water level starts at 0, and</span>
<span class="sd">    at any time, it must be between min_level and max_level.</span>

<span class="sd">    If the variable `times[i]` is assigned a value t, and `actives[i]` is</span>
<span class="sd">    `True`, then the current level changes by `level_changes[i]`, which is</span>
<span class="sd">    constant,</span>
<span class="sd">    at time t.</span>

<span class="sd">     Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please</span>
<span class="sd">     use fixed level_changes to simulate initial state.</span>

<span class="sd">     Therefore, at any time:</span>
<span class="sd">         sum(level_changes[i] * actives[i] if times[i] &lt;= t) in [min_level,</span>
<span class="sd">         max_level]</span>


<span class="sd">    The array of boolean variables &#39;actives&#39;, if defined, indicates which</span>
<span class="sd">    actions are actually performed.</span>

<span class="sd">    Args:</span>
<span class="sd">      times: A list of affine expressions which specify the time of the filling</span>
<span class="sd">        or emptying the reservoir.</span>
<span class="sd">      level_changes: A list of integer values that specifies the amount of the</span>
<span class="sd">        emptying or filling.</span>
<span class="sd">      actives: a list of boolean variables. They indicates if the</span>
<span class="sd">        emptying/refilling events actually take place.</span>
<span class="sd">      min_level: At any time, the level of the reservoir must be greater or</span>
<span class="sd">        equal than the min level.</span>
<span class="sd">      max_level: At any time, the level of the reservoir must be less or equal</span>
<span class="sd">        than the max level.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if max_level &lt; min_level.</span>

<span class="sd">      ValueError: if max_level &lt; 0.</span>

<span class="sd">      ValueError: if min_level &gt; 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="n">min_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Reservoir constraint must have a max_level &gt;= min_level&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a max_level &gt;= 0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a min_level &lt;= 0&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">time_exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">level_changes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">level_changes</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">active_literals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">actives</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">min_level</span> <span class="o">=</span> <span class="n">min_level</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="n">max_level</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMapDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">bool_var_array</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `var == i + offset &lt;=&gt; bool_var_array[i] == true for all i`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bool_var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bool_var_array</span><span class="p">):</span>
            <span class="n">b_index</span> <span class="o">=</span> <span class="n">bool_var</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="n">var_index</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_index</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_index</span><span class="p">)</span>

            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_index</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">b_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">AddImplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `a =&gt; b` (`a` implies `b`).&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_or</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddBoolOr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `Or(literals) == true`: Sum(literals) &gt;= 1.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_or</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAtLeastOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as `AddBoolOr`: `Sum(literals) &gt;= 1`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">(</span><span class="o">*</span><span class="n">literals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddAtMostOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `AtMostOne(literals)`: `Sum(literals) &lt;= 1`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">at_most_one</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddExactlyOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `ExactlyOne(literals)`: `Sum(literals) == 1`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">exactly_one</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddBoolAnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `And(literals) == true`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_and</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddBoolXOr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `XOr(literals) == true`.</span>

<span class="sd">    In contrast to AddBoolOr and AddBoolAnd, it does not support</span>
<span class="sd">        .OnlyEnforceIf().</span>

<span class="sd">    Args:</span>
<span class="sd">      *literals: the list of literals in the constraint.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `Constraint` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_xor</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">exprs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Min(exprs)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">exprs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Max(exprs)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddDivisionEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == num // denom` (integer division rounded towards 0).&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">denom</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddAbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Abs(var)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddModuloEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target = var % mod`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddMultiplicationEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == expressions[0] * .. * expressions[n]`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_prod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_prod</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="c1"># Scheduling support</span>

    <span class="k">def</span> <span class="nf">NewIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, size, and end.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Internally, it ensures that `start + size == end`.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      end: The end of the interval. It can be an affine or constant expression.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>

        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: size must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: end must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewFixedSizeIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, and a fixed size.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It must be an integer value.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewOptionalIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_present</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an optional interval var from start, size, end, and is_present.</span>

<span class="sd">    An optional interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap. This constraint is protected by an is_present</span>
<span class="sd">    literal that indicates if it is active or not.</span>

<span class="sd">    Internally, it ensures that `is_present` implies `start + size == end`.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an integer value, or an</span>
<span class="sd">        integer variable.</span>
<span class="sd">      size: The size of the interval. It can be an integer value, or an integer</span>
<span class="sd">        variable.</span>
<span class="sd">      end: The end of the interval. It can be an integer value, or an integer</span>
<span class="sd">        variable.</span>
<span class="sd">      is_present: A literal that indicates if the interval is active or not. A</span>
<span class="sd">        inactive interval is simply ignored by all constraints.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="c1"># Add the linear constraint.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">OnlyEnforceIf</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>

        <span class="c1"># Creates the IntervalConstraintProto object.</span>
        <span class="n">is_present_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: size must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: end must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span>
                           <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewOptionalFixedSizeIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">is_present</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, and a fixed size.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It must be an integer value.</span>
<span class="sd">      is_present: A literal that indicates if the interval is active or not. A</span>
<span class="sd">        inactive interval is simply ignored by all constraints.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="n">is_present_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span>
                           <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddNoOverlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_vars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds NoOverlap(interval_vars).</span>

<span class="sd">    A NoOverlap constraint ensures that all present intervals do not overlap</span>
<span class="sd">    in time.</span>

<span class="sd">    Args:</span>
<span class="sd">      interval_vars: The list of interval variables to constrain.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">interval_vars</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddNoOverlap2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_intervals</span><span class="p">,</span> <span class="n">y_intervals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds NoOverlap2D(x_intervals, y_intervals).</span>

<span class="sd">    A NoOverlap2D constraint ensures that all present rectangles do not overlap</span>
<span class="sd">    on a plane. Each rectangle is aligned with the X and Y axis, and is defined</span>
<span class="sd">    by two intervals which represent its projection onto the X and Y axis.</span>

<span class="sd">    Furthermore, one box is optional if at least one of the x or y interval is</span>
<span class="sd">    optional.</span>

<span class="sd">    Args:</span>
<span class="sd">      x_intervals: The X coordinates of the rectangles.</span>
<span class="sd">      y_intervals: The Y coordinates of the rectangles.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap_2d</span><span class="o">.</span><span class="n">x_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_intervals</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap_2d</span><span class="o">.</span><span class="n">y_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y_intervals</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="k">def</span> <span class="nf">AddCumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">demands</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Cumulative(intervals, demands, capacity).</span>

<span class="sd">    This constraint enforces that:</span>

<span class="sd">        for all t:</span>
<span class="sd">          sum(demands[i]</span>
<span class="sd">            if (start(intervals[i]) &lt;= t &lt; end(intervals[i])) and</span>
<span class="sd">            (intervals[i] is present)) &lt;= capacity</span>

<span class="sd">    Args:</span>
<span class="sd">      intervals: The list of intervals.</span>
<span class="sd">      demands: The list of demands for each interval. Each demand must be &gt;= 0.</span>
<span class="sd">        Each demand can be an integer value, or an integer variable.</span>
<span class="sd">      capacity: The maximum capacity of the cumulative constraint. It must be a</span>
<span class="sd">        positive integer value or variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">demands</span><span class="p">:</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">demands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">capacity</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">capacity</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>

    <span class="c1"># Support for deep copy.</span>
    <span class="k">def</span> <span class="nf">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the model, and creates a new one from a CpModelProto instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">other_model</span><span class="o">.</span><span class="n">Proto</span><span class="p">())</span>

        <span class="c1"># Rebuild constant map.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">GetBoolVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created Boolean variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetBoolVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetBoolVarFromProtoIndex: index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> does not reference&#39;</span> <span class="o">+</span>
                <span class="s1">&#39; a Boolean variable&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created integer variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntervalVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created interval variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntervalVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ct</span><span class="o">.</span><span class="n">HasField</span><span class="p">(</span><span class="s1">&#39;interval&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntervalVarFromProtoIndex: index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> does not reference an&#39;</span>
                <span class="o">+</span> <span class="s1">&#39; interval variable&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Helpers.</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the underlying CpModelProto.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span>

    <span class="k">def</span> <span class="nf">Negated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">GetOrMakeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of a variable, its negation, or a number.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">)</span> <span class="ow">and</span>
              <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">arg</span><span class="o">.</span><span class="n">Expression</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetOrMakeIndex(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an index from a boolean expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AssertIsBooleanVariable</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AssertIsBooleanVariable</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">Not</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_boolean</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetOrMakeBooleanIndex(&#39;</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntervalIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntervalVar</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetIntervalIndex(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">VarIndexToVarProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">var_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="o">-</span><span class="n">var_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">ParseLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a LinearExpressionProto built from a LinearExpr instance.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">LinearExpressionProto</span><span class="p">()</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">negate</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="n">linear_expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">constant</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Wrong argument&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
            <span class="n">result</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_SetObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;objective&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;floating_point_objective&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">minimize</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Negated</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">Index</span><span class="p">()))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
            <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">is_integer</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">GetFloatVarValueMap</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">is_integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">minimize</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">constant</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">constant</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">minimize</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Negated</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">maximize</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">minimize</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">constant</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">floating_point_objective</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39; is not a valid objective&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model to minimize(obj).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetObjective</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model to maximize(obj).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetObjective</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">HasField</span><span class="p">(</span><span class="s1">&#39;objective&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDecisionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">var_strategy</span><span class="p">,</span> <span class="n">domain_strategy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a search strategy to the model.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: a list of variables this strategy will assign.</span>
<span class="sd">      var_strategy: heuristic to choose the next variable to assign.</span>
<span class="sd">      domain_strategy: heuristic to reduce the domain of the selected variable.</span>
<span class="sd">        Currently, this is advanced code: the union of all strategies added to</span>
<span class="sd">          the model must be complete, i.e. instantiates all variables.</span>
<span class="sd">          Otherwise, Solve() will fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="n">strategy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">search_strategy</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">strategy</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="n">strategy</span><span class="o">.</span><span class="n">variable_selection_strategy</span> <span class="o">=</span> <span class="n">var_strategy</span>
        <span class="n">strategy</span><span class="o">.</span><span class="n">domain_reduction_strategy</span> <span class="o">=</span> <span class="n">domain_strategy</span>

    <span class="k">def</span> <span class="nf">ModelStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string containing some model statistics.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedModelStats</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">Validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string indicating that the model is invalid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedValidateModel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">ExportToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the model as a protocol buffer to &#39;file&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">      file: file to write the model to. If the filename ends with &#39;txt&#39;, the</span>
<span class="sd">        model will be written as a text file, otherwise, the binary format will</span>
<span class="sd">        be used.</span>

<span class="sd">    Returns:</span>
<span class="sd">      True if the model was correctly written.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedWriteModelToFile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssertIsBooleanVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s1">&#39; is not a boolean variable&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39; is not a boolean variable&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds &#39;var == value&#39; as a hint to the solver.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">solution_hint</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">solution_hint</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ClearHints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove any solution hint from the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;solution_hint&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddAssumption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the literal &#39;lit&#39; to the model as assumptions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">assumptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">lit</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">AddAssumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the literals to the model as assumptions.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AddAssumption</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ClearAssumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all assumptions from the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;assumptions&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Methods for building a CP model.</p>

<p>Methods beginning with:</p>

<ul>
<li><code>New</code> create integer, boolean, or interval variables.</li>
<li><code><a href="#CpModel.Add">Add</a></code> create new constraints and add them to the model.</li>
</ul>
</div>


                            <div id="CpModel.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">CpModel</span><span class="signature">()</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpModelProto</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpModel.NewIntVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewIntVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewIntVar</span><span class="signature">(self, lb, ub, name)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewIntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an integer variable with domain [lb, ub].</span>

<span class="sd">    The CP-SAT solver is limited to integer variables. If you have fractional</span>
<span class="sd">    values, scale them up so that they become integers; if you have strings,</span>
<span class="sd">    encode them as integers.</span>

<span class="sd">    Args:</span>
<span class="sd">      lb: Lower bound for the variable.</span>
<span class="sd">      ub: Upper bound for the variable.</span>
<span class="sd">      name: The name of the variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      a variable whose domain is [lb, ub].</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create an integer variable with domain [lb, ub].</p>

<p>The CP-SAT solver is limited to integer variables. If you have fractional
values, scale them up so that they become integers; if you have strings,
encode them as integers.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>lb:</strong>  Lower bound for the variable.</li>
<li><strong>ub:</strong>  Upper bound for the variable.</li>
<li><strong>name:</strong>  The name of the variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>a variable whose domain is [lb, ub].</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.NewIntVarFromDomain" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewIntVarFromDomain">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewIntVarFromDomain</span><span class="signature">(self, domain, name)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewIntVarFromDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an integer variable from a domain.</span>

<span class="sd">    A domain is a set of integers specified by a collection of intervals.</span>
<span class="sd">    For example, `model.NewIntVarFromDomain(cp_model.</span>
<span class="sd">         Domain.FromIntervals([[1, 2], [4, 6]]), &#39;x&#39;)`</span>

<span class="sd">    Args:</span>
<span class="sd">      domain: An instance of the Domain class.</span>
<span class="sd">      name: The name of the variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a variable whose domain is the given domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create an integer variable from a domain.</p>

<p>A domain is a set of integers specified by a collection of intervals.
For example, <code>model.NewIntVarFromDomain(cp_model.
     Domain.FromIntervals([[1, 2], [4, 6]]), 'x')</code></p>

<h6 id="args">Args</h6>

<ul>
<li><strong>domain:</strong>  An instance of the Domain class.</li>
<li><strong>name:</strong>  The name of the variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>a variable whose domain is the given domain.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.NewBoolVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewBoolVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewBoolVar</span><span class="signature">(self, name)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewBoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a 0-1 variable with the given name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a 0-1 variable with the given name.</p>
</div>


                            </div>
                            <div id="CpModel.NewConstant" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewConstant">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewConstant</span><span class="signature">(self, value)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewConstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Declares a constant integer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                      <span class="kc">None</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Declares a constant integer.</p>
</div>


                            </div>
                            <div id="CpModel.AddLinearConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddLinearConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddLinearConstraint</span><span class="signature">(self, linear_expr, lb, ub)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddLinearConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the constraint: `lb &lt;= linear_expr &lt;= ub`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddLinearExpressionInDomain</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">Domain</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds the constraint: <code>lb &lt;= linear_expr &lt;= ub</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddLinearExpressionInDomain" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddLinearExpressionInDomain">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddLinearExpressionInDomain</span><span class="signature">(self, linear_expr, domain)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddLinearExpressionInDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the constraint: `linear_expr` in `domain`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
            <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="n">linear_expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntVar</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Wrong argument&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
                <span class="n">cmh</span><span class="o">.</span><span class="n">capped_subtraction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">domain</span><span class="o">.</span><span class="n">FlattenedIntervals</span><span class="p">()</span>
            <span class="p">])</span>
            <span class="k">return</span> <span class="n">ct</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">domain</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([])</span>  <span class="c1"># Evaluate to false.</span>
            <span class="c1"># Nothing to do otherwise.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Not supported: CpModel.AddLinearExpressionInDomain(&#39;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds the constraint: <code>linear_expr</code> in <code>domain</code>.</p>
</div>


                            </div>
                            <div id="CpModel.Add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.Add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Add</span><span class="signature">(self, ct)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a `BoundedLinearExpression` to the model.</span>

<span class="sd">    Args:</span>
<span class="sd">      ct: A [`BoundedLinearExpression`](#boundedlinearexpression).</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">BoundedLinearExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddLinearExpressionInDomain</span><span class="p">(</span>
                <span class="n">ct</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">Domain</span><span class="o">.</span><span class="n">FromFlatIntervals</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">Bounds</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">ct</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([</span><span class="kc">True</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ct</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">([])</span>  <span class="c1"># Evaluate to false.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Not supported: CpModel.Add(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a <code><a href="#BoundedLinearExpression">BoundedLinearExpression</a></code> to the model.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>ct:</strong>  A <a href="#boundedlinearexpression"><code>BoundedLinearExpression</code></a>.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.AddAllDifferent" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAllDifferent">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAllDifferent</span><span class="signature">(self, *expressions)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AllDifferent(expressions).</span>

<span class="sd">    This constraint forces all expressions to have different values.</span>

<span class="sd">    Args:</span>
<span class="sd">      *expressions: simple expressions of the form a * var + constant.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">all_diff</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expanded</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds AllDifferent(expressions).</p>

<p>This constraint forces all expressions to have different values.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>*expressions:</strong>  simple expressions of the form a * var + constant.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.AddElement" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddElement">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddElement</span><span class="signature">(self, index, variables, target)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the element constraint: `variables[index] == target`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddElement expects a non-empty variables array&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">variables</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds the element constraint: <code>variables[index] == target</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddCircuit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddCircuit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddCircuit</span><span class="signature">(self, arcs)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Circuit(arcs).</span>

<span class="sd">    Adds a circuit constraint from a sparse list of arcs that encode the graph.</span>

<span class="sd">    A circuit is a unique Hamiltonian path in a subgraph of the total</span>
<span class="sd">    graph. In case a node &#39;i&#39; is not in the path, then there must be a</span>
<span class="sd">    loop arc &#39;i -&gt; i&#39; associated with a true literal. Otherwise</span>
<span class="sd">    this constraint will fail.</span>

<span class="sd">    Args:</span>
<span class="sd">      arcs: a list of arcs. An arc is a tuple (source_node, destination_node,</span>
<span class="sd">        literal). The arc is selected in the circuit if the literal is true.</span>
<span class="sd">        Both source_node and destination_node must be integers between 0 and the</span>
<span class="sd">        number of nodes - 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the list of arcs is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddCircuit expects a non-empty array of arcs&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds Circuit(arcs).</p>

<p>Adds a circuit constraint from a sparse list of arcs that encode the graph.</p>

<p>A circuit is a unique Hamiltonian path in a subgraph of the total
graph. In case a node 'i' is not in the path, then there must be a
loop arc 'i -> i' associated with a true literal. Otherwise
this constraint will fail.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>arcs:</strong>  a list of arcs. An arc is a tuple (source_node, destination_node,
literal). The arc is selected in the circuit if the literal is true.
Both source_node and destination_node must be integers between 0 and the
number of nodes - 1.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError:</strong>  If the list of arcs is empty.</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddMultipleCircuit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddMultipleCircuit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddMultipleCircuit</span><span class="signature">(self, arcs)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddMultipleCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a multiple circuit constraint, aka the &quot;VRP&quot; constraint.</span>

<span class="sd">    The direct graph where arc #i (from tails[i] to head[i]) is present iff</span>
<span class="sd">    literals[i] is true must satisfy this set of properties:</span>
<span class="sd">    - #incoming arcs == 1 except for node 0.</span>
<span class="sd">    - #outgoing arcs == 1 except for node 0.</span>
<span class="sd">    - for node zero, #incoming arcs == #outgoing arcs.</span>
<span class="sd">    - There are no duplicate arcs.</span>
<span class="sd">    - Self-arcs are allowed except for node 0.</span>
<span class="sd">    - There is no cycle in this graph, except through node 0.</span>

<span class="sd">    Args:</span>
<span class="sd">      arcs: a list of arcs. An arc is a tuple (source_node, destination_node,</span>
<span class="sd">        literal). The arc is selected in the circuit if the literal is true.</span>
<span class="sd">        Both source_node and destination_node must be integers between 0 and the</span>
<span class="sd">        number of nodes - 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: If the list of arcs is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddMultipleCircuit expects a non-empty array of arcs&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="n">arcs</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int32</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">tails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a multiple circuit constraint, aka the "VRP" constraint.</p>

<p>The direct graph where arc #i (from tails[i] to head[i]) is present iff
literals[i] is true must satisfy this set of properties:</p>

<ul>
<li>#incoming arcs == 1 except for node 0.</li>
<li>#outgoing arcs == 1 except for node 0.</li>
<li>for node zero, #incoming arcs == #outgoing arcs.</li>
<li>There are no duplicate arcs.</li>
<li>Self-arcs are allowed except for node 0.</li>
<li>There is no cycle in this graph, except through node 0.</li>
</ul>

<h6 id="args">Args</h6>

<ul>
<li><strong>arcs:</strong>  a list of arcs. An arc is a tuple (source_node, destination_node,
literal). The arc is selected in the circuit if the literal is true.
Both source_node and destination_node must be integers between 0 and the
number of nodes - 1.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError:</strong>  If the list of arcs is empty.</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddAllowedAssignments" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAllowedAssignments">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAllowedAssignments</span><span class="signature">(self, variables, tuples_list)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AllowedAssignments(variables, tuples_list).</span>

<span class="sd">    An AllowedAssignments constraint is a constraint on an array of variables,</span>
<span class="sd">    which requires that when all variables are assigned values, the resulting</span>
<span class="sd">    array equals one of the  tuples in `tuple_list`.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: A list of variables.</span>
<span class="sd">      tuples_list: A list of admissible tuples. Each tuple must have the same</span>
<span class="sd">        length as the variables, and the ith value of a tuple corresponds to the</span>
<span class="sd">        ith variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: If a tuple does not have the same size as the list of</span>
<span class="sd">          variables.</span>
<span class="sd">      ValueError: If the array of variables is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddAllowedAssignments expects a non-empty variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tuples_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arity</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Tuple &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; has the wrong arity&#39;</span><span class="p">)</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">ar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds AllowedAssignments(variables, tuples_list).</p>

<p>An AllowedAssignments constraint is a constraint on an array of variables,
which requires that when all variables are assigned values, the resulting
array equals one of the  tuples in <code>tuple_list</code>.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>variables:</strong>  A list of variables.</li>
<li><strong>tuples_list:</strong>  A list of admissible tuples. Each tuple must have the same
length as the variables, and the ith value of a tuple corresponds to the
ith variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TypeError:</strong>  If a tuple does not have the same size as the list of
variables.</li>
<li><strong>ValueError:</strong>  If the array of variables is empty.</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddForbiddenAssignments" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddForbiddenAssignments">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddForbiddenAssignments</span><span class="signature">(self, variables, tuples_list)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddForbiddenAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds AddForbiddenAssignments(variables, [tuples_list]).</span>

<span class="sd">    A ForbiddenAssignments constraint is a constraint on an array of variables</span>
<span class="sd">    where the list of impossible combinations is provided in the tuples list.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: A list of variables.</span>
<span class="sd">      tuples_list: A list of forbidden tuples. Each tuple must have the same</span>
<span class="sd">        length as the variables, and the *i*th value of a tuple corresponds to</span>
<span class="sd">        the *i*th variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: If a tuple does not have the same size as the list of</span>
<span class="sd">                 variables.</span>
<span class="sd">      ValueError: If the array of variables is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddForbiddenAssignments expects a non-empty variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddAllowedAssignments</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">tuples_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">negated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds AddForbiddenAssignments(variables, [tuples_list]).</p>

<p>A ForbiddenAssignments constraint is a constraint on an array of variables
where the list of impossible combinations is provided in the tuples list.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>variables:</strong>  A list of variables.</li>
<li><strong>tuples_list:</strong>  A list of forbidden tuples. Each tuple must have the same
length as the variables, and the <em>i</em>th value of a tuple corresponds to
the <em>i</em>th variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TypeError:</strong>  If a tuple does not have the same size as the list of
variables.</li>
<li><strong>ValueError:</strong>  If the array of variables is empty.</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddAutomaton" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAutomaton">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAutomaton</span><span class="signature">(
    self,
    transition_variables,
    starting_state,
    final_states,
    transition_triples
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAutomaton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_variables</span><span class="p">,</span> <span class="n">starting_state</span><span class="p">,</span> <span class="n">final_states</span><span class="p">,</span>
                     <span class="n">transition_triples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an automaton constraint.</span>

<span class="sd">    An automaton constraint takes a list of variables (of size *n*), an initial</span>
<span class="sd">    state, a set of final states, and a set of transitions. A transition is a</span>
<span class="sd">    triplet (*tail*, *transition*, *head*), where *tail* and *head* are states,</span>
<span class="sd">    and *transition* is the label of an arc from *head* to *tail*,</span>
<span class="sd">    corresponding to the value of one variable in the list of variables.</span>

<span class="sd">    This automaton will be unrolled into a flow with *n* + 1 phases. Each phase</span>
<span class="sd">    contains the possible states of the automaton. The first state contains the</span>
<span class="sd">    initial state. The last phase contains the final states.</span>

<span class="sd">    Between two consecutive phases *i* and *i* + 1, the automaton creates a set</span>
<span class="sd">    of arcs. For each transition (*tail*, *transition*, *head*), it will add</span>
<span class="sd">    an arc from the state *tail* of phase *i* and the state *head* of phase</span>
<span class="sd">    *i* + 1. This arc is labeled by the value *transition* of the variables</span>
<span class="sd">    `variables[i]`. That is, this arc can only be selected if `variables[i]`</span>
<span class="sd">    is assigned the value *transition*.</span>

<span class="sd">    A feasible solution of this constraint is an assignment of variables such</span>
<span class="sd">    that, starting from the initial state in phase 0, there is a path labeled by</span>
<span class="sd">    the values of the variables that ends in one of the final states in the</span>
<span class="sd">    final phase.</span>

<span class="sd">    Args:</span>
<span class="sd">      transition_variables: A non-empty list of variables whose values</span>
<span class="sd">        correspond to the labels of the arcs traversed by the automaton.</span>
<span class="sd">      starting_state: The initial state of the automaton.</span>
<span class="sd">      final_states: A non-empty list of admissible final states.</span>
<span class="sd">      transition_triples: A list of transitions for the automaton, in the</span>
<span class="sd">        following format (current_state, variable_value, next_state).</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if `transition_variables`, `final_states`, or</span>
<span class="sd">        `transition_triples` are empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transition_variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;AddAutomaton expects a non-empty transition_variables &#39;</span>
                <span class="s1">&#39;array&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">final_states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddAutomaton expects some final states&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transition_triples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AddAutomaton expects some transition triples&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">transition_variables</span><span class="p">])</span>
        <span class="n">starting_state</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">starting_state</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">starting_state</span> <span class="o">=</span> <span class="n">starting_state</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">final_states</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">final_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transition_triples</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Tuple &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s1">&#39; has the wrong arity (!= 3)&#39;</span><span class="p">)</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_tail</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">transition_head</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds an automaton constraint.</p>

<p>An automaton constraint takes a list of variables (of size <em>n</em>), an initial
state, a set of final states, and a set of transitions. A transition is a
triplet (<em>tail</em>, <em>transition</em>, <em>head</em>), where <em>tail</em> and <em>head</em> are states,
and <em>transition</em> is the label of an arc from <em>head</em> to <em>tail</em>,
corresponding to the value of one variable in the list of variables.</p>

<p>This automaton will be unrolled into a flow with <em>n</em> + 1 phases. Each phase
contains the possible states of the automaton. The first state contains the
initial state. The last phase contains the final states.</p>

<p>Between two consecutive phases <em>i</em> and <em>i</em> + 1, the automaton creates a set
of arcs. For each transition (<em>tail</em>, <em>transition</em>, <em>head</em>), it will add
an arc from the state <em>tail</em> of phase <em>i</em> and the state <em>head</em> of phase
<em>i</em> + 1. This arc is labeled by the value <em>transition</em> of the variables
<code>variables[i]</code>. That is, this arc can only be selected if <code>variables[i]</code>
is assigned the value <em>transition</em>.</p>

<p>A feasible solution of this constraint is an assignment of variables such
that, starting from the initial state in phase 0, there is a path labeled by
the values of the variables that ends in one of the final states in the
final phase.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>transition_variables:</strong>  A non-empty list of variables whose values
correspond to the labels of the arcs traversed by the automaton.</li>
<li><strong>starting_state:</strong>  The initial state of the automaton.</li>
<li><strong>final_states:</strong>  A non-empty list of admissible final states.</li>
<li><strong>transition_triples:</strong>  A list of transitions for the automaton, in the
following format (current_state, variable_value, next_state).</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError:</strong>  if <code>transition_variables</code>, <code>final_states</code>, or
<code>transition_triples</code> are empty.</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddInverse" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddInverse">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddInverse</span><span class="signature">(self, variables, inverse_variables)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddInverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">inverse_variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Inverse(variables, inverse_variables).</span>

<span class="sd">    An inverse constraint enforces that if `variables[i]` is assigned a value</span>
<span class="sd">    `j`, then `inverse_variables[j]` is assigned a value `i`. And vice versa.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: An array of integer variables.</span>
<span class="sd">      inverse_variables: An array of integer variables.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: if variables and inverse_variables have different lengths, or</span>
<span class="sd">          if they are empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">variables</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">inverse_variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;The Inverse constraint does not accept empty arrays&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inverse_variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;In the inverse constraint, the two array variables and&#39;</span>
                <span class="s1">&#39; inverse_variables must have the same length.&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">f_direct</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">f_inverse</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inverse_variables</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds Inverse(variables, inverse_variables).</p>

<p>An inverse constraint enforces that if <code>variables[i]</code> is assigned a value
<code>j</code>, then <code>inverse_variables[j]</code> is assigned a value <code>i</code>. And vice versa.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>variables:</strong>  An array of integer variables.</li>
<li><strong>inverse_variables:</strong>  An array of integer variables.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>TypeError:</strong>  if variables and inverse_variables have different lengths, or
if they are empty.</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddReservoirConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddReservoirConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddReservoirConstraint</span><span class="signature">(self, times, level_changes, min_level, max_level)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddReservoirConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">level_changes</span><span class="p">,</span> <span class="n">min_level</span><span class="p">,</span>
                               <span class="n">max_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Reservoir(times, level_changes, min_level, max_level).</span>

<span class="sd">    Maintains a reservoir level within bounds. The water level starts at 0, and</span>
<span class="sd">    at any time, it must be between min_level and max_level.</span>

<span class="sd">    If the affine expression `times[i]` is assigned a value t, then the current</span>
<span class="sd">    level changes by `level_changes[i]`, which is constant, at time t.</span>

<span class="sd">     Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please</span>
<span class="sd">     use fixed level_changes to simulate initial state.</span>

<span class="sd">     Therefore, at any time:</span>
<span class="sd">         sum(level_changes[i] if times[i] &lt;= t) in [min_level, max_level]</span>

<span class="sd">    Args:</span>
<span class="sd">      times: A list of affine expressions which specify the time of the filling</span>
<span class="sd">        or emptying the reservoir.</span>
<span class="sd">      level_changes: A list of integer values that specifies the amount of the</span>
<span class="sd">        emptying or filling.</span>
<span class="sd">      min_level: At any time, the level of the reservoir must be greater or</span>
<span class="sd">        equal than the min level.</span>
<span class="sd">      max_level: At any time, the level of the reservoir must be less or equal</span>
<span class="sd">        than the max level.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if max_level &lt; min_level.</span>

<span class="sd">      ValueError: if max_level &lt; 0.</span>

<span class="sd">      ValueError: if min_level &gt; 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="n">min_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Reservoir constraint must have a max_level &gt;= min_level&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a max_level &gt;= 0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a min_level &lt;= 0&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">time_exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">level_changes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">level_changes</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">min_level</span> <span class="o">=</span> <span class="n">min_level</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="n">max_level</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds Reservoir(times, level_changes, min_level, max_level).</p>

<p>Maintains a reservoir level within bounds. The water level starts at 0, and
at any time, it must be between min_level and max_level.</p>

<p>If the affine expression <code>times[i]</code> is assigned a value t, then the current
level changes by <code>level_changes[i]</code>, which is constant, at time t.</p>

<p>Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please
 use fixed level_changes to simulate initial state.</p>

<p>Therefore, at any time:
     sum(level_changes[i] if times[i] &lt;= t) in [min_level, max_level]</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>times:</strong>  A list of affine expressions which specify the time of the filling
or emptying the reservoir.</li>
<li><strong>level_changes:</strong>  A list of integer values that specifies the amount of the
emptying or filling.</li>
<li><strong>min_level:</strong>  At any time, the level of the reservoir must be greater or
equal than the min level.</li>
<li><strong>max_level:</strong>  At any time, the level of the reservoir must be less or equal
than the max level.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError:</strong>  if max_level &lt; min_level.</li>
<li><strong>ValueError:</strong>  if max_level &lt; 0.</li>
<li><strong>ValueError:</strong>  if min_level &gt; 0</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddReservoirConstraintWithActive" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddReservoirConstraintWithActive">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddReservoirConstraintWithActive</span><span class="signature">(self, times, level_changes, actives, min_level, max_level)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddReservoirConstraintWithActive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">level_changes</span><span class="p">,</span> <span class="n">actives</span><span class="p">,</span>
                                         <span class="n">min_level</span><span class="p">,</span> <span class="n">max_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Reservoir(times, level_changes, actives, min_level, max_level).</span>

<span class="sd">    Maintains a reservoir level within bounds. The water level starts at 0, and</span>
<span class="sd">    at any time, it must be between min_level and max_level.</span>

<span class="sd">    If the variable `times[i]` is assigned a value t, and `actives[i]` is</span>
<span class="sd">    `True`, then the current level changes by `level_changes[i]`, which is</span>
<span class="sd">    constant,</span>
<span class="sd">    at time t.</span>

<span class="sd">     Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please</span>
<span class="sd">     use fixed level_changes to simulate initial state.</span>

<span class="sd">     Therefore, at any time:</span>
<span class="sd">         sum(level_changes[i] * actives[i] if times[i] &lt;= t) in [min_level,</span>
<span class="sd">         max_level]</span>


<span class="sd">    The array of boolean variables &#39;actives&#39;, if defined, indicates which</span>
<span class="sd">    actions are actually performed.</span>

<span class="sd">    Args:</span>
<span class="sd">      times: A list of affine expressions which specify the time of the filling</span>
<span class="sd">        or emptying the reservoir.</span>
<span class="sd">      level_changes: A list of integer values that specifies the amount of the</span>
<span class="sd">        emptying or filling.</span>
<span class="sd">      actives: a list of boolean variables. They indicates if the</span>
<span class="sd">        emptying/refilling events actually take place.</span>
<span class="sd">      min_level: At any time, the level of the reservoir must be greater or</span>
<span class="sd">        equal than the min level.</span>
<span class="sd">      max_level: At any time, the level of the reservoir must be less or equal</span>
<span class="sd">        than the max level.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if max_level &lt; min_level.</span>

<span class="sd">      ValueError: if max_level &lt; 0.</span>

<span class="sd">      ValueError: if min_level &gt; 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="n">min_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Reservoir constraint must have a max_level &gt;= min_level&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a max_level &gt;= 0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reservoir constraint must have a min_level &lt;= 0&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">time_exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">times</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">level_changes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">level_changes</span><span class="p">)</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">active_literals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">actives</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">min_level</span> <span class="o">=</span> <span class="n">min_level</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">reservoir</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="n">max_level</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds Reservoir(times, level_changes, actives, min_level, max_level).</p>

<p>Maintains a reservoir level within bounds. The water level starts at 0, and
at any time, it must be between min_level and max_level.</p>

<p>If the variable <code>times[i]</code> is assigned a value t, and <code>actives[i]</code> is
<code>True</code>, then the current level changes by <code>level_changes[i]</code>, which is
constant,
at time t.</p>

<p>Note that min level must be &lt;= 0, and the max level must be &gt;= 0. Please
 use fixed level_changes to simulate initial state.</p>

<p>Therefore, at any time:
     sum(level_changes[i] * actives[i] if times[i] &lt;= t) in [min_level,
     max_level]</p>

<p>The array of boolean variables 'actives', if defined, indicates which
actions are actually performed.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>times:</strong>  A list of affine expressions which specify the time of the filling
or emptying the reservoir.</li>
<li><strong>level_changes:</strong>  A list of integer values that specifies the amount of the
emptying or filling.</li>
<li><strong>actives:</strong>  a list of boolean variables. They indicates if the
emptying/refilling events actually take place.</li>
<li><strong>min_level:</strong>  At any time, the level of the reservoir must be greater or
equal than the min level.</li>
<li><strong>max_level:</strong>  At any time, the level of the reservoir must be less or equal
than the max level.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError:</strong>  if max_level &lt; min_level.</li>
<li><strong>ValueError:</strong>  if max_level &lt; 0.</li>
<li><strong>ValueError:</strong>  if min_level &gt; 0</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.AddMapDomain" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddMapDomain">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddMapDomain</span><span class="signature">(self, var, bool_var_array, offset=0)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddMapDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">bool_var_array</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `var == i + offset &lt;=&gt; bool_var_array[i] == true for all i`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bool_var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bool_var_array</span><span class="p">):</span>
            <span class="n">b_index</span> <span class="o">=</span> <span class="n">bool_var</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="n">var_index</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_index</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_index</span><span class="p">)</span>

            <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_index</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">b_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">INT_MIN</span><span class="p">:</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">INT_MAX</span><span class="p">:</span>
                <span class="n">model_ct</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>var == i + offset &lt;=&gt; bool_var_array[i] == true for all i</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddImplication" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddImplication">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddImplication</span><span class="signature">(self, a, b)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddImplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `a =&gt; b` (`a` implies `b`).&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_or</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">enforcement_literal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>a =&gt; b</code> (<code>a</code> implies <code>b</code>).</p>
</div>


                            </div>
                            <div id="CpModel.AddBoolOr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddBoolOr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddBoolOr</span><span class="signature">(self, *literals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddBoolOr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `Or(literals) == true`: Sum(literals) &gt;= 1.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_or</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>Or(literals) == true</code>: Sum(literals) &gt;= 1.</p>
</div>


                            </div>
                            <div id="CpModel.AddAtLeastOne" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAtLeastOne">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAtLeastOne</span><span class="signature">(self, *literals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAtLeastOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as `AddBoolOr`: `Sum(literals) &gt;= 1`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AddBoolOr</span><span class="p">(</span><span class="o">*</span><span class="n">literals</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as <code><a href="#CpModel.AddBoolOr">AddBoolOr</a></code>: <code>Sum(literals) &gt;= 1</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddAtMostOne" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAtMostOne">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAtMostOne</span><span class="signature">(self, *literals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAtMostOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `AtMostOne(literals)`: `Sum(literals) &lt;= 1`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">at_most_one</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>AtMostOne(literals)</code>: <code>Sum(literals) &lt;= 1</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddExactlyOne" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddExactlyOne">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddExactlyOne</span><span class="signature">(self, *literals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddExactlyOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `ExactlyOne(literals)`: `Sum(literals) == 1`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">exactly_one</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>ExactlyOne(literals)</code>: <code>Sum(literals) == 1</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddBoolAnd" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddBoolAnd">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddBoolAnd</span><span class="signature">(self, *literals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddBoolAnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `And(literals) == true`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_and</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>And(literals) == true</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddBoolXOr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddBoolXOr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddBoolXOr</span><span class="signature">(self, *literals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddBoolXOr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `XOr(literals) == true`.</span>

<span class="sd">    In contrast to AddBoolOr and AddBoolAnd, it does not support</span>
<span class="sd">        .OnlyEnforceIf().</span>

<span class="sd">    Args:</span>
<span class="sd">      *literals: the list of literals in the constraint.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `Constraint` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">bool_xor</span><span class="o">.</span><span class="n">literals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">literals</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>XOr(literals) == true</code>.</p>

<p>In contrast to AddBoolOr and AddBoolAnd, it does not support
    .OnlyEnforceIf().</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>*literals:</strong>  the list of literals in the constraint.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An <code><a href="#Constraint">Constraint</a></code> object.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.AddMinEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddMinEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddMinEquality</span><span class="signature">(self, target, exprs)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddMinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">exprs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Min(exprs)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>target == Min(exprs)</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddMaxEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddMaxEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddMaxEquality</span><span class="signature">(self, target, exprs)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddMaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">exprs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Max(exprs)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>target == Max(exprs)</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddDivisionEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddDivisionEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddDivisionEquality</span><span class="signature">(self, target, num, denom)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddDivisionEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == num // denom` (integer division rounded towards 0).&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">denom</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_div</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>target == num // denom</code> (integer division rounded towards 0).</p>
</div>


                            </div>
                            <div id="CpModel.AddAbsEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAbsEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAbsEquality</span><span class="signature">(self, target, expr)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == Abs(var)`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">lin_max</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>target == Abs(var)</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddModuloEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddModuloEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddModuloEquality</span><span class="signature">(self, target, var, mod)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddModuloEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target = var % mod`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_mod</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>target = var % mod</code>.</p>
</div>


                            </div>
                            <div id="CpModel.AddMultiplicationEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddMultiplicationEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddMultiplicationEquality</span><span class="signature">(self, target, *expressions)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddMultiplicationEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds `target == expressions[0] * .. * expressions[n]`.&quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_prod</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">int_prod</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds <code>target == expressions[0] * .. * expressions[n]</code>.</p>
</div>


                            </div>
                            <div id="CpModel.NewIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewIntervalVar</span><span class="signature">(self, start, size, end, name)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, size, and end.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Internally, it ensures that `start + size == end`.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      end: The end of the interval. It can be an affine or constant expression.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>

        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: size must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: end must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval variable from start, size, and end.</p>

<p>An interval variable is a constraint, that is itself used in other
constraints like NoOverlap.</p>

<p>Internally, it ensures that <code>start + size == end</code>.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start:</strong>  The start of the interval. It can be an affine or constant
expression.</li>
<li><strong>size:</strong>  The size of the interval. It can be an affine or constant
expression.</li>
<li><strong>end:</strong>  The end of the interval. It can be an affine or constant expression.</li>
<li><strong>name:</strong>  The name of the interval variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An <code><a href="#IntervalVar">IntervalVar</a></code> object.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.NewFixedSizeIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewFixedSizeIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewFixedSizeIntervalVar</span><span class="signature">(self, start, size, name)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewFixedSizeIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, and a fixed size.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It must be an integer value.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval variable from start, and a fixed size.</p>

<p>An interval variable is a constraint, that is itself used in other
constraints like NoOverlap.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start:</strong>  The start of the interval. It can be an affine or constant
expression.</li>
<li><strong>size:</strong>  The size of the interval. It must be an integer value.</li>
<li><strong>name:</strong>  The name of the interval variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An <code><a href="#IntervalVar">IntervalVar</a></code> object.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.NewOptionalIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewOptionalIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewOptionalIntervalVar</span><span class="signature">(self, start, size, end, is_present, name)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewOptionalIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_present</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an optional interval var from start, size, end, and is_present.</span>

<span class="sd">    An optional interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap. This constraint is protected by an is_present</span>
<span class="sd">    literal that indicates if it is active or not.</span>

<span class="sd">    Internally, it ensures that `is_present` implies `start + size == end`.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an integer value, or an</span>
<span class="sd">        integer variable.</span>
<span class="sd">      size: The size of the interval. It can be an integer value, or an integer</span>
<span class="sd">        variable.</span>
<span class="sd">      end: The end of the interval. It can be an integer value, or an integer</span>
<span class="sd">        variable.</span>
<span class="sd">      is_present: A literal that indicates if the interval is active or not. A</span>
<span class="sd">        inactive interval is simply ignored by all constraints.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="c1"># Add the linear constraint.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">OnlyEnforceIf</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>

        <span class="c1"># Creates the IntervalConstraintProto object.</span>
        <span class="n">is_present_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: size must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: end must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span>
                           <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an optional interval var from start, size, end, and is_present.</p>

<p>An optional interval variable is a constraint, that is itself used in other
constraints like NoOverlap. This constraint is protected by an is_present
literal that indicates if it is active or not.</p>

<p>Internally, it ensures that <code>is_present</code> implies <code>start + size == end</code>.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start:</strong>  The start of the interval. It can be an integer value, or an
integer variable.</li>
<li><strong>size:</strong>  The size of the interval. It can be an integer value, or an integer
variable.</li>
<li><strong>end:</strong>  The end of the interval. It can be an integer value, or an integer
variable.</li>
<li><strong>is_present:</strong>  A literal that indicates if the interval is active or not. A
inactive interval is simply ignored by all constraints.</li>
<li><strong>name:</strong>  The name of the interval variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An <code><a href="#IntervalVar">IntervalVar</a></code> object.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.NewOptionalFixedSizeIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.NewOptionalFixedSizeIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewOptionalFixedSizeIntervalVar</span><span class="signature">(self, start, size, is_present, name)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewOptionalFixedSizeIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">is_present</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an interval variable from start, and a fixed size.</span>

<span class="sd">    An interval variable is a constraint, that is itself used in other</span>
<span class="sd">    constraints like NoOverlap.</span>

<span class="sd">    Args:</span>
<span class="sd">      start: The start of the interval. It can be an affine or constant</span>
<span class="sd">        expression.</span>
<span class="sd">      size: The size of the interval. It must be an integer value.</span>
<span class="sd">      is_present: A literal that indicates if the interval is active or not. A</span>
<span class="sd">        inactive interval is simply ignored by all constraints.</span>
<span class="sd">      name: The name of the interval variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An `IntervalVar` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">start_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">size_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">end_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_expr</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;cp_model.NewIntervalVar: start must be affine or constant.&#39;</span><span class="p">)</span>
        <span class="n">is_present_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">is_present</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">start_expr</span><span class="p">,</span> <span class="n">size_expr</span><span class="p">,</span> <span class="n">end_expr</span><span class="p">,</span>
                           <span class="n">is_present_index</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval variable from start, and a fixed size.</p>

<p>An interval variable is a constraint, that is itself used in other
constraints like NoOverlap.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>start:</strong>  The start of the interval. It can be an affine or constant
expression.</li>
<li><strong>size:</strong>  The size of the interval. It must be an integer value.</li>
<li><strong>is_present:</strong>  A literal that indicates if the interval is active or not. A
inactive interval is simply ignored by all constraints.</li>
<li><strong>name:</strong>  The name of the interval variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An <code><a href="#IntervalVar">IntervalVar</a></code> object.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.AddNoOverlap" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddNoOverlap">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddNoOverlap</span><span class="signature">(self, interval_vars)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddNoOverlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_vars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds NoOverlap(interval_vars).</span>

<span class="sd">    A NoOverlap constraint ensures that all present intervals do not overlap</span>
<span class="sd">    in time.</span>

<span class="sd">    Args:</span>
<span class="sd">      interval_vars: The list of interval variables to constrain.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">interval_vars</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds NoOverlap(interval_vars).</p>

<p>A NoOverlap constraint ensures that all present intervals do not overlap
in time.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>interval_vars:</strong>  The list of interval variables to constrain.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.AddNoOverlap2D" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddNoOverlap2D">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddNoOverlap2D</span><span class="signature">(self, x_intervals, y_intervals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddNoOverlap2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_intervals</span><span class="p">,</span> <span class="n">y_intervals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds NoOverlap2D(x_intervals, y_intervals).</span>

<span class="sd">    A NoOverlap2D constraint ensures that all present rectangles do not overlap</span>
<span class="sd">    on a plane. Each rectangle is aligned with the X and Y axis, and is defined</span>
<span class="sd">    by two intervals which represent its projection onto the X and Y axis.</span>

<span class="sd">    Furthermore, one box is optional if at least one of the x or y interval is</span>
<span class="sd">    optional.</span>

<span class="sd">    Args:</span>
<span class="sd">      x_intervals: The X coordinates of the rectangles.</span>
<span class="sd">      y_intervals: The Y coordinates of the rectangles.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap_2d</span><span class="o">.</span><span class="n">x_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_intervals</span><span class="p">])</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">no_overlap_2d</span><span class="o">.</span><span class="n">y_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y_intervals</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds NoOverlap2D(x_intervals, y_intervals).</p>

<p>A NoOverlap2D constraint ensures that all present rectangles do not overlap
on a plane. Each rectangle is aligned with the X and Y axis, and is defined
by two intervals which represent its projection onto the X and Y axis.</p>

<p>Furthermore, one box is optional if at least one of the x or y interval is
optional.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>x_intervals:</strong>  The X coordinates of the rectangles.</li>
<li><strong>y_intervals:</strong>  The Y coordinates of the rectangles.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.AddCumulative" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddCumulative">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddCumulative</span><span class="signature">(self, intervals, demands, capacity)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddCumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">demands</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds Cumulative(intervals, demands, capacity).</span>

<span class="sd">    This constraint enforces that:</span>

<span class="sd">        for all t:</span>
<span class="sd">          sum(demands[i]</span>
<span class="sd">            if (start(intervals[i]) &lt;= t &lt; end(intervals[i])) and</span>
<span class="sd">            (intervals[i] is present)) &lt;= capacity</span>

<span class="sd">    Args:</span>
<span class="sd">      intervals: The list of intervals.</span>
<span class="sd">      demands: The list of demands for each interval. Each demand must be &gt;= 0.</span>
<span class="sd">        Each demand can be an integer value, or an integer variable.</span>
<span class="sd">      capacity: The maximum capacity of the cumulative constraint. It must be a</span>
<span class="sd">        positive integer value or variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">      An instance of the `Constraint` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">model_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">ct</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GetIntervalIndex</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">demands</span><span class="p">:</span>
            <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">demands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="n">model_ct</span><span class="o">.</span><span class="n">cumulative</span><span class="o">.</span><span class="n">capacity</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ParseLinearExpression</span><span class="p">(</span><span class="n">capacity</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ct</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds Cumulative(intervals, demands, capacity).</p>

<h6 id="this-constraint-enforces-that">This constraint enforces that</h6>

<blockquote>
  <p>for all t:
    sum(demands[i]
      if (start(intervals[i]) &lt;= t &lt; end(intervals[i])) and
      (intervals[i] is present)) &lt;= capacity</p>
</blockquote>

<h6 id="args">Args</h6>

<ul>
<li><strong>intervals:</strong>  The list of intervals.</li>
<li><strong>demands:</strong>  The list of demands for each interval. Each demand must be &gt;= 0.
Each demand can be an integer value, or an integer variable.</li>
<li><strong>capacity:</strong>  The maximum capacity of the cumulative constraint. It must be a
positive integer value or variable.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An instance of the <code><a href="#Constraint">Constraint</a></code> class.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.CopyFrom" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.CopyFrom">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CopyFrom</span><span class="signature">(self, other_model)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CopyFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the model, and creates a new one from a CpModelProto instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">other_model</span><span class="o">.</span><span class="n">Proto</span><span class="p">())</span>

        <span class="c1"># Rebuild constant map.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reset the model, and creates a new one from a CpModelProto instance.</p>
</div>


                            </div>
                            <div id="CpModel.GetBoolVarFromProtoIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.GetBoolVarFromProtoIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetBoolVarFromProtoIndex</span><span class="signature">(self, index)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetBoolVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created Boolean variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetBoolVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetBoolVarFromProtoIndex: index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> does not reference&#39;</span> <span class="o">+</span>
                <span class="s1">&#39; a Boolean variable&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an already created Boolean variable from its index.</p>
</div>


                            </div>
                            <div id="CpModel.GetIntVarFromProtoIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.GetIntVarFromProtoIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetIntVarFromProtoIndex</span><span class="signature">(self, index)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetIntVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created integer variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an already created integer variable from its index.</p>
</div>


                            </div>
                            <div id="CpModel.GetIntervalVarFromProtoIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.GetIntervalVarFromProtoIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetIntervalVarFromProtoIndex</span><span class="signature">(self, index)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetIntervalVarFromProtoIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an already created interval variable from its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntervalVarFromProtoIndex: out of bound index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ct</span><span class="o">.</span><span class="n">HasField</span><span class="p">(</span><span class="s1">&#39;interval&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;GetIntervalVarFromProtoIndex: index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1"> does not reference an&#39;</span>
                <span class="o">+</span> <span class="s1">&#39; interval variable&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an already created interval variable from its index.</p>
</div>


                            </div>
                            <div id="CpModel.Proto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.Proto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Proto</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Proto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the underlying CpModelProto.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the underlying CpModelProto.</p>
</div>


                            </div>
                            <div id="CpModel.Negated" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.Negated">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Negated</span><span class="signature">(self, index)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Negated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpModel.GetOrMakeIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.GetOrMakeIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetOrMakeIndex</span><span class="signature">(self, arg)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetOrMakeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of a variable, its negation, or a number.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">)</span> <span class="ow">and</span>
              <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">arg</span><span class="o">.</span><span class="n">Expression</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetOrMakeIndex(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39;)&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index of a variable, its negation, or a number.</p>
</div>


                            </div>
                            <div id="CpModel.GetOrMakeBooleanIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.GetOrMakeBooleanIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetOrMakeBooleanIndex</span><span class="signature">(self, arg)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an index from a boolean expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AssertIsBooleanVariable</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AssertIsBooleanVariable</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">Not</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_boolean</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetOrMakeBooleanIndex(&#39;</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an index from a boolean expression.</p>
</div>


                            </div>
                            <div id="CpModel.GetIntervalIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.GetIntervalIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetIntervalIndex</span><span class="signature">(self, arg)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetIntervalIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IntervalVar</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NotSupported: model.GetIntervalIndex(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpModel.GetOrMakeIndexFromConstant" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.GetOrMakeIndexFromConstant">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetOrMakeIndexFromConstant</span><span class="signature">(self, value)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetOrMakeIndexFromConstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">index</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpModel.VarIndexToVarProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.VarIndexToVarProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VarIndexToVarProto</span><span class="signature">(self, var_index)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VarIndexToVarProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">var_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="o">-</span><span class="n">var_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpModel.ParseLinearExpression" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.ParseLinearExpression">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ParseLinearExpression</span><span class="signature">(self, linear_expr, negate=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ParseLinearExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_expr</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a LinearExpressionProto built from a LinearExpr instance.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">LinearExpressionProto</span><span class="p">()</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">negate</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">mult</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">coeffs_map</span><span class="p">,</span> <span class="n">constant</span> <span class="o">=</span> <span class="n">linear_expr</span><span class="o">.</span><span class="n">GetIntegerVarValueMap</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">constant</span> <span class="o">*</span> <span class="n">mult</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">coeffs_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Wrong argument&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">cmh</span><span class="o">.</span><span class="n">assert_is_int64</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">result</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
            <span class="n">result</span><span class="o">.</span><span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">mult</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a LinearExpressionProto built from a LinearExpr instance.</p>
</div>


                            </div>
                            <div id="CpModel.Minimize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.Minimize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Minimize</span><span class="signature">(self, obj)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model to minimize(obj).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetObjective</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the objective of the model to minimize(obj).</p>
</div>


                            </div>
                            <div id="CpModel.Maximize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.Maximize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Maximize</span><span class="signature">(self, obj)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the objective of the model to maximize(obj).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetObjective</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the objective of the model to maximize(obj).</p>
</div>


                            </div>
                            <div id="CpModel.HasObjective" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.HasObjective">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasObjective</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">HasField</span><span class="p">(</span><span class="s1">&#39;objective&#39;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpModel.AddDecisionStrategy" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddDecisionStrategy">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddDecisionStrategy</span><span class="signature">(self, variables, var_strategy, domain_strategy)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddDecisionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">var_strategy</span><span class="p">,</span> <span class="n">domain_strategy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a search strategy to the model.</span>

<span class="sd">    Args:</span>
<span class="sd">      variables: a list of variables this strategy will assign.</span>
<span class="sd">      var_strategy: heuristic to choose the next variable to assign.</span>
<span class="sd">      domain_strategy: heuristic to reduce the domain of the selected variable.</span>
<span class="sd">        Currently, this is advanced code: the union of all strategies added to</span>
<span class="sd">          the model must be complete, i.e. instantiates all variables.</span>
<span class="sd">          Otherwise, Solve() will fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="n">strategy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">search_strategy</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">strategy</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
        <span class="n">strategy</span><span class="o">.</span><span class="n">variable_selection_strategy</span> <span class="o">=</span> <span class="n">var_strategy</span>
        <span class="n">strategy</span><span class="o">.</span><span class="n">domain_reduction_strategy</span> <span class="o">=</span> <span class="n">domain_strategy</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a search strategy to the model.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>variables:</strong>  a list of variables this strategy will assign.</li>
<li><strong>var_strategy:</strong>  heuristic to choose the next variable to assign.</li>
<li><strong>domain_strategy:</strong>  heuristic to reduce the domain of the selected variable.
Currently, this is advanced code: the union of all strategies added to
 the model must be complete, i.e. instantiates all variables.
 Otherwise, Solve() will fail.</li>
</ul>
</div>


                            </div>
                            <div id="CpModel.ModelStats" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.ModelStats">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ModelStats</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ModelStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string containing some model statistics.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedModelStats</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a string containing some model statistics.</p>
</div>


                            </div>
                            <div id="CpModel.Validate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.Validate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Validate</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string indicating that the model is invalid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedValidateModel</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a string indicating that the model is invalid.</p>
</div>


                            </div>
                            <div id="CpModel.ExportToFile" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.ExportToFile">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExportToFile</span><span class="signature">(self, file)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ExportToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the model as a protocol buffer to &#39;file&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">      file: file to write the model to. If the filename ends with &#39;txt&#39;, the</span>
<span class="sd">        model will be written as a text file, otherwise, the binary format will</span>
<span class="sd">        be used.</span>

<span class="sd">    Returns:</span>
<span class="sd">      True if the model was correctly written.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedWriteModelToFile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">file</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Write the model as a protocol buffer to 'file'.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>file:</strong>  file to write the model to. If the filename ends with 'txt', the
model will be written as a text file, otherwise, the binary format will
be used.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>True if the model was correctly written.</p>
</blockquote>
</div>


                            </div>
                            <div id="CpModel.AssertIsBooleanVariable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AssertIsBooleanVariable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AssertIsBooleanVariable</span><span class="signature">(self, x)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AssertIsBooleanVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s1">&#39; is not a boolean variable&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39; is not a boolean variable&#39;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpModel.AddHint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddHint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddHint</span><span class="signature">(self, var, value)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds &#39;var == value&#39; as a hint to the solver.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">solution_hint</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeIndex</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">solution_hint</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds 'var == value' as a hint to the solver.</p>
</div>


                            </div>
                            <div id="CpModel.ClearHints" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.ClearHints">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ClearHints</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ClearHints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove any solution hint from the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;solution_hint&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove any solution hint from the model.</p>
</div>


                            </div>
                            <div id="CpModel.AddAssumption" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAssumption">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAssumption</span><span class="signature">(self, lit)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAssumption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the literal &#39;lit&#39; to the model as assumptions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">assumptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetOrMakeBooleanIndex</span><span class="p">(</span><span class="n">lit</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Add the literal 'lit' to the model as assumptions.</p>
</div>


                            </div>
                            <div id="CpModel.AddAssumptions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.AddAssumptions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAssumptions</span><span class="signature">(self, literals)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAssumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the literals to the model as assumptions.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AddAssumption</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Add the literals to the model as assumptions.</p>
</div>


                            </div>
                            <div id="CpModel.ClearAssumptions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpModel.ClearAssumptions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ClearAssumptions</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ClearAssumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all assumptions from the model.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span><span class="o">.</span><span class="n">ClearField</span><span class="p">(</span><span class="s1">&#39;assumptions&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Remove all assumptions from the model.</p>
</div>


                            </div>
                </section>
                <section id="ExpandGeneratorOrTuple">
                            <div class="attr function"><a class="headerlink" href="#ExpandGeneratorOrTuple">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExpandGeneratorOrTuple</span><span class="signature">(args)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ExpandGeneratorOrTuple</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>  <span class="c1"># Tuple</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_a_number</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LinearExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">args</span>
    <span class="c1"># Generator</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

        </details>

    

                </section>
                <section id="EvaluateLinearExpr">
                            <div class="attr function"><a class="headerlink" href="#EvaluateLinearExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EvaluateLinearExpr</span><span class="signature">(expression, solution)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">EvaluateLinearExpr</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate a linear expression against a solution.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">LinearExpr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot interpret </span><span class="si">%s</span><span class="s1"> as a linear expression.&#39;</span> <span class="o">%</span>
                        <span class="n">expression</span><span class="p">)</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="n">expression</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
            <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Index</span><span class="p">()]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s1"> as a linear expression.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>
</pre></div>

        </details>

            <div class="docstring"><p>Evaluate a linear expression against a solution.</p>
</div>


                </section>
                <section id="EvaluateBooleanExpression">
                            <div class="attr function"><a class="headerlink" href="#EvaluateBooleanExpression">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EvaluateBooleanExpression</span><span class="signature">(literal, solution)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">EvaluateBooleanExpression</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate a boolean expression against a solution.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">literal</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span>
                                                   <span class="n">_NotBooleanVariable</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">literal</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">solution</span><span class="o">.</span><span class="n">solution</span><span class="p">[</span><span class="o">-</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">literal</span><span class="si">}</span><span class="s1"> as a boolean expression.&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Evaluate a boolean expression against a solution.</p>
</div>


                </section>
                <section id="CpSolver">
                                <div class="attr class">
        <a class="headerlink" href="#CpSolver">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">CpSolver</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CpSolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main solver class.</span>

<span class="sd">  The purpose of this class is to search for a solution to the model provided</span>
<span class="sd">  to the Solve() method.</span>

<span class="sd">  Once Solve() is called, this class allows inspecting the solution found</span>
<span class="sd">  with the Value() and BooleanValue() methods, as well as general statistics</span>
<span class="sd">  about the solve procedure.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">sat_parameters_pb2</span><span class="o">.</span><span class="n">SatParameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="p">:</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">solution_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves a problem and passes each solution to the callback if not null.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="n">solve_wrapper</span> <span class="o">=</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="p">()</span>

        <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="o">.</span><span class="n">SetSerializedParameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">solve_wrapper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solution_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">AddSolutionCallback</span><span class="p">(</span><span class="n">solution_callback</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">AddLogCallback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span><span class="o">.</span><span class="n">FromString</span><span class="p">(</span>
            <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="o">.</span><span class="n">SerializedSolve</span><span class="p">(</span>
                <span class="n">model</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">solve_wrapper</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">solution_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">ClearSolutionCallback</span><span class="p">(</span><span class="n">solution_callback</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>

    <span class="k">def</span> <span class="nf">SolveWithSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED Use Solve() with the callback argument.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;SolveWithSolutionCallback is deprecated; use Solve() with&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;the callback argument.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchForAllSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED Use Solve() with the right parameter.</span>

<span class="sd">    Search for all solutions of a satisfiability problem.</span>

<span class="sd">    This method searches for all feasible solutions of a given model.</span>
<span class="sd">    Then it feeds the solution to the callback.</span>

<span class="sd">    Note that the model cannot contain an objective.</span>

<span class="sd">    Args:</span>
<span class="sd">      model: The model to solve.</span>
<span class="sd">      callback: The callback that will be called at each solution.</span>

<span class="sd">    Returns:</span>
<span class="sd">      The status of the solve:</span>

<span class="sd">      * *FEASIBLE* if some solutions have been found</span>
<span class="sd">      * *INFEASIBLE* if the solver has proved there are no solution</span>
<span class="sd">      * *OPTIMAL* if all solutions have been found</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;SearchForAllSolutions is deprecated; use Solve() with&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;enumerate_all_solutions = True.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">HasObjective</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Search for all solutions is only defined on &#39;</span>
                            <span class="s1">&#39;satisfiability problems&#39;</span><span class="p">)</span>
        <span class="c1"># Store old parameter.</span>
        <span class="n">enumerate_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

        <span class="c1"># Restore parameter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span> <span class="o">=</span> <span class="n">enumerate_all</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>

    <span class="k">def</span> <span class="nf">StopSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stops the current search asynchronously.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="o">.</span><span class="n">StopSearch</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of a linear expression after solve.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EvaluateLinearExpr</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BooleanValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the boolean value of a literal after solve.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EvaluateBooleanExpression</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of the objective after solve.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">objective_value</span>

    <span class="k">def</span> <span class="nf">BestObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the best lower (upper) bound found when min(max)imizing.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">best_objective_bound</span>

    <span class="k">def</span> <span class="nf">StatusName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the name of the status returned by Solve().&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>
        <span class="k">return</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverStatus</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumBooleans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of boolean variables managed by the SAT solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_booleans</span>

    <span class="k">def</span> <span class="nf">NumConflicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of conflicts since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_conflicts</span>

    <span class="k">def</span> <span class="nf">NumBranches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of search branches explored by the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_branches</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the wall time in seconds since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">wall_time</span>

    <span class="k">def</span> <span class="nf">UserTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the user time in seconds since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">user_time</span>

    <span class="k">def</span> <span class="nf">ResponseStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns some statistics on the solution found as a string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedSolverResponseStats</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">ResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the response object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span>

    <span class="k">def</span> <span class="nf">SufficientAssumptionsForInfeasibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the indices of the infeasible assumptions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">sufficient_assumptions_for_infeasibility</span>

    <span class="k">def</span> <span class="nf">SolutionInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns some information on the solve process.</span>

<span class="sd">    Returns some information on how the solution was found, or the reason</span>
<span class="sd">    why the model or the parameters are invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">solution_info</span>
</pre></div>

        </details>

            <div class="docstring"><p>Main solver class.</p>

<p>The purpose of this class is to search for a solution to the model provided
to the Solve() method.</p>

<p>Once Solve() is called, this class allows inspecting the solution found
with the Value() and BooleanValue() methods, as well as general statistics
about the solve procedure.</p>
</div>


                            <div id="CpSolver.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">CpSolver</span><span class="signature">()</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">sat_parameters_pb2</span><span class="o">.</span><span class="n">SatParameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="p">:</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="CpSolver.Solve" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.Solve">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solve</span><span class="signature">(self, model, solution_callback=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">solution_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves a problem and passes each solution to the callback if not null.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="n">solve_wrapper</span> <span class="o">=</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="p">()</span>

        <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="o">.</span><span class="n">SetSerializedParameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">solve_wrapper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solution_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">AddSolutionCallback</span><span class="p">(</span><span class="n">solution_callback</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">AddLogCallback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_callback</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span> <span class="o">=</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span><span class="o">.</span><span class="n">FromString</span><span class="p">(</span>
            <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolveWrapper</span><span class="o">.</span><span class="n">SerializedSolve</span><span class="p">(</span>
                <span class="n">model</span><span class="o">.</span><span class="n">Proto</span><span class="p">()</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">(),</span> <span class="n">solve_wrapper</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">solution_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">solve_wrapper</span><span class="o">.</span><span class="n">ClearSolutionCallback</span><span class="p">(</span><span class="n">solution_callback</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>
</pre></div>

        </details>

            <div class="docstring"><p>Solves a problem and passes each solution to the callback if not null.</p>
</div>


                            </div>
                            <div id="CpSolver.SolveWithSolutionCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.SolveWithSolutionCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveWithSolutionCallback</span><span class="signature">(self, model, callback)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolveWithSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED Use Solve() with the callback argument.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;SolveWithSolutionCallback is deprecated; use Solve() with&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;the callback argument.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>DEPRECATED Use Solve() with the callback argument.</p>
</div>


                            </div>
                            <div id="CpSolver.SearchForAllSolutions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.SearchForAllSolutions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SearchForAllSolutions</span><span class="signature">(self, model, callback)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SearchForAllSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED Use Solve() with the right parameter.</span>

<span class="sd">    Search for all solutions of a satisfiability problem.</span>

<span class="sd">    This method searches for all feasible solutions of a given model.</span>
<span class="sd">    Then it feeds the solution to the callback.</span>

<span class="sd">    Note that the model cannot contain an objective.</span>

<span class="sd">    Args:</span>
<span class="sd">      model: The model to solve.</span>
<span class="sd">      callback: The callback that will be called at each solution.</span>

<span class="sd">    Returns:</span>
<span class="sd">      The status of the solve:</span>

<span class="sd">      * *FEASIBLE* if some solutions have been found</span>
<span class="sd">      * *INFEASIBLE* if the solver has proved there are no solution</span>
<span class="sd">      * *OPTIMAL* if all solutions have been found</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;SearchForAllSolutions is deprecated; use Solve() with&#39;</span> <span class="o">+</span>
            <span class="s1">&#39;enumerate_all_solutions = True.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">HasObjective</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Search for all solutions is only defined on &#39;</span>
                            <span class="s1">&#39;satisfiability problems&#39;</span><span class="p">)</span>
        <span class="c1"># Store old parameter.</span>
        <span class="n">enumerate_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

        <span class="c1"># Restore parameter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">enumerate_all_solutions</span> <span class="o">=</span> <span class="n">enumerate_all</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>
</pre></div>

        </details>

            <div class="docstring"><p>DEPRECATED Use Solve() with the right parameter.</p>

<p>Search for all solutions of a satisfiability problem.</p>

<p>This method searches for all feasible solutions of a given model.
Then it feeds the solution to the callback.</p>

<p>Note that the model cannot contain an objective.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>model:</strong>  The model to solve.</li>
<li><strong>callback:</strong>  The callback that will be called at each solution.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>The status of the solve:</p>
  
  <ul>
  <li><em>FEASIBLE</em> if some solutions have been found</li>
  <li><em>INFEASIBLE</em> if the solver has proved there are no solution</li>
  <li><em>OPTIMAL</em> if all solutions have been found</li>
  </ul>
</blockquote>
</div>


                            </div>
                            <div id="CpSolver.StopSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.StopSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StopSearch</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StopSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stops the current search asynchronously.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__solve_wrapper</span><span class="o">.</span><span class="n">StopSearch</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Stops the current search asynchronously.</p>
</div>


                            </div>
                            <div id="CpSolver.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self, expression)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of a linear expression after solve.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EvaluateLinearExpr</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the value of a linear expression after solve.</p>
</div>


                            </div>
                            <div id="CpSolver.BooleanValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.BooleanValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BooleanValue</span><span class="signature">(self, literal)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BooleanValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the boolean value of a literal after solve.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EvaluateBooleanExpression</span><span class="p">(</span><span class="n">literal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the boolean value of a literal after solve.</p>
</div>


                            </div>
                            <div id="CpSolver.ObjectiveValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.ObjectiveValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectiveValue</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of the objective after solve.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">objective_value</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the value of the objective after solve.</p>
</div>


                            </div>
                            <div id="CpSolver.BestObjectiveBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.BestObjectiveBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BestObjectiveBound</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BestObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the best lower (upper) bound found when min(max)imizing.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">best_objective_bound</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the best lower (upper) bound found when min(max)imizing.</p>
</div>


                            </div>
                            <div id="CpSolver.StatusName" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.StatusName">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StatusName</span><span class="signature">(self, status=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StatusName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the name of the status returned by Solve().&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">status</span>
        <span class="k">return</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverStatus</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the name of the status returned by Solve().</p>
</div>


                            </div>
                            <div id="CpSolver.NumBooleans" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.NumBooleans">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumBooleans</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumBooleans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of boolean variables managed by the SAT solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_booleans</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of boolean variables managed by the SAT solver.</p>
</div>


                            </div>
                            <div id="CpSolver.NumConflicts" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.NumConflicts">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumConflicts</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumConflicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of conflicts since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_conflicts</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of conflicts since the creation of the solver.</p>
</div>


                            </div>
                            <div id="CpSolver.NumBranches" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.NumBranches">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumBranches</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumBranches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of search branches explored by the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">num_branches</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of search branches explored by the solver.</p>
</div>


                            </div>
                            <div id="CpSolver.WallTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.WallTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WallTime</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the wall time in seconds since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">wall_time</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the wall time in seconds since the creation of the solver.</p>
</div>


                            </div>
                            <div id="CpSolver.UserTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.UserTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">UserTime</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">UserTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the user time in seconds since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">user_time</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the user time in seconds since the creation of the solver.</p>
</div>


                            </div>
                            <div id="CpSolver.ResponseStats" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.ResponseStats">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ResponseStats</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ResponseStats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns some statistics on the solution found as a string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">swig_helper</span><span class="o">.</span><span class="n">CpSatHelper</span><span class="o">.</span><span class="n">SerializedSolverResponseStats</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns some statistics on the solution found as a string.</p>
</div>


                            </div>
                            <div id="CpSolver.ResponseProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.ResponseProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ResponseProto</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the response object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the response object.</p>
</div>


                            </div>
                            <div id="CpSolver.SufficientAssumptionsForInfeasibility" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.SufficientAssumptionsForInfeasibility">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SufficientAssumptionsForInfeasibility</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SufficientAssumptionsForInfeasibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the indices of the infeasible assumptions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">sufficient_assumptions_for_infeasibility</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the indices of the infeasible assumptions.</p>
</div>


                            </div>
                            <div id="CpSolver.SolutionInfo" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolver.SolutionInfo">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolutionInfo</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolutionInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns some information on the solve process.</span>

<span class="sd">    Returns some information on how the solution was found, or the reason</span>
<span class="sd">    why the model or the parameters are invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution</span><span class="o">.</span><span class="n">solution_info</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns some information on the solve process.</p>

<p>Returns some information on how the solution was found, or the reason
why the model or the parameters are invalid.</p>
</div>


                            </div>
                </section>
                <section id="CpSolverSolutionCallback">
                                <div class="attr class">
        <a class="headerlink" href="#CpSolverSolutionCallback">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">CpSolverSolutionCallback</span><wbr>(<span class="base">ortools.sat.python.swig_helper.SolutionCallback</span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CpSolverSolutionCallback</span><span class="p">(</span><span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solution callback.</span>

<span class="sd">  This class implements a callback that will be called at each new solution</span>
<span class="sd">  found during search.</span>

<span class="sd">  The method OnSolutionCallback() will be called by the solver, and must be</span>
<span class="sd">  implemented. The current solution can be queried using the BooleanValue()</span>
<span class="sd">  and Value() methods.</span>

<span class="sd">  It inherits the following methods from its base class:</span>

<span class="sd">  * `ObjectiveValue(self)`</span>
<span class="sd">  * `BestObjectiveBound(self)`</span>
<span class="sd">  * `NumBooleans(self)`</span>
<span class="sd">  * `NumConflicts(self)`</span>
<span class="sd">  * `NumBranches(self)`</span>
<span class="sd">  * `WallTime(self)`</span>
<span class="sd">  * `UserTime(self)`</span>

<span class="sd">  These methods returns the same information as their counterpart in the</span>
<span class="sd">  `CpSolver` class.</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OnSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Proxy for the same method in snake case.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_solution_callback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">BooleanValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the boolean value of a boolean literal.</span>

<span class="sd">    Args:</span>
<span class="sd">        lit: A boolean variable or its negation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The Boolean value of the literal in the solution.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: if `lit` is not a boolean variable or its negation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasResponse</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">lit</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SolutionBooleanValue</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">lit</span><span class="si">}</span><span class="s1"> as a boolean expression.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates an linear expression in the current solution.</span>

<span class="sd">    Args:</span>
<span class="sd">        expression: a linear expression of the model.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An integer value equal to the evaluation of the linear expression</span>
<span class="sd">        against the current solution.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: if &#39;expression&#39; is not a LinearExpr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasResponse</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="n">expression</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                    <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SolutionIntegerValue</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">SolutionIntegerValue</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">expression</span><span class="si">}</span><span class="s1"> as a linear expression.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">Response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current solution response.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span><span class="o">.</span><span class="n">FromString</span><span class="p">(</span>
            <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="o">.</span><span class="n">SerializedResponse</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Solution callback.</p>

<p>This class implements a callback that will be called at each new solution
found during search.</p>

<p>The method OnSolutionCallback() will be called by the solver, and must be
implemented. The current solution can be queried using the BooleanValue()
and Value() methods.</p>

<p>It inherits the following methods from its base class:</p>

<ul>
<li><code>ObjectiveValue(self)</code></li>
<li><code>BestObjectiveBound(self)</code></li>
<li><code>NumBooleans(self)</code></li>
<li><code>NumConflicts(self)</code></li>
<li><code>NumBranches(self)</code></li>
<li><code>WallTime(self)</code></li>
<li><code>UserTime(self)</code></li>
</ul>

<p>These methods returns the same information as their counterpart in the
<code><a href="#CpSolver">CpSolver</a></code> class.</p>
</div>


                            <div id="CpSolverSolutionCallback.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolverSolutionCallback.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">CpSolverSolutionCallback</span><span class="signature">()</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>__init__(self: ortools.sat.python.swig_helper.SolutionCallback) -> None</p>
</div>


                            </div>
                            <div id="CpSolverSolutionCallback.OnSolutionCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolverSolutionCallback.OnSolutionCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OnSolutionCallback</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OnSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Proxy for the same method in snake case.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_solution_callback</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Proxy for the same method in snake case.</p>
</div>


                            </div>
                            <div id="CpSolverSolutionCallback.BooleanValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolverSolutionCallback.BooleanValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BooleanValue</span><span class="signature">(self, lit)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BooleanValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the boolean value of a boolean literal.</span>

<span class="sd">    Args:</span>
<span class="sd">        lit: A boolean variable or its negation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The Boolean value of the literal in the solution.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: if `lit` is not a boolean variable or its negation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasResponse</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">lit</span><span class="o">.</span><span class="n">Index</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SolutionBooleanValue</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">lit</span><span class="si">}</span><span class="s1"> as a boolean expression.&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the boolean value of a boolean literal.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>lit:</strong>  A boolean variable or its negation.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>The Boolean value of the literal in the solution.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>RuntimeError:</strong>  if <code>lit</code> is not a boolean variable or its negation.</li>
</ul>
</div>


                            </div>
                            <div id="CpSolverSolutionCallback.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolverSolutionCallback.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self, expression)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates an linear expression in the current solution.</span>

<span class="sd">    Args:</span>
<span class="sd">        expression: a linear expression of the model.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An integer value equal to the evaluation of the linear expression</span>
<span class="sd">        against the current solution.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: if &#39;expression&#39; is not a LinearExpr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasResponse</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Solve() has not be called.&#39;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="n">expression</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">to_process</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cmh</span><span class="o">.</span><span class="n">is_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_ProductCst</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">(),</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficient</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Left</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">Right</span><span class="p">(),</span> <span class="n">coeff</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_SumArray</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">():</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                    <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_WeightedSum</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Expressions</span><span class="p">(),</span> <span class="n">expr</span><span class="o">.</span><span class="n">Coefficients</span><span class="p">()):</span>
                    <span class="n">to_process</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntVar</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SolutionIntegerValue</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Index</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_NotBooleanVariable</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">SolutionIntegerValue</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Not</span><span class="p">()</span><span class="o">.</span><span class="n">Index</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Cannot interpret </span><span class="si">{</span><span class="n">expression</span><span class="si">}</span><span class="s1"> as a linear expression.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>
</pre></div>

        </details>

            <div class="docstring"><p>Evaluates an linear expression in the current solution.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>expression:</strong>  a linear expression of the model.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>An integer value equal to the evaluation of the linear expression
  against the current solution.</p>
</blockquote>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>RuntimeError:</strong>  if 'expression' is not a LinearExpr.</li>
</ul>
</div>


                            </div>
                            <div id="CpSolverSolutionCallback.Response" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#CpSolverSolutionCallback.Response">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Response</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current solution response.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cp_model_pb2</span><span class="o">.</span><span class="n">CpSolverResponse</span><span class="o">.</span><span class="n">FromString</span><span class="p">(</span>
            <span class="n">swig_helper</span><span class="o">.</span><span class="n">SolutionCallback</span><span class="o">.</span><span class="n">SerializedResponse</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the current solution response.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt>ortools.sat.python.swig_helper.SolutionCallback</dt>
                                <dd id="CpSolverSolutionCallback.BestObjectiveBound" class="function">BestObjectiveBound</dd>
                <dd id="CpSolverSolutionCallback.DeterministicTime" class="function">DeterministicTime</dd>
                <dd id="CpSolverSolutionCallback.HasResponse" class="function">HasResponse</dd>
                <dd id="CpSolverSolutionCallback.NumBinaryPropagations" class="function">NumBinaryPropagations</dd>
                <dd id="CpSolverSolutionCallback.NumBooleans" class="function">NumBooleans</dd>
                <dd id="CpSolverSolutionCallback.NumBranches" class="function">NumBranches</dd>
                <dd id="CpSolverSolutionCallback.NumConflicts" class="function">NumConflicts</dd>
                <dd id="CpSolverSolutionCallback.NumIntegerPropagations" class="function">NumIntegerPropagations</dd>
                <dd id="CpSolverSolutionCallback.ObjectiveValue" class="function">ObjectiveValue</dd>
                <dd id="CpSolverSolutionCallback.SerializedResponse" class="function">SerializedResponse</dd>
                <dd id="CpSolverSolutionCallback.SolutionBooleanValue" class="function">SolutionBooleanValue</dd>
                <dd id="CpSolverSolutionCallback.SolutionIntegerValue" class="function">SolutionIntegerValue</dd>
                <dd id="CpSolverSolutionCallback.StopSearch" class="function">StopSearch</dd>
                <dd id="CpSolverSolutionCallback.UserTime" class="function">UserTime</dd>
                <dd id="CpSolverSolutionCallback.WallTime" class="function">WallTime</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="ObjectiveSolutionPrinter">
                                <div class="attr class">
        <a class="headerlink" href="#ObjectiveSolutionPrinter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ObjectiveSolutionPrinter</span><wbr>(<span class="base"><a href="#CpSolverSolutionCallback">CpSolverSolutionCallback</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ObjectiveSolutionPrinter</span><span class="p">(</span><span class="n">CpSolverSolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Display the objective value and time of intermediate solutions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ObjectiveValue</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s, objective = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Display the objective value and time of intermediate solutions.</p>
</div>


                            <div id="ObjectiveSolutionPrinter.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ObjectiveSolutionPrinter.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ObjectiveSolutionPrinter</span><span class="signature">()</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>__init__(self: ortools.sat.python.swig_helper.SolutionCallback) -> None</p>
</div>


                            </div>
                            <div id="ObjectiveSolutionPrinter.on_solution_callback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ObjectiveSolutionPrinter.on_solution_callback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">on_solution_callback</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ObjectiveValue</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s, objective = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

        </details>

            <div class="docstring"><p>Called on each new solution.</p>
</div>


                            </div>
                            <div id="ObjectiveSolutionPrinter.solution_count" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ObjectiveSolutionPrinter.solution_count">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">solution_count</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of solutions found.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#CpSolverSolutionCallback">CpSolverSolutionCallback</a></dt>
                                <dd id="ObjectiveSolutionPrinter.OnSolutionCallback" class="function"><a href="#CpSolverSolutionCallback.OnSolutionCallback">OnSolutionCallback</a></dd>
                <dd id="ObjectiveSolutionPrinter.BooleanValue" class="function"><a href="#CpSolverSolutionCallback.BooleanValue">BooleanValue</a></dd>
                <dd id="ObjectiveSolutionPrinter.Value" class="function"><a href="#CpSolverSolutionCallback.Value">Value</a></dd>
                <dd id="ObjectiveSolutionPrinter.Response" class="function"><a href="#CpSolverSolutionCallback.Response">Response</a></dd>

            </div>
            <div><dt>ortools.sat.python.swig_helper.SolutionCallback</dt>
                                <dd id="ObjectiveSolutionPrinter.BestObjectiveBound" class="function">BestObjectiveBound</dd>
                <dd id="ObjectiveSolutionPrinter.DeterministicTime" class="function">DeterministicTime</dd>
                <dd id="ObjectiveSolutionPrinter.HasResponse" class="function">HasResponse</dd>
                <dd id="ObjectiveSolutionPrinter.NumBinaryPropagations" class="function">NumBinaryPropagations</dd>
                <dd id="ObjectiveSolutionPrinter.NumBooleans" class="function">NumBooleans</dd>
                <dd id="ObjectiveSolutionPrinter.NumBranches" class="function">NumBranches</dd>
                <dd id="ObjectiveSolutionPrinter.NumConflicts" class="function">NumConflicts</dd>
                <dd id="ObjectiveSolutionPrinter.NumIntegerPropagations" class="function">NumIntegerPropagations</dd>
                <dd id="ObjectiveSolutionPrinter.ObjectiveValue" class="function">ObjectiveValue</dd>
                <dd id="ObjectiveSolutionPrinter.SerializedResponse" class="function">SerializedResponse</dd>
                <dd id="ObjectiveSolutionPrinter.SolutionBooleanValue" class="function">SolutionBooleanValue</dd>
                <dd id="ObjectiveSolutionPrinter.SolutionIntegerValue" class="function">SolutionIntegerValue</dd>
                <dd id="ObjectiveSolutionPrinter.StopSearch" class="function">StopSearch</dd>
                <dd id="ObjectiveSolutionPrinter.UserTime" class="function">UserTime</dd>
                <dd id="ObjectiveSolutionPrinter.WallTime" class="function">WallTime</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="VarArrayAndObjectiveSolutionPrinter">
                                <div class="attr class">
        <a class="headerlink" href="#VarArrayAndObjectiveSolutionPrinter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">VarArrayAndObjectiveSolutionPrinter</span><wbr>(<span class="base"><a href="#CpSolverSolutionCallback">CpSolverSolutionCallback</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VarArrayAndObjectiveSolutionPrinter</span><span class="p">(</span><span class="n">CpSolverSolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print intermediate solutions (objective, variable values, time).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ObjectiveValue</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s, objective = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Print intermediate solutions (objective, variable values, time).</p>
</div>


                            <div id="VarArrayAndObjectiveSolutionPrinter.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VarArrayAndObjectiveSolutionPrinter.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">VarArrayAndObjectiveSolutionPrinter</span><span class="signature">(variables)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>__init__(self: ortools.sat.python.swig_helper.SolutionCallback) -> None</p>
</div>


                            </div>
                            <div id="VarArrayAndObjectiveSolutionPrinter.on_solution_callback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VarArrayAndObjectiveSolutionPrinter.on_solution_callback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">on_solution_callback</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ObjectiveValue</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s, objective = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

        </details>

            <div class="docstring"><p>Called on each new solution.</p>
</div>


                            </div>
                            <div id="VarArrayAndObjectiveSolutionPrinter.solution_count" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VarArrayAndObjectiveSolutionPrinter.solution_count">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">solution_count</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of solutions found.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#CpSolverSolutionCallback">CpSolverSolutionCallback</a></dt>
                                <dd id="VarArrayAndObjectiveSolutionPrinter.OnSolutionCallback" class="function"><a href="#CpSolverSolutionCallback.OnSolutionCallback">OnSolutionCallback</a></dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.BooleanValue" class="function"><a href="#CpSolverSolutionCallback.BooleanValue">BooleanValue</a></dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.Value" class="function"><a href="#CpSolverSolutionCallback.Value">Value</a></dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.Response" class="function"><a href="#CpSolverSolutionCallback.Response">Response</a></dd>

            </div>
            <div><dt>ortools.sat.python.swig_helper.SolutionCallback</dt>
                                <dd id="VarArrayAndObjectiveSolutionPrinter.BestObjectiveBound" class="function">BestObjectiveBound</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.DeterministicTime" class="function">DeterministicTime</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.HasResponse" class="function">HasResponse</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.NumBinaryPropagations" class="function">NumBinaryPropagations</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.NumBooleans" class="function">NumBooleans</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.NumBranches" class="function">NumBranches</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.NumConflicts" class="function">NumConflicts</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.NumIntegerPropagations" class="function">NumIntegerPropagations</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.ObjectiveValue" class="function">ObjectiveValue</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.SerializedResponse" class="function">SerializedResponse</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.SolutionBooleanValue" class="function">SolutionBooleanValue</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.SolutionIntegerValue" class="function">SolutionIntegerValue</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.StopSearch" class="function">StopSearch</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.UserTime" class="function">UserTime</dd>
                <dd id="VarArrayAndObjectiveSolutionPrinter.WallTime" class="function">WallTime</dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="VarArraySolutionPrinter">
                                <div class="attr class">
        <a class="headerlink" href="#VarArraySolutionPrinter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">VarArraySolutionPrinter</span><wbr>(<span class="base"><a href="#CpSolverSolutionCallback">CpSolverSolutionCallback</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VarArraySolutionPrinter</span><span class="p">(</span><span class="n">CpSolverSolutionCallback</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print intermediate solutions (variable values, time).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Print intermediate solutions (variable values, time).</p>
</div>


                            <div id="VarArraySolutionPrinter.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VarArraySolutionPrinter.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">VarArraySolutionPrinter</span><span class="signature">(variables)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="n">CpSolverSolutionCallback</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>__init__(self: ortools.sat.python.swig_helper.SolutionCallback) -> None</p>
</div>


                            </div>
                            <div id="VarArraySolutionPrinter.on_solution_callback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VarArraySolutionPrinter.on_solution_callback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">on_solution_callback</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">on_solution_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called on each new solution.&quot;&quot;&quot;</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solution </span><span class="si">%i</span><span class="s1">, time = </span><span class="si">%0.2f</span><span class="s1"> s&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__start_time</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__variables</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

        </details>

            <div class="docstring"><p>Called on each new solution.</p>
</div>


                            </div>
                            <div id="VarArraySolutionPrinter.solution_count" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VarArraySolutionPrinter.solution_count">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">solution_count</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">solution_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of solutions found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__solution_count</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of solutions found.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#CpSolverSolutionCallback">CpSolverSolutionCallback</a></dt>
                                <dd id="VarArraySolutionPrinter.OnSolutionCallback" class="function"><a href="#CpSolverSolutionCallback.OnSolutionCallback">OnSolutionCallback</a></dd>
                <dd id="VarArraySolutionPrinter.BooleanValue" class="function"><a href="#CpSolverSolutionCallback.BooleanValue">BooleanValue</a></dd>
                <dd id="VarArraySolutionPrinter.Value" class="function"><a href="#CpSolverSolutionCallback.Value">Value</a></dd>
                <dd id="VarArraySolutionPrinter.Response" class="function"><a href="#CpSolverSolutionCallback.Response">Response</a></dd>

            </div>
            <div><dt>ortools.sat.python.swig_helper.SolutionCallback</dt>
                                <dd id="VarArraySolutionPrinter.BestObjectiveBound" class="function">BestObjectiveBound</dd>
                <dd id="VarArraySolutionPrinter.DeterministicTime" class="function">DeterministicTime</dd>
                <dd id="VarArraySolutionPrinter.HasResponse" class="function">HasResponse</dd>
                <dd id="VarArraySolutionPrinter.NumBinaryPropagations" class="function">NumBinaryPropagations</dd>
                <dd id="VarArraySolutionPrinter.NumBooleans" class="function">NumBooleans</dd>
                <dd id="VarArraySolutionPrinter.NumBranches" class="function">NumBranches</dd>
                <dd id="VarArraySolutionPrinter.NumConflicts" class="function">NumConflicts</dd>
                <dd id="VarArraySolutionPrinter.NumIntegerPropagations" class="function">NumIntegerPropagations</dd>
                <dd id="VarArraySolutionPrinter.ObjectiveValue" class="function">ObjectiveValue</dd>
                <dd id="VarArraySolutionPrinter.SerializedResponse" class="function">SerializedResponse</dd>
                <dd id="VarArraySolutionPrinter.SolutionBooleanValue" class="function">SolutionBooleanValue</dd>
                <dd id="VarArraySolutionPrinter.SolutionIntegerValue" class="function">SolutionIntegerValue</dd>
                <dd id="VarArraySolutionPrinter.StopSearch" class="function">StopSearch</dd>
                <dd id="VarArraySolutionPrinter.UserTime" class="function">UserTime</dd>
                <dd id="VarArraySolutionPrinter.WallTime" class="function">WallTime</dd>

            </div>
                                </dl>
                            </div>
                </section>
    </main>
</body>
</html>